//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
package creator ;import (_b "bytes";_gc "encoding/xml";_e "errors";_f "fmt";_dad "github.com/gorilla/i18n/linebreak";_ge "github.com/unidoc/unichart/render";_gfb "github.com/unidoc/unipdf/v3/common";_cc "github.com/unidoc/unipdf/v3/contentstream";_bf "github.com/unidoc/unipdf/v3/contentstream/draw";
_gd "github.com/unidoc/unipdf/v3/core";_fd "github.com/unidoc/unipdf/v3/internal/graphic2d/svg";_cb "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_fdc "github.com/unidoc/unipdf/v3/internal/license";_af "github.com/unidoc/unipdf/v3/internal/transform";
_ed "github.com/unidoc/unipdf/v3/model";_ec "golang.org/x/text/unicode/bidi";_a "image";_eb "io";_da "log";_cf "math";_gf "os";_fb "regexp";_c "sort";_ad "strconv";_de "strings";_d "text/template";_bg "unicode";);

// Invoice represents a configurable invoice template.
type Invoice struct{_cfaa string ;_ddga *Image ;_eefe *InvoiceAddress ;_gbee *InvoiceAddress ;_fcfa string ;_aafc [2]*InvoiceCell ;_defb [2]*InvoiceCell ;_beff [2]*InvoiceCell ;_ccad [][2]*InvoiceCell ;_dfdgd []*InvoiceCell ;_fafff [][]*InvoiceCell ;_abgd [2]*InvoiceCell ;
_acgc [2]*InvoiceCell ;_dgab [][2]*InvoiceCell ;_cgfce [2]string ;_eged [2]string ;_fbbb [][2]string ;_dedg TextStyle ;_edab TextStyle ;_cedg TextStyle ;_eabg TextStyle ;_fgdg TextStyle ;_ebbe TextStyle ;_fcb TextStyle ;_fffb InvoiceCellProps ;_dbff InvoiceCellProps ;
_afeb InvoiceCellProps ;_bdff InvoiceCellProps ;_gaeb Positioning ;};func (_gbcb *Creator )newPage ()*_ed .PdfPage {_afa :=_ed .NewPdfPage ();_ecbcb :=_gbcb ._dfce [0];_gaad :=_gbcb ._dfce [1];_edfe :=_ed .PdfRectangle {Llx :0,Lly :0,Urx :_ecbcb ,Ury :_gaad };
_afa .MediaBox =&_edfe ;_gbcb ._ffeg =_ecbcb ;_gbcb ._adc =_gaad ;_gbcb .initContext ();return _afa ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_fag *Creator )DrawHeader (drawHeaderFunc func (_egeg *Block ,_bcg HeaderFunctionArgs )){_fag ._fdbc =drawHeaderFunc ;};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_fafa *Image )ConvertToBinary ()error {return _fafa ._bdec .ConvertToBinary ()};

// Scale scales the ellipse dimensions by the specified factors.
func (_eaefd *Ellipse )Scale (xFactor ,yFactor float64 ){_eaefd ._efge =xFactor *_eaefd ._efge ;_eaefd ._abda =yFactor *_eaefd ._abda ;};func _bdf ()*Division {return &Division {_dffg :true }};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_cfbce *Creator )MoveTo (x ,y float64 ){_cfbce ._abe .X =x ;_cfbce ._abe .Y =y };

// SetWidthTop sets border width for top.
func (_dbc *border )SetWidthTop (bw float64 ){_dbc ._agg =bw };func (_accd *templateProcessor )run ()error {_gbbca :=_gc .NewDecoder (_b .NewReader (_accd ._dbcbe ));var _adbgb *templateNode ;for {_eeeb ,_dgagb :=_gbbca .Token ();if _dgagb !=nil {if _dgagb ==_eb .EOF {return nil ;
};return _dgagb ;};if _eeeb ==nil {break ;};_ggabb ,_gaeac :=_abebc (_gbbca );_ddba :=_gbbca .InputOffset ();switch _abgaf :=_eeeb .(type ){case _gc .StartElement :_gfb .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_abgaf .Name .Local );
_ecba ,_gddeed :=_egbd [_abgaf .Name .Local ];if !_gddeed {if _accd ._dgaga ==""{if _ggabb !=0{_gfb .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_abgaf .Name .Local ,_ggabb ,_gaeac );
}else {_gfb .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_abgaf .Name .Local ,_ddba );
};}else {if _ggabb !=0{_gfb .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_abgaf .Name .Local ,_accd ._dgaga ,_ggabb ,_gaeac );
}else {_gfb .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_abgaf .Name .Local ,_accd ._dgaga ,_ddba );
};};continue ;};_adbgb =&templateNode {_adbf :_abgaf ,_gfggb :_adbgb ,_aebgb :_ggabb ,_gbcdg :_gaeac ,_gcgb :_ddba };if _aaaab :=_ecba ._cgeb ;_aaaab !=nil {_adbgb ._cagcg ,_dgagb =_aaaab (_accd ,_adbgb );if _dgagb !=nil {return _dgagb ;};};case _gc .EndElement :_gfb .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_abgaf .Name .Local );
if _adbgb !=nil {if _adbgb ._cagcg !=nil {if _gcabc :=_accd .renderNode (_adbgb );_gcabc !=nil {return _gcabc ;};};_adbgb =_adbgb ._gfggb ;};case _gc .CharData :if _adbgb !=nil &&_adbgb ._cagcg !=nil {if _gbcbg :=_accd .addNodeText (_adbgb ,string (_abgaf ));
_gbcbg !=nil {return _gbcbg ;};};case _gc .Comment :_gfb .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_abgaf ));
};};return nil ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_faaba *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_beegc :=uint (len (_faaba ._dfdgd ));if index > _beegc {index =_beegc ;};_ddec :=_faaba .NewColumn (description );_faaba ._dfdgd =append (_faaba ._dfdgd [:index ],append ([]*InvoiceCell {_ddec },_faaba ._dfdgd [index :]...)...);
return _ddec ;};

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_aacb *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_aacb ._eedbb =dashArray ;_aacb ._deaa =dashPhase ;};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_bfdc *Ellipse )SetPositioning (position Positioning ){_bfdc ._dfda =position };func _ddfb (_cadb _a .Image )(*Image ,error ){_aegf ,_bdcdc :=_ed .ImageHandling .NewImageFromGoImage (_cadb );if _bdcdc !=nil {return nil ,_bdcdc ;};return _edcg (_aegf );
};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_cee *Chapter )SetShowNumbering (show bool ){_cee ._ccf =show ;_cee ._fdgb .SetText (_cee .headingText ());};

// Opacity returns the opacity of the line.
func (_gfgg *Line )Opacity ()float64 {return _gfgg ._efgda };

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_bgdf *Invoice )SetColumns (cols []*InvoiceCell ){_bgdf ._dfdgd =cols };

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_gfbg rune ;_gac []error ;};func (_aagbe *Invoice )newCell (_bdcc string ,_baba InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_baba ,_bdcc };};

// GetMargins returns the left, right, top, bottom Margins.
func (_dbcbc *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dbcbc ._dead .Left ,_dbcbc ._dead .Right ,_dbcbc ._dead .Top ,_dbcbc ._dead .Bottom ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//
//	[number] [title]      [separator] [page]
//
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_efdca *StyledParagraph ;_ffge []*TOCLine ;_ccggc TextStyle ;_adcec TextStyle ;_dfdfe TextStyle ;_cffeag TextStyle ;_ageg string ;_fcfdg float64 ;_cgdcf Margins ;_aadcda Positioning ;_gbagb TextStyle ;_daedd bool ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cgfde *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ecega :=ctx ;_cbcee ,ctx ,_ccdfec :=_cgfde ._fbaf .GeneratePageBlocks (ctx );if _ccdfec !=nil {return _cbcee ,ctx ,_ccdfec ;};if _cgfde ._cbffc .IsRelative (){ctx .X =_ecega .X ;
};if _cgfde ._cbffc .IsAbsolute (){return _cbcee ,_ecega ,nil ;};return _cbcee ,ctx ,nil ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_egedc *List )SetIndent (indent float64 ){_egedc ._gdfg =indent ;_egedc ._edag =false };func (_ddag *templateProcessor )parsePageBreak (_ebac *templateNode )(interface{},error ){return _agde (),nil ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_faac float64 ;_ccag float64 ;_efge float64 ;_abda float64 ;_dfda Positioning ;_fdaa Color ;_eag float64 ;_gdcga Color ;_fddf float64 ;_ddbee float64 ;_cdg Margins ;_gaeg FitMode ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};func (_gdb *Creator )setActivePage (_dabd *_ed .PdfPage ){_gdb ._eed =_dabd };


// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// SetFillOpacity sets the fill opacity of the ellipse.
func (_efe *Ellipse )SetFillOpacity (opacity float64 ){_efe ._eag =opacity };

// AddColorStop add color stop info for rendering gradient color.
func (_ebge *RadialShading )AddColorStop (color Color ,point float64 ){_ebge ._efef .AddColorStop (color ,point );};func _dbe (_gaeagd string ,_fedeg TextStyle )*Paragraph {_egfg :=&Paragraph {_bdfc :_gaeagd ,_bbcb :_fedeg .Font ,_afffc :_fedeg .FontSize ,_efbdc :1.0,_cgbcg :true ,_gbbc :true ,_ebaa :TextAlignmentLeft ,_egcg :0,_bedg :1,_ageb :1,_fadf :PositionRelative };
_egfg .SetColor (_fedeg .Color );return _egfg ;};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_cbcd *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ddcb :=ctx ;var _cgea []*Block ;_agaf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _cbcd ._fadf .IsRelative (){ctx .X +=_cbcd ._edbc .Left ;ctx .Y +=_cbcd ._edbc .Top ;
ctx .Width -=_cbcd ._edbc .Left +_cbcd ._edbc .Right ;ctx .Height -=_cbcd ._edbc .Top ;_cbcd .SetWidth (ctx .Width );if _cbcd .Height ()> ctx .Height {_cgea =append (_cgea ,_agaf );_agaf =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_fdef :=ctx ;
_fdef .Y =ctx .Margins .Top ;_fdef .X =ctx .Margins .Left +_cbcd ._edbc .Left ;_fdef .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_fdef .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cbcd ._edbc .Left -_cbcd ._edbc .Right ;
ctx =_fdef ;};}else {if int (_cbcd ._begf )<=0{_cbcd .SetWidth (_cbcd .getTextWidth ());};ctx .X =_cbcd ._acde ;ctx .Y =_cbcd ._eddg ;};ctx ,_ffggd :=_ddac (_agaf ,_cbcd ,ctx );if _ffggd !=nil {_gfb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ffggd );
return nil ,ctx ,_ffggd ;};_cgea =append (_cgea ,_agaf );if _cbcd ._fadf .IsRelative (){ctx .Y +=_cbcd ._edbc .Bottom ;ctx .Height -=_cbcd ._edbc .Bottom ;if !ctx .Inline {ctx .X =_ddcb .X ;ctx .Width =_ddcb .Width ;};return _cgea ,ctx ,nil ;};return _cgea ,_ddcb ,nil ;
};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_ebec *LinearShading )SetExtends (start bool ,end bool ){_ebec ._fded .SetExtends (start ,end )};

// TextAlignment options for paragraph.
type TextAlignment int ;

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_ggfa *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_ggfa ._gffac =halign };

// SetBorderWidth sets the border width of the ellipse.
func (_cbeaf *Ellipse )SetBorderWidth (bw float64 ){_cbeaf ._fddf =bw };

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_bfcg float64 ;_baeb float64 ;_dcbe float64 ;_adg float64 ;_egbc float64 ;_bdba float64 ;_fcadf Color ;_cgbde float64 ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_cgba *List )Width ()float64 {return 0};

// SetText sets the text content of the Paragraph.
func (_fegfc *Paragraph )SetText (text string ){_fegfc ._bdfc =text };

// Text sets the text content of the Paragraph.
func (_degg *Paragraph )Text ()string {return _degg ._bdfc };

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_dgfc *Invoice )SetNoteHeadingStyle (style TextStyle ){_dgfc ._fcb =style };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);func _daegd (_aefbe *_ed .PdfFont ,_befa float64 )*fontMetrics {_gggf :=&fontMetrics {};
if _aefbe ==nil {_gfb .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");return _gggf ;};_aafe ,_cdgfa :=_aefbe .GetFontDescriptor ();if _cdgfa !=nil {_gfb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_cdgfa );
return _gggf ;};if _gggf ._faffg ,_cdgfa =_aafe .GetCapHeight ();_cdgfa !=nil {_gfb .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_cdgfa );
};if int (_gggf ._faffg )<=0{_gfb .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_gggf ._faffg =1000;};_gggf ._faffg *=_befa /1000.0;if _gggf ._ebdef ,_cdgfa =_aafe .GetXHeight ();_cdgfa !=nil {_gfb .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_cdgfa );
};_gggf ._ebdef *=_befa /1000.0;if _gggf ._ddbda ,_cdgfa =_aafe .GetAscent ();_cdgfa !=nil {_gfb .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_cdgfa );
};_gggf ._ddbda *=_befa /1000.0;if _gggf ._ccdgd ,_cdgfa =_aafe .GetDescent ();_cdgfa !=nil {_gfb .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_cdgfa );
};_gggf ._ccdgd *=_befa /1000.0;return _gggf ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_bfcb *Image )ScaleToWidth (w float64 ){_bfbf :=_bfcb ._dafe /_bfcb ._dgfb ;_bfcb ._dgfb =w ;_bfcb ._dafe =w *_bfbf ;};

// SetLazy sets the lazy mode for the image.
func (_gcdc *Image )SetLazy (lazy bool ){_gcdc ._fcaf =lazy };func _dgeae (_ggce ,_bfeb interface{})(interface{},error ){_abbc ,_edbg :=_adecd (_ggce );if _edbg !=nil {return nil ,_edbg ;};switch _ggbbc :=_abbc .(type ){case int64 :_cgbac ,_addcc :=_adecd (_bfeb );
if _addcc !=nil {return nil ,_addcc ;};switch _gdaeg :=_cgbac .(type ){case int64 :return _ggbbc +_gdaeg ,nil ;case float64 :return float64 (_ggbbc )+_gdaeg ,nil ;};case float64 :_facdf ,_gbeac :=_adecd (_bfeb );if _gbeac !=nil {return nil ,_gbeac ;};switch _cabac :=_facdf .(type ){case int64 :return _ggbbc +float64 (_cabac ),nil ;
case float64 :return _ggbbc +_cabac ,nil ;};};return nil ,_f .Errorf ("\u0066\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0025\u0076\u0020\u0061\u006e\u0064\u0020\u0025\u0076",_ggce ,_bfeb );};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_bbed *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_bbed .Text },nil ;};var _bbecee []string ;var _gcda []rune ;var _dgdf float64 ;var _efaff []float64 ;_ebcdg :=_bbed .Style ;_abaad :=_faeef (_bbed .Text );
for _ ,_cdebdd :=range _bbed .Text {if _cdebdd =='\u000A'{_bbbac :=_ffee (string (_gcda ),_abaad );_bbecee =append (_bbecee ,_de .TrimRightFunc (_bbbac ,_bg .IsSpace )+string (_cdebdd ));_gcda =nil ;_dgdf =0;_efaff =nil ;continue ;};_dcbff :=_cdebdd ==' ';
_cfdef ,_dfdfc :=_ebcdg .Font .GetRuneMetrics (_cdebdd );if !_dfdfc {_gfb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_cdebdd ,_cdebdd ,_ebcdg .Font .BaseFont (),_ebcdg .Font .Subtype ());
_gfb .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_ebcdg .Font );_gfb .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_ebcdg .Font .Encoder ());return nil ,_e .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_dcgea :=_ebcdg .FontSize *_cfdef .Wx ;_bdbfa :=_dcgea ;if !_dcbff {_bdbfa =_dcgea +_ebcdg .CharSpacing *1000.0;};if _dgdf +_dcgea > width *1000.0{_ffbc :=-1;if !_dcbff {for _ecceb :=len (_gcda )-1;_ecceb >=0;_ecceb --{if _gcda [_ecceb ]==' '{_ffbc =_ecceb ;
break ;};};};_ebdfd :=string (_gcda );if _ffbc > 0{_ebdfd =string (_gcda [0:_ffbc +1]);_gcda =append (_gcda [_ffbc +1:],_cdebdd );_efaff =append (_efaff [_ffbc +1:],_bdbfa );_dgdf =0;for _ ,_cdecg :=range _efaff {_dgdf +=_cdecg ;};}else {if _dcbff {_gcda =[]rune {};
_efaff =[]float64 {};_dgdf =0;}else {_gcda =[]rune {_cdebdd };_efaff =[]float64 {_bdbfa };_dgdf =_bdbfa ;};};_ebdfd =_ffee (_ebdfd ,_abaad );_bbecee =append (_bbecee ,_de .TrimRightFunc (_ebdfd ,_bg .IsSpace ));}else {_gcda =append (_gcda ,_cdebdd );_dgdf +=_bdbfa ;
_efaff =append (_efaff ,_bdbfa );};};if len (_gcda )> 0{_ggfda :=string (_gcda );_ggfda =_ffee (_ggfda ,_abaad );_bbecee =append (_bbecee ,_ggfda );};return _bbecee ,nil ;};func (_cebb *Paragraph )getMaxLineWidth ()float64 {if _cebb ._baeba ==nil ||len (_cebb ._baeba )==0{_cebb .wrapText ();
};var _gccbc float64 ;for _ ,_cfac :=range _cebb ._baeba {_fgefb :=_cebb .getTextLineWidth (_cfac );if _fgefb > _gccbc {_gccbc =_fgefb ;};};return _gccbc ;};

// NewDivision returns a new Division container component.
func (_eecde *Creator )NewDivision ()*Division {return _bdf ()};type grayColor struct{_faf float64 };

// NewChapter creates a new chapter with the specified title as the heading.
func (_bdcf *Creator )NewChapter (title string )*Chapter {_bdcf ._ecbc ++;_cgff :=_bdcf .NewTextStyle ();_cgff .FontSize =16;return _gdf (nil ,_bdcf ._dcag ,_bdcf ._dccf ,title ,_bdcf ._ecbc ,_cgff );};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_dgbf *Creator )SetForms (form *_ed .PdfAcroForm )error {_dgbf ._fgda =form ;return nil };func _geae (_dcbd []_bf .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_cgfd :&_bf .PolyBezierCurve {Curves :_dcbd ,BorderColor :_ed .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_daab :1.0,_fbfd :1.0};
};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_dfaf *Creator )SetPageLabels (pageLabels _gd .PdfObject ){_dfaf ._fega =pageLabels };

// SkipOver skips over a specified number of rows and cols.
func (_fdda *Table )SkipOver (rows ,cols int ){_dggg :=rows *_fdda ._dfeg +cols -1;if _dggg < 0{_gfb .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _dffe :=0;_dffe < _dggg ;_dffe ++{_fdda .NewCell ();};};

// SetLineWidth sets the line width.
func (_dbac *Polyline )SetLineWidth (lineWidth float64 ){_dbac ._daag .LineWidth =lineWidth };

// Scale block by specified factors in the x and y directions.
func (_cd *Block )Scale (sx ,sy float64 ){_fdb :=_cc .NewContentCreator ().Scale (sx ,sy ).Operations ();*_cd ._ebg =append (*_fdb ,*_cd ._ebg ...);_cd ._ebg .WrapIfNeeded ();_cd ._bc *=sx ;_cd ._ag *=sy ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_baaf *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gdfd :=ctx ;var _ecgg []*Block ;_cggcd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _baaf ._cbgac .IsRelative (){ctx .X +=_baaf ._acbfg .Left ;ctx .Y +=_baaf ._acbfg .Top ;
ctx .Width -=_baaf ._acbfg .Left +_baaf ._acbfg .Right ;ctx .Height -=_baaf ._acbfg .Top ;_baaf .SetWidth (ctx .Width );}else {if int (_baaf ._bcdba )<=0{_baaf .SetWidth (_baaf .getTextWidth ()/1000.0);};ctx .X =_baaf ._fdbg ;ctx .Y =_baaf ._ccac ;};if _baaf ._abdc !=nil {_baaf ._abdc (_baaf ,ctx );
};if _agbgb :=_baaf .wrapText ();_agbgb !=nil {return nil ,ctx ,_agbgb ;};_ddfba :=_baaf ._feab ;_acdc :=0;for {_dggc ,_gbgf ,_bfgd :=_dabcb (_cggcd ,_baaf ,_ddfba ,ctx );if _bfgd !=nil {_gfb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bfgd );
return nil ,ctx ,_bfgd ;};ctx =_dggc ;_ecgg =append (_ecgg ,_cggcd );if _ddfba =_gbgf ;len (_gbgf )==0{break ;};if len (_gbgf )==_acdc {return nil ,ctx ,_e .New ("\u006e\u006f\u0074\u0020\u0065\u006e\u006f\u0075\u0067\u0068 \u0073\u0070\u0061\u0063\u0065\u0020\u0066o\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068");
};_cggcd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dggc =ctx ;_dggc .Y =ctx .Margins .Top ;_dggc .X =ctx .Margins .Left +_baaf ._acbfg .Left ;_dggc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_dggc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_baaf ._acbfg .Left -_baaf ._acbfg .Right ;
ctx =_dggc ;_acdc =len (_gbgf );};if _baaf ._cbgac .IsRelative (){ctx .Y +=_baaf ._acbfg .Bottom ;ctx .Height -=_baaf ._acbfg .Bottom ;if !ctx .Inline {ctx .X =_gdfd .X ;ctx .Width =_gdfd .Width ;};return _ecgg ,ctx ,nil ;};return _ecgg ,_gdfd ,nil ;};


// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_ead *Block )Draw (d Drawable )error {_fed :=DrawContext {};_fed .Width =_ead ._bc ;_fed .Height =_ead ._ag ;_fed .PageWidth =_ead ._bc ;_fed .PageHeight =_ead ._ag ;_fed .X =0;_fed .Y =0;_ebb ,_ ,_cda :=d .GeneratePageBlocks (_fed );if _cda !=nil {return _cda ;
};if len (_ebb )!=1{return ErrContentNotFit ;};for _ ,_eec :=range _ebb {if _cdd :=_ead .mergeBlocks (_eec );_cdd !=nil {return _cdd ;};};return nil ;};func _cbgc (_aacd *Block ,_efdg *Image ,_bacc DrawContext )(DrawContext ,error ){_gegg :=_bacc ;_beeg :=1;
_gfbaa :=_gd .PdfObjectName (_f .Sprintf ("\u0049\u006d\u0067%\u0064",_beeg ));for _aacd ._ece .HasXObjectByName (_gfbaa ){_beeg ++;_gfbaa =_gd .PdfObjectName (_f .Sprintf ("\u0049\u006d\u0067%\u0064",_beeg ));};_eacff :=_aacd ._ece .SetXObjectImageByNameLazy (_gfbaa ,_efdg ._abga ,_efdg ._fcaf );
if _eacff !=nil {return _bacc ,_eacff ;};_cgfc :=0;_cbdd :=_gd .PdfObjectName (_f .Sprintf ("\u0047\u0053\u0025\u0064",_cgfc ));for _aacd ._ece .HasExtGState (_cbdd ){_cgfc ++;_cbdd =_gd .PdfObjectName (_f .Sprintf ("\u0047\u0053\u0025\u0064",_cgfc ));
};_edgbc :=_gd .MakeDict ();_edgbc .Set ("\u0042\u004d",_gd .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _efdg ._deeeg < 1.0{_edgbc .Set ("\u0043\u0041",_gd .MakeFloat (_efdg ._deeeg ));_edgbc .Set ("\u0063\u0061",_gd .MakeFloat (_efdg ._deeeg ));
};_eacff =_aacd ._ece .AddExtGState (_cbdd ,_gd .MakeIndirectObject (_edgbc ));if _eacff !=nil {return _bacc ,_eacff ;};_afdd :=_efdg .Width ();_adbcg :=_efdg .Height ();_ ,_agad :=_efdg .rotatedSize ();_efee :=_bacc .X ;_bagd :=_bacc .PageHeight -_bacc .Y -_adbcg ;
if _efdg ._eecdg .IsRelative (){_bagd -=(_agad -_adbcg )/2;switch _efdg ._aabe {case HorizontalAlignmentCenter :_efee +=(_bacc .Width -_afdd )/2;case HorizontalAlignmentRight :_efee =_bacc .PageWidth -_bacc .Margins .Right -_efdg ._ceaa .Right -_afdd ;
};};_acgg :=_efdg ._eadd ;_edaa :=_cc .NewContentCreator ();_edaa .Add_gs (_cbdd );_edaa .Translate (_efee ,_bagd );if _acgg !=0{_edaa .Translate (_afdd /2,_adbcg /2);_edaa .RotateDeg (_acgg );_edaa .Translate (-_afdd /2,-_adbcg /2);};_edaa .Scale (_afdd ,_adbcg ).Add_Do (_gfbaa );
_agaa :=_edaa .Operations ();_agaa .WrapIfNeeded ();_aacd .addContents (_agaa );if _efdg ._eecdg .IsRelative (){_bacc .Y +=_agad ;_bacc .Height -=_agad ;return _bacc ,nil ;};return _gegg ,nil ;};

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_fddd *GraphicSVG )ScaleToWidth (w float64 ){_edba :=_fddd ._caga .Height /_fddd ._caga .Width ;_fddd ._caga .Width =w ;_fddd ._caga .Height =w *_edba ;_fddd ._caga .SetScaling (_edba ,_edba );};

// SetWidth sets line width.
func (_acac *Curve )SetWidth (width float64 ){_acac ._cgbde =width };

// SetBorderRadius sets the radius of the rectangle corners.
func (_beba *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_beba ._gbda =topLeft ;_beba ._gaebc =topRight ;_beba ._ecga =bottomLeft ;_beba ._cbca =bottomRight ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_bbbg int ;_ggf string ;_fdgb *Paragraph ;_age []Drawable ;_ecab int ;_ccf bool ;_adde bool ;_agbf Positioning ;_dce ,_feec float64 ;_ggda Margins ;_bef *Chapter ;_dfgd *TOC ;_gbc *_ed .Outline ;_dcg *_ed .OutlineItem ;_fce uint ;};
func (_dgcg *Invoice )generateNoteBlocks (_dceb DrawContext )([]*Block ,DrawContext ,error ){_ecabg :=_bdf ();_fgebe :=append ([][2]string {_dgcg ._cgfce ,_dgcg ._eged },_dgcg ._fbbb ...);for _ ,_eccg :=range _fgebe {if _eccg [1]!=""{_bdbf :=_dgcg .drawSection (_eccg [0],_eccg [1]);
for _ ,_bbde :=range _bdbf {_ecabg .Add (_bbde );};_fegf :=_cfeea (_dgcg ._dedg );_fegf .SetMargins (0,0,10,0);_ecabg .Add (_fegf );};};return _ecabg .GeneratePageBlocks (_dceb );};func (_cdgd *templateProcessor )parseStyledParagraph (_gdgdg *templateNode )(interface{},error ){_fcba :=_cdgd .creator .NewStyledParagraph ();
for _ ,_cged :=range _gdgdg ._adbf .Attr {_abcfg :=_cged .Value ;switch _cafga :=_cged .Name .Local ;_cafga {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_fcba .SetTextAlignment (_cdgd .parseTextAlignmentAttr (_cafga ,_abcfg ));case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_fcba .SetTextVerticalAlignment (_cdgd .parseTextVerticalAlignmentAttr (_cafga ,_abcfg ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_fcba .SetLineHeight (_cdgd .parseFloatAttr (_cafga ,_abcfg ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ddgbd :=_cdgd .parseMarginAttr (_cafga ,_abcfg );_fcba .SetMargins (_ddgbd .Left ,_ddgbd .Right ,_ddgbd .Top ,_ddgbd .Bottom );
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_fcba .SetEnableWrap (_cdgd .parseBoolAttr (_cafga ,_abcfg ));case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_fcba .EnableWordWrap (_cdgd .parseBoolAttr (_cafga ,_abcfg ));
case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_fcba .SetTextOverflow (_cdgd .parseTextOverflowAttr (_cafga ,_abcfg ));case "\u0078":_fcba .SetPos (_cdgd .parseFloatAttr (_cafga ,_abcfg ),_fcba ._ccac );case "\u0079":_fcba .SetPos (_fcba ._fdbg ,_cdgd .parseFloatAttr (_cafga ,_abcfg ));
case "\u0061\u006e\u0067l\u0065":_fcba .SetAngle (_cdgd .parseFloatAttr (_cafga ,_abcfg ));default:_cdgd .nodeLogDebug (_gdgdg ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cafga );
};};return _fcba ,nil ;};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_dcba *Creator )SetOutlineTree (outlineTree *_ed .PdfOutlineTreeNode ){_dcba ._agcag =outlineTree };func (_gbeec *templateProcessor )parseColor (_cdddg string )Color {if _cdddg ==""{return nil ;};_gbddeg ,_cfcdgd :=_gbeec ._bfega .ColorMap [_cdddg ];
if _cfcdgd {return _gbddeg ;};if _cdddg [0]=='#'{return ColorRGBFromHex (_cdddg );};return nil ;};type componentRenderer interface{Draw (_bfgg Drawable )error ;};var PPI float64 =72;func (_gcabd *templateProcessor )parseLinkAttr (_fddcg ,_affa string )*_ed .PdfAnnotation {_affa =_de .TrimSpace (_affa );
if _de .HasPrefix (_affa ,"\u0075\u0072\u006c(\u0027")&&_de .HasSuffix (_affa ,"\u0027\u0029")&&len (_affa )> 7{return _cgcg (_affa [5:len (_affa )-2]);};if _de .HasPrefix (_affa ,"\u0070\u0061\u0067e\u0028")&&_de .HasSuffix (_affa ,"\u0029")&&len (_affa )> 6{var (_aacag error ;
_ecgdg int64 ;_bdae float64 ;_baca float64 ;_fcgd =1.0;_gddba =_de .Split (_affa [5:len (_affa )-1],"\u002c"););_ecgdg ,_aacag =_ad .ParseInt (_de .TrimSpace (_gddba [0]),10,64);if _aacag !=nil {_gfb .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_aacag );
return nil ;};if len (_gddba )>=2{_bdae ,_aacag =_ad .ParseFloat (_de .TrimSpace (_gddba [1]),64);if _aacag !=nil {_gfb .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_aacag );
return nil ;};};if len (_gddba )>=3{_baca ,_aacag =_ad .ParseFloat (_de .TrimSpace (_gddba [2]),64);if _aacag !=nil {_gfb .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_aacag );
return nil ;};};if len (_gddba )>=4{_fcgd ,_aacag =_ad .ParseFloat (_de .TrimSpace (_gddba [3]),64);if _aacag !=nil {_gfb .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_aacag );
return nil ;};};return _bfee (_ecgdg -1,_bdae ,_baca ,_fcgd );};return nil ;};

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_fccd *Rectangle )FillOpacity ()float64 {return _fccd ._efgb };

// SetMargins sets the Paragraph's margins.
func (_cdcc *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_cdcc ._acbfg .Left =left ;_cdcc ._acbfg .Right =right ;_cdcc ._acbfg .Top =top ;_cdcc ._acbfg .Bottom =bottom ;};

// AddTotalLine adds a new line in the invoice totals table.
func (_cccc *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_cbed :=&InvoiceCell {_cccc ._bdff ,desc };_eafd :=&InvoiceCell {_cccc ._bdff ,value };_cccc ._dgab =append (_cccc ._dgab ,[2]*InvoiceCell {_cbed ,_eafd });return _cbed ,_eafd ;
};func _bdaeb (_cdbgbc *_ed .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_cdbgbc ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;);

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//
//	red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_gbdd :float64 (r )/255.0,_bffe :float64 (g )/255.0,_dgdd :float64 (b )/255.0};};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// NewInvoice returns an instance of an empty invoice.
func (_cfef *Creator )NewInvoice ()*Invoice {_fgf :=_cfef .NewTextStyle ();_fgf .Font =_cfef ._efae ;return _cdec (_cfef .NewTextStyle (),_fgf );};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_agba *Creator )MoveDown (dy float64 ){_agba ._abe .Y +=dy };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_caagf *TOC )SetLineSeparatorStyle (style TextStyle ){_caagf ._dfdfe =style };

// SetFillOpacity sets the fill opacity.
func (_bffc *CurvePolygon )SetFillOpacity (opacity float64 ){_bffc ._egfd =opacity };

// Padding returns the padding of the component.
func (_bgfc *Division )Padding ()(_ebee ,_gagb ,_abbe ,_fdgaa float64 ){return _bgfc ._babd .Left ,_bgfc ._babd .Right ,_bgfc ._babd .Top ,_bgfc ._babd .Bottom ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// Title returns the title of the invoice.
func (_abdae *Invoice )Title ()string {return _abdae ._cfaa };

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_ecea *Creator )RotateDeg (angleDeg int64 )error {_cbe :=_ecea .getActivePage ();if _cbe ==nil {_gfb .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _e .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_gfb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _faeg int64 ;if _cbe .Rotate !=nil {_faeg =*(_cbe .Rotate );};_faeg +=angleDeg ;_cbe .Rotate =&_faeg ;return nil ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_cage *Image )SetPos (x ,y float64 ){_cage ._eecdg =PositionAbsolute ;_cage ._abeg =x ;_cage ._cggeb =y ;};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// Height returns the height of the line.
func (_gfac *Line )Height ()float64 {_gafe :=_gfac ._cdff ;if _gfac ._dffgg ==_gfac ._fbfbg {_gafe /=2;};return _cf .Abs (_gfac ._dbd -_gfac ._acad )+_gafe ;};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_bcbd *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bcbd ._accae .Left ,_bcbd ._accae .Right ,_bcbd ._accae .Top ,_bcbd ._accae .Bottom ;};

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_dbgfc *Ellipse )ScaleToHeight (h float64 ){_gbbd :=_dbgfc ._efge /_dbgfc ._abda ;_dbgfc ._abda =h ;_dbgfc ._efge =h *_gbbd ;};func _fdgc (_bggb _ge .ChartRenderable )*Chart {return &Chart {_ddge :_bggb ,_gbea :PositionRelative ,_bfa :Margins {Top :10,Bottom :10}};
};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_egged int ;_dfeg int ;_dcef int ;_dbeeb []float64 ;_eegf []float64 ;_fgac float64 ;_cfcdg []*TableCell ;_agdgb []int ;_fafag Positioning ;_bgbcd ,_adedc float64 ;_dead Margins ;_befce bool ;_bdcdfg int ;_feac int ;_egegc bool ;_efbed bool ;
_gdad bool ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_ebbb *Creator )DrawFooter (drawFooterFunc func (_gfef *Block ,_cfdd FooterFunctionArgs )){_ebbb ._adff =drawFooterFunc ;};

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_eabfg *Rectangle )SetFitMode (fitMode FitMode ){_eabfg ._gfag =fitMode };type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_fede Drawable )(Drawable ,error );};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_dag :_cf .Max (_cf .Min (c ,1.0),0.0),_acg :_cf .Max (_cf .Min (m ,1.0),0.0),_befc :_cf .Max (_cf .Min (y ,1.0),0.0),_dgde :_cf .Max (_cf .Min (k ,1.0),0.0)};};func (_fcec *List )markerWidth ()float64 {var _fecc float64 ;
for _ ,_dbca :=range _fcec ._gaegd {_abegd :=_cfeea (_fcec ._aaagc );_abegd .SetEnableWrap (false );_abegd .SetTextAlignment (TextAlignmentRight );_abegd .Append (_dbca ._afdbb .Text ).Style =_dbca ._afdbb .Style ;_cbdc :=_abegd .getTextWidth ()/1000.0;
if _fecc < _cbdc {_fecc =_cbdc ;};};return _fecc ;};

// SetTitle sets the title of the invoice.
func (_cafb *Invoice )SetTitle (title string ){_cafb ._cfaa =title };func _cabd (_egecd ,_ffgcd ,_dgff ,_bbda float64 )*Line {return &Line {_dffgg :_egecd ,_acad :_ffgcd ,_fbfbg :_dgff ,_dbd :_bbda ,_cdba :ColorBlack ,_efgda :1.0,_cdff :1.0,_eedbb :[]int64 {1,1},_edec :PositionAbsolute };
};

// SetBorderOpacity sets the border opacity of the rectangle.
func (_abee *Rectangle )SetBorderOpacity (opacity float64 ){_abee ._fgbf =opacity };

// Positioning returns the type of positioning the rectangle is set to use.
func (_bgbc *Rectangle )Positioning ()Positioning {return _bgbc ._dffd };

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_fbgga *Rectangle )ScaleToWidth (w float64 ){_cgfgc :=_fbgga ._ggbab /_fbgga ._cegcg ;_fbgga ._cegcg =w ;_fbgga ._ggbab =w *_cgfgc ;};func _cdcbe (_eegc *templateProcessor ,_ddeea *templateNode )(interface{},error ){return _eegc .parseStyledParagraph (_ddeea );
};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_abedbd *Invoice )TotalLines ()[][2]*InvoiceCell {_gagd :=[][2]*InvoiceCell {_abedbd ._abgd };_gagd =append (_gagd ,_abedbd ._dgab ...);return append (_gagd ,_abedbd ._acgc );};

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_gdbb *Creator )Flip (flipH ,flipV bool )error {_ggab :=_gdbb .getActivePage ();if _ggab ==nil {return _e .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_ebed ,_dface :=_gdbb ._cgf [_ggab ];if !_dface {_ebed =&pageTransformations {};
_gdbb ._cgf [_ggab ]=_ebed ;};_ebed ._gcgc =flipH ;_ebed ._bbce =flipV ;return nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cdae *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _edga float64 ;var _ddecd []*StyledParagraph ;for _ ,_geafc :=range _cdae ._gaegd {_ggba :=_cfeea (_cdae ._aaagc );_ggba .SetEnableWrap (false );_ggba .SetTextAlignment (TextAlignmentRight );
_ggba .Append (_geafc ._afdbb .Text ).Style =_geafc ._afdbb .Style ;_aadgf :=_ggba .getTextWidth ()/1000.0/ctx .Width ;if _edga < _aadgf {_edga =_aadgf ;};_ddecd =append (_ddecd ,_ggba );};_gffea :=_gegfb (2);_gffea .SetColumnWidths (_edga ,1-_edga );_gffea .SetMargins (_cdae ._afded .Left +_cdae ._gdfg ,_cdae ._afded .Right ,_cdae ._afded .Top ,_cdae ._afded .Bottom );
_gffea .EnableRowWrap (true );for _fdgae ,_dgbe :=range _cdae ._gaegd {_bcde :=_gffea .NewCell ();_bcde .SetIndent (0);_bcde .SetContent (_ddecd [_fdgae ]);_bcde =_gffea .NewCell ();_bcde .SetIndent (0);_bcde .SetContent (_dgbe ._cbgb );};return _gffea .GeneratePageBlocks (ctx );
};

// SetLineOpacity sets the line opacity.
func (_bgec *Polyline )SetLineOpacity (opacity float64 ){_bgec ._gcaa =opacity };

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};func (_ced *Block )drawToPage (_feg *_ed .PdfPage )error {_bede :=&_cc .ContentStreamOperations {};if _feg .Resources ==nil {_feg .Resources =_ed .NewPdfPageResources ();};_bae :=_ffe (_bede ,_feg .Resources ,_ced ._ebg ,_ced ._ece );
if _bae !=nil {return _bae ;};if _bae =_afc (_ced ._ece ,_feg .Resources );_bae !=nil {return _bae ;};if _bae =_feg .AppendContentBytes (_bede .Bytes (),true );_bae !=nil {return _bae ;};for _ ,_gec :=range _ced ._ba {_feg .AddAnnotation (_gec );};return nil ;
};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_fbfb *Division )Add (d VectorDrawable )error {switch _bbdb :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_cdfb ,_ecgca :=_bbdb .ContainerComponent (_fbfb );
if _ecgca !=nil {return _ecgca ;};_effd ,_befb :=_cdfb .(VectorDrawable );if !_befb {return _f .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_cdfb );
};d =_effd ;default:return _e .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_fbfb ._ggcc =append (_fbfb ._ggcc ,d );return nil ;};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_gcd :=&Block {};_gcd ._ebg =&_cc .ContentStreamOperations {};_gcd ._ece =_ed .NewPdfPageResources ();_gcd ._bc =width ;_gcd ._ag =height ;return _gcd ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_fgdd []*_ed .PdfPage ;_dddac map[*_ed .PdfPage ]*Block ;_cgf map[*_ed .PdfPage ]*pageTransformations ;_eed *_ed .PdfPage ;_dfce PageSize ;_abe DrawContext ;_ggeg Margins ;_ffeg ,_adc float64 ;_ecbc int ;_fcc func (_daac FrontpageFunctionArgs );
_acee func (_adda *TOC )error ;_fdbc func (_gaae *Block ,_dga HeaderFunctionArgs );_adff func (_fcf *Block ,_bgb FooterFunctionArgs );_cgbd func (_bbgg PageFinalizeFunctionArgs )error ;_cfd func (_fba *_ed .PdfWriter )error ;_aded bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_dcag *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_dccf *_ed .Outline ;_agcag *_ed .PdfOutlineTreeNode ;_fgda *_ed .PdfAcroForm ;_fega _gd .PdfObject ;_affc _ed .Optimizer ;_eac []*_ed .PdfFont ;_egc *_ed .PdfFont ;_efae *_ed .PdfFont ;};

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_efbe *GraphicSVG )ScaleToHeight (h float64 ){_fggeb :=_efbe ._caga .Width /_efbe ._caga .Height ;_efbe ._caga .Height =h ;_efbe ._caga .Width =h *_fggeb ;_efbe ._caga .SetScaling (_fggeb ,_fggeb );};

// GetCoords returns coordinates of border.
func (_cceb *border )GetCoords ()(float64 ,float64 ){return _cceb ._dgd ,_cceb ._bce };

// ColorGrayFromHex converts color hex code to gray color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ff -> white.
func ColorGrayFromHex (hexStr string )Color {_ggbe :=grayColor {};if (len (hexStr )!=2&&len (hexStr )!=3)||hexStr [0]!='#'{_gfb .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ggbe ;
};var _cgbcf int ;if len (hexStr )==2{var _dgb int ;_geaf ,_gaf :=_f .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078",&_dgb );if _gaf !=nil {_gfb .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_gaf );
return _ggbe ;};if _geaf !=1{_gfb .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ggbe ;};_cgbcf =_dgb *16+_dgb ;}else {_bffd ,_ddf :=_f .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078",&_cgbcf );
if _ddf !=nil {_gfb .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ggbe ;};if _bffd !=1{_gfb .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_bffd );
return _ggbe ;};};_ggbe ._faf =float64 (_cgbcf )/255.0;return _ggbe ;};func (_ffcbf *StyledParagraph )getTextHeight ()float64 {var _dcdag float64 ;for _ ,_cbddg :=range _ffcbf ._fcdf {_faag :=_cbddg .Style .FontSize *_ffcbf ._agcdg ;if _faag > _dcdag {_dcdag =_faag ;
};};return _dcdag ;};

// Crop crops the Image to the specified bounds.
func (_ccfc *Image )Crop (x0 ,y0 ,x1 ,y1 int ){_deca ,_dfdee :=_ccfc ._bdec .ToGoImage ();if _dfdee !=nil {_da .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0074o\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_dfdee );
};var _cbcf _a .Image ;_cafda :=_a .Rect (x0 ,y0 ,x1 ,y1 );if _bbe :=_cafda .Intersect (_deca .Bounds ());!_cafda .Empty (){_ecaa :=_a .NewRGBA (_a .Rect (0,0,_cafda .Dx (),_cafda .Dy ()));for _gcec :=_bbe .Min .Y ;_gcec < _bbe .Max .Y ;_gcec ++{for _acca :=_bbe .Min .X ;
_acca < _bbe .Max .X ;_acca ++{_ecaa .Set (_acca -_bbe .Min .X ,_gcec -_bbe .Min .Y ,_deca .At (_acca ,_gcec ));};};_cbcf =_ecaa ;}else {_cbcf =&_a .RGBA {};};_ebeg ,_dfdee :=_ed .ImageHandling .NewImageFromGoImage (_cbcf );if _dfdee !=nil {_da .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0066\u0072\u006fm\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_dfdee );
};_ecbe :=float64 (_ebeg .Width );_eacaa :=float64 (_ebeg .Height );_ccfc ._bdec =_ebeg ;_ccfc ._dddd =_ecbe ;_ccfc ._egbcd =_eacaa ;_ccfc ._dgfb =_ecbe ;_ccfc ._dafe =_eacaa ;};

// SetWidthLeft sets border width for left.
func (_aga *border )SetWidthLeft (bw float64 ){_aga ._eddf =bw };

// NewFilledCurve returns a instance of filled curve.
func (_afg *Creator )NewFilledCurve ()*FilledCurve {return _dfea ()};

// Lines returns all the rows of the invoice line items table.
func (_aafg *Invoice )Lines ()[][]*InvoiceCell {return _aafg ._fafff };

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_bceg *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_bceg ._ggcfg =&_ed .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};func _bddfd (_dbeg [][]_bf .Point )*Polygon {return &Polygon {_bdcee :&_bf .Polygon {Points :_dbeg },_cagc :1.0,_beac :1.0};
};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_dggae *TOC )SetLineLevelOffset (levelOffset float64 ){_dggae ._fcfdg =levelOffset };

// SetPositioning sets the positioning of the line (absolute or relative).
func (_eefea *Line )SetPositioning (positioning Positioning ){_eefea ._edec =positioning };

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_fdaace *Image )ScaleToHeight (h float64 ){_dddf :=_fdaace ._dgfb /_fdaace ._dafe ;_fdaace ._dafe =h ;_fdaace ._dgfb =h *_dddf ;};

// SetFillOpacity sets the fill opacity of the rectangle.
func (_fefd *Rectangle )SetFillOpacity (opacity float64 ){_fefd ._efgb =opacity };

// SetHeight sets the height of the rectangle.
func (_cfea *Rectangle )SetHeight (height float64 ){_cfea ._ggbab =height };

// SetWidthRight sets border width for right.
func (_eda *border )SetWidthRight (bw float64 ){_eda ._ecac =bw };func _efacg (_baaa ,_eaeg ,_egdf ,_edece float64 )*Rectangle {return &Rectangle {_gadgc :_baaa ,_adac :_eaeg ,_cegcg :_egdf ,_ggbab :_edece ,_dffd :PositionAbsolute ,_efgb :1.0,_feea :ColorBlack ,_cfdf :1.0,_fgbf :1.0};
};func _gdf (_cdbg *Chapter ,_efc *TOC ,_faa *_ed .Outline ,_dacd string ,_gfba int ,_cga TextStyle )*Chapter {var _geed uint =1;if _cdbg !=nil {_geed =_cdbg ._fce +1;};_gdd :=&Chapter {_bbbg :_gfba ,_ggf :_dacd ,_ccf :true ,_adde :true ,_bef :_cdbg ,_dfgd :_efc ,_gbc :_faa ,_age :[]Drawable {},_fce :_geed };
_gga :=_dbe (_gdd .headingText (),_cga );_gga .SetFont (_cga .Font );_gga .SetFontSize (_cga .FontSize );_gdd ._fdgb =_gga ;return _gdd ;};

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_efef *shading ;_becbb *_ed .PdfRectangle ;_bagda AnchorPoint ;_caeg float64 ;_defbd float64 ;_cegbd float64 ;_adfa float64 ;};

// SetBorderOpacity sets the border opacity.
func (_faebc *Polygon )SetBorderOpacity (opacity float64 ){_faebc ._beac =opacity };

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_fbba *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _efacg (x ,y ,width ,height );};func (_egce *templateProcessor )parseRadialGradientAttr (creator *Creator ,_acaga string )Color {_ceggd :=ColorBlack ;if _acaga ==""{return _ceggd ;
};var (_adaaa error ;_dgbeg =0.0;_fedda =0.0;_dfdcd =-1.0;_babe =_de .Split (_acaga [16:len (_acaga )-1],"\u002c"););_cdegg :=_de .Fields (_babe [0]);if len (_cdegg )==2&&_de .TrimSpace (_cdegg [0])[0]!='#'{_dgbeg ,_adaaa =_ad .ParseFloat (_cdegg [0],64);
if _adaaa !=nil {_gfb .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_adaaa );
};_fedda ,_adaaa =_ad .ParseFloat (_cdegg [1],64);if _adaaa !=nil {_gfb .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_adaaa );
};_babe =_babe [1:];};_dgfg :=_de .TrimSpace (_babe [0]);if _dgfg [0]!='#'{_dfdcd ,_adaaa =_ad .ParseFloat (_dgfg ,64);if _adaaa !=nil {_gfb .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_adaaa );
};_babe =_babe [1:];};_cebcf ,_fdbad :=_egce .processGradientColorPair (_babe );if _cebcf ==nil ||_fdbad ==nil {return _ceggd ;};_bada :=creator .NewRadialGradientColor (_dgbeg ,_fedda ,0,_dfdcd ,[]*ColorPoint {});for _bbgdg :=0;_bbgdg < len (_cebcf );
_bbgdg ++{_bada .AddColorStop (_cebcf [_bbgdg ],_fdbad [_bbgdg ]);};return _bada ;};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_baffc *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};func _agef (_bgba *templateProcessor ,_gegb *templateNode )(interface{},error ){return _bgba .parseImage (_gegb );};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_eefeb *_ed .PdfAnnotation ;_egae bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;};

// AddSection adds a new content section at the end of the invoice.
func (_bbfb *Invoice )AddSection (title ,content string ){_bbfb ._fbbb =append (_bbfb ._fbbb ,[2]string {title ,content });};

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_facd *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _gfee (x ,y ,innerRadius ,outerRadius ,colorPoints );};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_daee *Ellipse )BorderOpacity ()float64 {return _daee ._ddbee };

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_caca *Division )Height ()float64 {var _dfae float64 ;for _ ,_ebebg :=range _caca ._ggcc {switch _dde :=_ebebg .(type ){case marginDrawable :_ ,_ ,_dgbfa ,_dcbb :=_dde .GetMargins ();_dfae +=_dde .Height ()+_dgbfa +_dcbb ;default:_dfae +=_dde .Height ();
};};return _dfae ;};

// SetWidthBottom sets border width for bottom.
func (_fde *border )SetWidthBottom (bw float64 ){_fde ._cfc =bw };

// SetBorderColor sets the border color of the ellipse.
func (_egfee *Ellipse )SetBorderColor (col Color ){_egfee ._gdcga =col };

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_dfdbc *LinearShading )SetAntiAlias (enable bool ){_dfdbc ._fded .SetAntiAlias (enable )};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_eedb *Creator )Draw (d Drawable )error {if _eedb .getActivePage ()==nil {_eedb .NewPage ();};_ecebc ,_fgdf ,_egfb :=d .GeneratePageBlocks (_eedb ._abe );if _egfb !=nil {return _egfb ;};if len (_fgdf ._gac )> 0{_eedb .Errors =append (_eedb .Errors ,_fgdf ._gac ...);
};for _cbab ,_cafd :=range _ecebc {if _cbab > 0{_eedb .NewPage ();};_gag :=_eedb .getActivePage ();if _cfbd ,_afde :=_eedb ._dddac [_gag ];_afde {if _fdag :=_cfbd .mergeBlocks (_cafd );_fdag !=nil {return _fdag ;};if _ccg :=_afc (_cafd ._ece ,_cfbd ._ece );
_ccg !=nil {return _ccg ;};}else {_eedb ._dddac [_gag ]=_cafd ;};};_eedb ._abe .X =_fgdf .X ;_eedb ._abe .Y =_fgdf .Y ;_eedb ._abe .Height =_fgdf .PageHeight -_fgdf .Y -_fgdf .Margins .Bottom ;return nil ;};

// Append adds a new text chunk to the paragraph.
func (_gdbbe *StyledParagraph )Append (text string )*TextChunk {_ddbg :=NewTextChunk (text ,_gdbbe ._beafc );return _gdbbe .appendChunk (_ddbg );};func (_dfef *Paragraph )wrapText ()error {if !_dfef ._cgbcg ||int (_dfef ._begf )<=0{_dfef ._baeba =[]string {_dfef ._bdfc };
return nil ;};_gebg :=NewTextChunk (_dfef ._bdfc ,TextStyle {Font :_dfef ._bbcb ,FontSize :_dfef ._afffc });_gcgf ,_cace :=_gebg .Wrap (_dfef ._begf );if _cace !=nil {return _cace ;};if _dfef ._agbafd > 0&&len (_gcgf )> _dfef ._agbafd {_gcgf =_gcgf [:_dfef ._agbafd ];
};_dfef ._baeba =_gcgf ;return nil ;};func _bbcbd (_ecgaf *Table ,_dadee DrawContext )([]*Block ,DrawContext ,error ){var _bgdeg []*Block ;_ebfgf :=NewBlock (_dadee .PageWidth ,_dadee .PageHeight );_ecgaf .updateRowHeights (_dadee .Width -_ecgaf ._dead .Left -_ecgaf ._dead .Right );
_eefg :=_ecgaf ._dead .Top ;if _ecgaf ._fafag .IsRelative ()&&!_ecgaf ._efbed {_aggcb :=_ecgaf .Height ();if _aggcb > _dadee .Height -_ecgaf ._dead .Top &&_aggcb <=_dadee .PageHeight -_dadee .Margins .Top -_dadee .Margins .Bottom {_bgdeg =[]*Block {NewBlock (_dadee .PageWidth ,_dadee .PageHeight -_dadee .Y )};
var _fcfac error ;if _ ,_dadee ,_fcfac =_agde ().GeneratePageBlocks (_dadee );_fcfac !=nil {return nil ,_dadee ,_fcfac ;};_eefg =0;};};_gffb :=_dadee ;if _ecgaf ._fafag .IsAbsolute (){_dadee .X =_ecgaf ._bgbcd ;_dadee .Y =_ecgaf ._adedc ;}else {_dadee .X +=_ecgaf ._dead .Left ;
_dadee .Y +=_eefg ;_dadee .Width -=_ecgaf ._dead .Left +_ecgaf ._dead .Right ;_dadee .Height -=_eefg ;};_fcff :=_dadee .Width ;_bafa :=_dadee .X ;_cdcge :=_dadee .Y ;_bcfa :=_dadee .Height ;_bcab :=0;_fgecf ,_afcae :=-1,-1;if _ecgaf ._befce {for _cbffa ,_fabab :=range _ecgaf ._cfcdg {if _fabab ._ggccd < _ecgaf ._bdcdfg {continue ;
};if _fabab ._ggccd > _ecgaf ._feac {break ;};if _fgecf < 0{_fgecf =_cbffa ;};_afcae =_cbffa ;};};if _cdbeg :=_ecgaf .wrapContent (_dadee );_cdbeg !=nil {return nil ,_dadee ,_cdbeg ;};_ecgaf .updateRowHeights (_dadee .Width -_ecgaf ._dead .Left -_ecgaf ._dead .Right );
var (_cgfb bool ;_bgdg int ;_fccac int ;_efaba bool ;_gead int ;_fgebg error ;);for _gccea :=0;_gccea < len (_ecgaf ._cfcdg );_gccea ++{_gcef :=_ecgaf ._cfcdg [_gccea ];if _fafbd ,_cffea :=_ecgaf .getLastCellFromCol (_gcef ._eafa );_fafbd ==_gccea {if (_cffea ._ggccd +_cffea ._effeb -1)< _ecgaf ._egged {for _gbfff :=_gcef ._ggccd ;
_gbfff < _ecgaf ._egged ;_gbfff ++{_cdbaf :=&TableCell {};_cdbaf ._ggccd =_gbfff +1;_cdbaf ._effeb =1;_cdbaf ._eafa =_gcef ._eafa ;_ecgaf ._cfcdg =append (_ecgaf ._cfcdg ,_cdbaf );};};};_eafc :=_gcef .width (_ecgaf ._dbeeb ,_fcff );_adgce :=float64 (0.0);
for _eecbc :=0;_eecbc < _gcef ._eafa -1;_eecbc ++{_adgce +=_ecgaf ._dbeeb [_eecbc ]*_fcff ;};_fcefb :=float64 (0.0);for _fefe :=_bcab ;_fefe < _gcef ._ggccd -1;_fefe ++{_fcefb +=_ecgaf ._eegf [_fefe ];};_dadee .Height =_bcfa -_fcefb ;_dbbf :=float64 (0.0);
for _cagcb :=0;_cagcb < _gcef ._effeb ;_cagcb ++{_dbbf +=_ecgaf ._eegf [_gcef ._ggccd +_cagcb -1];};_dafba :=_efaba &&_gcef ._ggccd !=_gead ;_gead =_gcef ._ggccd ;if _dafba ||_dbbf > _dadee .Height {if _ecgaf ._egegc &&!_efaba {_efaba ,_fgebg =_ecgaf .wrapRow (_gccea ,_dadee ,_fcff );
if _fgebg !=nil {return nil ,_dadee ,_fgebg ;};if _efaba {_gccea --;continue ;};};_bgdeg =append (_bgdeg ,_ebfgf );_ebfgf =NewBlock (_dadee .PageWidth ,_dadee .PageHeight );_bafa =_dadee .Margins .Left +_ecgaf ._dead .Left ;_cdcge =_dadee .Margins .Top ;
_dadee .Height =_dadee .PageHeight -_dadee .Margins .Top -_dadee .Margins .Bottom ;_dadee .Page ++;_bcfa =_dadee .Height ;_bcab =_gcef ._ggccd -1;_fcefb =0;_efaba =false ;if _ecgaf ._befce &&_fgecf >=0{_bgdg =_gccea ;_gccea =_fgecf -1;_fccac =_bcab ;_bcab =_ecgaf ._bdcdfg -1;
_cgfb =true ;if _gcef ._effeb > (_ecgaf ._egged -_gead )||(_gcef ._effeb > 1&&_gccea < 0){_gfb .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_cgfb =false ;_fgecf ,_afcae =-1,-1;};continue ;};if _dafba {_gccea --;continue ;};};_dadee .Width =_eafc ;_dadee .X =_bafa +_adgce ;_dadee .Y =_cdcge +_fcefb ;if _dbbf > _dadee .PageHeight -_dadee .Margins .Top -_dadee .Margins .Bottom {_dbbf =_dadee .PageHeight -_dadee .Margins .Top -_dadee .Margins .Bottom ;
};_agcdb :=_gccb (_dadee .X ,_dadee .Y ,_eafc ,_dbbf );if _gcef ._ebfde !=nil {_agcdb .SetFillColor (_gcef ._ebfde );};_agcdb .LineStyle =_gcef ._beaee ;_agcdb ._ddda =_gcef ._gcecd ;_agcdb ._dbf =_gcef ._bfae ;_agcdb ._bgf =_gcef ._bebdb ;_agcdb ._acc =_gcef ._cbaca ;
if _gcef ._gdga !=nil {_agcdb .SetColorLeft (_gcef ._gdga );};if _gcef ._ddeb !=nil {_agcdb .SetColorBottom (_gcef ._ddeb );};if _gcef ._ffgab !=nil {_agcdb .SetColorRight (_gcef ._ffgab );};if _gcef ._bebf !=nil {_agcdb .SetColorTop (_gcef ._bebf );};
_agcdb .SetWidthBottom (_gcef ._bdbcc );_agcdb .SetWidthLeft (_gcef ._fafbe );_agcdb .SetWidthRight (_gcef ._agge );_agcdb .SetWidthTop (_gcef ._defbe );_eade :=NewBlock (_ebfgf ._bc ,_ebfgf ._ag );_adede :=_ebfgf .Draw (_agcdb );if _adede !=nil {_gfb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_adede );
};if _gcef ._aeeee !=nil {_ggee :=_gcef ._aeeee .Width ();_ggfba :=_gcef ._aeeee .Height ();_cfegc :=0.0;switch _bbece :=_gcef ._aeeee .(type ){case *Paragraph :if _bbece ._cgbcg {_ggee =_bbece .getMaxLineWidth ()/1000.0;};_dega ,_bbef ,_ :=_bbece .getTextMetrics ();
_deaee ,_dedfg :=_dega *_bbece ._efbdc ,_bbef *_bbece ._efbdc ;_ggfba =_ggfba -_dedfg +_deaee ;_cfegc +=_deaee -_dedfg ;_bcdf :=0.5;if _ecgaf ._gdad {_bcdf =0.3;};switch _gcef ._eagd {case CellVerticalAlignmentTop :_cfegc +=_deaee *_bcdf ;case CellVerticalAlignmentBottom :_cfegc -=_deaee *_bcdf ;
};_ggee +=_bbece ._edbc .Left +_bbece ._edbc .Right ;_ggfba +=_bbece ._edbc .Top +_bbece ._edbc .Bottom ;case *StyledParagraph :if _bbece ._eagfa {_ggee =_bbece .getMaxLineWidth ()/1000.0;};_egfeg ,_fgebb ,_dgga :=_bbece .getLineMetrics (0);_dccb ,_cccfa :=_egfeg *_bbece ._agcdg ,_fgebb *_bbece ._agcdg ;
if _bbece ._cdcg ==TextVerticalAlignmentCenter {_cfegc =_cccfa -(_fgebb +(_egfeg +_dgga -_fgebb )/2+(_cccfa -_fgebb )/2);};if len (_bbece ._feab )==1{_ggfba =_dccb ;}else {_ggfba =_ggfba -_cccfa +_dccb ;};_cfegc +=_dccb -_cccfa ;switch _gcef ._eagd {case CellVerticalAlignmentTop :_cfegc +=_dccb *0.5;
case CellVerticalAlignmentBottom :_cfegc -=_dccb *0.5;};_ggee +=_bbece ._acbfg .Left +_bbece ._acbfg .Right ;_ggfba +=_bbece ._acbfg .Top +_bbece ._acbfg .Bottom ;case *Table :_ggee =_eafc ;case *List :_ggee =_eafc ;case *Division :_ggee =_eafc ;case *Chart :_ggee =_eafc ;
case *Line :_ggfba +=_bbece ._accae .Top +_bbece ._accae .Bottom ;_cfegc -=_bbece .Height ()/2;case *Image :_ggee +=_bbece ._ceaa .Left +_bbece ._ceaa .Right ;_ggfba +=_bbece ._ceaa .Top +_bbece ._ceaa .Bottom ;};switch _gcef ._gffac {case CellHorizontalAlignmentLeft :_dadee .X +=_gcef ._bgeed ;
_dadee .Width -=_gcef ._bgeed ;case CellHorizontalAlignmentCenter :if _ebaed :=_eafc -_ggee ;_ebaed > 0{_dadee .X +=_ebaed /2;_dadee .Width -=_ebaed /2;};case CellHorizontalAlignmentRight :if _eafc > _ggee {_dadee .X =_dadee .X +_eafc -_ggee -_gcef ._bgeed ;
_dadee .Width -=_gcef ._bgeed ;};};_dcec :=_dadee .Y ;_gdcgad :=_dadee .Height ;_dadee .Y +=_cfegc ;switch _gcef ._eagd {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _deag :=_dbbf -_ggfba ;_deag > 0{_dadee .Y +=_deag /2;_dadee .Height -=_deag /2;
};case CellVerticalAlignmentBottom :if _dbbf > _ggfba {_dadee .Y =_dadee .Y +_dbbf -_ggfba ;_dadee .Height =_dbbf ;};};_bgbd :=_ebfgf .DrawWithContext (_gcef ._aeeee ,_dadee );if _bgbd !=nil {if _e .Is (_bgbd ,ErrContentNotFit )&&!_dafba {_ebfgf =_eade ;
_dafba =true ;_gccea --;continue ;};_gfb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bgbd );};_dadee .Y =_dcec ;_dadee .Height =_gdcgad ;};_dadee .Y +=_dbbf ;_dadee .Height -=_dbbf ;if _cgfb &&_gccea +1> _afcae {_cdcge +=_fcefb +_dbbf ;
_bcfa -=_dbbf +_fcefb ;_bcab =_fccac ;_gccea =_bgdg -1;_cgfb =false ;};};_bgdeg =append (_bgdeg ,_ebfgf );if _ecgaf ._fafag .IsAbsolute (){return _bgdeg ,_gffb ,nil ;};_dadee .X =_gffb .X ;_dadee .Width =_gffb .Width ;_dadee .Y +=_ecgaf ._dead .Bottom ;
_dadee .Height -=_ecgaf ._dead .Bottom ;return _bgdeg ,_dadee ,nil ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_debd *RadialShading )ToPdfShadingPattern ()*_ed .PdfShadingPatternType3 {_ggea ,_adabg ,_bcgaf :=_debd ._efef ._cbcbg .ToRGB ();_gedf :=_debd .shadingModel ();_gedf .PdfShading .Background =_gd .MakeArrayFromFloats ([]float64 {_ggea ,_adabg ,_bcgaf });
_efcf :=_ed .NewPdfShadingPatternType3 ();_efcf .Shading =_gedf ;return _efcf ;};func (_bcggfd *templateProcessor )parseInt64Attr (_edbbg ,_ecdf string )int64 {_gfb .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_edbbg ,_ecdf );
_bafcf ,_ :=_ad .ParseInt (_ecdf ,10,64);return _bafcf ;};func _ddac (_eaaedc *Block ,_fdabb *Paragraph ,_bafb DrawContext )(DrawContext ,error ){_adfe :=1;_bebee :=_gd .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ad .Itoa (_adfe ));for _eaaedc ._ece .HasFontByName (_bebee ){_adfe ++;
_bebee =_gd .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ad .Itoa (_adfe ));};_dbea :=_eaaedc ._ece .SetFontByName (_bebee ,_fdabb ._bbcb .ToPdfObject ());if _dbea !=nil {return _bafb ,_dbea ;};_fdabb .wrapText ();_caed :=_cc .NewContentCreator ();_caed .Add_q ();
_abceg :=_bafb .PageHeight -_bafb .Y -_fdabb ._afffc *_fdabb ._efbdc ;_caed .Translate (_bafb .X ,_abceg );if _fdabb ._egcg !=0{_caed .RotateDeg (_fdabb ._egcg );};_agggg :=_dec (_fdabb ._ebfca );_dbea =_bfgc (_eaaedc ,_agggg ,_fdabb ._ebfca ,func ()Rectangle {return Rectangle {_gadgc :_bafb .X ,_adac :_abceg ,_cegcg :_fdabb .getMaxLineWidth ()/1000.0,_ggbab :_fdabb .Height ()};
});if _dbea !=nil {return _bafb ,_dbea ;};_caed .Add_BT ().SetNonStrokingColor (_agggg ).Add_Tf (_bebee ,_fdabb ._afffc ).Add_TL (_fdabb ._afffc *_fdabb ._efbdc );for _bdcb ,_cgac :=range _fdabb ._baeba {if _bdcb !=0{_caed .Add_Tstar ();};_beae :=[]rune (_cgac );
_ccbg :=0.0;_ddbeg :=0;for _egbb ,_cfce :=range _beae {if _cfce ==' '{_ddbeg ++;continue ;};if _cfce =='\u000A'{continue ;};_beca ,_ggace :=_fdabb ._bbcb .GetRuneMetrics (_cfce );if !_ggace {_gfb .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_egbb ,_cfce ,_cfce ,_fdabb ._bbcb .BaseFont (),_fdabb ._bbcb .Subtype ());
return _bafb ,_e .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_ccbg +=_fdabb ._afffc *_beca .Wx ;};var _bgga []_gd .PdfObject ;_gacbe ,_cbeg :=_fdabb ._bbcb .GetRuneMetrics (' ');
if !_cbeg {return _bafb ,_e .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_gfeff :=_gacbe .Wx ;switch _fdabb ._ebaa {case TextAlignmentJustify :if _ddbeg > 0&&_bdcb < len (_fdabb ._baeba )-1{_gfeff =(_fdabb ._begf *1000.0-_ccbg )/float64 (_ddbeg )/_fdabb ._afffc ;
};case TextAlignmentCenter :_gecce :=_ccbg +float64 (_ddbeg )*_gfeff *_fdabb ._afffc ;_bbaf :=(_fdabb ._begf *1000.0-_gecce )/2/_fdabb ._afffc ;_bgga =append (_bgga ,_gd .MakeFloat (-_bbaf ));case TextAlignmentRight :_bfbe :=_ccbg +float64 (_ddbeg )*_gfeff *_fdabb ._afffc ;
_ceeb :=(_fdabb ._begf *1000.0-_bfbe )/_fdabb ._afffc ;_bgga =append (_bgga ,_gd .MakeFloat (-_ceeb ));};_dfacc :=_fdabb ._bbcb .Encoder ();var _cegb []byte ;for _ ,_ddgf :=range _beae {if _ddgf =='\u000A'{continue ;};if _ddgf ==' '{if len (_cegb )> 0{_bgga =append (_bgga ,_gd .MakeStringFromBytes (_cegb ));
_cegb =nil ;};_bgga =append (_bgga ,_gd .MakeFloat (-_gfeff ));}else {if _ ,_cgdd :=_dfacc .RuneToCharcode (_ddgf );!_cgdd {_dbea =UnsupportedRuneError {Message :_f .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ddgf ,_ddgf ),Rune :_ddgf };
_bafb ._gac =append (_bafb ._gac ,_dbea );_gfb .Log .Debug (_dbea .Error ());if _bafb ._gfbg <=0{continue ;};_ddgf =_bafb ._gfbg ;};_cegb =append (_cegb ,_dfacc .Encode (string (_ddgf ))...);};};if len (_cegb )> 0{_bgga =append (_bgga ,_gd .MakeStringFromBytes (_cegb ));
};_caed .Add_TJ (_bgga ...);};_caed .Add_ET ();_caed .Add_Q ();_gcad :=_caed .Operations ();_gcad .WrapIfNeeded ();_eaaedc .addContents (_gcad );if _fdabb ._fadf .IsRelative (){_gcfg :=_fdabb .Height ();_bafb .Y +=_gcfg ;_bafb .Height -=_gcfg ;if _bafb .Inline {_bafb .X +=_fdabb .Width ()+_fdabb ._edbc .Right ;
};};return _bafb ,nil ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_ccbfb *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_egebe ,_gfgge :=_ccbfb .Wrap (width );if _gfgge !=nil {return nil ,_gfgge ;};_dabef :=int (height /_ccbfb .Style .FontSize );if _dabef >=len (_egebe ){return nil ,nil ;};_efccdb :="\u000a";
_ccbfb .Text =_de .Replace (_de .Join (_egebe [:_dabef ],"\u0020"),_efccdb +"\u0020",_efccdb ,-1);_bagba :=_de .Replace (_de .Join (_egebe [_dabef :],"\u0020"),_efccdb +"\u0020",_efccdb ,-1);return NewTextChunk (_bagba ,_ccbfb .Style ),nil ;};

// SetBorderOpacity sets the border opacity.
func (_egbaa *CurvePolygon )SetBorderOpacity (opacity float64 ){_egbaa ._fggf =opacity };

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_ddcg *RadialShading )SetExtends (start bool ,end bool ){_ddcg ._efef .SetExtends (start ,end )};

// SetAngle sets the rotation angle of the text.
func (_befd *Paragraph )SetAngle (angle float64 ){_befd ._egcg =angle };

// FitMode returns the fit mode of the rectangle.
func (_cffgd *Rectangle )FitMode ()FitMode {return _cffgd ._gfag };

// Width returns the current page width.
func (_addb *Creator )Width ()float64 {return _addb ._ffeg };

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;func (_bbbe *List )ctxHeight (_adga float64 )float64 {_adga -=_bbbe ._gdfg ;var _fcac float64 ;for _ ,_fgaf :=range _bbbe ._gaegd {_fcac +=_fgaf .ctxHeight (_adga );};return _fcac ;};func (_bgfcb *Invoice )drawSection (_aeeec ,_fcbf string )[]*StyledParagraph {var _affb []*StyledParagraph ;
if _aeeec !=""{_dfcfd :=_cfeea (_bgfcb ._fcb );_dfcfd .SetMargins (0,0,0,5);_dfcfd .Append (_aeeec );_affb =append (_affb ,_dfcfd );};if _fcbf !=""{_abca :=_cfeea (_bgfcb ._ebbe );_abca .Append (_fcbf );_affb =append (_affb ,_abca );};return _affb ;};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_ceefb *Paragraph )SetMaxLines (maxLines int ){_ceefb ._agbafd =maxLines ;_ceefb .wrapText ()};

// SetSellerAddress sets the seller address of the invoice.
func (_gadcd *Invoice )SetSellerAddress (address *InvoiceAddress ){_gadcd ._gbee =address };

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_bfe *Block )SetPos (x ,y float64 ){_bfe ._ea =PositionAbsolute ;_bfe ._edd =x ;_bfe ._dcc =y };

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_aaaf *Image )SetFitMode (fitMode FitMode ){_aaaf ._caec =fitMode };

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_cdc DrawContext )([]*Block ,DrawContext ,error );};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_ddge _ge .ChartRenderable ;_gbea Positioning ;_bgce float64 ;_ggdf float64 ;_bfa Margins ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_ceeae *StyledParagraph )SetTextAlignment (align TextAlignment ){_ceeae ._fgfd =align };

// Height returns the height of the graphic svg.
func (_gdbda *GraphicSVG )Height ()float64 {return _gdbda ._caga .Height };

// NewPolygon creates a new polygon.
func (_bfcc *Creator )NewPolygon (points [][]_bf .Point )*Polygon {return _bddfd (points )};var _egbd =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_dfefb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cgeb :_cdcbe },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_dfefb :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_cgeb :_gcagf },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_dfefb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cgeb :_fceeb },"\u0074\u0061\u0062l\u0065":&templateTag {_dfefb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cgeb :_debfb },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_dfefb :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_cgeb :_dccg },"\u006c\u0069\u006e\u0065":&templateTag {_dfefb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cgeb :_ddebg },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_dfefb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cgeb :_ccgg },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_dfefb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cgeb :_cecd },"\u0069\u006d\u0061g\u0065":&templateTag {_dfefb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cgeb :_agef },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_dfefb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cgeb :_ffdfg },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_dfefb :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cgeb :_aggga },"\u0063\u0068\u0061r\u0074":&templateTag {_dfefb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cgeb :_cffb },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_dfefb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_cgeb :_ccab },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_dfefb :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_cgeb :_abgab },"\u006c\u0069\u0073\u0074":&templateTag {_dfefb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cgeb :_bdabd },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_dfefb :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_cgeb :_bbca },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_dfefb :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_cgeb :_dfcdb }};


// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_gbb *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gcae :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_geeg ,_ffaa :=_gcae .setOpacity (_gbb ._egfd ,_gbb ._fggf );if _ffaa !=nil {return nil ,ctx ,_ffaa ;};_gecc :=_gbb ._gfae ;
_gecc .FillEnabled =_gecc .FillColor !=nil ;_gecc .BorderEnabled =_gecc .BorderColor !=nil &&_gecc .BorderWidth > 0;var (_bddf =ctx .PageHeight ;_aadca =_gecc .Rings ;_aead =make ([][]_bf .CubicBezierCurve ,0,len (_gecc .Rings )););_aefg :=_ed .PdfRectangle {};
if len (_aadca )> 0&&len (_aadca [0])> 0{_becb :=_aadca [0][0];_becb .P0 .Y =_bddf -_becb .P0 .Y ;_becb .P1 .Y =_bddf -_becb .P1 .Y ;_becb .P2 .Y =_bddf -_becb .P2 .Y ;_becb .P3 .Y =_bddf -_becb .P3 .Y ;_aefg =_becb .GetBounds ();};for _ ,_gdcef :=range _aadca {_eggb :=make ([]_bf .CubicBezierCurve ,0,len (_gdcef ));
for _ ,_dff :=range _gdcef {_bedb :=_dff ;_bedb .P0 .Y =_bddf -_bedb .P0 .Y ;_bedb .P1 .Y =_bddf -_bedb .P1 .Y ;_bedb .P2 .Y =_bddf -_bedb .P2 .Y ;_bedb .P3 .Y =_bddf -_bedb .P3 .Y ;_eggb =append (_eggb ,_bedb );_fcebg :=_bedb .GetBounds ();_aefg .Llx =_cf .Min (_aefg .Llx ,_fcebg .Llx );
_aefg .Lly =_cf .Min (_aefg .Lly ,_fcebg .Lly );_aefg .Urx =_cf .Max (_aefg .Urx ,_fcebg .Urx );_aefg .Ury =_cf .Max (_aefg .Ury ,_fcebg .Ury );};_aead =append (_aead ,_eggb );};_gecc .Rings =_aead ;defer func (){_gecc .Rings =_aadca }();if _gecc .FillEnabled {_gffg :=_bfgc (_gcae ,_gbb ._gfae .FillColor ,_gbb ._aeef ,func ()Rectangle {return Rectangle {_gadgc :_aefg .Llx ,_adac :_aefg .Lly ,_cegcg :_aefg .Width (),_ggbab :_aefg .Height ()};
});if _gffg !=nil {return nil ,ctx ,_gffg ;};};_ggbf ,_ ,_ffaa :=_gecc .Draw (_geeg );if _ffaa !=nil {return nil ,ctx ,_ffaa ;};if _ffaa =_gcae .addContentsByString (string (_ggbf ));_ffaa !=nil {return nil ,ctx ,_ffaa ;};return []*Block {_gcae },ctx ,nil ;
};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_ggff *Table )EnableRowWrap (enable bool ){_ggff ._egegc =enable };

// SetBorderWidth sets the border width.
func (_cega *CurvePolygon )SetBorderWidth (borderWidth float64 ){_cega ._gfae .BorderWidth =borderWidth };

// NewImageFromData creates an Image from image data.
func (_agbaf *Creator )NewImageFromData (data []byte )(*Image ,error ){return _ceef (data )};

// SetDueDate sets the due date of the invoice.
func (_defc *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_defc ._beff [1].Value =dueDate ;return _defc ._beff [0],_defc ._beff [1];};func (_bbbf *StyledParagraph )getTextWidth ()float64 {var _ddgaa float64 ;_gege :=len (_bbbf ._fcdf );
for _gfaae ,_faba :=range _bbbf ._fcdf {_abef :=&_faba .Style ;_cacda :=len (_faba .Text );for _debc ,_agbge :=range _faba .Text {if _agbge =='\u000A'{continue ;};_gagef ,_dcfaca :=_abef .Font .GetRuneMetrics (_agbge );if !_dcfaca {_gfb .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_agbge );
return -1;};_ddgaa +=_abef .FontSize *_gagef .Wx *_abef .horizontalScale ();if _agbge !=' '&&(_gfaae !=_gege -1||_debc !=_cacda -1){_ddgaa +=_abef .CharSpacing *1000.0;};};};return _ddgaa ;};func _debfb (_dcdc *templateProcessor ,_eebd *templateNode )(interface{},error ){return _dcdc .parseTable (_eebd );
};func _gedg (_eaae VectorDrawable ,_agcad float64 )float64 {switch _dade :=_eaae .(type ){case *Paragraph :if _dade ._cgbcg {_dade .SetWidth (_agcad -_dade ._edbc .Left -_dade ._edbc .Right );};return _dade .Height ()+_dade ._edbc .Top +_dade ._edbc .Bottom ;
case *StyledParagraph :if _dade ._eagfa {_dade .SetWidth (_agcad -_dade ._acbfg .Left -_dade ._acbfg .Right );};return _dade .Height ()+_dade ._acbfg .Top +_dade ._acbfg .Bottom ;case *Image :_dade .applyFitMode (_agcad );return _dade .Height ()+_dade ._ceaa .Top +_dade ._ceaa .Bottom ;
case *Rectangle :_dade .applyFitMode (_agcad );return _dade .Height ()+_dade ._ddfc .Top +_dade ._ddfc .Bottom +_dade ._cfdf ;case *Ellipse :_dade .applyFitMode (_agcad );return _dade .Height ()+_dade ._cdg .Top +_dade ._cdg .Bottom ;case *Division :return _dade .ctxHeight (_agcad )+_dade ._baad .Top +_dade ._baad .Bottom +_dade ._babd .Top +_dade ._babd .Bottom ;
case *Table :_dade .updateRowHeights (_agcad -_dade ._dead .Left -_dade ._dead .Right );return _dade .Height ()+_dade ._dead .Top +_dade ._dead .Bottom ;case *List :return _dade .ctxHeight (_agcad )+_dade ._afded .Top +_dade ._afded .Bottom ;case marginDrawable :_ ,_ ,_cfaf ,_ddc :=_dade .GetMargins ();
return _dade .Height ()+_cfaf +_ddc ;default:return _dade .Height ();};};

// Lines returns all the lines the table of contents has.
func (_acdbb *TOC )Lines ()[]*TOCLine {return _acdbb ._ffge };

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_dddb *Chart )Width ()float64 {return float64 (_dddb ._ddge .Width ())};

// Width returns the Block's width.
func (_cfa *Block )Width ()float64 {return _cfa ._bc };

// Width returns Image's document width.
func (_edgbe *Image )Width ()float64 {return _edgbe ._dgfb };func _gcfc (_geedac string )(*GraphicSVG ,error ){_ageae ,_cdab :=_fd .ParseFromFile (_geedac );if _cdab !=nil {return nil ,_cdab ;};return _fedgf (_ageae );};func _gbfdg (_cdbgb []*ColorPoint )*LinearShading {return &LinearShading {_fded :&shading {_cbcbg :ColorWhite ,_aagae :false ,_cfffe :[]bool {false ,false },_dcagf :_cdbgb },_ggcfg :&_ed .PdfRectangle {}};
};

// Height returns Image's document height.
func (_abgc *Image )Height ()float64 {return _abgc ._dafe };

// NewImageFromFile creates an Image from a file.
func (_dfdb *Creator )NewImageFromFile (path string )(*Image ,error ){return _egbad (path )};func _fedgf (_cddb *_fd .GraphicSVG )(*GraphicSVG ,error ){return &GraphicSVG {_caga :_cddb ,_dcce :PositionRelative ,_fcgg :Margins {Top :10,Bottom :10}},nil ;
};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_efbg *Creator )AddPage (page *_ed .PdfPage )error {_bdafb ,_fdcb :=_efbg .wrapPageIfNeeded (page );if _fdcb !=nil {return _fdcb ;};if _bdafb !=nil {page =_bdafb ;};_fecd ,_fdcb :=page .GetMediaBox ();if _fdcb !=nil {_gfb .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_fdcb );
return _fdcb ;};_fecd .Normalize ();_cdfg ,_fegd :=_fecd .Llx ,_fecd .Lly ;_cebf :=_fecd ;if _fgdac :=page .CropBox ;_fgdac !=nil &&*_fgdac !=*_fecd {_fgdac .Normalize ();_cdfg ,_fegd =_fgdac .Llx ,_fgdac .Lly ;_cebf =_fgdac ;};_edff :=_af .IdentityMatrix ();
_eceb ,_fdcb :=page .GetRotate ();if _fdcb !=nil {_gfb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_fdcb .Error ());
};_cba :=_eceb %360!=0&&_eceb %90==0;if _cba {_cgdg :=float64 ((360+_eceb %360)%360);if _cgdg ==90{_edff =_edff .Translate (_cebf .Width (),0);}else if _cgdg ==180{_edff =_edff .Translate (_cebf .Width (),_cebf .Height ());}else if _cgdg ==270{_edff =_edff .Translate (0,_cebf .Height ());
};_edff =_edff .Mult (_af .RotationMatrix (_cgdg *_cf .Pi /180));_edff =_edff .Round (0.000001);_aagbg :=_acdff (_cebf ,_edff );_cebf =_aagbg ;_cebf .Normalize ();};if _cdfg !=0||_fegd !=0{_edff =_af .TranslationMatrix (_cdfg ,_fegd ).Mult (_edff );};if !_edff .Identity (){_edff =_edff .Round (0.000001);
_efbg ._cgf [page ]=&pageTransformations {_dab :&_edff };};_efbg ._ffeg =_cebf .Width ();_efbg ._adc =_cebf .Height ();_efbg .initContext ();_efbg ._fgdd =append (_efbg ._fgdd ,page );_efbg ._abe .Page ++;return nil ;};const (CellBorderSideLeft CellBorderSide =iota ;
CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_fgga *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_fgga ._abafe =textOverflow };

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_dggf *TableCell )SetContent (vd VectorDrawable )error {switch _abbaa :=vd .(type ){case *Paragraph :if _abbaa ._gbbc {_abbaa ._cgbcg =true ;};_dggf ._aeeee =vd ;case *StyledParagraph :if _abbaa ._cdebe {_abbaa ._eagfa =true ;};_dggf ._aeeee =vd ;
case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_dggf ._aeeee =vd ;default:_gfb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _gd .ErrTypeError ;};return nil ;};func _cffef (_cdcga ,_bdggd ,_gadaf string ,_dgec uint ,_ddbgg TextStyle )*TOCLine {return _ccdbd (TextChunk {Text :_cdcga ,Style :_ddbgg },TextChunk {Text :_bdggd ,Style :_ddbgg },TextChunk {Text :_gadaf ,Style :_ddbgg },_dgec ,_ddbgg );
};

// NewList creates a new list.
func (_gbde *Creator )NewList ()*List {return _deeb (_gbde .NewTextStyle ())};func _gdbd (_adae [][]_bf .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_gfae :&_bf .CurvePolygon {Rings :_adae },_egfd :1.0,_fggf :1.0};};

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_fadag *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fadag ._ddfc .Left ,_fadag ._ddfc .Right ,_fadag ._ddfc .Top ,_fadag ._ddfc .Bottom ;};func _ffe (_bffaf *_cc .ContentStreamOperations ,_ffg *_ed .PdfPageResources ,_bga *_cc .ContentStreamOperations ,_cdb *_ed .PdfPageResources )error {_efb :=map[_gd .PdfObjectName ]_gd .PdfObjectName {};
_fg :=map[_gd .PdfObjectName ]_gd .PdfObjectName {};_ded :=map[_gd .PdfObjectName ]_gd .PdfObjectName {};_ffff :=map[_gd .PdfObjectName ]_gd .PdfObjectName {};_eaee :=map[_gd .PdfObjectName ]_gd .PdfObjectName {};_fdd :=map[_gd .PdfObjectName ]_gd .PdfObjectName {};
for _ ,_geb :=range *_bga {switch _geb .Operand {case "\u0044\u006f":if len (_geb .Params )==1{if _gef ,_bad :=_geb .Params [0].(*_gd .PdfObjectName );_bad {if _ ,_bdg :=_efb [*_gef ];!_bdg {var _add _gd .PdfObjectName ;_aae ,_ :=_cdb .GetXObjectByName (*_gef );
if _aae !=nil {_add =*_gef ;for {_aba ,_ :=_ffg .GetXObjectByName (_add );if _aba ==nil ||_aba ==_aae {break ;};_add =*_gd .MakeName (_fege (_add .String ()));};};_ffg .SetXObjectByName (_add ,_aae );_efb [*_gef ]=_add ;};_gfc :=_efb [*_gef ];_geb .Params [0]=&_gfc ;
};};case "\u0054\u0066":if len (_geb .Params )==2{if _cfe ,_acbb :=_geb .Params [0].(*_gd .PdfObjectName );_acbb {if _ ,_ggd :=_fg [*_cfe ];!_ggd {_adbg ,_ebf :=_cdb .GetFontByName (*_cfe );_bdd :=*_cfe ;if _ebf &&_adbg !=nil {_bdd =_dfd (_cfe .String (),_adbg ,_ffg );
};_ffg .SetFontByName (_bdd ,_adbg );_fg [*_cfe ]=_bdd ;};_cg :=_fg [*_cfe ];_geb .Params [0]=&_cg ;};};case "\u0043\u0053","\u0063\u0073":if len (_geb .Params )==1{if _dfa ,_aee :=_geb .Params [0].(*_gd .PdfObjectName );_aee {if _ ,_fec :=_ded [*_dfa ];
!_fec {var _fee _gd .PdfObjectName ;_ffeb ,_edfd :=_cdb .GetColorspaceByName (*_dfa );if _edfd {_fee =*_dfa ;for {_fdf ,_fdg :=_ffg .GetColorspaceByName (_fee );if !_fdg ||_ffeb ==_fdf {break ;};_fee =*_gd .MakeName (_fege (_fee .String ()));};_ffg .SetColorspaceByName (_fee ,_ffeb );
_ded [*_dfa ]=_fee ;}else {_gfb .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _bgd ,_aeg :=_ded [*_dfa ];_aeg {_geb .Params [0]=&_bgd ;}else {_gfb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_dfa );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_geb .Params )==1{if _gfe ,_aag :=_geb .Params [0].(*_gd .PdfObjectName );_aag {if _ ,_edc :=_ffff [*_gfe ];!_edc {var _fad _gd .PdfObjectName ;_deg ,_cad :=_cdb .GetPatternByName (*_gfe );if _cad {_fad =*_gfe ;
for {_bcd ,_dcfg :=_ffg .GetPatternByName (_fad );if !_dcfg ||_bcd ==_deg {break ;};_fad =*_gd .MakeName (_fege (_fad .String ()));};_fddc :=_ffg .SetPatternByName (_fad ,_deg .ToPdfObject ());if _fddc !=nil {return _fddc ;};_ffff [*_gfe ]=_fad ;};};if _fbf ,_ecc :=_ffff [*_gfe ];
_ecc {_geb .Params [0]=&_fbf ;};};};case "\u0073\u0068":if len (_geb .Params )==1{if _gdg ,_fgb :=_geb .Params [0].(*_gd .PdfObjectName );_fgb {if _ ,_cbc :=_eaee [*_gdg ];!_cbc {var _fgbb _gd .PdfObjectName ;_ccd ,_eca :=_cdb .GetShadingByName (*_gdg );
if _eca {_fgbb =*_gdg ;for {_bggc ,_eecc :=_ffg .GetShadingByName (_fgbb );if !_eecc ||_ccd ==_bggc {break ;};_fgbb =*_gd .MakeName (_fege (_fgbb .String ()));};_agfa :=_ffg .SetShadingByName (_fgbb ,_ccd .ToPdfObject ());if _agfa !=nil {_gfb .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_agfa );
return _agfa ;};_eaee [*_gdg ]=_fgbb ;}else {_gfb .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _gfd ,_edg :=_eaee [*_gdg ];_edg {_geb .Params [0]=&_gfd ;}else {_gfb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_gdg );
};};};case "\u0067\u0073":if len (_geb .Params )==1{if _agd ,_fga :=_geb .Params [0].(*_gd .PdfObjectName );_fga {if _ ,_cag :=_fdd [*_agd ];!_cag {var _cgb _gd .PdfObjectName ;_ddg ,_eeg :=_cdb .GetExtGState (*_agd );if _eeg {_cgb =*_agd ;for {_faef ,_degf :=_ffg .GetExtGState (_cgb );
if !_degf ||_ddg ==_faef {break ;};_cgb =*_gd .MakeName (_fege (_cgb .String ()));};};_ffg .AddExtGState (_cgb ,_ddg );_fdd [*_agd ]=_cgb ;};_cef :=_fdd [*_agd ];_geb .Params [0]=&_cef ;};};};*_bffaf =append (*_bffaf ,_geb );};return nil ;};const (AnchorBottomLeft AnchorPoint =iota ;
AnchorBottomRight ;AnchorTopLeft ;AnchorTopRight ;AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_gagfe *Table )MultiRowCell (rowspan int )*TableCell {return _gagfe .MultiCell (rowspan ,1)};

// SetMargins sets the Paragraph's margins.
func (_bebba *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_bebba ._edbc .Left =left ;_bebba ._edbc .Right =right ;_bebba ._edbc .Top =top ;_bebba ._edbc .Bottom =bottom ;};

// SetAnchor set gradient position anchor.
// Default to center.
func (_gaagd *RadialShading )SetAnchor (anchor AnchorPoint ){_gaagd ._bagda =anchor };func _cfeea (_bggab TextStyle )*StyledParagraph {return &StyledParagraph {_fcdf :[]*TextChunk {},_beafc :_bggab ,_fbag :_bdaeb (_bggab .Font ),_agcdg :1.0,_fgfd :TextAlignmentLeft ,_eagfa :true ,_cdebe :true ,_bedga :false ,_edgf :0,_beec :1,_gfea :1,_cbgac :PositionRelative };
};type templateProcessor struct{creator *Creator ;_dbcbe []byte ;_bfega *TemplateOptions ;_acdbca componentRenderer ;_dgaga string ;};func (_gcdb *Invoice )generateHeaderBlocks (_fbbac DrawContext )([]*Block ,DrawContext ,error ){_ccdfe :=_cfeea (_gcdb ._cedg );
_ccdfe .SetEnableWrap (true );_ccdfe .Append (_gcdb ._cfaa );_aagbd :=_gegfb (2);if _gcdb ._ddga !=nil {_agadg :=_aagbd .NewCell ();_agadg .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_agadg .SetVerticalAlignment (CellVerticalAlignmentMiddle );
_agadg .SetIndent (0);_agadg .SetContent (_gcdb ._ddga );_gcdb ._ddga .ScaleToHeight (_ccdfe .Height ()+20);}else {_aagbd .SkipCells (1);};_fbedg :=_aagbd .NewCell ();_fbedg .SetHorizontalAlignment (CellHorizontalAlignmentRight );_fbedg .SetVerticalAlignment (CellVerticalAlignmentMiddle );
_fbedg .SetContent (_ccdfe );return _aagbd .GeneratePageBlocks (_fbbac );};func (_fdab *Chapter )headingNumber ()string {var _dedd string ;if _fdab ._ccf {if _fdab ._bbbg !=0{_dedd =_ad .Itoa (_fdab ._bbbg )+"\u002e";};if _fdab ._bef !=nil {_adfd :=_fdab ._bef .headingNumber ();
if _adfd !=""{_dedd =_adfd +_dedd ;};};};return _dedd ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_dabe []_bf .CubicBezierCurve ;FillEnabled bool ;_eea Color ;BorderEnabled bool ;BorderWidth float64 ;_faeb Color ;};

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_gbcg *shading )SetExtends (start bool ,end bool ){_gbcg ._cfffe =[]bool {start ,end }};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_dadfd *Invoice )NoteStyle ()TextStyle {return _dadfd ._ebbe };

// SetFillColor sets the fill color of the ellipse.
func (_caef *Ellipse )SetFillColor (col Color ){_caef ._fdaa =col };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_gdbe *Division )Width ()float64 {return 0};

// CurCol returns the currently active cell's column number.
func (_dagc *Table )CurCol ()int {_afca :=(_dagc ._dcef -1)%(_dagc ._dfeg )+1;return _afca };

// SetFont sets the Paragraph's font.
func (_dgad *Paragraph )SetFont (font *_ed .PdfFont ){_dgad ._bbcb =font };

// Height returns the height of the ellipse.
func (_efdaa *Ellipse )Height ()float64 {return _efdaa ._abda };func (_efafd *TableCell )width (_gcefa []float64 ,_effa float64 )float64 {_ffcbc :=float64 (0.0);for _cegdd :=0;_cegdd < _efafd ._edaeg ;_cegdd ++{_ffcbc +=_gcefa [_efafd ._eafa +_cegdd -1];
};return _ffcbc *_effa ;};func (_eaefb *Invoice )newColumn (_eacg string ,_edda CellHorizontalAlignment )*InvoiceCell {_dacea :=&InvoiceCell {_eaefb ._dbff ,_eacg };_dacea .Alignment =_edda ;return _dacea ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_adgcc *TOC )SetLineStyle (style TextStyle ){_adgcc .SetLineNumberStyle (style );_adgcc .SetLineTitleStyle (style );_adgcc .SetLineSeparatorStyle (style );_adgcc .SetLinePageStyle (style );};

// SetStyle sets the style of the line (solid or dashed).
func (_abfcd *Line )SetStyle (style _bf .LineStyle ){_abfcd ._cdcb =style };type templateNode struct{_cagcg interface{};_adbf _gc .StartElement ;_gfggb *templateNode ;_aebgb int ;_gbcdg int ;_gcgb int64 ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_addge *TableCell )SetBorderLineStyle (style _bf .LineStyle ){_addge ._beaee =style };func (_ce *Block )addContents (_gg *_cc .ContentStreamOperations ){_ce ._ebg .WrapIfNeeded ();_gg .WrapIfNeeded ();*_ce ._ebg =append (*_ce ._ebg ,*_gg ...);};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_beaf *LinearShading )ToPdfShadingPattern ()*_ed .PdfShadingPatternType2 {_gefgd ,_abba ,_febc :=_beaf ._fded ._cbcbg .ToRGB ();_ebdg :=_beaf .shadingModel ();_ebdg .PdfShading .Background =_gd .MakeArrayFromFloats ([]float64 {_gefgd ,_abba ,_febc });
_dbfbe :=_ed .NewPdfShadingPatternType2 ();_dbfbe .Shading =_ebdg ;return _dbfbe ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_ggfb *Invoice )AddressStyle ()TextStyle {return _ggfb ._eabg };

// SetColorBottom sets border color for bottom.
func (_gff *border )SetColorBottom (col Color ){_gff ._gbdg =col };func _dfcdb (_bdfg *templateProcessor ,_daaa *templateNode )(interface{},error ){return _bdfg .parseListMarker (_daaa );};func (_gfed *Image )rotatedSize ()(float64 ,float64 ){_fafee :=_gfed ._dgfb ;
_ddeg :=_gfed ._dafe ;_gcce :=_gfed ._eadd ;if _gcce ==0{return _fafee ,_ddeg ;};_ffgg :=_bf .Path {Points :[]_bf .Point {_bf .NewPoint (0,0).Rotate (_gcce ),_bf .NewPoint (_fafee ,0).Rotate (_gcce ),_bf .NewPoint (0,_ddeg ).Rotate (_gcce ),_bf .NewPoint (_fafee ,_ddeg ).Rotate (_gcce )}}.GetBoundingBox ();
return _ffgg .Width ,_ffgg .Height ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_gdgd *Invoice )NoteHeadingStyle ()TextStyle {return _gdgd ._fcb };func (_gebfe *StyledParagraph )getTextLineWidth (_cbda []*TextChunk )float64 {var _daegf float64 ;_bece :=len (_cbda );for _abgb ,_bgfe :=range _cbda {_ggad :=&_bgfe .Style ;_dgea :=len (_bgfe .Text );
for _dcda ,_cdga :=range _bgfe .Text {if _cdga =='\u000A'{continue ;};_gabb ,_eafe :=_ggad .Font .GetRuneMetrics (_cdga );if !_eafe {_gfb .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_cdga );
return -1;};_daegf +=_ggad .FontSize *_gabb .Wx *_ggad .horizontalScale ();if _cdga !=' '&&(_abgb !=_bece -1||_dcda !=_dgea -1){_daegf +=_ggad .CharSpacing *1000.0;};};};return _daegf ;};func _bcce (_ffbg Color ,_bgde float64 )*ColorPoint {return &ColorPoint {_cegfg :_ffbg ,_bddag :_bgde }};
func (_fcace *templateProcessor )parseFloatAttr (_eecec ,_ddgd string )float64 {_gfb .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_eecec ,_ddgd );
_dbdea ,_ :=_ad .ParseFloat (_ddgd ,64);return _dbdea ;};func (_agcb *templateProcessor )getNodeErrorLocation (_addbc *templateNode ,_fdcg string ,_dabce ...interface{})string {_ecgf :=_f .Sprintf (_fdcg ,_dabce ...);_dbdcd :=_f .Sprintf ("\u0025\u0064",_addbc ._gcgb );
if _addbc ._aebgb !=0{_dbdcd =_f .Sprintf ("\u0025\u0064\u003a%\u0064",_addbc ._aebgb ,_addbc ._gbcdg );};if _agcb ._dgaga !=""{return _f .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_ecgf ,_agcb ._dgaga ,_dbdcd );};return _f .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_ecgf ,_dbdcd );
};func (_dbggg *templateProcessor )parseBoolAttr (_cdebd ,_bbbfe string )bool {_gfb .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_cdebd ,_bbbfe );
_dedegg ,_ :=_ad .ParseBool (_bbbfe );return _bbbfe ==""||_dedegg ;};

// SetBorderWidth sets the border width.
func (_dcge *Polygon )SetBorderWidth (borderWidth float64 ){_dcge ._bdcee .BorderWidth =borderWidth };type shading struct{_cbcbg Color ;_aagae bool ;_cfffe []bool ;_dcagf []*ColorPoint ;};

// SetLevel sets the indentation level of the TOC line.
func (_ebdfa *TOCLine )SetLevel (level uint ){_ebdfa ._cefgd =level ;_ebdfa ._fbaf ._acbfg .Left =_ebdfa ._gabdg +float64 (_ebdfa ._cefgd -1)*_ebdfa ._fabb ;};func _bbca (_dbcab *templateProcessor ,_daea *templateNode )(interface{},error ){return _dbcab .parseListItem (_daea );
};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_bed *Block )AddAnnotation (annotation *_ed .PdfAnnotation ){for _ ,_dca :=range _bed ._ba {if _dca ==annotation {return ;};};_bed ._ba =append (_bed ._ba ,annotation );};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_bfg *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bfg ._bfa .Left ,_bfg ._bfa .Right ,_bfg ._bfa .Top ,_bfg ._bfa .Bottom ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_adfec *Table )NewCell ()*TableCell {return _adfec .MultiCell (1,1)};func _dec (_cec Color )_ed .PdfColor {if _cec ==nil {_cec =ColorBlack ;};switch _bfd :=_cec .(type ){case grayColor :return _ed .NewPdfColorDeviceGray (_bfd ._faf );case cmykColor :return _ed .NewPdfColorDeviceCMYK (_bfd ._dag ,_bfd ._acg ,_bfd ._befc ,_bfd ._dgde );
case *LinearShading :return _ed .NewPdfColorPatternType2 ();case *RadialShading :return _ed .NewPdfColorPatternType3 ();};return _ed .NewPdfColorDeviceRGB (_cec .ToRGB ());};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_aecf *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_ffcb :=[2]*InvoiceCell {_aecf .newCell (description ,_aecf ._fffb ),_aecf .newCell (value ,_aecf ._fffb )};_aecf ._ccad =append (_aecf ._ccad ,_ffcb );return _ffcb [0],_ffcb [1];
};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_cbef *RadialShading )AddShadingResource (block *Block )(_afefc _gd .PdfObjectName ,_deeg error ){_eeef :=1;_afefc =_gd .PdfObjectName ("\u0053\u0068"+_ad .Itoa (_eeef ));for block ._ece .HasShadingByName (_afefc ){_eeef ++;_afefc =_gd .PdfObjectName ("\u0053\u0068"+_ad .Itoa (_eeef ));
};if _bcec :=block ._ece .SetShadingByName (_afefc ,_cbef .shadingModel ().ToPdfObject ());_bcec !=nil {return "",_bcec ;};return _afefc ,nil ;};

// SetFillOpacity sets the fill opacity.
func (_fgae *PolyBezierCurve )SetFillOpacity (opacity float64 ){_fgae ._daab =opacity };

// AddColorStop add color stop information for rendering gradient.
func (_ceca *shading )AddColorStop (color Color ,point float64 ){_ceca ._dcagf =append (_ceca ._dcagf ,_bcce (color ,point ));};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_fgg :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_gfb .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fgg ;
};var _abb ,_def ,_cacd int ;if len (hexStr )==4{var _fef ,_dbg ,_eff int ;_badgd ,_ffab :=_f .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_fef ,&_dbg ,&_eff );if _ffab !=nil {_gfb .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_ffab );
return _fgg ;};if _badgd !=3{_gfb .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fgg ;};_abb =_fef *16+_fef ;_def =_dbg *16+_dbg ;_cacd =_eff *16+_eff ;}else {_dfe ,_dede :=_f .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_abb ,&_def ,&_cacd );
if _dede !=nil {_gfb .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fgg ;};if _dfe !=3{_gfb .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_dfe );
return _fgg ;};};_befcc :=float64 (_abb )/255.0;_afcb :=float64 (_def )/255.0;_eeec :=float64 (_cacd )/255.0;_fgg ._gbdd =_befcc ;_fgg ._bffe =_afcb ;_fgg ._dgdd =_eeec ;return _fgg ;};func (_cbbgd *templateProcessor )parseBackground (_cadfg *templateNode )(interface{},error ){_gbdab :=&Background {};
for _ ,_adce :=range _cadfg ._adbf .Attr {_baccg :=_adce .Value ;switch _dfcdc :=_adce .Name .Local ;_dfcdc {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_gbdab .FillColor =_cbbgd .parseColorAttr (_dfcdc ,_baccg );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_gbdab .BorderColor =_cbbgd .parseColorAttr (_dfcdc ,_baccg );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_gbdab .BorderSize =_cbbgd .parseFloatAttr (_dfcdc ,_baccg );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_cbada ,_caeaf ,_acfae ,_bgbbb :=_cbbgd .parseBorderRadiusAttr (_dfcdc ,_baccg );
_gbdab .SetBorderRadius (_cbada ,_caeaf ,_bgbbb ,_acfae );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_gbdab .BorderRadiusTopLeft =_cbbgd .parseFloatAttr (_dfcdc ,_baccg );
case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_gbdab .BorderRadiusTopRight =_cbbgd .parseFloatAttr (_dfcdc ,_baccg );case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_gbdab .BorderRadiusBottomLeft =_cbbgd .parseFloatAttr (_dfcdc ,_baccg );
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_gbdab .BorderRadiusBottomRight =_cbbgd .parseFloatAttr (_dfcdc ,_baccg );default:_cbbgd .nodeLogDebug (_cadfg ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_dfcdc );
};};return _gbdab ,nil ;};

// SetAngle sets the rotation angle of the text.
func (_gcfe *StyledParagraph )SetAngle (angle float64 ){_gcfe ._edgf =angle };func _fceeb (_fegbc *templateProcessor ,_ceag *templateNode )(interface{},error ){return _fegbc .parseDivision (_ceag );};

// SetAngle sets Image rotation angle in degrees.
func (_bacf *Image )SetAngle (angle float64 ){_bacf ._eadd =angle };

// NewTOCLine creates a new table of contents line with the default style.
func (_fdcc *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _cffef (number ,title ,page ,level ,_fdcc .NewTextStyle ());};

// SetDate sets the date of the invoice.
func (_adge *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_adge ._defb [1].Value =date ;return _adge ._defb [0],_adge ._defb [1];};

// Logo returns the logo of the invoice.
func (_eabdg *Invoice )Logo ()*Image {return _eabdg ._ddga };

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_becbda *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_becbda ._eagd =valign };func (_gabgd *templateProcessor )parseCellAlignmentAttr (_gdfdg ,_egdbd string )CellHorizontalAlignment {_gfb .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gdfdg ,_egdbd );
_eeeff :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_egdbd ];return _eeeff ;
};func (_beeb *Image )applyFitMode (_decbg float64 ){_decbg -=_beeb ._ceaa .Left +_beeb ._ceaa .Right ;switch _beeb ._caec {case FitModeFillWidth :_beeb .ScaleToWidth (_decbg );};};

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_bcba *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _gbfdg (colorPoints );};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_fbg *Block )ScaleToHeight (h float64 ){_gad :=h /_fbg ._ag ;_fbg .Scale (_gad ,_gad )};

// Notes returns the notes section of the invoice as a title-content pair.
func (_eegg *Invoice )Notes ()(string ,string ){return _eegg ._cgfce [0],_eegg ._cgfce [1]};

// ColorGrayFromArithmetic creates a Color from a grayscale value (0-1).
// Example:
//
//	gray := ColorGrayFromArithmetic(0.7)
func ColorGrayFromArithmetic (g float64 )Color {return grayColor {g }};

// SetColorRight sets border color for right.
func (_gea *border )SetColorRight (col Color ){_gea ._gca =col };

// SetWidth sets the width of the ellipse.
func (_adgd *Ellipse )SetWidth (width float64 ){_adgd ._efge =width };

// GeneratePageBlocks draw graphic svg into block.
func (_bebb *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fcae :=ctx ;_dgbfd :=_bebb ._dcce .IsRelative ();var _ecabe []*Block ;if _dgbfd {_gedeg :=1.0;_ggbb :=_bebb ._fcgg .Top ;if _bebb ._caga .Height > ctx .Height -_bebb ._fcgg .Top {_ecabe =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _fagf error ;if _ ,ctx ,_fagf =_agde ().GeneratePageBlocks (ctx );_fagf !=nil {return nil ,ctx ,_fagf ;};_ggbb =0;};ctx .X +=_bebb ._fcgg .Left +_gedeg ;ctx .Y +=_ggbb ;ctx .Width -=_bebb ._fcgg .Left +_bebb ._fcgg .Right +2*_gedeg ;ctx .Height -=_ggbb ;
}else {ctx .X =_bebb ._dgdc ;ctx .Y =_bebb ._gdde ;};_bdcfd :=_cc .NewContentCreator ();_bdcfd .Translate (0,ctx .PageHeight );_bdcfd .Scale (1,-1);_bdcfd .Translate (ctx .X ,ctx .Y );_gfab :=_bebb ._caga .Width /_bebb ._caga .ViewBox .W ;_bcga :=_bebb ._caga .Height /_bebb ._caga .ViewBox .H ;
_effe :=0.0;_afgg :=0.0;if _dgbfd {_effe =_bebb ._dgdc -(_bebb ._caga .ViewBox .X *_cf .Max (_gfab ,_bcga ));_afgg =_bebb ._gdde -(_bebb ._caga .ViewBox .Y *_cf .Max (_gfab ,_bcga ));};_bebb ._caga .ToContentCreator (_bdcfd ,_gfab ,_bcga ,_effe ,_afgg );
_gbgd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _gfdc :=_gbgd .addContentsByString (_bdcfd .String ());_gfdc !=nil {return nil ,ctx ,_gfdc ;};if _dgbfd {_ggef :=_bebb .Height ()+_bebb ._fcgg .Bottom ;ctx .Y +=_ggef ;ctx .Height -=_ggef ;}else {ctx =_fcae ;
};_ecabe =append (_ecabe ,_gbgd );return _ecabe ,ctx ,nil ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_cgfd *_bf .PolyBezierCurve ;_daab float64 ;_fbfd float64 ;_gbbdb Color ;};

// SetBorderColor sets the border color.
func (_aaecg *Polygon )SetBorderColor (color Color ){_aaecg ._bdcee .BorderColor =_dec (color )};

// Height returns the height of the list.
func (_gdcc *List )Height ()float64 {var _abab float64 ;for _ ,_gccbd :=range _gdcc ._gaegd {_abab +=_gccbd .ctxHeight (_gdcc .Width ());};return _abab ;};func (_agf *Block )addContentsByString (_cea string )error {_adbc :=_cc .NewContentStreamParser (_cea );
_eae ,_dcf :=_adbc .Parse ();if _dcf !=nil {return _dcf ;};_agf ._ebg .WrapIfNeeded ();_eae .WrapIfNeeded ();*_agf ._ebg =append (*_agf ._ebg ,*_eae ...);return nil ;};

// SetBorderOpacity sets the border opacity.
func (_gdfge *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_gdfge ._fbfd =opacity };func (_fdbgg *templateProcessor )nodeLogError (_ffgga *templateNode ,_aabgc string ,_degd ...interface{}){_gfb .Log .Error (_fdbgg .getNodeErrorLocation (_ffgga ,_aabgc ,_degd ...));
};

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_dbgf *Ellipse )FillOpacity ()float64 {return _dbgf ._eag };

// SetLineHeight sets the line height (1.0 default).
func (_febg *Paragraph )SetLineHeight (lineheight float64 ){_febg ._efbdc =lineheight };

// Style returns the style of the line.
func (_ebd *Line )Style ()_bf .LineStyle {return _ebd ._cdcb };

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// Positioning returns the type of positioning the line is set to use.
func (_efdd *Line )Positioning ()Positioning {return _efdd ._edec };func _cffb (_gcgd *templateProcessor ,_fcfd *templateNode )(interface{},error ){return _gcgd .parseChart (_fcfd );};

// SetCoords sets the center coordinates of the ellipse.
func (_gdbeg *Ellipse )SetCoords (xc ,yc float64 ){_gdbeg ._faac =xc ;_gdbeg ._ccag =yc };

// SetNumber sets the number of the invoice.
func (_fgebd *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_fgebd ._aafc [1].Value =number ;return _fgebd ._aafc [0],_fgebd ._aafc [1];};

// SetFillColor sets the fill color.
func (_gegf *Polygon )SetFillColor (color Color ){_gegf ._acegc =color ;_gegf ._bdcee .FillColor =_dec (color );};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_gebdbf *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_bgbbd :=&_gebdbf ._cgdcf ;_bgbbd .Left =left ;_bgbbd .Right =right ;_bgbbd .Top =top ;_bgbbd .Bottom =bottom ;};type templateTag struct{_dfefb map[string ]struct{};_cgeb func (*templateProcessor ,*templateNode )(interface{},error );
};func _gfee (_adgg float64 ,_ggaac float64 ,_fdbaa float64 ,_cefc float64 ,_cfde []*ColorPoint )*RadialShading {return &RadialShading {_efef :&shading {_cbcbg :ColorWhite ,_aagae :false ,_cfffe :[]bool {false ,false },_dcagf :_cfde },_caeg :_adgg ,_defbd :_ggaac ,_cegbd :_fdbaa ,_adfa :_cefc ,_bagda :AnchorCenter };
};

// String implements error interface.
func (_ccaf UnsupportedRuneError )Error ()string {return _ccaf .Message };

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;
);

// SetBorderWidth sets the border width.
func (_agebf *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_agebf ._cgfd .BorderWidth =borderWidth ;};func (_adec *Block )duplicate ()*Block {_gb :=&Block {};*_gb =*_adec ;_adb :=_cc .ContentStreamOperations {};_adb =append (_adb ,*_adec ._ebg ...);
_gb ._ebg =&_adb ;return _gb ;};func (_dagdgd *templateProcessor )parseHorizontalAlignmentAttr (_abagd ,_feed string )HorizontalAlignment {_gfb .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_abagd ,_feed );
_bdgge :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_feed ];return _bdgge ;};func _gcagf (_ecfd *templateProcessor ,_dbab *templateNode )(interface{},error ){return _ecfd .parseTextChunk (_dbab ,nil );
};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_ddfbe *Line )SetFitMode (fitMode FitMode ){_ddfbe ._effdb =fitMode };func (_gedd *templateProcessor )nodeLogDebug (_ggeab *templateNode ,_abdbc string ,_ccda ...interface{}){_gfb .Log .Debug (_gedd .getNodeErrorLocation (_ggeab ,_abdbc ,_ccda ...));
};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_dda *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dgg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_geaa ,_ ,_cdfe :=_dda .draw (_dgg ,"");if _cdfe !=nil {return nil ,ctx ,_cdfe ;};_cdfe =_dgg .addContentsByString (string (_geaa ));
if _cdfe !=nil {return nil ,ctx ,_cdfe ;};return []*Block {_dgg },ctx ,nil ;};

// SetStyleTop sets border style for top side.
func (_dac *border )SetStyleTop (style CellBorderStyle ){_dac ._bgf =style };

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_gbdd :_cf .Max (_cf .Min (r ,1.0),0.0),_bffe :_cf .Max (_cf .Min (g ,1.0),0.0),_dgdd :_cf .Max (_cf .Min (b ,1.0),0.0)};};

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_ffcd *Rectangle )GetCoords ()(float64 ,float64 ){return _ffcd ._gadgc ,_ffcd ._adac };

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_cbac *Rectangle )ScaleToHeight (h float64 ){_acdae :=_cbac ._cegcg /_cbac ._ggbab ;_cbac ._ggbab =h ;_cbac ._cegcg =h *_acdae ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_bebd *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fedg :=ctx ;if _bebd ._agbf .IsRelative (){ctx .X +=_bebd ._ggda .Left ;ctx .Y +=_bebd ._ggda .Top ;ctx .Width -=_bebd ._ggda .Left +_bebd ._ggda .Right ;ctx .Height -=_bebd ._ggda .Top ;
};_ebfe ,_aab ,_dcb :=_bebd ._fdgb .GeneratePageBlocks (ctx );if _dcb !=nil {return _ebfe ,ctx ,_dcb ;};ctx =_aab ;_bcda :=ctx .X ;_gbe :=ctx .Y -_bebd ._fdgb .Height ();_edae :=int64 (ctx .Page );_aaga :=_bebd .headingNumber ();_bbc :=_bebd .headingText ();
if _bebd ._adde {_cac :=_bebd ._dfgd .Add (_aaga ,_bebd ._ggf ,_ad .FormatInt (_edae ,10),_bebd ._fce );if _bebd ._dfgd ._daedd {_cac .SetLink (_edae ,_bcda ,_gbe );};};if _bebd ._dcg ==nil {_bebd ._dcg =_ed .NewOutlineItem (_bbc ,_ed .NewOutlineDest (_edae -1,_bcda ,_gbe ));
if _bebd ._bef !=nil {_bebd ._bef ._dcg .Add (_bebd ._dcg );}else {_bebd ._gbc .Add (_bebd ._dcg );};}else {_addc :=&_bebd ._dcg .Dest ;_addc .Page =_edae -1;_addc .X =_bcda ;_addc .Y =_gbe ;};for _ ,_fceb :=range _bebd ._age {_efab ,_cefd ,_fgec :=_fceb .GeneratePageBlocks (ctx );
if _fgec !=nil {return _ebfe ,ctx ,_fgec ;};if len (_efab )< 1{continue ;};_ebfe [len (_ebfe )-1].mergeBlocks (_efab [0]);_ebfe =append (_ebfe ,_efab [1:]...);ctx =_cefd ;};if _bebd ._agbf .IsRelative (){ctx .X =_fedg .X ;};if _bebd ._agbf .IsAbsolute (){return _ebfe ,_fedg ,nil ;
};return _ebfe ,ctx ,nil ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_ecff *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ecff ._acbfg .Left ,_ecff ._acbfg .Right ,_ecff ._acbfg .Top ,_ecff ._acbfg .Bottom ;};

// Link returns link information for this line.
func (_fcbfe *TOCLine )Link ()(_bdfab int64 ,_gacbc ,_gcdg float64 ){return _fcbfe ._bceb ,_fcbfe ._edacd ,_fcbfe ._gdedb ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_cbegf *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_defcd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gaec ,_bbee :=_defcd .setOpacity (_cbegf ._daab ,_cbegf ._fbfd );if _bbee !=nil {return nil ,ctx ,_bbee ;
};_adeb :=_cbegf ._cgfd ;_adeb .FillEnabled =_adeb .FillColor !=nil ;var (_beaea =ctx .PageHeight ;_dbcd =_adeb .Curves ;_eaac =make ([]_bf .CubicBezierCurve ,0,len (_adeb .Curves )););_edbb :=_ed .PdfRectangle {};for _abeb :=range _adeb .Curves {_cfegg :=_dbcd [_abeb ];
_cfegg .P0 .Y =_beaea -_cfegg .P0 .Y ;_cfegg .P1 .Y =_beaea -_cfegg .P1 .Y ;_cfegg .P2 .Y =_beaea -_cfegg .P2 .Y ;_cfegg .P3 .Y =_beaea -_cfegg .P3 .Y ;_eaac =append (_eaac ,_cfegg );_aefc :=_cfegg .GetBounds ();if _abeb ==0{_edbb =_aefc ;}else {_edbb .Llx =_cf .Min (_edbb .Llx ,_aefc .Llx );
_edbb .Lly =_cf .Min (_edbb .Lly ,_aefc .Lly );_edbb .Urx =_cf .Max (_edbb .Urx ,_aefc .Urx );_edbb .Ury =_cf .Max (_edbb .Ury ,_aefc .Ury );};};_adeb .Curves =_eaac ;defer func (){_adeb .Curves =_dbcd }();if _adeb .FillEnabled {_fedd :=_bfgc (_defcd ,_cbegf ._cgfd .FillColor ,_cbegf ._gbbdb ,func ()Rectangle {return Rectangle {_gadgc :_edbb .Llx ,_adac :_edbb .Lly ,_cegcg :_edbb .Width (),_ggbab :_edbb .Height ()};
});if _fedd !=nil {return nil ,ctx ,_fedd ;};};_dbce ,_ ,_bbee :=_adeb .Draw (_gaec );if _bbee !=nil {return nil ,ctx ,_bbee ;};if _bbee =_defcd .addContentsByString (string (_dbce ));_bbee !=nil {return nil ,ctx ,_bbee ;};return []*Block {_defcd },ctx ,nil ;
};

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_fded *shading ;_ggcfg *_ed .PdfRectangle ;_gcbca float64 ;};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;func (_bbd rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _bbd ._gbdd ,_bbd ._bffe ,_bbd ._dgdd };

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_dffgg float64 ;_acad float64 ;_fbfbg float64 ;_dbd float64 ;_cdba Color ;_cdcb _bf .LineStyle ;_efgda float64 ;_eedbb []int64 ;_deaa int64 ;_cdff float64 ;_edec Positioning ;_effdb FitMode ;_accae Margins ;};

// Height returns the total height of all rows.
func (_aece *Table )Height ()float64 {_bbeeg :=float64 (0.0);for _ ,_ccecd :=range _aece ._eegf {_bbeeg +=_ccecd ;};return _bbeeg ;};func (_fbbg *StyledParagraph )wrapWordChunks (){if !_fbbg ._bedga {return ;};var (_ecee []*TextChunk ;_cacb *_ed .PdfFont ;
);for _ ,_bgcd :=range _fbbg ._fcdf {_faae :=[]rune (_bgcd .Text );if _cacb ==nil {_cacb =_bgcd .Style .Font ;};_dagd :=_bgcd ._eefeb ;_acgbb :=_bgcd .VerticalAlignment ;if len (_ecee )> 0{if len (_faae )==1&&_bg .IsPunct (_faae [0])&&_bgcd .Style .Font ==_cacb {_beece :=[]rune (_ecee [len (_ecee )-1].Text );
_ecee [len (_ecee )-1].Text =string (append (_beece ,_faae [0]));continue ;}else {_ ,_bbfd :=_ad .Atoi (_bgcd .Text );if _bbfd ==nil {_bega :=[]rune (_ecee [len (_ecee )-1].Text );_bfeg :=len (_bega );if _bfeg >=2{_ ,_aeacg :=_ad .Atoi (string (_bega [_bfeg -2]));
if _aeacg ==nil &&_bg .IsPunct (_bega [_bfeg -1]){_ecee [len (_ecee )-1].Text =string (append (_bega ,_faae ...));continue ;};};};};};_fabf ,_fagd :=_gcgad (_bgcd .Text );if _fagd !=nil {_gfb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_fagd );
_fabf =[]string {_bgcd .Text };};for _ ,_abcf :=range _fabf {_ebfea :=NewTextChunk (_abcf ,_bgcd .Style );_ebfea ._eefeb =_eggfg (_dagd );_ebfea .VerticalAlignment =_acgbb ;_ecee =append (_ecee ,_ebfea );};_cacb =_bgcd .Style .Font ;};if len (_ecee )> 0{_fbbg ._fcdf =_ecee ;
};};func _ddebg (_fagc *templateProcessor ,_fage *templateNode )(interface{},error ){return _fagc .parseLine (_fage );};

// SetSideBorderStyle sets the cell's side border style.
func (_cfbge *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_cfbge ._bebdb =style ;_cfbge ._cbaca =style ;_cfbge ._gcecd =style ;_cfbge ._bfae =style ;case CellBorderSideTop :_cfbge ._bebdb =style ;
case CellBorderSideBottom :_cfbge ._cbaca =style ;case CellBorderSideLeft :_cfbge ._gcecd =style ;case CellBorderSideRight :_cfbge ._bfae =style ;};};

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_dace *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_dace ._cdg .Left =left ;_dace ._cdg .Right =right ;_dace ._cdg .Top =top ;_dace ._cdg .Bottom =bottom ;};func (_eface *templateProcessor )parseTextAlignmentAttr (_cegce ,_agfg string )TextAlignment {_gfb .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_cegce ,_agfg );
_agafa :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_agfg ];
return _agafa ;};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_dfee *Creator )PageFinalize (pageFinalizeFunc func (_adbcc PageFinalizeFunctionArgs )error ){_dfee ._cgbd =pageFinalizeFunc ;};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;func (_fcffe *TableCell )cloneProps (_aaac VectorDrawable )*TableCell {_gded :=*_fcffe ;_gded ._aeeee =_aaac ;return &_gded ;};func (_dada *templateProcessor )parseFloatArray (_bdcef ,_bagc string )[]float64 {_gfb .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bdcef ,_bagc );
_dacbg :=_de .Fields (_bagc );_gcge :=make ([]float64 ,0,len (_dacbg ));for _ ,_abea :=range _dacbg {_fgdgf ,_ :=_ad .ParseFloat (_abea ,64);_gcge =append (_gcge ,_fgdgf );};return _gcge ;};

// FitMode returns the fit mode of the line.
func (_feaa *Line )FitMode ()FitMode {return _feaa ._effdb };

// SetBorderColor sets the border color for the path.
func (_efag *FilledCurve )SetBorderColor (color Color ){_efag ._faeb =color };func _gbff ()*listItem {return &listItem {}};func _ccab (_gfefg *templateProcessor ,_fgfdgd *templateNode )(interface{},error ){return _gfefg .parsePageBreak (_fgfdgd );};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_gdcb *LinearShading )AddShadingResource (block *Block )(_dbgbb _gd .PdfObjectName ,_face error ){_cfee :=1;_dbgbb =_gd .PdfObjectName ("\u0053\u0068"+_ad .Itoa (_cfee ));for block ._ece .HasShadingByName (_dbgbb ){_cfee ++;_dbgbb =_gd .PdfObjectName ("\u0053\u0068"+_ad .Itoa (_cfee ));
};if _gaag :=block ._ece .SetShadingByName (_dbgbb ,_gdcb .shadingModel ().ToPdfObject ());_gaag !=nil {return "",_gaag ;};return _dbgbb ,nil ;};

// DashPattern returns the dash pattern of the line.
func (_deea *Line )DashPattern ()(_defa []int64 ,_fcbfb int64 ){return _deea ._eedbb ,_deea ._deaa };

// MoveY moves the drawing context to absolute position y.
func (_eacf *Creator )MoveY (y float64 ){_eacf ._abe .Y =y };

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_aafdd *Invoice )Sections ()[][2]string {return _aafdd ._fbbb };

// SetFillColor sets background color for border.
func (_ebfb *border )SetFillColor (col Color ){_ebfb ._bea =col };func _caefe (_gefcb map[string ]interface{},_babac ...interface{})(map[string ]interface{},error ){_gbaf :=len (_babac );if _gbaf %2!=0{return nil ,_gd .ErrRangeError ;};for _aadda :=0;_aadda < _gbaf ;
_aadda +=2{_fageg ,_afdedg :=_babac [_aadda ].(string );if !_afdedg {return nil ,_gd .ErrTypeError ;};_gefcb [_fageg ]=_babac [_aadda +1];};return _gefcb ,nil ;};

// SellerAddress returns the seller address used in the invoice template.
func (_ddee *Invoice )SellerAddress ()*InvoiceAddress {return _ddee ._gbee };

// FillColor returns the fill color of the rectangle.
func (_dggd *Rectangle )FillColor ()Color {return _dggd ._daage };

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_agggga *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_ababg :=NewTextChunk (text ,_agggga ._fbag );_ababg ._eefeb =_cgcg (url );return _agggga .appendChunk (_ababg );};

// SetWidth sets the width of the rectangle.
func (_acbd *Rectangle )SetWidth (width float64 ){_acbd ._cegcg =width };

// Width returns the width of the Paragraph.
func (_dbad *Paragraph )Width ()float64 {if _dbad ._cgbcg &&int (_dbad ._begf )> 0{return _dbad ._begf ;};return _dbad .getTextWidth ()/1000.0;};func _ffdfg (_feba *templateProcessor ,_cfgf *templateNode )(interface{},error ){return _feba .parseChapter (_cfgf );
};

// WriteToFile writes the Creator output to file specified by path.
func (_baef *Creator )WriteToFile (outputPath string )error {_ccdbg ,_acae :=_gf .Create (outputPath );if _acae !=nil {return _acae ;};defer _ccdbg .Close ();return _baef .Write (_ccdbg );};func _agde ()*PageBreak {return &PageBreak {}};

// NewTOC creates a new table of contents.
func (_cebc *Creator )NewTOC (title string )*TOC {_dedeg :=_cebc .NewTextStyle ();_dedeg .Font =_cebc ._efae ;return _faaec (title ,_cebc .NewTextStyle (),_dedeg );};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_dfc *Chart )SetPos (x ,y float64 ){_dfc ._gbea =PositionAbsolute ;_dfc ._bgce =x ;_dfc ._ggdf =y ;};func (_cbeda *Invoice )generateInformationBlocks (_bedea DrawContext )([]*Block ,DrawContext ,error ){_dbgd :=_cfeea (_cbeda ._dedg );_dbgd .SetMargins (0,0,0,20);
_aabb :=_cbeda .drawAddress (_cbeda ._gbee );_aabb =append (_aabb ,_dbgd );_aabb =append (_aabb ,_cbeda .drawAddress (_cbeda ._eefe )...);_faebb :=_bdf ();for _ ,_cbcfa :=range _aabb {_faebb .Add (_cbcfa );};_aaea :=_cbeda .drawInformation ();_cefdg :=_gegfb (2);
_cefdg .SetMargins (0,0,25,0);_dgedb :=_cefdg .NewCell ();_dgedb .SetIndent (0);_dgedb .SetContent (_faebb );_dgedb =_cefdg .NewCell ();_dgedb .SetContent (_aaea );return _cefdg .GeneratePageBlocks (_bedea );};

// SetSideBorderColor sets the cell's side border color.
func (_abfg *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_abfg ._bebf =col ;_abfg ._ddeb =col ;_abfg ._gdga =col ;_abfg ._ffgab =col ;case CellBorderSideTop :_abfg ._bebf =col ;case CellBorderSideBottom :_abfg ._ddeb =col ;
case CellBorderSideLeft :_abfg ._gdga =col ;case CellBorderSideRight :_abfg ._ffgab =col ;};};

// SetBuyerAddress sets the buyer address of the invoice.
func (_aeadb *Invoice )SetBuyerAddress (address *InvoiceAddress ){_aeadb ._eefe =address };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};func (_aagc *StyledParagraph )getLineMetrics (_ceaed int )(_bdef ,_abaa ,_becbd float64 ){if _aagc ._feab ==nil ||len (_aagc ._feab )==0{_aagc .wrapText ();};if _ceaed < 0||_ceaed > len (_aagc ._feab )-1{_gfb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_ceaed );
return 0,0,0;};_egge :=_aagc ._feab [_ceaed ];for _ ,_dgag :=range _egge {_cfbg :=_daegd (_dgag .Style .Font ,_dgag .Style .FontSize );if _cfbg ._faffg > _bdef {_bdef =_cfbg ._faffg ;};if _cfbg ._ccdgd < _becbd {_becbd =_cfbg ._ccdgd ;};if _fadfa :=_dgag .Style .FontSize ;
_fadfa > _abaa {_abaa =_fadfa ;};};return _bdef ,_abaa ,_becbd ;};

// SetStyleLeft sets border style for left side.
func (_adbgc *border )SetStyleLeft (style CellBorderStyle ){_adbgc ._ddda =style };

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_ebfg *Creator )NewPage ()*_ed .PdfPage {_cdbf :=_ebfg .newPage ();_ebfg ._fgdd =append (_ebfg ._fgdd ,_cdbf );_ebfg ._abe .Page ++;return _cdbf ;};type listItem struct{_cbgb VectorDrawable ;_afdbb TextChunk ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_eabd *Creator )NewImageFromGoImage (goimg _a .Image )(*Image ,error ){return _ddfb (goimg )};func (_aabea *StyledParagraph )getMaxLineWidth ()float64 {if _aabea ._feab ==nil ||len (_aabea ._feab )==0{_aabea .wrapText ();};var _aebg float64 ;for _ ,_gcbaf :=range _aabea ._feab {_befbb :=_aabea .getTextLineWidth (_gcbaf );
if _befbb > _aebg {_aebg =_befbb ;};};return _aebg ;};

// SetSideBorderWidth sets the cell's side border width.
func (_abgf *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_abgf ._defbe =width ;_abgf ._bdbcc =width ;_abgf ._fafbe =width ;_abgf ._agge =width ;case CellBorderSideTop :_abgf ._defbe =width ;case CellBorderSideBottom :_abgf ._bdbcc =width ;
case CellBorderSideLeft :_abgf ._fafbe =width ;case CellBorderSideRight :_abgf ._agge =width ;};};func (_aecc *Creator )getActivePage ()*_ed .PdfPage {if _aecc ._eed ==nil {if len (_aecc ._fgdd )==0{return nil ;};return _aecc ._fgdd [len (_aecc ._fgdd )-1];
};return _aecc ._eed ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_bcgcg *TextChunk )SetAnnotation (annotation *_ed .PdfAnnotation ){_bcgcg ._eefeb =annotation };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_dbaa *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _gdcd (x1 ,y1 ,cx ,cy ,x2 ,y2 );};type fontMetrics struct{_faffg float64 ;_ebdef float64 ;_ddbda float64 ;_ccdgd float64 ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_befaf *TOC )SetLinePageStyle (style TextStyle ){_befaf ._cffeag =style };

// Vertical returns total vertical (top + bottom) margin.
func (_bgag *Margins )Vertical ()float64 {return _bgag .Bottom +_bgag .Top };func (_be *Block )setOpacity (_aad float64 ,_fbc float64 )(string ,error ){if (_aad < 0||_aad >=1.0)&&(_fbc < 0||_fbc >=1.0){return "",nil ;};_bee :=0;_gfa :=_f .Sprintf ("\u0047\u0053\u0025\u0064",_bee );
for _be ._ece .HasExtGState (_gd .PdfObjectName (_gfa )){_bee ++;_gfa =_f .Sprintf ("\u0047\u0053\u0025\u0064",_bee );};_bb :=_gd .MakeDict ();if _aad >=0&&_aad < 1.0{_bb .Set ("\u0063\u0061",_gd .MakeFloat (_aad ));};if _fbc >=0&&_fbc < 1.0{_bb .Set ("\u0043\u0041",_gd .MakeFloat (_fbc ));
};_ecf :=_be ._ece .AddExtGState (_gd .PdfObjectName (_gfa ),_bb );if _ecf !=nil {return "",_ecf ;};return _gfa ,nil ;};func _cdec (_bgee ,_cfdad TextStyle )*Invoice {_aefgb :=&Invoice {_cfaa :"\u0049N\u0056\u004f\u0049\u0043\u0045",_fcfa :"\u002c\u0020",_dedg :_bgee ,_edab :_cfdad };
_aefgb ._gbee =&InvoiceAddress {Separator :_aefgb ._fcfa };_aefgb ._eefe =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_aefgb ._fcfa };_bdga :=ColorRGBFrom8bit (245,245,245);_dfcf :=ColorRGBFrom8bit (155,155,155);_aefgb ._cedg =_cfdad ;
_aefgb ._cedg .Color =_dfcf ;_aefgb ._cedg .FontSize =20;_aefgb ._eabg =_bgee ;_aefgb ._fgdg =_cfdad ;_aefgb ._ebbe =_bgee ;_aefgb ._fcb =_cfdad ;_aefgb ._fffb =_aefgb .NewCellProps ();_aefgb ._fffb .BackgroundColor =_bdga ;_aefgb ._fffb .TextStyle =_cfdad ;
_aefgb ._dbff =_aefgb .NewCellProps ();_aefgb ._dbff .TextStyle =_cfdad ;_aefgb ._dbff .BackgroundColor =_bdga ;_aefgb ._dbff .BorderColor =_bdga ;_aefgb ._afeb =_aefgb .NewCellProps ();_aefgb ._afeb .BorderColor =_bdga ;_aefgb ._afeb .BorderSides =[]CellBorderSide {CellBorderSideBottom };
_aefgb ._afeb .Alignment =CellHorizontalAlignmentRight ;_aefgb ._bdff =_aefgb .NewCellProps ();_aefgb ._bdff .Alignment =CellHorizontalAlignmentRight ;_aefgb ._aafc =[2]*InvoiceCell {_aefgb .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_aefgb ._fffb ),_aefgb .newCell ("",_aefgb ._fffb )};
_aefgb ._defb =[2]*InvoiceCell {_aefgb .newCell ("\u0044\u0061\u0074\u0065",_aefgb ._fffb ),_aefgb .newCell ("",_aefgb ._fffb )};_aefgb ._beff =[2]*InvoiceCell {_aefgb .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_aefgb ._fffb ),_aefgb .newCell ("",_aefgb ._fffb )};
_aefgb ._abgd =[2]*InvoiceCell {_aefgb .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_aefgb ._bdff ),_aefgb .newCell ("",_aefgb ._bdff )};_abcb :=_aefgb ._bdff ;_abcb .TextStyle =_cfdad ;_abcb .BackgroundColor =_bdga ;_abcb .BorderColor =_bdga ;
_aefgb ._acgc =[2]*InvoiceCell {_aefgb .newCell ("\u0054\u006f\u0074a\u006c",_abcb ),_aefgb .newCell ("",_abcb )};_aefgb ._cgfce =[2]string {"\u004e\u006f\u0074e\u0073",""};_aefgb ._eged =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_aefgb ._dfdgd =[]*InvoiceCell {_aefgb .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_aefgb .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_aefgb .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_aefgb .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _aefgb ;};func (_dcdb *templateProcessor )parseListItem (_ebcee *templateNode )(interface{},error ){if _ebcee ._gfggb ==nil {_dcdb .nodeLogError (_ebcee ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_adee ;};_ddbd ,_addcf :=_ebcee ._gfggb ._cagcg .(*List );if !_addcf {_dcdb .nodeLogError (_ebcee ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_adee ;};_ggec :=_gbff ();_ggec ._afdbb =_ddbd ._defad ;return _ggec ,nil ;};

// SetRowPosition sets cell row position.
func (_afbf *TableCell )SetRowPosition (row int ){_afbf ._ggccd =row };type pageTransformations struct{_dab *_af .Matrix ;_gcgc bool ;_bbce bool ;};func (_eaaed *Image )makeXObject ()error {_adaf ,_cggg :=_ed .NewXObjectImageFromImageLazy (_eaaed ._bdec ,nil ,_eaaed ._afab ,_eaaed ._fcaf );
if _cggg !=nil {_gfb .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cggg );return _cggg ;};_eaaed ._abga =_adaf ;
return nil ;};func (_gaed *TextChunk )clone ()*TextChunk {_afgag :=*_gaed ;_afgag ._eefeb =_eggfg (_gaed ._eefeb );return &_afgag ;};func _dccg (_fgff *templateProcessor ,_dcac *templateNode )(interface{},error ){return _fgff .parseTableCell (_dcac );};


// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_dgabf *Paragraph )SetColor (col Color ){_dgabf ._ebfca =col };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_dfcff *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_gaaeg :=&_dfcff ._fbaf ._acbfg ;return _dfcff ._gabdg ,_gaaeg .Right ,_gaaeg .Top ,_gaaeg .Bottom ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cgee *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dfdbe :=ctx ;_gfcg :=[]func (_feef DrawContext )([]*Block ,DrawContext ,error ){_cgee .generateHeaderBlocks ,_cgee .generateInformationBlocks ,_cgee .generateLineBlocks ,_cgee .generateTotalBlocks ,_cgee .generateNoteBlocks };
var _ggfc []*Block ;for _ ,_bcdb :=range _gfcg {_bacee ,_eagf ,_ebce :=_bcdb (ctx );if _ebce !=nil {return _ggfc ,ctx ,_ebce ;};if len (_ggfc )==0{_ggfc =_bacee ;}else if len (_bacee )> 0{_ggfc [len (_ggfc )-1].mergeBlocks (_bacee [0]);_ggfc =append (_ggfc ,_bacee [1:]...);
};ctx =_eagf ;};if _cgee ._gaeb .IsRelative (){ctx .X =_dfdbe .X ;};if _cgee ._gaeb .IsAbsolute (){return _ggfc ,_dfdbe ,nil ;};return _ggfc ,ctx ,nil ;};

// SetAngle sets the rotation angle in degrees.
func (_deb *Block )SetAngle (angleDeg float64 ){_deb ._agc =angleDeg };

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ebg *_cc .ContentStreamOperations ;_ece *_ed .PdfPageResources ;_ea Positioning ;_edd ,_dcc float64 ;_bc float64 ;_ag float64 ;_agc float64 ;_fe Margins ;_ba []*_ed .PdfAnnotation ;};

// List represents a list of items.
// The representation of a list item is as follows:
//
//	[marker] [content]
//
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_gaegd []*listItem ;_afded Margins ;_defad TextChunk ;_gdfg float64 ;_edag bool ;_cegd Positioning ;_aaagc TextStyle ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//
//	red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_dag :_cf .Min (float64 (c ),100)/100.0,_acg :_cf .Min (float64 (m ),100)/100.0,_befc :_cf .Min (float64 (y ),100)/100.0,_dgde :_cf .Min (float64 (k ),100)/100.0};};func _aggga (_fdfa *templateProcessor ,_ccccf *templateNode )(interface{},error ){return _fdfa .parseChapterHeading (_ccccf );
};

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// RotatedSize returns the width and height of the rotated block.
func (_ac *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_ecb ,_aac :=_dddge (_ac ._bc ,_ac ._ag ,_ac ._agc );return _ecb ,_aac ;};func (_bggd *TOCLine )prepareParagraph (_eccfd *StyledParagraph ,_eedc DrawContext ){_beadf :=_bggd .Title .Text ;if _bggd .Number .Text !=""{_beadf ="\u0020"+_beadf ;
};_beadf +="\u0020";_decac :=_bggd .Page .Text ;if _decac !=""{_decac ="\u0020"+_decac ;};_eccfd ._fcdf =[]*TextChunk {{Text :_bggd .Number .Text ,Style :_bggd .Number .Style ,_eefeb :_bggd .getLineLink ()},{Text :_beadf ,Style :_bggd .Title .Style ,_eefeb :_bggd .getLineLink ()},{Text :_decac ,Style :_bggd .Page .Style ,_eefeb :_bggd .getLineLink ()}};
_eccfd .wrapText ();_ggdac :=len (_eccfd ._feab );if _ggdac ==0{return ;};_dbgbbe :=_eedc .Width *1000-_eccfd .getTextLineWidth (_eccfd ._feab [_ggdac -1]);_dedga :=_eccfd .getTextLineWidth ([]*TextChunk {&_bggd .Separator });_cece :=int (_dbgbbe /_dedga );
_gbeea :=_de .Repeat (_bggd .Separator .Text ,_cece );_aaeed :=_bggd .Separator .Style ;_egbeg :=_eccfd .Insert (2,_gbeea );_egbeg .Style =_aaeed ;_egbeg ._eefeb =_bggd .getLineLink ();_dbgbbe =_dbgbbe -float64 (_cece )*_dedga ;if _dbgbbe > 500{_fbca ,_bggdg :=_aaeed .Font .GetRuneMetrics (' ');
if _bggdg &&_dbgbbe > _fbca .Wx {_gbge :=int (_dbgbbe /_fbca .Wx );if _gbge > 0{_abec :=_aaeed ;_abec .FontSize =1;_egbeg =_eccfd .Insert (2,_de .Repeat ("\u0020",_gbge ));_egbeg .Style =_abec ;_egbeg ._eefeb =_bggd .getLineLink ();};};};};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_ggcc []VectorDrawable ;_dgf Positioning ;_baad Margins ;_babd Margins ;_afdb bool ;_dffg bool ;_aadg *Background ;};

// SetMargins sets the margins of the paragraph.
func (_bcfc *List )SetMargins (left ,right ,top ,bottom float64 ){_bcfc ._afded .Left =left ;_bcfc ._afded .Right =right ;_bcfc ._afded .Top =top ;_bcfc ._afded .Bottom =bottom ;};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_gbfe *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_gbfe ._cdcg =align ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// NewSubchapter creates a new child chapter with the specified title.
func (_dbfd *Chapter )NewSubchapter (title string )*Chapter {_eece :=_deac (_dbfd ._fdgb ._bbcb );_eece .FontSize =14;_dbfd ._ecab ++;_bffad :=_gdf (_dbfd ,_dbfd ._dfgd ,_dbfd ._gbc ,title ,_dbfd ._ecab ,_eece );_dbfd .Add (_bffad );return _bffad ;};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_ddcba *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// Columns returns all the columns in the invoice line items table.
func (_ddgb *Invoice )Columns ()[]*InvoiceCell {return _ddgb ._dfdgd };

// SetLineColor sets the line color.
func (_efca *Polyline )SetLineColor (color Color ){_efca ._daag .LineColor =_dec (color )};func _gdcd (_ddbe ,_gba ,_bgfd ,_cgfg ,_ebfd ,_bbbc float64 )*Curve {_bebgg :=&Curve {};_bebgg ._bfcg =_ddbe ;_bebgg ._baeb =_gba ;_bebgg ._dcbe =_bgfd ;_bebgg ._adg =_cgfg ;
_bebgg ._egbc =_ebfd ;_bebgg ._bdba =_bbbc ;_bebgg ._fcadf =ColorBlack ;_bebgg ._cgbde =1.0;return _bebgg ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_fea *Block )DrawTemplate (c *Creator ,r _eb .Reader ,data interface{},options *TemplateOptions )error {return _gcagg (c ,r ,data ,options ,_fea );};func (_gfda *Paragraph )getTextWidth ()float64 {_eacaee :=0.0;for _ ,_bbfcc :=range _gfda ._bdfc {if _bbfcc =='\u000A'{continue ;
};_afb ,_bddcg :=_gfda ._bbcb .GetRuneMetrics (_bbfcc );if !_bddcg {_gfb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_bbfcc ,_bbfcc );
return -1;};_eacaee +=_gfda ._afffc *_afb .Wx ;};return _eacaee ;};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_daae *Table )MultiCell (rowspan ,colspan int )*TableCell {_daae ._dcef ++;_gbfec :=(_daae .moveToNextAvailableCell ()-1)%(_daae ._dfeg )+1;_cadfc :=(_daae ._dcef -1)/_daae ._dfeg +1;for _cadfc > _daae ._egged {_daae ._egged ++;_daae ._eegf =append (_daae ._eegf ,_daae ._fgac );
};_eecg :=&TableCell {};_eecg ._ggccd =_cadfc ;_eecg ._eafa =_gbfec ;_eecg ._bgeed =5;_eecg ._gcecd =CellBorderStyleNone ;_eecg ._beaee =_bf .LineStyleSolid ;_eecg ._gffac =CellHorizontalAlignmentLeft ;_eecg ._eagd =CellVerticalAlignmentTop ;_eecg ._fafbe =0;
_eecg ._bdbcc =0;_eecg ._agge =0;_eecg ._defbe =0;_aefcg :=ColorBlack ;_eecg ._gdga =_aefcg ;_eecg ._ddeb =_aefcg ;_eecg ._ffgab =_aefcg ;_eecg ._bebf =_aefcg ;if rowspan < 1{_gfb .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_bdafc :=_daae ._egged -(_eecg ._ggccd -1);if rowspan > _bdafc {_gfb .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_bdafc );
_daae ._egged +=rowspan -1;for _adea :=0;_adea <=rowspan -_bdafc ;_adea ++{_daae ._eegf =append (_daae ._eegf ,_daae ._fgac );};};for _cadd :=0;_cadd < colspan &&_gbfec +_cadd -1< len (_daae ._agdgb );_cadd ++{_daae ._agdgb [_gbfec +_cadd -1]=rowspan -1;
};_eecg ._effeb =rowspan ;if colspan < 1{_gfb .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_bcfaa :=_daae ._dfeg -(_eecg ._eafa -1);if colspan > _bcfaa {_gfb .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_bcfaa );
colspan =_bcfaa ;};_eecg ._edaeg =colspan ;_daae ._dcef +=colspan -1;_daae ._cfcdg =append (_daae ._cfcdg ,_eecg );_eecg ._afbd =_daae ;return _eecg ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};func (_dfdbd *Table )wrapContent (_acdbc DrawContext )error {if _dfdbd ._egegc {return nil ;};_dfdbd .sortCells ();_fffbc :=func (_bfbca *TableCell ,_bacgb int ,_aabf int ,_ccca int )(_aecd int ){if _ccca < 1{return -1;
};_fadaa :=0;for _gdcdb :=_aabf +1;_gdcdb < len (_dfdbd ._cfcdg )-1;_gdcdb ++{_bagae :=_dfdbd ._cfcdg [_gdcdb ];if _bagae ._ggccd ==_ccca &&_fadaa !=_aabf {_fadaa =_gdcdb ;if (_bagae ._eafa < _bfbca ._eafa &&_dfdbd ._dfeg > _bagae ._eafa )||_bfbca ._eafa < _dfdbd ._dfeg {continue ;
};break ;};};_acadf :=float64 (0.0);for _gaab :=0;_gaab < _bfbca ._effeb ;_gaab ++{_acadf +=_dfdbd ._eegf [_bfbca ._ggccd +_gaab -1];};_cdag :=_bfbca .width (_dfdbd ._dbeeb ,_acdbc .Width );var (_egdd VectorDrawable ;_ccagf =false ;);switch _fadc :=_bfbca ._aeeee .(type ){case *StyledParagraph :_eaad :=_acdbc ;
_eaad .Height =_cf .Floor (_acadf -_fadc ._acbfg .Top -_fadc ._acbfg .Bottom -0.5*_fadc .getTextHeight ());_eaad .Width =_cdag ;_edagc ,_fedaf ,_gecf :=_fadc .split (_eaad );if _gecf !=nil {_gfb .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_gecf .Error ());
};if _edagc !=nil &&_fedaf !=nil {_dfdbd ._cfcdg [_aabf ]._aeeee =_edagc ;_egdd =_fedaf ;_ccagf =true ;};};_dfdbd ._cfcdg [_aabf ]._effeb =_bfbca ._effeb ;_acdbc .Height =_acdbc .PageHeight -_acdbc .Margins .Top -_acdbc .Margins .Bottom ;_dedfc :=_bfbca .cloneProps (nil );
if _ccagf {_dedfc ._aeeee =_egdd ;};_dedfc ._effeb =_bacgb ;_dedfc ._ggccd =_ccca +1;_dedfc ._eafa =_bfbca ._eafa ;if _dedfc ._ggccd +_dedfc ._effeb -1> _dfdbd ._egged {for _eceac :=_dfdbd ._egged ;_eceac < _dedfc ._ggccd +_dedfc ._effeb -1;_eceac ++{_dfdbd ._egged ++;
_dfdbd ._eegf =append (_dfdbd ._eegf ,_dfdbd ._fgac );};};_dfdbd ._cfcdg =append (_dfdbd ._cfcdg [:_fadaa +1],append ([]*TableCell {_dedfc },_dfdbd ._cfcdg [_fadaa +1:]...)...);return _fadaa +1;};_ebeff :=func (_dcgd *TableCell ,_bbggf int ,_eabbb int ,_cefe float64 )(_acfd int ){_fbfcb :=_dcgd .width (_dfdbd ._dbeeb ,_acdbc .Width );
_egga :=_cefe ;_gfbgce :=1;_debfc :=_acdbc .Height ;if _debfc > 0{for _egga > _debfc {_egga -=_acdbc .Height ;_debfc =_acdbc .PageHeight -_acdbc .Margins .Top -_acdbc .Margins .Bottom ;_gfbgce ++;};};var (_ccfd VectorDrawable ;_bccb =false ;);switch _fgce :=_dcgd ._aeeee .(type ){case *StyledParagraph :_eagb :=_acdbc ;
_eagb .Height =_cf .Floor (_acdbc .Height -_fgce ._acbfg .Top -_fgce ._acbfg .Bottom -0.5*_fgce .getTextHeight ());_eagb .Width =_fbfcb ;_bfcfe ,_bddfb ,_ebfdec :=_fgce .split (_eagb );if _ebfdec !=nil {_gfb .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_ebfdec .Error ());
};if _bfcfe !=nil &&_bddfb !=nil {_dfdbd ._cfcdg [_bbggf ]._aeeee =_bfcfe ;_ccfd =_bddfb ;_bccb =true ;};};if _gfbgce < 2{return -1;};if _dfdbd ._cfcdg [_bbggf ]._ggccd +_gfbgce -1> _dfdbd ._egged {for _cbbd :=0;_cbbd < _gfbgce ;_cbbd ++{_dfdbd ._egged ++;
_dfdbd ._eegf =append (_dfdbd ._eegf ,_dfdbd ._fgac );};};_baeeg :=_cefe /float64 (_gfbgce );for _dafffb :=0;_dafffb < _gfbgce ;_dafffb ++{_dfdbd ._eegf [_eabbb +_dafffb -1]=_baeeg ;};_acdbc .Height =_acdbc .PageHeight -_acdbc .Margins .Top -_acdbc .Margins .Bottom ;
_bdfag :=_dcgd .cloneProps (nil );if _bccb {_bdfag ._aeeee =_ccfd ;};_bdfag ._effeb =1;_bdfag ._ggccd =_eabbb +_gfbgce -1;_bdfag ._eafa =_dcgd ._eafa ;_dfdbd ._cfcdg =append (_dfdbd ._cfcdg ,_bdfag );return len (_dfdbd ._cfcdg );};_egdc :=1;_fcag :=-1;
for _ebffb :=0;_ebffb < len (_dfdbd ._cfcdg );_ebffb ++{_abac :=_dfdbd ._cfcdg [_ebffb ];if _fcag ==_ebffb {_egdc =_abac ._ggccd ;};if _abac ._effeb < 2{if _babc :=_dfdbd ._eegf [_abac ._ggccd -1];_babc > _acdbc .Height {_fcag =_ebeff (_abac ,_ebffb ,_abac ._ggccd ,_babc );
continue ;};continue ;};_bdgdd :=float64 (0);for _fcaae :=0;_fcaae < _abac ._effeb ;_fcaae ++{_bdgdd +=_dfdbd ._eegf [_abac ._ggccd +_fcaae -1];};_daad :=float64 (0);for _ababgg :=_egdc -1;_ababgg < _abac ._ggccd -1;_ababgg ++{_daad +=_dfdbd ._eegf [_ababgg ];
};if _bdgdd <=(_acdbc .Height -_daad ){continue ;};_aabgd :=float64 (0.0);_feeab :=_abac ._effeb ;_gabf :=-1;_fafeb :=1;for _eefac :=1;_eefac <=_abac ._effeb ;_eefac ++{if (_aabgd +_dfdbd ._eegf [_abac ._ggccd +_eefac -2])> (_acdbc .Height -_daad ){_fafeb --;
break ;};_gabf =_abac ._ggccd +_eefac -1;_feeab =_abac ._effeb -_eefac ;_aabgd +=_dfdbd ._eegf [_abac ._ggccd +_eefac -2];_fafeb ++;};if _abac ._effeb ==_feeab {_acdbc .Height =_acdbc .PageHeight -_acdbc .Margins .Top -_acdbc .Margins .Bottom ;_egdc =_abac ._ggccd ;
_ebffb --;continue ;};if _feeab > 0&&_abac ._effeb > _fafeb {_abac ._effeb =_fafeb ;_fcag =_fffbc (_abac ,_feeab ,_ebffb ,_gabf );if _ebffb +1==_fcag {_ebffb --;};};_egdc =_abac ._ggccd ;};_dfdbd .sortCells ();return nil ;};func (_fdfe *pageTransformations )applyFlip (_cae *_ed .PdfPage )error {_ffebd ,_fcdd :=_fdfe ._gcgc ,_fdfe ._bbce ;
if !_ffebd &&!_fcdd {return nil ;};if _cae ==nil {return _e .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_ddbb ,_bdc :=_cae .GetMediaBox ();if _bdc !=nil {return _bdc ;};_gbca ,_degff :=_ddbb .Width (),_ddbb .Height ();
_bbf ,_bdc :=_cae .GetRotate ();if _bdc !=nil {_gfb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_bdc .Error ());
};if _ege :=_bbf %360!=0&&_bbf %90==0;_ege {if _abd :=(360+_bbf %360)%360;_abd ==90||_abd ==270{_ffebd ,_fcdd =_fcdd ,_ffebd ;};};_afd ,_eaca :=1.0,0.0;if _ffebd {_afd ,_eaca =-1.0,-_gbca ;};_ccc ,_ggcf :=1.0,0.0;if _fcdd {_ccc ,_ggcf =-1.0,-_degff ;};
_fcca :=_cc .NewContentCreator ().Scale (_afd ,_ccc ).Translate (_eaca ,_ggcf );_fcfg ,_bdc :=_gd .MakeStream (_fcca .Bytes (),_gd .NewFlateEncoder ());if _bdc !=nil {return _bdc ;};_ccde :=_gd .MakeArray (_fcfg );_ccde .Append (_cae .GetContentStreamObjs ()...);
_cae .Contents =_ccde ;return nil ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cggc *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _cggc ._aafc [0],_cggc ._aafc [1]};

// GetOptimizer returns current PDF optimizer.
func (_abg *Creator )GetOptimizer ()_ed .Optimizer {return _abg ._affc };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_gaadc *Creator )NewTextStyle ()TextStyle {return _deac (_gaadc ._egc )};

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_cegfg Color ;_bddag float64 ;};

// SetPos sets absolute positioning with specified coordinates.
func (_fegg *StyledParagraph )SetPos (x ,y float64 ){_fegg ._cbgac =PositionAbsolute ;_fegg ._fdbg =x ;_fegg ._ccac =y ;};

// GeneratePageBlocks generates a page break block.
func (_fcgga *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_agbc :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_bgae :=ctx ;_bgae .Y =ctx .Margins .Top ;
_bgae .X =ctx .Margins .Left ;_bgae .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_bgae .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_bgae ;return _agbc ,ctx ,nil ;};

// SetBorderRadius sets the radius of the background corners.
func (_dc *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_dc .BorderRadiusTopLeft =topLeft ;_dc .BorderRadiusTopRight =topRight ;_dc .BorderRadiusBottomLeft =bottomLeft ;_dc .BorderRadiusBottomRight =bottomRight ;};

// GetRowHeight returns the height of the specified row.
func (_acgge *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_acgge ._eegf ){return 0,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _acgge ._eegf [row -1],nil ;
};

// AppendCurve appends a Bezier curve to the filled curve.
func (_afcc *FilledCurve )AppendCurve (curve _bf .CubicBezierCurve )*FilledCurve {_afcc ._dabe =append (_afcc ._dabe ,curve );return _afcc ;};func (_fecg *pageTransformations )transformPage (_ffcc *_ed .PdfPage )error {if _gfcb :=_fecg .applyFlip (_ffcc );
_gfcb !=nil {return _gfcb ;};return nil ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_ccggg *TOC )SetLineNumberStyle (style TextStyle ){_ccggg ._ccggc =style };func (_gdcfg *templateProcessor )addNodeText (_cddgc *templateNode ,_abbf string )error {_gaaf :=_cddgc ._cagcg ;if _gaaf ==nil {return nil ;};switch _dabbf :=_gaaf .(type ){case *TextChunk :_dabbf .Text =_abbf ;
case *Paragraph :switch _cddgc ._adbf .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _cddgc ._gfggb !=nil {if _deef ,_ebgg :=_cddgc ._gfggb ._cagcg .(*Chapter );_ebgg {_deef ._ggf =_abbf ;_dabbf .SetText (_deef .headingText ());
};};default:_dabbf .SetText (_abbf );};};return nil ;};

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_fcef *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_fcef ._ddfc .Left =left ;_fcef ._ddfc .Right =right ;_fcef ._ddfc .Top =top ;_fcef ._ddfc .Bottom =bottom ;};func (_fcdbg *templateProcessor )parseCellVerticalAlignmentAttr (_afaf ,_dcfc string )CellVerticalAlignment {_gfb .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_afaf ,_dcfc );
_afad :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_dcfc ];return _afad ;};type rgbColor struct{_gbdd ,_bffe ,_dgdd float64 };
func (_bccee *TextStyle )horizontalScale ()float64 {return _bccee .HorizontalScaling /100};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_fcdf []*TextChunk ;_beafc TextStyle ;_fbag TextStyle ;_fgfd TextAlignment ;_cdcg TextVerticalAlignment ;_agcdg float64 ;_eagfa bool ;_bcdba float64 ;_bedga bool ;_cdebe bool ;_abafe TextOverflow ;_edgf float64 ;_acbfg Margins ;
_cbgac Positioning ;_fdbg float64 ;_ccac float64 ;_beec float64 ;_gfea float64 ;_feab [][]*TextChunk ;_abdc func (_bdcff *StyledParagraph ,_cddc DrawContext );};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_abdaef *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_abdaef ._becbb =&_ed .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _ge .ChartRenderable )*Chart {return _fdgc (chart )};func _deac (_fgfeg *_ed .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_fgfeg ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};func _bfgc (_abgag *Block ,_gbfd _ed .PdfColor ,_acdee Color ,_dcbad func ()Rectangle )error {switch _beaa :=_gbfd .(type ){case *_ed .PdfColorPatternType2 :_dgdce ,_gbfg :=_acdee .(*LinearShading );if !_gbfg {return _f .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");
};_decg :=_dcbad ();_dgdce .SetBoundingBox (_decg ._gadgc ,_decg ._adac ,_decg ._cegcg ,_decg ._ggbab );_cgade ,_eefed :=_dgdce .AddPatternResource (_abgag );if _eefed !=nil {return _f .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_eefed );
};_beaa .PatternName =_cgade ;case *_ed .PdfColorPatternType3 :_dabbe ,_gbag :=_acdee .(*RadialShading );if !_gbag {return _f .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_cfcef :=_dcbad ();_dabbe .SetBoundingBox (_cfcef ._gadgc ,_cfcef ._adac ,_cfcef ._cegcg ,_cfcef ._ggbab );_cacaf ,_ebfdb :=_dabbe .AddPatternResource (_abgag );if _ebfdb !=nil {return _f .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_ebfdb );
};_beaa .PatternName =_cacaf ;};return nil ;};func (_baa *Block )transform (_dae _af .Matrix ){_edf :=_cc .NewContentCreator ().Add_cm (_dae [0],_dae [1],_dae [3],_dae [4],_dae [6],_dae [7]).Operations ();*_baa ._ebg =append (*_edf ,*_baa ._ebg ...);_baa ._ebg .WrapIfNeeded ();
};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_aff *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aff ._ggda .Left ,_aff ._ggda .Right ,_aff ._ggda .Top ,_aff ._ggda .Bottom ;};

// Height returns the current page height.
func (_gcbb *Creator )Height ()float64 {return _gcbb ._adc };

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_efecf *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_efecf ._dfeg {_gfb .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_efecf ._dbeeb =widths ;return nil ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_ed .PdfPage )(*Block ,error ){_cfg :=&Block {};_db ,_ae :=page .GetAllContentStreams ();if _ae !=nil {return nil ,_ae ;};_aa :=_cc .NewContentStreamParser (_db );_bff ,_ae :=_aa .Parse ();if _ae !=nil {return nil ,_ae ;};_bff .WrapIfNeeded ();
_cfg ._ebg =_bff ;if page .Resources !=nil {_cfg ._ece =page .Resources ;}else {_cfg ._ece =_ed .NewPdfPageResources ();};_gfbd ,_ae :=page .GetMediaBox ();if _ae !=nil {return nil ,_ae ;};if _gfbd .Llx !=0||_gfbd .Lly !=0{_cfg .translate (-_gfbd .Llx ,_gfbd .Lly );
};_cfg ._bc =_gfbd .Urx -_gfbd .Llx ;_cfg ._ag =_gfbd .Ury -_gfbd .Lly ;if page .Rotate !=nil {_cfg ._agc =-float64 (*page .Rotate );};return _cfg ,nil ;};func _badc (_fbgge []_bf .Point )*Polyline {return &Polyline {_daag :&_bf .Polyline {Points :_fbgge ,LineColor :_ed .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_gcaa :1.0};
};

// GeneratePageBlocks implements drawable interface.
func (_egba *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gcab :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ffgc :=_egba ._dgd ;_bfc :=ctx .PageHeight -_egba ._bce ;if _egba ._bea !=nil {_cdeg :=_bf .Rectangle {Opacity :1.0,X :_egba ._dgd ,Y :ctx .PageHeight -_egba ._bce -_egba ._cff ,Height :_egba ._cff ,Width :_egba ._adf };
_cdeg .FillEnabled =true ;_dfg :=_dec (_egba ._bea );_ddb :=_bfgc (_gcab ,_dfg ,_egba ._bea ,func ()Rectangle {return Rectangle {_gadgc :_cdeg .X ,_adac :_cdeg .Y ,_cegcg :_cdeg .Width ,_ggbab :_cdeg .Height };});if _ddb !=nil {return nil ,ctx ,_ddb ;};
_cdeg .FillColor =_dfg ;_cdeg .BorderEnabled =false ;_cca ,_ ,_ddb :=_cdeg .Draw ("");if _ddb !=nil {return nil ,ctx ,_ddb ;};_ddb =_gcab .addContentsByString (string (_cca ));if _ddb !=nil {return nil ,ctx ,_ddb ;};};_feag :=_egba ._agg ;_aea :=_egba ._cfc ;
_ffa :=_egba ._eddf ;_agbg :=_egba ._ecac ;_ebbd :=_egba ._agg ;if _egba ._bgf ==CellBorderStyleDouble {_ebbd +=2*_feag ;};_gaa :=_egba ._cfc ;if _egba ._acc ==CellBorderStyleDouble {_gaa +=2*_aea ;};_dea :=_egba ._eddf ;if _egba ._ddda ==CellBorderStyleDouble {_dea +=2*_ffa ;
};_egff :=_egba ._ecac ;if _egba ._dbf ==CellBorderStyleDouble {_egff +=2*_agbg ;};_eafb :=(_ebbd -_dea )/2;_bac :=(_ebbd -_egff )/2;_beb :=(_gaa -_dea )/2;_bag :=(_gaa -_egff )/2;if _egba ._agg !=0{_cbb :=_ffgc ;_ebc :=_bfc ;if _egba ._bgf ==CellBorderStyleDouble {_ebc -=_feag ;
_cfb :=_bf .BasicLine {LineColor :_dec (_egba ._eaf ),Opacity :1.0,LineWidth :_egba ._agg ,LineStyle :_egba .LineStyle ,X1 :_cbb -_ebbd /2+_eafb ,Y1 :_ebc +2*_feag ,X2 :_cbb +_ebbd /2-_bac +_egba ._adf ,Y2 :_ebc +2*_feag };_fbe ,_ ,_cab :=_cfb .Draw ("");
if _cab !=nil {return nil ,ctx ,_cab ;};_cab =_gcab .addContentsByString (string (_fbe ));if _cab !=nil {return nil ,ctx ,_cab ;};};_fda :=_bf .BasicLine {LineWidth :_egba ._agg ,Opacity :1.0,LineColor :_dec (_egba ._eaf ),LineStyle :_egba .LineStyle ,X1 :_cbb -_ebbd /2+_eafb +(_dea -_egba ._eddf ),Y1 :_ebc ,X2 :_cbb +_ebbd /2-_bac +_egba ._adf -(_egff -_egba ._ecac ),Y2 :_ebc };
_ffaf ,_ ,_fdeb :=_fda .Draw ("");if _fdeb !=nil {return nil ,ctx ,_fdeb ;};_fdeb =_gcab .addContentsByString (string (_ffaf ));if _fdeb !=nil {return nil ,ctx ,_fdeb ;};};if _egba ._cfc !=0{_gbg :=_ffgc ;_efbb :=_bfc -_egba ._cff ;if _egba ._acc ==CellBorderStyleDouble {_efbb +=_aea ;
_dfag :=_bf .BasicLine {LineWidth :_egba ._cfc ,Opacity :1.0,LineColor :_dec (_egba ._gbdg ),LineStyle :_egba .LineStyle ,X1 :_gbg -_gaa /2+_beb ,Y1 :_efbb -2*_aea ,X2 :_gbg +_gaa /2-_bag +_egba ._adf ,Y2 :_efbb -2*_aea };_edgg ,_ ,_gaef :=_dfag .Draw ("");
if _gaef !=nil {return nil ,ctx ,_gaef ;};_gaef =_gcab .addContentsByString (string (_edgg ));if _gaef !=nil {return nil ,ctx ,_gaef ;};};_ffgb :=_bf .BasicLine {LineWidth :_egba ._cfc ,Opacity :1.0,LineColor :_dec (_egba ._gbdg ),LineStyle :_egba .LineStyle ,X1 :_gbg -_gaa /2+_beb +(_dea -_egba ._eddf ),Y1 :_efbb ,X2 :_gbg +_gaa /2-_bag +_egba ._adf -(_egff -_egba ._ecac ),Y2 :_efbb };
_fcd ,_ ,_ggdg :=_ffgb .Draw ("");if _ggdg !=nil {return nil ,ctx ,_ggdg ;};_ggdg =_gcab .addContentsByString (string (_fcd ));if _ggdg !=nil {return nil ,ctx ,_ggdg ;};};if _egba ._eddf !=0{_gfeb :=_ffgc ;_egffb :=_bfc ;if _egba ._ddda ==CellBorderStyleDouble {_gfeb +=_ffa ;
_fdfg :=_bf .BasicLine {LineWidth :_egba ._eddf ,Opacity :1.0,LineColor :_dec (_egba ._bdb ),LineStyle :_egba .LineStyle ,X1 :_gfeb -2*_ffa ,Y1 :_egffb +_dea /2+_eafb ,X2 :_gfeb -2*_ffa ,Y2 :_egffb -_dea /2-_beb -_egba ._cff };_cbd ,_ ,_ecgc :=_fdfg .Draw ("");
if _ecgc !=nil {return nil ,ctx ,_ecgc ;};_ecgc =_gcab .addContentsByString (string (_cbd ));if _ecgc !=nil {return nil ,ctx ,_ecgc ;};};_faea :=_bf .BasicLine {LineWidth :_egba ._eddf ,Opacity :1.0,LineColor :_dec (_egba ._bdb ),LineStyle :_egba .LineStyle ,X1 :_gfeb ,Y1 :_egffb +_dea /2+_eafb -(_ebbd -_egba ._agg ),X2 :_gfeb ,Y2 :_egffb -_dea /2-_beb -_egba ._cff +(_gaa -_egba ._cfc )};
_ffc ,_ ,_ceb :=_faea .Draw ("");if _ceb !=nil {return nil ,ctx ,_ceb ;};_ceb =_gcab .addContentsByString (string (_ffc ));if _ceb !=nil {return nil ,ctx ,_ceb ;};};if _egba ._ecac !=0{_fbgg :=_ffgc +_egba ._adf ;_aeac :=_bfc ;if _egba ._dbf ==CellBorderStyleDouble {_fbgg -=_agbg ;
_adbcb :=_bf .BasicLine {LineWidth :_egba ._ecac ,Opacity :1.0,LineColor :_dec (_egba ._gca ),LineStyle :_egba .LineStyle ,X1 :_fbgg +2*_agbg ,Y1 :_aeac +_egff /2+_bac ,X2 :_fbgg +2*_agbg ,Y2 :_aeac -_egff /2-_bag -_egba ._cff };_dee ,_ ,_eaa :=_adbcb .Draw ("");
if _eaa !=nil {return nil ,ctx ,_eaa ;};_eaa =_gcab .addContentsByString (string (_dee ));if _eaa !=nil {return nil ,ctx ,_eaa ;};};_geg :=_bf .BasicLine {LineWidth :_egba ._ecac ,Opacity :1.0,LineColor :_dec (_egba ._gca ),LineStyle :_egba .LineStyle ,X1 :_fbgg ,Y1 :_aeac +_egff /2+_bac -(_ebbd -_egba ._agg ),X2 :_fbgg ,Y2 :_aeac -_egff /2-_bag -_egba ._cff +(_gaa -_egba ._cfc )};
_aec ,_ ,_ged :=_geg .Draw ("");if _ged !=nil {return nil ,ctx ,_ged ;};_ged =_gcab .addContentsByString (string (_aec ));if _ged !=nil {return nil ,ctx ,_ged ;};};return []*Block {_gcab },ctx ,nil ;};func _gccb (_ggb ,_fca ,_egf ,_bfea float64 )*border {_ggg :=&border {};
_ggg ._dgd =_ggb ;_ggg ._bce =_fca ;_ggg ._adf =_egf ;_ggg ._cff =_bfea ;_ggg ._eaf =ColorBlack ;_ggg ._gbdg =ColorBlack ;_ggg ._bdb =ColorBlack ;_ggg ._gca =ColorBlack ;_ggg ._agg =0;_ggg ._cfc =0;_ggg ._eddf =0;_ggg ._ecac =0;_ggg .LineStyle =_bf .LineStyleSolid ;
return _ggg ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_affe *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _affe ._defb [0],_affe ._defb [1]};

// SetFillColor sets the fill color of the rectangle.
func (_efagg *Rectangle )SetFillColor (col Color ){_efagg ._daage =col };

// SetBackgroundColor sets the cell's background color.
func (_acggf *TableCell )SetBackgroundColor (col Color ){_acggf ._ebfde =col };

// NewCurvePolygon creates a new curve polygon.
func (_dfb *Creator )NewCurvePolygon (rings [][]_bf .CubicBezierCurve )*CurvePolygon {return _gdbd (rings );};

// Context returns the current drawing context.
func (_aaa *Creator )Context ()DrawContext {return _aaa ._abe };

// SetFontSize sets the font size in document units (points).
func (_bcbg *Paragraph )SetFontSize (fontSize float64 ){_bcbg ._afffc =fontSize };

// ColorGrayFrom8bit creates a Color from 8-bit (0-255) gray values.
// Example:
//
//	gray := ColorGrayFrom8bit(255, 0, 0)
func ColorGrayFrom8bit (g byte )Color {return grayColor {float64 (g )/255.0}};func (_aadcd *templateProcessor )parseRectangle (_bccba *templateNode )(interface{},error ){_baaab :=_aadcd .creator .NewRectangle (0,0,0,0);for _ ,_baade :=range _bccba ._adbf .Attr {_aaccg :=_baade .Value ;
switch _acabc :=_baade .Name .Local ;_acabc {case "\u0078":_baaab ._gadgc =_aadcd .parseFloatAttr (_acabc ,_aaccg );case "\u0079":_baaab ._adac =_aadcd .parseFloatAttr (_acabc ,_aaccg );case "\u0077\u0069\u0064t\u0068":_baaab .SetWidth (_aadcd .parseFloatAttr (_acabc ,_aaccg ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_baaab .SetHeight (_aadcd .parseFloatAttr (_acabc ,_aaccg ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_baaab .SetFillColor (_aadcd .parseColorAttr (_acabc ,_aaccg ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_baaab .SetFillOpacity (_aadcd .parseFloatAttr (_acabc ,_aaccg ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_baaab .SetBorderColor (_aadcd .parseColorAttr (_acabc ,_aaccg ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_baaab .SetBorderOpacity (_aadcd .parseFloatAttr (_acabc ,_aaccg ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_baaab .SetBorderWidth (_aadcd .parseFloatAttr (_acabc ,_aaccg ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_ddfe ,_cbgf ,_fbad ,_ffadf :=_aadcd .parseBorderRadiusAttr (_acabc ,_aaccg );
_baaab .SetBorderRadius (_ddfe ,_cbgf ,_ffadf ,_fbad );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_baaab ._gbda =_aadcd .parseFloatAttr (_acabc ,_aaccg );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_baaab ._gaebc =_aadcd .parseFloatAttr (_acabc ,_aaccg );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_baaab ._ecga =_aadcd .parseFloatAttr (_acabc ,_aaccg );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_baaab ._cbca =_aadcd .parseFloatAttr (_acabc ,_aaccg );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_baaab .SetPositioning (_aadcd .parsePositioningAttr (_acabc ,_aaccg ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_baaab .SetFitMode (_aadcd .parseFitModeAttr (_acabc ,_aaccg ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cgdf :=_aadcd .parseMarginAttr (_acabc ,_aaccg );
_baaab .SetMargins (_cgdf .Left ,_cgdf .Right ,_cgdf .Top ,_cgdf .Bottom );default:_aadcd .nodeLogDebug (_bccba ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_acabc );
};};return _baaab ,nil ;};

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_caga *_fd .GraphicSVG ;_dcce Positioning ;_dgdc float64 ;_gdde float64 ;_fcgg Margins ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_acdb *Paragraph )SetEnableWrap (enableWrap bool ){_acdb ._cgbcg =enableWrap ;_acdb ._gbbc =false ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_bcfe *StyledParagraph )Height ()float64 {_bcfe .wrapText ();var _afgf float64 ;for _ ,_eacc :=range _bcfe ._feab {var _cdgb float64 ;for _ ,_dcbbc :=range _eacc {_fcge :=_bcfe ._agcdg *_dcbbc .Style .FontSize ;if _fcge > _cdgb {_cdgb =_fcge ;};};
_afgf +=_cdgb ;};return _afgf ;};func (_edea *listItem )ctxHeight (_fcadd float64 )float64 {var _cbad float64 ;switch _edcb :=_edea ._cbgb .(type ){case *Paragraph :if _edcb ._cgbcg {_edcb .SetWidth (_fcadd -_edcb ._edbc .Horizontal ());};_cbad =_edcb .Height ()+_edcb ._edbc .Vertical ();
_cbad +=0.5*_edcb ._afffc *_edcb ._efbdc ;case *StyledParagraph :if _edcb ._eagfa {_edcb .SetWidth (_fcadd -_edcb ._acbfg .Horizontal ());};_cbad =_edcb .Height ()+_edcb ._acbfg .Vertical ();_cbad +=0.5*_edcb .getTextHeight ();case *List :_ecdc :=_fcadd -_edea ._afdbb .Width ()-_edcb ._afded .Horizontal ()-_edcb ._gdfg ;
_cbad =_edcb .ctxHeight (_ecdc )+_edcb ._afded .Vertical ();case *Image :_cbad =_edcb .Height ()+_edcb ._ceaa .Vertical ();case *Division :_ffbe :=_fcadd -_edea ._afdbb .Width ()-_edcb ._baad .Horizontal ();_cbad =_edcb .ctxHeight (_ffbe )+_edcb ._baad .Vertical ();
case *Table :_cgbec :=_fcadd -_edea ._afdbb .Width ()-_edcb ._dead .Horizontal ();_edcb .updateRowHeights (_cgbec );_cbad =_edcb .Height ()+_edcb ._dead .Vertical ();default:_cbad =_edea ._cbgb .Height ();};return _cbad ;};

// EnableWordWrap sets the paragraph word wrap flag.
func (_bgaec *StyledParagraph )EnableWordWrap (val bool ){_bgaec ._bedga =val };

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_gefa *TOC )SetLineSeparator (separator string ){_gefa ._ageg =separator };

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_fdaac *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_aadd []*Block ;_fdffa =NewBlock (ctx .PageWidth ,ctx .PageHeight );_acce =ctx ;);_dfaa :=_fdaac ._dfda .IsRelative ();if _dfaa {_fdaac .applyFitMode (ctx .Width );
ctx .X +=_fdaac ._cdg .Left ;ctx .Y +=_fdaac ._cdg .Top ;ctx .Width -=_fdaac ._cdg .Left +_fdaac ._cdg .Right ;ctx .Height -=_fdaac ._cdg .Top +_fdaac ._cdg .Bottom ;if _fdaac ._abda > ctx .Height {_aadd =append (_aadd ,_fdffa );_fdffa =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_bgdc :=ctx ;_bgdc .Y =ctx .Margins .Top +_fdaac ._cdg .Top ;_bgdc .X =ctx .Margins .Left +_fdaac ._cdg .Left ;_bgdc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_fdaac ._cdg .Top -_fdaac ._cdg .Bottom ;_bgdc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_fdaac ._cdg .Left -_fdaac ._cdg .Right ;
ctx =_bgdc ;};}else {ctx .X =_fdaac ._faac -_fdaac ._efge /2;ctx .Y =_fdaac ._ccag -_fdaac ._abda /2;};_fdde :=_bf .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_fdaac ._abda ,Width :_fdaac ._efge ,Height :_fdaac ._abda ,BorderWidth :_fdaac ._fddf ,Opacity :1.0};
if _fdaac ._fdaa !=nil {_fdde .FillEnabled =true ;_cfda :=_dec (_fdaac ._fdaa );_afeg :=_bfgc (_fdffa ,_cfda ,_fdaac ._fdaa ,func ()Rectangle {return Rectangle {_gadgc :_fdde .X ,_adac :_fdde .Y ,_cegcg :_fdde .Width ,_ggbab :_fdde .Height };});if _afeg !=nil {return nil ,ctx ,_afeg ;
};_fdde .FillColor =_cfda ;};if _fdaac ._gdcga !=nil {_fdde .BorderEnabled =false ;if _fdaac ._fddf > 0{_fdde .BorderEnabled =true ;};_fdde .BorderColor =_dec (_fdaac ._gdcga );_fdde .BorderWidth =_fdaac ._fddf ;};_fceae ,_aeba :=_fdffa .setOpacity (_fdaac ._eag ,_fdaac ._ddbee );
if _aeba !=nil {return nil ,ctx ,_aeba ;};_caa ,_ ,_aeba :=_fdde .Draw (_fceae );if _aeba !=nil {return nil ,ctx ,_aeba ;};_aeba =_fdffa .addContentsByString (string (_caa ));if _aeba !=nil {return nil ,ctx ,_aeba ;};if _dfaa {ctx .X =_acce .X ;ctx .Width =_acce .Width ;
ctx .Y +=_fdaac ._abda +_fdaac ._cdg .Bottom ;ctx .Height -=_fdaac ._abda ;}else {ctx =_acce ;};_aadd =append (_aadd ,_fdffa );return _aadd ,ctx ,nil ;};

// TOC returns the table of contents component of the creator.
func (_dgba *Creator )TOC ()*TOC {return _dgba ._dcag };

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_bdcee *_bf .Polygon ;_cagc float64 ;_beac float64 ;_acegc Color ;};func (_agffb *Paragraph )getTextMetrics ()(_ggefe ,_bbba ,_gdcde float64 ){_ffbd :=_daegd (_agffb ._bbcb ,_agffb ._afffc );if _ffbd ._faffg > _ggefe {_ggefe =_ffbd ._faffg ;
};if _ffbd ._ccdgd < _gdcde {_gdcde =_ffbd ._ccdgd ;};if _fgbd :=_agffb ._afffc ;_fgbd > _bbba {_bbba =_fgbd ;};return _ggefe ,_bbba ,_gdcde ;};func (_ecgga *Table )resetColumnWidths (){_ecgga ._dbeeb =[]float64 {};_gbeb :=float64 (1.0)/float64 (_ecgga ._dfeg );
for _eddaa :=0;_eddaa < _ecgga ._dfeg ;_eddaa ++{_ecgga ._dbeeb =append (_ecgga ._dbeeb ,_gbeb );};};

// FillColor returns the fill color of the ellipse.
func (_bbbd *Ellipse )FillColor ()Color {return _bbbd ._fdaa };func (_ecbf *List )split (_gcba DrawContext )(_dgfbg ,_ebdb *List ){var (_gcga float64 ;_addaf ,_ggcd []*listItem ;);_eecag :=_gcba .Width -_ecbf ._afded .Horizontal ()-_ecbf ._gdfg -_ecbf .markerWidth ();
_edcgc :=_ecbf .markerWidth ();for _gcage ,_bdbc :=range _ecbf ._gaegd {_fegc :=_bdbc .ctxHeight (_eecag );_gcga +=_fegc ;if _gcga <=_gcba .Height {_addaf =append (_addaf ,_bdbc );}else {switch _gdfe :=_bdbc ._cbgb .(type ){case *List :_ddbcd :=_gcba ;
_ddbcd .Height =_cf .Floor (_fegc -(_gcga -_gcba .Height ));_bgbb ,_fdae :=_gdfe .split (_ddbcd );if _bgbb !=nil {_bgea :=_gbff ();_bgea ._afdbb =_bdbc ._afdbb ;_bgea ._cbgb =_bgbb ;_addaf =append (_addaf ,_bgea );};if _fdae !=nil {_aceg :=_gdfe ._defad .Style .FontSize ;
_gfca ,_gaeag :=_gdfe ._defad .Style .Font .GetRuneMetrics (' ');if _gaeag {_aceg =_gdfe ._defad .Style .FontSize *_gfca .Wx *_gdfe ._defad .Style .horizontalScale ()/1000.0;};_fdgd :=_de .Repeat ("\u0020",int (_edcgc /_aceg ));_bdda :=_gbff ();_bdda ._afdbb =*NewTextChunk (_fdgd ,_gdfe ._defad .Style );
_bdda ._cbgb =_fdae ;_ggcd =append (_ggcd ,_bdda );_ggcd =append (_ggcd ,_ecbf ._gaegd [_gcage +1:]...);};default:_ggcd =_ecbf ._gaegd [_gcage :];};if len (_ggcd )> 0{break ;};};};if len (_addaf )> 0{_dgfbg =_deeb (_ecbf ._aaagc );*_dgfbg =*_ecbf ;_dgfbg ._gaegd =_addaf ;
};if len (_ggcd )> 0{_ebdb =_deeb (_ecbf ._aaagc );*_ebdb =*_ecbf ;_ebdb ._gaegd =_ggcd ;};return _dgfbg ,_ebdb ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_faca *Table )SetPos (x ,y float64 ){_faca ._fafag =PositionAbsolute ;_faca ._bgbcd =x ;_faca ._adedc =y ;};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_baefd *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbcb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gfbgd ,_agcf :=_dbcb .setOpacity (_baefd ._cagc ,_baefd ._beac );if _agcf !=nil {return nil ,ctx ,_agcf ;};
_ceec :=_baefd ._bdcee ;_ceec .FillEnabled =_ceec .FillColor !=nil ;_ceec .BorderEnabled =_ceec .BorderColor !=nil &&_ceec .BorderWidth > 0;_baegd :=_ceec .Points ;_feefa :=_ed .PdfRectangle {};_dfdc :=false ;for _cbce :=range _baegd {for _dfagb :=range _baegd [_cbce ]{_ddaa :=&_baegd [_cbce ][_dfagb ];
_ddaa .Y =ctx .PageHeight -_ddaa .Y ;if !_dfdc {_feefa .Llx =_ddaa .X ;_feefa .Lly =_ddaa .Y ;_feefa .Urx =_ddaa .X ;_feefa .Ury =_ddaa .Y ;_dfdc =true ;}else {_feefa .Llx =_cf .Min (_feefa .Llx ,_ddaa .X );_feefa .Lly =_cf .Min (_feefa .Lly ,_ddaa .Y );
_feefa .Urx =_cf .Max (_feefa .Urx ,_ddaa .X );_feefa .Ury =_cf .Max (_feefa .Ury ,_ddaa .Y );};};};if _ceec .FillEnabled {_eecb :=_bfgc (_dbcb ,_baefd ._bdcee .FillColor ,_baefd ._acegc ,func ()Rectangle {return Rectangle {_gadgc :_feefa .Llx ,_adac :_feefa .Lly ,_cegcg :_feefa .Width (),_ggbab :_feefa .Height ()};
});if _eecb !=nil {return nil ,ctx ,_eecb ;};};_cgfge ,_ ,_agcf :=_ceec .Draw (_gfbgd );if _agcf !=nil {return nil ,ctx ,_agcf ;};if _agcf =_dbcb .addContentsByString (string (_cgfge ));_agcf !=nil {return nil ,ctx ,_agcf ;};return []*Block {_dbcb },ctx ,nil ;
};var (ErrContentNotFit =_e .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
);

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_cffg *Image )GetHorizontalAlignment ()HorizontalAlignment {return _cffg ._aabe };

// NewTable create a new Table with a specified number of columns.
func (_fcea *Creator )NewTable (cols int )*Table {return _gegfb (cols )};func _gaeff (_bgebg ,_afdbbe ,_dabg int )[]int {_eagc :=[]int {};for _ebaeb :=_bgebg ;_ebaeb <=_dabg ;_ebaeb +=_afdbbe {_eagc =append (_eagc ,_ebaeb );};return _eagc ;};

// SetBackground sets the background properties of the component.
func (_edb *Division )SetBackground (background *Background ){_edb ._aadg =background };func _bfee (_gedda int64 ,_cbfd ,_cfgc ,_cada float64 )*_ed .PdfAnnotation {_gceaf :=_ed .NewPdfAnnotationLink ();_faddb :=_ed .NewBorderStyle ();_faddb .SetBorderWidth (0);
_gceaf .BS =_faddb .ToPdfObject ();if _gedda < 0{_gedda =0;};_gceaf .Dest =_gd .MakeArray (_gd .MakeInteger (_gedda ),_gd .MakeName ("\u0058\u0059\u005a"),_gd .MakeFloat (_cbfd ),_gd .MakeFloat (_cfgc ),_gd .MakeFloat (_cada ));return _gceaf .PdfAnnotation ;
};func (_gebge *TableCell )height (_bcbae float64 )float64 {var _ebbf float64 ;switch _dabbea :=_gebge ._aeeee .(type ){case *Paragraph :if _dabbea ._cgbcg {_dabbea .SetWidth (_bcbae -_gebge ._bgeed -_dabbea ._edbc .Left -_dabbea ._edbc .Right );};_ebbf =_dabbea .Height ()+_dabbea ._edbc .Top +_dabbea ._edbc .Bottom ;
if !_gebge ._afbd ._gdad {_ebbf +=(0.5*_dabbea ._afffc *_dabbea ._efbdc );};case *StyledParagraph :if _dabbea ._eagfa {_dabbea .SetWidth (_bcbae -_gebge ._bgeed -_dabbea ._acbfg .Left -_dabbea ._acbfg .Right );};_ebbf =_dabbea .Height ()+_dabbea ._acbfg .Top +_dabbea ._acbfg .Bottom ;
if !_gebge ._afbd ._gdad {_ebbf +=(0.5*_dabbea .getTextHeight ());};case *Image :_dabbea .applyFitMode (_bcbae -_gebge ._bgeed );_ebbf =_dabbea .Height ()+_dabbea ._ceaa .Top +_dabbea ._ceaa .Bottom ;case *Table :_dabbea .updateRowHeights (_bcbae -_gebge ._bgeed -_dabbea ._dead .Left -_dabbea ._dead .Right );
_ebbf =_dabbea .Height ()+_dabbea ._dead .Top +_dabbea ._dead .Bottom ;case *List :_ebbf =_dabbea .ctxHeight (_bcbae -_gebge ._bgeed )+_dabbea ._afded .Top +_dabbea ._afded .Bottom ;case *Division :_ebbf =_dabbea .ctxHeight (_bcbae -_gebge ._bgeed )+_dabbea ._baad .Top +_dabbea ._baad .Bottom +_dabbea ._babd .Top +_dabbea ._babd .Bottom ;
case *Chart :_ebbf =_dabbea .Height ()+_dabbea ._bfa .Top +_dabbea ._bfa .Bottom ;case *Rectangle :_dabbea .applyFitMode (_bcbae -_gebge ._bgeed );_ebbf =_dabbea .Height ()+_dabbea ._ddfc .Top +_dabbea ._ddfc .Bottom +_dabbea ._cfdf ;case *Ellipse :_dabbea .applyFitMode (_bcbae -_gebge ._bgeed );
_ebbf =_dabbea .Height ()+_dabbea ._cdg .Top +_dabbea ._cdg .Bottom ;case *Line :_ebbf =_dabbea .Height ()+_dabbea ._accae .Top +_dabbea ._accae .Bottom ;};return _ebbf ;};type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );
};

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_dcab *GraphicSVG )SetPos (x ,y float64 ){_dcab ._dcce =PositionAbsolute ;_dcab ._dgdc =x ;_dcab ._gdde =y ;};

// LineWidth returns the width of the line.
func (_fece *Line )LineWidth ()float64 {return _fece ._cdff };

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_fbd *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _cabd (x1 ,y1 ,x2 ,y2 )};func (_fddeg *templateProcessor )parseTableCell (_agddfb *templateNode )(interface{},error ){if _agddfb ._gfggb ==nil {_fddeg .nodeLogError (_agddfb ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_adee ;};_caefa ,_feaf :=_agddfb ._gfggb ._cagcg .(*Table );if !_feaf {_fddeg .nodeLogError (_agddfb ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_agddfb ._gfggb ._cagcg );
return nil ,_adee ;};var _bbgee ,_ebege int64 ;for _ ,_efde :=range _agddfb ._adbf .Attr {_fgcc :=_efde .Value ;switch _abfgc :=_efde .Name .Local ;_abfgc {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_bbgee =_fddeg .parseInt64Attr (_abfgc ,_fgcc );case "\u0072o\u0077\u0073\u0070\u0061\u006e":_ebege =_fddeg .parseInt64Attr (_abfgc ,_fgcc );
};};if _bbgee <=0{_bbgee =1;};if _ebege <=0{_ebege =1;};_adeda :=_caefa .MultiCell (int (_ebege ),int (_bbgee ));for _ ,_efeb :=range _agddfb ._adbf .Attr {_gdccb :=_efeb .Value ;switch _fbbcb :=_efeb .Name .Local ;_fbbcb {case "\u0069\u006e\u0064\u0065\u006e\u0074":_adeda .SetIndent (_fddeg .parseFloatAttr (_fbbcb ,_gdccb ));
case "\u0061\u006c\u0069g\u006e":_adeda .SetHorizontalAlignment (_fddeg .parseCellAlignmentAttr (_fbbcb ,_gdccb ));case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_adeda .SetVerticalAlignment (_fddeg .parseCellVerticalAlignmentAttr (_fbbcb ,_gdccb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_adeda .SetSideBorderStyle (CellBorderSideAll ,_fddeg .parseCellBorderStyleAttr (_fbbcb ,_gdccb ));case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_adeda .SetSideBorderStyle (CellBorderSideTop ,_fddeg .parseCellBorderStyleAttr (_fbbcb ,_gdccb ));
case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_adeda .SetSideBorderStyle (CellBorderSideBottom ,_fddeg .parseCellBorderStyleAttr (_fbbcb ,_gdccb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_adeda .SetSideBorderStyle (CellBorderSideLeft ,_fddeg .parseCellBorderStyleAttr (_fbbcb ,_gdccb ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_adeda .SetSideBorderStyle (CellBorderSideRight ,_fddeg .parseCellBorderStyleAttr (_fbbcb ,_gdccb ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_adeda .SetSideBorderWidth (CellBorderSideAll ,_fddeg .parseFloatAttr (_fbbcb ,_gdccb ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_adeda .SetSideBorderWidth (CellBorderSideTop ,_fddeg .parseFloatAttr (_fbbcb ,_gdccb ));case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_adeda .SetSideBorderWidth (CellBorderSideBottom ,_fddeg .parseFloatAttr (_fbbcb ,_gdccb ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_adeda .SetSideBorderWidth (CellBorderSideLeft ,_fddeg .parseFloatAttr (_fbbcb ,_gdccb ));case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_adeda .SetSideBorderWidth (CellBorderSideRight ,_fddeg .parseFloatAttr (_fbbcb ,_gdccb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_adeda .SetSideBorderColor (CellBorderSideAll ,_fddeg .parseColorAttr (_fbbcb ,_gdccb ));case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_adeda .SetSideBorderColor (CellBorderSideTop ,_fddeg .parseColorAttr (_fbbcb ,_gdccb ));
case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_adeda .SetSideBorderColor (CellBorderSideBottom ,_fddeg .parseColorAttr (_fbbcb ,_gdccb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_adeda .SetSideBorderColor (CellBorderSideLeft ,_fddeg .parseColorAttr (_fbbcb ,_gdccb ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_adeda .SetSideBorderColor (CellBorderSideRight ,_fddeg .parseColorAttr (_fbbcb ,_gdccb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_adeda .SetBorderLineStyle (_fddeg .parseLineStyleAttr (_fbbcb ,_gdccb ));
case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_adeda .SetBackgroundColor (_fddeg .parseColorAttr (_fbbcb ,_gdccb ));case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;
default:_fddeg .nodeLogDebug (_agddfb ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_fbbcb );
};};return _adeda ,nil ;};

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _bcce (color ,point )};

// SetColPosition sets cell column position.
func (_fabe *TableCell )SetColPosition (col int ){_fabe ._eafa =col };

// Insert adds a new text chunk at the specified position in the paragraph.
func (_dcfac *StyledParagraph )Insert (index uint ,text string )*TextChunk {_dfcg :=uint (len (_dcfac ._fcdf ));if index > _dfcg {index =_dfcg ;};_cgde :=NewTextChunk (text ,_dcfac ._beafc );_dcfac ._fcdf =append (_dcfac ._fcdf [:index ],append ([]*TextChunk {_cgde },_dcfac ._fcdf [index :]...)...);
_dcfac .wrapText ();return _cgde ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_deab *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _deab ._acgc [0],_deab ._acgc [1]};func (_ceaae *templateProcessor )parseTable (_bgcb *templateNode )(interface{},error ){var _ggca int64 ;for _ ,_dgggd :=range _bgcb ._adbf .Attr {_gdcca :=_dgggd .Value ;
switch _ebfgfg :=_dgggd .Name .Local ;_ebfgfg {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_ggca =_ceaae .parseInt64Attr (_ebfgfg ,_gdcca );};};if _ggca <=0{_ceaae .nodeLogDebug (_bgcb ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_ggca );
_ggca =1;};_gbdde :=_ceaae .creator .NewTable (int (_ggca ));for _ ,_eeba :=range _bgcb ._adbf .Attr {_deagf :=_eeba .Value ;switch _dfcfg :=_eeba .Name .Local ;_dfcfg {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_gbdde .SetColumnWidths (_ceaae .parseFloatArray (_dfcfg ,_deagf )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_cdad :=_ceaae .parseMarginAttr (_dfcfg ,_deagf );_gbdde .SetMargins (_cdad .Left ,_cdad .Right ,_cdad .Top ,_cdad .Bottom );case "\u0078":_gbdde .SetPos (_ceaae .parseFloatAttr (_dfcfg ,_deagf ),_gbdde ._adedc );
case "\u0079":_gbdde .SetPos (_gbdde ._bgbcd ,_ceaae .parseFloatAttr (_dfcfg ,_deagf ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_gbdde ._bdcdfg =int (_ceaae .parseInt64Attr (_dfcfg ,_deagf ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_gbdde ._feac =int (_ceaae .parseInt64Attr (_dfcfg ,_deagf ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_gbdde .EnableRowWrap (_ceaae .parseBoolAttr (_dfcfg ,_deagf ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_gbdde .EnablePageWrap (_ceaae .parseBoolAttr (_dfcfg ,_deagf ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_ceaae .nodeLogDebug (_bgcb ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_dfcfg );
};};if _gbdde ._bdcdfg !=0&&_gbdde ._feac !=0{_abcff :=_gbdde .SetHeaderRows (_gbdde ._bdcdfg ,_gbdde ._feac );if _abcff !=nil {_ceaae .nodeLogDebug (_bgcb ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_abcff );
};}else {_gbdde ._bdcdfg =0;_gbdde ._feac =0;};return _gbdde ,nil ;};

// SetHeight sets the Image's document height to specified h.
func (_cfeg *Image )SetHeight (h float64 ){_cfeg ._dafe =h };

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_ggfca *Rectangle )SetPositioning (position Positioning ){_ggfca ._dffd =position };type cmykColor struct{_dag ,_acg ,_befc ,_dgde float64 };

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_acab *List )Add (item VectorDrawable )(*TextChunk ,error ){_dbgb :=&listItem {_cbgb :item ,_afdbb :_acab ._defad };switch _gaea :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _gaea ._edag {_gaea ._gdfg =15;};case *Division :case *Image :case *Table :default:return nil ,_e .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_acab ._gaegd =append (_acab ._gaegd ,_dbgb );return &_dbgb ._afdbb ,nil ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_gafa *Creator )SetOptimizer (optimizer _ed .Optimizer ){_gafa ._affc =optimizer };

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_fa *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ca :=_af .IdentityMatrix ();_agb ,_gbd :=_fa .Width (),_fa .Height ();if _fa ._ea .IsRelative (){_ca =_ca .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_gbd );}else {_ca =_ca .Translate (_fa ._edd ,ctx .PageHeight -_fa ._dcc -_gbd );
};_ef :=_gbd ;if _fa ._agc !=0{_ca =_ca .Translate (_agb /2,_gbd /2).Rotate (_fa ._agc *_cf .Pi /180.0).Translate (-_agb /2,-_gbd /2);_ ,_ef =_fa .RotatedSize ();};if _fa ._ea .IsRelative (){ctx .Y +=_ef ;};_aeb :=_cc .NewContentCreator ();_aeb .Add_cm (_ca [0],_ca [1],_ca [3],_ca [4],_ca [6],_ca [7]);
_ga :=_fa .duplicate ();_gdc :=append (*_aeb .Operations (),*_ga ._ebg ...);_gdc .WrapIfNeeded ();_ga ._ebg =&_gdc ;for _ ,_bd :=range _fa ._ba {_eg ,_bda :=_gd .GetArray (_bd .Rect );if !_bda ||_eg .Len ()!=4{_gfb .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_bd .Rect );
continue ;};_bffa ,_ff :=_ed .NewPdfRectangle (*_eg );if _ff !=nil {_gfb .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_ff );
continue ;};_bffa .Transform (_ca );_bd .Rect =_bffa .ToPdfObject ();};return []*Block {_ga },ctx ,nil ;};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_abgg *LinearShading )AddPatternResource (block *Block )(_ecbeb _gd .PdfObjectName ,_eecf error ){_degb :=1;_febf :=_gd .PdfObjectName ("\u0050"+_ad .Itoa (_degb ));for block ._ece .HasPatternByName (_febf ){_degb ++;_febf =_gd .PdfObjectName ("\u0050"+_ad .Itoa (_degb ));
};if _dfdgf :=block ._ece .SetPatternByName (_febf ,_abgg .ToPdfShadingPattern ().ToPdfObject ());_dfdgf !=nil {return "",_dfdgf ;};return _febf ,nil ;};

// CreateFrontPage sets a function to generate a front Page.
func (_adbd *Creator )CreateFrontPage (genFrontPageFunc func (_cdf FrontpageFunctionArgs )){_adbd ._fcc =genFrontPageFunc ;};const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_bgfcf *Invoice )InfoLines ()[][2]*InvoiceCell {_ebca :=[][2]*InvoiceCell {_bgfcf ._aafc ,_bgfcf ._defb ,_bgfcf ._beff };return append (_ebca ,_bgfcf ._ccad ...);};

// FitMode returns the fit mode of the image.
func (_bgeb *Image )FitMode ()FitMode {return _bgeb ._caec };

// SetInline sets the inline mode of the division.
func (_bafc *Division )SetInline (inline bool ){_bafc ._afdb =inline };

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cbde *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _cbde ._beff [0],_cbde ._beff [1]};

// BorderWidth returns the border width of the rectangle.
func (_eadb *Rectangle )BorderWidth ()float64 {return _eadb ._cfdf };

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};func (_gedef *templateProcessor )parseChart (_dedgb *templateNode )(interface{},error ){var _cecc string ;for _ ,_acba :=range _dedgb ._adbf .Attr {_faega :=_acba .Value ;switch _adagf :=_acba .Name .Local ;
_adagf {case "\u0073\u0072\u0063":_cecc =_faega ;};};if _cecc ==""{_gedef .nodeLogError (_dedgb ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_gcbe ;};_bcfcb ,_ecbebc :=_gedef ._bfega .ChartMap [_cecc ];if !_ecbebc {_gedef .nodeLogError (_dedgb ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_cecc );
return nil ,_gcbe ;};_ccdac :=NewChart (_bcfcb );for _ ,_dbfdf :=range _dedgb ._adbf .Attr {_fbbd :=_dbfdf .Value ;switch _gafd :=_dbfdf .Name .Local ;_gafd {case "\u0078":_ccdac .SetPos (_gedef .parseFloatAttr (_gafd ,_fbbd ),_ccdac ._ggdf );case "\u0079":_ccdac .SetPos (_ccdac ._bgce ,_gedef .parseFloatAttr (_gafd ,_fbbd ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_ffec :=_gedef .parseMarginAttr (_gafd ,_fbbd );_ccdac .SetMargins (_ffec .Left ,_ffec .Right ,_ffec .Top ,_ffec .Bottom );case "\u0077\u0069\u0064t\u0068":_ccdac ._ddge .SetWidth (int (_gedef .parseFloatAttr (_gafd ,_fbbd )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_ccdac ._ddge .SetHeight (int (_gedef .parseFloatAttr (_gafd ,_fbbd )));case "\u0073\u0072\u0063":break ;default:_gedef .nodeLogDebug (_dedgb ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_gafd );
};};return _ccdac ,nil ;};func _afc (_aef ,_aed *_ed .PdfPageResources )error {_gbf ,_ :=_aef .GetColorspaces ();if _gbf !=nil &&len (_gbf .Colorspaces )> 0{for _efg ,_egg :=range _gbf .Colorspaces {_gcg :=*_gd .MakeName (_efg );if _aed .HasColorspaceByName (_gcg ){continue ;
};_fffe :=_aed .SetColorspaceByName (_gcg ,_egg );if _fffe !=nil {return _fffe ;};};};return nil ;};func (_fdfce *StyledParagraph )split (_adgb DrawContext )(_dfeec ,_ddaab *StyledParagraph ,_fabac error ){if _fabac =_fdfce .wrapChunks (false );_fabac !=nil {return nil ,nil ,_fabac ;
};if len (_fdfce ._feab )==1&&_fdfce ._agcdg > _adgb .Height {return _fdfce ,nil ,nil ;};_bead :=func (_ababb []*TextChunk ,_eecagb []*TextChunk )[]*TextChunk {if len (_eecagb )==0{return _ababb ;};_bffba :=len (_ababb );if _bffba ==0{return append (_ababb ,_eecagb ...);
};if _ababb [_bffba -1].Style ==_eecagb [0].Style {_ababb [_bffba -1].Text +=_eecagb [0].Text ;}else {_ababb =append (_ababb ,_eecagb [0]);};return append (_ababb ,_eecagb [1:]...);};_ebff :=func (_dafd *StyledParagraph ,_egdb []*TextChunk )*StyledParagraph {if len (_egdb )==0{return nil ;
};_bbec :=*_dafd ;_bbec ._fcdf =_egdb ;return &_bbec ;};var (_gebd float64 ;_dgbd []*TextChunk ;_fecga []*TextChunk ;);for _ ,_egbe :=range _fdfce ._feab {var _ffafc float64 ;_fbda :=make ([]*TextChunk ,0,len (_egbe ));for _ ,_fagg :=range _egbe {if _cddcg :=_fagg .Style .FontSize ;
_cddcg > _ffafc {_ffafc =_cddcg ;};_fbda =append (_fbda ,_fagg .clone ());};_ffafc *=_fdfce ._agcdg ;if _fdfce ._cbgac .IsRelative (){if _gebd +_ffafc > _adgb .Height {_fecga =_bead (_fecga ,_fbda );}else {_dgbd =_bead (_dgbd ,_fbda );};};_gebd +=_ffafc ;
};_fdfce ._feab =nil ;if len (_fecga )==0{return _fdfce ,nil ,nil ;};return _ebff (_fdfce ,_dgbd ),_ebff (_fdfce ,_fecga ),nil ;};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_adefd *Division )SetPadding (left ,right ,top ,bottom float64 ){_adefd ._babd .Left =left ;_adefd ._babd .Right =right ;_adefd ._babd .Top =top ;_adefd ._babd .Bottom =bottom ;};

// NewCell returns a new invoice table cell.
func (_dgdb *Invoice )NewCell (value string )*InvoiceCell {return _dgdb .newCell (value ,_dgdb .NewCellProps ());};func (_aacc *Table )sortCells (){_c .Slice (_aacc ._cfcdg ,func (_gabg ,_bbcg int )bool {_gddea :=_aacc ._cfcdg [_gabg ]._ggccd ;_fgfc :=_aacc ._cfcdg [_bbcg ]._ggccd ;
if _gddea < _fgfc {return true ;};if _gddea > _fgfc {return false ;};return _aacc ._cfcdg [_gabg ]._eafa < _aacc ._cfcdg [_bbcg ]._eafa ;});};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_gcee *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fcgbd :=_gcee ;if _gcee ._egegc {_fcgbd =_gcee .clone ();};return _bbcbd (_fcgbd ,ctx );};

// NewPageBreak create a new page break.
func (_cbdb *Creator )NewPageBreak ()*PageBreak {return _agde ()};func _abgab (_egca *templateProcessor ,_dbdf *templateNode )(interface{},error ){return _egca .parseBackground (_dbdf );};func (_fccb *RadialShading )shadingModel ()*_ed .PdfShadingType3 {_ffag ,_ebae ,_ccece :=_fccb ._efef ._cbcbg .ToRGB ();
var _febe _bf .Point ;switch _fccb ._bagda {case AnchorBottomLeft :_febe =_bf .Point {X :_fccb ._becbb .Llx ,Y :_fccb ._becbb .Lly };case AnchorBottomRight :_febe =_bf .Point {X :_fccb ._becbb .Urx ,Y :_fccb ._becbb .Ury -_fccb ._becbb .Height ()};case AnchorTopLeft :_febe =_bf .Point {X :_fccb ._becbb .Llx ,Y :_fccb ._becbb .Lly +_fccb ._becbb .Height ()};
case AnchorTopRight :_febe =_bf .Point {X :_fccb ._becbb .Urx ,Y :_fccb ._becbb .Ury };case AnchorLeft :_febe =_bf .Point {X :_fccb ._becbb .Llx ,Y :_fccb ._becbb .Lly +_fccb ._becbb .Height ()/2};case AnchorTop :_febe =_bf .Point {X :_fccb ._becbb .Llx +_fccb ._becbb .Width ()/2,Y :_fccb ._becbb .Ury };
case AnchorRight :_febe =_bf .Point {X :_fccb ._becbb .Urx ,Y :_fccb ._becbb .Lly +_fccb ._becbb .Height ()/2};case AnchorBottom :_febe =_bf .Point {X :_fccb ._becbb .Urx +_fccb ._becbb .Width ()/2,Y :_fccb ._becbb .Lly };default:_febe =_bf .NewPoint (_fccb ._becbb .Llx +_fccb ._becbb .Width ()/2,_fccb ._becbb .Lly +_fccb ._becbb .Height ()/2);
};_gagec :=_fccb ._cegbd ;_gcea :=_fccb ._adfa ;_gfdd :=_febe .X +_fccb ._caeg ;_cagcf :=_febe .Y +_fccb ._defbd ;if _gagec ==-1.0{_gagec =0.0;};if _gcea ==-1.0{var _cadc []float64 ;_adaae :=_cf .Pow (_gfdd -_fccb ._becbb .Llx ,2)+_cf .Pow (_cagcf -_fccb ._becbb .Lly ,2);
_cadc =append (_cadc ,_cf .Abs (_adaae ));_debb :=_cf .Pow (_gfdd -_fccb ._becbb .Llx ,2)+_cf .Pow (_fccb ._becbb .Lly +_fccb ._becbb .Height ()-_cagcf ,2);_cadc =append (_cadc ,_cf .Abs (_debb ));_dgaa :=_cf .Pow (_fccb ._becbb .Urx -_gfdd ,2)+_cf .Pow (_cagcf -_fccb ._becbb .Ury -_fccb ._becbb .Height (),2);
_cadc =append (_cadc ,_cf .Abs (_dgaa ));_efaf :=_cf .Pow (_fccb ._becbb .Urx -_gfdd ,2)+_cf .Pow (_fccb ._becbb .Ury -_cagcf ,2);_cadc =append (_cadc ,_cf .Abs (_efaf ));_c .Slice (_cadc ,func (_efbf ,_eabb int )bool {return _efbf > _eabb });_gcea =_cf .Sqrt (_cadc [0]);
};_cdgc :=&_ed .PdfRectangle {Llx :_gfdd -_gcea ,Lly :_cagcf -_gcea ,Urx :_gfdd +_gcea ,Ury :_cagcf +_gcea };_aagd :=_ed .NewPdfShadingType3 ();_aagd .PdfShading .ShadingType =_gd .MakeInteger (3);_aagd .PdfShading .ColorSpace =_ed .NewPdfColorspaceDeviceRGB ();
_aagd .PdfShading .Background =_gd .MakeArrayFromFloats ([]float64 {_ffag ,_ebae ,_ccece });_aagd .PdfShading .BBox =_cdgc ;_aagd .PdfShading .AntiAlias =_gd .MakeBool (_fccb ._efef ._aagae );_aagd .Coords =_gd .MakeArrayFromFloats ([]float64 {_gfdd ,_cagcf ,_gagec ,_gfdd ,_cagcf ,_gcea });
_aagd .Domain =_gd .MakeArrayFromFloats ([]float64 {0.0,1.0});_aagd .Extend =_gd .MakeArray (_gd .MakeBool (_fccb ._efef ._cfffe [0]),_gd .MakeBool (_fccb ._efef ._cfffe [1]));_aagd .Function =_fccb ._efef .generatePdfFunctions ();return _aagd ;};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_dcad *Line )SetMargins (left ,right ,top ,bottom float64 ){_dcad ._accae .Left =left ;_dcad ._accae .Right =right ;_dcad ._accae .Top =top ;_dcad ._accae .Bottom =bottom ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_bgac *Creator )EnableFontSubsetting (font *_ed .PdfFont ){_bgac ._eac =append (_bgac ._eac ,font )};

// IsRelative checks if the positioning is relative.
func (_aefb Positioning )IsRelative ()bool {return _aefb ==PositionRelative };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_ccdb *Creator )MoveRight (dx float64 ){_ccdb ._abe .X +=dx };

// SetText replaces all the text of the paragraph with the specified one.
func (_eeeg *StyledParagraph )SetText (text string )*TextChunk {_eeeg .Reset ();return _eeeg .Append (text );};func _aced (_effb float64 ,_dgdcf int )float64 {_aacdg :=_cf .Pow10 (_dgdcf );return _cf .Round (_aacdg *_effb )/_aacdg ;};

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _gcfc (path )};func (_daed *FilledCurve )draw (_bbfc *Block ,_ggfe string )([]byte ,*_ed .PdfRectangle ,error ){_bgcc :=_bf .NewCubicBezierPath ();for _ ,_dfgf :=range _daed ._dabe {_bgcc =_bgcc .AppendCurve (_dfgf );
};creator :=_cc .NewContentCreator ();creator .Add_q ();if _daed .FillEnabled &&_daed ._eea !=nil {_dfcd :=_dec (_daed ._eea );_cddg :=_bfgc (_bbfc ,_dfcd ,_daed ._eea ,func ()Rectangle {_dfdg :=_bf .NewCubicBezierPath ();for _ ,_gfgc :=range _daed ._dabe {_dfdg =_dfdg .AppendCurve (_gfgc );
};_gcf :=_dfdg .GetBoundingBox ();if _daed .BorderEnabled {_gcf .Height +=_daed .BorderWidth ;_gcf .Width +=_daed .BorderWidth ;_gcf .X -=_daed .BorderWidth /2;_gcf .Y -=_daed .BorderWidth /2;};return Rectangle {_gadgc :_gcf .X ,_adac :_gcf .Y ,_cegcg :_gcf .Width ,_ggbab :_gcf .Height };
});if _cddg !=nil {return nil ,nil ,_cddg ;};creator .SetNonStrokingColor (_dfcd );};if _daed .BorderEnabled {if _daed ._faeb !=nil {creator .SetStrokingColor (_dec (_daed ._faeb ));};creator .Add_w (_daed .BorderWidth );};if len (_ggfe )> 1{creator .Add_gs (_gd .PdfObjectName (_ggfe ));
};_bf .DrawBezierPathWithCreator (_bgcc ,creator );creator .Add_h ();if _daed .FillEnabled &&_daed .BorderEnabled {creator .Add_B ();}else if _daed .FillEnabled {creator .Add_f ();}else if _daed .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_bfdgc :=_bgcc .GetBoundingBox ();
if _daed .BorderEnabled {_bfdgc .Height +=_daed .BorderWidth ;_bfdgc .Width +=_daed .BorderWidth ;_bfdgc .X -=_daed .BorderWidth /2;_bfdgc .Y -=_daed .BorderWidth /2;};_afaeg :=&_ed .PdfRectangle {};_afaeg .Llx =_bfdgc .X ;_afaeg .Lly =_bfdgc .Y ;_afaeg .Urx =_bfdgc .X +_bfdgc .Width ;
_afaeg .Ury =_bfdgc .Y +_bfdgc .Height ;return creator .Bytes (),_afaeg ,nil ;};

// SetFillColor sets the fill color.
func (_cfff *PolyBezierCurve )SetFillColor (color Color ){_cfff ._gbbdb =color ;_cfff ._cgfd .FillColor =_dec (color );};func (_daffe *templateProcessor )parseBorderRadiusAttr (_ebcc ,_fababc string )(_fgeg ,_cbfcg ,_fddfgf ,_ebdd float64 ){_gfb .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_ebcc ,_fababc );
switch _fgcec :=_de .Fields (_fababc );len (_fgcec ){case 1:_fgeg ,_ =_ad .ParseFloat (_fgcec [0],64);_cbfcg =_fgeg ;_fddfgf =_fgeg ;_ebdd =_fgeg ;case 2:_fgeg ,_ =_ad .ParseFloat (_fgcec [0],64);_fddfgf =_fgeg ;_cbfcg ,_ =_ad .ParseFloat (_fgcec [1],64);
_ebdd =_cbfcg ;case 3:_fgeg ,_ =_ad .ParseFloat (_fgcec [0],64);_cbfcg ,_ =_ad .ParseFloat (_fgcec [1],64);_ebdd =_cbfcg ;_fddfgf ,_ =_ad .ParseFloat (_fgcec [2],64);case 4:_fgeg ,_ =_ad .ParseFloat (_fgcec [0],64);_cbfcg ,_ =_ad .ParseFloat (_fgcec [1],64);
_fddfgf ,_ =_ad .ParseFloat (_fgcec [2],64);_ebdd ,_ =_ad .ParseFloat (_fgcec [3],64);};return _fgeg ,_cbfcg ,_fddfgf ,_ebdd ;};func _dfea ()*FilledCurve {_ggcg :=FilledCurve {};_ggcg ._dabe =[]_bf .CubicBezierCurve {};return &_ggcg ;};

// SkipCells skips over a specified number of cells in the table.
func (_cdgfd *Table )SkipCells (num int ){if num < 0{_gfb .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _cffgg :=0;_cffgg < num ;_cffgg ++{_cdgfd .NewCell ();};};func (_bege *templateProcessor )parseColorAttr (_egdg ,_gecfd string )Color {_gfb .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_egdg ,_gecfd );
_gecfd =_de .TrimSpace (_gecfd );if _de .HasPrefix (_gecfd ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_de .HasSuffix (_gecfd ,"\u0029")&&len (_gecfd )> 17{return _bege .parseLinearGradientAttr (_bege .creator ,_gecfd );
};if _de .HasPrefix (_gecfd ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_de .HasSuffix (_gecfd ,"\u0029")&&len (_gecfd )> 17{return _bege .parseRadialGradientAttr (_bege .creator ,_gecfd );};if _eega :=_bege .parseColor (_gecfd );
_eega !=nil {return _eega ;};return ColorBlack ;};

// Width returns the width of the ellipse.
func (_bdbg *Ellipse )Width ()float64 {return _bdbg ._efge };func _dgeda (_gfaag ...interface{})[]interface{}{return _gfaag };func (_ebdf *templateProcessor )parseFontAttr (_afce ,_acege string )*_ed .PdfFont {_gfb .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_afce ,_acege );
_geaaa :=_ebdf .creator ._egc ;if _acege ==""{return _geaaa ;};_ebfcadc :=_de .Split (_acege ,"\u002c");for _ ,_adbgf :=range _ebfcadc {_adbgf =_de .TrimSpace (_adbgf );if _adbgf ==""{continue ;};_gdbdad ,_gacg :=_ebdf ._bfega .FontMap [_acege ];if _gacg {return _gdbdad ;
};_gdfde ,_gacg :=map[string ]_ed .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_ed .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_ed .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_ed .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_ed .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_ed .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_ed .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_ed .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_ed .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_ed .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_ed .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_ed .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_ed .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_ed .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_ed .TimesBoldItalicName }[_acege ];
if _gacg {if _agbd ,_afbc :=_ed .NewStandard14Font (_gdfde );_afbc ==nil {return _agbd ;};};if _gbbf :=_ebdf .parseAttrPropList (_adbgf );len (_gbbf )> 0{if _dfafd ,_egdcb :=_gbbf ["\u0070\u0061\u0074\u0068"];_egdcb {_egdbf :=_ed .NewPdfFontFromTTFFile ;
if _ccbf ,_gbacc :=_gbbf ["\u0074\u0079\u0070\u0065"];_gbacc &&_ccbf =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_egdbf =_ed .NewCompositePdfFontFromTTFFile ;};if _fgebf ,_fbbe :=_egdbf (_dfafd );_fbbe !=nil {_gfb .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_dfafd ,_fbbe );
}else {return _fgebf ;};};};};return _geaaa ;};

// SetNotes sets the notes section of the invoice.
func (_ffd *Invoice )SetNotes (title ,content string ){_ffd ._cgfce =[2]string {title ,content }};func _deeb (_aggc TextStyle )*List {return &List {_defad :TextChunk {Text :"\u2022\u0020",Style :_aggc },_gdfg :0,_edag :true ,_cegd :PositionRelative ,_aaagc :_aggc };
};

// Level returns the indentation level of the TOC line.
func (_adbce *TOCLine )Level ()uint {return _adbce ._cefgd };

// SetHeight sets the height of the ellipse.
func (_ecce *Ellipse )SetHeight (height float64 ){_ecce ._abda =height };

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_faad *Division )EnablePageWrap (enable bool ){_faad ._dffg =enable };func (_faadd *templateProcessor )parseAttrPropList (_fcbc string )map[string ]string {_egcea :=_de .Fields (_fcbc );if len (_egcea )==0{return nil ;};_geabc :=map[string ]string {};
for _ ,_ecdd :=range _egcea {_bcdda :=_aegd .FindStringSubmatch (_ecdd );if len (_bcdda )< 3{continue ;};_cacc ,_bfcga :=_de .TrimSpace (_bcdda [1]),_bcdda [2];if _cacc ==""{continue ;};_geabc [_cacc ]=_bfcga ;};return _geabc ;};

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_fcddd *Rectangle )BorderOpacity ()float64 {return _fcddd ._fgbf };

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_bge *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bge ._ceaa .Left ,_bge ._ceaa .Right ,_bge ._ceaa .Top ,_bge ._ceaa .Bottom ;};func (_gceb *Table )moveToNextAvailableCell ()int {_acdbd :=(_gceb ._dcef -1)%(_gceb ._dfeg )+1;
for {if _acdbd -1>=len (_gceb ._agdgb ){if _gceb ._agdgb [0]==0{return _acdbd ;};_acdbd =1;}else if _gceb ._agdgb [_acdbd -1]==0{return _acdbd ;};_gceb ._dcef ++;_gceb ._agdgb [_acdbd -1]--;_acdbd ++;};};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_acbbc *Paragraph )SetTextAlignment (align TextAlignment ){_acbbc ._ebaa =align };

// SetBorderColor sets the cell's border color.
func (_fbec *TableCell )SetBorderColor (col Color ){_fbec ._gdga =col ;_fbec ._ddeb =col ;_fbec ._ffgab =col ;_fbec ._bebf =col ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_eaga *TOC )SetShowLinks (showLinks bool ){_eaga ._daedd =showLinks };func _gcagg (_cccaf *Creator ,_eecee _eb .Reader ,_gbga interface{},_bbcf *TemplateOptions ,_fegb componentRenderer )error {if _cccaf ==nil {_gfb .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _cffc ;};_dfcge :="";if _adfba ,_fggdf :=_eecee .(*_gf .File );_fggdf {_dfcge =_adfba .Name ();};_eebb :=_b .NewBuffer (nil );if _ ,_bgfb :=_eb .Copy (_eebb ,_eecee );_bgfb !=nil {return _bgfb ;};_baebd :=_d .FuncMap {"\u0064\u0069\u0063\u0074":_gaade ,"\u0061\u0064\u0064":_dgeae ,"\u0061\u0072\u0072a\u0079":_dgeda ,"\u0065\u0078\u0074\u0065\u006e\u0064\u0044\u0069\u0063\u0074":_caefe ,"\u006da\u006b\u0065\u0053\u0065\u0071":_gaeff };
if _bbcf !=nil &&_bbcf .HelperFuncMap !=nil {for _cegbe ,_efff :=range _bbcf .HelperFuncMap {if _ ,_abdd :=_baebd [_cegbe ];_abdd {_gfb .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cegbe );
continue ;};_baebd [_cegbe ]=_efff ;};};_dacgca ,_ffac :=_d .New ("").Funcs (_baebd ).Parse (_eebb .String ());if _ffac !=nil {return _ffac ;};if _bbcf !=nil &&_bbcf .SubtemplateMap !=nil {for _gadce ,_dddg :=range _bbcf .SubtemplateMap {if _gadce ==""{_gfb .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _dddg ==nil {_gfb .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_agbcf :=_b .NewBuffer (nil );if _ ,_aefag :=_eb .Copy (_agbcf ,_dddg );_aefag !=nil {return _aefag ;};if _ ,_acaf :=_dacgca .New (_gadce ).Parse (_agbcf .String ());_acaf !=nil {return _acaf ;};};};_eebb .Reset ();if _bbgd :=_dacgca .Execute (_eebb ,_gbga );
_bbgd !=nil {return _bbgd ;};return _eebe (_cccaf ,_dfcge ,_eebb .Bytes (),_bbcf ,_fegb ).run ();};

// SetColor sets the line color.
func (_cefad *Curve )SetColor (col Color ){_cefad ._fcadf =col };

// NewImage create a new image from a unidoc image (model.Image).
func (_cbea *Creator )NewImage (img *_ed .Image )(*Image ,error ){return _edcg (img )};func (_eacga *templateProcessor )parseFitModeAttr (_aebdf ,_ecebb string )FitMode {_gfb .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_aebdf ,_ecebb );
_acafb :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_ecebb ];return _acafb ;};

// CurRow returns the currently active cell's row number.
func (_fead *Table )CurRow ()int {_caag :=(_fead ._dcef -1)/_fead ._dfeg +1;return _caag };func (_daaee *templateProcessor )parseListMarker (_gabc *templateNode )(interface{},error ){if _gabc ._gfggb ==nil {_daaee .nodeLogError (_gabc ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_adee ;};var _gggd *TextChunk ;switch _fbbacg :=_gabc ._gfggb ._cagcg .(type ){case *List :_gggd =&_fbbacg ._defad ;case *listItem :_gggd =&_fbbacg ._afdbb ;default:_daaee .nodeLogError (_gabc ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_fbbacg );
return nil ,_adee ;};if _ ,_febbd :=_daaee .parseTextChunk (_gabc ,_gggd );_febbd !=nil {_daaee .nodeLogError (_gabc ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_febbd );
return nil ,nil ;};return _gggd ,nil ;};

// Scale scales Image by a constant factor, both width and height.
func (_fcgb *Image )Scale (xFactor ,yFactor float64 ){_fcgb ._dgfb =xFactor *_fcgb ._dgfb ;_fcgb ._dafe =yFactor *_fcgb ._dafe ;};

// SetBorderWidth sets the border width of the rectangle.
func (_gde *Rectangle )SetBorderWidth (bw float64 ){_gde ._cfdf =bw };

// FitMode returns the fit mode of the ellipse.
func (_fgge *Ellipse )FitMode ()FitMode {return _fgge ._gaeg };

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_gdaa *Division )SetMargins (left ,right ,top ,bottom float64 ){_gdaa ._baad .Left =left ;_gdaa ._baad .Right =right ;_gdaa ._baad .Top =top ;_gdaa ._baad .Bottom =bottom ;};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_cceba *Line )SetColor (color Color ){_cceba ._cdba =color };

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_gadgc float64 ;_adac float64 ;_cegcg float64 ;_ggbab float64 ;_dffd Positioning ;_daage Color ;_efgb float64 ;_feea Color ;_cfdf float64 ;_fgbf float64 ;_gbda float64 ;_gaebc float64 ;_ecga float64 ;_cbca float64 ;_ddfc Margins ;
_gfag FitMode ;};func _dabcb (_eefa *Block ,_ggbee *StyledParagraph ,_egea [][]*TextChunk ,_fadg DrawContext )(DrawContext ,[][]*TextChunk ,error ){_gfgbb :=1;_debdf :=_gd .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gfgbb ));for _eefa ._ece .HasFontByName (_debdf ){_gfgbb ++;
_debdf =_gd .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gfgbb ));};_dbeag :=_eefa ._ece .SetFontByName (_debdf ,_ggbee ._beafc .Font .ToPdfObject ());if _dbeag !=nil {return _fadg ,nil ,_dbeag ;};_gfgbb ++;_affd :=_debdf ;_effed :=_ggbee ._beafc .FontSize ;
_gbbg :=_ggbee ._cbgac .IsRelative ();var _acge [][]_gd .PdfObjectName ;var _fcfge [][]*TextChunk ;var _adcdc float64 ;for _eeb ,_daafa :=range _egea {var _aedf []_gd .PdfObjectName ;var _dgdbc float64 ;if len (_daafa )> 0{_dgdbc =_daafa [0].Style .FontSize ;
};for _ ,_cdaa :=range _daafa {_cdbe :=_cdaa .Style ;if _cdaa .Text !=""&&_cdbe .FontSize > _dgdbc {_dgdbc =_cdbe .FontSize ;};if _dgdbc > _fadg .PageHeight {return _fadg ,nil ,_e .New ("\u0050\u0061\u0072\u0061\u0067\u0072a\u0070\u0068\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u006ca\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0070\u0061\u0067\u0065 \u0068e\u0069\u0067\u0068\u0074");
};_debdf =_gd .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gfgbb ));_ecfc :=_eefa ._ece .SetFontByName (_debdf ,_cdbe .Font .ToPdfObject ());if _ecfc !=nil {return _fadg ,nil ,_ecfc ;};_aedf =append (_aedf ,_debdf );_gfgbb ++;};
_dgdbc *=_ggbee ._agcdg ;if _gbbg &&_adcdc +_dgdbc > _fadg .Height {_fcfge =_egea [_eeb :];_egea =_egea [:_eeb ];break ;};_adcdc +=_dgdbc ;_acge =append (_acge ,_aedf );};_cbbgg ,_bcee ,_cddbb :=_ggbee .getLineMetrics (0);_aebb ,_cfec :=_cbbgg *_ggbee ._agcdg ,_bcee *_ggbee ._agcdg ;
if len (_egea )==0{return _fadg ,_fcfge ,nil ;};_bdcad :=_cc .NewContentCreator ();_bdcad .Add_q ();_acbe :=_cfec ;if _ggbee ._cdcg ==TextVerticalAlignmentCenter {_acbe =_bcee +(_cbbgg +_cddbb -_bcee )/2+(_cfec -_bcee )/2;};_ceebf :=_fadg .PageHeight -_fadg .Y -_acbe ;
_bdcad .Translate (_fadg .X ,_ceebf );_cadba :=_ceebf ;if _ggbee ._edgf !=0{_bdcad .RotateDeg (_ggbee ._edgf );};if _ggbee ._abafe ==TextOverflowHidden {_bdcad .Add_re (0,-_adcdc +_aebb +1,_ggbee ._bcdba ,_adcdc ).Add_W ().Add_n ();};_bdcad .Add_BT ();
var _aged []*_bf .BasicLine ;for _baec ,_fbdf :=range _egea {_ffega :=_fadg .X ;var _edffb float64 ;if len (_fbdf )> 0{_edffb =_fbdf [0].Style .FontSize ;};_cbbgg ,_ ,_cddbb =_ggbee .getLineMetrics (_baec );_cfec =(_cbbgg +_cddbb );for _ ,_ebgc :=range _fbdf {_gfge :=&_ebgc .Style ;
if _ebgc .Text !=""&&_gfge .FontSize > _edffb {_edffb =_gfge .FontSize ;};if _cfec > _edffb {_edffb =_cfec ;};};if _baec !=0{_bdcad .Add_TD (0,-_edffb *_ggbee ._agcdg );_cadba -=_edffb *_ggbee ._agcdg ;};_cdegf :=_baec ==len (_egea )-1;var (_agdea float64 ;
_gffa float64 ;_bbgag *fontMetrics ;_bfdcg float64 ;_egda uint ;);var _eadc []float64 ;for _ ,_fafae :=range _fbdf {_ccfe :=&_fafae .Style ;if _ccfe .FontSize > _gffa {_gffa =_ccfe .FontSize ;_bbgag =_daegd (_fafae .Style .Font ,_ccfe .FontSize );};if _cfec > _gffa {_gffa =_cfec ;
};_dbcea ,_gcecb :=_ccfe .Font .GetRuneMetrics (' ');if _dbcea .Wx ==0&&_ccfe .MultiFont !=nil {_dbcea ,_gcecb =_ccfe .MultiFont .GetRuneMetrics (' ');_ccfe .MultiFont .Reset ();};if !_gcecb {return _fadg ,nil ,_e .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _agdf uint ;var _fcfgeb float64 ;_gecef :=len (_fafae .Text );for _bgbf ,_baed :=range _fafae .Text {if _baed ==' '{_agdf ++;continue ;};if _baed =='\u000A'{continue ;};_aefbd ,_baga :=_ccfe .Font .GetRuneMetrics (_baed );if _aefbd .Wx ==0&&_ccfe .MultiFont !=nil {_aefbd ,_baga =_ccfe .MultiFont .GetRuneMetrics (' ');
_ccfe .MultiFont .Reset ();};if !_baga {_gfb .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_baed );return _fadg ,nil ,_e .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");
};_fcfgeb +=_ccfe .FontSize *_aefbd .Wx *_ccfe .horizontalScale ();if _bgbf !=_gecef -1{_fcfgeb +=_ccfe .CharSpacing *1000.0;};};_eadc =append (_eadc ,_fcfgeb );_agdea +=_fcfgeb ;_bfdcg +=float64 (_agdf )*_dbcea .Wx *_ccfe .FontSize *_ccfe .horizontalScale ();
_egda +=_agdf ;};_gffa *=_ggbee ._agcdg ;var _fgca []_gd .PdfObject ;_eddff :=_ggbee ._bcdba *1000.0;if _ggbee ._fgfd ==TextAlignmentJustify {if _egda > 0&&!_cdegf {_bfdcg =(_eddff -_agdea )/float64 (_egda )/_effed ;};}else if _ggbee ._fgfd ==TextAlignmentCenter {_bffcg :=(_eddff -_agdea -_bfdcg )/2;
_cgbf :=_bffcg /_effed ;_fgca =append (_fgca ,_gd .MakeFloat (-_cgbf ));_ffega +=_bffcg /1000.0;}else if _ggbee ._fgfd ==TextAlignmentRight {_caea :=(_eddff -_agdea -_bfdcg );_cbegc :=_caea /_effed ;_fgca =append (_fgca ,_gd .MakeFloat (-_cbegc ));_ffega +=_caea /1000.0;
};if len (_fgca )> 0{_bdcad .Add_Tf (_affd ,_effed ).Add_TL (_effed *_ggbee ._agcdg ).Add_TJ (_fgca ...);};_ffgf :=0.0;for _fbge ,_ebcd :=range _fbdf {_dbdc :=&_ebcd .Style ;_bged :=_affd ;_fbaga :=_effed ;_dbee :=_dbdc .OutlineColor !=nil ;_abbd :=_dbdc .HorizontalScaling !=DefaultHorizontalScaling ;
_beceb :=_dbdc .OutlineSize !=1;if _beceb {_bdcad .Add_w (_dbdc .OutlineSize );};_cgaf :=_dbdc .RenderingMode !=TextRenderingModeFill ;if _cgaf {_bdcad .Add_Tr (int64 (_dbdc .RenderingMode ));};_dffa :=_dbdc .CharSpacing !=0;if _dffa {_bdcad .Add_Tc (_dbdc .CharSpacing );
};_bcegg :=_dbdc .TextRise !=0;if _bcegg {_bdcad .Add_Ts (_dbdc .TextRise );};if _ebcd .VerticalAlignment !=TextVerticalAlignmentBaseline {_cegg :=_daegd (_ebcd .Style .Font ,_dbdc .FontSize );switch _ebcd .VerticalAlignment {case TextVerticalAlignmentCenter :_ffgf =_bbgag ._ebdef /2-_cegg ._ebdef /2;
case TextVerticalAlignmentBottom :_ffgf =_bbgag ._ccdgd -_cegg ._ccdgd ;case TextVerticalAlignmentTop :_ffgf =_bcee -_dbdc .FontSize ;};if _ffgf !=0.0{_bdcad .Translate (0,_ffgf );};};if _ggbee ._fgfd !=TextAlignmentJustify ||_cdegf {_gfaac ,_agdb :=_dbdc .Font .GetRuneMetrics (' ');
if !_agdb {return _fadg ,nil ,_e .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_bged =_acge [_baec ][_fbge ];_fbaga =_dbdc .FontSize ;
_bfdcg =_gfaac .Wx *_dbdc .horizontalScale ();};_afgd :=_dbdc .Font .Encoder ();var _acbbb []byte ;var _dafb bool ;_cgcb :=_dbdc .Font ;for _ ,_efce :=range _ebcd .Text {if _efce =='\u000A'{continue ;};if _efce ==' '{if len (_acbbb )> 0{if _dbee {_bdcad .SetStrokingColor (_dec (_dbdc .OutlineColor ));
};if _abbd {_bdcad .Add_Tz (_dbdc .HorizontalScaling );};_cgce :=_acge [_baec ][_fbge ];if _dafb {_cgce =_gd .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gfgbb ));_gaca :=_eefa ._ece .SetFontByName (_cgce ,_cgcb .ToPdfObject ());
if _gaca !=nil {return _fadg ,nil ,_gaca ;};_gfgbb ++;_dafb =false ;_afgd =_dbdc .Font .Encoder ();};_bdcad .SetNonStrokingColor (_dec (_dbdc .Color )).Add_Tf (_cgce ,_dbdc .FontSize ).Add_TJ ([]_gd .PdfObject {_gd .MakeStringFromBytes (_acbbb )}...);_acbbb =nil ;
};if _abbd {_bdcad .Add_Tz (DefaultHorizontalScaling );};_bdcad .Add_Tf (_bged ,_fbaga ).Add_TJ ([]_gd .PdfObject {_gd .MakeFloat (-_bfdcg )}...);_eadc [_fbge ]+=_bfdcg *_fbaga ;}else {if _ ,_agab :=_afgd .RuneToCharcode (_efce );!_agab {if _dbdc .MultiFont !=nil {_cfgg ,_acgbe :=_dbdc .MultiFont .Encoder (_efce );
if _acgbe {if len (_acbbb )!=0{_acbbd :=_gd .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gfgbb ));_abbaf :=_eefa ._ece .SetFontByName (_bged ,_cgcb .ToPdfObject ());if _abbaf !=nil {return _fadg ,nil ,_abbaf ;};_bdcad .SetNonStrokingColor (_dec (_dbdc .Color )).Add_Tf (_acbbd ,_dbdc .FontSize ).Add_TJ ([]_gd .PdfObject {_gd .MakeStringFromBytes (_acbbb )}...);
_gfgbb ++;_acbbb =nil ;};_afgd =_cfgg ;_dafb =true ;_cgcb =_dbdc .MultiFont .CurrentFont ;};}else {_dbeag =UnsupportedRuneError {Message :_f .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_efce ,_efce ),Rune :_efce };
_fadg ._gac =append (_fadg ._gac ,_dbeag );_gfb .Log .Debug (_dbeag .Error ());if _fadg ._gfbg <=0{continue ;};_efce =_fadg ._gfbg ;};};_adgab :=_afgd .Encode (string (_efce ));_acbbb =append (_acbbb ,_adgab ...);};if _dbdc .MultiFont !=nil {_dbdc .MultiFont .Reset ();
};};if len (_acbbb )> 0{if _dbee {_bdcad .SetStrokingColor (_dec (_dbdc .OutlineColor ));};if _abbd {_bdcad .Add_Tz (_dbdc .HorizontalScaling );};_cagg :=_acge [_baec ][_fbge ];if _dafb {_cagg =_gd .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gfgbb ));
_dabcba :=_eefa ._ece .SetFontByName (_cagg ,_cgcb .ToPdfObject ());if _dabcba !=nil {return _fadg ,nil ,_dabcba ;};_gfgbb ++;_dafb =false ;};_bdcad .SetNonStrokingColor (_dec (_dbdc .Color )).Add_Tf (_cagg ,_dbdc .FontSize ).Add_TJ ([]_gd .PdfObject {_gd .MakeStringFromBytes (_acbbb )}...);
};_cdcfc :=_eadc [_fbge ]/1000.0;if _dbdc .Underline {_gcbbd :=_dbdc .UnderlineStyle .Color ;if _gcbbd ==nil {_gcbbd =_ebcd .Style .Color ;};_dceg ,_efccd ,_badd :=_gcbbd .ToRGB ();_bfdea :=_ffega -_fadg .X ;_aefe :=_cadba -_ceebf +_dbdc .TextRise -_dbdc .UnderlineStyle .Offset ;
_aged =append (_aged ,&_bf .BasicLine {X1 :_bfdea ,Y1 :_aefe ,X2 :_bfdea +_cdcfc ,Y2 :_aefe ,LineWidth :_ebcd .Style .UnderlineStyle .Thickness ,LineColor :_ed .NewPdfColorDeviceRGB (_dceg ,_efccd ,_badd )});};if _ebcd ._eefeb !=nil {var _adfb *_gd .PdfObjectArray ;
if !_ebcd ._egae {switch _dbdb :=_ebcd ._eefeb .GetContext ().(type ){case *_ed .PdfAnnotationLink :_adfb =_gd .MakeArray ();_dbdb .Rect =_adfb ;_dedca ,_fccbe :=_dbdb .Dest .(*_gd .PdfObjectArray );if _fccbe &&_dedca .Len ()==5{_gdbg ,_ffbb :=_dedca .Get (1).(*_gd .PdfObjectName );
if _ffbb &&_gdbg .String ()=="\u0058\u0059\u005a"{_aagbge ,_fabdd :=_gd .GetNumberAsFloat (_dedca .Get (3));if _fabdd ==nil {_dedca .Set (3,_gd .MakeFloat (_fadg .PageHeight -_aagbge ));};};};};_ebcd ._egae =true ;};if _adfb !=nil {_ffdf :=_bf .NewPoint (_ffega -_fadg .X ,_cadba +_dbdc .TextRise -_ceebf ).Rotate (_ggbee ._edgf );
_ffdf .X +=_fadg .X ;_ffdf .Y +=_ceebf ;_gade ,_afebc ,_cegfgc ,_gddbe :=_dddge (_cdcfc ,_gffa ,_ggbee ._edgf );_ffdf .X +=_gade ;_ffdf .Y +=_afebc ;_adfb .Clear ();_adfb .Append (_gd .MakeFloat (_ffdf .X ));_adfb .Append (_gd .MakeFloat (_ffdf .Y ));_adfb .Append (_gd .MakeFloat (_ffdf .X +_cegfgc ));
_adfb .Append (_gd .MakeFloat (_ffdf .Y +_gddbe ));};_eefa .AddAnnotation (_ebcd ._eefeb );};_ffega +=_cdcfc ;if _beceb {_bdcad .Add_w (1.0);};if _dbee {_bdcad .Add_RG (0.0,0.0,0.0);};if _cgaf {_bdcad .Add_Tr (int64 (TextRenderingModeFill ));};if _dffa {_bdcad .Add_Tc (0);
};if _bcegg {_bdcad .Add_Ts (0);};if _abbd {_bdcad .Add_Tz (DefaultHorizontalScaling );};if _ffgf !=0.0{_bdcad .Translate (0,-_ffgf );_ffgf =0.0;};};};_bdcad .Add_ET ();for _ ,_bfbc :=range _aged {_bdcad .SetStrokingColor (_bfbc .LineColor ).Add_w (_bfbc .LineWidth ).Add_m (_bfbc .X1 ,_bfbc .Y1 ).Add_l (_bfbc .X2 ,_bfbc .Y2 ).Add_s ();
};_bdcad .Add_Q ();_ccdc :=_bdcad .Operations ();_ccdc .WrapIfNeeded ();_eefa .addContents (_ccdc );if _gbbg {_aaca :=_adcdc ;_fadg .Y +=_aaca ;_fadg .Height -=_aaca ;if _fadg .Inline {_fadg .X +=_ggbee .Width ()+_ggbee ._acbfg .Right ;};};return _fadg ,_fcfge ,nil ;
};

// LevelOffset returns the amount of space an indentation level occupies.
func (_gebgd *TOCLine )LevelOffset ()float64 {return _gebgd ._fabb };func (_fgad *Invoice )generateTotalBlocks (_agff DrawContext )([]*Block ,DrawContext ,error ){_baab :=_gegfb (4);_baab .SetMargins (0,0,10,10);_ddbc :=[][2]*InvoiceCell {_fgad ._abgd };
_ddbc =append (_ddbc ,_fgad ._dgab ...);_ddbc =append (_ddbc ,_fgad ._acgc );for _ ,_feb :=range _ddbc {_gdab ,_bcfg :=_feb [0],_feb [1];if _bcfg .Value ==""{continue ;};_baab .SkipCells (2);_cfcda :=_baab .NewCell ();_cfcda .SetBackgroundColor (_gdab .BackgroundColor );
_cfcda .SetHorizontalAlignment (_bcfg .Alignment );_fgad .setCellBorder (_cfcda ,_gdab );_cge :=_cfeea (_gdab .TextStyle );_cge .SetMargins (0,0,2,1);_cge .Append (_gdab .Value );_cfcda .SetContent (_cge );_cfcda =_baab .NewCell ();_cfcda .SetBackgroundColor (_bcfg .BackgroundColor );
_cfcda .SetHorizontalAlignment (_bcfg .Alignment );_fgad .setCellBorder (_cfcda ,_gdab );_cge =_cfeea (_bcfg .TextStyle );_cge .SetMargins (0,0,2,1);_cge .Append (_bcfg .Value );_cfcda .SetContent (_cge );};return _baab .GeneratePageBlocks (_agff );};func (_fdec grayColor )ToRGB ()(float64 ,float64 ,float64 ){return _fdec ._faf ,_fdec ._faf ,_fdec ._faf };


// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_gfgf *Creator )Finalize ()error {if _gfgf ._aded {return nil ;};_fbb :=len (_gfgf ._fgdd );_dcd :=0;if _gfgf ._fcc !=nil {_acf :=*_gfgf ;_gfgf ._fgdd =nil ;_gfgf ._eed =nil ;_gfgf .initContext ();_afac :=FrontpageFunctionArgs {PageNum :1,TotalPages :_fbb };
_gfgf ._fcc (_afac );_dcd +=len (_gfgf ._fgdd );_gfgf ._fgdd =_acf ._fgdd ;_gfgf ._eed =_acf ._eed ;};if _gfgf .AddTOC {_gfgf .initContext ();_gfgf ._abe .Page =_dcd +1;if _gfgf .CustomTOC &&_gfgf ._acee !=nil {_cacdc :=*_gfgf ;_gfgf ._fgdd =nil ;_gfgf ._eed =nil ;
if _bebg :=_gfgf ._acee (_gfgf ._dcag );_bebg !=nil {return _bebg ;};_dcd +=len (_gfgf ._fgdd );_gfgf ._fgdd =_cacdc ._fgdd ;_gfgf ._eed =_cacdc ._eed ;}else {if _gfgf ._acee !=nil {if _dcae :=_gfgf ._acee (_gfgf ._dcag );_dcae !=nil {return _dcae ;};};
_eab ,_ ,_cbga :=_gfgf ._dcag .GeneratePageBlocks (_gfgf ._abe );if _cbga !=nil {_gfb .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_cbga );
return _cbga ;};_dcd +=len (_eab );};_gdcg :=_gfgf ._dcag .Lines ();for _ ,_fdecf :=range _gdcg {_fdff ,_cbdf :=_ad .Atoi (_fdecf .Page .Text );if _cbdf !=nil {continue ;};_fdecf .Page .Text =_ad .Itoa (_fdff +_dcd );_fdecf ._bceb +=int64 (_dcd );};};_facg :=false ;
var _bdgg []*_ed .PdfPage ;if _gfgf ._fcc !=nil {_adcd :=*_gfgf ;_gfgf ._fgdd =nil ;_gfgf ._eed =nil ;_ecgdd :=FrontpageFunctionArgs {PageNum :1,TotalPages :_fbb };_gfgf ._fcc (_ecgdd );_fbb +=len (_gfgf ._fgdd );_bdgg =_gfgf ._fgdd ;_gfgf ._fgdd =append (_gfgf ._fgdd ,_adcd ._fgdd ...);
_gfgf ._eed =_adcd ._eed ;_facg =true ;};var _ggga []*_ed .PdfPage ;if _gfgf .AddTOC {_gfgf .initContext ();if _gfgf .CustomTOC &&_gfgf ._acee !=nil {_aeec :=*_gfgf ;_gfgf ._fgdd =nil ;_gfgf ._eed =nil ;if _adab :=_gfgf ._acee (_gfgf ._dcag );_adab !=nil {_gfb .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_adab );
return _adab ;};_ggga =_gfgf ._fgdd ;_fbb +=len (_ggga );_gfgf ._fgdd =_aeec ._fgdd ;_gfgf ._eed =_aeec ._eed ;}else {if _gfgf ._acee !=nil {if _baff :=_gfgf ._acee (_gfgf ._dcag );_baff !=nil {_gfb .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_baff );
return _baff ;};};_abc ,_ ,_ :=_gfgf ._dcag .GeneratePageBlocks (_gfgf ._abe );for _ ,_bcb :=range _abc {_bcb .SetPos (0,0);_fbb ++;_caeb :=_gfgf .newPage ();_ggga =append (_ggga ,_caeb );_gfgf .setActivePage (_caeb );_gfgf .Draw (_bcb );};};if _facg {_geeda :=_bdgg ;
_ede :=_gfgf ._fgdd [len (_bdgg ):];_gfgf ._fgdd =append ([]*_ed .PdfPage {},_geeda ...);_gfgf ._fgdd =append (_gfgf ._fgdd ,_ggga ...);_gfgf ._fgdd =append (_gfgf ._fgdd ,_ede ...);}else {_gfgf ._fgdd =append (_ggga ,_gfgf ._fgdd ...);};};if _gfgf ._dccf !=nil &&_gfgf .AddOutlines {var _caf func (_daaf *_ed .OutlineItem );
_caf =func (_egfe *_ed .OutlineItem ){_egfe .Dest .Page +=int64 (_dcd );if _cgg :=int (_egfe .Dest .Page );_cgg >=0&&_cgg < len (_gfgf ._fgdd ){_egfe .Dest .PageObj =_gfgf ._fgdd [_cgg ].GetPageAsIndirectObject ();}else {_gfb .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_cgg );
};_egfe .Dest .Y =_gfgf ._adc -_egfe .Dest .Y ;_aaec :=_egfe .Items ();for _ ,_cefa :=range _aaec {_caf (_cefa );};};_baac :=_gfgf ._dccf .Items ();for _ ,_bagg :=range _baac {_caf (_bagg );};if _gfgf .AddTOC {var _eacae int ;if _facg {_eacae =len (_bdgg );
};_edde :=_ed .NewOutlineDest (int64 (_eacae ),0,_gfgf ._adc );if _eacae >=0&&_eacae < len (_gfgf ._fgdd ){_edde .PageObj =_gfgf ._fgdd [_eacae ].GetPageAsIndirectObject ();}else {_gfb .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_eacae );
};_gfgf ._dccf .Insert (0,_ed .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_edde ));};};for _bdce ,_abfc :=range _gfgf ._fgdd {_gfgf .setActivePage (_abfc );if _gfgf ._cgbd !=nil {_dcaa ,_bade ,_bec :=_abfc .Size ();
if _bec !=nil {return _bec ;};_aeeca :=PageFinalizeFunctionArgs {PageNum :_bdce +1,PageWidth :_dcaa ,PageHeight :_bade ,TOCPages :len (_ggga ),TotalPages :_fbb };if _ccee :=_gfgf ._cgbd (_aeeca );_ccee !=nil {_gfb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_ccee );
return _ccee ;};};if _gfgf ._fdbc !=nil {_aede :=NewBlock (_gfgf ._ffeg ,_gfgf ._ggeg .Top );_deee :=HeaderFunctionArgs {PageNum :_bdce +1,TotalPages :_fbb };_gfgf ._fdbc (_aede ,_deee );_aede .SetPos (0,0);if _aadb :=_gfgf .Draw (_aede );_aadb !=nil {_gfb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_aadb );
return _aadb ;};};if _gfgf ._adff !=nil {_dcfb :=NewBlock (_gfgf ._ffeg ,_gfgf ._ggeg .Bottom );_caba :=FooterFunctionArgs {PageNum :_bdce +1,TotalPages :_fbb };_gfgf ._adff (_dcfb ,_caba );_dcfb .SetPos (0,_gfgf ._adc -_dcfb ._ag );if _edfa :=_gfgf .Draw (_dcfb );
_edfa !=nil {_gfb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_edfa );return _edfa ;};};_bbdg ,_efabf :=_gfgf ._cgf [_abfc ];if _addg ,_bdcd :=_gfgf ._dddac [_abfc ];
_bdcd {if _efabf {_bbdg .transformBlock (_addg );};if _efba :=_addg .drawToPage (_abfc );_efba !=nil {_gfb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_bdce +1,_efba );
return _efba ;};};if _efabf {if _dcbf :=_bbdg .transformPage (_abfc );_dcbf !=nil {_gfb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_dcbf );
return _dcbf ;};};};_gfgf ._aded =true ;return nil ;};func (_gdca *templateProcessor )parseInt64Array (_eeceg ,_ccgf string )[]int64 {_gfb .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_eeceg ,_ccgf );
_gdae :=_de .Fields (_ccgf );_acgeb :=make ([]int64 ,0,len (_gdae ));for _ ,_eddac :=range _gdae {_ffce ,_ :=_ad .ParseInt (_eddac ,10,64);_acgeb =append (_acgeb ,_ffce );};return _acgeb ;};

// Positioning returns the type of positioning the ellipse is set to use.
func (_geceb *Ellipse )Positioning ()Positioning {return _geceb ._dfda };func (_dbed *templateProcessor )parseTextChunk (_fcebff *templateNode ,_dddgf *TextChunk )(interface{},error ){if _fcebff ._gfggb ==nil {_dbed .nodeLogError (_fcebff ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_adee ;};var (_ccacf =_dbed .creator .NewTextStyle ();_ffdfb bool ;);for _ ,_dabcd :=range _fcebff ._adbf .Attr {if _dabcd .Name .Local =="\u006c\u0069\u006e\u006b"{_ggdge ,_gdcda :=_fcebff ._gfggb ._cagcg .(*StyledParagraph );if !_gdcda {_dbed .nodeLogError (_fcebff ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_ffdfb =true ;}else {_ccacf =_ggdge ._fbag ;};break ;};};if _dddgf ==nil {_dddgf =NewTextChunk ("",_ccacf );};for _ ,_acfaf :=range _fcebff ._adbf .Attr {_egde :=_acfaf .Value ;switch _cbag :=_acfaf .Name .Local ;_cbag {case "\u0063\u006f\u006co\u0072":_dddgf .Style .Color =_dbed .parseColorAttr (_cbag ,_egde );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_dddgf .Style .OutlineColor =_dbed .parseColorAttr (_cbag ,_egde );case "\u0066\u006f\u006e\u0074":_dddgf .Style .Font =_dbed .parseFontAttr (_cbag ,_egde );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_dddgf .Style .FontSize =_dbed .parseFloatAttr (_cbag ,_egde );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_dddgf .Style .OutlineSize =_dbed .parseFloatAttr (_cbag ,_egde );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_dddgf .Style .CharSpacing =_dbed .parseFloatAttr (_cbag ,_egde );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_dddgf .Style .HorizontalScaling =_dbed .parseFloatAttr (_cbag ,_egde );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_dddgf .Style .RenderingMode =_dbed .parseTextRenderingModeAttr (_cbag ,_egde );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_dddgf .Style .Underline =_dbed .parseBoolAttr (_cbag ,_egde );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_dddgf .Style .UnderlineStyle .Color =_dbed .parseColorAttr (_cbag ,_egde );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_dddgf .Style .UnderlineStyle .Offset =_dbed .parseFloatAttr (_cbag ,_egde );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_dddgf .Style .UnderlineStyle .Thickness =_dbed .parseFloatAttr (_cbag ,_egde );
case "\u006c\u0069\u006e\u006b":if !_ffdfb {_dddgf ._eefeb =_dbed .parseLinkAttr (_cbag ,_egde );};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_dddgf .Style .TextRise =_dbed .parseFloatAttr (_cbag ,_egde );default:_dbed .nodeLogDebug (_fcebff ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_cbag );
};};return _dddgf ,nil ;};func (_efaggc *templateProcessor )nodeError (_acdef *templateNode ,_ceed string ,_fbfde ...interface{})error {return _f .Errorf (_efaggc .getNodeErrorLocation (_acdef ,_ceed ,_fbfde ...));};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bdgf *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _bdgf ._abgd [0],_bdgf ._abgd [1]};func (_cfcb *Invoice )generateLineBlocks (_egfa DrawContext )([]*Block ,DrawContext ,error ){_dfge :=_gegfb (len (_cfcb ._dfdgd ));_dfge .SetMargins (0,0,25,0);
for _ ,_dacb :=range _cfcb ._dfdgd {_degffa :=_cfeea (_dacb .TextStyle );_degffa .SetMargins (0,0,1,0);_degffa .Append (_dacb .Value );_dcfa :=_dfge .NewCell ();_dcfa .SetHorizontalAlignment (_dacb .Alignment );_dcfa .SetBackgroundColor (_dacb .BackgroundColor );
_cfcb .setCellBorder (_dcfa ,_dacb );_dcfa .SetContent (_degffa );};for _ ,_aeea :=range _cfcb ._fafff {for _ ,_feae :=range _aeea {_eceg :=_cfeea (_feae .TextStyle );_eceg .SetMargins (0,0,3,2);_eceg .Append (_feae .Value );_abff :=_dfge .NewCell ();_abff .SetHorizontalAlignment (_feae .Alignment );
_abff .SetBackgroundColor (_feae .BackgroundColor );_cfcb .setCellBorder (_abff ,_feae );_abff .SetContent (_eceg );};};return _dfge .GeneratePageBlocks (_egfa );};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_eeac *Table )Width ()float64 {return 0};func (_fccg *Table )clone ()*Table {_bcbgb :=*_fccg ;_bcbgb ._eegf =make ([]float64 ,len (_fccg ._eegf ));copy (_bcbgb ._eegf ,_fccg ._eegf );_bcbgb ._dbeeb =make ([]float64 ,len (_fccg ._dbeeb ));copy (_bcbgb ._dbeeb ,_fccg ._dbeeb );
_bcbgb ._cfcdg =make ([]*TableCell ,0,len (_fccg ._cfcdg ));for _ ,_gaac :=range _fccg ._cfcdg {_ebga :=*_gaac ;_ebga ._afbd =&_bcbgb ;_bcbgb ._cfcdg =append (_bcbgb ._cfcdg ,&_ebga );};return &_bcbgb ;};

// SetStyleRight sets border style for right side.
func (_faee *border )SetStyleRight (style CellBorderStyle ){_faee ._dbf =style };

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_eedf *Invoice )SetAddressHeadingStyle (style TextStyle ){_eedf ._fgdg =style };func (_cbcb *Paragraph )getTextLineWidth (_begb string )float64 {var _aagg float64 ;for _ ,_cbf :=range _begb {if _cbf =='\u000A'{continue ;};_dcfe ,_abce :=_cbcb ._bbcb .GetRuneMetrics (_cbf );
if !_abce {_gfb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_cbf ,_cbf );
return -1;};_aagg +=_cbcb ._afffc *_dcfe .Wx ;};return _aagg ;};

// SetRowHeight sets the height for a specified row.
func (_cfbb *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_cfbb ._eegf ){return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cfbb ._eegf [row -1]=h ;return nil ;
};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_fecec *RadialShading )AddPatternResource (block *Block )(_aaaga _gd .PdfObjectName ,_gdeb error ){_gadd :=1;_fecgd :=_gd .PdfObjectName ("\u0050"+_ad .Itoa (_gadd ));for block ._ece .HasPatternByName (_fecgd ){_gadd ++;_fecgd =_gd .PdfObjectName ("\u0050"+_ad .Itoa (_gadd ));
};if _cgbca :=block ._ece .SetPatternByName (_fecgd ,_fecec .ToPdfShadingPattern ().ToPdfObject ());_cgbca !=nil {return "",_cgbca ;};return _fecgd ,nil ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_bbccc *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _bbccc ._dffgg ,_bbccc ._acad ,_bbccc ._fbfbg ,_bbccc ._dbd ;};

// SetIndent sets the cell's left indent.
func (_edcbg *TableCell )SetIndent (indent float64 ){_edcbg ._bgeed =indent };func (_cacce *TOCLine )getLineLink ()*_ed .PdfAnnotation {if _cacce ._bceb <=0{return nil ;};return _bfee (_cacce ._bceb -1,_cacce ._edacd ,_cacce ._gdedb ,0);};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_afag *Creator )NewPolyBezierCurve (curves []_bf .CubicBezierCurve )*PolyBezierCurve {return _geae (curves );};func _ccgg (_dcfcc *templateProcessor ,_fcbacc *templateNode )(interface{},error ){return _dcfcc .parseRectangle (_fcbacc );};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_eddec *TOCLine )SetLevelOffset (levelOffset float64 ){_eddec ._fabb =levelOffset ;_eddec ._fbaf ._acbfg .Left =_eddec ._gabdg +float64 (_eddec ._cefgd -1)*_eddec ._fabb ;};

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_dbagb *Rectangle )SetCoords (x ,y float64 ){_dbagb ._gadgc =x ;_dbagb ._adac =y };func (_cfaaa *Table )getLastCellFromCol (_feee int )(int ,*TableCell ){for _fcga :=len (_cfaaa ._cfcdg )-1;_fcga >=0;_fcga --{if _cfaaa ._cfcdg [_fcga ]._eafa ==_feee {return _fcga ,_cfaaa ._cfcdg [_fcga ];
};};return 0,nil ;};var (_aegd =_fb .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");_cffc =_e .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");
_adee =_e .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");_fgbc =_e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");
_gcbe =_e .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e"););

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetFillColor sets the fill color for the path.
func (_fabg *FilledCurve )SetFillColor (color Color ){_fabg ._eea =color };

// SetFillColor sets the fill color.
func (_aaf *CurvePolygon )SetFillColor (color Color ){_aaf ._aeef =color ;_aaf ._gfae .FillColor =_dec (color );};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_bbb *Block )ScaleToWidth (w float64 ){_eee :=w /_bbb ._bc ;_bbb .Scale (_eee ,_eee )};

// Length calculates and returns the length of the line.
func (_aebdb *Line )Length ()float64 {return _cf .Sqrt (_cf .Pow (_aebdb ._fbfbg -_aebdb ._dffgg ,2.0)+_cf .Pow (_aebdb ._dbd -_aebdb ._acad ,2.0));};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_afacd *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_gfcc :=range subtable ._cfcdg {_dedgc :=&TableCell {};*_dedgc =*_gfcc ;_dedgc ._afbd =_afacd ;_dedgc ._eafa +=col -1;if _abdcf :=_afacd ._dfeg -(_dedgc ._eafa -1);_abdcf < _dedgc ._edaeg {_afacd ._dfeg +=_dedgc ._edaeg -_abdcf ;
_afacd .resetColumnWidths ();_gfb .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_afacd ._dfeg );
};_dedgc ._ggccd +=row -1;_beea :=subtable ._eegf [_gfcc ._ggccd -1];if _dedgc ._ggccd > _afacd ._egged {for _dedgc ._ggccd > _afacd ._egged {_afacd ._egged ++;_afacd ._eegf =append (_afacd ._eegf ,_afacd ._fgac );};_afacd ._eegf [_dedgc ._ggccd -1]=_beea ;
}else {_afacd ._eegf [_dedgc ._ggccd -1]=_cf .Max (_afacd ._eegf [_dedgc ._ggccd -1],_beea );};_afacd ._cfcdg =append (_afacd ._cfcdg ,_dedgc );};_afacd .sortCells ();};

// DrawWithContext draws the Block using the specified drawing context.
func (_ccea *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_dd ,_ ,_eba :=d .GeneratePageBlocks (ctx );if _eba !=nil {return _eba ;};if len (_dd )!=1{return ErrContentNotFit ;};for _ ,_fff :=range _dd {if _daa :=_ccea .mergeBlocks (_fff );
_daa !=nil {return _daa ;};};return nil ;};

// SetLineWidth sets the line width.
func (_dabc *Line )SetLineWidth (width float64 ){_dabc ._cdff =width };

// AddLine adds a new line with the provided style to the table of contents.
func (_eecbca *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_eecbca ._ffge =append (_eecbca ._ffge ,line );return line ;};

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_fac *Chapter )Add (d Drawable )error {if Drawable (_fac )==d {_gfb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _bgc :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_fac ._age =append (_fac ._age ,d );case containerDrawable :_fbed ,_baeg :=_bgc .ContainerComponent (_fac );
if _baeg !=nil {return _baeg ;};_fac ._age =append (_fac ._age ,_fbed );default:_gfb .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _e .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};func (_gcgfg *Table )wrapRow (_gabd int ,_cbedc DrawContext ,_bcfed float64 )(bool ,error ){if !_gcgfg ._egegc {return false ,nil ;};var (_bdgad =_gcgfg ._cfcdg [_gabd ];_egfc =-1;_gdbff []*TableCell ;_acgd float64 ;_cfeaf bool ;_cgfcd =make ([]float64 ,0,len (_gcgfg ._dbeeb ));
);_feda :=func (_baccf *TableCell ,_egdff VectorDrawable ,_gddf bool )*TableCell {_gcabf :=*_baccf ;_gcabf ._aeeee =_egdff ;if _gddf {_gcabf ._ggccd ++;};return &_gcabf ;};_gbcd :=func (_dgdea int ,_dfga VectorDrawable ){var _cfdfc float64 =-1;if _dfga ==nil {if _cede :=_cgfcd [_dgdea -_gabd ];
_cede > _cbedc .Height {_dfga =_gcgfg ._cfcdg [_dgdea ]._aeeee ;_gcgfg ._cfcdg [_dgdea ]._aeeee =nil ;_cgfcd [_dgdea -_gabd ]=0;_cfdfc =_cede ;};};_dabca :=_feda (_gcgfg ._cfcdg [_dgdea ],_dfga ,true );_gdbff =append (_gdbff ,_dabca );if _cfdfc < 0{_cfdfc =_dabca .height (_cbedc .Width );
};if _cfdfc > _acgd {_acgd =_cfdfc ;};};for _edaaf :=_gabd ;_edaaf < len (_gcgfg ._cfcdg );_edaaf ++{_ggdgg :=_gcgfg ._cfcdg [_edaaf ];if _bdgad ._ggccd !=_ggdgg ._ggccd {_egfc =_edaaf ;break ;};_cbedc .Width =_ggdgg .width (_gcgfg ._dbeeb ,_bcfed );_dgae :=_ggdgg .height (_cbedc .Width );
var _gfaeb VectorDrawable ;switch _cgbg :=_ggdgg ._aeeee .(type ){case *StyledParagraph :if _dgae > _cbedc .Height {_faagf :=_cbedc ;_faagf .Height =_cf .Floor (_cbedc .Height -_cgbg ._acbfg .Top -_cgbg ._acbfg .Bottom -0.5*_cgbg .getTextHeight ());_ffde ,_dabdg ,_ega :=_cgbg .split (_faagf );
if _ega !=nil {return false ,_ega ;};if _ffde !=nil &&_dabdg !=nil {_cgbg =_ffde ;_ggdgg =_feda (_ggdgg ,_ffde ,false );_gcgfg ._cfcdg [_edaaf ]=_ggdgg ;_gfaeb =_dabdg ;_cfeaf =true ;};_dgae =_ggdgg .height (_cbedc .Width );};case *Division :if _dgae > _cbedc .Height {_cfab :=_cbedc ;
_cfab .Height =_cf .Floor (_cbedc .Height -_cgbg ._baad .Top -_cgbg ._baad .Bottom );_eebf ,_gcdcd :=_cgbg .split (_cfab );if _eebf !=nil &&_gcdcd !=nil {_cgbg =_eebf ;_ggdgg =_feda (_ggdgg ,_eebf ,false );_gcgfg ._cfcdg [_edaaf ]=_ggdgg ;_gfaeb =_gcdcd ;
_cfeaf =true ;if _eebf ._aadg !=nil {_eebf ._aadg .BorderRadiusBottomLeft =0;_eebf ._aadg .BorderRadiusBottomRight =0;};if _gcdcd ._aadg !=nil {_gcdcd ._aadg .BorderRadiusTopLeft =0;_gcdcd ._aadg .BorderRadiusTopRight =0;};_dgae =_ggdgg .height (_cbedc .Width );
};};case *List :if _dgae > _cbedc .Height {_fdfd :=_cbedc ;_fdfd .Height =_cf .Floor (_cbedc .Height -_cgbg ._afded .Vertical ());_febb ,_dagg :=_cgbg .split (_fdfd );if _febb !=nil {_cgbg =_febb ;_ggdgg =_feda (_ggdgg ,_febb ,false );_gcgfg ._cfcdg [_edaaf ]=_ggdgg ;
};if _dagg !=nil {_gfaeb =_dagg ;_cfeaf =true ;};_dgae =_ggdgg .height (_cbedc .Width );};};_cgfcd =append (_cgfcd ,_dgae );if _cfeaf {if _gdbff ==nil {_gdbff =make ([]*TableCell ,0,len (_gcgfg ._dbeeb ));for _eaff :=_gabd ;_eaff < _edaaf ;_eaff ++{_gbcd (_eaff ,nil );
};};_gbcd (_edaaf ,_gfaeb );};};var _gfaee float64 ;for _ ,_ecca :=range _cgfcd {if _ecca > _gfaee {_gfaee =_ecca ;};};if _cfeaf &&_gfaee < _cbedc .Height {if _egfc < 0{_egfc =len (_gcgfg ._cfcdg );};_geag :=_gcgfg ._cfcdg [_egfc -1]._ggccd +_gcgfg ._cfcdg [_egfc -1]._effeb -1;
for _fecca :=_egfc ;_fecca < len (_gcgfg ._cfcdg );_fecca ++{_gcgfg ._cfcdg [_fecca ]._ggccd ++;};_gcgfg ._cfcdg =append (_gcgfg ._cfcdg [:_egfc ],append (_gdbff ,_gcgfg ._cfcdg [_egfc :]...)...);_gcgfg ._eegf =append (_gcgfg ._eegf [:_geag ],append ([]float64 {_acgd },_gcgfg ._eegf [_geag :]...)...);
_gcgfg ._eegf [_bdgad ._ggccd +_bdgad ._effeb -2]=_gfaee ;};return _cfeaf ,nil ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_ceg *Creator )CreateTableOfContents (genTOCFunc func (_dbb *TOC )error ){_ceg ._acee =genTOCFunc };

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_dbcf *Table )EnablePageWrap (enable bool ){_dbcf ._efbed =enable };

// Color returns the color of the line.
func (_cdcf *Line )Color ()Color {return _cdcf ._cdba };func (_fcfgee *templateProcessor )parseLinearGradientAttr (creator *Creator ,_babaa string )Color {_ecde :=ColorBlack ;if _babaa ==""{return _ecde ;};_bfda :=creator .NewLinearGradientColor ([]*ColorPoint {});
_bfda .SetExtends (true ,true );var (_daec =_de .Split (_babaa [16:len (_babaa )-1],"\u002c");_bagfa =_de .TrimSpace (_daec [0]););if _de .HasSuffix (_bagfa ,"\u0064\u0065\u0067"){_bffca ,_dcccd :=_ad .ParseFloat (_bagfa [:len (_bagfa )-3],64);if _dcccd !=nil {_gfb .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_dcccd );
}else {_bfda .SetAngle (_bffca );};_daec =_daec [1:];};_efdf ,_effedb :=_fcfgee .processGradientColorPair (_daec );if _efdf ==nil ||_effedb ==nil {return _ecde ;};for _ggfg :=0;_ggfg < len (_efdf );_ggfg ++{_bfda .AddColorStop (_efdf [_ggfg ],_effedb [_ggfg ]);
};return _bfda ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_ceea *Image )SetMargins (left ,right ,top ,bottom float64 ){_ceea ._ceaa .Left =left ;_ceea ._ceaa .Right =right ;_ceea ._ceaa .Top =top ;_ceea ._ceaa .Bottom =bottom ;};func _eebe (_gebdb *Creator ,_ecdg string ,_eddge []byte ,_bbgfg *TemplateOptions ,_eccc componentRenderer )*templateProcessor {if _bbgfg ==nil {_bbgfg =&TemplateOptions {};
};_bbgfg .init ();if _eccc ==nil {_eccc =_gebdb ;};return &templateProcessor {creator :_gebdb ,_dbcbe :_eddge ,_bfega :_bbgfg ,_acdbca :_eccc ,_dgaga :_ecdg };};

// SetMargins sets the margins of the graphic svg component.
func (_aaaa *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_aaaa ._fcgg .Left =left ;_aaaa ._fcgg .Right =right ;_aaaa ._fcgg .Top =top ;_aaaa ._fcgg .Bottom =bottom ;};

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_cfafg *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_gbbb []*Block ;_ffad =NewBlock (ctx .PageWidth ,ctx .PageHeight );_eeee =ctx ;_fecf ,_bddd =_cfafg ._dffgg ,ctx .PageHeight -_cfafg ._acad ;_bbgf ,_gage =_cfafg ._fbfbg ,ctx .PageHeight -_cfafg ._dbd ;
);_bdfa :=_cfafg ._edec .IsRelative ();if _bdfa {ctx .X +=_cfafg ._accae .Left ;ctx .Y +=_cfafg ._accae .Top ;ctx .Width -=_cfafg ._accae .Left +_cfafg ._accae .Right ;ctx .Height -=_cfafg ._accae .Top +_cfafg ._accae .Bottom ;_fecf ,_bddd ,_bbgf ,_gage =_cfafg .computeCoords (ctx );
if _cfafg .Height ()> ctx .Height {_gbbb =append (_gbbb ,_ffad );_ffad =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_adeg :=ctx ;_adeg .Y =ctx .Margins .Top +_cfafg ._accae .Top ;_adeg .X =ctx .Margins .Left +_cfafg ._accae .Left ;_adeg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_cfafg ._accae .Top -_cfafg ._accae .Bottom ;
_adeg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cfafg ._accae .Left -_cfafg ._accae .Right ;ctx =_adeg ;_fecf ,_bddd ,_bbgf ,_gage =_cfafg .computeCoords (ctx );};};_gbddc :=_bf .BasicLine {X1 :_fecf ,Y1 :_bddd ,X2 :_bbgf ,Y2 :_gage ,LineColor :_dec (_cfafg ._cdba ),Opacity :_cfafg ._efgda ,LineWidth :_cfafg ._cdff ,LineStyle :_cfafg ._cdcb ,DashArray :_cfafg ._eedbb ,DashPhase :_cfafg ._deaa };
_cbgca ,_eagg :=_ffad .setOpacity (1.0,_cfafg ._efgda );if _eagg !=nil {return nil ,ctx ,_eagg ;};_bffb ,_ ,_eagg :=_gbddc .Draw (_cbgca );if _eagg !=nil {return nil ,ctx ,_eagg ;};if _eagg =_ffad .addContentsByString (string (_bffb ));_eagg !=nil {return nil ,ctx ,_eagg ;
};if _bdfa {ctx .X =_eeee .X ;ctx .Width =_eeee .Width ;_fadb :=_cfafg .Height ();ctx .Y +=_fadb +_cfafg ._accae .Bottom ;ctx .Height -=_fadb ;}else {ctx =_eeee ;};_gbbb =append (_gbbb ,_ffad );return _gbbb ,ctx ,nil ;};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_gfbgc *Invoice )SetAddressStyle (style TextStyle ){_gfbgc ._eabg =style };

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_dddda *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_dfaff []*Block ;_geda =NewBlock (ctx .PageWidth ,ctx .PageHeight );_ddgg =ctx ;_ecgcc =_dddda ._cfdf /2;);_bagb :=_dddda ._dffd .IsRelative ();if _bagb {_dddda .applyFitMode (ctx .Width );
ctx .X +=_dddda ._ddfc .Left +_ecgcc ;ctx .Y +=_dddda ._ddfc .Top +_ecgcc ;ctx .Width -=_dddda ._ddfc .Left +_dddda ._ddfc .Right ;ctx .Height -=_dddda ._ddfc .Top +_dddda ._ddfc .Bottom ;if _dddda ._ggbab > ctx .Height {_dfaff =append (_dfaff ,_geda );
_geda =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cfeaa :=ctx ;_cfeaa .Y =ctx .Margins .Top +_dddda ._ddfc .Top +_ecgcc ;_cfeaa .X =ctx .Margins .Left +_dddda ._ddfc .Left +_ecgcc ;_cfeaa .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_dddda ._ddfc .Top -_dddda ._ddfc .Bottom ;
_cfeaa .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dddda ._ddfc .Left -_dddda ._ddfc .Right ;ctx =_cfeaa ;};}else {ctx .X =_dddda ._gadgc ;ctx .Y =_dddda ._adac ;};_agdd :=_bf .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_dddda ._ggbab ,Width :_dddda ._cegcg ,Height :_dddda ._ggbab ,BorderRadiusTopLeft :_dddda ._gbda ,BorderRadiusTopRight :_dddda ._gaebc ,BorderRadiusBottomLeft :_dddda ._ecga ,BorderRadiusBottomRight :_dddda ._cbca ,Opacity :1.0};
if _dddda ._daage !=nil {_agdd .FillEnabled =true ;_gfgfc :=_dec (_dddda ._daage );_dbae :=_bfgc (_geda ,_gfgfc ,_dddda ._daage ,func ()Rectangle {return Rectangle {_gadgc :_agdd .X ,_adac :_agdd .Y ,_cegcg :_agdd .Width ,_ggbab :_agdd .Height };});if _dbae !=nil {return nil ,ctx ,_dbae ;
};_agdd .FillColor =_gfgfc ;};if _dddda ._feea !=nil &&_dddda ._cfdf > 0{_agdd .BorderEnabled =true ;_agdd .BorderColor =_dec (_dddda ._feea );_agdd .BorderWidth =_dddda ._cfdf ;};_fceeg ,_ccbc :=_geda .setOpacity (_dddda ._efgb ,_dddda ._fgbf );if _ccbc !=nil {return nil ,ctx ,_ccbc ;
};_edcd ,_ ,_ccbc :=_agdd .Draw (_fceeg );if _ccbc !=nil {return nil ,ctx ,_ccbc ;};if _ccbc =_geda .addContentsByString (string (_edcd ));_ccbc !=nil {return nil ,ctx ,_ccbc ;};if _bagb {ctx .X =_ddgg .X ;ctx .Width =_ddgg .Width ;_cbdfg :=_dddda ._ggbab +_ecgcc ;
ctx .Y +=_cbdfg +_dddda ._ddfc .Bottom ;ctx .Height -=_cbdfg ;}else {ctx =_ddgg ;};_dfaff =append (_dfaff ,_geda );return _dfaff ,ctx ,nil ;};

// SetTotal sets the total of the invoice.
func (_gedb *Invoice )SetTotal (value string ){_gedb ._acgc [1].Value =value };var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);
ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_fab *Creator )NewParagraph (text string )*Paragraph {return _dbe (text ,_fab .NewTextStyle ())};func _abebc (_acfb *_gc .Decoder )(int ,int ){return 0,0};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_aaeg *RadialShading )SetAntiAlias (enable bool ){_aaeg ._efef .SetAntiAlias (enable )};func _adecd (_ebfbc interface{})(interface{},error ){switch _cfad :=_ebfbc .(type ){case uint8 :return int64 (_cfad ),nil ;case int8 :return int64 (_cfad ),nil ;
case uint16 :return int64 (_cfad ),nil ;case int16 :return int64 (_cfad ),nil ;case uint32 :return int64 (_cfad ),nil ;case int32 :return int64 (_cfad ),nil ;case uint64 :return int64 (_cfad ),nil ;case int64 :return _cfad ,nil ;case int :return int64 (_cfad ),nil ;
case float32 :return float64 (_cfad ),nil ;case float64 :return _cfad ,nil ;};return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0076\u0061\u006c\u0075\u0065\u002c\u0020\u0025\u0076\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072",_ebfbc );
};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// SetMargins sets the margins of the chart component.
func (_aadc *Chart )SetMargins (left ,right ,top ,bottom float64 ){_aadc ._bfa .Left =left ;_aadc ._bfa .Right =right ;_aadc ._bfa .Top =top ;_aadc ._bfa .Bottom =bottom ;};func (_cdbfc *templateProcessor )parseEllipse (_ffcf *templateNode )(interface{},error ){_bdac :=_cdbfc .creator .NewEllipse (0,0,0,0);
for _ ,_fggec :=range _ffcf ._adbf .Attr {_fbgd :=_fggec .Value ;switch _gfdae :=_fggec .Name .Local ;_gfdae {case "\u0063\u0078":_bdac ._faac =_cdbfc .parseFloatAttr (_gfdae ,_fbgd );case "\u0063\u0079":_bdac ._ccag =_cdbfc .parseFloatAttr (_gfdae ,_fbgd );
case "\u0077\u0069\u0064t\u0068":_bdac .SetWidth (_cdbfc .parseFloatAttr (_gfdae ,_fbgd ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_bdac .SetHeight (_cdbfc .parseFloatAttr (_gfdae ,_fbgd ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_bdac .SetFillColor (_cdbfc .parseColorAttr (_gfdae ,_fbgd ));
case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_bdac .SetFillOpacity (_cdbfc .parseFloatAttr (_gfdae ,_fbgd ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_bdac .SetBorderColor (_cdbfc .parseColorAttr (_gfdae ,_fbgd ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_bdac .SetBorderOpacity (_cdbfc .parseFloatAttr (_gfdae ,_fbgd ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_bdac .SetBorderWidth (_cdbfc .parseFloatAttr (_gfdae ,_fbgd ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_bdac .SetPositioning (_cdbfc .parsePositioningAttr (_gfdae ,_fbgd ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_bdac .SetFitMode (_cdbfc .parseFitModeAttr (_gfdae ,_fbgd ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_edabe :=_cdbfc .parseMarginAttr (_gfdae ,_fbgd );
_bdac .SetMargins (_edabe .Left ,_edabe .Right ,_edabe .Top ,_edabe .Bottom );default:_cdbfc .nodeLogDebug (_ffcf ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gfdae );
};};return _bdac ,nil ;};func _gaade (_effec ...interface{})(map[string ]interface{},error ){_dadgf :=len (_effec );if _dadgf %2!=0{_gfb .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_dadgf );
return nil ,_gd .ErrRangeError ;};_dgfbf :=map[string ]interface{}{};for _baaeb :=0;_baaeb < _dadgf ;_baaeb +=2{_aeceb ,_bggbc :=_effec [_baaeb ].(string );if !_bggbc {_gfb .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_effec [_baaeb ]);
return nil ,_gd .ErrTypeError ;};_dgfbf [_aeceb ]=_effec [_baaeb +1];};return _dgfbf ,nil ;};

// SetLogo sets the logo of the invoice.
func (_aefa *Invoice )SetLogo (logo *Image ){_aefa ._ddga =logo };func (_aedfc *templateProcessor )renderNode (_gfga *templateNode )error {_bcggf :=_gfga ._cagcg ;if _bcggf ==nil {return nil ;};_gdbga :=_gfga ._adbf .Name .Local ;_fdffd ,_caab :=_egbd [_gdbga ];
if !_caab {_aedfc .nodeLogDebug (_gfga ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_gdbga );return nil ;};var _acbae interface{};if _gfga ._gfggb !=nil &&_gfga ._gfggb ._cagcg !=nil {_fbbbe :=_gfga ._gfggb ._adbf .Name .Local ;
if _ ,_caab =_fdffd ._dfefb [_fbbbe ];!_caab {_aedfc .nodeLogDebug (_gfga ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_fbbbe ,_gdbga );
return _adee ;};_acbae =_gfga ._gfggb ._cagcg ;}else {_aeaeg :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _aedfc ._acdbca .(type ){case *Block :_aeaeg ="\u0062\u006c\u006fc\u006b";};if _ ,_caab =_fdffd ._dfefb [_aeaeg ];!_caab {_aedfc .nodeLogDebug (_gfga ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_aeaeg ,_gdbga );
return _adee ;};_acbae =_aedfc ._acdbca ;};switch _fbdfd :=_acbae .(type ){case componentRenderer :_fbcbb ,_cddbbg :=_bcggf .(Drawable );if !_cddbbg {_aedfc .nodeLogError (_gfga ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_gdbga ,_bcggf );
return _fgbc ;};_bcad :=_fbdfd .Draw (_fbcbb );if _bcad !=nil {return _aedfc .nodeError (_gfga ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_gdbga ,_bcggf ,_bcad );
};case *Division :switch _dfdf :=_bcggf .(type ){case *Background :_fbdfd .SetBackground (_dfdf );case VectorDrawable :_fbcbd :=_fbdfd .Add (_dfdf );if _fbcbd !=nil {return _aedfc .nodeError (_gfga ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_gdbga ,_bcggf ,_fbcbd );
};};case *TableCell :_fafd ,_acec :=_bcggf .(VectorDrawable );if !_acec {_aedfc .nodeLogError (_gfga ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_gdbga ,_bcggf );
return _fgbc ;};_dgfa :=_fbdfd .SetContent (_fafd );if _dgfa !=nil {return _aedfc .nodeError (_gfga ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_gdbga ,_bcggf ,_dgfa );
};case *StyledParagraph :_acdeb ,_bcfad :=_bcggf .(*TextChunk );if !_bcfad {_aedfc .nodeLogError (_gfga ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_gdbga ,_bcggf );
return _fgbc ;};_fbdfd .appendChunk (_acdeb );case *Chapter :switch _fddegg :=_bcggf .(type ){case *Chapter :return nil ;case *Paragraph :if _gfga ._adbf .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_babae :=_fbdfd .Add (_fddegg );if _babae !=nil {return _aedfc .nodeError (_gfga ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_gdbga ,_bcggf ,_babae );
};case Drawable :_ccdg :=_fbdfd .Add (_fddegg );if _ccdg !=nil {return _aedfc .nodeError (_gfga ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_gdbga ,_bcggf ,_ccdg );
};};case *List :switch _abad :=_bcggf .(type ){case *TextChunk :case *listItem :_fbdfd ._gaegd =append (_fbdfd ._gaegd ,_abad );default:_aedfc .nodeLogError (_gfga ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gdbga ,_bcggf );
};case *listItem :switch _ebgf :=_bcggf .(type ){case *TextChunk :case *StyledParagraph :_fbdfd ._cbgb =_ebgf ;case *List :if _ebgf ._edag {_ebgf ._gdfg =15;};_fbdfd ._cbgb =_ebgf ;case *Image :_fbdfd ._cbgb =_ebgf ;case *Division :_fbdfd ._cbgb =_ebgf ;
case *Table :_fbdfd ._cbgb =_ebgf ;default:_aedfc .nodeLogError (_gfga ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_gdbga ,_bcggf );
return _fgbc ;};};return nil ;};type border struct{_dgd float64 ;_bce float64 ;_adf float64 ;_cff float64 ;_bea Color ;_bdb Color ;_eddf float64 ;_gbdg Color ;_cfc float64 ;_gca Color ;_ecac float64 ;_eaf Color ;_agg float64 ;LineStyle _bf .LineStyle ;
_ddda CellBorderStyle ;_dbf CellBorderStyle ;_bgf CellBorderStyle ;_acc CellBorderStyle ;};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_bcdd *RadialShading )SetBackgroundColor (backgroundColor Color ){_bcdd ._efef .SetBackgroundColor (backgroundColor );};func _fege (_bde string )string {_faed :=_ecbb .FindAllString (_bde ,-1);if len (_faed )==0{_bde =_bde +"\u0030";}else {_gee ,_aaee :=_ad .Atoi (_faed [len (_faed )-1]);
if _aaee !=nil {_gfb .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_aaee );
_bde =_bde +"\u0030";}else {_gee ++;_ebe :=_de .LastIndex (_bde ,_faed [len (_faed )-1]);if _ebe ==-1{_bde =_f .Sprintf ("\u0025\u0073\u0025\u0064",_bde [:len (_bde )-1],_gee );}else {_bde =_bde [:_ebe ]+_ad .Itoa (_gee );};};};return _bde ;};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_aggdd *Invoice )SetNoteStyle (style TextStyle ){_aggdd ._ebbe =style };

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_cdgf *LinearShading )SetAngle (angle float64 ){_cdgf ._gcbca =angle };

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// AddColorStop add color stop info for rendering gradient color.
func (_beffa *LinearShading )AddColorStop (color Color ,point float64 ){_beffa ._fded .AddColorStop (color ,point );};

// NewPolyline creates a new polyline.
func (_geff *Creator )NewPolyline (points []_bf .Point )*Polyline {return _badc (points )};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_edbe *TOC )SetHeading (text string ,style TextStyle ){_efcg :=_edbe .Heading ();_efcg .Reset ();_agce :=_efcg .Append (text );_agce .Style =style ;};

// SetStyleBottom sets border style for bottom side.
func (_bab *border )SetStyleBottom (style CellBorderStyle ){_bab ._acc =style };

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_df *Block )SetMargins (left ,right ,top ,bottom float64 ){_df ._fe .Left =left ;_df ._fe .Right =right ;_df ._fe .Top =top ;_df ._fe .Bottom =bottom ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_afaa *StyledParagraph )SetEnableWrap (enableWrap bool ){_afaa ._eagfa =enableWrap ;_afaa ._cdebe =false ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_efgd *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dadf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cgc :=_cc .NewContentCreator ();_cgc .Add_q ().Add_w (_efgd ._cgbde ).SetStrokingColor (_dec (_efgd ._fcadf )).Add_m (_efgd ._bfcg ,ctx .PageHeight -_efgd ._baeb ).Add_v (_efgd ._dcbe ,ctx .PageHeight -_efgd ._adg ,_efgd ._egbc ,ctx .PageHeight -_efgd ._bdba ).Add_S ().Add_Q ();
_eggd :=_dadf .addContentsByString (_cgc .String ());if _eggd !=nil {return nil ,ctx ,_eggd ;};return []*Block {_dadf },ctx ,nil ;};

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_ccgc *GraphicSVG )Scale (xFactor ,yFactor float64 ){_ccgc ._caga .Width =xFactor *_ccgc ._caga .Width ;_ccgc ._caga .Height =yFactor *_ccgc ._caga .Height ;_ccgc ._caga .SetScaling (xFactor ,yFactor );};func (_bdcdf *StyledParagraph )wrapText ()error {return _bdcdf .wrapChunks (true )};
func (_gadcb *Division )split (_fedga DrawContext )(_gffe ,_bcfb *Division ){var (_fgeb float64 ;_bgbg ,_baee []VectorDrawable ;);_ebcb :=_fedga .Width -_gadcb ._baad .Left -_gadcb ._baad .Right -_gadcb ._babd .Left -_gadcb ._babd .Right ;for _cegc ,_beg :=range _gadcb ._ggcc {_fgeb +=_gedg (_beg ,_ebcb );
if _fgeb < _fedga .Height {_bgbg =append (_bgbg ,_beg );}else {_baee =_gadcb ._ggcc [_cegc :];break ;};};if len (_bgbg )> 0{_gffe =_bdf ();*_gffe =*_gadcb ;_gffe ._ggcc =_bgbg ;if _gadcb ._aadg !=nil {_gffe ._aadg =&Background {};*_gffe ._aadg =*_gadcb ._aadg ;
};};if len (_baee )> 0{_bcfb =_bdf ();*_bcfb =*_gadcb ;_bcfb ._ggcc =_baee ;if _gadcb ._aadg !=nil {_bcfb ._aadg =&Background {};*_bcfb ._aadg =*_gadcb ._aadg ;};};return _gffe ,_bcfb ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_bgaa *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bgaa ._edbc .Left ,_bgaa ._edbc .Right ,_bgaa ._edbc .Top ,_bgaa ._edbc .Bottom ;};func (_ccec *LinearShading )shadingModel ()*_ed .PdfShadingType2 {_bcfgg :=_bf .NewPoint (_ccec ._ggcfg .Llx +_ccec ._ggcfg .Width ()/2,_ccec ._ggcfg .Lly +_ccec ._ggcfg .Height ()/2);
_bfgf :=_bf .NewPoint (_ccec ._ggcfg .Llx ,_ccec ._ggcfg .Lly +_ccec ._ggcfg .Height ()/2).Add (-_bcfgg .X ,-_bcfgg .Y ).Rotate (_ccec ._gcbca ).Add (_bcfgg .X ,_bcfgg .Y );_bfgf =_bf .NewPoint (_cf .Max (_cf .Min (_bfgf .X ,_ccec ._ggcfg .Urx ),_ccec ._ggcfg .Llx ),_cf .Max (_cf .Min (_bfgf .Y ,_ccec ._ggcfg .Ury ),_ccec ._ggcfg .Lly ));
_dgbaf :=_bf .NewPoint (_ccec ._ggcfg .Urx ,_ccec ._ggcfg .Lly +_ccec ._ggcfg .Height ()/2).Add (-_bcfgg .X ,-_bcfgg .Y ).Rotate (_ccec ._gcbca ).Add (_bcfgg .X ,_bcfgg .Y );_dgbaf =_bf .NewPoint (_cf .Min (_cf .Max (_dgbaf .X ,_ccec ._ggcfg .Llx ),_ccec ._ggcfg .Urx ),_cf .Min (_cf .Max (_dgbaf .Y ,_ccec ._ggcfg .Lly ),_ccec ._ggcfg .Ury ));
_cbfe :=_ed .NewPdfShadingType2 ();_cbfe .PdfShading .ShadingType =_gd .MakeInteger (2);_cbfe .PdfShading .ColorSpace =_ed .NewPdfColorspaceDeviceRGB ();_cbfe .PdfShading .AntiAlias =_gd .MakeBool (_ccec ._fded ._aagae );_cbfe .Coords =_gd .MakeArrayFromFloats ([]float64 {_bfgf .X ,_bfgf .Y ,_dgbaf .X ,_dgbaf .Y });
_cbfe .Extend =_gd .MakeArray (_gd .MakeBool (_ccec ._fded ._cfffe [0]),_gd .MakeBool (_ccec ._fded ._cfffe [1]));_cbfe .Function =_ccec ._fded .generatePdfFunctions ();return _cbfe ;};

// SetBorderOpacity sets the border opacity of the ellipse.
func (_ffb *Ellipse )SetBorderOpacity (opacity float64 ){_ffb ._ddbee =opacity };

// The Image type is used to draw an image onto PDF.
type Image struct{_abga *_ed .XObjectImage ;_bdec *_ed .Image ;_eadd float64 ;_dgfb ,_dafe float64 ;_dddd ,_egbcd float64 ;_eecdg Positioning ;_aabe HorizontalAlignment ;_abeg float64 ;_cggeb float64 ;_deeeg float64 ;_ceaa Margins ;_agcd ,_bcgg float64 ;
_afab _gd .StreamEncoder ;_caec FitMode ;_fcaf bool ;};func (_cafg *StyledParagraph )wrapChunks (_cbdbd bool )error {if !_cafg ._eagfa ||int (_cafg ._bcdba )<=0{_cafg ._feab =[][]*TextChunk {_cafg ._fcdf };return nil ;};if _cafg ._bedga {_cafg .wrapWordChunks ();
};_cafg ._feab =[][]*TextChunk {};var _bcfef []*TextChunk ;var _cbcda float64 ;_bccea :=_bg .IsSpace ;if !_cbdbd {_bccea =func (rune )bool {return false };};_afaegf :=_fgefd (_cafg ._bcdba *1000.0,0.000001);for _ ,_dafff :=range _cafg ._fcdf {_eddgb :=_dafff .Style ;
_cdaf :=_dafff ._eefeb ;_gafc :=_dafff .VerticalAlignment ;var (_fgfdg []rune ;_aceec []float64 ;);_bca :=_faeef (_dafff .Text );for _ ,_fbbc :=range _dafff .Text {if _fbbc =='\u000A'{if !_cbdbd {_fgfdg =append (_fgfdg ,_fbbc );};_bcfef =append (_bcfef ,&TextChunk {Text :_de .TrimRightFunc (string (_fgfdg ),_bccea ),Style :_eddgb ,_eefeb :_eggfg (_cdaf ),VerticalAlignment :_gafc });
_cafg ._feab =append (_cafg ._feab ,_bcfef );_bcfef =nil ;_cbcda =0;_fgfdg =nil ;_aceec =nil ;continue ;};_gefc :=_fbbc ==' ';_eafba ,_fddef :=_eddgb .Font .GetRuneMetrics (_fbbc );if _eafba .Wx ==0&&_eddgb .MultiFont !=nil ||_eddgb .MultiFont !=nil &&!_fddef {_eafba ,_fddef =_eddgb .MultiFont .GetRuneMetrics (_fbbc );
};if !_fddef {_gfb .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fbbc );return _e .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_acbbfg :=_eddgb .FontSize *_eafba .Wx *_eddgb .horizontalScale ();_cebd :=_acbbfg ;if !_gefc {_cebd =_acbbfg +_eddgb .CharSpacing *1000.0;};if _cbcda +_acbbfg > _afaegf {_gbae :=-1;if !_gefc {for _bcgad :=len (_fgfdg )-1;_bcgad >=0;_bcgad --{if _fgfdg [_bcgad ]==' '{_gbae =_bcgad ;
break ;};};};if _cafg ._bedga {_cadg :=len (_bcfef );if _cadg > 0{_bcfef [_cadg -1].Text =_de .TrimRightFunc (_bcfef [_cadg -1].Text ,_bccea );_cafg ._feab =append (_cafg ._feab ,_bcfef );_bcfef =[]*TextChunk {};};_fgfdg =append (_fgfdg ,_fbbc );_aceec =append (_aceec ,_cebd );
if _gbae >=0{_fgfdg =_fgfdg [_gbae +1:];_aceec =_aceec [_gbae +1:];};_cbcda =0;for _ ,_ccbbb :=range _aceec {_cbcda +=_ccbbb ;};if _cbcda > _afaegf {_cdbc :=string (_fgfdg [:len (_fgfdg )-1]);_cdbc =_ffee (_cdbc ,_bca );if !_cbdbd &&_gefc {_cdbc +="\u0020";
};_bcfef =append (_bcfef ,&TextChunk {Text :_de .TrimRightFunc (_cdbc ,_bccea ),Style :_eddgb ,_eefeb :_eggfg (_cdaf ),VerticalAlignment :_gafc });_cafg ._feab =append (_cafg ._feab ,_bcfef );_bcfef =[]*TextChunk {};_fgfdg =[]rune {_fbbc };_aceec =[]float64 {_cebd };
_cbcda =_cebd ;};continue ;};_abag :=string (_fgfdg );if _gbae >=0{_abag =string (_fgfdg [0:_gbae +1]);_fgfdg =_fgfdg [_gbae +1:];_fgfdg =append (_fgfdg ,_fbbc );_aceec =_aceec [_gbae +1:];_aceec =append (_aceec ,_cebd );_cbcda =0;for _ ,_agcda :=range _aceec {_cbcda +=_agcda ;
};}else {if _gefc {_cbcda =0;_fgfdg =[]rune {};_aceec =[]float64 {};}else {_cbcda =_cebd ;_fgfdg =[]rune {_fbbc };_aceec =[]float64 {_cebd };};};_abag =_ffee (_abag ,_bca );if !_cbdbd &&_gefc {_abag +="\u0020";};_bcfef =append (_bcfef ,&TextChunk {Text :_de .TrimRightFunc (_abag ,_bccea ),Style :_eddgb ,_eefeb :_eggfg (_cdaf ),VerticalAlignment :_gafc });
_cafg ._feab =append (_cafg ._feab ,_bcfef );_bcfef =[]*TextChunk {};}else {_cbcda +=_cebd ;_fgfdg =append (_fgfdg ,_fbbc );_aceec =append (_aceec ,_cebd );};};if len (_fgfdg )> 0{_afagg :=_ffee (string (_fgfdg ),_bca );_bcfef =append (_bcfef ,&TextChunk {Text :_afagg ,Style :_eddgb ,_eefeb :_eggfg (_cdaf ),VerticalAlignment :_gafc });
};};if len (_bcfef )> 0{_cafg ._feab =append (_cafg ._feab ,_bcfef );};return nil ;};const (DefaultHorizontalScaling =100;);func _egbad (_bbcc string )(*Image ,error ){_aade ,_cbabe :=_gf .Open (_bbcc );if _cbabe !=nil {return nil ,_cbabe ;};defer _aade .Close ();
_eada ,_cbabe :=_ed .ImageHandling .Read (_aade );if _cbabe !=nil {_gfb .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cbabe );return nil ,_cbabe ;};return _edcg (_eada );
};func (_gaeba *templateProcessor )processGradientColorPair (_ebde []string )(_ddgbg []Color ,_fbgf []float64 ){for _ ,_bdab :=range _ebde {var (_ebgeg =_de .Fields (_bdab );_ceac =len (_ebgeg ););if _ceac ==0{continue ;};_bggg :="";if _ceac > 1{_bggg =_de .TrimSpace (_ebgeg [1]);
};_ccfdb :=-1.0;if _de .HasSuffix (_bggg ,"\u0025"){_fbecb ,_efcd :=_ad .ParseFloat (_bggg [:len (_bggg )-1],64);if _efcd !=nil {_gfb .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_efcd );
};_ccfdb =_fbecb /100.0;};_abeba :=_gaeba .parseColor (_de .TrimSpace (_ebgeg [0]));if _abeba !=nil {_ddgbg =append (_ddgbg ,_abeba );_fbgf =append (_fbgf ,_ccfdb );};};if len (_ddgbg )!=len (_fbgf ){_gfb .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_dacdc :=-1;_edbf :=0.0;for _dfgeb ,_dedgg :=range _fbgf {if _dedgg ==-1.0{if _dfgeb ==0{_dedgg =0.0;_fbgf [_dfgeb ]=0.0;continue ;};_dacdc ++;if _dfgeb < len (_fbgf )-1{continue ;}else {_dedgg =1.0;_fbgf [_dfgeb ]=1.0;};};_ddegc :=_dacdc +1;
for _adgbc :=_dfgeb -_dacdc ;_adgbc < _dfgeb ;_adgbc ++{_fbgf [_adgbc ]=_edbf +(float64 (_adgbc )*(_dedgg -_edbf )/float64 (_ddegc ));};_edbf =_dedgg ;_dacdc =-1;};return _ddgbg ,_fbgf ;};func (_acbda *templateProcessor )parseLineStyleAttr (_cedga ,_cccab string )_bf .LineStyle {_gfb .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_cedga ,_cccab );
_edgff :=map[string ]_bf .LineStyle {"\u0073\u006f\u006ci\u0064":_bf .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_bf .LineStyleDashed }[_cccab ];return _edgff ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_ggacd *Invoice )BuyerAddress ()*InvoiceAddress {return _ggacd ._eefe };func (_fgfe *Invoice )setCellBorder (_adgde *TableCell ,_cdfbd *InvoiceCell ){for _ ,_ccba :=range _cdfbd .BorderSides {_adgde .SetBorder (_ccba ,CellBorderStyleSingle ,_cdfbd .BorderWidth );
};_adgde .SetBorderColor (_cdfbd .BorderColor );};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_ccbb *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _ccbb ._abga ==nil {if _eggf :=_ccbb .makeXObject ();_eggf !=nil {return nil ,ctx ,_eggf ;};};var _fafe []*Block ;_dfdbb :=ctx ;_fada :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _ccbb ._eecdg .IsRelative (){_ccbb .applyFitMode (ctx .Width );ctx .X +=_ccbb ._ceaa .Left ;ctx .Y +=_ccbb ._ceaa .Top ;ctx .Width -=_ccbb ._ceaa .Left +_ccbb ._ceaa .Right ;ctx .Height -=_ccbb ._ceaa .Top +_ccbb ._ceaa .Bottom ;if _ccbb ._dafe > ctx .Height {_fafe =append (_fafe ,_fada );
_fada =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_afff :=ctx ;_afff .Y =ctx .Margins .Top +_ccbb ._ceaa .Top ;_afff .X =ctx .Margins .Left +_ccbb ._ceaa .Left ;_afff .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_ccbb ._ceaa .Top -_ccbb ._ceaa .Bottom ;
_afff .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ccbb ._ceaa .Left -_ccbb ._ceaa .Right ;ctx =_afff ;};}else {ctx .X =_ccbb ._abeg ;ctx .Y =_ccbb ._cggeb ;};ctx ,_cacdb :=_cbgc (_fada ,_ccbb ,ctx );if _cacdb !=nil {return nil ,ctx ,_cacdb ;
};_fafe =append (_fafe ,_fada );if _ccbb ._eecdg .IsAbsolute (){ctx =_dfdbb ;}else {ctx .X =_dfdbb .X ;ctx .Width =_dfdbb .Width ;ctx .Y +=_ccbb ._ceaa .Bottom ;};return _fafe ,ctx ,nil ;};

// SetPos sets absolute positioning with specified coordinates.
func (_acfa *Paragraph )SetPos (x ,y float64 ){_acfa ._fadf =PositionAbsolute ;_acfa ._acde =x ;_acfa ._eddg =y ;};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_ee *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ee ._fe .Left ,_ee ._fe .Right ,_ee ._fe .Top ,_ee ._fe .Bottom ;};

// SetBorderColor sets the border color.
func (_ffgca *PolyBezierCurve )SetBorderColor (color Color ){_ffgca ._cgfd .BorderColor =_dec (color )};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_cbgcab *LinearShading )SetBackgroundColor (backgroundColor Color ){_cbgcab ._fded .SetBackgroundColor (backgroundColor );};func (_gabfc *templateProcessor )parseImage (_agdec *templateNode )(interface{},error ){var _ecgfc string ;for _ ,_gebfc :=range _agdec ._adbf .Attr {_fcbd :=_gebfc .Value ;
switch _debda :=_gebfc .Name .Local ;_debda {case "\u0073\u0072\u0063":_ecgfc =_fcbd ;};};_fccbd ,_fedf :=_gabfc .loadImageFromSrc (_ecgfc );if _fedf !=nil {return nil ,_fedf ;};for _ ,_feeb :=range _agdec ._adbf .Attr {_afdbc :=_feeb .Value ;switch _afee :=_feeb .Name .Local ;
_afee {case "\u0061\u006c\u0069g\u006e":_fccbd .SetHorizontalAlignment (_gabfc .parseHorizontalAlignmentAttr (_afee ,_afdbc ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_fccbd .SetOpacity (_gabfc .parseFloatAttr (_afee ,_afdbc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ggfbc :=_gabfc .parseMarginAttr (_afee ,_afdbc );
_fccbd .SetMargins (_ggfbc .Left ,_ggfbc .Right ,_ggfbc .Top ,_ggfbc .Bottom );case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_fccbd .SetFitMode (_gabfc .parseFitModeAttr (_afee ,_afdbc ));case "\u0078":_fccbd .SetPos (_gabfc .parseFloatAttr (_afee ,_afdbc ),_fccbd ._cggeb );
case "\u0079":_fccbd .SetPos (_fccbd ._abeg ,_gabfc .parseFloatAttr (_afee ,_afdbc ));case "\u0077\u0069\u0064t\u0068":_fccbd .SetWidth (_gabfc .parseFloatAttr (_afee ,_afdbc ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_fccbd .SetHeight (_gabfc .parseFloatAttr (_afee ,_afdbc ));
case "\u0061\u006e\u0067l\u0065":_fccbd .SetAngle (_gabfc .parseFloatAttr (_afee ,_afdbc ));case "\u0073\u0072\u0063":break ;default:_gabfc .nodeLogDebug (_agdec ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_afee );
};};return _fccbd ,nil ;};

// BorderColor returns the border color of the ellipse.
func (_gfce *Ellipse )BorderColor ()Color {return _gfce ._gdcga };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline };};

// NewCellProps returns the default properties of an invoice cell.
func (_bfbb *Invoice )NewCellProps ()InvoiceCellProps {_agfdb :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_bfbb ._dedg ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_agfdb ,BorderColor :_agfdb ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_efbd *Chapter )SetIncludeInTOC (includeInTOC bool ){_efbd ._adde =includeInTOC };

// Reset removes all the text chunks the paragraph contains.
func (_ebad *StyledParagraph )Reset (){_ebad ._fcdf =[]*TextChunk {}};func (_aadgd *templateProcessor )parseDivision (_cead *templateNode )(interface{},error ){_feabg :=_aadgd .creator .NewDivision ();for _ ,_cbge :=range _cead ._adbf .Attr {_agda :=_cbge .Value ;
switch _cefg :=_cbge .Name .Local ;_cefg {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_feabg .EnablePageWrap (_aadgd .parseBoolAttr (_cefg ,_agda ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cgec :=_aadgd .parseMarginAttr (_cefg ,_agda );
_feabg .SetMargins (_cgec .Left ,_cgec .Right ,_cgec .Top ,_cgec .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_eeggf :=_aadgd .parseMarginAttr (_cefg ,_agda );_feabg .SetPadding (_eeggf .Left ,_eeggf .Right ,_eeggf .Top ,_eeggf .Bottom );default:_aadgd .nodeLogDebug (_cead ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cefg );
};};return _feabg ,nil ;};

// Indent returns the left offset of the list when nested into another list.
func (_dgdg *List )Indent ()float64 {return _dgdg ._gdfg };func (_gfged *templateProcessor )parseList (_fdfef *templateNode )(interface{},error ){_dbgba :=_gfged .creator .NewList ();for _ ,_afegb :=range _fdfef ._adbf .Attr {_bbfbe :=_afegb .Value ;switch _fgebgb :=_afegb .Name .Local ;
_fgebgb {case "\u0069\u006e\u0064\u0065\u006e\u0074":_dbgba .SetIndent (_gfged .parseFloatAttr (_fgebgb ,_bbfbe ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ceee :=_gfged .parseMarginAttr (_fgebgb ,_bbfbe );_dbgba .SetMargins (_ceee .Left ,_ceee .Right ,_ceee .Top ,_ceee .Bottom );
default:_gfged .nodeLogDebug (_fdfef ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_fgebgb );
};};return _dbgba ,nil ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_aeecb *Image )SetWidth (w float64 ){_aeecb ._dgfb =w };

// Width returns the width of the graphic svg.
func (_dccc *GraphicSVG )Width ()float64 {return _dccc ._caga .Width };

// TitleStyle returns the style properties used to render the invoice title.
func (_cccf *Invoice )TitleStyle ()TextStyle {return _cccf ._cedg };func (_eaef *Chapter )headingText ()string {_efda :=_eaef ._ggf ;if _gfg :=_eaef .headingNumber ();_gfg !=""{_efda =_f .Sprintf ("\u0025\u0073\u0020%\u0073",_gfg ,_efda );};return _efda ;
};func (_dgee *Creator )initContext (){_dgee ._abe .X =_dgee ._ggeg .Left ;_dgee ._abe .Y =_dgee ._ggeg .Top ;_dgee ._abe .Width =_dgee ._ffeg -_dgee ._ggeg .Right -_dgee ._ggeg .Left ;_dgee ._abe .Height =_dgee ._adc -_dgee ._ggeg .Bottom -_dgee ._ggeg .Top ;
_dgee ._abe .PageHeight =_dgee ._adc ;_dgee ._abe .PageWidth =_dgee ._ffeg ;_dgee ._abe .Margins =_dgee ._ggeg ;_dgee ._abe ._gfbg =_dgee .UnsupportedCharacterReplacement ;};func (_eacfb *templateProcessor )parseTextOverflowAttr (_gdcfb ,_ffbef string )TextOverflow {_gfb .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_gdcfb ,_ffbef );
_bcae :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_ffbef ];return _bcae ;};

// IsAbsolute checks if the positioning is absolute.
func (_fgef Positioning )IsAbsolute ()bool {return _fgef ==PositionAbsolute };func (_gggac *templateProcessor )parseChapterHeading (_bgdab *templateNode )(interface{},error ){if _bgdab ._gfggb ==nil {_gggac .nodeLogError (_bgdab ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_adee ;};_deec ,_fced :=_bgdab ._gfggb ._cagcg .(*Chapter );if !_fced {_gggac .nodeLogError (_bgdab ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_bgdab ._gfggb ._cagcg );
return nil ,_adee ;};_ccccg :=_deec .GetHeading ();if _ ,_gefb :=_gggac .parseParagraph (_bgdab ,_ccccg );_gefb !=nil {return nil ,_gefb ;};return _ccccg ,nil ;};

// Height returns the Block's height.
func (_cce *Block )Height ()float64 {return _cce ._ag };func (_ecag *TemplateOptions )init (){if _ecag .SubtemplateMap ==nil {_ecag .SubtemplateMap =map[string ]_eb .Reader {};};if _ecag .FontMap ==nil {_ecag .FontMap =map[string ]*_ed .PdfFont {};};if _ecag .ImageMap ==nil {_ecag .ImageMap =map[string ]*_ed .Image {};
};if _ecag .ColorMap ==nil {_ecag .ColorMap =map[string ]Color {};};if _ecag .ChartMap ==nil {_ecag .ChartMap =map[string ]_ge .ChartRenderable {};};};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_dbde *Rectangle )Height ()float64 {return _dbde ._ggbab };

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_cbff *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbfce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_efad ,_baae :=_bbfce .setOpacity (_cbff ._gcaa ,_cbff ._gcaa );if _baae !=nil {return nil ,ctx ,_baae ;};_efec :=_cbff ._daag .Points ;
for _gfbf :=range _efec {_ddcbg :=&_efec [_gfbf ];_ddcbg .Y =ctx .PageHeight -_ddcbg .Y ;};_efagb ,_ ,_baae :=_cbff ._daag .Draw (_efad );if _baae !=nil {return nil ,ctx ,_baae ;};if _baae =_bbfce .addContentsByString (string (_efagb ));_baae !=nil {return nil ,ctx ,_baae ;
};return []*Block {_bbfce },ctx ,nil ;};func _cgcg (_cebfc string )*_ed .PdfAnnotation {_bcfac :=_ed .NewPdfAnnotationLink ();_fbbbd :=_ed .NewBorderStyle ();_fbbbd .SetBorderWidth (0);_bcfac .BS =_fbbbd .ToPdfObject ();_becab :=_ed .NewPdfActionURI ();
_becab .URI =_gd .MakeString (_cebfc );_bcfac .SetAction (_becab .PdfAction );return _bcfac .PdfAnnotation ;};

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_ggaa *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _bbge (xc ,yc ,width ,height );};

// SetColorLeft sets border color for left.
func (_eecd *border )SetColorLeft (col Color ){_eecd ._bdb =col };func _ccdbd (_acega ,_aafaa ,_eaffa TextChunk ,_fgcf uint ,_aeadd TextStyle )*TOCLine {_ebbg :=_cfeea (_aeadd );_ebbg .SetEnableWrap (true );_ebbg .SetTextAlignment (TextAlignmentLeft );
_ebbg .SetMargins (0,0,2,2);_egad :=&TOCLine {_fbaf :_ebbg ,Number :_acega ,Title :_aafaa ,Page :_eaffa ,Separator :TextChunk {Text :"\u002e",Style :_aeadd },_gabdg :0,_cefgd :_fgcf ,_fabb :10,_cbffc :PositionRelative };_ebbg ._acbfg .Left =_egad ._gabdg +float64 (_egad ._cefgd -1)*_egad ._fabb ;
_ebbg ._abdc =_egad .prepareParagraph ;return _egad ;};

// Lazy gets the lazy mode for the image.
func (_gacb *Image )Lazy ()bool {return _gacb ._fcaf };func _ceef (_gagf []byte )(*Image ,error ){_gbfb :=_b .NewReader (_gagf );_gbgdg ,_acbc :=_ed .ImageHandling .Read (_gbfb );if _acbc !=nil {_gfb .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_acbc );
return nil ,_acbc ;};return _edcg (_gbgdg );};func (_bbbcf *Invoice )drawAddress (_baag *InvoiceAddress )[]*StyledParagraph {var _adag []*StyledParagraph ;if _baag .Heading !=""{_afef :=_cfeea (_bbbcf ._fgdg );_afef .SetMargins (0,0,0,7);_afef .Append (_baag .Heading );
_adag =append (_adag ,_afef );};_debf :=_cfeea (_bbbcf ._eabg );_debf .SetLineHeight (1.2);_fdbb :=_baag .Separator ;if _fdbb ==""{_fdbb =_bbbcf ._fcfa ;};_aeee :=_baag .City ;if _baag .State !=""{if _aeee !=""{_aeee +=_fdbb ;};_aeee +=_baag .State ;};
if _baag .Zip !=""{if _aeee !=""{_aeee +=_fdbb ;};_aeee +=_baag .Zip ;};if _baag .Name !=""{_debf .Append (_baag .Name +"\u000a");};if _baag .Street !=""{_debf .Append (_baag .Street +"\u000a");};if _baag .Street2 !=""{_debf .Append (_baag .Street2 +"\u000a");
};if _aeee !=""{_debf .Append (_aeee +"\u000a");};if _baag .Country !=""{_debf .Append (_baag .Country +"\u000a");};_fabd :=_cfeea (_bbbcf ._eabg );_fabd .SetLineHeight (1.2);_fabd .SetMargins (0,0,7,0);if _baag .Phone !=""{_fabd .Append (_baag .fmtLine (_baag .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_baag .HidePhoneLabel ));
};if _baag .Email !=""{_fabd .Append (_baag .fmtLine (_baag .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_baag .HideEmailLabel ));};_adag =append (_adag ,_debf ,_fabd );return _adag ;};

// Scale scales the rectangle dimensions by the specified factors.
func (_gddee *Rectangle )Scale (xFactor ,yFactor float64 ){_gddee ._cegcg =xFactor *_gddee ._cegcg ;_gddee ._ggbab =yFactor *_gddee ._ggbab ;};func _gadab (_gfbc *_gf .File )([]*_ed .PdfPage ,error ){_egcf ,_dabgf :=_ed .NewPdfReader (_gfbc );if _dabgf !=nil {return nil ,_dabgf ;
};_bcded ,_dabgf :=_egcf .GetNumPages ();if _dabgf !=nil {return nil ,_dabgf ;};var _aaaac []*_ed .PdfPage ;for _edcde :=0;_edcde < _bcded ;_edcde ++{_fgdb ,_ccce :=_egcf .GetPage (_edcde +1);if _ccce !=nil {return nil ,_ccce ;};_aaaac =append (_aaaac ,_fgdb );
};return _aaaac ,nil ;};

// SkipRows skips over a specified number of rows in the table.
func (_eceae *Table )SkipRows (num int ){_abeff :=num *_eceae ._dfeg -1;if _abeff < 0{_gfb .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _bcdc :=0;_bcdc < _abeff ;_bcdc ++{_eceae .NewCell ();};};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// MultiFont represents an encoder that accepts multiple fonts and selects the correct font for encoding.
MultiFont *_ed .MultipleFontEncoder ;

// Font represents the font the text will use.
Font *_ed .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};func (_bbea *StyledParagraph )appendChunk (_efcc *TextChunk )*TextChunk {_bbea ._fcdf =append (_bbea ._fcdf ,_efcc );_bbea .wrapText ();return _efcc ;};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};func (_afeec *templateProcessor )parseTextRenderingModeAttr (_gafea ,_ecccg string )TextRenderingMode {_gfb .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gafea ,_ecccg );
_ddecda :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_ecccg ];
return _ddecda ;};

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_egecb *Rectangle )Width ()float64 {return _egecb ._cegcg };

// AddLine appends a new line to the invoice line items table.
func (_gddc *Invoice )AddLine (values ...string )[]*InvoiceCell {_dadeg :=len (_gddc ._dfdgd );var _dage []*InvoiceCell ;for _daff ,_cggd :=range values {_aggg :=_gddc .newCell (_cggd ,_gddc ._afeb );if _daff < _dadeg {_aggg .Alignment =_gddc ._dfdgd [_daff ].Alignment ;
};_dage =append (_dage ,_aggg );};_gddc ._fafff =append (_gddc ._fafff ,_dage );return _dage ;};

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_abaf *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _abaf ._cdg .Left ,_abaf ._cdg .Right ,_abaf ._cdg .Top ,_abaf ._cdg .Bottom ;};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_cbfc *shading )SetBackgroundColor (backgroundColor Color ){_cbfc ._cbcbg =backgroundColor };

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _gcag ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_gab :=&Creator {};_gab ._fgdd =[]*_ed .PdfPage {};_gab ._dddac =map[*_ed .PdfPage ]*Block {};_gab ._cgf =map[*_ed .PdfPage ]*pageTransformations {};_gab .SetPageSize (PageSizeLetter );
_ecaca :=0.1*_gab ._ffeg ;_gab ._ggeg .Left =_ecaca ;_gab ._ggeg .Right =_ecaca ;_gab ._ggeg .Top =_ecaca ;_gab ._ggeg .Bottom =_ecaca ;var _cadf error ;_gab ._egc ,_cadf =_ed .NewStandard14Font (_ed .HelveticaName );if _cadf !=nil {_gab ._egc =_ed .DefaultFont ();
};_gab ._efae ,_cadf =_ed .NewStandard14Font (_ed .HelveticaBoldName );if _cadf !=nil {_gab ._egc =_ed .DefaultFont ();};_gab ._dcag =_gab .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_gab .AddOutlines =true ;
_gab ._dccf =_ed .NewOutline ();_fdc .TrackUse (_gcag );return _gab ;};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_deae *List )Marker ()*TextChunk {return &_deae ._defad };func _acdff (_cgdcc *_ed .PdfRectangle ,_ecad _af .Matrix )*_ed .PdfRectangle {var _eafg _ed .PdfRectangle ;_eafg .Llx ,_eafg .Lly =_ecad .Transform (_cgdcc .Llx ,_cgdcc .Lly );_eafg .Urx ,_eafg .Ury =_ecad .Transform (_cgdcc .Urx ,_cgdcc .Ury );
_eafg .Normalize ();return &_eafg ;};

// SetBorderColor sets the border color.
func (_daf *CurvePolygon )SetBorderColor (color Color ){_daf ._gfae .BorderColor =_dec (color )};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_abgdg *TOCLine )SetStyle (style TextStyle ){_abgdg .Number .Style =style ;_abgdg .Title .Style =style ;_abgdg .Separator .Style =style ;_abgdg .Page .Style =style ;};func _fgefd (_geef float64 ,_bfefc float64 )float64 {return _cf .Round (_geef /_bfefc )*_bfefc };
func (_decfc *Table )updateRowHeights (_aagcf float64 ){for _ ,_eddgf :=range _decfc ._cfcdg {_cfacf :=_eddgf .width (_decfc ._dbeeb ,_aagcf );_feaab :=_eddgf .height (_cfacf );_bgeeb :=_decfc ._eegf [_eddgf ._ggccd +_eddgf ._effeb -2];if _eddgf ._effeb > 1{_ecffg :=0.0;
_cdge :=_decfc ._eegf [_eddgf ._ggccd -1:(_eddgf ._ggccd +_eddgf ._effeb -1)];for _ ,_dacgc :=range _cdge {_ecffg +=_dacgc ;};if _feaab <=_ecffg {continue ;};};if _feaab > _bgeeb {_adbde :=_feaab /float64 (_eddgf ._effeb );if _adbde > _bgeeb {for _gdba :=1;
_gdba <=_eddgf ._effeb ;_gdba ++{if _adbde > _decfc ._eegf [_eddgf ._ggccd +_gdba -2]{_decfc ._eegf [_eddgf ._ggccd +_gdba -2]=_adbde ;};};};};};};func _gcgad (_deagb string )([]string ,error ){var (_dfdgc []string ;_gdbgf []rune ;);for _ ,_affcg :=range _deagb {if _affcg =='\u000A'{if len (_gdbgf )> 0{_dfdgc =append (_dfdgc ,string (_gdbgf ));
};_dfdgc =append (_dfdgc ,string (_affcg ));_gdbgf =nil ;continue ;};_gdbgf =append (_gdbgf ,_affcg );};if len (_gdbgf )> 0{_dfdgc =append (_dfdgc ,string (_gdbgf ));};var _febgf []string ;for _ ,_cfefb :=range _dfdgc {_aeece :=[]rune (_cfefb );_cefadb :=_dad .NewScanner (_aeece );
var _dddc []rune ;for _fdaea :=0;_fdaea < len (_aeece );_fdaea ++{_ ,_ceadb ,_gcbbe :=_cefadb .Next ();if _gcbbe !=nil {return nil ,_gcbbe ;};if _ceadb ==_dad .BreakProhibited ||_bg .IsSpace (_aeece [_fdaea ]){_dddc =append (_dddc ,_aeece [_fdaea ]);if _bg .IsSpace (_aeece [_fdaea ]){_febgf =append (_febgf ,string (_dddc ));
_dddc =[]rune {};};continue ;}else {if len (_dddc )> 0{_febgf =append (_febgf ,string (_dddc ));};_dddc =[]rune {_aeece [_fdaea ]};};};if len (_dddc )> 0{_febgf =append (_febgf ,string (_dddc ));};};return _febgf ,nil ;};

// Rows returns the total number of rows the table has.
func (_fabdf *Table )Rows ()int {return _fabdf ._egged };

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_adgef *Table )MultiColCell (colspan int )*TableCell {return _adgef .MultiCell (1,colspan )};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_aagb *Creator )SetPageSize (size PageSize ){_aagb ._dfce =size ;_aagb ._ffeg =size [0];_aagb ._adc =size [1];_bacd :=0.1*_aagb ._ffeg ;_aagb ._ggeg .Left =_bacd ;_aagb ._ggeg .Right =_bacd ;_aagb ._ggeg .Top =_bacd ;_aagb ._ggeg .Bottom =_bacd ;
};

// SetLineHeight sets the line height (1.0 default).
func (_ccfcc *StyledParagraph )SetLineHeight (lineheight float64 ){_ccfcc ._agcdg =lineheight };

// Width returns the width of the Paragraph.
func (_dbda *StyledParagraph )Width ()float64 {if _dbda ._eagfa &&int (_dbda ._bcdba )> 0{return _dbda ._bcdba ;};return _dbda .getTextWidth ()/1000.0;};func (_agfd *Ellipse )applyFitMode (_bfad float64 ){_bfad -=_agfd ._cdg .Left +_agfd ._cdg .Right ;
switch _agfd ._gaeg {case FitModeFillWidth :_agfd .ScaleToWidth (_bfad );};};

// Add adds a new line with the default style to the table of contents.
func (_adegd *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_dcdcd :=_adegd .AddLine (_ccdbd (TextChunk {Text :number ,Style :_adegd ._ccggc },TextChunk {Text :title ,Style :_adegd ._adcec },TextChunk {Text :page ,Style :_adegd ._cffeag },level ,_adegd ._gbagb ));
if _dcdcd ==nil {return nil ;};_dcfgf :=&_adegd ._cgdcf ;_dcdcd .SetMargins (_dcfgf .Left ,_dcfgf .Right ,_dcfgf .Top ,_dcfgf .Bottom );_dcdcd .SetLevelOffset (_adegd ._fcfdg );_dcdcd .Separator .Text =_adegd ._ageg ;_dcdcd .Separator .Style =_adegd ._dfdfe ;
return _dcdcd ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_efgg *shading )SetAntiAlias (enable bool ){_efgg ._aagae =enable };func _ffee (_egab string ,_edggf bool )string {_gecd :=_egab ;if _gecd ==""{return "";};_ecbfc :=_ec .Paragraph {};_ ,_bccg :=_ecbfc .SetString (_egab );if _bccg !=nil {return _gecd ;
};_adba ,_bccg :=_ecbfc .Order ();if _bccg !=nil {return _gecd ;};_gfbfd :=_adba .NumRuns ();_deaae :=make ([]string ,_gfbfd );for _dcgdd :=0;_dcgdd < _adba .NumRuns ();_dcgdd ++{_cgaa :=_adba .Run (_dcgdd );_aaba :=_cgaa .String ();if _cgaa .Direction ()==_ec .RightToLeft {_aaba =_ec .ReverseString (_aaba );
};if _edggf {_deaae [_dcgdd ]=_aaba ;}else {_deaae [_gfbfd -1]=_aaba ;};_gfbfd --;};if len (_deaae )!=_adba .NumRuns (){return _egab ;};_gecd =_de .Join (_deaae ,"");return _gecd ;};

// Height returns the height of the chart.
func (_dgc *Chart )Height ()float64 {return float64 (_dgc ._ddge .Height ())};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_fdfc *Invoice )AddressHeadingStyle ()TextStyle {return _fdfc ._edab };

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_geab *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_gefg *_ed .PdfWriter )error ){_geab ._cfd =pdfWriterAccessFunc ;};

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_fgc *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fgc ._fcgg .Left ,_fgc ._fcgg .Right ,_fgc ._fcgg .Top ,_fgc ._fcgg .Bottom ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_cgbe *Invoice )SetTerms (title ,content string ){_cgbe ._eged =[2]string {title ,content }};func (_cegf *Division )ctxHeight (_daeg float64 )float64 {_daeg -=_cegf ._baad .Left +_cegf ._baad .Right +_cegf ._babd .Left +_cegf ._babd .Right ;var _geccg float64 ;
for _ ,_gadg :=range _cegf ._ggcc {_geccg +=_gedg (_gadg ,_daeg );};return _geccg ;};func _gegfb (_gcbg int )*Table {_fafb :=&Table {_dfeg :_gcbg ,_fgac :10.0,_dbeeb :[]float64 {},_eegf :[]float64 {},_cfcdg :[]*TableCell {},_agdgb :make ([]int ,_gcbg ),_efbed :true };
_fafb .resetColumnWidths ();return _fafb ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_abed *Creator )DrawTemplate (r _eb .Reader ,data interface{},options *TemplateOptions )error {return _gcagg (_abed ,r ,data ,options ,_abed );};func _dfd (_dadg string ,_fecb _gd .PdfObject ,_egb *_ed .PdfPageResources )_gd .PdfObjectName {_bdaf :=_de .TrimRightFunc (_de .TrimSpace (_dadg ),func (_efd rune )bool {return _bg .IsNumber (_efd )});
if _bdaf ==""{_bdaf ="\u0046\u006f\u006e\u0074";};_cbg :=0;_cgd :=_gd .PdfObjectName (_dadg );for {_ebfa ,_agca :=_egb .GetFontByName (_cgd );if !_agca ||_ebfa ==_fecb {break ;};_cbg ++;_cgd =_gd .PdfObjectName (_f .Sprintf ("\u0025\u0073\u0025\u0064",_bdaf ,_cbg ));
};return _cgd ;};func (_bddc *Creator )wrapPageIfNeeded (_abdb *_ed .PdfPage )(*_ed .PdfPage ,error ){_dedf ,_cgfe :=_abdb .GetAllContentStreams ();if _cgfe !=nil {return nil ,_cgfe ;};_cffe :=_cc .NewContentStreamParser (_dedf );_ccdd ,_cgfe :=_cffe .Parse ();
if _cgfe !=nil {return nil ,_cgfe ;};if !_ccdd .HasUnclosedQ (){return nil ,nil ;};_ccdd .WrapIfNeeded ();_gce ,_cgfe :=_gd .MakeStream (_ccdd .Bytes (),_gd .NewFlateEncoder ());if _cgfe !=nil {return nil ,_cgfe ;};_abdb .Contents =_gd .MakeArray (_gce );
return _abdb ,nil ;};

// MoveX moves the drawing context to absolute position x.
func (_bddg *Creator )MoveX (x float64 ){_bddg ._abe .X =x };

// SetOpacity sets opacity for Image.
func (_cefdd *Image )SetOpacity (opacity float64 ){_cefdd ._deeeg =opacity };

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_ebfde Color ;_beaee _bf .LineStyle ;_gcecd CellBorderStyle ;_gdga Color ;_fafbe float64 ;_cbaca CellBorderStyle ;_ddeb Color ;_bdbcc float64 ;_bfae CellBorderStyle ;_ffgab Color ;_agge float64 ;_bebdb CellBorderStyle ;_bebf Color ;
_defbe float64 ;_ggccd ,_eafa int ;_effeb int ;_edaeg int ;_aeeee VectorDrawable ;_gffac CellHorizontalAlignment ;_eagd CellVerticalAlignment ;_bgeed float64 ;_afbd *Table ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_bdefc *Table )SetMargins (left ,right ,top ,bottom float64 ){_bdefc ._dead .Left =left ;_bdefc ._dead .Right =right ;_bdefc ._dead .Top =top ;_bdefc ._dead .Bottom =bottom ;};func (_fdaf cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_badg :=_fdaf ._dgde ;
return 1-(_fdaf ._dag *(1-_badg )+_badg ),1-(_fdaf ._acg *(1-_badg )+_badg ),1-(_fdaf ._befc *(1-_badg )+_badg );};

// GeneratePageBlocks draws the chart onto a block.
func (_ecgd *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ada :=ctx ;_ace :=_ecgd ._gbea .IsRelative ();var _cfbc []*Block ;if _ace {_dba :=1.0;_fcad :=_ecgd ._bfa .Top ;if float64 (_ecgd ._ddge .Height ())> ctx .Height -_ecgd ._bfa .Top {_cfbc =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _ebfc error ;if _ ,ctx ,_ebfc =_agde ().GeneratePageBlocks (ctx );_ebfc !=nil {return nil ,ctx ,_ebfc ;};_fcad =0;};ctx .X +=_ecgd ._bfa .Left +_dba ;ctx .Y +=_fcad ;ctx .Width -=_ecgd ._bfa .Left +_ecgd ._bfa .Right +2*_dba ;ctx .Height -=_fcad ;_ecgd ._ddge .SetWidth (int (ctx .Width ));
}else {ctx .X =_ecgd ._bgce ;ctx .Y =_ecgd ._ggdf ;};_dedcg :=_cc .NewContentCreator ();_dedcg .Translate (0,ctx .PageHeight );_dedcg .Scale (1,-1);_dedcg .Translate (ctx .X ,ctx .Y );_eegbf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ecgd ._ddge .Render (_cb .NewRenderer (_dedcg ,_eegbf ._ece ),nil );
if _gbdgc :=_eegbf .addContentsByString (_dedcg .String ());_gbdgc !=nil {return nil ,ctx ,_gbdgc ;};if _ace {_dfac :=_ecgd .Height ()+_ecgd ._bfa .Bottom ;ctx .Y +=_dfac ;ctx .Height -=_dfac ;}else {ctx =_ada ;};_cfbc =append (_cfbc ,_eegbf );return _cfbc ,ctx ,nil ;
};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_cagf *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _ccdbd (number ,title ,page ,level ,style );};

// Margins returns the margins of the list: left, right, top, bottom.
func (_fgdad *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _fgdad ._afded .Left ,_fgdad ._afded .Right ,_fgdad ._afded .Top ,_fgdad ._afded .Bottom ;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_daag *_bf .Polyline ;_gcaa float64 ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_bdag *Invoice )SetTitleStyle (style TextStyle ){_bdag ._cedg =style };func _edcg (_fcdb *_ed .Image )(*Image ,error ){_dged :=float64 (_fcdb .Width );_bfaa :=float64 (_fcdb .Height );return &Image {_bdec :_fcdb ,_dddd :_dged ,_egbcd :_bfaa ,_dgfb :_dged ,_dafe :_bfaa ,_eadd :0,_deeeg :1.0,_eecdg :PositionRelative },nil ;
};

// SetColorTop sets border color for top.
func (_edgb *border )SetColorTop (col Color ){_edgb ._eaf =col };

// Width returns the cell's width based on the input draw context.
func (_bgda *TableCell )Width (ctx DrawContext )float64 {_eddef :=float64 (0.0);for _ccbcb :=0;_ccbcb < _bgda ._edaeg ;_ccbcb ++{_eddef +=_bgda ._afbd ._dbeeb [_bgda ._eafa +_ccbcb -1];};_ebef :=ctx .Width *_eddef ;return _ebef ;};const (FitModeNone FitMode =iota ;
FitModeFillWidth ;);

// BorderWidth returns the border width of the ellipse.
func (_deda *Ellipse )BorderWidth ()float64 {return _deda ._fddf };

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_fbcg *TOC )SetLineTitleStyle (style TextStyle ){_fbcg ._adcec =style };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gccd *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggefg :=ctx ;_egbcf ,ctx ,_acbdf :=_gccd ._efdca .GeneratePageBlocks (ctx );if _acbdf !=nil {return _egbcf ,ctx ,_acbdf ;};for _ ,_eaag :=range _gccd ._ffge {_fgba :=_eaag ._bceb ;
if !_gccd ._daedd {_eaag ._bceb =0;};_gada ,_cecab ,_cdbag :=_eaag .GeneratePageBlocks (ctx );_eaag ._bceb =_fgba ;if _cdbag !=nil {return _egbcf ,ctx ,_cdbag ;};if len (_gada )< 1{continue ;};_egbcf [len (_egbcf )-1].mergeBlocks (_gada [0]);_egbcf =append (_egbcf ,_gada [1:]...);
ctx =_cecab ;};if _gccd ._aadcda .IsRelative (){ctx .X =_ggefg .X ;};if _gccd ._aadcda .IsAbsolute (){return _egbcf ,_ggefg ,nil ;};return _egbcf ,ctx ,nil ;};

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_ggac *Ellipse )GetCoords ()(float64 ,float64 ){return _ggac ._faac ,_ggac ._ccag };

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};func (_edgc *pageTransformations )transformBlock (_fcg *Block ){if _edgc ._dab !=nil {_fcg .transform (*_edgc ._dab );};};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_egfdf *StyledParagraph )SetWidth (width float64 ){_egfdf ._bcdba =width ;_egfdf .wrapText ()};func (_bebe *Line )computeCoords (_edcc DrawContext )(_gdcf ,_dece ,_fcaa ,_gcbc float64 ){_gdcf =_edcc .X ;_fcaa =_gdcf +_bebe ._fbfbg -_bebe ._dffgg ;
_eacd :=_bebe ._cdff ;if _bebe ._dffgg ==_bebe ._fbfbg {_eacd /=2;};if _bebe ._acad < _bebe ._dbd {_dece =_edcc .PageHeight -_edcc .Y -_eacd ;_gcbc =_dece -_bebe ._dbd +_bebe ._acad ;}else {_gcbc =_edcc .PageHeight -_edcc .Y -_eacd ;_dece =_gcbc -_bebe ._acad +_bebe ._dbd ;
};switch _bebe ._effdb {case FitModeFillWidth :_fcaa =_gdcf +_edcc .Width ;};return _gdcf ,_dece ,_fcaa ,_gcbc ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_dbag *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_bcgd []*Block ;_acgb bool ;_bffaa error ;_bcf =_dbag ._dgf .IsRelative ();_fcddc =_dbag ._baad .Top ;);if _bcf &&!_dbag ._dffg &&!_dbag ._afdb {_gdbf :=_dbag .ctxHeight (ctx .Width );
if _gdbf > ctx .Height -_dbag ._baad .Top &&_gdbf <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _bcgd ,ctx ,_bffaa =_agde ().GeneratePageBlocks (ctx );_bffaa !=nil {return nil ,ctx ,_bffaa ;};_acgb =true ;_fcddc =0;};};_faff :=ctx ;_cagd :=ctx ;
if _bcf {ctx .X +=_dbag ._baad .Left ;ctx .Y +=_fcddc ;ctx .Width -=_dbag ._baad .Left +_dbag ._baad .Right ;ctx .Height -=_fcddc ;_cagd =ctx ;ctx .X +=_dbag ._babd .Left ;ctx .Y +=_dbag ._babd .Top ;ctx .Width -=_dbag ._babd .Left +_dbag ._babd .Right ;
ctx .Height -=_dbag ._babd .Top ;ctx .Margins .Top +=_dbag ._babd .Top ;ctx .Margins .Bottom +=_dbag ._babd .Bottom ;ctx .Margins .Left +=_dbag ._baad .Left +_dbag ._babd .Left ;ctx .Margins .Right +=_dbag ._baad .Right +_dbag ._babd .Right ;};ctx .Inline =_dbag ._afdb ;
_bacg :=ctx ;_afae :=ctx ;var _cded float64 ;for _ ,_dbaf :=range _dbag ._ggcc {if ctx .Inline {if (ctx .X -_bacg .X )+_dbaf .Width ()<=ctx .Width {ctx .Y =_afae .Y ;ctx .Height =_afae .Height ;}else {ctx .X =_bacg .X ;ctx .Width =_bacg .Width ;_afae .Y +=_cded ;
_afae .Height -=_cded ;_cded =0;};};_fbfg ,_bdgc ,_acaec :=_dbaf .GeneratePageBlocks (ctx );if _acaec !=nil {_gfb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_acaec );
return nil ,ctx ,_acaec ;};if len (_fbfg )< 1{continue ;};if len (_bcgd )> 0{_bcgd [len (_bcgd )-1].mergeBlocks (_fbfg [0]);_bcgd =append (_bcgd ,_fbfg [1:]...);}else {if _bffg :=_fbfg [0]._ebg ;_bffg ==nil ||len (*_bffg )==0{_acgb =true ;};_bcgd =append (_bcgd ,_fbfg [0:]...);
};if ctx .Inline {if ctx .Page !=_bdgc .Page {_bacg .Y =ctx .Margins .Top ;_bacg .Height =ctx .PageHeight -ctx .Margins .Top ;_afae .Y =_bacg .Y ;_afae .Height =_bacg .Height ;_cded =_bdgc .Height -_bacg .Height ;}else {if _ggfd :=ctx .Height -_bdgc .Height ;
_ggfd > _cded {_cded =_ggfd ;};};}else {_bdgc .X =ctx .X ;};ctx =_bdgc ;};if len (_dbag ._ggcc )==0{_cdeb :=NewBlock (ctx .Width ,0);_bcgd =append (_bcgd ,_cdeb );};ctx .Inline =_faff .Inline ;ctx .Margins =_faff .Margins ;if _bcf {ctx .X =_faff .X ;ctx .Width =_faff .Width ;
ctx .Y +=_dbag ._babd .Bottom ;ctx .Height -=_dbag ._babd .Bottom ;};if _dbag ._aadg !=nil {_bcgd ,_bffaa =_dbag .drawBackground (_bcgd ,_cagd ,ctx ,_acgb );if _bffaa !=nil {return nil ,ctx ,_bffaa ;};};if _dbag ._dgf .IsAbsolute (){return _bcgd ,_faff ,nil ;
};ctx .Y +=_dbag ._baad .Bottom ;ctx .Height -=_dbag ._baad .Bottom ;return _bcgd ,ctx ,nil ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_agec *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_agec ._aabe =alignment };

// Heading returns the heading component of the table of contents.
func (_cfbdg *TOC )Heading ()*StyledParagraph {return _cfbdg ._efdca };

// NewColumn returns a new column for the line items invoice table.
func (_fddfg *Invoice )NewColumn (description string )*InvoiceCell {return _fddfg .newColumn (description ,CellHorizontalAlignmentLeft );};

// SetBorderColor sets border color of the rectangle.
func (_gegd *Rectangle )SetBorderColor (col Color ){_gegd ._feea =col };

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_fffg *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_dcgb :=_cfeea (_fffg ._aaagc );_dcgb .Append (text );_acbbf ,_aabg :=_fffg .Add (_dcgb );return _dcgb ,_acbbf ,_aabg ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_eaggg *Paragraph )Height ()float64 {_eaggg .wrapText ();return float64 (len (_eaggg ._baeba ))*_eaggg ._efbdc *_eaggg ._afffc ;};func (_efac *Invoice )drawInformation ()*Table {_bfada :=_gegfb (2);_fdbe :=append ([][2]*InvoiceCell {_efac ._aafc ,_efac ._defb ,_efac ._beff },_efac ._ccad ...);
for _ ,_dadga :=range _fdbe {_edeb ,_cgdb :=_dadga [0],_dadga [1];if _cgdb .Value ==""{continue ;};_fbcb :=_bfada .NewCell ();_fbcb .SetBackgroundColor (_edeb .BackgroundColor );_efac .setCellBorder (_fbcb ,_edeb );_bggf :=_cfeea (_edeb .TextStyle );_bggf .Append (_edeb .Value );
_bggf .SetMargins (0,0,2,1);_fbcb .SetContent (_bggf );_fbcb =_bfada .NewCell ();_fbcb .SetBackgroundColor (_cgdb .BackgroundColor );_efac .setCellBorder (_fbcb ,_cgdb );_bggf =_cfeea (_cgdb .TextStyle );_bggf .Append (_cgdb .Value );_bggf .SetMargins (0,0,2,1);
_fbcb .SetContent (_bggf );};return _bfada ;};

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_fadab *Line )Width ()float64 {return _cf .Abs (_fadab ._fbfbg -_fadab ._dffgg )};func _eggfg (_aggca *_ed .PdfAnnotation )*_ed .PdfAnnotation {if _aggca ==nil {return nil ;};var _bfef *_ed .PdfAnnotation ;switch _fdca :=_aggca .GetContext ().(type ){case *_ed .PdfAnnotationLink :if _bggca :=_cacdg (_fdca );
_bggca !=nil {_bfef =_bggca .PdfAnnotation ;};};return _bfef ;};func (_afafa *templateProcessor )loadImageFromSrc (_cbfa string )(*Image ,error ){if _cbfa ==""{_gfb .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_gcbe ;};_begfb :=_de .Split (_cbfa ,"\u002c");for _ ,_cgafe :=range _begfb {_cgafe =_de .TrimSpace (_cgafe );if _cgafe ==""{continue ;};_cbgg ,_ddagc :=_afafa ._bfega .ImageMap [_cgafe ];if _ddagc {return _edcg (_cbgg );};if _aggf :=_afafa .parseAttrPropList (_cgafe );
len (_aggf )> 0{if _bfaeg ,_gfaab :=_aggf ["\u0070\u0061\u0074\u0068"];_gfaab {if _abddf ,_decgf :=_egbad (_bfaeg );_decgf !=nil {_gfb .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_bfaeg ,_decgf );
}else {return _abddf ,nil ;};};};};_gfb .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_cbfa );return nil ,_gcbe ;};

// Width returns the width of the specified text chunk.
func (_bgab *TextChunk )Width ()float64 {var (_efabb float64 ;_bbeg =_bgab .Style ;);for _ ,_adefdb :=range _bgab .Text {_facgg ,_bdgga :=_bbeg .Font .GetRuneMetrics (_adefdb );if !_bdgga {_gfb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_adefdb ,_adefdb ,_bbeg .Font .BaseFont (),_bbeg .Font .Subtype ());
_gfb .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_bbeg .Font );_gfb .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_bbeg .Font .Encoder ());};_dabbc :=_bbeg .FontSize *_facgg .Wx ;_cacg :=_dabbc ;if _adefdb !=' '{_cacg =_dabbc +_bbeg .CharSpacing *1000.0;
};_efabb +=_cacg ;};return _efabb /1000.0;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_cbcc *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _e .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _e .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _e .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_cbcc ._befce =true ;_cbcc ._bdcdfg =startRow ;_cbcc ._feac =endRow ;return nil ;};func (_eef *InvoiceAddress )fmtLine (_ecd ,_egec string ,_fgbe bool )string {if _fgbe {_egec ="";};return _f .Sprintf ("\u0025\u0073\u0025s\u000a",_egec ,_ecd );};func (_dge *Block )mergeBlocks (_aada *Block )error {_ddd :=_ffe (_dge ._ebg ,_dge ._ece ,_aada ._ebg ,_aada ._ece );
if _ddd !=nil {return _ddd ;};for _ ,_ggc :=range _aada ._ba {_dge .AddAnnotation (_ggc );};return nil ;};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _d .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_eb .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_ed .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_ed .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_ge .ChartRenderable ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_dabb *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_dabb ._ggeg .Left =left ;_dabb ._ggeg .Right =right ;_dabb ._ggeg .Top =top ;_dabb ._ggeg .Bottom =bottom ;};

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_eabf *Ellipse )ScaleToWidth (w float64 ){_gece :=_eabf ._abda /_eabf ._efge ;_eabf ._efge =w ;_eabf ._abda =w *_gece ;};func _cecd (_affg *templateProcessor ,_caeba *templateNode )(interface{},error ){return _affg .parseEllipse (_caeba );};

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _aafb (svgStr )};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_gdgfc *Invoice )Terms ()(string ,string ){return _gdgfc ._eged [0],_gdgfc ._eged [1]};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_bagf *Ellipse )SetFitMode (fitMode FitMode ){_bagf ._gaeg =fitMode };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_bfge *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_abdaf :=NewTextChunk (text ,_bfge ._fbag );_abdaf ._eefeb =_bfee (page -1,x ,y ,zoom );return _bfge .appendChunk (_abdaf );};func (_bgcea *shading )generatePdfFunctions ()[]_ed .PdfFunction {if len (_bgcea ._dcagf )==0{return nil ;
}else if len (_bgcea ._dcagf )<=2{_cbbg ,_gdbdg ,_gdbfd :=_bgcea ._dcagf [0]._cegfg .ToRGB ();_daef ,_bfde ,_acbbe :=_bgcea ._dcagf [len (_bgcea ._dcagf )-1]._cegfg .ToRGB ();return []_ed .PdfFunction {&_ed .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_cbbg ,_gdbdg ,_gdbfd },C1 :[]float64 {_daef ,_bfde ,_acbbe }}};
}else {_dacg :=[]_ed .PdfFunction {};_cgeef :=[]float64 {};for _aaeaa :=0;_aaeaa < len (_bgcea ._dcagf )-1;_aaeaa ++{_dcgab ,_agddf ,_acbf :=_bgcea ._dcagf [_aaeaa ]._cegfg .ToRGB ();_aeefe ,_eccf ,_eacdd :=_bgcea ._dcagf [_aaeaa +1]._cegfg .ToRGB ();_befcb :=&_ed .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_dcgab ,_agddf ,_acbf },C1 :[]float64 {_aeefe ,_eccf ,_eacdd }};
_dacg =append (_dacg ,_befcb );if _aaeaa > 0{_cgeef =append (_cgeef ,_bgcea ._dcagf [_aaeaa ]._bddag );};};_edfae :=[]float64 {};for range _dacg {_edfae =append (_edfae ,[]float64 {0.0,1.0}...);};return []_ed .PdfFunction {&_ed .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_dacg ,Bounds :_cgeef ,Encode :_edfae }};
};};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_fge *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_fge ._ggda .Left =left ;_fge ._ggda .Right =right ;_fge ._ggda .Top =top ;_fge ._ggda .Bottom =bottom ;};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_dgbfg *Creator )NewStyledParagraph ()*StyledParagraph {return _cfeea (_dgbfg .NewTextStyle ())};func _aafb (_agdg string )(*GraphicSVG ,error ){_dafg ,_cddd :=_fd .ParseFromString (_agdg );if _cddd !=nil {return nil ,_cddd ;};return _fedgf (_dafg );
};func _faeef (_cfceb string )bool {_fffdb :=func (_bcdag rune )bool {return _bcdag =='\u000A'};_agggab :=_de .TrimFunc (_cfceb ,_fffdb );_ccdgc :=_ec .Paragraph {};_ ,_dcfed :=_ccdgc .SetString (_agggab );if _dcfed !=nil {return true ;};_cbec ,_dcfed :=_ccdgc .Order ();
if _dcfed !=nil {return true ;};if _cbec .NumRuns ()< 1{return true ;};return _ccdgc .IsLeftToRight ();};func _faaec (_gdfea string ,_gcfga ,_acabcb TextStyle )*TOC {_geggf :=_acabcb ;_geggf .FontSize =14;_aaae :=_cfeea (_geggf );_aaae .SetEnableWrap (true );
_aaae .SetTextAlignment (TextAlignmentLeft );_aaae .SetMargins (0,0,0,5);_bcfgf :=_aaae .Append (_gdfea );_bcfgf .Style =_geggf ;return &TOC {_efdca :_aaae ,_ffge :[]*TOCLine {},_ccggc :_gcfga ,_adcec :_gcfga ,_dfdfe :_gcfga ,_cffeag :_gcfga ,_ageg :"\u002e",_fcfdg :10,_cgdcf :Margins {0,0,2,2},_aadcda :PositionRelative ,_gbagb :_gcfga ,_daedd :true };
};

// Margins returns the margins of the component.
func (_cgdgc *Division )Margins ()(_feff ,_gbac ,_gfaa ,_gaba float64 ){return _cgdgc ._baad .Left ,_cgdgc ._baad .Right ,_cgdgc ._baad .Top ,_cgdgc ._baad .Bottom ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_gaee *Image )SetEncoder (encoder _gd .StreamEncoder ){_gaee ._afab =encoder };var PPMM =float64 (72*1.0/25.4);

// SetSubtotal sets the subtotal of the invoice.
func (_bdca *Invoice )SetSubtotal (value string ){_bdca ._abgd [1].Value =value };func _bbge (_decb ,_aebd ,_geccf ,_cgge float64 )*Ellipse {return &Ellipse {_faac :_decb ,_ccag :_aebd ,_efge :_geccf ,_abda :_cgge ,_dfda :PositionAbsolute ,_eag :1.0,_gdcga :ColorBlack ,_fddf :1.0,_ddbee :1.0};
};

// SetMargins sets the margins TOC line.
func (_geec *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_geec ._gabdg =left ;_gcbd :=&_geec ._fbaf ._acbfg ;_gcbd .Left =_geec ._gabdg +float64 (_geec ._cefgd -1)*_geec ._fabb ;_gcbd .Right =right ;_gcbd .Top =top ;_gcbd .Bottom =bottom ;};
func (_eede *templateProcessor )parseChapter (_fecef *templateNode )(interface{},error ){_fdecfe :=_eede .creator .NewChapter ;if _fecef ._gfggb !=nil {if _fgebeg ,_ggdb :=_fecef ._gfggb ._cagcg .(*Chapter );_ggdb {_fdecfe =_fgebeg .NewSubchapter ;};};
_fccaca :=_fdecfe ("");for _ ,_gbgb :=range _fecef ._adbf .Attr {_dffggc :=_gbgb .Value ;switch _gdadc :=_gbgb .Name .Local ;_gdadc {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_fccaca .SetShowNumbering (_eede .parseBoolAttr (_gdadc ,_dffggc ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_fccaca .SetIncludeInTOC (_eede .parseBoolAttr (_gdadc ,_dffggc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_eedbe :=_eede .parseMarginAttr (_gdadc ,_dffggc );_fccaca .SetMargins (_eedbe .Left ,_eedbe .Right ,_eedbe .Top ,_eedbe .Bottom );
default:_eede .nodeLogDebug (_fecef ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gdadc );
};};return _fccaca ,nil ;};func (_aagba *templateProcessor )parsePositioningAttr (_bbbab ,_bfbg string )Positioning {_gfb .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bbbab ,_bfbg );
_ffcg :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_bfbg ];return _ffcg ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;
CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);func (_bgdfd *templateProcessor )parseMarginAttr (_gegec ,_feeef string )Margins {_gfb .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_gegec ,_feeef );
_egdae :=Margins {};switch _bdffc :=_de .Fields (_feeef );len (_bdffc ){case 1:_egdae .Top ,_ =_ad .ParseFloat (_bdffc [0],64);_egdae .Bottom =_egdae .Top ;_egdae .Left =_egdae .Top ;_egdae .Right =_egdae .Top ;case 2:_egdae .Top ,_ =_ad .ParseFloat (_bdffc [0],64);
_egdae .Bottom =_egdae .Top ;_egdae .Left ,_ =_ad .ParseFloat (_bdffc [1],64);_egdae .Right =_egdae .Left ;case 3:_egdae .Top ,_ =_ad .ParseFloat (_bdffc [0],64);_egdae .Left ,_ =_ad .ParseFloat (_bdffc [1],64);_egdae .Right =_egdae .Left ;_egdae .Bottom ,_ =_ad .ParseFloat (_bdffc [2],64);
case 4:_egdae .Top ,_ =_ad .ParseFloat (_bdffc [0],64);_egdae .Right ,_ =_ad .ParseFloat (_bdffc [1],64);_egdae .Bottom ,_ =_ad .ParseFloat (_bdffc [2],64);_egdae .Left ,_ =_ad .ParseFloat (_bdffc [3],64);};return _egdae ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// BorderColor returns the border color of the rectangle.
func (_edca *Rectangle )BorderColor ()Color {return _edca ._feea };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_bdafd *TOCLine )SetLink (page int64 ,x ,y float64 ){_bdafd ._edacd =x ;_bdafd ._gdedb =y ;_bdafd ._bceb =page ;_fgfg :=_bdafd ._fbaf ._fbag .Color ;_bdafd .Number .Style .Color =_fgfg ;_bdafd .Title .Style .Color =_fgfg ;_bdafd .Separator .Style .Color =_fgfg ;
_bdafd .Page .Style .Color =_fgfg ;};

// SetOpacity sets the opacity of the line (0-1).
func (_decad *Line )SetOpacity (opacity float64 ){_decad ._efgda =opacity };func (_ggcfb *templateProcessor )parseParagraph (_egcc *templateNode ,_deeae *Paragraph )(interface{},error ){if _deeae ==nil {_deeae =_ggcfb .creator .NewParagraph ("");};for _ ,_bbgac :=range _egcc ._adbf .Attr {_dffae :=_bbgac .Value ;
switch _ecbde :=_bbgac .Name .Local ;_ecbde {case "\u0066\u006f\u006e\u0074":_deeae .SetFont (_ggcfb .parseFontAttr (_ecbde ,_dffae ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_deeae .SetFontSize (_ggcfb .parseFloatAttr (_ecbde ,_dffae ));case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_deeae .SetTextAlignment (_ggcfb .parseTextAlignmentAttr (_ecbde ,_dffae ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_deeae .SetLineHeight (_ggcfb .parseFloatAttr (_ecbde ,_dffae ));case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_deeae .SetEnableWrap (_ggcfb .parseBoolAttr (_ecbde ,_dffae ));
case "\u0063\u006f\u006co\u0072":_deeae .SetColor (_ggcfb .parseColorAttr (_ecbde ,_dffae ));case "\u0078":_deeae .SetPos (_ggcfb .parseFloatAttr (_ecbde ,_dffae ),_deeae ._eddg );case "\u0079":_deeae .SetPos (_deeae ._acde ,_ggcfb .parseFloatAttr (_ecbde ,_dffae ));
case "\u0061\u006e\u0067l\u0065":_deeae .SetAngle (_ggcfb .parseFloatAttr (_ecbde ,_dffae ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_efdc :=_ggcfb .parseMarginAttr (_ecbde ,_dffae );_deeae .SetMargins (_efdc .Left ,_efdc .Right ,_efdc .Top ,_efdc .Bottom );
case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_deeae .SetMaxLines (int (_ggcfb .parseInt64Attr (_ecbde ,_dffae )));default:_ggcfb .nodeLogDebug (_egcc ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_ecbde );
};};return _deeae ,nil ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_dfec *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_dfec ._dcag =toc ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_gda *Chapter )GetHeading ()*Paragraph {return _gda ._fdgb };func _bdabd (_dcbdb *templateProcessor ,_ffced *templateNode )(interface{},error ){return _dcbdb .parseList (_ffced );};

// AppendColumn appends a column to the line items table.
func (_ebfbf *Invoice )AppendColumn (description string )*InvoiceCell {_facc :=_ebfbf .NewColumn (description );_ebfbf ._dfdgd =append (_ebfbf ._dfdgd ,_facc );return _facc ;};func _cacdg (_cdbb *_ed .PdfAnnotationLink )*_ed .PdfAnnotationLink {if _cdbb ==nil {return nil ;
};_bggbcg :=_ed .NewPdfAnnotationLink ();_bggbcg .BS =_cdbb .BS ;_bggbcg .A =_cdbb .A ;if _eage ,_dbbd :=_cdbb .GetAction ();_dbbd ==nil &&_eage !=nil {_bggbcg .SetAction (_eage );};if _fafc ,_gcfgg :=_cdbb .Dest .(*_gd .PdfObjectArray );_gcfgg {_bggbcg .Dest =_gd .MakeArray (_fafc .Elements ()...);
};return _bggbcg ;};

// SetBorder sets the cell's border style.
func (_abgdc *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_abgdc ._gcecd =CellBorderStyleSingle ;_abgdc ._fafbe =width ;_abgdc ._cbaca =CellBorderStyleSingle ;
_abgdc ._bdbcc =width ;_abgdc ._bfae =CellBorderStyleSingle ;_abgdc ._agge =width ;_abgdc ._bebdb =CellBorderStyleSingle ;_abgdc ._defbe =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_abgdc ._gcecd =CellBorderStyleDouble ;_abgdc ._fafbe =width ;
_abgdc ._cbaca =CellBorderStyleDouble ;_abgdc ._bdbcc =width ;_abgdc ._bfae =CellBorderStyleDouble ;_abgdc ._agge =width ;_abgdc ._bebdb =CellBorderStyleDouble ;_abgdc ._defbe =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_abgdc ._gcecd =style ;
_abgdc ._fafbe =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_abgdc ._cbaca =style ;_abgdc ._bdbcc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_abgdc ._bfae =style ;
_abgdc ._agge =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_abgdc ._bebdb =style ;_abgdc ._defbe =width ;};};func (_dgbc *templateProcessor )parseTextVerticalAlignmentAttr (_geddc ,_afbfg string )TextVerticalAlignment {_gfb .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_geddc ,_afbfg );
_ffebg :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_afbfg ];return _ffebg ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_fbaf *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_gabdg float64 ;_cefgd uint ;_fabb float64 ;_cbffc Positioning ;_edacd float64 ;_gdedb float64 ;_bceb int64 ;};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_gfae *_bf .CurvePolygon ;_egfd float64 ;_fggf float64 ;_aeef Color ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_fbcbf *Paragraph )SetWidth (width float64 ){_fbcbf ._begf =width ;_fbcbf .wrapText ()};

// Cols returns the total number of columns the table has.
func (_dcgf *Table )Cols ()int {return _dcgf ._dfeg };func (_beadb *templateProcessor )parseCellBorderStyleAttr (_fbbea ,_efcea string )CellBorderStyle {_gfb .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_fbbea ,_efcea );
_ebdbf :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_efcea ];return _ebdbf ;};

// GetIndent get the cell's left indent.
func (_dbcg *TableCell )GetIndent ()float64 {return _dbcg ._bgeed };func (_faab *Division )drawBackground (_edfb []*Block ,_aeaf ,_ccdf DrawContext ,_abedb bool )([]*Block ,error ){_cgdc :=len (_edfb );if _cgdc ==0||_faab ._aadg ==nil {return _edfb ,nil ;
};_acag :=make ([]*Block ,0,len (_edfb ));for _eeca ,_dbgg :=range _edfb {var (_bbfa =_faab ._aadg .BorderRadiusTopLeft ;_bfdg =_faab ._aadg .BorderRadiusTopRight ;_aaag =_faab ._aadg .BorderRadiusBottomLeft ;_bfce =_faab ._aadg .BorderRadiusBottomRight ;
);_aggd :=_aeaf ;_aggd .Page +=_eeca ;if _eeca ==0{if _abedb {_acag =append (_acag ,_dbgg );continue ;};if _cgdc ==1{_aggd .Height =_ccdf .Y -_aeaf .Y ;};}else {_aggd .X =_aggd .Margins .Left +_faab ._baad .Left ;_aggd .Y =_aggd .Margins .Top ;_aggd .Width =_aggd .PageWidth -_aggd .Margins .Left -_aggd .Margins .Right -_faab ._baad .Left -_faab ._baad .Right ;
if _eeca ==_cgdc -1{_aggd .Height =_ccdf .Y -_aggd .Margins .Top -_faab ._baad .Top ;}else {_aggd .Height =_aggd .PageHeight -_aggd .Margins .Top -_aggd .Margins .Bottom ;};if !_abedb {_bbfa =0;_bfdg =0;};};if _cgdc > 1&&_eeca !=_cgdc -1{_aaag =0;_bfce =0;
};_edac :=_efacg (_aggd .X ,_aggd .Y ,_aggd .Width ,_aggd .Height );_edac .SetFillColor (_faab ._aadg .FillColor );_edac .SetBorderColor (_faab ._aadg .BorderColor );_edac .SetBorderWidth (_faab ._aadg .BorderSize );_edac .SetBorderRadius (_bbfa ,_bfdg ,_aaag ,_bfce );
_aafa ,_ ,_gfgb :=_edac .GeneratePageBlocks (_aggd );if _gfgb !=nil {return nil ,_gfgb ;};if len (_aafa )==0{continue ;};_ceae :=_aafa [0];if _gfgb =_ceae .mergeBlocks (_dbgg );_gfgb !=nil {return nil ,_gfgb ;};_acag =append (_acag ,_ceae );};return _acag ,nil ;
};var _ecbb =_fb .MustCompile ("\u005c\u0064\u002b");

// Write output of creator to io.Writer interface.
func (_cfcd *Creator )Write (ws _eb .Writer )error {if _beed :=_cfcd .Finalize ();_beed !=nil {return _beed ;};_gede :=_ed .NewPdfWriter ();_gede .SetOptimizer (_cfcd ._affc );if _cfcd ._fgda !=nil {_gbcf :=_gede .SetForms (_cfcd ._fgda );if _gbcf !=nil {_gfb .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_gbcf );
return _gbcf ;};};if _cfcd ._agcag !=nil {_gede .AddOutlineTree (_cfcd ._agcag );}else if _cfcd ._dccf !=nil &&_cfcd .AddOutlines {_gede .AddOutlineTree (&_cfcd ._dccf .ToPdfOutline ().PdfOutlineTreeNode );};if _cfcd ._fega !=nil {if _fdga :=_gede .SetPageLabels (_cfcd ._fega );
_fdga !=nil {_gfb .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_fdga );return _fdga ;};};if _cfcd ._eac !=nil {for _ ,_dgbab :=range _cfcd ._eac {_fadd :=_dgbab .SubsetRegistered ();
if _fadd !=nil {_gfb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_fadd );return _fadd ;};};};if _cfcd ._cfd !=nil {_fbgb :=_cfcd ._cfd (&_gede );
if _fbgb !=nil {_gfb .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_fbgb );return _fbgb ;};};for _ ,_adaa :=range _cfcd ._fgdd {_fcebf :=_gede .AddPage (_adaa );if _fcebf !=nil {_gfb .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_fcebf );
return _fcebf ;};};_aabc :=_gede .Write (ws );if _aabc !=nil {return _aabc ;};return nil ;};func _dddge (_eabfgg ,_deebd ,_cecf float64 )(_gddfc ,_ebea ,_ecbdg ,_cebg float64 ){if _cecf ==0{return 0,0,_eabfgg ,_deebd ;};_bfgdc :=_bf .Path {Points :[]_bf .Point {_bf .NewPoint (0,0).Rotate (_cecf ),_bf .NewPoint (_eabfgg ,0).Rotate (_cecf ),_bf .NewPoint (0,_deebd ).Rotate (_cecf ),_bf .NewPoint (_eabfgg ,_deebd ).Rotate (_cecf )}}.GetBoundingBox ();
return _bfgdc .X ,_bfgdc .Y ,_bfgdc .Width ,_bfgdc .Height ;};func (_fdba *Rectangle )applyFitMode (_dcada float64 ){_dcada -=_fdba ._ddfc .Left +_fdba ._ddfc .Right +_fdba ._cfdf ;switch _fdba ._gfag {case FitModeFillWidth :_fdba .ScaleToWidth (_dcada );
};};

// Angle returns the block rotation angle in degrees.
func (_fc *Block )Angle ()float64 {return _fc ._agc };

// Inline returns whether the inline mode of the division is active.
func (_gebe *Division )Inline ()bool {return _gebe ._afdb };

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_bdfc string ;_bbcb *_ed .PdfFont ;_afffc float64 ;_efbdc float64 ;_ebfca Color ;_ebaa TextAlignment ;_cgbcg bool ;_begf float64 ;_agbafd int ;_gbbc bool ;_egcg float64 ;_edbc Margins ;_fadf Positioning ;_acde float64 ;_eddg float64 ;
_bedg ,_ageb float64 ;_baeba []string ;};

// SetFillOpacity sets the fill opacity.
func (_bdcdcg *Polygon )SetFillOpacity (opacity float64 ){_bdcdcg ._cagc =opacity };

// SetCompactMode sets the compact mode flag for this table.
//
// By enabling compact mode, table cell that contains Paragraph/StyleParagraph
// would not add extra height when calculating it's height.
//
// The default value is false.
func (_bgedb *Table )SetCompactMode (enable bool ){_bgedb ._gdad =enable };func (_ab *Block )translate (_dg ,_gcb float64 ){_baf :=_cc .NewContentCreator ().Translate (_dg ,-_gcb ).Operations ();*_ab ._ebg =append (*_baf ,*_ab ._ebg ...);_ab ._ebg .WrapIfNeeded ();
};func (_edge *templateProcessor )parseLine (_cfdae *templateNode )(interface{},error ){_fbgee :=_edge .creator .NewLine (0,0,0,0);for _ ,_bccc :=range _cfdae ._adbf .Attr {_gddd :=_bccc .Value ;switch _ebbec :=_bccc .Name .Local ;_ebbec {case "\u0078\u0031":_fbgee ._dffgg =_edge .parseFloatAttr (_ebbec ,_gddd );
case "\u0079\u0031":_fbgee ._acad =_edge .parseFloatAttr (_ebbec ,_gddd );case "\u0078\u0032":_fbgee ._fbfbg =_edge .parseFloatAttr (_ebbec ,_gddd );case "\u0079\u0032":_fbgee ._dbd =_edge .parseFloatAttr (_ebbec ,_gddd );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_fbgee .SetLineWidth (_edge .parseFloatAttr (_ebbec ,_gddd ));
case "\u0063\u006f\u006co\u0072":_fbgee .SetColor (_edge .parseColorAttr (_ebbec ,_gddd ));case "\u0073\u0074\u0079l\u0065":_fbgee .SetStyle (_edge .parseLineStyleAttr (_ebbec ,_gddd ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_fbgee .SetDashPattern (_edge .parseInt64Array (_ebbec ,_gddd ),_fbgee ._deaa );
case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_fbgee .SetDashPattern (_fbgee ._eedbb ,_edge .parseInt64Attr (_ebbec ,_gddd ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_fbgee .SetOpacity (_edge .parseFloatAttr (_ebbec ,_gddd ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_fbgee .SetPositioning (_edge .parsePositioningAttr (_ebbec ,_gddd ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_fbgee .SetFitMode (_edge .parseFitModeAttr (_ebbec ,_gddd ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_caad :=_edge .parseMarginAttr (_ebbec ,_gddd );
_fbgee .SetMargins (_caad .Left ,_caad .Right ,_caad .Top ,_caad .Bottom );default:_edge .nodeLogDebug (_cfdae ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ebbec );
};};return _fbgee ,nil ;};

// Horizontal returns total horizontal (left + right) margin.
func (_fggd *Margins )Horizontal ()float64 {return _fggd .Left +_fggd .Right };