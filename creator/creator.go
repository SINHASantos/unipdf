//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
package creator ;import (_cc "bytes";_b "encoding/xml";_fc "errors";_f "fmt";_af "github.com/gorilla/i18n/linebreak";_fbb "github.com/unidoc/unichart/render";_ca "github.com/unidoc/unipdf/v3/common";_eag "github.com/unidoc/unipdf/v3/contentstream";_ddb "github.com/unidoc/unipdf/v3/contentstream/draw";
_be "github.com/unidoc/unipdf/v3/core";_ea "github.com/unidoc/unipdf/v3/internal/graphic2d/svg";_bd "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_ag "github.com/unidoc/unipdf/v3/internal/license";_cbe "github.com/unidoc/unipdf/v3/internal/transform";
_gd "github.com/unidoc/unipdf/v3/model";_fbg "golang.org/x/text/unicode/bidi";_dd "image";_cb "io";_bg "log";_ff "math";_e "os";_c "path/filepath";_g "regexp";_d "sort";_fd "strconv";_ddf "strings";_fb "text/template";_ab "unicode";);

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};func _ggagfc ()*FilledCurve {_fcac :=FilledCurve {};_fcac ._cefdf =[]_ddb .CubicBezierCurve {};return &_fcac ;};

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_dcebe *Rectangle )Width ()float64 {return _dcebe ._dacdg };func (_dga *Block )mergeBlocks (_aa *Block )error {_eagb :=_cga (_dga ._ge ,_dga ._fa ,_aa ._ge ,_aa ._fa );if _eagb !=nil {return _eagb ;};for _ ,_dea :=range _aa ._bdc {_dga .AddAnnotation (_dea );
};return nil ;};func (_cgbcd *templateProcessor )parseBoolAttr (_ecgef ,_gaece string )bool {_ca .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_ecgef ,_gaece );
_afedd ,_ :=_fd .ParseBool (_gaece );return _gaece ==""||_afedd ;};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_faeb *RadialShading )SetBackgroundColor (backgroundColor Color ){_faeb ._ffcg .SetBackgroundColor (backgroundColor );};

// Height returns the height of the graphic svg.
func (_cfda *GraphicSVG )Height ()float64 {return _cfda ._dddg .Height };func (_egfb *templateProcessor )parseLineStyleAttr (_acgea ,_ebbdb string )_ddb .LineStyle {_ca .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_acgea ,_ebbdb );
_dgfad :=map[string ]_ddb .LineStyle {"\u0073\u006f\u006ci\u0064":_ddb .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_ddb .LineStyleDashed }[_ebbdb ];return _dgfad ;};

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_dacd *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dacd ._dffg .Left ,_dacd ._dffg .Right ,_dacd ._dffg .Top ,_dacd ._dffg .Bottom ;};func (_bacc *Chapter )headingText ()string {_ggda :=_bacc ._fagc ;if _fbfa :=_bacc .headingNumber ();
_fbfa !=""{_ggda =_f .Sprintf ("\u0025\u0073\u0020%\u0073",_fbfa ,_ggda );};return _ggda ;};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_ddcb *Chart )Width ()float64 {return float64 (_ddcb ._bgcd .Width ())};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_dfb *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_dfb ._gffac .Left =left ;_dfb ._gffac .Right =right ;_dfb ._gffac .Top =top ;_dfb ._gffac .Bottom =bottom ;};

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_feeg *Creator )Flip (flipH ,flipV bool )error {_ffdc :=_feeg .getActivePage ();if _ffdc ==nil {return _fc .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_bbgf ,_eefb :=_feeg ._gaf [_ffdc ];if !_eefb {_bbgf =&pageTransformations {};
_feeg ._gaf [_ffdc ]=_bbgf ;};_bbgf ._fgfca =flipH ;_bbgf ._gfega =flipV ;return nil ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_cccc *Creator )RotateDeg (angleDeg int64 )error {_fcbg :=_cccc .getActivePage ();if _fcbg ==nil {_ca .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _fc .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_ca .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _fc .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _fagg int64 ;if _fcbg .Rotate !=nil {_fagg =*(_fcbg .Rotate );};_fagg +=angleDeg ;_fcbg .Rotate =&_fagg ;return nil ;};func _agbf (_cfaa []byte )(*Image ,error ){_ecdd :=_cc .NewReader (_cfaa );
_cbac ,_eefe :=_gd .ImageHandling .Read (_ecdd );if _eefe !=nil {_ca .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_eefe );return nil ,_eefe ;};return _bddd (_cbac );
};

// SetWidthRight sets border width for right.
func (_ddfa *border )SetWidthRight (bw float64 ){_ddfa ._dggc =bw };func _bacfg (_cbfg TextStyle )*List {return &List {_cacc :TextChunk {Text :"\u2022\u0020",Style :_cbfg },_eeccg :0,_gcbf :true ,_egbg :PositionRelative ,_edga :_cbfg };};

// SetAngle sets the rotation angle of the text.
func (_adaae *StyledParagraph )SetAngle (angle float64 ){_adaae ._cbace =angle };func _fdaf (_bcaeb *templateProcessor ,_fbgd *templateNode )(interface{},error ){return _bcaeb .parseDivision (_fbgd );};

// SetMarkedContentID sets the marked content id for the chart.
func (_badf *Chart )SetMarkedContentID (mcid int64 )*_gd .KDict {_badf ._gcge =&mcid ;_gfbf :=_gd .NewKDictionary ();_gfbf .S =_be .MakeName (_gd .StructureTypeFigure );_gfbf .K =_be .MakeInteger (mcid );return _gfbf ;};

// NewPolyline creates a new polyline.
func (_dad *Creator )NewPolyline (points []_ddb .Point )*Polyline {return _gcee (points )};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);
ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););func (_acebb *StyledParagraph )getTextLineWidth (_bfeg []*TextChunk )float64 {var _egfe float64 ;_fdeae :=len (_bfeg );for _gfbfe ,_bcbf :=range _bfeg {_bdce :=&_bcbf .Style ;
_acdg :=len (_bcbf .Text );for _egedc ,_ggcc :=range _bcbf .Text {if _ggcc =='\u000A'{continue ;};_dggfc ,_cgfc :=_bdce .Font .GetRuneMetrics (_ggcc );if !_cgfc {_ca .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ggcc );
return -1;};_egfe +=_bdce .FontSize *_dggfc .Wx *_bdce .horizontalScale ();if _ggcc !=' '&&(_gfbfe !=_fdeae -1||_egedc !=_acdg -1){_egfe +=_bdce .CharSpacing *1000.0;};};};return _egfe ;};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;func _cegb (_cacf ,_dfaef ,_acgb ,_ecdg float64 )*Line {return &Line {_cbagd :_cacf ,_efeb :_dfaef ,_agbba :_acgb ,_dcga :_ecdg ,_ffga :ColorBlack ,_gbfc :1.0,_adcb :1.0,_cccd :[]int64 {1,1},_fcbba :PositionAbsolute };};

// DrawWithContext draws the Block using the specified drawing context.
func (_dbe *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_daf ,_ ,_ceg :=d .GeneratePageBlocks (ctx );if _ceg !=nil {return _ceg ;};if len (_daf )!=1{return ErrContentNotFit ;};for _ ,_dfd :=range _daf {if _cafa :=_dbe .mergeBlocks (_dfd );
_cafa !=nil {return _cafa ;};};return nil ;};

// SetMarkedContentID sets marked content ID.
func (_egc *border )SetMarkedContentID (id int64 )*_gd .KDict {return nil };

// SetColorBottom sets border color for bottom.
func (_aee *border )SetColorBottom (col Color ){_aee ._bfde =col };func (_ggee *Invoice )drawInformation ()*Table {_dfbb :=_gdcg (2);_gbbb :=append ([][2]*InvoiceCell {_ggee ._eeffg ,_ggee ._cegfg ,_ggee ._fgfe },_ggee ._ebf ...);for _ ,_gfegg :=range _gbbb {_feca ,_agca :=_gfegg [0],_gfegg [1];
if _agca .Value ==""{continue ;};_edcb :=_dfbb .NewCell ();_edcb .SetBackgroundColor (_feca .BackgroundColor );_ggee .setCellBorder (_edcb ,_feca );_afdf :=_aedcd (_feca .TextStyle );_afdf .Append (_feca .Value );_afdf .SetMargins (0,0,2,1);_edcb .SetContent (_afdf );
_edcb =_dfbb .NewCell ();_edcb .SetBackgroundColor (_agca .BackgroundColor );_ggee .setCellBorder (_edcb ,_agca );_afdf =_aedcd (_agca .TextStyle );_afdf .Append (_agca .Value );_afdf .SetMargins (0,0,2,1);_edcb .SetContent (_afdf );};return _dfbb ;};

// SetMarkedContentID sets the marked content ID for the paragraph.
func (_faed *StyledParagraph )SetMarkedContentID (mcid int64 )*_gd .KDict {_faed ._gbdb =&mcid ;_fabc :=_gd .NewKDictionary ();_fabc .S =_be .MakeName ("\u0050");_fabc .K =_be .MakeInteger (mcid );return _fabc ;};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_eecc *Creator )SetOutlineTree (outlineTree *_gd .PdfOutlineTreeNode ){_eecc ._dfac =outlineTree };

// SetFillOpacity sets the fill opacity of the ellipse.
func (_cbbe *Ellipse )SetFillOpacity (opacity float64 ){_cbbe ._baae =opacity };func _ebaa (_faddbe string ,_bfebb bool )string {_cgfb :=_faddbe ;if _cgfb ==""{return "";};_fcacg :=_fbg .Paragraph {};_ ,_fdcfg :=_fcacg .SetString (_faddbe );if _fdcfg !=nil {return _cgfb ;
};_fgbd ,_fdcfg :=_fcacg .Order ();if _fdcfg !=nil {return _cgfb ;};_cbbgb :=_fgbd .NumRuns ();_gaadg :=make ([]string ,_cbbgb );for _ffdff :=0;_ffdff < _fgbd .NumRuns ();_ffdff ++{_ecae :=_fgbd .Run (_ffdff );_bbgfd :=_ecae .String ();if _ecae .Direction ()==_fbg .RightToLeft {_bbgfd =_fbg .ReverseString (_bbgfd );
};if _bfebb {_gaadg [_ffdff ]=_bbgfd ;}else {_gaadg [_cbbgb -1]=_bbgfd ;};_cbbgb --;};if len (_gaadg )!=_fgbd .NumRuns (){return _faddbe ;};_cgfb =_ddf .Join (_gaadg ,"");return _cgfb ;};func _ecdbd (_dgbag *_gd .PdfFont ,_adffe float64 )*fontMetrics {_efff :=&fontMetrics {};
if _dgbag ==nil {_ca .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");return _efff ;};_bddde ,_ccabd :=_dgbag .GetFontDescriptor ();if _ccabd !=nil {_ca .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_ccabd );
return _efff ;};if _efff ._edgacc ,_ccabd =_bddde .GetCapHeight ();_ccabd !=nil {_ca .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_ccabd );
};if int (_efff ._edgacc )<=0{_ca .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_efff ._edgacc =1000;};_efff ._edgacc *=_adffe /1000.0;if _efff ._daeb ,_ccabd =_bddde .GetXHeight ();_ccabd !=nil {_ca .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_ccabd );
};_efff ._daeb *=_adffe /1000.0;if _efff ._gecf ,_ccabd =_bddde .GetAscent ();_ccabd !=nil {_ca .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_ccabd );
};_efff ._gecf *=_adffe /1000.0;if _efff ._gfcgf ,_ccabd =_bddde .GetDescent ();_ccabd !=nil {_ca .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_ccabd );
};_efff ._gfcgf *=_adffe /1000.0;return _efff ;};func _dfdb (_dcdf _fbb .ChartRenderable )*Chart {return &Chart {_bgcd :_dcdf ,_eebg :PositionRelative ,_aabg :Margins {Top :10,Bottom :10}};};

// SetTotal sets the total of the invoice.
func (_edce *Invoice )SetTotal (value string ){_edce ._cecdb [1].Value =value };func (_agbg cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_dfeb :=_agbg ._febg ;return 1-(_agbg ._cgab *(1-_dfeb )+_dfeb ),1-(_agbg ._bfdc *(1-_dfeb )+_dfeb ),1-(_agbg ._fec *(1-_dfeb )+_dfeb );
};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;func (_aag *Chapter )headingNumber ()string {var _bfb string ;if _aag ._dge {if _aag ._gag !=0{_bfb =_fd .Itoa (_aag ._gag )+"\u002e";};if _aag ._bae !=nil {_dgb :=_aag ._bae .headingNumber ();if _dgb !=""{_bfb =_dgb +_bfb ;};};};
return _bfb ;};func _bbdfeg (_ageac *_gd .PdfAnnotationLink )*_gd .PdfAnnotationLink {if _ageac ==nil {return nil ;};_bcbd :=_gd .NewPdfAnnotationLink ();_bcbd .BS =_ageac .BS ;_bcbd .A =_ageac .A ;if _egec ,_aegfe :=_ageac .GetAction ();_aegfe ==nil &&_egec !=nil {_bcbd .SetAction (_egec );
};if _bfab ,_cbbdf :=_ageac .Dest .(*_be .PdfObjectArray );_cbbdf {_bcbd .Dest =_be .MakeArray (_bfab .Elements ()...);};return _bcbd ;};

// SetFillOpacity sets the fill opacity of the rectangle.
func (_geagb *Rectangle )SetFillOpacity (opacity float64 ){_geagb ._aadb =opacity };

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _fde ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_cfeb :=&Creator {};_cfeb ._bee =[]*_gd .PdfPage {};_cfeb ._fafg =map[*_gd .PdfPage ]*Block {};_cfeb ._gaf =map[*_gd .PdfPage ]*pageTransformations {};_cfeb .SetPageSize (PageSizeLetter );
_dfcb :=0.1*_cfeb ._baec ;_cfeb ._gffac .Left =_dfcb ;_cfeb ._gffac .Right =_dfcb ;_cfeb ._gffac .Top =_dfcb ;_cfeb ._gffac .Bottom =_dfcb ;var _ggdc error ;_cfeb ._fbbd ,_ggdc =_gd .NewStandard14Font (_gd .HelveticaName );if _ggdc !=nil {_cfeb ._fbbd =_gd .DefaultFont ();
};_cfeb ._gafc ,_ggdc =_gd .NewStandard14Font (_gd .HelveticaBoldName );if _ggdc !=nil {_cfeb ._fbbd =_gd .DefaultFont ();};_cfeb ._dda =_cfeb .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");
_cfeb .AddOutlines =true ;_cfeb ._eagf =_gd .NewOutline ();_ag .TrackUse (_fde );return _cfeb ;};func (_gdfea *Invoice )generateInformationBlocks (_dceb DrawContext )([]*Block ,DrawContext ,error ){_ebcg :=_aedcd (_gdfea ._bdae );_ebcg .SetMargins (0,0,0,20);
_ebdc :=_gdfea .drawAddress (_gdfea ._afbf );_ebdc =append (_ebdc ,_ebcg );_ebdc =append (_ebdc ,_gdfea .drawAddress (_gdfea ._adbcd )...);_egedg :=_cfgb ();for _ ,_afaee :=range _ebdc {_egedg .Add (_afaee );};_eaaa :=_gdfea .drawInformation ();_ddfd :=_gdcg (2);
_ddfd .SetMargins (0,0,25,0);_dfdf :=_ddfd .NewCell ();_dfdf .SetIndent (0);_dfdf .SetContent (_egedg );_dfdf =_ddfd .NewCell ();_dfdf .SetContent (_eaaa );return _ddfd .GeneratePageBlocks (_dceb );};

// ColorGrayFromHex converts color hex code to gray color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ff -> white.
func ColorGrayFromHex (hexStr string )Color {_fcbb :=grayColor {};if (len (hexStr )!=2&&len (hexStr )!=3)||hexStr [0]!='#'{_ca .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcbb ;
};var _dfae int ;if len (hexStr )==2{var _bfdd int ;_cdec ,_abbc :=_f .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078",&_bfdd );if _abbc !=nil {_ca .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_abbc );
return _fcbb ;};if _cdec !=1{_ca .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcbb ;};_dfae =_bfdd *16+_bfdd ;}else {_gedf ,_bba :=_f .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078",&_dfae );
if _bba !=nil {_ca .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcbb ;};if _gedf !=1{_ca .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_gedf );
return _fcbb ;};};_fcbb ._ddcc =float64 (_dfae )/255.0;return _fcbb ;};

// SetFillOpacity sets the fill opacity.
func (_bgccg *Polygon )SetFillOpacity (opacity float64 ){_bgccg ._cbfb =opacity };func (_cfdcb *templateProcessor )run ()error {_ddfff :=_b .NewDecoder (_cc .NewReader (_cfdcb ._fagcac ));var _aegag *templateNode ;for {_abaad ,_dggef :=_ddfff .Token ();
if _dggef !=nil {if _dggef ==_cb .EOF {return nil ;};return _dggef ;};if _abaad ==nil {break ;};_dbfae ,_degb :=_abfae (_ddfff );_cfbb :=_ddfff .InputOffset ();switch _bbed :=_abaad .(type ){case _b .StartElement :_ca .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_bbed .Name .Local );
_febf ,_dacb :=_dfbbf [_bbed .Name .Local ];if !_dacb {if _cfdcb ._cabb ==""{if _dbfae !=0{_ca .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_bbed .Name .Local ,_dbfae ,_degb );
}else {_ca .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_bbed .Name .Local ,_cfbb );
};}else {if _dbfae !=0{_ca .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_bbed .Name .Local ,_cfdcb ._cabb ,_dbfae ,_degb );
}else {_ca .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_bbed .Name .Local ,_cfdcb ._cabb ,_cfbb );
};};continue ;};_aegag =&templateNode {_eccfd :_bbed ,_ddbbd :_aegag ,_gbdd :_dbfae ,_ggcca :_degb ,_afdda :_cfbb };if _cccgb :=_febf ._bdafc ;_cccgb !=nil {_aegag ._fdfd ,_dggef =_cccgb (_cfdcb ,_aegag );if _dggef !=nil {return _dggef ;};};case _b .EndElement :_ca .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_bbed .Name .Local );
if _aegag !=nil {if _aegag ._fdfd !=nil {if _badce :=_cfdcb .renderNode (_aegag );_badce !=nil {return _badce ;};};_aegag =_aegag ._ddbbd ;};case _b .CharData :if _aegag !=nil &&_aegag ._fdfd !=nil {if _feabf :=_cfdcb .addNodeText (_aegag ,string (_bbed ));
_feabf !=nil {return _feabf ;};};case _b .Comment :_ca .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_bbed ));
};};return nil ;};func (_afbee *LinearShading )shadingModel ()*_gd .PdfShadingType2 {_fgfb :=_ddb .NewPoint (_afbee ._ddfb .Llx +_afbee ._ddfb .Width ()/2,_afbee ._ddfb .Lly +_afbee ._ddfb .Height ()/2);_bceb :=_ddb .NewPoint (_afbee ._ddfb .Llx ,_afbee ._ddfb .Lly +_afbee ._ddfb .Height ()/2).Add (-_fgfb .X ,-_fgfb .Y ).Rotate (_afbee ._cfebd ).Add (_fgfb .X ,_fgfb .Y );
_bceb =_ddb .NewPoint (_ff .Max (_ff .Min (_bceb .X ,_afbee ._ddfb .Urx ),_afbee ._ddfb .Llx ),_ff .Max (_ff .Min (_bceb .Y ,_afbee ._ddfb .Ury ),_afbee ._ddfb .Lly ));_fecf :=_ddb .NewPoint (_afbee ._ddfb .Urx ,_afbee ._ddfb .Lly +_afbee ._ddfb .Height ()/2).Add (-_fgfb .X ,-_fgfb .Y ).Rotate (_afbee ._cfebd ).Add (_fgfb .X ,_fgfb .Y );
_fecf =_ddb .NewPoint (_ff .Min (_ff .Max (_fecf .X ,_afbee ._ddfb .Llx ),_afbee ._ddfb .Urx ),_ff .Min (_ff .Max (_fecf .Y ,_afbee ._ddfb .Lly ),_afbee ._ddfb .Ury ));_ddac :=_gd .NewPdfShadingType2 ();_ddac .PdfShading .ShadingType =_be .MakeInteger (2);
_ddac .PdfShading .ColorSpace =_gd .NewPdfColorspaceDeviceRGB ();_ddac .PdfShading .AntiAlias =_be .MakeBool (_afbee ._faee ._fdda );_ddac .Coords =_be .MakeArrayFromFloats ([]float64 {_bceb .X ,_bceb .Y ,_fecf .X ,_fecf .Y });_ddac .Extend =_be .MakeArray (_be .MakeBool (_afbee ._faee ._gecd [0]),_be .MakeBool (_afbee ._faee ._gecd [1]));
_ddac .Function =_afbee ._faee .generatePdfFunctions ();return _ddac ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_bea *Block )ScaleToWidth (w float64 ){_ecc :=w /_bea ._de ;_bea .Scale (_ecc ,_ecc )};func (_cbdd *templateProcessor )parseChart (_agdcd *templateNode )(interface{},error ){var _cgdfc string ;for _ ,_efag :=range _agdcd ._eccfd .Attr {_ddecg :=_efag .Value ;
switch _bbcfgf :=_efag .Name .Local ;_bbcfgf {case "\u0073\u0072\u0063":_cgdfc =_ddecg ;};};if _cgdfc ==""{_cbdd .nodeLogError (_agdcd ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_fababg ;};_ggcf ,_dage :=_cbdd ._agabg .ChartMap [_cgdfc ];if !_dage {_cbdd .nodeLogError (_agdcd ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_cgdfc );
return nil ,_fababg ;};_ggdac :=NewChart (_ggcf );for _ ,_fgbc :=range _agdcd ._eccfd .Attr {_cbagdc :=_fgbc .Value ;switch _bgea :=_fgbc .Name .Local ;_bgea {case "\u0078":_ggdac .SetPos (_cbdd .parseFloatAttr (_bgea ,_cbagdc ),_ggdac ._badb );case "\u0079":_ggdac .SetPos (_ggdac ._cfca ,_cbdd .parseFloatAttr (_bgea ,_cbagdc ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_caad :=_cbdd .parseMarginAttr (_bgea ,_cbagdc );_ggdac .SetMargins (_caad .Left ,_caad .Right ,_caad .Top ,_caad .Bottom );case "\u0077\u0069\u0064t\u0068":_ggdac ._bgcd .SetWidth (int (_cbdd .parseFloatAttr (_bgea ,_cbagdc )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_ggdac ._bgcd .SetHeight (int (_cbdd .parseFloatAttr (_bgea ,_cbagdc )));case "\u0073\u0072\u0063":break ;default:_cbdd .nodeLogDebug (_agdcd ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_bgea );
};};return _ggdac ,nil ;};

// SetOpacity sets opacity for Image.
func (_dgggf *Image )SetOpacity (opacity float64 ){_dgggf ._fgec =opacity };

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_cgbd *List )Marker ()*TextChunk {return &_cgbd ._cacc };

// SetMarkedContentID sets marked content ID.
func (_egga *CurvePolygon )SetMarkedContentID (mcid int64 )*_gd .KDict {_egga ._acgc =&mcid ;_eggg :=_gd .NewKDictionary ();_eggg .S =_be .MakeName (_gd .StructureTypeFigure );_eggg .K =_be .MakeInteger (mcid );return _eggg ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_cfbd *Invoice )InfoLines ()[][2]*InvoiceCell {_fagca :=[][2]*InvoiceCell {_cfbd ._eeffg ,_cfbd ._cegfg ,_cfbd ._fgfe };return append (_fagca ,_cfbd ._ebf ...);};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_fg *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fg ._bc .Left ,_fg ._bc .Right ,_fg ._bc .Top ,_fg ._bc .Bottom ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_dfeg *Image )SetWidth (w float64 ){_dfeg ._dcbe =w };

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_ceege Color ;_aecgdc _ddb .LineStyle ;_bddcf CellBorderStyle ;_edgac Color ;_debdc float64 ;_dgag CellBorderStyle ;_daea Color ;_acdc float64 ;_deef CellBorderStyle ;_cada Color ;_gecc float64 ;_gcccg CellBorderStyle ;_agcef Color ;
_efec float64 ;_fgcga ,_gggbbd int ;_edegf int ;_ffebf int ;_bdea VectorDrawable ;_bebbe CellHorizontalAlignment ;_bdcca CellVerticalAlignment ;_adeb float64 ;_gabb *Table ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_bdcf *Invoice )SetBuyerAddress (address *InvoiceAddress ){_bdcf ._adbcd =address };func _addgg ()*PageBreak {return &PageBreak {}};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_ffcb *RadialShading )SetAntiAlias (enable bool ){_ffcb ._ffcg .SetAntiAlias (enable )};func (_dbab *Invoice )generateNoteBlocks (_cbff DrawContext )([]*Block ,DrawContext ,error ){_ggea :=_cfgb ();_dggag :=append ([][2]string {_dbab ._cdbg ,_dbab ._acae },_dbab ._dbef ...);
for _ ,_beab :=range _dggag {if _beab [1]!=""{_egdg :=_dbab .drawSection (_beab [0],_beab [1]);for _ ,_adcd :=range _egdg {_ggea .Add (_adcd );};_cbdf :=_aedcd (_dbab ._bdae );_cbdf .SetMargins (0,0,10,0);_ggea .Add (_cbdf );};};return _ggea .GeneratePageBlocks (_cbff );
};func (_cbecf *templateProcessor )parseFloatAttr (_dccea ,_dadc string )float64 {_ca .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_dccea ,_dadc );
_cggcf ,_ :=_fd .ParseFloat (_dadc ,64);return _cggcf ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ggbf *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aggb :=ctx ;_eecd ,ctx ,_ccfga :=_ggbf ._gfbgc .GeneratePageBlocks (ctx );if _ccfga !=nil {return _eecd ,ctx ,_ccfga ;};for _ ,_facgd :=range _ggbf ._gfcc {_cabd :=_facgd ._bfabf ;
if !_ggbf ._daded {_facgd ._bfabf =0;};_ecfd ,_fgcgag ,_acee :=_facgd .GeneratePageBlocks (ctx );_facgd ._bfabf =_cabd ;if _acee !=nil {return _eecd ,ctx ,_acee ;};if len (_ecfd )< 1{continue ;};_eecd [len (_eecd )-1].mergeBlocks (_ecfd [0]);_eecd =append (_eecd ,_ecfd [1:]...);
ctx =_fgcgag ;};if _ggbf ._egade .IsRelative (){ctx .X =_aggb .X ;};if _ggbf ._egade .IsAbsolute (){return _eecd ,_aggb ,nil ;};return _eecd ,ctx ,nil ;};

// SetStyleRight sets border style for right side.
func (_cda *border )SetStyleRight (style CellBorderStyle ){_cda ._cbgf =style };

// NewList creates a new list.
func (_dfg *Creator )NewList ()*List {return _bacfg (_dfg .NewTextStyle ())};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_egbb *Creator )NewStyledParagraph ()*StyledParagraph {return _aedcd (_egbb .NewTextStyle ())};

// SetBorderWidth sets the border width.
func (_fdcb *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_fdcb ._bgdab .BorderWidth =borderWidth ;};

// BorderColor returns the border color of the ellipse.
func (_gacb *Ellipse )BorderColor ()Color {return _gacb ._bfgf };func _gaea (_bgddb *Block ,_eaee _gd .PdfColor ,_bffbe Color ,_fefcc func ()Rectangle )error {switch _beea :=_eaee .(type ){case *_gd .PdfColorPatternType2 :_bfeag ,_efcec :=_bffbe .(*LinearShading );
if !_efcec {return _f .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_bega :=_fefcc ();_bfeag .SetBoundingBox (_bega ._fdeb ,_bega ._fefcd ,_bega ._dacdg ,_bega ._ddccd );
_fdgde ,_cbfff :=_bfeag .AddPatternResource (_bgddb );if _cbfff !=nil {return _f .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_cbfff );
};_beea .PatternName =_fdgde ;case *_gd .PdfColorPatternType3 :_ecfee ,_efba :=_bffbe .(*RadialShading );if !_efba {return _f .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_agafc :=_fefcc ();_ecfee .SetBoundingBox (_agafc ._fdeb ,_agafc ._fefcd ,_agafc ._dacdg ,_agafc ._ddccd );_gdega ,_bdaf :=_ecfee .AddPatternResource (_bgddb );if _bdaf !=nil {return _f .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_bdaf );
};_beea .PatternName =_gdega ;};return nil ;};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_ebb *Division )Width ()float64 {return 0};func _cgcff (_dcgbd string ,_dgggb ,_ggdbe TextStyle )*TOC {_efeca :=_ggdbe ;_efeca .FontSize =14;_beeb :=_aedcd (_efeca );_beeb .SetEnableWrap (true );_beeb .SetTextAlignment (TextAlignmentLeft );_beeb .SetMargins (0,0,0,5);
_faec :=_beeb .Append (_dcgbd );_faec .Style =_efeca ;return &TOC {_gfbgc :_beeb ,_gfcc :[]*TOCLine {},_defeaa :_dgggb ,_eebgb :_dgggb ,_daffbe :_dgggb ,_ccffd :_dgggb ,_gffbbe :"\u002e",_dddcf :10,_caada :Margins {0,0,2,2},_egade :PositionRelative ,_cdef :_dgggb ,_daded :true };
};func _fac (_bgbb Color )_gd .PdfColor {if _bgbb ==nil {_bgbb =ColorBlack ;};switch _bgda :=_bgbb .(type ){case grayColor :return _gd .NewPdfColorDeviceGray (_bgda ._ddcc );case cmykColor :return _gd .NewPdfColorDeviceCMYK (_bgda ._cgab ,_bgda ._bfdc ,_bgda ._fec ,_bgda ._febg );
case *LinearShading :return _gd .NewPdfColorPatternType2 ();case *RadialShading :return _gd .NewPdfColorPatternType3 ();};return _gd .NewPdfColorDeviceRGB (_bgbb .ToRGB ());};func (_aafg *Line )computeCoords (_aaea DrawContext )(_dabbc ,_fdccd ,_ccd ,_beggf float64 ){_dabbc =_aaea .X ;
_ccd =_dabbc +_aafg ._agbba -_aafg ._cbagd ;_dacg :=_aafg ._adcb ;if _aafg ._cbagd ==_aafg ._agbba {_dacg /=2;};if _aafg ._efeb < _aafg ._dcga {_fdccd =_aaea .PageHeight -_aaea .Y -_dacg ;_beggf =_fdccd -_aafg ._dcga +_aafg ._efeb ;}else {_beggf =_aaea .PageHeight -_aaea .Y -_dacg ;
_fdccd =_beggf -_aafg ._efeb +_aafg ._dcga ;};switch _aafg ._aedgf {case FitModeFillWidth :_ccd =_dabbc +_aaea .Width ;};return _dabbc ,_fdccd ,_ccd ,_beggf ;};func (_egae *List )markerWidth ()float64 {var _cbbc float64 ;for _ ,_dfdbb :=range _egae ._fadf {_gged :=_aedcd (_egae ._edga );
_gged .SetEnableWrap (false );_gged .SetTextAlignment (TextAlignmentRight );_gged .Append (_dfdbb ._gdeca .Text ).Style =_dfdbb ._gdeca .Style ;_dfdbf :=_gged .getTextWidth ()/1000.0;if _cbbc < _dfdbf {_cbbc =_dfdbf ;};};return _cbbc ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_bgfag *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_bdfc []*Block ;_abac bool ;_fdae error ;_dag =_bgfag ._fbfc .IsRelative ();_aeega =_bgfag ._fceg .Top ;);if _dag &&!_bgfag ._adbb &&!_bgfag ._dccc {_bdbf :=_bgfag .ctxHeight (ctx .Width );
if _bdbf > ctx .Height -_bgfag ._fceg .Top &&_bdbf <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _bdfc ,ctx ,_fdae =_addgg ().GeneratePageBlocks (ctx );_fdae !=nil {return nil ,ctx ,_fdae ;};_abac =true ;_aeega =0;};};_eccga :=ctx ;_fgbg :=ctx ;
if _dag {ctx .X +=_bgfag ._fceg .Left ;ctx .Y +=_aeega ;ctx .Width -=_bgfag ._fceg .Left +_bgfag ._fceg .Right ;ctx .Height -=_aeega ;_fgbg =ctx ;ctx .X +=_bgfag ._dcfb .Left ;ctx .Y +=_bgfag ._dcfb .Top ;ctx .Width -=_bgfag ._dcfb .Left +_bgfag ._dcfb .Right ;
ctx .Height -=_bgfag ._dcfb .Top ;ctx .Margins .Top +=_bgfag ._dcfb .Top ;ctx .Margins .Bottom +=_bgfag ._dcfb .Bottom ;ctx .Margins .Left +=_bgfag ._fceg .Left +_bgfag ._dcfb .Left ;ctx .Margins .Right +=_bgfag ._fceg .Right +_bgfag ._dcfb .Right ;};ctx .Inline =_bgfag ._dccc ;
_eccf :=ctx ;_bbcb :=ctx ;var _aefb float64 ;for _ ,_afbd :=range _bgfag ._cggf {if ctx .Inline {if (ctx .X -_eccf .X )+_afbd .Width ()<=ctx .Width {ctx .Y =_bbcb .Y ;ctx .Height =_bbcb .Height ;}else {ctx .X =_eccf .X ;ctx .Width =_eccf .Width ;_bbcb .Y +=_aefb ;
_bbcb .Height -=_aefb ;_aefb =0;};};_bbec ,_dccb ,_fccc :=_afbd .GeneratePageBlocks (ctx );if _fccc !=nil {_ca .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_fccc );
return nil ,ctx ,_fccc ;};if len (_bbec )< 1{continue ;};if len (_bdfc )> 0{_bdfc [len (_bdfc )-1].mergeBlocks (_bbec [0]);_bdfc =append (_bdfc ,_bbec [1:]...);}else {if _eebc :=_bbec [0]._ge ;_eebc ==nil ||len (*_eebc )==0{_abac =true ;};_bdfc =append (_bdfc ,_bbec [0:]...);
};if ctx .Inline {if ctx .Page !=_dccb .Page {_eccf .Y =ctx .Margins .Top ;_eccf .Height =ctx .PageHeight -ctx .Margins .Top ;_bbcb .Y =_eccf .Y ;_bbcb .Height =_eccf .Height ;_aefb =_dccb .Height -_eccf .Height ;}else {if _gbfg :=ctx .Height -_dccb .Height ;
_gbfg > _aefb {_aefb =_gbfg ;};};}else {_dccb .X =ctx .X ;};ctx =_dccb ;};if len (_bgfag ._cggf )==0{_cab :=NewBlock (ctx .Width ,0);_bdfc =append (_bdfc ,_cab );};ctx .Inline =_eccga .Inline ;ctx .Margins =_eccga .Margins ;if _dag {ctx .X =_eccga .X ;
ctx .Width =_eccga .Width ;ctx .Y +=_bgfag ._dcfb .Bottom ;ctx .Height -=_bgfag ._dcfb .Bottom ;};if _bgfag ._bacfc !=nil {_bdfc ,_fdae =_bgfag .drawBackground (_bdfc ,_fgbg ,ctx ,_abac );if _fdae !=nil {return nil ,ctx ,_fdae ;};};if _bgfag ._fbfc .IsAbsolute (){return _bdfc ,_eccga ,nil ;
};ctx .Y +=_bgfag ._fceg .Bottom ;ctx .Height -=_bgfag ._fceg .Bottom ;return _bdfc ,ctx ,nil ;};

// SetMarkedContentID sets the marked content ID for the chapter.
func (_fda *Chapter )SetMarkedContentID (id int64 )*_gd .KDict {return nil };

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_aedg *Creator )NewImageFromGoImage (goimg _dd .Image )(*Image ,error ){return _gdbcg (goimg )};func (_bbag *List )ctxHeight (_bebe float64 )float64 {_bebe -=_bbag ._eeccg ;var _gbgfg float64 ;for _ ,_bbfb :=range _bbag ._fadf {_gbgfg +=_bbfb .ctxHeight (_bebe );
};return _gbgfg ;};

// Append adds a new text chunk to the paragraph.
func (_dged *StyledParagraph )Append (text string )*TextChunk {_cgbdc :=NewTextChunk (text ,_dged ._cggd );return _dged .appendChunk (_cgbdc );};

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_fede *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_fede ._cccd =dashArray ;_fede ._aaed =dashPhase ;};

// NewImageFromFile creates an Image from a file.
func (_gac *Creator )NewImageFromFile (path string )(*Image ,error ){return _dgc (path )};

// List represents a list of items.
// The representation of a list item is as follows:
//
//	[marker] [content]
//
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_fadf []*listItem ;_edgdc Margins ;_cacc TextChunk ;_eeccg float64 ;_gcbf bool ;_egbg Positioning ;_edga TextStyle ;};

// Width returns the width of the ellipse.
func (_acde *Ellipse )Width ()float64 {return _acde ._gbea };func _dfcd ()*listItem {return &listItem {}};

// SetMarkedContentID sets marked content ID.
func (_baaf *Invoice )SetMarkedContentID (id int64 )*_gd .KDict {return nil };

// Width returns the width of the Paragraph.
func (_gecb *Paragraph )Width ()float64 {if _gecb ._abaa &&int (_gecb ._gba )> 0{return _gecb ._gba ;};return _gecb .getTextWidth ()/1000.0;};func (_gffad grayColor )ToRGB ()(float64 ,float64 ,float64 ){return _gffad ._ddcc ,_gffad ._ddcc ,_gffad ._ddcc ;
};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// Height returns the height of the ellipse.
func (_gbbg *Ellipse )Height ()float64 {return _gbbg ._fgbb };

// SetHeight sets the Image's document height to specified h.
func (_cegde *Image )SetHeight (h float64 ){_cegde ._fae =h };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_efc *Chapter )SetIncludeInTOC (includeInTOC bool ){_efc ._addc =includeInTOC };func _ccac (_dgae VectorDrawable ,_ceag float64 )float64 {switch _ecd :=_dgae .(type ){case *Paragraph :if _ecd ._abaa {_ecd .SetWidth (_ceag -_ecd ._cgacg .Left -_ecd ._cgacg .Right );
};return _ecd .Height ()+_ecd ._cgacg .Top +_ecd ._cgacg .Bottom ;case *StyledParagraph :if _ecd ._egbgc {_ecd .SetWidth (_ceag -_ecd ._affa .Left -_ecd ._affa .Right );};return _ecd .Height ()+_ecd ._affa .Top +_ecd ._affa .Bottom ;case *Image :_ecd .applyFitMode (_ceag );
return _ecd .Height ()+_ecd ._fcad .Top +_ecd ._fcad .Bottom ;case *Rectangle :_ecd .applyFitMode (_ceag );return _ecd .Height ()+_ecd ._ddfgb .Top +_ecd ._ddfgb .Bottom +_ecd ._bcdgg ;case *Ellipse :_ecd .applyFitMode (_ceag );return _ecd .Height ()+_ecd ._dffg .Top +_ecd ._dffg .Bottom ;
case *Division :return _ecd .ctxHeight (_ceag )+_ecd ._fceg .Top +_ecd ._fceg .Bottom +_ecd ._dcfb .Top +_ecd ._dcfb .Bottom ;case *Table :_ecd .updateRowHeights (_ceag -_ecd ._ccecg .Left -_ecd ._ccecg .Right );return _ecd .Height ()+_ecd ._ccecg .Top +_ecd ._ccecg .Bottom ;
case *List :return _ecd .ctxHeight (_ceag )+_ecd ._edgdc .Top +_ecd ._edgdc .Bottom ;case marginDrawable :_ ,_ ,_cbba ,_abgd :=_ecd .GetMargins ();return _ecd .Height ()+_cbba +_abgd ;default:return _ecd .Height ();};};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_eded float64 ;_dbcd float64 ;_efdba float64 ;_bacf float64 ;_ffea float64 ;_agefe float64 ;_gffeeb Color ;_bdag float64 ;_dffa *int64 ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_gbd *Creator )NewTextStyle ()TextStyle {return _dbdbf (_gbd ._fbbd )};

// SetWidth sets the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_debgb *Paragraph )SetWidth (width float64 ){_debgb ._gba =width ;_debgb .wrapText ()};

// SetBorderOpacity sets the border opacity of the rectangle.
func (_dbdd *Rectangle )SetBorderOpacity (opacity float64 ){_dbdd ._ggge =opacity };func (_gebc *Invoice )generateTotalBlocks (_gdgeg DrawContext )([]*Block ,DrawContext ,error ){_cdfab :=_gdcg (4);_cdfab .SetMargins (0,0,10,10);_bfee :=[][2]*InvoiceCell {_gebc ._ffce };
_bfee =append (_bfee ,_gebc ._gfgd ...);_bfee =append (_bfee ,_gebc ._cecdb );for _ ,_cbee :=range _bfee {_ecad ,_gdeb :=_cbee [0],_cbee [1];if _gdeb .Value ==""{continue ;};_cdfab .SkipCells (2);_eefed :=_cdfab .NewCell ();_eefed .SetBackgroundColor (_ecad .BackgroundColor );
_eefed .SetHorizontalAlignment (_gdeb .Alignment );_gebc .setCellBorder (_eefed ,_ecad );_ggbba :=_aedcd (_ecad .TextStyle );_ggbba .SetMargins (0,0,2,1);_ggbba .Append (_ecad .Value );_eefed .SetContent (_ggbba );_eefed =_cdfab .NewCell ();_eefed .SetBackgroundColor (_gdeb .BackgroundColor );
_eefed .SetHorizontalAlignment (_gdeb .Alignment );_gebc .setCellBorder (_eefed ,_ecad );_ggbba =_aedcd (_gdeb .TextStyle );_ggbba .SetMargins (0,0,2,1);_ggbba .Append (_gdeb .Value );_eefed .SetContent (_ggbba );};return _cdfab .GeneratePageBlocks (_gdgeg );
};

// NewFilledCurve returns a instance of filled curve.
func (_bbbg *Creator )NewFilledCurve ()*FilledCurve {return _ggagfc ()};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_adca *Division )Height ()float64 {var _bfff float64 ;for _ ,_caaa :=range _adca ._cggf {switch _bcf :=_caaa .(type ){case marginDrawable :_ ,_ ,_aafd ,_dddc :=_bcf .GetMargins ();_bfff +=_bcf .Height ()+_aafd +_dddc ;default:_bfff +=_bcf .Height ();
};};return _bfff ;};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_afae *Invoice )SetNoteHeadingStyle (style TextStyle ){_afae ._begb =style };func _fcde (_dedeg *templateProcessor ,_ddcfe *templateNode )(interface{},error ){return _dedeg .parseLine (_ddcfe );};

// Width returns the cell's width based on the input draw context.
func (_ebgbf *TableCell )Width (ctx DrawContext )float64 {_eddfe :=float64 (0.0);for _gdce :=0;_gdce < _ebgbf ._ffebf ;_gdce ++{_eddfe +=_ebgbf ._gabb ._faae [_ebgbf ._gggbbd +_gdce -1];};_fddge :=ctx .Width *_eddfe ;return _fddge ;};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_egad *Ellipse )SetFitMode (fitMode FitMode ){_egad ._fdbc =fitMode };const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;AnchorTopLeft ;AnchorTopRight ;AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);

// NewTOCLine creates a new table of contents line with the default style.
func (_cecd *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _eefca (number ,title ,page ,level ,_cecd .NewTextStyle ());};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;func (_gcad *TextStyle )horizontalScale ()float64 {return _gcad .HorizontalScaling /100};

// AddHighlightedText adds a new highlighted text to the paragraph.
func (_gagca *StyledParagraph )AddHighlightedText (text string ,color Color ,alpha float64 )*TextChunk {_cafe :=NewTextChunk (text ,_gagca ._cggd );_cafe .Highlight (color ,alpha );return _gagca .appendChunk (_cafe );};

// SetFontSize sets the font size in document units (points).
func (_gadd *Paragraph )SetFontSize (fontSize float64 ){_gadd ._geac =fontSize };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_beba *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_aaccd :=NewTextChunk (text ,_beba ._debd );_aaccd .AddAnnotation (_egded (page -1,x ,y ,zoom ));return _beba .appendChunk (_aaccd );};func _bdcfa (_feae string )bool {_bfec :=func (_fdfa rune )bool {return _fdfa =='\u000A'};
_dbdac :=_ddf .TrimFunc (_feae ,_bfec );_fbad :=_fbg .Paragraph {};_ ,_gggff :=_fbad .SetString (_dbdac );if _gggff !=nil {return true ;};_cbage ,_gggff :=_fbad .Order ();if _gggff !=nil {return true ;};if _cbage .NumRuns ()< 1{return true ;};return _fbad .IsLeftToRight ();
};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_ddcce *Line )SetMargins (left ,right ,top ,bottom float64 ){_ddcce ._cbeb .Left =left ;_ddcce ._cbeb .Right =right ;_ddcce ._cbeb .Top =top ;_ddcce ._cbeb .Bottom =bottom ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_fbaa *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fbaa ._aabg .Left ,_fbaa ._aabg .Right ,_fbaa ._aabg .Top ,_fbaa ._aabg .Bottom ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_aaae *StyledParagraph )Insert (index uint ,text string )*TextChunk {_fegcg :=uint (len (_aaae ._bcbc ));if index > _fegcg {index =_fegcg ;};_fbgcg :=NewTextChunk (text ,_aaae ._cggd );_aaae ._bcbc =append (_aaae ._bcbc [:index ],append ([]*TextChunk {_fbgcg },_aaae ._bcbc [index :]...)...);
_aaae .wrapText ();return _fbgcg ;};func (_acaa *StyledParagraph )wrapText ()error {return _acaa .wrapChunks (true )};

// SetLazy sets the lazy mode for the image.
func (_cgdef *Image )SetLazy (lazy bool ){_cgdef ._bfbd =lazy };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_adbgc *TOCLine )SetLink (page int64 ,x ,y float64 ){_adbgc ._bfcae =x ;_adbgc ._geaed =y ;_adbgc ._bfabf =page ;_egdde :=_adbgc ._ecfeg ._debd .Color ;_adbgc .Number .Style .Color =_egdde ;_adbgc .Title .Style .Color =_egdde ;_adbgc .Separator .Style .Color =_egdde ;
_adbgc .Page .Style .Color =_egdde ;};

// FitMode returns the fit mode of the ellipse.
func (_fged *Ellipse )FitMode ()FitMode {return _fged ._fdbc };

// Angle returns the block rotation angle in degrees.
func (_ee *Block )Angle ()float64 {return _ee ._ac };func (_cdbce *templateProcessor )parseColor (_eddg string )Color {if _eddg ==""{return nil ;};_cbfbg ,_bddbg :=_cdbce ._agabg .ColorMap [_eddg ];if _bddbg {return _cbfbg ;};if _eddg [0]=='#'{return ColorRGBFromHex (_eddg );
};return nil ;};

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _dgbe (path )};

// SetSubtotal sets the subtotal of the invoice.
func (_dggf *Invoice )SetSubtotal (value string ){_dggf ._ffce [1].Value =value };

// SetFillColor sets the fill color.
func (_gcbd *PolyBezierCurve )SetFillColor (color Color ){_gcbd ._gfde =color ;_gcbd ._bgdab .FillColor =_fac (color );};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_aeef *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aeeed :=_aeef ;if _aeef ._ffeag {_aeeed =_aeef .clone ();};return _cbgg (_aeeed ,ctx );};func (_agbff *templateProcessor )parseFontAttr (_bdacb ,_aeacg string )*_gd .PdfFont {_ca .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_bdacb ,_aeacg );
_gcde :=_agbff .creator ._fbbd ;if _aeacg ==""{return _gcde ;};_afefg :=_ddf .Split (_aeacg ,"\u002c");for _ ,_ddece :=range _afefg {_ddece =_ddf .TrimSpace (_ddece );if _ddece ==""{continue ;};_cfcd ,_cgbae :=_agbff ._agabg .FontMap [_aeacg ];if _cgbae {return _cfcd ;
};_aafgg ,_cgbae :=map[string ]_gd .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_gd .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_gd .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_gd .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_gd .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_gd .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_gd .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_gd .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_gd .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_gd .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_gd .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_gd .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_gd .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_gd .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_gd .TimesBoldItalicName }[_aeacg ];
if _cgbae {if _deafa ,_cbca :=_gd .NewStandard14Font (_aafgg );_cbca ==nil {return _deafa ;};};if _ceed :=_agbff .parseAttrPropList (_ddece );len (_ceed )> 0{if _cccca ,_caafb :=_ceed ["\u0070\u0061\u0074\u0068"];_caafb {_aabda :=_gd .NewPdfFontFromTTFFile ;
if _cfcac ,_dgcag :=_ceed ["\u0074\u0079\u0070\u0065"];_dgcag &&_cfcac =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_aabda =_gd .NewCompositePdfFontFromTTFFile ;};if _afcbc ,_cgdca :=_aabda (_cccca );_cgdca !=nil {_ca .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_cccca ,_cgdca );
}else {return _afcbc ;};};};};return _gcde ;};

// SetPos sets absolute positioning with specified coordinates.
func (_dfcge *StyledParagraph )SetPos (x ,y float64 ){_dfcge ._abab =PositionAbsolute ;_dfcge ._cabcd =x ;_dfcge ._ccde =y ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_afcb *Creator )CreateTableOfContents (genTOCFunc func (_ceba *TOC )error ){_afcb ._bef =genTOCFunc ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_gccg *TOC )SetLineStyle (style TextStyle ){_gccg .SetLineNumberStyle (style );_gccg .SetLineTitleStyle (style );_gccg .SetLineSeparatorStyle (style );_gccg .SetLinePageStyle (style );};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// MultiFont represents an encoder that accepts multiple fonts and selects the correct font for encoding.
MultiFont *_gd .MultipleFontEncoder ;

// Font represents the font the text will use.
Font *_gd .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_dgcg *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _dgcg ._cbagd ,_dgcg ._efeb ,_dgcg ._agbba ,_dgcg ._dcga ;};func _efb (_age string )string {_fba :=_fee .FindAllString (_age ,-1);if len (_fba )==0{_age =_age +"\u0030";}else {_fcea ,_gec :=_fd .Atoi (_fba [len (_fba )-1]);
if _gec !=nil {_ca .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_gec );
_age =_age +"\u0030";}else {_fcea ++;_dbbf :=_ddf .LastIndex (_age ,_fba [len (_fba )-1]);if _dbbf ==-1{_age =_f .Sprintf ("\u0025\u0073\u0025\u0064",_age [:len (_age )-1],_fcea );}else {_age =_age [:_dbbf ]+_fd .Itoa (_fcea );};};};return _age ;};

// Margins returns the margins of the component.
func (_aaaa *Division )Margins ()(_cece ,_bgfgb ,_efaa ,_dcacc float64 ){return _aaaa ._fceg .Left ,_aaaa ._fceg .Right ,_aaaa ._fceg .Top ,_aaaa ._fceg .Bottom ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_gea *Creator )DrawHeader (drawHeaderFunc func (_agfa *Block ,_gffeg HeaderFunctionArgs )){_gea ._eee =drawHeaderFunc ;};func (_eeded *Table )getLastCellFromCol (_ecdcb int )(int ,*TableCell ){for _abbdd :=len (_eeded ._gedg )-1;_abbdd >=0;_abbdd --{if _eeded ._gedg [_abbdd ]._gggbbd ==_ecdcb {return _abbdd ,_eeded ._gedg [_abbdd ];
};};return 0,nil ;};

// NewPageBreak create a new page break.
func (_cbaaf *Creator )NewPageBreak ()*PageBreak {return _addgg ()};

// Invoice represents a configurable invoice template.
type Invoice struct{_bgfbda string ;_afed *Image ;_adbcd *InvoiceAddress ;_afbf *InvoiceAddress ;_gggd string ;_eeffg [2]*InvoiceCell ;_cegfg [2]*InvoiceCell ;_fgfe [2]*InvoiceCell ;_ebf [][2]*InvoiceCell ;_gbbc []*InvoiceCell ;_gdfd [][]*InvoiceCell ;
_ffce [2]*InvoiceCell ;_cecdb [2]*InvoiceCell ;_gfgd [][2]*InvoiceCell ;_cdbg [2]string ;_acae [2]string ;_dbef [][2]string ;_bdae TextStyle ;_ddba TextStyle ;_fcbed TextStyle ;_gdga TextStyle ;_fefc TextStyle ;_degfg TextStyle ;_begb TextStyle ;_ffda InvoiceCellProps ;
_dbbfd InvoiceCellProps ;_ddce InvoiceCellProps ;_aabdc InvoiceCellProps ;_afbg Positioning ;};func (_gcgg *Creator )wrapPageIfNeeded (_caa *_gd .PdfPage )(*_gd .PdfPage ,error ){_cdgf ,_ddgf :=_caa .GetAllContentStreams ();if _ddgf !=nil {return nil ,_ddgf ;
};_gabc :=_eag .NewContentStreamParser (_cdgf );_egag ,_ddgf :=_gabc .Parse ();if _ddgf !=nil {return nil ,_ddgf ;};if !_egag .HasUnclosedQ (){return nil ,nil ;};_egag .WrapIfNeeded ();_ebc ,_ddgf :=_be .MakeStream (_egag .Bytes (),_be .NewFlateEncoder ());
if _ddgf !=nil {return nil ,_ddgf ;};_caa .Contents =_be .MakeArray (_ebc );return _caa ,nil ;};

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_cbagd float64 ;_efeb float64 ;_agbba float64 ;_dcga float64 ;_ffga Color ;_dddcg _ddb .LineStyle ;_gbfc float64 ;_cccd []int64 ;_aaed int64 ;_adcb float64 ;_fcbba Positioning ;_aedgf FitMode ;_cbeb Margins ;_afac *int64 ;};

// Positioning returns the type of positioning the ellipse is set to use.
func (_gbef *Ellipse )Positioning ()Positioning {return _gbef ._gbbf };func (_faaa *listItem )ctxHeight (_abga float64 )float64 {var _dfea float64 ;switch _egac :=_faaa ._cfec .(type ){case *Paragraph :if _egac ._abaa {_egac .SetWidth (_abga -_egac ._cgacg .Horizontal ());
};_dfea =_egac .Height ()+_egac ._cgacg .Vertical ();_dfea +=0.5*_egac ._geac *_egac ._agdbb ;case *StyledParagraph :if _egac ._egbgc {_egac .SetWidth (_abga -_egac ._affa .Horizontal ());};_dfea =_egac .Height ()+_egac ._affa .Vertical ();_dfea +=0.5*_egac .getTextHeight ();
case *List :_defea :=_abga -_faaa ._gdeca .Width ()-_egac ._edgdc .Horizontal ()-_egac ._eeccg ;_dfea =_egac .ctxHeight (_defea )+_egac ._edgdc .Vertical ();case *Image :_dfea =_egac .Height ()+_egac ._fcad .Vertical ();case *Division :_ddfaa :=_abga -_faaa ._gdeca .Width ()-_egac ._fceg .Horizontal ();
_dfea =_egac .ctxHeight (_ddfaa )+_egac ._fceg .Vertical ();case *Table :_egddb :=_abga -_faaa ._gdeca .Width ()-_egac ._ccecg .Horizontal ();_egac .updateRowHeights (_egddb );_dfea =_egac .Height ()+_egac ._ccecg .Vertical ();default:_dfea =_faaa ._cfec .Height ();
};return _dfea ;};

// GeneratePageBlocks draw graphic svg into block.
func (_agbb *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ddab :=ctx ;_fegd :=_agbb ._cdgd .IsRelative ();var _acedc []*Block ;if _fegd {_feffb :=1.0;_ebdea :=_agbb ._agdb .Top ;if _agbb ._dddg .Height > ctx .Height -_agbb ._agdb .Top {_acedc =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _aceb error ;if _ ,ctx ,_aceb =_addgg ().GeneratePageBlocks (ctx );_aceb !=nil {return nil ,ctx ,_aceb ;};_ebdea =0;};ctx .X +=_agbb ._agdb .Left +_feffb ;ctx .Y +=_ebdea ;ctx .Width -=_agbb ._agdb .Left +_agbb ._agdb .Right +2*_feffb ;ctx .Height -=_ebdea ;
}else {ctx .X =_agbb ._eeeb ;ctx .Y =_agbb ._gca ;};_aeaf :=_eag .NewContentCreator ();_aeaf .Translate (0,ctx .PageHeight );_aeaf .Scale (1,-1);_aeaf .Translate (ctx .X ,ctx .Y );_cbed :=_agbb ._dddg .Width /_agbb ._dddg .ViewBox .W ;_fgg :=_agbb ._dddg .Height /_agbb ._dddg .ViewBox .H ;
_aecg :=0.0;_caed :=0.0;if _fegd {_aecg =_agbb ._eeeb -(_agbb ._dddg .ViewBox .X *_ff .Max (_cbed ,_fgg ));_caed =_agbb ._gca -(_agbb ._dddg .ViewBox .Y *_ff .Max (_cbed ,_fgg ));};_adfb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _agbb ._dcfc !=nil {_aeaf .Add_BDC (*_be .MakeName (_gd .StructureTypeFigure ),map[string ]_be .PdfObject {"\u004d\u0043\u0049\u0044":_be .MakeInteger (*_agbb ._dcfc )});
};_agbb ._dddg .ToContentCreator (_aeaf ,_adfb ._fa ,_cbed ,_fgg ,_aecg ,_caed );if _agbb ._dcfc !=nil {_aeaf .Add_EMC ();};if _bbfd :=_adfb .addContentsByString (_aeaf .String ());_bbfd !=nil {return nil ,ctx ,_bbfd ;};if _fegd {_ccgf :=_agbb .Height ()+_agbb ._agdb .Bottom ;
ctx .Y +=_ccgf ;ctx .Height -=_ccgf ;}else {ctx =_ddab ;};_acedc =append (_acedc ,_adfb );return _acedc ,ctx ,nil ;};

// SetMarkedContentID sets the marked content identifier.
func (_aeb *Division )SetMarkedContentID (id int64 )*_gd .KDict {return nil };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};func _efafa (_edba *templateProcessor ,_cgcf *templateNode )(interface{},error ){return _edba .parseList (_cgcf );};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_eebbd *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_dddad :=_aedcd (_eebbd ._edga );_dddad .Append (text );_dfec ,_efda :=_eebbd .Add (_dddad );return _dddad ,_dfec ,_efda ;};

// SetIndent sets the cell's left indent.
func (_aeed *TableCell )SetIndent (indent float64 ){_aeed ._adeb =indent };

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_ddec *Creator )MoveDown (dy float64 ){_ddec ._ecfb .Y +=dy };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//
//	[number] [title]      [separator] [page]
//
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_gfbgc *StyledParagraph ;_gfcc []*TOCLine ;_defeaa TextStyle ;_eebgb TextStyle ;_daffbe TextStyle ;_ccffd TextStyle ;_gffbbe string ;_dddcf float64 ;_caada Margins ;_egade Positioning ;_cdef TextStyle ;_daded bool ;};

// FillColor returns the fill color of the ellipse.
func (_cgabg *Ellipse )FillColor ()Color {return _cgabg ._cgcbc };func (_cggef *templateProcessor )parseRectangle (_fccf *templateNode )(interface{},error ){_dfecf :=_cggef .creator .NewRectangle (0,0,0,0);for _ ,_gcdc :=range _fccf ._eccfd .Attr {_gbag :=_gcdc .Value ;
switch _accdf :=_gcdc .Name .Local ;_accdf {case "\u0078":_dfecf ._fdeb =_cggef .parseFloatAttr (_accdf ,_gbag );case "\u0079":_dfecf ._fefcd =_cggef .parseFloatAttr (_accdf ,_gbag );case "\u0077\u0069\u0064t\u0068":_dfecf .SetWidth (_cggef .parseFloatAttr (_accdf ,_gbag ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_dfecf .SetHeight (_cggef .parseFloatAttr (_accdf ,_gbag ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_dfecf .SetFillColor (_cggef .parseColorAttr (_accdf ,_gbag ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_dfecf .SetFillOpacity (_cggef .parseFloatAttr (_accdf ,_gbag ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_dfecf .SetBorderColor (_cggef .parseColorAttr (_accdf ,_gbag ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_dfecf .SetBorderOpacity (_cggef .parseFloatAttr (_accdf ,_gbag ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_dfecf .SetBorderWidth (_cggef .parseFloatAttr (_accdf ,_gbag ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_eccd ,_acdea ,_ebeb ,_dfbga :=_cggef .parseBorderRadiusAttr (_accdf ,_gbag );
_dfecf .SetBorderRadius (_eccd ,_acdea ,_dfbga ,_ebeb );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_dfecf ._dfegd =_cggef .parseFloatAttr (_accdf ,_gbag );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_dfecf ._afgd =_cggef .parseFloatAttr (_accdf ,_gbag );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_dfecf ._ebddb =_cggef .parseFloatAttr (_accdf ,_gbag );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_dfecf ._fcgc =_cggef .parseFloatAttr (_accdf ,_gbag );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_dfecf .SetPositioning (_cggef .parsePositioningAttr (_accdf ,_gbag ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_dfecf .SetFitMode (_cggef .parseFitModeAttr (_accdf ,_gbag ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_aedeb :=_cggef .parseMarginAttr (_accdf ,_gbag );
_dfecf .SetMargins (_aedeb .Left ,_aedeb .Right ,_aedeb .Top ,_aedeb .Bottom );default:_cggef .nodeLogDebug (_fccf ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_accdf );
};};return _dfecf ,nil ;};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_cbab *Line )SetColor (color Color ){_cbab ._ffga =color };

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_debg *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _debg ._eeffg [0],_debg ._eeffg [1]};

// SetStyleLeft sets border style for left side.
func (_cfg *border )SetStyleLeft (style CellBorderStyle ){_cfg ._fgfc =style };func _efca (_aegd *Block ,_bgaeb *StyledParagraph ,_fcadf [][]*TextChunk ,_gggba DrawContext )(DrawContext ,[][]*TextChunk ,error ){_gddd :=1;_dfba :=_be .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gddd ));
for _aegd ._fa .HasFontByName (_dfba ){_gddd ++;_dfba =_be .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gddd ));};_aagd :=_aegd ._fa .SetFontByName (_dfba ,_bgaeb ._cggd .Font .ToPdfObject ());if _aagd !=nil {return _gggba ,nil ,_aagd ;
};_gddd ++;_efedc :=_dfba ;_cbdbf :=_bgaeb ._cggd .FontSize ;_cadd :=_bgaeb ._abab .IsRelative ();var _gggbf [][]_be .PdfObjectName ;var _affde [][]*TextChunk ;var _ebbgf float64 ;for _cabf ,_fcge :=range _fcadf {var _efbe []_be .PdfObjectName ;var _fafgc float64 ;
if len (_fcge )> 0{_fafgc =_fcge [0].Style .FontSize ;};for _ ,_ead :=range _fcge {_cfcee :=_ead .Style ;if _ead .Text !=""&&_cfcee .FontSize > _fafgc {_fafgc =_cfcee .FontSize ;};if _fafgc > _gggba .PageHeight {return _gggba ,nil ,_fc .New ("\u0050\u0061\u0072\u0061\u0067\u0072a\u0070\u0068\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u006ca\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0070\u0061\u0067\u0065 \u0068e\u0069\u0067\u0068\u0074");
};_dfba =_be .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gddd ));_addaf :=_aegd ._fa .SetFontByName (_dfba ,_cfcee .Font .ToPdfObject ());if _addaf !=nil {return _gggba ,nil ,_addaf ;};_efbe =append (_efbe ,_dfba );_gddd ++;};_fafgc *=_bgaeb ._bcde ;
if _cadd &&_ebbgf +_fafgc > _gggba .Height {_affde =_fcadf [_cabf :];_fcadf =_fcadf [:_cabf ];break ;};_ebbgf +=_fafgc ;_gggbf =append (_gggbf ,_efbe );};_bbcfg ,_dgcd ,_gdccf :=_bgaeb .getLineMetrics (0);_deeb ,_ebaeg :=_bbcfg *_bgaeb ._bcde ,_dgcd *_bgaeb ._bcde ;
if len (_fcadf )==0{return _gggba ,_affde ,nil ;};_ggdae :=_eag .NewContentCreator ();_ggdae .Add_q ();_edac :=_ebaeg ;if _bgaeb ._eeedb ==TextVerticalAlignmentCenter {_edac =_dgcd +(_bbcfg +_gdccf -_dgcd )/2+(_ebaeg -_dgcd )/2;};_dgfe :=_gggba .PageHeight -_gggba .Y -_edac ;
_ggdae .Translate (_gggba .X ,_dgfe );_bbbd :=_dgfe ;if _bgaeb ._cbace !=0{_ggdae .RotateDeg (_bgaeb ._cbace );};if _bgaeb ._fcga ==TextOverflowHidden {_ggdae .Add_re (0,-_ebbgf +_deeb +1,_bgaeb ._cbcb ,_ebbgf ).Add_W ().Add_n ();};_ggdae .Add_BT ();_eebf :=map[string ]_be .PdfObject {};
if _bgaeb ._gbdb !=nil {_eebf ["\u004d\u0043\u0049\u0044"]=_be .MakeInteger (*_bgaeb ._gbdb );};if _bgaeb ._abce !=""{_eebf ["\u004c\u0061\u006e\u0067"]=_be .MakeString (_bgaeb ._abce );};if len (_eebf )> 0{_ggdae .Add_BDC (*_be .MakeName (_gd .StructureTypeParagraph ),_eebf );
};var _cgba []*_ddb .BasicLine ;for _gaed ,_dgee :=range _fcadf {_gced :=_gggba .X ;var _cdbaf float64 ;if len (_dgee )> 0{_cdbaf =_dgee [0].Style .FontSize ;};_bbcfg ,_ ,_gdccf =_bgaeb .getLineMetrics (_gaed );_ebaeg =(_bbcfg +_gdccf );for _ ,_dccbf :=range _dgee {_gaaa :=&_dccbf .Style ;
if _dccbf .Text !=""&&_gaaa .FontSize > _cdbaf {_cdbaf =_gaaa .FontSize ;};if _ebaeg > _cdbaf {_cdbaf =_ebaeg ;};};if _gaed !=0{_ggdae .Add_TD (0,-_cdbaf *_bgaeb ._bcde );_bbbd -=_cdbaf *_bgaeb ._bcde ;};_abaae :=_gaed ==len (_fcadf )-1;var (_ccge float64 ;
_gdbaf float64 ;_afbc *fontMetrics ;_aged float64 ;_bfgfe uint ;);var _gbgfge []float64 ;for _ ,_ffaf :=range _dgee {_gabce :=&_ffaf .Style ;if _gabce .FontSize > _gdbaf {_gdbaf =_gabce .FontSize ;_afbc =_ecdbd (_ffaf .Style .Font ,_gabce .FontSize );};
if _ebaeg > _gdbaf {_gdbaf =_ebaeg ;};_fbfg ,_dcdb :=_gabce .Font .GetRuneMetrics (' ');if _fbfg .Wx ==0&&_gabce .MultiFont !=nil {_fbfg ,_dcdb =_gabce .MultiFont .GetRuneMetrics (' ');_gabce .MultiFont .Reset ();};if !_dcdb {return _gggba ,nil ,_fc .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _daafc uint ;var _effdd float64 ;_gfab :=len (_ffaf .Text );for _fcgbbe ,_gbfe :=range _ffaf .Text {if _gbfe ==' '{_daafc ++;continue ;};if _gbfe =='\u000A'{continue ;};_afaa ,_fgaeee :=_gabce .Font .GetRuneMetrics (_gbfe );if _afaa .Wx ==0&&_gabce .MultiFont !=nil {_afaa ,_fgaeee =_gabce .MultiFont .GetRuneMetrics (' ');
_gabce .MultiFont .Reset ();};if !_fgaeee {_ca .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_gbfe );return _gggba ,nil ,_fc .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");
};_effdd +=_gabce .FontSize *_afaa .Wx *_gabce .horizontalScale ();if _fcgbbe !=_gfab -1{_effdd +=_gabce .CharSpacing *1000.0;};};_gbgfge =append (_gbgfge ,_effdd );_ccge +=_effdd ;_aged +=float64 (_daafc )*_fbfg .Wx *_gabce .FontSize *_gabce .horizontalScale ();
_bfgfe +=_daafc ;};_gdbaf *=_bgaeb ._bcde ;var _gafg []_be .PdfObject ;_dcad :=_bgaeb ._cbcb *1000.0;if _bgaeb ._abff ==TextAlignmentJustify {if _bfgfe > 0&&!_abaae {_aged =(_dcad -_ccge )/float64 (_bfgfe )/_cbdbf ;};}else if _bgaeb ._abff ==TextAlignmentCenter {_gceec :=(_dcad -_ccge -_aged )/2;
_gfge :=_gceec /_cbdbf ;_gafg =append (_gafg ,_be .MakeFloat (-_gfge ));_gced +=_gceec /1000.0;}else if _bgaeb ._abff ==TextAlignmentRight {_ebbdd :=(_dcad -_ccge -_aged );_afab :=_ebbdd /_cbdbf ;_gafg =append (_gafg ,_be .MakeFloat (-_afab ));_gced +=_ebbdd /1000.0;
};if len (_gafg )> 0{_ggdae .Add_Tf (_efedc ,_cbdbf ).Add_TL (_cbdbf *_bgaeb ._bcde ).Add_TJ (_gafg ...);};_abcf :=0.0;for _acgef ,_geaeg :=range _dgee {_bebc :=&_geaeg .Style ;_bfbda :=_efedc ;_eaeca :=_cbdbf ;_aefa :=_bebc .OutlineColor !=nil ;_cbcf :=_bebc .HorizontalScaling !=DefaultHorizontalScaling ;
_fdeac :=_bebc .OutlineSize !=1;if _fdeac {_ggdae .Add_w (_bebc .OutlineSize );};_edgab :=_bebc .RenderingMode !=TextRenderingModeFill ;if _edgab {_ggdae .Add_Tr (int64 (_bebc .RenderingMode ));};_ebbe :=_bebc .CharSpacing !=0;if _ebbe {_ggdae .Add_Tc (_bebc .CharSpacing );
};_cbbd :=_bebc .TextRise !=0;if _cbbd {_ggdae .Add_Ts (_bebc .TextRise );};if _geaeg .VerticalAlignment !=TextVerticalAlignmentBaseline {_gafdg :=_ecdbd (_geaeg .Style .Font ,_bebc .FontSize );switch _geaeg .VerticalAlignment {case TextVerticalAlignmentCenter :_abcf =_afbc ._daeb /2-_gafdg ._daeb /2;
case TextVerticalAlignmentBottom :_abcf =_afbc ._gfcgf -_gafdg ._gfcgf ;case TextVerticalAlignmentTop :_abcf =_dgcd -_bebc .FontSize ;};if _abcf !=0.0{_ggdae .Translate (0,_abcf );};};if _bgaeb ._abff !=TextAlignmentJustify ||_abaae {_bdaa ,_fegdd :=_bebc .Font .GetRuneMetrics (' ');
if !_fegdd {return _gggba ,nil ,_fc .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_bfbda =_gggbf [_gaed ][_acgef ];_eaeca =_bebc .FontSize ;
_aged =_bdaa .Wx *_bebc .horizontalScale ();};_egbdcf :=_bebc .Font .Encoder ();var _cebf []byte ;var _cegaf bool ;_bacd :=_bebc .Font ;for _ ,_edcbd :=range _geaeg .Text {if _edcbd =='\u000A'{continue ;};if _edcbd ==' '{if len (_cebf )> 0{if _aefa {_ggdae .SetStrokingColor (_fac (_bebc .OutlineColor ));
};if _cbcf {_ggdae .Add_Tz (_bebc .HorizontalScaling );};_abdb :=_gggbf [_gaed ][_acgef ];if _cegaf {_abdb =_be .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gddd ));_dbad :=_aegd ._fa .SetFontByName (_abdb ,_bacd .ToPdfObject ());
if _dbad !=nil {return _gggba ,nil ,_dbad ;};_gddd ++;_cegaf =false ;_egbdcf =_bebc .Font .Encoder ();};_ggdae .SetNonStrokingColor (_fac (_bebc .Color )).Add_Tf (_abdb ,_bebc .FontSize ).Add_TJ ([]_be .PdfObject {_be .MakeStringFromBytes (_cebf )}...);
_cebf =nil ;};if _cbcf {_ggdae .Add_Tz (DefaultHorizontalScaling );};_ggdae .Add_Tf (_bfbda ,_eaeca ).Add_TJ ([]_be .PdfObject {_be .MakeFloat (-_aged )}...);_gbgfge [_acgef ]+=_aged *_eaeca ;}else {if _ ,_face :=_egbdcf .RuneToCharcode (_edcbd );!_face {if _bebc .MultiFont !=nil {_ecbb ,_cddfg :=_bebc .MultiFont .Encoder (_edcbd );
if _cddfg {if len (_cebf )!=0{_abda :=_be .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gddd ));_decgd :=_aegd ._fa .SetFontByName (_bfbda ,_bacd .ToPdfObject ());if _decgd !=nil {return _gggba ,nil ,_decgd ;};_ggdae .SetNonStrokingColor (_fac (_bebc .Color )).Add_Tf (_abda ,_bebc .FontSize ).Add_TJ ([]_be .PdfObject {_be .MakeStringFromBytes (_cebf )}...);
_gddd ++;_cebf =nil ;};_egbdcf =_ecbb ;_cegaf =true ;_bacd =_bebc .MultiFont .CurrentFont ;};}else {_aagd =UnsupportedRuneError {Message :_f .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_edcbd ,_edcbd ),Rune :_edcbd };
_gggba ._ebbc =append (_gggba ._ebbc ,_aagd );_ca .Log .Debug (_aagd .Error ());if _gggba ._ebeg <=0{continue ;};_edcbd =_gggba ._ebeg ;};};_ccfed :=_egbdcf .Encode (string (_edcbd ));_cebf =append (_cebf ,_ccfed ...);};if _bebc .MultiFont !=nil {_bebc .MultiFont .Reset ();
};};if len (_cebf )> 0{if _aefa {_ggdae .SetStrokingColor (_fac (_bebc .OutlineColor ));};if _cbcf {_ggdae .Add_Tz (_bebc .HorizontalScaling );};_ccced :=_gggbf [_gaed ][_acgef ];if _cegaf {_ccced =_be .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gddd ));
_ecba :=_aegd ._fa .SetFontByName (_ccced ,_bacd .ToPdfObject ());if _ecba !=nil {return _gggba ,nil ,_ecba ;};_gddd ++;_cegaf =false ;};_ggdae .SetNonStrokingColor (_fac (_bebc .Color )).Add_Tf (_ccced ,_bebc .FontSize ).Add_TJ ([]_be .PdfObject {_be .MakeStringFromBytes (_cebf )}...);
};_bacg :=_gbgfge [_acgef ]/1000.0;if _bebc .Underline {_dgdbe :=_bebc .UnderlineStyle .Color ;if _dgdbe ==nil {_dgdbe =_geaeg .Style .Color ;};_gdae ,_eagce ,_bcgfe :=_dgdbe .ToRGB ();_cceg :=_gced -_gggba .X ;_bbdgb :=_bbbd -_dgfe +_bebc .TextRise -_bebc .UnderlineStyle .Offset ;
_cgba =append (_cgba ,&_ddb .BasicLine {X1 :_cceg ,Y1 :_bbdgb ,X2 :_cceg +_bacg ,Y2 :_bbdgb ,LineWidth :_geaeg .Style .UnderlineStyle .Thickness ,LineColor :_gd .NewPdfColorDeviceRGB (_gdae ,_eagce ,_bcgfe )});};for _ebcb ,_bcdfg :=range _geaeg ._bcfe {var _ccgb *_be .PdfObjectArray ;
if len (_geaeg ._dgdde )==_ebcb {switch _bded :=_bcdfg .GetContext ().(type ){case *_gd .PdfAnnotationLink :_ccgb =_be .MakeArray ();_bded .Rect =_ccgb ;_cbgc ,_abbe :=_bded .Dest .(*_be .PdfObjectArray );if _abbe &&_cbgc .Len ()==5{_efebb ,_dgca :=_cbgc .Get (1).(*_be .PdfObjectName );
if _dgca &&_efebb .String ()=="\u0058\u0059\u005a"{_geee ,_ccfaf :=_be .GetNumberAsFloat (_cbgc .Get (3));if _ccfaf ==nil {_cbgc .Set (3,_be .MakeFloat (_gggba .PageHeight -_geee ));};};};case *_gd .PdfAnnotationHighlight :_ccgb =_be .MakeArray ();_bded .Rect =_ccgb ;
_gebce :=_gced ;_ggbgge :=_bbbd +_bebc .TextRise ;_dagbg :=_baead (&_gd .PdfRectangle {Llx :_gebce ,Lly :_ggbgge ,Urx :_gebce +_bacg ,Ury :_ggbgge +_gdbaf },_bgaeb ._cbace );_bded .QuadPoints =_be .MakeArrayFromFloats ([]float64 {_dagbg [0].X ,_dagbg [0].Y ,_dagbg [1].X ,_dagbg [1].Y ,_dagbg [3].X ,_dagbg [3].Y ,_dagbg [2].X ,_dagbg [2].Y });
};_geaeg ._dgdde =append (_geaeg ._dgdde ,true );};if _ccgb !=nil {_dfacg :=_ddb .NewPoint (_gced -_gggba .X ,_bbbd +_bebc .TextRise -_dgfe ).Rotate (_bgaeb ._cbace );_dfacg .X +=_gggba .X ;_dfacg .Y +=_dgfe ;_dgfeg ,_cbef ,_cbbfa ,_geceg :=_bcecf (_bacg ,_gdbaf ,_bgaeb ._cbace );
_dfacg .X +=_dgfeg ;_dfacg .Y +=_cbef ;_ccgb .Clear ();_ccgb .Append (_be .MakeFloat (_dfacg .X ));_ccgb .Append (_be .MakeFloat (_dfacg .Y ));_ccgb .Append (_be .MakeFloat (_dfacg .X +_cbbfa ));_ccgb .Append (_be .MakeFloat (_dfacg .Y +_geceg ));};_aegd .AddAnnotation (_bcdfg );
};_gced +=_bacg ;if _fdeac {_ggdae .Add_w (1.0);};if _aefa {_ggdae .Add_RG (0.0,0.0,0.0);};if _edgab {_ggdae .Add_Tr (int64 (TextRenderingModeFill ));};if _ebbe {_ggdae .Add_Tc (0);};if _cbbd {_ggdae .Add_Ts (0);};if _cbcf {_ggdae .Add_Tz (DefaultHorizontalScaling );
};if _abcf !=0.0{_ggdae .Translate (0,-_abcf );_abcf =0.0;};};};if len (_eebf )> 0{_ggdae .Add_EMC ();};_ggdae .Add_ET ();for _ ,_dbgb :=range _cgba {_ggdae .SetStrokingColor (_dbgb .LineColor ).Add_w (_dbgb .LineWidth ).Add_m (_dbgb .X1 ,_dbgb .Y1 ).Add_l (_dbgb .X2 ,_dbgb .Y2 ).Add_s ();
};_ggdae .Add_Q ();_beaf :=_ggdae .Operations ();_beaf .WrapIfNeeded ();_aegd .addContents (_beaf );if _cadd {_cdage :=_ebbgf ;_gggba .Y +=_cdage ;_gggba .Height -=_cdage ;if _gggba .Inline {_gggba .X +=_bgaeb .Width ()+_bgaeb ._affa .Right ;};};return _gggba ,_affde ,nil ;
};

// FitMode returns the fit mode of the image.
func (_agcd *Image )FitMode ()FitMode {return _agcd ._gfba };

// SetFillColor sets the fill color of the rectangle.
func (_dfecc *Rectangle )SetFillColor (col Color ){_dfecc ._gffbd =col };func _dbdbf (_decb *_gd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_decb ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};func (_bcad *Invoice )drawSection (_deea ,_fad string )[]*StyledParagraph {var _badc []*StyledParagraph ;if _deea !=""{_degg :=_aedcd (_bcad ._begb );_degg .SetMargins (0,0,0,5);_degg .Append (_deea );_badc =append (_badc ,_degg );};if _fad !=""{_dfab :=_aedcd (_bcad ._degfg );
_dfab .Append (_fad );_badc =append (_badc ,_dfab );};return _badc ;};

// EnableWordWrap sets the paragraph word wrap flag.
func (_abade *StyledParagraph )EnableWordWrap (val bool ){_abade ._fecad =val };

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_acbbf *Image )ScaleToHeight (h float64 ){_bedb :=_acbbf ._dcbe /_acbbf ._fae ;_acbbf ._fae =h ;_acbbf ._dcbe =h *_bedb ;};

// SetAngle sets the rotation angle of the text.
func (_fbbg *Paragraph )SetAngle (angle float64 ){_fbbg ._ggc =angle };

// GetOptimizer returns current PDF optimizer.
func (_ceb *Creator )GetOptimizer ()_gd .Optimizer {return _ceb ._bfg };

// CurRow returns the currently active cell's row number.
func (_dgbfe *Table )CurRow ()int {_efeg :=(_dgbfe ._eaeec -1)/_dgbfe ._cafcb +1;return _efeg };

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_bgcdb *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_geec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bbfe ,_febb :=_geec .setOpacity (_bgcdb ._bgabd ,_bgcdb ._acfa );if _febb !=nil {return nil ,ctx ,_febb ;
};_gcgd :=_bgcdb ._fbff ;_gcgd .FillEnabled =_gcgd .FillColor !=nil ;_gcgd .BorderEnabled =_gcgd .BorderColor !=nil &&_gcgd .BorderWidth > 0;var (_cbfa =ctx .PageHeight ;_ggagf =_gcgd .Rings ;_bebb =make ([][]_ddb .CubicBezierCurve ,0,len (_gcgd .Rings ));
);_fagga :=_gd .PdfRectangle {};if len (_ggagf )> 0&&len (_ggagf [0])> 0{_gdf :=_ggagf [0][0];_gdf .P0 .Y =_cbfa -_gdf .P0 .Y ;_gdf .P1 .Y =_cbfa -_gdf .P1 .Y ;_gdf .P2 .Y =_cbfa -_gdf .P2 .Y ;_gdf .P3 .Y =_cbfa -_gdf .P3 .Y ;_fagga =_gdf .GetBounds ();
};for _ ,_aeg :=range _ggagf {_fcdc :=make ([]_ddb .CubicBezierCurve ,0,len (_aeg ));for _ ,_eebaf :=range _aeg {_edc :=_eebaf ;_edc .P0 .Y =_cbfa -_edc .P0 .Y ;_edc .P1 .Y =_cbfa -_edc .P1 .Y ;_edc .P2 .Y =_cbfa -_edc .P2 .Y ;_edc .P3 .Y =_cbfa -_edc .P3 .Y ;
_fcdc =append (_fcdc ,_edc );_bfaa :=_edc .GetBounds ();_fagga .Llx =_ff .Min (_fagga .Llx ,_bfaa .Llx );_fagga .Lly =_ff .Min (_fagga .Lly ,_bfaa .Lly );_fagga .Urx =_ff .Max (_fagga .Urx ,_bfaa .Urx );_fagga .Ury =_ff .Max (_fagga .Ury ,_bfaa .Ury );
};_bebb =append (_bebb ,_fcdc );};_gcgd .Rings =_bebb ;defer func (){_gcgd .Rings =_ggagf }();if _gcgd .FillEnabled {_fbc :=_gaea (_geec ,_bgcdb ._fbff .FillColor ,_bgcdb ._fdbd ,func ()Rectangle {return Rectangle {_fdeb :_fagga .Llx ,_fefcd :_fagga .Lly ,_dacdg :_fagga .Width (),_ddccd :_fagga .Height ()};
});if _fbc !=nil {return nil ,ctx ,_fbc ;};};_bffa ,_ ,_febb :=_gcgd .MarkedDraw (_bbfe ,_bgcdb ._acgc );if _febb !=nil {return nil ,ctx ,_febb ;};if _febb =_geec .addContentsByString (string (_bffa ));_febb !=nil {return nil ,ctx ,_febb ;};return []*Block {_geec },ctx ,nil ;
};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_gcaf *_ddb .Polyline ;_aegga float64 ;_ecga *int64 ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_egcg *shading )SetAntiAlias (enable bool ){_egcg ._fdda =enable };

// SetViewerPreferences sets the viewer preferences for the PDF document.
func (_cdggd *Creator )SetViewerPreferences (viewerPreferences *_gd .ViewerPreferences ){_cdggd ._ggfa =viewerPreferences ;};func (_dfgf *Invoice )generateLineBlocks (_dedd DrawContext )([]*Block ,DrawContext ,error ){_bcgc :=_gdcg (len (_dfgf ._gbbc ));
_bcgc .SetMargins (0,0,25,0);for _ ,_fbdeb :=range _dfgf ._gbbc {_fcgbb :=_aedcd (_fbdeb .TextStyle );_fcgbb .SetMargins (0,0,1,0);_fcgbb .Append (_fbdeb .Value );_fafc :=_bcgc .NewCell ();_fafc .SetHorizontalAlignment (_fbdeb .Alignment );_fafc .SetBackgroundColor (_fbdeb .BackgroundColor );
_dfgf .setCellBorder (_fafc ,_fbdeb );_fafc .SetContent (_fcgbb );};for _ ,_edeb :=range _dfgf ._gdfd {for _ ,_agaf :=range _edeb {_egbdc :=_aedcd (_agaf .TextStyle );_egbdc .SetMargins (0,0,3,2);_egbdc .Append (_agaf .Value );_ageg :=_bcgc .NewCell ();
_ageg .SetHorizontalAlignment (_agaf .Alignment );_ageg .SetBackgroundColor (_agaf .BackgroundColor );_dfgf .setCellBorder (_ageg ,_agaf );_ageg .SetContent (_egbdc );};};return _bcgc .GeneratePageBlocks (_dedd );};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_bdffd *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_bdffd ._ggaca =alignment };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_cfbf *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edbc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_egge ,_bcgf :=_edbc .setOpacity (_cfbf ._cbfb ,_cfbf ._gcdg );if _bcgf !=nil {return nil ,ctx ,_bcgf ;};_acdec :=_cfbf ._dbfd ;
_acdec .FillEnabled =_acdec .FillColor !=nil ;_acdec .BorderEnabled =_acdec .BorderColor !=nil &&_acdec .BorderWidth > 0;_dgaef :=_acdec .Points ;_baed :=_gd .PdfRectangle {};_daacf :=false ;for _aefbf :=range _dgaef {for _dcaa :=range _dgaef [_aefbf ]{_becg :=&_dgaef [_aefbf ][_dcaa ];
_becg .Y =ctx .PageHeight -_becg .Y ;if !_daacf {_baed .Llx =_becg .X ;_baed .Lly =_becg .Y ;_baed .Urx =_becg .X ;_baed .Ury =_becg .Y ;_daacf =true ;}else {_baed .Llx =_ff .Min (_baed .Llx ,_becg .X );_baed .Lly =_ff .Min (_baed .Lly ,_becg .Y );_baed .Urx =_ff .Max (_baed .Urx ,_becg .X );
_baed .Ury =_ff .Max (_baed .Ury ,_becg .Y );};};};if _acdec .FillEnabled {_aegg :=_gaea (_edbc ,_cfbf ._dbfd .FillColor ,_cfbf ._aafdc ,func ()Rectangle {return Rectangle {_fdeb :_baed .Llx ,_fefcd :_baed .Lly ,_dacdg :_baed .Width (),_ddccd :_baed .Height ()};
});if _aegg !=nil {return nil ,ctx ,_aegg ;};};_gccc ,_ ,_bcgf :=_acdec .MarkedDraw (_egge ,_cfbf ._fgdbe );if _bcgf !=nil {return nil ,ctx ,_bcgf ;};if _bcgf =_edbc .addContentsByString (string (_gccc ));_bcgf !=nil {return nil ,ctx ,_bcgf ;};return []*Block {_edbc },ctx ,nil ;
};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_dbgg DrawContext )([]*Block ,DrawContext ,error );

// SetMarkedContentID sets the marked content id for the drawable.
SetMarkedContentID (_dac int64 )*_gd .KDict ;};

// SetLineWidth sets the line width.
func (_bagg *Polyline )SetLineWidth (lineWidth float64 ){_bagg ._gcaf .LineWidth =lineWidth };

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_gdgc *Chart )SetPos (x ,y float64 ){_gdgc ._eebg =PositionAbsolute ;_gdgc ._cfca =x ;_gdgc ._badb =y ;};

// SetStyleBottom sets border style for bottom side.
func (_gefb *border )SetStyleBottom (style CellBorderStyle ){_gefb ._dcd =style };

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_gfgbe *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// SetTerms sets the terms and conditions section of the invoice.
func (_caaca *Invoice )SetTerms (title ,content string ){_caaca ._acae =[2]string {title ,content }};

// ClearAnnotations clears any existing annotations.
func (_fafa *TextChunk )ClearAnnotations (){_fafa ._bcfe =[]*_gd .PdfAnnotation {}};func (_abceb *templateProcessor )parseCellBorderStyleAttr (_acaed ,_befg string )CellBorderStyle {_ca .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_acaed ,_befg );
_aebdb :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_befg ];return _aebdb ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_aggc *Invoice )BuyerAddress ()*InvoiceAddress {return _aggc ._adbcd };

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_deab *Paragraph )SetColor (col Color ){_deab ._ebbg =col };func _cdae (_ceaaaf *templateProcessor ,_cccaf *templateNode )(interface{},error ){return _ceaaaf .parseTextChunk (_cccaf ,nil );};func (_befe *pageTransformations )applyFlip (_eed *_gd .PdfPage )error {_gaba ,_dfef :=_befe ._fgfca ,_befe ._gfega ;
if !_gaba &&!_dfef {return nil ;};if _eed ==nil {return _fc .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_befa ,_bafd :=_eed .GetMediaBox ();if _bafd !=nil {return _bafd ;};_aded ,_aedc :=_befa .Width (),_befa .Height ();
_bcec ,_bafd :=_eed .GetRotate ();if _bafd !=nil {_ca .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_bafd .Error ());
};if _gcba :=_bcec %360!=0&&_bcec %90==0;_gcba {if _adea :=(360+_bcec %360)%360;_adea ==90||_adea ==270{_gaba ,_dfef =_dfef ,_gaba ;};};_ecfa ,_beb :=1.0,0.0;if _gaba {_ecfa ,_beb =-1.0,-_aded ;};_fagf ,_bgdaf :=1.0,0.0;if _dfef {_fagf ,_bgdaf =-1.0,-_aedc ;
};_dcf :=_eag .NewContentCreator ().Scale (_ecfa ,_fagf ).Translate (_beb ,_bgdaf );_eacf ,_bafd :=_be .MakeStream (_dcf .Bytes (),_be .NewFlateEncoder ());if _bafd !=nil {return _bafd ;};_eda :=_be .MakeArray (_eacf );_eda .Append (_eed .GetContentStreamObjs ()...);
_eed .Contents =_eda ;return nil ;};func (_gddbc *templateProcessor )parseColorAttr (_eabfa ,_egfd string )Color {_ca .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_eabfa ,_egfd );
_egfd =_ddf .TrimSpace (_egfd );if _ddf .HasPrefix (_egfd ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_ddf .HasSuffix (_egfd ,"\u0029")&&len (_egfd )> 17{return _gddbc .parseLinearGradientAttr (_gddbc .creator ,_egfd );
};if _ddf .HasPrefix (_egfd ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_ddf .HasSuffix (_egfd ,"\u0029")&&len (_egfd )> 17{return _gddbc .parseRadialGradientAttr (_gddbc .creator ,_egfd );};if _ebfc :=_gddbc .parseColor (_egfd );
_ebfc !=nil {return _ebfc ;};return ColorBlack ;};func (_badfdd *StyledParagraph )split (_bgdc DrawContext )(_gabe ,_dfaa *StyledParagraph ,_fgaee error ){if _fgaee =_badfdd .wrapChunks (false );_fgaee !=nil {return nil ,nil ,_fgaee ;};if len (_badfdd ._ccae )==1&&_badfdd ._bcde > _bgdc .Height {return _badfdd ,nil ,nil ;
};_eagbf :=func (_fcba []*TextChunk ,_abace []*TextChunk )[]*TextChunk {if len (_abace )==0{return _fcba ;};_adege :=len (_fcba );if _adege ==0{return append (_fcba ,_abace ...);};if _fcba [_adege -1].Style ==_abace [0].Style {_fcba [_adege -1].Text +=_abace [0].Text ;
}else {_fcba =append (_fcba ,_abace [0]);};return append (_fcba ,_abace [1:]...);};_ggfe :=func (_ccec *StyledParagraph ,_fafbd []*TextChunk )*StyledParagraph {if len (_fafbd )==0{return nil ;};_gcef :=*_ccec ;_gcef ._bcbc =_fafbd ;return &_gcef ;};var (_eece float64 ;
_aefd []*TextChunk ;_fadd []*TextChunk ;);for _ ,_ddebg :=range _badfdd ._ccae {var _fcfe float64 ;_fdaee :=make ([]*TextChunk ,0,len (_ddebg ));for _ ,_fefe :=range _ddebg {if _decd :=_fefe .Style .FontSize ;_decd > _fcfe {_fcfe =_decd ;};_fdaee =append (_fdaee ,_fefe .clone ());
};_fcfe *=_badfdd ._bcde ;if _badfdd ._abab .IsRelative (){if _eece +_fcfe > _bgdc .Height {_fadd =_eagbf (_fadd ,_fdaee );}else {_aefd =_eagbf (_aefd ,_fdaee );};};_eece +=_fcfe ;};_badfdd ._ccae =nil ;if len (_fadd )==0{return _badfdd ,nil ,nil ;};return _ggfe (_badfdd ,_aefd ),_ggfe (_badfdd ,_fadd ),nil ;
};

// SetMarkedContentID sets the marked content ID for the image.
func (_gefc *Image )SetMarkedContentID (mcid int64 )*_gd .KDict {_gefc ._cebad =&mcid ;_beaa :=_gd .NewKDictionary ();_beaa .S =_be .MakeName (_gd .StructureTypeFigure );_beaa .K =_be .MakeInteger (mcid );return _beaa ;};

// SetBorderColor sets the border color.
func (_fbaae *Polygon )SetBorderColor (color Color ){_fbaae ._dbfd .BorderColor =_fac (color )};

// SetBorderOpacity sets the border opacity.
func (_bcab *CurvePolygon )SetBorderOpacity (opacity float64 ){_bcab ._acfa =opacity };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_fgdb *Image )ScaleToWidth (w float64 ){_fcce :=_fgdb ._fae /_fgdb ._dcbe ;_fgdb ._dcbe =w ;_fgdb ._fae =w *_fcce ;};

// Add adds a new line with the default style to the table of contents.
func (_cfedd *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_bgacc :=_cfedd .AddLine (_gcaeg (TextChunk {Text :number ,Style :_cfedd ._defeaa },TextChunk {Text :title ,Style :_cfedd ._eebgb },TextChunk {Text :page ,Style :_cfedd ._ccffd },level ,_cfedd ._cdef ));
if _bgacc ==nil {return nil ;};_daede :=&_cfedd ._caada ;_bgacc .SetMargins (_daede .Left ,_daede .Right ,_daede .Top ,_daede .Bottom );_bgacc .SetLevelOffset (_cfedd ._dddcf );_bgacc .Separator .Text =_cfedd ._gffbbe ;_bgacc .Separator .Style =_cfedd ._daffbe ;
return _bgacc ;};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_egff *Rectangle )Height ()float64 {return _egff ._ddccd };

// TOC returns the table of contents component of the creator.
func (_ffb *Creator )TOC ()*TOC {return _ffb ._dda };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_dbfe *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dbfe ._dfdg .Left ,_dbfe ._dfdg .Right ,_dbfe ._dfdg .Top ,_dbfe ._dfdg .Bottom ;};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;
TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;);

// Width returns the width of the specified text chunk.
func (_aedcg *TextChunk )Width ()float64 {var (_bggab float64 ;_dafbg =_aedcg .Style ;);for _ ,_ccgg :=range _aedcg .Text {_ffbf ,_bgee :=_dafbg .Font .GetRuneMetrics (_ccgg );if !_bgee {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_ccgg ,_ccgg ,_dafbg .Font .BaseFont (),_dafbg .Font .Subtype ());
_ca .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_dafbg .Font );_ca .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_dafbg .Font .Encoder ());};_dgba :=_dafbg .FontSize *_ffbf .Wx ;_bcedf :=_dgba ;if _ccgg !=' '{_bcedf =_dgba +_dafbg .CharSpacing *1000.0;
};_bggab +=_bcedf ;};return _bggab /1000.0;};func (_cdggf *StyledParagraph )getMaxLineWidth ()float64 {if _cdggf ._ccae ==nil ||(_cdggf ._ccae !=nil &&len (_cdggf ._ccae )==0){_cdggf .wrapText ();};var _cgceg float64 ;for _ ,_dbba :=range _cdggf ._ccae {_cffe :=_cdggf .getTextLineWidth (_dbba );
if _cffe > _cgceg {_cgceg =_cffe ;};};return _cgceg ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_ggdaa *Table )EnableRowWrap (enable bool ){_ggdaa ._ffeag =enable };

// NewImageFromData creates an Image from image data.
func (_adgb *Creator )NewImageFromData (data []byte )(*Image ,error ){return _agbf (data )};func _cegc (_eadb *_e .File )([]*_gd .PdfPage ,error ){_abdba ,_eedeaf :=_gd .NewPdfReader (_eadb );if _eedeaf !=nil {return nil ,_eedeaf ;};_adae ,_eedeaf :=_abdba .GetNumPages ();
if _eedeaf !=nil {return nil ,_eedeaf ;};var _gcfc []*_gd .PdfPage ;for _aeffa :=0;_aeffa < _adae ;_aeffa ++{_fdfdf ,_gggfg :=_abdba .GetPage (_aeffa +1);if _gggfg !=nil {return nil ,_gggfg ;};_gcfc =append (_gcfc ,_fdfdf );};return _gcfc ,nil ;};

// SetMakeredContentID sets the marked content identifier for the ellipse.
func (_bccf *Ellipse )SetMarkedContentID (mcid int64 )*_gd .KDict {_bccf ._ecdc =&mcid ;_cccgc :=_gd .NewKDictionary ();_cccgc .S =_be .MakeName (_gd .StructureTypeFigure );_cccgc .K =_be .MakeInteger (mcid );return _cccgc ;};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_ecgae *RadialShading )AddPatternResource (block *Block )(_eaab _be .PdfObjectName ,_daba error ){_aedca :=1;_eeec :=_be .PdfObjectName ("\u0050"+_fd .Itoa (_aedca ));for block ._fa .HasPatternByName (_eeec ){_aedca ++;_eeec =_be .PdfObjectName ("\u0050"+_fd .Itoa (_aedca ));
};if _fgef :=block ._fa .SetPatternByName (_eeec ,_ecgae .ToPdfShadingPattern ().ToPdfObject ());_fgef !=nil {return "",_fgef ;};return _eeec ,nil ;};func (_fdfec *templateProcessor )parseRadialGradientAttr (creator *Creator ,_feeee string )Color {_cfae :=ColorBlack ;
if _feeee ==""{return _cfae ;};var (_dacdga error ;_acfg =0.0;_fadgf =0.0;_ccaea =-1.0;_cfeg =_ddf .Split (_feeee [16:len (_feeee )-1],"\u002c"););_abbf :=_ddf .Fields (_cfeg [0]);if len (_abbf )==2&&_ddf .TrimSpace (_abbf [0])[0]!='#'{_acfg ,_dacdga =_fd .ParseFloat (_abbf [0],64);
if _dacdga !=nil {_ca .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_dacdga );
};_fadgf ,_dacdga =_fd .ParseFloat (_abbf [1],64);if _dacdga !=nil {_ca .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_dacdga );
};_cfeg =_cfeg [1:];};_eecfg :=_ddf .TrimSpace (_cfeg [0]);if _eecfg [0]!='#'{_ccaea ,_dacdga =_fd .ParseFloat (_eecfg ,64);if _dacdga !=nil {_ca .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_dacdga );
};_cfeg =_cfeg [1:];};_cdacc ,_bebg :=_fdfec .processGradientColorPair (_cfeg );if _cdacc ==nil ||_bebg ==nil {return _cfae ;};_cadgf :=creator .NewRadialGradientColor (_acfg ,_fadgf ,0,_ccaea ,[]*ColorPoint {});for _cfbg :=0;_cfbg < len (_cdacc );_cfbg ++{_cadgf .AddColorStop (_cdacc [_cfbg ],_bebg [_cfbg ]);
};return _cadgf ;};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_gfddb *Ellipse )BorderOpacity ()float64 {return _gfddb ._egegc };

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_abbg *Ellipse )SetPositioning (position Positioning ){_abbg ._gbbf =position };

// AppendCurve appends a Bezier curve to the filled curve.
func (_cgda *FilledCurve )AppendCurve (curve _ddb .CubicBezierCurve )*FilledCurve {_cgda ._cefdf =append (_cgda ._cefdf ,curve );return _cgda ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_bbfc *Creator )NewChapter (title string )*Chapter {_bbfc ._agdg ++;_bbdf :=_bbfc .NewTextStyle ();_bbdf .FontSize =16;return _dbaf (nil ,_bbfc ._dda ,_bbfc ._eagf ,title ,_bbfc ._agdg ,_bbdf );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gddbe *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adbcg :=ctx ;_fafca :=[]func (_caff DrawContext )([]*Block ,DrawContext ,error ){_gddbe .generateHeaderBlocks ,_gddbe .generateInformationBlocks ,_gddbe .generateLineBlocks ,_gddbe .generateTotalBlocks ,_gddbe .generateNoteBlocks };
var _beaad []*Block ;for _ ,_feee :=range _fafca {_gcae ,_bbbf ,_affff :=_feee (ctx );if _affff !=nil {return _beaad ,ctx ,_affff ;};if len (_beaad )==0{_beaad =_gcae ;}else if len (_gcae )> 0{_beaad [len (_beaad )-1].mergeBlocks (_gcae [0]);_beaad =append (_beaad ,_gcae [1:]...);
};ctx =_bbbf ;};if _gddbe ._afbg .IsRelative (){ctx .X =_adbcg .X ;};if _gddbe ._afbg .IsAbsolute (){return _beaad ,_adbcg ,nil ;};return _beaad ,ctx ,nil ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_cbaceg *TableCell )SetBorderLineStyle (style _ddb .LineStyle ){_cbaceg ._aecgdc =style };type border struct{_ffa float64 ;_cbc float64 ;_dc float64 ;_ggb float64 ;_agaab Color ;_fed Color ;_cgd float64 ;_bfde Color ;_fcec float64 ;_gcg Color ;_dggc float64 ;
_ed Color ;_egeb float64 ;LineStyle _ddb .LineStyle ;_fgfc CellBorderStyle ;_cbgf CellBorderStyle ;_gdgg CellBorderStyle ;_dcd CellBorderStyle ;};

// BorderWidth returns the border width of the ellipse.
func (_dgggg *Ellipse )BorderWidth ()float64 {return _dgggg ._fdcc };func (_daffb *StyledParagraph )getLineMetrics (_fafgg int )(_baff ,_eegb ,_ceeg float64 ){if _daffb ._ccae ==nil ||(_daffb ._ccae !=nil &&len (_daffb ._ccae )==0){_daffb .wrapText ();
};if _fafgg < 0||_fafgg > len (_daffb ._ccae )-1{_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_fafgg );
return 0,0,0;};_gfaa :=_daffb ._ccae [_fafgg ];for _ ,_bafaf :=range _gfaa {_bdeg :=_ecdbd (_bafaf .Style .Font ,_bafaf .Style .FontSize );if _bdeg ._edgacc > _baff {_baff =_bdeg ._edgacc ;};if _bdeg ._gfcgf < _ceeg {_ceeg =_bdeg ._gfcgf ;};if _ccfa :=_bafaf .Style .FontSize ;
_ccfa > _eegb {_eegb =_ccfa ;};};return _baff ,_eegb ,_ceeg ;};func (_cba *Block )addContentsByString (_eae string )error {_adbc :=_eag .NewContentStreamParser (_eae );_bdd ,_aef :=_adbc .Parse ();if _aef !=nil {return _aef ;};_cba ._ge .WrapIfNeeded ();
_bdd .WrapIfNeeded ();*_cba ._ge =append (*_cba ._ge ,*_bdd ...);return nil ;};func (_dgg *Block )translate (_adc ,_ddbg float64 ){_gde :=_eag .NewContentCreator ().Translate (_adc ,-_ddbg ).Operations ();*_dgg ._ge =append (*_gde ,*_dgg ._ge ...);_dgg ._ge .WrapIfNeeded ();
};func (_ddff *Invoice )generateHeaderBlocks (_fgca DrawContext )([]*Block ,DrawContext ,error ){_bacb :=_aedcd (_ddff ._fcbed );_bacb .SetEnableWrap (true );_bacb .Append (_ddff ._bgfbda );_bgcdbb :=_gdcg (2);if _ddff ._afed !=nil {_ecadb :=_bgcdbb .NewCell ();
_ecadb .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_ecadb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_ecadb .SetIndent (0);_ecadb .SetContent (_ddff ._afed );_ddff ._afed .ScaleToHeight (_bacb .Height ()+20);}else {_bgcdbb .SkipCells (1);
};_egaa :=_bgcdbb .NewCell ();_egaa .SetHorizontalAlignment (CellHorizontalAlignmentRight );_egaa .SetVerticalAlignment (CellVerticalAlignmentMiddle );_egaa .SetContent (_bacb );return _bgcdbb .GeneratePageBlocks (_fgca );};

// GetMargins returns the left, right, top, bottom Margins.
func (_dbeeb *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dbeeb ._ccecg .Left ,_dbeeb ._ccecg .Right ,_dbeeb ._ccecg .Top ,_dbeeb ._ccecg .Bottom ;};func (_aeea *Table )resetColumnWidths (){_aeea ._faae =[]float64 {};_ddccc :=float64 (1.0)/float64 (_aeea ._cafcb );
for _cffeg :=0;_cffeg < _aeea ._cafcb ;_cffeg ++{_aeea ._faae =append (_aeea ._faae ,_ddccc );};};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_afd :_ff .Max (_ff .Min (r ,1.0),0.0),_fef :_ff .Max (_ff .Min (g ,1.0),0.0),_cbbf :_ff .Max (_ff .Min (b ,1.0),0.0)};};

// SetPositioning sets the positioning of the line (absolute or relative).
func (_acff *Line )SetPositioning (positioning Positioning ){_acff ._fcbba =positioning };type shading struct{_bbdfc Color ;_fdda bool ;_gecd []bool ;_agcac []*ColorPoint ;};func (_dagad *templateProcessor )parseAttrPropList (_cddbg string )map[string ]string {_ffafa :=_ddf .Fields (_cddbg );
if len (_ffafa )==0{return nil ;};_cccab :=map[string ]string {};for _ ,_gfgfe :=range _ffafa {_edecf :=_ebeae .FindStringSubmatch (_gfgfe );if len (_edecf )< 3{continue ;};_bfgd ,_gafca :=_ddf .TrimSpace (_edecf [1]),_edecf [2];if _bfgd ==""{continue ;
};_cccab [_bfgd ]=_gafca ;};return _cccab ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_edaeb *TOC )SetLineNumberStyle (style TextStyle ){_edaeb ._defeaa =style };

// Logo returns the logo of the invoice.
func (_cafbc *Invoice )Logo ()*Image {return _cafbc ._afed };const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_abaf *Invoice )SetAddressStyle (style TextStyle ){_abaf ._gdga =style };func _cgfa (_ebcc map[string ]interface{},_eaaae ...interface{})(map[string ]interface{},error ){_ebfb :=len (_eaaae );if _ebfb %2!=0{return nil ,_be .ErrRangeError ;};for _feea :=0;
_feea < _ebfb ;_feea +=2{_befac ,_agda :=_eaaae [_feea ].(string );if !_agda {return nil ,_be .ErrTypeError ;};_ebcc [_befac ]=_eaaae [_feea +1];};return _ebcc ,nil ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_aabgc *Invoice )Notes ()(string ,string ){return _aabgc ._cdbg [0],_aabgc ._cdbg [1]};func (_cgb *FilledCurve )draw (_gddb *Block ,_egbd string )([]byte ,*_gd .PdfRectangle ,error ){_dffc :=_ddb .NewCubicBezierPath ();for _ ,_bced :=range _cgb ._cefdf {_dffc =_dffc .AppendCurve (_bced );
};creator :=_eag .NewContentCreator ();if _cgb ._gfecd !=nil {creator .Add_BDC (*_be .MakeName (_gd .StructureTypeFigure ),map[string ]_be .PdfObject {"\u004d\u0043\u0049\u0044":_be .MakeInteger (*_cgb ._gfecd )});};creator .Add_q ();if _cgb .FillEnabled &&_cgb ._gdge !=nil {_ecfag :=_fac (_cgb ._gdge );
_cdbf :=_gaea (_gddb ,_ecfag ,_cgb ._gdge ,func ()Rectangle {_gdfa :=_ddb .NewCubicBezierPath ();for _ ,_ceagf :=range _cgb ._cefdf {_gdfa =_gdfa .AppendCurve (_ceagf );};_bgeb :=_gdfa .GetBoundingBox ();if _cgb .BorderEnabled {_bgeb .Height +=_cgb .BorderWidth ;
_bgeb .Width +=_cgb .BorderWidth ;_bgeb .X -=_cgb .BorderWidth /2;_bgeb .Y -=_cgb .BorderWidth /2;};return Rectangle {_fdeb :_bgeb .X ,_fefcd :_bgeb .Y ,_dacdg :_bgeb .Width ,_ddccd :_bgeb .Height };});if _cdbf !=nil {return nil ,nil ,_cdbf ;};creator .SetNonStrokingColor (_ecfag );
};if _cgb .BorderEnabled {if _cgb ._aebe !=nil {creator .SetStrokingColor (_fac (_cgb ._aebe ));};creator .Add_w (_cgb .BorderWidth );};if len (_egbd )> 1{creator .Add_gs (_be .PdfObjectName (_egbd ));};_ddb .DrawBezierPathWithCreator (_dffc ,creator );
creator .Add_h ();if _cgb .FillEnabled &&_cgb .BorderEnabled {creator .Add_B ();}else if _cgb .FillEnabled {creator .Add_f ();}else if _cgb .BorderEnabled {creator .Add_S ();};creator .Add_Q ();if _cgb ._gfecd !=nil {creator .Add_EMC ();};_fagcd :=_dffc .GetBoundingBox ();
if _cgb .BorderEnabled {_fagcd .Height +=_cgb .BorderWidth ;_fagcd .Width +=_cgb .BorderWidth ;_fagcd .X -=_cgb .BorderWidth /2;_fagcd .Y -=_cgb .BorderWidth /2;};_bgef :=&_gd .PdfRectangle {};_bgef .Llx =_fagcd .X ;_bgef .Lly =_fagcd .Y ;_bgef .Urx =_fagcd .X +_fagcd .Width ;
_bgef .Ury =_fagcd .Y +_fagcd .Height ;return creator .Bytes (),_bgef ,nil ;};

// SetBorderColor sets the cell's border color.
func (_cdfce *TableCell )SetBorderColor (col Color ){_cdfce ._edgac =col ;_cdfce ._daea =col ;_cdfce ._cada =col ;_cdfce ._agcef =col ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//
//	red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_cgab :_ff .Min (float64 (c ),100)/100.0,_bfdc :_ff .Min (float64 (m ),100)/100.0,_fec :_ff .Min (float64 (y ),100)/100.0,_febg :_ff .Min (float64 (k ),100)/100.0};};func _cfgc (_dagb ,_acce ,_cddf ,_acagg float64 )*Ellipse {return &Ellipse {_dbeb :_dagb ,_caaf :_acce ,_gbea :_cddf ,_fgbb :_acagg ,_gbbf :PositionAbsolute ,_baae :1.0,_bfgf :ColorBlack ,_fdcc :1.0,_egegc :1.0};
};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_fbff *_ddb .CurvePolygon ;_bgabd float64 ;_acfa float64 ;_fdbd Color ;_acgc *int64 ;};func (_bfad *Ellipse )applyFitMode (_fddd float64 ){_fddd -=_bfad ._dffg .Left +_bfad ._dffg .Right ;switch _bfad ._fdbc {case FitModeFillWidth :_bfad .ScaleToWidth (_fddd );
};};func (_fbed *pageTransformations )transformBlock (_fea *Block ){if _fbed ._agce !=nil {_fea .transform (*_fbed ._agce );};};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_dgab *Table )SetMargins (left ,right ,top ,bottom float64 ){_dgab ._ccecg .Left =left ;_dgab ._ccecg .Right =right ;_dgab ._ccecg .Top =top ;_dgab ._ccecg .Bottom =bottom ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_dgdcb *LinearShading )ToPdfShadingPattern ()*_gd .PdfShadingPatternType2 {_cbde ,_dccbg ,_caffb :=_dgdcb ._faee ._bbdfc .ToRGB ();_bcdf :=_dgdcb .shadingModel ();_bcdf .PdfShading .Background =_be .MakeArrayFromFloats ([]float64 {_cbde ,_dccbg ,_caffb });
_fgce :=_gd .NewPdfShadingPatternType2 ();_fgce .Shading =_bcdf ;return _fgce ;};

// SetBorder sets the cell's border style.
func (_daaef *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_daaef ._bddcf =CellBorderStyleSingle ;_daaef ._debdc =width ;_daaef ._dgag =CellBorderStyleSingle ;
_daaef ._acdc =width ;_daaef ._deef =CellBorderStyleSingle ;_daaef ._gecc =width ;_daaef ._gcccg =CellBorderStyleSingle ;_daaef ._efec =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_daaef ._bddcf =CellBorderStyleDouble ;_daaef ._debdc =width ;
_daaef ._dgag =CellBorderStyleDouble ;_daaef ._acdc =width ;_daaef ._deef =CellBorderStyleDouble ;_daaef ._gecc =width ;_daaef ._gcccg =CellBorderStyleDouble ;_daaef ._efec =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_daaef ._bddcf =style ;
_daaef ._debdc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_daaef ._dgag =style ;_daaef ._acdc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_daaef ._deef =style ;
_daaef ._gecc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_daaef ._gcccg =style ;_daaef ._efec =width ;};};

// SetMarkedContentID sets the marked content ID.
func (_fecab *PolyBezierCurve )SetMarkedContentID (mcid int64 )*_gd .KDict {_fecab ._bgadb =&mcid ;_cdfe :=_gd .NewKDictionary ();_cdfe .S =_be .MakeName (_gd .StructureTypeFigure );_cdfe .K =_be .MakeInteger (mcid );return _cdfe ;};func _gcaeg (_aedf ,_eecce ,_gccgf TextChunk ,_ecdda uint ,_daca TextStyle )*TOCLine {_decfd :=_aedcd (_daca );
_decfd .SetEnableWrap (true );_decfd .SetTextAlignment (TextAlignmentLeft );_decfd .SetMargins (0,0,2,2);_dcgaa :=&TOCLine {_ecfeg :_decfd ,Number :_aedf ,Title :_eecce ,Page :_gccgf ,Separator :TextChunk {Text :"\u002e",Style :_daca },_gdcff :0,_bfcf :_ecdda ,_gedeb :10,_cdfed :PositionRelative };
_decfd ._affa .Left =_dcgaa ._gdcff +float64 (_dcgaa ._bfcf -1)*_dcgaa ._gedeb ;_decfd ._bfbe =_dcgaa .prepareParagraph ;return _dcgaa ;};type templateProcessor struct{creator *Creator ;_fagcac []byte ;_agabg *TemplateOptions ;_gfcf componentRenderer ;
_cabb string ;};

// AppendColumn appends a column to the line items table.
func (_bbfg *Invoice )AppendColumn (description string )*InvoiceCell {_gcebd :=_bbfg .NewColumn (description );_bbfg ._gbbc =append (_bbfg ._gbbc ,_gcebd );return _gcebd ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_eeda *Creator )Finalize ()error {if _eeda ._gbg {return nil ;};_cagc :=len (_eeda ._bee );_dde :=0;if _eeda ._bbde !=nil {_abf :=*_eeda ;_eeda ._bee =nil ;_eeda ._cafc =nil ;_eeda .initContext ();_ddd :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cagc };
_eeda ._bbde (_ddd );_dde +=len (_eeda ._bee );_eeda ._bee =_abf ._bee ;_eeda ._cafc =_abf ._cafc ;};if _eeda .AddTOC {_eeda .initContext ();_eeda ._ecfb .Page =_dde +1;if _eeda .CustomTOC &&_eeda ._bef !=nil {_bca :=*_eeda ;_eeda ._bee =nil ;_eeda ._cafc =nil ;
if _acdae :=_eeda ._bef (_eeda ._dda );_acdae !=nil {return _acdae ;};_dde +=len (_eeda ._bee );_eeda ._bee =_bca ._bee ;_eeda ._cafc =_bca ._cafc ;}else {if _eeda ._bef !=nil {if _edeg :=_eeda ._bef (_eeda ._dda );_edeg !=nil {return _edeg ;};};_feg ,_ ,_gfdd :=_eeda ._dda .GeneratePageBlocks (_eeda ._ecfb );
if _gfdd !=nil {_ca .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_gfdd );return _gfdd ;};_dde +=len (_feg );};_eagg :=_eeda ._dda .Lines ();
for _ ,_bdcc :=range _eagg {_ebad ,_bbdd :=_fd .Atoi (_bdcc .Page .Text );if _bbdd !=nil {continue ;};_bdcc .Page .Text =_fd .Itoa (_ebad +_dde );_bdcc ._bfabf +=int64 (_dde );};};_daee :=false ;var _adgf []*_gd .PdfPage ;if _eeda ._bbde !=nil {_fge :=*_eeda ;
_eeda ._bee =nil ;_eeda ._cafc =nil ;_cgdg :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cagc };_eeda ._bbde (_cgdg );_cagc +=len (_eeda ._bee );_adgf =_eeda ._bee ;_eeda ._bee =append (_eeda ._bee ,_fge ._bee ...);_eeda ._cafc =_fge ._cafc ;_daee =true ;
};var _cec []*_gd .PdfPage ;if _eeda .AddTOC {_eeda .initContext ();if _eeda .CustomTOC &&_eeda ._bef !=nil {_adbcc :=*_eeda ;_eeda ._bee =nil ;_eeda ._cafc =nil ;if _ggbgg :=_eeda ._bef (_eeda ._dda );_ggbgg !=nil {_ca .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_ggbgg );
return _ggbgg ;};_cec =_eeda ._bee ;_cagc +=len (_cec );_eeda ._bee =_adbcc ._bee ;_eeda ._cafc =_adbcc ._cafc ;}else {if _eeda ._bef !=nil {if _ecgb :=_eeda ._bef (_eeda ._dda );_ecgb !=nil {_ca .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_ecgb );
return _ecgb ;};};_bggf ,_ ,_ :=_eeda ._dda .GeneratePageBlocks (_eeda ._ecfb );for _ ,_acdd :=range _bggf {_acdd .SetPos (0,0);_cagc ++;_bgbcg :=_eeda .newPage ();_cec =append (_cec ,_bgbcg );_eeda .setActivePage (_bgbcg );_eeda .Draw (_acdd );};};if _daee {_edec :=_adgf ;
_afff :=_eeda ._bee [len (_adgf ):];_eeda ._bee =append ([]*_gd .PdfPage {},_edec ...);_eeda ._bee =append (_eeda ._bee ,_cec ...);_eeda ._bee =append (_eeda ._bee ,_afff ...);}else {_eeda ._bee =append (_cec ,_eeda ._bee ...);};};if _eeda ._eagf !=nil &&_eeda .AddOutlines {var _gdcb func (_efbc *_gd .OutlineItem );
_gdcb =func (_afdc *_gd .OutlineItem ){_afdc .Dest .Page +=int64 (_dde );if _affg :=int (_afdc .Dest .Page );_affg >=0&&_affg < len (_eeda ._bee ){_afdc .Dest .PageObj =_eeda ._bee [_affg ].GetPageAsIndirectObject ();}else {_ca .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_affg );
};_afdc .Dest .Y =_eeda ._defa -_afdc .Dest .Y ;_cgaa :=_afdc .Items ();for _ ,_ggfab :=range _cgaa {_gdcb (_ggfab );};};_facd :=_eeda ._eagf .Items ();for _ ,_egda :=range _facd {_gdcb (_egda );};if _eeda .AddTOC {var _cdb int ;if _daee {_cdb =len (_adgf );
};_bade :=_gd .NewOutlineDest (int64 (_cdb ),0,_eeda ._defa );if _cdb >=0&&_cdb < len (_eeda ._bee ){_bade .PageObj =_eeda ._bee [_cdb ].GetPageAsIndirectObject ();}else {_ca .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_cdb );
};_eeda ._eagf .Insert (0,_gd .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_bade ));};};for _afce ,_cbeg :=range _eeda ._bee {_eeda .setActivePage (_cbeg );if _eeda ._bdfe !=nil {_bgfef ,_beee ,_faff :=_cbeg .Size ();
if _faff !=nil {return _faff ;};_fdgd :=PageFinalizeFunctionArgs {PageNum :_afce +1,PageWidth :_bgfef ,PageHeight :_beee ,TOCPages :len (_cec ),TotalPages :_cagc };if _cddc :=_eeda ._bdfe (_fdgd );_cddc !=nil {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_cddc );
return _cddc ;};};if _eeda ._eee !=nil {_dgfd :=NewBlock (_eeda ._baec ,_eeda ._gffac .Top );_dggg :=HeaderFunctionArgs {PageNum :_afce +1,TotalPages :_cagc };_eeda ._eee (_dgfd ,_dggg );_dgfd .SetPos (0,0);if _gaa :=_eeda .Draw (_dgfd );_gaa !=nil {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_gaa );
return _gaa ;};};if _eeda ._fdc !=nil {_edgc :=NewBlock (_eeda ._baec ,_eeda ._gffac .Bottom );_gfda :=FooterFunctionArgs {PageNum :_afce +1,TotalPages :_cagc };_eeda ._fdc (_edgc ,_gfda );_edgc .SetPos (0,_eeda ._defa -_edgc ._ad );if _eea :=_eeda .Draw (_edgc );
_eea !=nil {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_eea );return _eea ;};};_eeee ,_ggbb :=_eeda ._gaf [_cbeg ];if _edd ,_badfa :=_eeda ._fafg [_cbeg ];
_badfa {if _ggbb {_eeee .transformBlock (_edd );};if _ecgbd :=_edd .drawToPage (_cbeg );_ecgbd !=nil {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_afce +1,_ecgbd );
return _ecgbd ;};};if _ggbb {if _gcfae :=_eeee .transformPage (_cbeg );_gcfae !=nil {_ca .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_gcfae );
return _gcfae ;};};};_eeda ._gbg =true ;return nil ;};func (_eaggb *Image )makeXObject ()error {_gggc ,_agfef :=_gd .NewXObjectImageFromImageLazy (_eaggb ._dgaaf ,nil ,_eaggb ._bdeb ,_eaggb ._bfbd );if _agfef !=nil {_ca .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_agfef );
return _agfef ;};_eaggb ._cbaag =_gggc ;return nil ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_cacbb *StyledParagraph )SetWidth (width float64 ){_cacbb ._cbcb =width ;_cacbb .wrapText ()};

// SetMarkedContentID sets marked content ID.
func (_agfe *Curve )SetMarkedContentID (mcid int64 )*_gd .KDict {_agfe ._dffa =&mcid ;_gffc :=_gd .NewKDictionary ();_gffc .S =_be .MakeName (_gd .StructureTypeFigure );_gffc .K =_be .MakeInteger (mcid );return _gffc ;};

// SetAnnotation sets an annotation on a TextChunk,
// this will replace any existing annotation that has been set.
// Supplying a nil value as parameter would clear all the annotations.
func (_bebad *TextChunk )SetAnnotation (annotation *_gd .PdfAnnotation ){if annotation ==nil {_bebad .ClearAnnotations ();}else {_bebad ._bcfe =[]*_gd .PdfAnnotation {annotation };};};

// SetLineWidth sets the line width.
func (_dbbd *Line )SetLineWidth (width float64 ){_dbbd ._adcb =width };

// AddLine appends a new line to the invoice line items table.
func (_egdd *Invoice )AddLine (values ...string )[]*InvoiceCell {_cegfd :=len (_egdd ._gbbc );var _caab []*InvoiceCell ;for _gcebdg ,_abbd :=range values {_fabb :=_egdd .newCell (_abbd ,_egdd ._ddce );if _gcebdg < _cegfd {_fabb .Alignment =_egdd ._gbbc [_gcebdg ].Alignment ;
};_caab =append (_caab ,_fabb );};_egdd ._gdfd =append (_egdd ._gdfd ,_caab );return _caab ;};func _bcecf (_dfag ,_gcddg ,_eacb float64 )(_gfff ,_fbcgf ,_fabda ,_gdad float64 ){if _eacb ==0{return 0,0,_dfag ,_gcddg ;};_ecfcd :=_ddb .Path {Points :[]_ddb .Point {_ddb .NewPoint (0,0).Rotate (_eacb ),_ddb .NewPoint (_dfag ,0).Rotate (_eacb ),_ddb .NewPoint (0,_gcddg ).Rotate (_eacb ),_ddb .NewPoint (_dfag ,_gcddg ).Rotate (_eacb )}}.GetBoundingBox ();
return _ecfcd .X ,_ecfcd .Y ,_ecfcd .Width ,_ecfcd .Height ;};

// NewInvoice returns an instance of an empty invoice.
func (_dfacb *Creator )NewInvoice ()*Invoice {_gffb :=_dfacb .NewTextStyle ();_gffb .Font =_dfacb ._gafc ;return _ccbgg (_dfacb .NewTextStyle (),_gffb );};func _gfged (_eafce *templateProcessor ,_dccbc *templateNode )(interface{},error ){return _eafce .parseListMarker (_dccbc );
};type pageTransformations struct{_agce *_cbe .Matrix ;_fgfca bool ;_gfega bool ;};

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_ggdee *Rectangle )SetFitMode (fitMode FitMode ){_ggdee ._dfgc =fitMode };

// SetLineOpacity sets the line opacity.
func (_bfeb *Polyline )SetLineOpacity (opacity float64 ){_bfeb ._aegga =opacity };

// SetBorderColor sets border color of the rectangle.
func (_cgcbf *Rectangle )SetBorderColor (col Color ){_cgcbf ._aagf =col };func _gfdba (_afdcd *templateProcessor ,_egeeb *templateNode )(interface{},error ){return _afdcd .parseStyledParagraph (_egeeb );};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// SetSellerAddress sets the seller address of the invoice.
func (_cdgfc *Invoice )SetSellerAddress (address *InvoiceAddress ){_cdgfc ._afbf =address };

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_fcdag *StyledParagraph )SetLanguageIdentifier (id string ){_fcdag ._abce =id };

// TitleStyle returns the style properties used to render the invoice title.
func (_bcaba *Invoice )TitleStyle ()TextStyle {return _bcaba ._fcbed };func _cbgg (_ccbe *Table ,_edfea DrawContext )([]*Block ,DrawContext ,error ){var _dgde []*Block ;_ceaaac :=NewBlock (_edfea .PageWidth ,_edfea .PageHeight );_ccbe .updateRowHeights (_edfea .Width -_ccbe ._ccecg .Left -_ccbe ._ccecg .Right );
_befb :=_ccbe ._ccecg .Top ;if _ccbe ._ccdf .IsRelative ()&&!_ccbe ._ebcgb {_begf :=_ccbe .Height ();if _begf > _edfea .Height -_ccbe ._ccecg .Top &&_begf <=_edfea .PageHeight -_edfea .Margins .Top -_edfea .Margins .Bottom {_dgde =[]*Block {NewBlock (_edfea .PageWidth ,_edfea .PageHeight -_edfea .Y )};
var _eafdc error ;if _ ,_edfea ,_eafdc =_addgg ().GeneratePageBlocks (_edfea );_eafdc !=nil {return nil ,_edfea ,_eafdc ;};_befb =0;};};_aega :=_edfea ;if _ccbe ._ccdf .IsAbsolute (){_edfea .X =_ccbe ._dece ;_edfea .Y =_ccbe ._aeff ;}else {_edfea .X +=_ccbe ._ccecg .Left ;
_edfea .Y +=_befb ;_edfea .Width -=_ccbe ._ccecg .Left +_ccbe ._ccecg .Right ;_edfea .Height -=_befb ;};_cbdg :=_edfea .Width ;_cbfaa :=_edfea .X ;_dace :=_edfea .Y ;_cddg :=_edfea .Height ;_ddeab :=0;_fecd ,_debef :=-1,-1;if _ccbe ._fbbbb {for _caaba ,_bggd :=range _ccbe ._gedg {if _bggd ._fgcga < _ccbe ._bccfd {continue ;
};if _bggd ._fgcga > _ccbe ._deceb {break ;};if _fecd < 0{_fecd =_caaba ;};_debef =_caaba ;};};if _gfbad :=_ccbe .wrapContent (_edfea );_gfbad !=nil {return nil ,_edfea ,_gfbad ;};_ccbe .updateRowHeights (_edfea .Width -_ccbe ._ccecg .Left -_ccbe ._ccecg .Right );
var (_gfbb bool ;_cebcg int ;_egdad int ;_bbfce bool ;_acbbc int ;_egab error ;);for _aadfb :=0;_aadfb < len (_ccbe ._gedg );_aadfb ++{_dbed :=_ccbe ._gedg [_aadfb ];if _gcebf ,_dfbe :=_ccbe .getLastCellFromCol (_dbed ._gggbbd );_gcebf ==_aadfb {if (_dfbe ._fgcga +_dfbe ._edegf -1)< _ccbe ._addf {for _ccgd :=_dbed ._fgcga ;
_ccgd < _ccbe ._addf ;_ccgd ++{_afgdc :=&TableCell {};_afgdc ._fgcga =_ccgd +1;_afgdc ._edegf =1;_afgdc ._gggbbd =_dbed ._gggbbd ;_ccbe ._gedg =append (_ccbe ._gedg ,_afgdc );};};};_dfbbg :=_dbed .width (_ccbe ._faae ,_cbdg );_dbfa :=float64 (0.0);for _dfgb :=0;
_dfgb < _dbed ._gggbbd -1;_dfgb ++{_dbfa +=_ccbe ._faae [_dfgb ]*_cbdg ;};_eddaf :=float64 (0.0);for _cbgdb :=_ddeab ;_cbgdb < _dbed ._fgcga -1;_cbgdb ++{_eddaf +=_ccbe ._gadc [_cbgdb ];};_edfea .Height =_cddg -_eddaf ;_abbea :=float64 (0.0);for _dbbgd :=0;
_dbbgd < _dbed ._edegf ;_dbbgd ++{_abbea +=_ccbe ._gadc [_dbed ._fgcga +_dbbgd -1];};_ffcf :=_bbfce &&_dbed ._fgcga !=_acbbc ;_acbbc =_dbed ._fgcga ;if _ffcf ||_abbea > _edfea .Height {if _ccbe ._ffeag &&!_bbfce {_bbfce ,_egab =_ccbe .wrapRow (_aadfb ,_edfea ,_cbdg );
if _egab !=nil {return nil ,_edfea ,_egab ;};if _bbfce {_aadfb --;continue ;};};_dgde =append (_dgde ,_ceaaac );_ceaaac =NewBlock (_edfea .PageWidth ,_edfea .PageHeight );_cbfaa =_edfea .Margins .Left +_ccbe ._ccecg .Left ;_dace =_edfea .Margins .Top ;
_edfea .Height =_edfea .PageHeight -_edfea .Margins .Top -_edfea .Margins .Bottom ;_edfea .Page ++;_cddg =_edfea .Height ;_ddeab =_dbed ._fgcga -1;_eddaf =0;_bbfce =false ;if _ccbe ._fbbbb &&_fecd >=0{_cebcg =_aadfb ;_aadfb =_fecd -1;_egdad =_ddeab ;_ddeab =_ccbe ._bccfd -1;
_gfbb =true ;if _dbed ._edegf > (_ccbe ._addf -_acbbc )||(_dbed ._edegf > 1&&_aadfb < 0){_ca .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_gfbb =false ;_fecd ,_debef =-1,-1;};continue ;};if _ffcf {_aadfb --;continue ;};};_edfea .Width =_dfbbg ;_edfea .X =_cbfaa +_dbfa ;_edfea .Y =_dace +_eddaf ;if _abbea > _edfea .PageHeight -_edfea .Margins .Top -_edfea .Margins .Bottom {_abbea =_edfea .PageHeight -_edfea .Margins .Top -_edfea .Margins .Bottom ;
};_faede :=_gdgf (_edfea .X ,_edfea .Y ,_dfbbg ,_abbea );if _dbed ._ceege !=nil {_faede .SetFillColor (_dbed ._ceege );};_faede .LineStyle =_dbed ._aecgdc ;_faede ._fgfc =_dbed ._bddcf ;_faede ._cbgf =_dbed ._deef ;_faede ._gdgg =_dbed ._gcccg ;_faede ._dcd =_dbed ._dgag ;
if _dbed ._edgac !=nil {_faede .SetColorLeft (_dbed ._edgac );};if _dbed ._daea !=nil {_faede .SetColorBottom (_dbed ._daea );};if _dbed ._cada !=nil {_faede .SetColorRight (_dbed ._cada );};if _dbed ._agcef !=nil {_faede .SetColorTop (_dbed ._agcef );
};_faede .SetWidthBottom (_dbed ._acdc );_faede .SetWidthLeft (_dbed ._debdc );_faede .SetWidthRight (_dbed ._gecc );_faede .SetWidthTop (_dbed ._efec );_geea :=NewBlock (_ceaaac ._de ,_ceaaac ._ad );_fdgbd :=_ceaaac .Draw (_faede );if _fdgbd !=nil {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fdgbd );
};if _dbed ._bdea !=nil {_fgeg :=_dbed ._bdea .Width ();_caffd :=_dbed ._bdea .Height ();_fcee :=0.0;switch _dbde :=_dbed ._bdea .(type ){case *Paragraph :if _dbde ._abaa {_fgeg =_dbde .getMaxLineWidth ()/1000.0;};_bgfdd ,_edcd ,_ :=_dbde .getTextMetrics ();
_fcaec ,_aada :=_bgfdd *_dbde ._agdbb ,_edcd *_dbde ._agdbb ;_caffd =_caffd -_aada +_fcaec ;_fcee +=_fcaec -_aada ;_bdfba :=0.5;if _ccbe ._ggab {_bdfba =0.3;};switch _dbed ._bdcca {case CellVerticalAlignmentTop :_fcee +=_fcaec *_bdfba ;case CellVerticalAlignmentBottom :_fcee -=_fcaec *_bdfba ;
};_fgeg +=_dbde ._cgacg .Left +_dbde ._cgacg .Right ;_caffd +=_dbde ._cgacg .Top +_dbde ._cgacg .Bottom ;case *StyledParagraph :if _dbde ._egbgc {_fgeg =_dbde .getMaxLineWidth ()/1000.0;};_dbgee ,_abbcb ,_fefccd :=_dbde .getLineMetrics (0);_fdcba ,_cbda :=_dbgee *_dbde ._bcde ,_abbcb *_dbde ._bcde ;
if _dbde ._eeedb ==TextVerticalAlignmentCenter {_fcee =_cbda -(_abbcb +(_dbgee +_fefccd -_abbcb )/2+(_cbda -_abbcb )/2);};if len (_dbde ._ccae )==1{_caffd =_fdcba ;}else {_caffd =_caffd -_cbda +_fdcba ;};_fcee +=_fdcba -_cbda ;switch _dbed ._bdcca {case CellVerticalAlignmentTop :_fcee +=_fdcba *0.5;
case CellVerticalAlignmentBottom :_fcee -=_fdcba *0.5;};_fgeg +=_dbde ._affa .Left +_dbde ._affa .Right ;_caffd +=_dbde ._affa .Top +_dbde ._affa .Bottom ;case *Table :_fgeg =_dfbbg ;case *List :_fgeg =_dfbbg ;case *Division :_fgeg =_dfbbg ;case *Chart :_fgeg =_dfbbg ;
case *Line :_caffd +=_dbde ._cbeb .Top +_dbde ._cbeb .Bottom ;_fcee -=_dbde .Height ()/2;case *Image :_fgeg +=_dbde ._fcad .Left +_dbde ._fcad .Right ;_caffd +=_dbde ._fcad .Top +_dbde ._fcad .Bottom ;};switch _dbed ._bebbe {case CellHorizontalAlignmentLeft :_edfea .X +=_dbed ._adeb ;
_edfea .Width -=_dbed ._adeb ;case CellHorizontalAlignmentCenter :if _cgegb :=_dfbbg -_fgeg ;_cgegb > 0{_edfea .X +=_cgegb /2;_edfea .Width -=_cgegb /2;};case CellHorizontalAlignmentRight :if _dfbbg > _fgeg {_edfea .X =_edfea .X +_dfbbg -_fgeg -_dbed ._adeb ;
_edfea .Width -=_dbed ._adeb ;};};_fded :=_edfea .Y ;_efcd :=_edfea .Height ;_edfea .Y +=_fcee ;switch _dbed ._bdcca {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _dabab :=_abbea -_caffd ;_dabab > 0{_edfea .Y +=_dabab /2;_edfea .Height -=_dabab /2;
};case CellVerticalAlignmentBottom :if _abbea > _caffd {_edfea .Y =_edfea .Y +_abbea -_caffd ;_edfea .Height =_abbea ;};};_gffge :=_ceaaac .DrawWithContext (_dbed ._bdea ,_edfea );if _gffge !=nil {if _fc .Is (_gffge ,ErrContentNotFit )&&!_ffcf {_ceaaac =_geea ;
_ffcf =true ;_aadfb --;continue ;};_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gffge );};_edfea .Y =_fded ;_edfea .Height =_efcd ;};_edfea .Y +=_abbea ;_edfea .Height -=_abbea ;if _gfbb &&_aadfb +1> _debef {_dace +=_eddaf +_abbea ;
_cddg -=_abbea +_eddaf ;_ddeab =_egdad ;_aadfb =_cebcg -1;_gfbb =false ;};};_dgde =append (_dgde ,_ceaaac );if _ccbe ._ccdf .IsAbsolute (){return _dgde ,_aega ,nil ;};_edfea .X =_aega .X ;_edfea .Width =_aega .Width ;_edfea .Y +=_ccbe ._ccecg .Bottom ;
_edfea .Height -=_ccbe ._ccecg .Bottom ;return _dgde ,_edfea ,nil ;};

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_eccgae *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_eccgae ._dffg .Left =left ;_eccgae ._dffg .Right =right ;_eccgae ._dffg .Top =top ;_eccgae ._dffg .Bottom =bottom ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_aca *Block )SetMargins (left ,right ,top ,bottom float64 ){_aca ._bc .Left =left ;_aca ._bc .Right =right ;_aca ._bc .Top =top ;_aca ._bc .Bottom =bottom ;};func _bdab (_gfedg *Block ,_dgbb *Image ,_gcab DrawContext )(DrawContext ,error ){_aaec :=_gcab ;
_adge :=1;_ddde :=_be .PdfObjectName (_f .Sprintf ("\u0049\u006d\u0067%\u0064",_adge ));for _gfedg ._fa .HasXObjectByName (_ddde ){_adge ++;_ddde =_be .PdfObjectName (_f .Sprintf ("\u0049\u006d\u0067%\u0064",_adge ));};_gbcg :=_gfedg ._fa .SetXObjectImageByNameLazy (_ddde ,_dgbb ._cbaag ,_dgbb ._bfbd );
if _gbcg !=nil {return _gcab ,_gbcg ;};_gaee :=0;_aabd :=_be .PdfObjectName (_f .Sprintf ("\u0047\u0053\u0025\u0064",_gaee ));for _gfedg ._fa .HasExtGState (_aabd ){_gaee ++;_aabd =_be .PdfObjectName (_f .Sprintf ("\u0047\u0053\u0025\u0064",_gaee ));};
_gagc :=_be .MakeDict ();_gagc .Set ("\u0042\u004d",_be .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _dgbb ._fgec < 1.0{_gagc .Set ("\u0043\u0041",_be .MakeFloat (_dgbb ._fgec ));_gagc .Set ("\u0063\u0061",_be .MakeFloat (_dgbb ._fgec ));};_gbcg =_gfedg ._fa .AddExtGState (_aabd ,_be .MakeIndirectObject (_gagc ));
if _gbcg !=nil {return _gcab ,_gbcg ;};_cgeg :=_dgbb .Width ();_gcddc :=_dgbb .Height ();_ ,_fdea :=_dgbb .rotatedSize ();_cdba :=_gcab .X ;_dbac :=_gcab .PageHeight -_gcab .Y -_gcddc ;if _dgbb ._dbafc .IsRelative (){_dbac -=(_fdea -_gcddc )/2;switch _dgbb ._ggaca {case HorizontalAlignmentCenter :_cdba +=(_gcab .Width -_cgeg )/2;
case HorizontalAlignmentRight :_cdba =_gcab .PageWidth -_gcab .Margins .Right -_dgbb ._fcad .Right -_cgeg ;};};_feba :=_dgbb ._afgb ;_ddeb :=_eag .NewContentCreator ();if _dgbb ._cebad !=nil {_ddeb .Add_BDC (*_be .MakeName (_gd .StructureTypeFigure ),map[string ]_be .PdfObject {"\u004d\u0043\u0049\u0044":_be .MakeInteger (*_dgbb ._cebad )});
};_ddeb .Add_gs (_aabd );_ddeb .Translate (_cdba ,_dbac );if _feba !=0{_ddeb .Translate (_cgeg /2,_gcddc /2);_ddeb .RotateDeg (_feba );_ddeb .Translate (-_cgeg /2,-_gcddc /2);};_ddeb .Scale (_cgeg ,_gcddc ).Add_Do (_ddde );if _dgbb ._cebad !=nil {_ddeb .Add_EMC ();
};_bgad :=_ddeb .Operations ();_bgad .WrapIfNeeded ();_gfedg .addContents (_bgad );if _dgbb ._dbafc .IsRelative (){_gcab .Y +=_fdea ;_gcab .Height -=_fdea ;return _gcab ,nil ;};return _aaec ,nil ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default, it occupies the available width in the drawing context.
type Paragraph struct{_bcgag string ;_caccd *_gd .PdfFont ;_geac float64 ;_agdbb float64 ;_ebbg Color ;_eced TextAlignment ;_abaa bool ;_gba float64 ;_gdef int ;_aagb bool ;_ggc float64 ;_cgacg Margins ;_adfd Positioning ;_dagaa float64 ;_dcag float64 ;
_babg ,_bcadb float64 ;_beag []string ;_bafa *int64 ;_fbbdg string ;};

// IsAbsolute checks if the positioning is absolute.
func (_caga Positioning )IsAbsolute ()bool {return _caga ==PositionAbsolute };

// GeneratePageBlocks draws the curve onto page blocks.
func (_bddb *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dabd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bcac :=_eag .NewContentCreator ();if _bddb ._dffa !=nil {_bcac .Add_BDC (*_be .MakeName (_gd .StructureTypeFigure ),map[string ]_be .PdfObject {"\u004d\u0043\u0049\u0044":_be .MakeInteger (*_bddb ._dffa )});
};_bcac .Add_q ().Add_w (_bddb ._bdag ).SetStrokingColor (_fac (_bddb ._gffeeb )).Add_m (_bddb ._eded ,ctx .PageHeight -_bddb ._dbcd ).Add_v (_bddb ._efdba ,ctx .PageHeight -_bddb ._bacf ,_bddb ._ffea ,ctx .PageHeight -_bddb ._agefe ).Add_S ().Add_Q ();
if _bddb ._dffa !=nil {_bcac .Add_EMC ();};_cafbb :=_dabd .addContentsByString (_bcac .String ());if _cafbb !=nil {return nil ,ctx ,_cafbb ;};return []*Block {_dabd },ctx ,nil ;};

// SetBorderColor sets the border color.
func (_dbbg *CurvePolygon )SetBorderColor (color Color ){_dbbg ._fbff .BorderColor =_fac (color )};

// SetInline sets the inline mode of the division.
func (_facb *Division )SetInline (inline bool ){_facb ._dccc =inline };const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_dabeb *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_dabeb ._bdcca =valign };func (_eegbe *Table )moveToNextAvailableCell ()int {_ebdad :=(_eegbe ._eaeec -1)%(_eegbe ._cafcb )+1;for {if _ebdad -1>=len (_eegbe ._gaad ){if _eegbe ._gaad [0]==0{return _ebdad ;
};_ebdad =1;}else if _eegbe ._gaad [_ebdad -1]==0{return _ebdad ;};_eegbe ._eaeec ++;_eegbe ._gaad [_ebdad -1]--;_ebdad ++;};};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_ccccf *Creator )NewParagraph (text string )*Paragraph {return _dafab (text ,_ccccf .NewTextStyle ());};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };
PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_fabfc *Table )MultiColCell (colspan int )*TableCell {return _fabfc .MultiCell (1,colspan )};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_ceda *Invoice )SetColumns (cols []*InvoiceCell ){_ceda ._gbbc =cols };

// SkipCells skips over a specified number of cells in the table.
func (_gabd *Table )SkipCells (num int ){if num < 0{_ca .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _baee :=0;_baee < num ;_baee ++{_gabd .NewCell ();};};

// SetFillColor sets the fill color.
func (_gdgea *Polygon )SetFillColor (color Color ){_gdgea ._aafdc =color ;_gdgea ._dbfd .FillColor =_fac (color );};

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_bccg *Table )MultiRowCell (rowspan int )*TableCell {return _bccg .MultiCell (rowspan ,1)};

// SetBorderOpacity sets the border opacity.
func (_afacg *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_afacg ._acfb =opacity };

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_bgge *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_bgge ._dfdg .Left =left ;_bgge ._dfdg .Right =right ;_bgge ._dfdg .Top =top ;_bgge ._dfdg .Bottom =bottom ;};

// GetRowHeight returns the height of the specified row.
func (_cabe *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_cabe ._gadc ){return 0,_fc .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _cabe ._gadc [row -1],nil ;
};

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_bbcaf *Rectangle )ScaleToWidth (w float64 ){_gffab :=_bbcaf ._ddccd /_bbcaf ._dacdg ;_bbcaf ._dacdg =w ;_bbcaf ._ddccd =w *_gffab ;};func (_eafg *Division )split (_cffb DrawContext )(_ccgcc ,_cfa *Division ){var (_fbcf float64 ;_acfd ,_fbde []VectorDrawable ;
);_bdbba :=_cffb .Width -_eafg ._fceg .Left -_eafg ._fceg .Right -_eafg ._dcfb .Left -_eafg ._dcfb .Right ;for _edea ,_fdbg :=range _eafg ._cggf {_fbcf +=_ccac (_fdbg ,_bdbba );if _fbcf < _cffb .Height {_acfd =append (_acfd ,_fdbg );}else {_fbde =_eafg ._cggf [_edea :];
break ;};};if len (_acfd )> 0{_ccgcc =_cfgb ();*_ccgcc =*_eafg ;_ccgcc ._cggf =_acfd ;if _eafg ._bacfc !=nil {_ccgcc ._bacfc =&Background {};*_ccgcc ._bacfc =*_eafg ._bacfc ;};};if len (_fbde )> 0{_cfa =_cfgb ();*_cfa =*_eafg ;_cfa ._cggf =_fbde ;if _eafg ._bacfc !=nil {_cfa ._bacfc =&Background {};
*_cfa ._bacfc =*_eafg ._bacfc ;};};return _ccgcc ,_cfa ;};

// SetNotes sets the notes section of the invoice.
func (_cbdb *Invoice )SetNotes (title ,content string ){_cbdb ._cdbg =[2]string {title ,content }};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_addgd *Invoice )Sections ()[][2]string {return _addgd ._dbef };

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_gggde *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aadc :=ctx ;var _dfce []*Block ;_cggfa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _gggde ._abab .IsRelative (){ctx .X +=_gggde ._affa .Left ;ctx .Y +=_gggde ._affa .Top ;
ctx .Width -=_gggde ._affa .Left +_gggde ._affa .Right ;ctx .Height -=_gggde ._affa .Top ;_gggde .SetWidth (ctx .Width );}else {if int (_gggde ._cbcb )<=0{_gggde .SetWidth (_gggde .getTextWidth ()/1000.0);};ctx .X =_gggde ._cabcd ;ctx .Y =_gggde ._ccde ;
};if _gggde ._bfbe !=nil {_gggde ._bfbe (_gggde ,ctx );};if _fcfd :=_gggde .wrapText ();_fcfd !=nil {return nil ,ctx ,_fcfd ;};_acfde :=_gggde ._ccae ;_gabaa :=0;for {_bddg ,_edgef ,_bdbfa :=_efca (_cggfa ,_gggde ,_acfde ,ctx );if _bdbfa !=nil {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bdbfa );
return nil ,ctx ,_bdbfa ;};ctx =_bddg ;_dfce =append (_dfce ,_cggfa );if _acfde =_edgef ;len (_edgef )==0{break ;};if len (_edgef )==_gabaa {return nil ,ctx ,_fc .New ("\u006e\u006f\u0074\u0020\u0065\u006e\u006f\u0075\u0067\u0068 \u0073\u0070\u0061\u0063\u0065\u0020\u0066o\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068");
};_cggfa =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_bddg =ctx ;_bddg .Y =ctx .Margins .Top ;_bddg .X =ctx .Margins .Left +_gggde ._affa .Left ;_bddg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_bddg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gggde ._affa .Left -_gggde ._affa .Right ;
ctx =_bddg ;_gabaa =len (_edgef );};if _gggde ._abab .IsRelative (){ctx .Y +=_gggde ._affa .Bottom ;ctx .Height -=_gggde ._affa .Bottom ;if !ctx .Inline {ctx .X =_aadc .X ;ctx .Width =_aadc .Width ;};return _dfce ,ctx ,nil ;};return _dfce ,_aadc ,nil ;
};

// SetEnableWrap sets the line wrapping enabled flag.
func (_aaaee *StyledParagraph )SetEnableWrap (enableWrap bool ){_aaaee ._egbgc =enableWrap ;_aaaee ._baceb =false ;};func _gdcg (_eafb int )*Table {_bfge :=&Table {_cafcb :_eafb ,_aedbd :10.0,_faae :[]float64 {},_gadc :[]float64 {},_gedg :[]*TableCell {},_gaad :make ([]int ,_eafb ),_ebcgb :true };
_bfge .resetColumnWidths ();return _bfge ;};

// SetAngle sets Image rotation angle in degrees.
func (_becc *Image )SetAngle (angle float64 ){_becc ._afgb =angle };

// AddColorStop add color stop info for rendering gradient color.
func (_dbaed *RadialShading )AddColorStop (color Color ,point float64 ){_dbaed ._ffcg .AddColorStop (color ,point );};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_eeccd *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _eeccd ._cegfg [0],_eeccd ._cegfg [1]};

// Reset removes all the text chunks the paragraph contains.
func (_ecgec *StyledParagraph )Reset (){_ecgec ._bcbc =[]*TextChunk {}};func _caacc (_cbgda *templateProcessor ,_gbbgc *templateNode )(interface{},error ){return _cbgda .parseBackground (_gbbgc );};func _gdgf (_gefde ,_cege ,_dgfb ,_ddbd float64 )*border {_ddbgc :=&border {};
_ddbgc ._ffa =_gefde ;_ddbgc ._cbc =_cege ;_ddbgc ._dc =_dgfb ;_ddbgc ._ggb =_ddbd ;_ddbgc ._ed =ColorBlack ;_ddbgc ._bfde =ColorBlack ;_ddbgc ._fed =ColorBlack ;_ddbgc ._gcg =ColorBlack ;_ddbgc ._egeb =0;_ddbgc ._fcec =0;_ddbgc ._cgd =0;_ddbgc ._dggc =0;
_ddbgc .LineStyle =_ddb .LineStyleSolid ;return _ddbgc ;};func (_ccfe *Image )applyFitMode (_fgcb float64 ){_fgcb -=_ccfe ._fcad .Left +_ccfe ._fcad .Right ;switch _ccfe ._gfba {case FitModeFillWidth :_ccfe .ScaleToWidth (_fgcb );};};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_bedf *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_dbee *_gd .PdfWriter )error ){_bedf ._eaa =pdfWriterAccessFunc ;};

// SetPos sets absolute positioning with specified coordinates.
func (_acccde *Paragraph )SetPos (x ,y float64 ){_acccde ._adfd =PositionAbsolute ;_acccde ._dagaa =x ;_acccde ._dcag =y ;};

// AddColorStop add color stop information for rendering gradient.
func (_gfeb *shading )AddColorStop (color Color ,point float64 ){_gfeb ._agcac =append (_gfeb ._agcac ,_cgeb (color ,point ));};func (_fgcg *Creator )newPage ()*_gd .PdfPage {_dcbb :=_gd .NewPdfPage ();_cccbb :=_fgcg ._gfed [0];_gdba :=_fgcg ._gfed [1];
_egd :=_gd .PdfRectangle {Llx :0,Lly :0,Urx :_cccbb ,Ury :_gdba };_dcbb .MediaBox =&_egd ;_fgcg ._baec =_cccbb ;_fgcg ._defa =_gdba ;_fgcg .initContext ();return _dcbb ;};

// SetTitle sets the title of the invoice.
func (_ebbf *Invoice )SetTitle (title string ){_ebbf ._bgfbda =title };func (_dff rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _dff ._afd ,_dff ._fef ,_dff ._cbbf };

// AddSection adds a new content section at the end of the invoice.
func (_debc *Invoice )AddSection (title ,content string ){_debc ._dbef =append (_debc ._dbef ,[2]string {title ,content });};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_adad *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _adad ._cbeb .Left ,_adad ._cbeb .Right ,_adad ._cbeb .Top ,_adad ._cbeb .Bottom ;};

// MoveY moves the drawing context to absolute position y.
func (_fbag *Creator )MoveY (y float64 ){_fbag ._ecfb .Y =y };var PPI float64 =72;

// SetMarkedContentID sets the marked content id for the list.
func (_cgdaf *List )SetMarkedContentID (id int64 )*_gd .KDict {return nil };

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_ffgf *Rectangle )ScaleToHeight (h float64 ){_bgae :=_ffgf ._dacdg /_ffgf ._ddccd ;_ffgf ._ddccd =h ;_ffgf ._dacdg =h *_bgae ;};

// Cols returns the total number of columns the table has.
func (_afgbe *Table )Cols ()int {return _afgbe ._cafcb };

// Vertical returns total vertical (top + bottom) margin.
func (_bdfff *Margins )Vertical ()float64 {return _bdfff .Bottom +_bdfff .Top };

// Columns returns all the columns in the invoice line items table.
func (_ddda *Invoice )Columns ()[]*InvoiceCell {return _ddda ._gbbc };

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_gbac *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_gbac ._gagb =&_gd .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// SetStyle sets the style of the line (solid or dashed).
func (_eggc *Line )SetStyle (style _ddb .LineStyle ){_eggc ._dddcg =style };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_ddcbfc *Table )NewCell ()*TableCell {return _ddcbfc .MultiCell (1,1)};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_baef *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_afbdf :=&_baef ._ecfeg ._affa ;return _baef ._gdcff ,_afbdf .Right ,_afbdf .Top ,_afbdf .Bottom ;};func _gdece (_faefg *templateProcessor ,_bcfd *templateNode )(interface{},error ){return _faefg .parseTableCell (_bcfd );
};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// Scale block by specified factors in the x and y directions.
func (_gbb *Block )Scale (sx ,sy float64 ){_ddg :=_eag .NewContentCreator ().Scale (sx ,sy ).Operations ();*_gbb ._ge =append (*_ddg ,*_gbb ._ge ...);_gbb ._ge .WrapIfNeeded ();_gbb ._de *=sx ;_gbb ._ad *=sy ;};

// SetMarkedContentID sets the marked content id for the paragraph.
func (_bdcg *Paragraph )SetMarkedContentID (mcid int64 )*_gd .KDict {_bdcg ._bafa =&mcid ;_dbebf :=_gd .NewKDictionary ();_dbebf .S =_be .MakeName ("\u0050");_dbebf .K =_be .MakeInteger (mcid );return _dbebf ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_adac *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_dgdd :=[2]*InvoiceCell {_adac .newCell (description ,_adac ._ffda ),_adac .newCell (value ,_adac ._ffda )};_adac ._ebf =append (_adac ._ebf ,_dgdd );return _dgdd [0],_dgdd [1];
};

// Margins returns the margins of the list: left, right, top, bottom.
func (_abbgg *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _abbgg ._edgdc .Left ,_abbgg ._edgdc .Right ,_abbgg ._edgdc .Top ,_abbgg ._edgdc .Bottom ;};

// SetMargins sets the margins of the paragraph.
func (_ecge *List )SetMargins (left ,right ,top ,bottom float64 ){_ecge ._edgdc .Left =left ;_ecge ._edgdc .Right =right ;_ecge ._edgdc .Top =top ;_ecge ._edgdc .Bottom =bottom ;};

// AddAnnotation adds an annotation on a TextChunk.
func (_ebcfe *TextChunk )AddAnnotation (annotation *_gd .PdfAnnotation ){if annotation ==nil {return ;};_ebcfe ._bcfe =append (_ebcfe ._bcfe ,annotation );};

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_cegff *Rectangle )SetPositioning (position Positioning ){_cegff ._dbdf =position };

// SetFillColor sets the fill color of the ellipse.
func (_afgg *Ellipse )SetFillColor (col Color ){_afgg ._cgcbc =col };

// NewSubchapter creates a new child chapter with the specified title.
func (_aaf *Chapter )NewSubchapter (title string )*Chapter {_ceab :=_dbdbf (_aaf ._adbf ._caccd );_ceab .FontSize =14;_aaf ._eec ++;_bde :=_dbaf (_aaf ,_aaf ._bbg ,_aaf ._acbg ,title ,_aaf ._eec ,_ceab );_aaf .Add (_bde );return _bde ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func (_acaac *templateProcessor )parseParagraph (_fcfa *templateNode ,_edfbd *Paragraph )(interface{},error ){if _edfbd ==nil {_edfbd =_acaac .creator .NewParagraph ("");};for _ ,_bfdg :=range _fcfa ._eccfd .Attr {_ddfe :=_bfdg .Value ;
switch _dfefd :=_bfdg .Name .Local ;_dfefd {case "\u0066\u006f\u006e\u0074":_edfbd .SetFont (_acaac .parseFontAttr (_dfefd ,_ddfe ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_edfbd .SetFontSize (_acaac .parseFloatAttr (_dfefd ,_ddfe ));case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_edfbd .SetTextAlignment (_acaac .parseTextAlignmentAttr (_dfefd ,_ddfe ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_edfbd .SetLineHeight (_acaac .parseFloatAttr (_dfefd ,_ddfe ));case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_edfbd .SetEnableWrap (_acaac .parseBoolAttr (_dfefd ,_ddfe ));
case "\u0063\u006f\u006co\u0072":_edfbd .SetColor (_acaac .parseColorAttr (_dfefd ,_ddfe ));case "\u0078":_edfbd .SetPos (_acaac .parseFloatAttr (_dfefd ,_ddfe ),_edfbd ._dcag );case "\u0079":_edfbd .SetPos (_edfbd ._dagaa ,_acaac .parseFloatAttr (_dfefd ,_ddfe ));
case "\u0061\u006e\u0067l\u0065":_edfbd .SetAngle (_acaac .parseFloatAttr (_dfefd ,_ddfe ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_gaab :=_acaac .parseMarginAttr (_dfefd ,_ddfe );_edfbd .SetMargins (_gaab .Left ,_gaab .Right ,_gaab .Top ,_gaab .Bottom );
case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_edfbd .SetMaxLines (int (_acaac .parseInt64Attr (_dfefd ,_ddfe )));default:_acaac .nodeLogDebug (_fcfa ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_dfefd );
};};return _edfbd ,nil ;};func (_agec *Paragraph )wrapText ()error {if !_agec ._abaa ||int (_agec ._gba )<=0{_agec ._beag =[]string {_agec ._bcgag };return nil ;};_aefe :=NewTextChunk (_agec ._bcgag ,TextStyle {Font :_agec ._caccd ,FontSize :_agec ._geac });
_bffe ,_bdbd :=_aefe .Wrap (_agec ._gba );if _bdbd !=nil {return _bdbd ;};if _agec ._gdef > 0&&len (_bffe )> _agec ._gdef {_bffe =_bffe [:_agec ._gdef ];};_agec ._beag =_bffe ;return nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_edb *Paragraph )SetLineHeight (lineheight float64 ){_edb ._agdbb =lineheight };

// AddLine adds a new line with the provided style to the table of contents.
func (_afbed *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_afbed ._gfcc =append (_afbed ._gfcc ,line );return line ;};func (_aabe *TableCell )width (_geaf []float64 ,_gcff float64 )float64 {_edgaf :=float64 (0.0);for _cdac :=0;_cdac < _aabe ._ffebf ;
_cdac ++{_edgaf +=_geaf [_aabe ._gggbbd +_cdac -1];};return _edgaf *_gcff ;};

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_gddgf *StyledParagraph )SetTextAlignment (align TextAlignment ){_gddgf ._abff =align };

// NewTOC creates a new table of contents.
func (_caac *Creator )NewTOC (title string )*TOC {_ccbc :=_caac .NewTextStyle ();_ccbc .Font =_caac ._gafc ;return _cgcff (title ,_caac .NewTextStyle (),_ccbc );};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_ebed *RadialShading )ToPdfShadingPattern ()*_gd .PdfShadingPatternType3 {_fagb ,_acdb ,_affd :=_ebed ._ffcg ._bbdfc .ToRGB ();_bbdeg :=_ebed .shadingModel ();_bbdeg .PdfShading .Background =_be .MakeArrayFromFloats ([]float64 {_fagb ,_acdb ,_affd });
_geaee :=_gd .NewPdfShadingPatternType3 ();_geaee .Shading =_bbdeg ;return _geaee ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_bcgb *Creator )NewImage (img *_gd .Image )(*Image ,error ){return _bddd (img )};func (_eggdd *TableCell )cloneProps (_gagcb VectorDrawable )*TableCell {_ecce :=*_eggdd ;_ecce ._bdea =_gagcb ;return &_ecce ;};

// String implements error interface.
func (_adbg UnsupportedRuneError )Error ()string {return _adbg .Message };

// Lines returns all the rows of the invoice line items table.
func (_gdgab *Invoice )Lines ()[][]*InvoiceCell {return _gdgab ._gdfd };func _aedcd (_bbfbe TextStyle )*StyledParagraph {return &StyledParagraph {_bcbc :[]*TextChunk {},_cggd :_bbfbe ,_debd :_cfbbd (_bbfbe .Font ),_bcde :1.0,_abff :TextAlignmentLeft ,_egbgc :true ,_baceb :true ,_fecad :false ,_cbace :0,_efea :1,_abag :1,_abab :PositionRelative ,_abce :""};
};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_caec *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _caec ._cecdb [0],_caec ._cecdb [1]};

// Height returns the current page height.
func (_dcac *Creator )Height ()float64 {return _dcac ._defa };

// NewCurvePolygon creates a new curve polygon.
func (_cefd *Creator )NewCurvePolygon (rings [][]_ddb .CubicBezierCurve )*CurvePolygon {return _ebcd (rings );};func (_ffcbf *templateProcessor )parseImage (_fdfdd *templateNode )(interface{},error ){var _cfbdb string ;for _ ,_gaegg :=range _fdfdd ._eccfd .Attr {_fgcdd :=_gaegg .Value ;
switch _gggga :=_gaegg .Name .Local ;_gggga {case "\u0073\u0072\u0063":_cfbdb =_fgcdd ;};};_bdccf ,_fdgcb :=_ffcbf .loadImageFromSrc (_cfbdb );if _fdgcb !=nil {return nil ,_fdgcb ;};var _egddc _be .StreamEncoder ;_geaca :=_ddf .ToLower (_c .Ext (_cfbdb ));
if _geaca =="\u006a\u0070\u0067"||_geaca =="\u006a\u0070\u0065\u0067"{_egddc =_be .NewDCTEncoder ();}else {_egddc =_be .NewFlateEncoder ();};_bdccf .SetEncoder (_egddc );for _ ,_cadab :=range _fdfdd ._eccfd .Attr {_fega :=_cadab .Value ;switch _dggad :=_cadab .Name .Local ;
_dggad {case "\u0061\u006c\u0069g\u006e":_bdccf .SetHorizontalAlignment (_ffcbf .parseHorizontalAlignmentAttr (_dggad ,_fega ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_bdccf .SetOpacity (_ffcbf .parseFloatAttr (_dggad ,_fega ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bgdge :=_ffcbf .parseMarginAttr (_dggad ,_fega );
_bdccf .SetMargins (_bgdge .Left ,_bgdge .Right ,_bgdge .Top ,_bgdge .Bottom );case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_bdccf .SetFitMode (_ffcbf .parseFitModeAttr (_dggad ,_fega ));case "\u0078":_bdccf .SetPos (_ffcbf .parseFloatAttr (_dggad ,_fega ),_bdccf ._bgabe );
case "\u0079":_bdccf .SetPos (_bdccf ._aeae ,_ffcbf .parseFloatAttr (_dggad ,_fega ));case "\u0077\u0069\u0064t\u0068":_bdccf .SetWidth (_ffcbf .parseFloatAttr (_dggad ,_fega ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_bdccf .SetHeight (_ffcbf .parseFloatAttr (_dggad ,_fega ));
case "\u0061\u006e\u0067l\u0065":_bdccf .SetAngle (_ffcbf .parseFloatAttr (_dggad ,_fega ));case "\u0065n\u0063\u006f\u0064\u0065\u0072":_egddc =_ffcbf .parseImageEncoder (_dggad ,_fega );if _egddc !=nil {_bdccf .SetEncoder (_egddc );};case "\u0073\u0072\u0063":break ;
default:_ffcbf .nodeLogDebug (_fdfdd ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_dggad );
};};return _bdccf ,nil ;};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_dgbee *List )Add (item VectorDrawable )(*TextChunk ,error ){_dadd :=&listItem {_cfec :item ,_gdeca :_dgbee ._cacc };switch _cegbg :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _cegbg ._gcbf {_cegbg ._eeccg =15;};case *Division :case *Image :case *Table :default:return nil ,_fc .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_dgbee ._fadf =append (_dgbee ._fadf ,_dadd );return &_dadd ._gdeca ,nil ;};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_gcggf *Table )EnablePageWrap (enable bool ){_gcggf ._ebcgb =enable };

// SetMakedContentID sets the marked content id for the table.
func (_defg *Table )SetMarkedContentID (mcid int64 )*_gd .KDict {return nil };

// SetBorderWidth sets the border width of the rectangle.
func (_fggd *Rectangle )SetBorderWidth (bw float64 ){_fggd ._bcdgg =bw };

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_dbg *Block )SetPos (x ,y float64 ){_dbg ._agg =PositionAbsolute ;_dbg ._eg =x ;_dbg ._bge =y };

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _fbb .ChartRenderable )*Chart {return _dfdb (chart )};func (_eacfa *templateProcessor )renderNode (_bcdb *templateNode )error {_gggecb :=_bcdb ._fdfd ;if _gggecb ==nil {return nil ;};_defab :=_bcdb ._eccfd .Name .Local ;_ebbadb ,_bfdbf :=_dfbbf [_defab ];
if !_bfdbf {_eacfa .nodeLogDebug (_bcdb ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_defab );return nil ;};var _gcddf interface{};if _bcdb ._ddbbd !=nil &&_bcdb ._ddbbd ._fdfd !=nil {_eacag :=_bcdb ._ddbbd ._eccfd .Name .Local ;
if _ ,_bfdbf =_ebbadb ._bfbgb [_eacag ];!_bfdbf {_eacfa .nodeLogDebug (_bcdb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_eacag ,_defab );
return _eeeee ;};_gcddf =_bcdb ._ddbbd ._fdfd ;}else {_fbgg :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _eacfa ._gfcf .(type ){case *Block :_fbgg ="\u0062\u006c\u006fc\u006b";};if _ ,_bfdbf =_ebbadb ._bfbgb [_fbgg ];!_bfdbf {_eacfa .nodeLogDebug (_bcdb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_fbgg ,_defab );
return _eeeee ;};_gcddf =_eacfa ._gfcf ;};switch _ggad :=_gcddf .(type ){case componentRenderer :_ecafc ,_babf :=_gggecb .(Drawable );if !_babf {_eacfa .nodeLogError (_bcdb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_defab ,_gggecb );
return _deegg ;};_addfd :=_ggad .Draw (_ecafc );if _addfd !=nil {return _eacfa .nodeError (_bcdb ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_defab ,_gggecb ,_addfd );
};case *Division :switch _fcdcd :=_gggecb .(type ){case *Background :_ggad .SetBackground (_fcdcd );case VectorDrawable :_cgcc :=_ggad .Add (_fcdcd );if _cgcc !=nil {return _eacfa .nodeError (_bcdb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_defab ,_gggecb ,_cgcc );
};};case *TableCell :_cfgd ,_fadg :=_gggecb .(VectorDrawable );if !_fadg {_eacfa .nodeLogError (_bcdb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_defab ,_gggecb );
return _deegg ;};_agge :=_ggad .SetContent (_cfgd );if _agge !=nil {return _eacfa .nodeError (_bcdb ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_defab ,_gggecb ,_agge );
};case *StyledParagraph :_dgdef ,_cefge :=_gggecb .(*TextChunk );if !_cefge {_eacfa .nodeLogError (_bcdb ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_defab ,_gggecb );
return _deegg ;};_ggad .appendChunk (_dgdef );case *Chapter :switch _ecagc :=_gggecb .(type ){case *Chapter :return nil ;case *Paragraph :if _bcdb ._eccfd .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_fcbf :=_ggad .Add (_ecagc );if _fcbf !=nil {return _eacfa .nodeError (_bcdb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_defab ,_gggecb ,_fcbf );
};case Drawable :_dbabf :=_ggad .Add (_ecagc );if _dbabf !=nil {return _eacfa .nodeError (_bcdb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_defab ,_gggecb ,_dbabf );
};};case *List :switch _aebec :=_gggecb .(type ){case *TextChunk :case *listItem :_ggad ._fadf =append (_ggad ._fadf ,_aebec );default:_eacfa .nodeLogError (_bcdb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_defab ,_gggecb );
};case *listItem :switch _dbgc :=_gggecb .(type ){case *TextChunk :case *StyledParagraph :_ggad ._cfec =_dbgc ;case *List :if _dbgc ._gcbf {_dbgc ._eeccg =15;};_ggad ._cfec =_dbgc ;case *Image :_ggad ._cfec =_dbgc ;case *Division :_ggad ._cfec =_dbgc ;
case *Table :_ggad ._cfec =_dbgc ;default:_eacfa .nodeLogError (_bcdb ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_defab ,_gggecb );
return _deegg ;};};return nil ;};const (DefaultHorizontalScaling =100;);

// SetStructTreeRoot sets the structure tree root to be appended in the document that will be created.
func (_dabf *Creator )SetStructTreeRoot (structTreeRoot *_gd .StructTreeRoot ){_dabf ._fgc =structTreeRoot ;};func _cebge (_badff *_gd .PdfAnnotation )*_gd .PdfAnnotation {if _badff ==nil {return nil ;};var _fdedb *_gd .PdfAnnotation ;switch _egcae :=_badff .GetContext ().(type ){case *_gd .PdfAnnotationLink :if _caeg :=_bbdfeg (_egcae );
_caeg !=nil {_fdedb =_caeg .PdfAnnotation ;};case *_gd .PdfAnnotationHighlight :if _dfcee :=_faadb (_egcae );_dfcee !=nil {_fdedb =_dfcee .PdfAnnotation ;};};return _fdedb ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_gd .PdfPage )(*Block ,error ){_ded :=&Block {};_ae ,_ege :=page .GetAllContentStreams ();if _ege !=nil {return nil ,_ege ;};_egg :=_eag .NewContentStreamParser (_ae );_afe ,_ege :=_egg .Parse ();if _ege !=nil {return nil ,_ege ;
};_afe .WrapIfNeeded ();_ded ._ge =_afe ;if page .Resources !=nil {_ded ._fa =page .Resources ;}else {_ded ._fa =_gd .NewPdfPageResources ();};_eb ,_ege :=page .GetMediaBox ();if _ege !=nil {return nil ,_ege ;};if _eb .Llx !=0||_eb .Lly !=0{_ded .translate (-_eb .Llx ,_eb .Lly );
};_ded ._de =_eb .Urx -_eb .Llx ;_ded ._ad =_eb .Ury -_eb .Lly ;if page .Rotate !=nil {_ded ._ac =-float64 (*page .Rotate );};return _ded ,nil ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_begbg *Invoice )AddressStyle ()TextStyle {return _begbg ._gdga };

// IsRelative checks if the positioning is relative.
func (_gdec Positioning )IsRelative ()bool {return _gdec ==PositionRelative };

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_dbfd *_ddb .Polygon ;_cbfb float64 ;_gcdg float64 ;_aafdc Color ;_fgdbe *int64 ;};func (_badg *templateProcessor )parseListMarker (_dgggfc *templateNode )(interface{},error ){if _dgggfc ._ddbbd ==nil {_badg .nodeLogError (_dgggfc ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_eeeee ;};var _ecdb *TextChunk ;switch _fcdagd :=_dgggfc ._ddbbd ._fdfd .(type ){case *List :_ecdb =&_fcdagd ._cacc ;case *listItem :_ecdb =&_fcdagd ._gdeca ;default:_badg .nodeLogError (_dgggfc ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_fcdagd );
return nil ,_eeeee ;};if _ ,_cbebf :=_badg .parseTextChunk (_dgggfc ,_ecdb );_cbebf !=nil {_badg .nodeLogError (_dgggfc ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_cbebf );
return nil ,nil ;};return _ecdb ,nil ;};func (_cgegf *templateProcessor )parseEllipse (_gdbgcg *templateNode )(interface{},error ){_febgff :=_cgegf .creator .NewEllipse (0,0,0,0);for _ ,_dfcdb :=range _gdbgcg ._eccfd .Attr {_gaada :=_dfcdb .Value ;switch _bcdfd :=_dfcdb .Name .Local ;
_bcdfd {case "\u0063\u0078":_febgff ._dbeb =_cgegf .parseFloatAttr (_bcdfd ,_gaada );case "\u0063\u0079":_febgff ._caaf =_cgegf .parseFloatAttr (_bcdfd ,_gaada );case "\u0077\u0069\u0064t\u0068":_febgff .SetWidth (_cgegf .parseFloatAttr (_bcdfd ,_gaada ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_febgff .SetHeight (_cgegf .parseFloatAttr (_bcdfd ,_gaada ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_febgff .SetFillColor (_cgegf .parseColorAttr (_bcdfd ,_gaada ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_febgff .SetFillOpacity (_cgegf .parseFloatAttr (_bcdfd ,_gaada ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_febgff .SetBorderColor (_cgegf .parseColorAttr (_bcdfd ,_gaada ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_febgff .SetBorderOpacity (_cgegf .parseFloatAttr (_bcdfd ,_gaada ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_febgff .SetBorderWidth (_cgegf .parseFloatAttr (_bcdfd ,_gaada ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_febgff .SetPositioning (_cgegf .parsePositioningAttr (_bcdfd ,_gaada ));
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_febgff .SetFitMode (_cgegf .parseFitModeAttr (_bcdfd ,_gaada ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_aadfa :=_cgegf .parseMarginAttr (_bcdfd ,_gaada );_febgff .SetMargins (_aadfa .Left ,_aadfa .Right ,_aadfa .Top ,_aadfa .Bottom );
default:_cgegf .nodeLogDebug (_gdbgcg ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_bcdfd );
};};return _febgff ,nil ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_ebadc *List )SetIndent (indent float64 ){_ebadc ._eeccg =indent ;_ebadc ._gcbf =false };func (_gggf *templateProcessor )parseMarginAttr (_bcebb ,_cfdd string )Margins {_ca .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_bcebb ,_cfdd );
_bgccgg :=Margins {};switch _fada :=_ddf .Fields (_cfdd );len (_fada ){case 1:_bgccgg .Top ,_ =_fd .ParseFloat (_fada [0],64);_bgccgg .Bottom =_bgccgg .Top ;_bgccgg .Left =_bgccgg .Top ;_bgccgg .Right =_bgccgg .Top ;case 2:_bgccgg .Top ,_ =_fd .ParseFloat (_fada [0],64);
_bgccgg .Bottom =_bgccgg .Top ;_bgccgg .Left ,_ =_fd .ParseFloat (_fada [1],64);_bgccgg .Right =_bgccgg .Left ;case 3:_bgccgg .Top ,_ =_fd .ParseFloat (_fada [0],64);_bgccgg .Left ,_ =_fd .ParseFloat (_fada [1],64);_bgccgg .Right =_bgccgg .Left ;_bgccgg .Bottom ,_ =_fd .ParseFloat (_fada [2],64);
case 4:_bgccgg .Top ,_ =_fd .ParseFloat (_fada [0],64);_bgccgg .Right ,_ =_fd .ParseFloat (_fada [1],64);_bgccgg .Bottom ,_ =_fd .ParseFloat (_fada [2],64);_bgccgg .Left ,_ =_fd .ParseFloat (_fada [3],64);};return _bgccgg ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_dbeb float64 ;_caaf float64 ;_gbea float64 ;_fgbb float64 ;_gbbf Positioning ;_cgcbc Color ;_baae float64 ;_bfgf Color ;_fdcc float64 ;_egegc float64 ;_dffg Margins ;_fdbc FitMode ;_ecdc *int64 ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_fbaf *Image )GetHorizontalAlignment ()HorizontalAlignment {return _fbaf ._ggaca };

// SetMargins sets the Paragraph's margins.
func (_dcfe *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_dcfe ._cgacg .Left =left ;_dcfe ._cgacg .Right =right ;_dcfe ._cgacg .Top =top ;_dcfe ._cgacg .Bottom =bottom ;};func (_adbed *templateProcessor )parseBorderRadiusAttr (_aaccg ,_agdcg string )(_cfaae ,_cdagc ,_cceaf ,_dadec float64 ){_ca .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_aaccg ,_agdcg );
switch _eeece :=_ddf .Fields (_agdcg );len (_eeece ){case 1:_cfaae ,_ =_fd .ParseFloat (_eeece [0],64);_cdagc =_cfaae ;_cceaf =_cfaae ;_dadec =_cfaae ;case 2:_cfaae ,_ =_fd .ParseFloat (_eeece [0],64);_cceaf =_cfaae ;_cdagc ,_ =_fd .ParseFloat (_eeece [1],64);
_dadec =_cdagc ;case 3:_cfaae ,_ =_fd .ParseFloat (_eeece [0],64);_cdagc ,_ =_fd .ParseFloat (_eeece [1],64);_dadec =_cdagc ;_cceaf ,_ =_fd .ParseFloat (_eeece [2],64);case 4:_cfaae ,_ =_fd .ParseFloat (_eeece [0],64);_cdagc ,_ =_fd .ParseFloat (_eeece [1],64);
_cceaf ,_ =_fd .ParseFloat (_eeece [2],64);_dadec ,_ =_fd .ParseFloat (_eeece [3],64);};return _cfaae ,_cdagc ,_cceaf ,_dadec ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_ccfcd *TOCLine )LevelOffset ()float64 {return _ccfcd ._gedeb };

// BorderWidth returns the border width of the rectangle.
func (_cbcec *Rectangle )BorderWidth ()float64 {return _cbcec ._bcdgg };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_faef *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_befc :=ctx ;var _gcbad []*Block ;_eace :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _faef ._adfd .IsRelative (){ctx .X +=_faef ._cgacg .Left ;ctx .Y +=_faef ._cgacg .Top ;
ctx .Width -=_faef ._cgacg .Left +_faef ._cgacg .Right ;ctx .Height -=_faef ._cgacg .Top ;_faef .SetWidth (ctx .Width );if _faef .Height ()> ctx .Height {_gcbad =append (_gcbad ,_eace );_eace =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cfee :=ctx ;
_cfee .Y =ctx .Margins .Top ;_cfee .X =ctx .Margins .Left +_faef ._cgacg .Left ;_cfee .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_cfee .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_faef ._cgacg .Left -_faef ._cgacg .Right ;
ctx =_cfee ;};}else {if int (_faef ._gba )<=0{_faef .SetWidth (_faef .getTextWidth ());};ctx .X =_faef ._dagaa ;ctx .Y =_faef ._dcag ;};ctx ,_gacc :=_babe (_eace ,_faef ,ctx );if _gacc !=nil {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gacc );
return nil ,ctx ,_gacc ;};_gcbad =append (_gcbad ,_eace );if _faef ._adfd .IsRelative (){ctx .Y +=_faef ._cgacg .Bottom ;ctx .Height -=_faef ._cgacg .Bottom ;if !ctx .Inline {ctx .X =_befc .X ;ctx .Width =_befc .Width ;};return _gcbad ,ctx ,nil ;};return _gcbad ,_befc ,nil ;
};func (_ddcgg *templateProcessor )parseCellAlignmentAttr (_ccbcb ,_edcdf string )CellHorizontalAlignment {_ca .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ccbcb ,_edcdf );
_caafbg :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_edcdf ];return _caafbg ;
};func _babe (_afgf *Block ,_dbce *Paragraph ,_dbge DrawContext )(DrawContext ,error ){_fggc :=1;_ggdeb :=_be .PdfObjectName ("\u0046\u006f\u006e\u0074"+_fd .Itoa (_fggc ));for _afgf ._fa .HasFontByName (_ggdeb ){_fggc ++;_ggdeb =_be .PdfObjectName ("\u0046\u006f\u006e\u0074"+_fd .Itoa (_fggc ));
};_bffaa :=_afgf ._fa .SetFontByName (_ggdeb ,_dbce ._caccd .ToPdfObject ());if _bffaa !=nil {return _dbge ,_bffaa ;};_dbce .wrapText ();_gede :=_eag .NewContentCreator ();_gede .Add_q ();_bdgg :=_dbge .PageHeight -_dbge .Y -_dbce ._geac *_dbce ._agdbb ;
_gede .Translate (_dbge .X ,_bdgg );if _dbce ._ggc !=0{_gede .RotateDeg (_dbce ._ggc );};_fdcca :=_fac (_dbce ._ebbg );_bffaa =_gaea (_afgf ,_fdcca ,_dbce ._ebbg ,func ()Rectangle {return Rectangle {_fdeb :_dbge .X ,_fefcd :_bdgg ,_dacdg :_dbce .getMaxLineWidth ()/1000.0,_ddccd :_dbce .Height ()};
});if _bffaa !=nil {return _dbge ,_bffaa ;};_gede .Add_BT ();_bfea :=map[string ]_be .PdfObject {};if _dbce ._bafa !=nil {_bfea ["\u004d\u0043\u0049\u0044"]=_be .MakeInteger (*_dbce ._bafa );};if _dbce ._fbbdg !=""{_bfea ["\u004c\u0061\u006e\u0067"]=_be .MakeString (_dbce ._fbbdg );
};if len (_bfea )> 0{_gede .Add_BDC (*_be .MakeName (_gd .StructureTypeParagraph ),_bfea );};_gede .SetNonStrokingColor (_fdcca ).Add_Tf (_ggdeb ,_dbce ._geac ).Add_TL (_dbce ._geac *_dbce ._agdbb );for _egea ,_cebada :=range _dbce ._beag {if _egea !=0{_gede .Add_Tstar ();
};_eddf :=[]rune (_cebada );_dagg :=0.0;_defc :=0;for _fgdcc ,_gcbge :=range _eddf {if _gcbge ==' '{_defc ++;continue ;};if _gcbge =='\u000A'{continue ;};_aacc ,_badbg :=_dbce ._caccd .GetRuneMetrics (_gcbge );if !_badbg {_ca .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_fgdcc ,_gcbge ,_gcbge ,_dbce ._caccd .BaseFont (),_dbce ._caccd .Subtype ());
return _dbge ,_fc .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_dagg +=_dbce ._geac *_aacc .Wx ;};var _dfcda []_be .PdfObject ;_daae ,_eedd :=_dbce ._caccd .GetRuneMetrics (' ');
if !_eedd {return _dbge ,_fc .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_ddcac :=_daae .Wx ;switch _dbce ._eced {case TextAlignmentJustify :if _defc > 0&&_egea < len (_dbce ._beag )-1{_ddcac =(_dbce ._gba *1000.0-_dagg )/float64 (_defc )/_dbce ._geac ;
};case TextAlignmentCenter :_bcfa :=_dagg +float64 (_defc )*_ddcac *_dbce ._geac ;_aggcb :=(_dbce ._gba *1000.0-_bcfa )/2/_dbce ._geac ;_dfcda =append (_dfcda ,_be .MakeFloat (-_aggcb ));case TextAlignmentRight :_efaaa :=_dagg +float64 (_defc )*_ddcac *_dbce ._geac ;
_effc :=(_dbce ._gba *1000.0-_efaaa )/_dbce ._geac ;_dfcda =append (_dfcda ,_be .MakeFloat (-_effc ));};_bgdd :=_dbce ._caccd .Encoder ();var _cccae []byte ;for _ ,_ddbb :=range _eddf {if _ddbb =='\u000A'{continue ;};if _ddbb ==' '{if len (_cccae )> 0{_dfcda =append (_dfcda ,_be .MakeStringFromBytes (_cccae ));
_cccae =nil ;};_dfcda =append (_dfcda ,_be .MakeFloat (-_ddcac ));}else {if _ ,_efgde :=_bgdd .RuneToCharcode (_ddbb );!_efgde {_bffaa =UnsupportedRuneError {Message :_f .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ddbb ,_ddbb ),Rune :_ddbb };
_dbge ._ebbc =append (_dbge ._ebbc ,_bffaa );_ca .Log .Debug (_bffaa .Error ());if _dbge ._ebeg <=0{continue ;};_ddbb =_dbge ._ebeg ;};_cccae =append (_cccae ,_bgdd .Encode (string (_ddbb ))...);};};if len (_cccae )> 0{_dfcda =append (_dfcda ,_be .MakeStringFromBytes (_cccae ));
};_gede .Add_TJ (_dfcda ...);};if len (_bfea )> 0{_gede .Add_EMC ();};_gede .Add_ET ();_gede .Add_Q ();_adcf :=_gede .Operations ();_adcf .WrapIfNeeded ();_afgf .addContents (_adcf );if _dbce ._adfd .IsRelative (){_afecg :=_dbce .Height ();_dbge .Y +=_afecg ;
_dbge .Height -=_afecg ;if _dbge .Inline {_dbge .X +=_dbce .Width ()+_dbce ._cgacg .Right ;};};return _dbge ,nil ;};

// SetBorderOpacity sets the border opacity of the ellipse.
func (_eabb *Ellipse )SetBorderOpacity (opacity float64 ){_eabb ._egegc =opacity };

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_eabba *Invoice )Terms ()(string ,string ){return _eabba ._acae [0],_eabba ._acae [1]};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_dbfgd *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_eeedg :=range subtable ._gedg {_ccff :=&TableCell {};*_ccff =*_eeedg ;_ccff ._gabb =_dbfgd ;_ccff ._gggbbd +=col -1;if _cbgdd :=_dbfgd ._cafcb -(_ccff ._gggbbd -1);_cbgdd < _ccff ._ffebf {_dbfgd ._cafcb +=_ccff ._ffebf -_cbgdd ;
_dbfgd .resetColumnWidths ();_ca .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_dbfgd ._cafcb );
};_ccff ._fgcga +=row -1;_dfdbba :=subtable ._gadc [_eeedg ._fgcga -1];if _ccff ._fgcga > _dbfgd ._addf {for _ccff ._fgcga > _dbfgd ._addf {_dbfgd ._addf ++;_dbfgd ._gadc =append (_dbfgd ._gadc ,_dbfgd ._aedbd );};_dbfgd ._gadc [_ccff ._fgcga -1]=_dfdbba ;
}else {_dbfgd ._gadc [_ccff ._fgcga -1]=_ff .Max (_dbfgd ._gadc [_ccff ._fgcga -1],_dfdbba );};_dbfgd ._gedg =append (_dbfgd ._gedg ,_ccff );};_dbfgd .sortCells ();};func _cfebg (_daed *templateProcessor ,_fdac *templateNode )(interface{},error ){return _daed .parseChapter (_fdac );
};

// SetMarkedContentID sets the marked content ID.
func (_daac *PageBreak )SetMarkedContentID (id int64 )*_gd .KDict {return nil };const (FitModeNone FitMode =iota ;FitModeFillWidth ;);

// SetHeight sets the height of the rectangle.
func (_aedd *Rectangle )SetHeight (height float64 ){_aedd ._ddccd =height };

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_aaeab *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_geba []*Block ;_ddbdb =NewBlock (ctx .PageWidth ,ctx .PageHeight );_fafb =ctx ;_bfc ,_aaga =_aaeab ._cbagd ,ctx .PageHeight -_aaeab ._efeb ;_dgdac ,_abef =_aaeab ._agbba ,ctx .PageHeight -_aaeab ._dcga ;
);_adbgf :=_aaeab ._fcbba .IsRelative ();if _adbgf {ctx .X +=_aaeab ._cbeb .Left ;ctx .Y +=_aaeab ._cbeb .Top ;ctx .Width -=_aaeab ._cbeb .Left +_aaeab ._cbeb .Right ;ctx .Height -=_aaeab ._cbeb .Top +_aaeab ._cbeb .Bottom ;_bfc ,_aaga ,_dgdac ,_abef =_aaeab .computeCoords (ctx );
if _aaeab .Height ()> ctx .Height {_geba =append (_geba ,_ddbdb );_ddbdb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gbge :=ctx ;_gbge .Y =ctx .Margins .Top +_aaeab ._cbeb .Top ;_gbge .X =ctx .Margins .Left +_aaeab ._cbeb .Left ;_gbge .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_aaeab ._cbeb .Top -_aaeab ._cbeb .Bottom ;
_gbge .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_aaeab ._cbeb .Left -_aaeab ._cbeb .Right ;ctx =_gbge ;_bfc ,_aaga ,_dgdac ,_abef =_aaeab .computeCoords (ctx );};};_afbe :=_ddb .BasicLine {X1 :_bfc ,Y1 :_aaga ,X2 :_dgdac ,Y2 :_abef ,LineColor :_fac (_aaeab ._ffga ),Opacity :_aaeab ._gbfc ,LineWidth :_aaeab ._adcb ,LineStyle :_aaeab ._dddcg ,DashArray :_aaeab ._cccd ,DashPhase :_aaeab ._aaed };
_egee ,_effe :=_ddbdb .setOpacity (1.0,_aaeab ._gbfc );if _effe !=nil {return nil ,ctx ,_effe ;};_bdbfe ,_ ,_effe :=_afbe .MarkedDraw (_egee ,_aaeab ._afac );if _effe !=nil {return nil ,ctx ,_effe ;};if _effe =_ddbdb .addContentsByString (string (_bdbfe ));
_effe !=nil {return nil ,ctx ,_effe ;};if _adbgf {ctx .X =_fafb .X ;ctx .Width =_fafb .Width ;_dcbgd :=_aaeab .Height ();ctx .Y +=_dcbgd +_aaeab ._cbeb .Bottom ;ctx .Height -=_dcbgd ;}else {ctx =_fafb ;};_geba =append (_geba ,_ddbdb );return _geba ,ctx ,nil ;
};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_abee *LinearShading )SetAntiAlias (enable bool ){_abee ._faee .SetAntiAlias (enable )};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_cegg *Invoice )NoteHeadingStyle ()TextStyle {return _cegg ._begb };

// SetAlternateText sets the alternate text for the image.
func (_eebbc *Image )SetAlternateText (text string ){_eebbc ._bfbga =text };

// AddTotalLine adds a new line in the invoice totals table.
func (_cfde *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_gad :=&InvoiceCell {_cfde ._aabdc ,desc };_acceg :=&InvoiceCell {_cfde ._aabdc ,value };_cfde ._gfgd =append (_cfde ._gfgd ,[2]*InvoiceCell {_gad ,_acceg });return _gad ,_acceg ;
};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_geacg *RadialShading )AddShadingResource (block *Block )(_ddebc _be .PdfObjectName ,_affdf error ){_daaec :=1;_ddebc =_be .PdfObjectName ("\u0053\u0068"+_fd .Itoa (_daaec ));for block ._fa .HasShadingByName (_ddebc ){_daaec ++;_ddebc =_be .PdfObjectName ("\u0053\u0068"+_fd .Itoa (_daaec ));
};if _fegdc :=block ._fa .SetShadingByName (_ddebc ,_geacg .shadingModel ().ToPdfObject ());_fegdc !=nil {return "",_fegdc ;};return _ddebc ,nil ;};

// GetIndent get the cell's left indent.
func (_fabab *TableCell )GetIndent ()float64 {return _fabab ._adeb };

// SetMarkedContentID sets marked content ID.
func (_eccb *FilledCurve )SetMarkedContentID (mcid int64 )*_gd .KDict {_eccb ._gfecd =&mcid ;_bgde :=_gd .NewKDictionary ();_bgde .S =_be .MakeName (_gd .StructureTypeFigure );_bgde .K =_be .MakeInteger (mcid );return _bgde ;};

// SetBorderColor sets the border color.
func (_egbae *PolyBezierCurve )SetBorderColor (color Color ){_egbae ._bgdab .BorderColor =_fac (color )};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_fgcd *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_fgcd ._eeedb =align ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_bfgc *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_efgb :=uint (len (_bfgc ._gbbc ));if index > _efgb {index =_efgb ;};_eeccb :=_bfgc .NewColumn (description );_bfgc ._gbbc =append (_bfgc ._gbbc [:index ],append ([]*InvoiceCell {_eeccb },_bfgc ._gbbc [index :]...)...);
return _eeccb ;};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_bacgca *TOC )SetLineLevelOffset (levelOffset float64 ){_bacgca ._dddcf =levelOffset };func (_eafcb *templateProcessor )parsePositioningAttr (_dgeea ,_ebcgd string )Positioning {_ca .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dgeea ,_ebcgd );
_gfbg :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_ebcgd ];return _gfbg ;};

// SetHeight sets the height of the ellipse.
func (_badd *Ellipse )SetHeight (height float64 ){_badd ._fgbb =height };

// SetRowPosition sets cell row position.
func (_acfe *TableCell )SetRowPosition (row int ){_acfe ._fgcga =row };func (_fdd *Block )setOpacity (_ce float64 ,_abb float64 )(string ,error ){if (_ce < 0||_ce >=1.0)&&(_abb < 0||_abb >=1.0){return "",nil ;};_dec :=0;_gdb :=_f .Sprintf ("\u0047\u0053\u0025\u0064",_dec );
for _fdd ._fa .HasExtGState (_be .PdfObjectName (_gdb )){_dec ++;_gdb =_f .Sprintf ("\u0047\u0053\u0025\u0064",_dec );};_cg :=_be .MakeDict ();if _ce >=0&&_ce < 1.0{_cg .Set ("\u0063\u0061",_be .MakeFloat (_ce ));};if _abb >=0&&_abb < 1.0{_cg .Set ("\u0043\u0041",_be .MakeFloat (_abb ));
};_fcf :=_fdd ._fa .AddExtGState (_be .PdfObjectName (_gdb ),_cg );if _fcf !=nil {return "",_fcf ;};return _gdb ,nil ;};

// SetMarkedContentID sets the marked content identifier.
func (_egde *Polygon )SetMarkedContentID (mcid int64 )*_gd .KDict {_egde ._fgdbe =&mcid ;_daab :=_gd .NewKDictionary ();_daab .S =_be .MakeName (_gd .StructureTypeFigure );_daab .K =_be .MakeInteger (mcid );return _daab ;};

// FitMode returns the fit mode of the line.
func (_fddf *Line )FitMode ()FitMode {return _fddf ._aedgf };

// Write output of creator to io.Writer interface.
func (_cafcd *Creator )Write (ws _cb .Writer )error {if _gfede :=_cafcd .Finalize ();_gfede !=nil {return _gfede ;};_ffba :="";if _bbb ,_acag :=ws .(*_e .File );_acag {_ffba =_bbb .Name ();};_bdg :=_gd .NewPdfWriter ();_bdg .SetOptimizer (_cafcd ._bfg );
_bdg .SetFileName (_ffba );if _cafcd ._bdac !=nil {_aaab :=_bdg .SetForms (_cafcd ._bdac );if _aaab !=nil {_ca .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_aaab );return _aaab ;};};if _cafcd ._dfac !=nil {_bdg .AddOutlineTree (_cafcd ._dfac );
}else if _cafcd ._eagf !=nil &&_cafcd .AddOutlines {_bdg .AddOutlineTree (&_cafcd ._eagf .ToPdfOutline ().PdfOutlineTreeNode );};if _cafcd ._ddad !=nil {if _bbdcf :=_bdg .SetPageLabels (_cafcd ._ddad );_bbdcf !=nil {_ca .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_bbdcf );
return _bbdcf ;};};if _cafcd ._dgad !=nil {for _ ,_efg :=range _cafcd ._dgad {_fabd :=_efg .SubsetRegistered ();if _fabd !=nil {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_fabd );
return _fabd ;};};};if _cafcd ._eaa !=nil {_degf :=_cafcd ._eaa (&_bdg );if _degf !=nil {_ca .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_degf );return _degf ;};};for _dgga ,_deca :=range _cafcd ._bee {_accf :=_bdg .AddPage (_deca );
if _accf !=nil {_ca .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_accf );return _accf ;};if _cafcd ._fgc !=nil {_bcb :=_cafcd ._fgc .K ;_beda ,_gcbg :=_bdg .GetPageIndirectObject (_dgga );
if _gcbg !=nil {_ca .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0043\u006fu\u006c\u0064\u0020n\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061ge\u0020\u0069\u006ed\u0069\u0072e\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074 \u0025\u0076",_gcbg );
};var _bfaf func (_bgba *_gd .KDict );_bfaf =func (_fgab *_gd .KDict ){if _fgab ==nil {return ;};if _fgab .GetPageNumber ()-1==int64 (_dgga ){_fgab .SetPage (_beda );};for _ ,_ceac :=range _fgab .GetChildren (){if _eeac :=_ceac .GetKDict ();_eeac !=nil {_bfaf (_eeac );
};};};for _ ,_bgeg :=range _bcb {_bfaf (_bgeg );};};};if _cafcd ._fgc !=nil {if _cae :=_bdg .SetCatalogStructTreeRoot (_cafcd ._fgc .ToPdfObject ());_cae !=nil {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020n\u006f\u0074\u0020\u0073\u0065\u0074 \u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065\u0065\u0052\u006f\u006ft\u003a\u0020\u0025\u0076",_cae );
return _cae ;};};if _cafcd ._ggfa !=nil {if _eccgb :=_bdg .SetCatalogViewerPreferences (_cafcd ._ggfa .ToPdfObject ());_eccgb !=nil {_ca .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065\u0074\u0020\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073\u003a\u0020\u0025\u0076",_eccgb );
return _eccgb ;};};if _cafcd ._ggfag !=""{if _fdb :=_bdg .SetCatalogLanguage (_be .MakeString (_cafcd ._ggfag ));_fdb !=nil {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065t\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u006c\u0061\u006e\u0067\u0075\u0061\u0067\u0065\u003a\u0020\u0025\u0076",_fdb );
return _fdb ;};};_baga :=_bdg .Write (ws );if _baga !=nil {return _baga ;};return nil ;};

// SetLevel sets the indentation level of the TOC line.
func (_accge *TOCLine )SetLevel (level uint ){_accge ._bfcf =level ;_accge ._ecfeg ._affa .Left =_accge ._gdcff +float64 (_accge ._bfcf -1)*_accge ._gedeb ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_addf int ;_cafcb int ;_eaeec int ;_faae []float64 ;_gadc []float64 ;_aedbd float64 ;_gedg []*TableCell ;_gaad []int ;_ccdf Positioning ;_dece ,_aeff float64 ;_ccecg Margins ;_fbbbb bool ;_bccfd int ;_deceb int ;_ffeag bool ;_ebcgb bool ;
_ggab bool ;};

// Width returns the width of the graphic svg.
func (_eedb *GraphicSVG )Width ()float64 {return _eedb ._dddg .Width };

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_dgea *Division )SetPadding (left ,right ,top ,bottom float64 ){_dgea ._dcfb .Left =left ;_dgea ._dcfb .Right =right ;_dgea ._dcfb .Top =top ;_dgea ._dcfb .Bottom =bottom ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_adcdb *List )Width ()float64 {return 0};func _dgbe (_ggeb string )(*GraphicSVG ,error ){_deda ,_ddea :=_ea .ParseFromFile (_ggeb );if _ddea !=nil {return nil ,_ddea ;};return _badfd (_deda );};func (_ggdb *templateProcessor )nodeLogError (_baba *templateNode ,_ffdb string ,_adgg ...interface{}){_ca .Log .Error (_ggdb .getNodeErrorLocation (_baba ,_ffdb ,_adgg ...));
};

// RotatedSize returns the width and height of the rotated block.
func (_ade *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_dgf ,_cfc :=_bcecf (_ade ._de ,_ade ._ad ,_ade ._ac );return _dgf ,_cfc ;};func (_cgdf *Table )sortCells (){_d .Slice (_cgdf ._gedg ,func (_gdabd ,_cbfca int )bool {_bdbef :=_cgdf ._gedg [_gdabd ]._fgcga ;
_fdbe :=_cgdf ._gedg [_cbfca ]._fgcga ;if _bdbef < _fdbe {return true ;};if _bdbef > _fdbe {return false ;};return _cgdf ._gedg [_gdabd ]._gggbbd < _cgdf ._gedg [_cbfca ]._gggbbd ;});};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_gdfg *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};func _cfgb ()*Division {return &Division {_adbb :true }};func (_ebbd *Invoice )newColumn (_fedbe string ,_adeg CellHorizontalAlignment )*InvoiceCell {_ffed :=&InvoiceCell {_ebbd ._dbbfd ,_fedbe };
_ffed .Alignment =_adeg ;return _ffed ;};

// DashPattern returns the dash pattern of the line.
func (_acccd *Line )DashPattern ()(_gdde []int64 ,_gfdc int64 ){return _acccd ._cccd ,_acccd ._aaed };

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_dddg *_ea .GraphicSVG ;_cdgd Positioning ;_eeeb float64 ;_gca float64 ;_agdb Margins ;_dcfc *int64 ;};

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_cedf *Rectangle )GetCoords ()(float64 ,float64 ){return _cedf ._fdeb ,_cedf ._fefcd };

// SetCompactMode sets the compact mode flag for this table.
//
// By enabling compact mode, table cell that contains Paragraph/StyleParagraph
// would not add extra height when calculating it's height.
//
// The default value is false.
func (_bbee *Table )SetCompactMode (enable bool ){_bbee ._ggab =enable };

// SetLogo sets the logo of the invoice.
func (_egfg *Invoice )SetLogo (logo *Image ){_egfg ._afed =logo };

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_dbdc *Invoice )NoteStyle ()TextStyle {return _dbdc ._degfg };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_ceaa *Chapter )SetShowNumbering (show bool ){_ceaa ._dge =show ;_ceaa ._adbf .SetText (_ceaa .headingText ());};func _ebdg (_gaeg [][]_ddb .Point )*Polygon {return &Polygon {_dbfd :&_ddb .Polygon {Points :_gaeg },_cbfb :1.0,_gcdg :1.0};};

// SetMarkedContentID sets marked content ID.
func (_cggg *Polyline )SetMarkedContentID (mcid int64 )*_gd .KDict {_cggg ._ecga =&mcid ;_eabcd :=_gd .NewKDictionary ();_eabcd .S =_be .MakeName (_gd .StructureTypeFigure );_eabcd .K =_be .MakeInteger (mcid );return _eabcd ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_aaeb *Paragraph )Height ()float64 {_aaeb .wrapText ();return float64 (len (_aaeb ._beag ))*_aaeb ._agdbb *_aaeb ._geac ;};

// SetSideBorderWidth sets the cell's side border width.
func (_eafc *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_eafc ._efec =width ;_eafc ._acdc =width ;_eafc ._debdc =width ;_eafc ._gecc =width ;case CellBorderSideTop :_eafc ._efec =width ;case CellBorderSideBottom :_eafc ._acdc =width ;
case CellBorderSideLeft :_eafc ._debdc =width ;case CellBorderSideRight :_eafc ._gecc =width ;};};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_gg :=&Block {};_gg ._ge =&_eag .ContentStreamOperations {};_gg ._fa =_gd .NewPdfPageResources ();_gg ._de =width ;_gg ._ad =height ;return _gg ;};

// SetLineColor sets the line color.
func (_fcggf *Polyline )SetLineColor (color Color ){_fcggf ._gcaf .LineColor =_fac (color )};func (_efacf *templateProcessor )parsePageBreak (_ddbf *templateNode )(interface{},error ){return _addgg (),nil ;};

// SetFont sets the Paragraph's font.
func (_aaad *Paragraph )SetFont (font *_gd .PdfFont ){_aaad ._caccd =font };func (_eceeb *templateProcessor )parseChapter (_eabf *templateNode )(interface{},error ){_bgac :=_eceeb .creator .NewChapter ;if _eabf ._ddbbd !=nil {if _aecae ,_gace :=_eabf ._ddbbd ._fdfd .(*Chapter );
_gace {_bgac =_aecae .NewSubchapter ;};};_fdadf :=_bgac ("");for _ ,_fcgga :=range _eabf ._eccfd .Attr {_fdcf :=_fcgga .Value ;switch _eedbc :=_fcgga .Name .Local ;_eedbc {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_fdadf .SetShowNumbering (_eceeb .parseBoolAttr (_eedbc ,_fdcf ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_fdadf .SetIncludeInTOC (_eceeb .parseBoolAttr (_eedbc ,_fdcf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cafdg :=_eceeb .parseMarginAttr (_eedbc ,_fdcf );_fdadf .SetMargins (_cafdg .Left ,_cafdg .Right ,_cafdg .Top ,_cafdg .Bottom );
default:_eceeb .nodeLogDebug (_eabf ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_eedbc );
};};return _fdadf ,nil ;};func (_afea *templateProcessor )parseTextVerticalAlignmentAttr (_abdg ,_eafcf string )TextVerticalAlignment {_ca .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_abdg ,_eafcf );
_bgefg :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_eafcf ];return _bgefg ;};

// Width returns Image's document width.
func (_ddfc *Image )Width ()float64 {return _ddfc ._dcbe };const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// Height returns the Block's height.
func (_gb *Block )Height ()float64 {return _gb ._ad };

// SetDate sets the date of the invoice.
func (_cdbe *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_cdbe ._cegfg [1].Value =date ;return _cdbe ._cegfg [0],_cdbe ._cegfg [1];};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_ebeg rune ;_ebbc []error ;};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_ccfgb Color ;_aeeb float64 ;};

// AddColorStop add color stop info for rendering gradient color.
func (_cdbc *LinearShading )AddColorStop (color Color ,point float64 ){_cdbc ._faee .AddColorStop (color ,point );};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_baac *Invoice )SetAddressHeadingStyle (style TextStyle ){_baac ._fefc =style };

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_fdgb *GraphicSVG )SetPos (x ,y float64 ){_fdgb ._cdgd =PositionAbsolute ;_fdgb ._eeeb =x ;_fdgb ._gca =y ;};

// Opacity returns the opacity of the line.
func (_gbgf *Line )Opacity ()float64 {return _gbgf ._gbfc };

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_geedc *Table )Width ()float64 {return 0};func (_gdggd *Table )updateRowHeights (_deebg float64 ){for _ ,_bccb :=range _gdggd ._gedg {_dabfc :=_bccb .width (_gdggd ._faae ,_deebg );_abcc :=_bccb .height (_dabfc );_eggdb :=_gdggd ._gadc [_bccb ._fgcga +_bccb ._edegf -2];
if _bccb ._edegf > 1{_ggbga :=0.0;_fbeaa :=_gdggd ._gadc [_bccb ._fgcga -1:(_bccb ._fgcga +_bccb ._edegf -1)];for _ ,_edcg :=range _fbeaa {_ggbga +=_edcg ;};if _abcc <=_ggbga {continue ;};};if _abcc > _eggdb {_geca :=_abcc /float64 (_bccb ._edegf );if _geca > _eggdb {for _eebgd :=1;
_eebgd <=_bccb ._edegf ;_eebgd ++{if _geca > _gdggd ._gadc [_bccb ._fgcga +_eebgd -2]{_gdggd ._gadc [_bccb ._fgcga +_eebgd -2]=_geca ;};};};};};};

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_edecd *shading )SetExtends (start bool ,end bool ){_edecd ._gecd =[]bool {start ,end }};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_dcbg *Image )ConvertToBinary ()error {return _dcbg ._dgaaf .ConvertToBinary ()};

// Heading returns the heading component of the table of contents.
func (_gdgee *TOC )Heading ()*StyledParagraph {return _gdgee ._gfbgc };const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;
TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// SetBackgroundColor sets the cell's background color.
func (_eeeab *TableCell )SetBackgroundColor (col Color ){_eeeab ._ceege =col };

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_fdegg *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_baafe :=&_fdegg ._caada ;_baafe .Left =left ;_baafe .Right =right ;_baafe .Top =top ;_baafe .Bottom =bottom ;};func (_dbfeg *templateProcessor )nodeError (_ddebf *templateNode ,_fdge string ,_aace ...interface{})error {return _f .Errorf ("\u0025\u0073",_dbfeg .getNodeErrorLocation (_ddebf ,_fdge ,_aace ...));
};type listItem struct{_cfec VectorDrawable ;_gdeca TextChunk ;};func (_ebde *Division )drawBackground (_adfa []*Block ,_gcgb ,_abgg DrawContext ,_ccgc bool )([]*Block ,error ){_cagce :=len (_adfa );if _cagce ==0||_ebde ._bacfc ==nil {return _adfa ,nil ;
};_dgbf :=make ([]*Block ,0,len (_adfa ));for _bdbe ,_gdeg :=range _adfa {var (_efgd =_ebde ._bacfc .BorderRadiusTopLeft ;_afec =_ebde ._bacfc .BorderRadiusTopRight ;_ebda =_ebde ._bacfc .BorderRadiusBottomLeft ;_cbce =_ebde ._bacfc .BorderRadiusBottomRight ;
);_bggcg :=_gcgb ;_bggcg .Page +=_bdbe ;if _bdbe ==0{if _ccgc {_dgbf =append (_dgbf ,_gdeg );continue ;};if _cagce ==1{_bggcg .Height =_abgg .Y -_gcgb .Y ;};}else {_bggcg .X =_bggcg .Margins .Left +_ebde ._fceg .Left ;_bggcg .Y =_bggcg .Margins .Top ;_bggcg .Width =_bggcg .PageWidth -_bggcg .Margins .Left -_bggcg .Margins .Right -_ebde ._fceg .Left -_ebde ._fceg .Right ;
if _bdbe ==_cagce -1{_bggcg .Height =_abgg .Y -_bggcg .Margins .Top -_ebde ._fceg .Top ;}else {_bggcg .Height =_bggcg .PageHeight -_bggcg .Margins .Top -_bggcg .Margins .Bottom ;};if !_ccgc {_efgd =0;_afec =0;};};if _cagce > 1&&_bdbe !=_cagce -1{_ebda =0;
_cbce =0;};_edag :=_acbe (_bggcg .X ,_bggcg .Y ,_bggcg .Width ,_bggcg .Height );_edag .SetFillColor (_ebde ._bacfc .FillColor );_edag .SetBorderColor (_ebde ._bacfc .BorderColor );_edag .SetBorderWidth (_ebde ._bacfc .BorderSize );_edag .SetBorderRadius (_efgd ,_afec ,_ebda ,_cbce );
_fffc ,_ ,_eaggc :=_edag .GeneratePageBlocks (_bggcg );if _eaggc !=nil {return nil ,_eaggc ;};if len (_fffc )==0{continue ;};_aecb :=_fffc [0];if _eaggc =_aecb .mergeBlocks (_gdeg );_eaggc !=nil {return nil ,_eaggc ;};_dgbf =append (_dgbf ,_aecb );};return _dgbf ,nil ;
};

// SetFillColor sets the fill color for the path.
func (_facdc *FilledCurve )SetFillColor (color Color ){_facdc ._gdge =color };

// SetAngle sets the rotation angle in degrees.
func (_dg *Block )SetAngle (angleDeg float64 ){_dg ._ac =angleDeg };

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_bbdb *Table )SetPos (x ,y float64 ){_bbdb ._ccdf =PositionAbsolute ;_bbdb ._dece =x ;_bbdb ._aeff =y ;};func _dgc (_caee string )(*Image ,error ){_aefba ,_cedc :=_e .Open (_caee );if _cedc !=nil {return nil ,_cedc ;};defer _aefba .Close ();_gae ,_cedc :=_gd .ImageHandling .Read (_aefba );
if _cedc !=nil {_ca .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cedc );return nil ,_cedc ;};return _bddd (_gae );};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cdee *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _cdee ._ffce [0],_cdee ._ffce [1]};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// Width returns the width of the Paragraph.
func (_dcbgb *StyledParagraph )Width ()float64 {if _dcbgb ._egbgc &&int (_dcbgb ._cbcb )> 0{return _dcbgb ._cbcb ;};return _dcbgb .getTextWidth ()/1000.0;};func (_fddb *templateProcessor )parseCellVerticalAlignmentAttr (_caae ,_aadcg string )CellVerticalAlignment {_ca .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_caae ,_aadcg );
_bggac :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_aadcg ];return _bggac ;
};func (_ffafc *templateProcessor )parseFitModeAttr (_edebc ,_eefef string )FitMode {_ca .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_edebc ,_eefef );
_gfbc :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_eefef ];return _gfbc ;};func (_cdf *pageTransformations )transformPage (_ageb *_gd .PdfPage )error {if _ffab :=_cdf .applyFlip (_ageb );
_ffab !=nil {return _ffab ;};return nil ;};func (_bdef *templateProcessor )parseImageEncoder (_gfdg ,_dadb string )_be .StreamEncoder {_ca .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074e\u003a\u0020\u0028\u0060\u0025s\u0060\u002c \u0025\u0073\u0029\u002e",_gfdg ,_dadb );
if _dadb =="\u0066\u006c\u0061t\u0065"{return _be .NewFlateEncoder ();}else if _dadb =="\u0064\u0063\u0074"{return _be .NewDCTEncoder ();};_ca .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0076\u0061\u006cu\u0065\u0020\u006f\u0066 \u0065\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u0020\u0066\u006f\u0075\u006e\u0064\u002e",_gfdg ,_dadb );
return nil ;};

// SetColorRight sets border color for right.
func (_aaa *border )SetColorRight (col Color ){_aaa ._gcg =col };

// Length calculates and returns the length of the line.
func (_dafa *Line )Length ()float64 {return _ff .Sqrt (_ff .Pow (_dafa ._agbba -_dafa ._cbagd ,2.0)+_ff .Pow (_dafa ._dcga -_dafa ._efeb ,2.0));};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_dddgf *Invoice )TotalLines ()[][2]*InvoiceCell {_gefa :=[][2]*InvoiceCell {_dddgf ._ffce };_gefa =append (_gefa ,_dddgf ._gfgd ...);return append (_gefa ,_dddgf ._cecdb );};func _bggfea (_efaee *templateProcessor ,_fgfcd *templateNode )(interface{},error ){return _efaee .parseChart (_fgfcd );
};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_eacea *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_bffg :=NewTextChunk (text ,_eacea ._debd );_bffg .AddAnnotation (_cgdd (url ));return _eacea .appendChunk (_bffg );};

// WriteToFile writes the Creator output to file specified by path.
func (_dgged *Creator )WriteToFile (outputPath string )error {_dcc ,_bbdg :=_e .Create (outputPath );if _bbdg !=nil {return _bbdg ;};defer _dcc .Close ();return _dgged .Write (_dcc );};

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_bdad *Ellipse )ScaleToWidth (w float64 ){_ffeb :=_bdad ._fgbb /_bdad ._gbea ;_bdad ._gbea =w ;_bdad ._fgbb =w *_ffeb ;};

// Context returns the current drawing context.
func (_egcd *Creator )Context ()DrawContext {return _egcd ._ecfb };

// SetBorderRadius sets the radius of the rectangle corners.
func (_dgfa *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_dgfa ._dfegd =topLeft ;_dgfa ._afgd =topRight ;_dgfa ._ebddb =bottomLeft ;_dgfa ._fcgc =bottomRight ;};func (_gfgdb *templateProcessor )parseInt64Array (_ccded ,_bcff string )[]int64 {_ca .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ccded ,_bcff );
_cggec :=_ddf .Fields (_bcff );_cecg :=make ([]int64 ,0,len (_cggec ));for _ ,_gddec :=range _cggec {_aeda ,_ :=_fd .ParseInt (_gddec ,10,64);_cecg =append (_cecg ,_aeda );};return _cecg ;};var _fee =_g .MustCompile ("\u005c\u0064\u002b");func _bdda (_aaedf *Creator ,_dcbeg string ,_fdcd []byte ,_gccf *TemplateOptions ,_bcef componentRenderer )*templateProcessor {if _gccf ==nil {_gccf =&TemplateOptions {};
};_gccf .init ();if _bcef ==nil {_bcef =_aaedf ;};return &templateProcessor {creator :_aaedf ,_fagcac :_fdcd ,_agabg :_gccf ,_gfcf :_bcef ,_cabb :_dcbeg };};func _bddd (_dfad *_gd .Image )(*Image ,error ){_accc :=float64 (_dfad .Width );_ebg :=float64 (_dfad .Height );
return &Image {_dgaaf :_dfad ,_dade :_accc ,_abecc :_ebg ,_dcbe :_accc ,_fae :_ebg ,_afgb :0,_fgec :1.0,_dbafc :PositionRelative },nil ;};func (_beff *StyledParagraph )wrapChunks (_agdd bool )error {if !_beff ._egbgc ||int (_beff ._cbcb )<=0{_beff ._ccae =[][]*TextChunk {_beff ._bcbc };
return nil ;};if _beff ._fecad {_beff .wrapWordChunks ();};_beff ._ccae =[][]*TextChunk {};var _fedbg []*TextChunk ;var _eedga float64 ;_bfded :=_ab .IsSpace ;if !_agdd {_bfded =func (rune )bool {return false };};_cfcad :=_fgfcf (_beff ._cbcb *1000.0,0.000001);
for _ ,_badfc :=range _beff ._bcbc {_abfaf :=_badfc .Style ;_adcdg :=_badfc ._bcfe ;_defcb :=_badfc .VerticalAlignment ;var (_daag []rune ;_agea []float64 ;);_eeef :=_bdcfa (_badfc .Text );for _ ,_bdcb :=range _badfc .Text {if _bdcb =='\u000A'{if !_agdd {_daag =append (_daag ,_bdcb );
};_fedbg =append (_fedbg ,&TextChunk {Text :_ddf .TrimRightFunc (string (_daag ),_bfded ),Style :_abfaf ,_bcfe :_aagc (_adcdg ),VerticalAlignment :_defcb });_beff ._ccae =append (_beff ._ccae ,_fedbg );_fedbg =nil ;_eedga =0;_daag =nil ;_agea =nil ;continue ;
};_ceceg :=_bdcb ==' ';_gdcc ,_fbcaf :=_abfaf .Font .GetRuneMetrics (_bdcb );if _gdcc .Wx ==0&&_abfaf .MultiFont !=nil ||_abfaf .MultiFont !=nil &&!_fbcaf {_gdcc ,_fbcaf =_abfaf .MultiFont .GetRuneMetrics (_bdcb );};if !_fbcaf {_ca .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bdcb );
return _fc .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_fgdab :=_abfaf .FontSize *_gdcc .Wx *_abfaf .horizontalScale ();_faca :=_fgdab ;if !_ceceg {_faca =_fgdab +_abfaf .CharSpacing *1000.0;
};if _eedga +_fgdab > _cfcad {_ffae :=-1;if !_ceceg {for _fbgb :=len (_daag )-1;_fbgb >=0;_fbgb --{if _daag [_fbgb ]==' '{_ffae =_fbgb ;break ;};};};if _beff ._fecad {_bece :=len (_fedbg );if _bece > 0{_fedbg [_bece -1].Text =_ddf .TrimRightFunc (_fedbg [_bece -1].Text ,_bfded );
_beff ._ccae =append (_beff ._ccae ,_fedbg );_fedbg =[]*TextChunk {};};_daag =append (_daag ,_bdcb );_agea =append (_agea ,_faca );if _ffae >=0{_daag =_daag [_ffae +1:];_agea =_agea [_ffae +1:];};_eedga =0;for _ ,_fcadg :=range _agea {_eedga +=_fcadg ;
};if _eedga > _cfcad {_bada :=string (_daag [:len (_daag )-1]);_bada =_ebaa (_bada ,_eeef );if !_agdd &&_ceceg {_bada +="\u0020";};_fedbg =append (_fedbg ,&TextChunk {Text :_ddf .TrimRightFunc (_bada ,_bfded ),Style :_abfaf ,_bcfe :_aagc (_adcdg ),VerticalAlignment :_defcb });
_beff ._ccae =append (_beff ._ccae ,_fedbg );_fedbg =[]*TextChunk {};_daag =[]rune {_bdcb };_agea =[]float64 {_faca };_eedga =_faca ;};continue ;};_cebg :=string (_daag );if _ffae >=0{_cebg =string (_daag [0:_ffae +1]);_daag =_daag [_ffae +1:];_daag =append (_daag ,_bdcb );
_agea =_agea [_ffae +1:];_agea =append (_agea ,_faca );_eedga =0;for _ ,_aebeb :=range _agea {_eedga +=_aebeb ;};}else {if _ceceg {_eedga =0;_daag =[]rune {};_agea =[]float64 {};}else {_eedga =_faca ;_daag =[]rune {_bdcb };_agea =[]float64 {_faca };};};
_cebg =_ebaa (_cebg ,_eeef );if !_agdd &&_ceceg {_cebg +="\u0020";};_fedbg =append (_fedbg ,&TextChunk {Text :_ddf .TrimRightFunc (_cebg ,_bfded ),Style :_abfaf ,_bcfe :_aagc (_adcdg ),VerticalAlignment :_defcb });_beff ._ccae =append (_beff ._ccae ,_fedbg );
_fedbg =[]*TextChunk {};}else {_eedga +=_faca ;_daag =append (_daag ,_bdcb );_agea =append (_agea ,_faca );};};if len (_daag )> 0{_fabaa :=_ebaa (string (_daag ),_eeef );_fedbg =append (_fedbg ,&TextChunk {Text :_fabaa ,Style :_abfaf ,_bcfe :_aagc (_adcdg ),VerticalAlignment :_defcb });
};};if len (_fedbg )> 0{_beff ._ccae =append (_beff ._ccae ,_fedbg );};return nil ;};

// Positioning returns the type of positioning the line is set to use.
func (_ffabc *Line )Positioning ()Positioning {return _ffabc ._fcbba };

// Height returns the height of the list.
func (_fceb *List )Height ()float64 {var _eggcd float64 ;for _ ,_efac :=range _fceb ._fadf {_eggcd +=_efac .ctxHeight (_fceb .Width ());};return _eggcd ;};type rgbColor struct{_afd ,_fef ,_cbbf float64 };func (_gdebg *Paragraph )getTextWidth ()float64 {_dbcfe :=0.0;
for _ ,_dbffa :=range _gdebg ._bcgag {if _dbffa =='\u000A'{continue ;};_gddg ,_cebc :=_gdebg ._caccd .GetRuneMetrics (_dbffa );if !_cebc {_ca .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_dbffa ,_dbffa );
return -1;};_dbcfe +=_gdebg ._geac *_gddg .Wx ;};return _dbcfe ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_dfda *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_dfda ._ddfb =&_gd .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_bgdab *_ddb .PolyBezierCurve ;_dcfbf float64 ;_acfb float64 ;_gfde Color ;_bgadb *int64 ;};

// SetNumber sets the number of the invoice.
func (_eefc *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_eefc ._eeffg [1].Value =number ;return _eefc ._eeffg [0],_eefc ._eeffg [1];};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_gbeg *Creator )SetPageLabels (pageLabels _be .PdfObject ){_gbeg ._ddad =pageLabels };var (ErrContentNotFit =_fc .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
);func (_eaca *templateProcessor )parseStyledParagraph (_abcff *templateNode )(interface{},error ){_feddb :=_eaca .creator .NewStyledParagraph ();for _ ,_cbdc :=range _abcff ._eccfd .Attr {_bcba :=_cbdc .Value ;switch _ebgg :=_cbdc .Name .Local ;_ebgg {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_feddb .SetTextAlignment (_eaca .parseTextAlignmentAttr (_ebgg ,_bcba ));
case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_feddb .SetTextVerticalAlignment (_eaca .parseTextVerticalAlignmentAttr (_ebgg ,_bcba ));case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_feddb .SetLineHeight (_eaca .parseFloatAttr (_ebgg ,_bcba ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_ffcef :=_eaca .parseMarginAttr (_ebgg ,_bcba );_feddb .SetMargins (_ffcef .Left ,_ffcef .Right ,_ffcef .Top ,_ffcef .Bottom );case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_feddb .SetEnableWrap (_eaca .parseBoolAttr (_ebgg ,_bcba ));
case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_feddb .EnableWordWrap (_eaca .parseBoolAttr (_ebgg ,_bcba ));case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_feddb .SetTextOverflow (_eaca .parseTextOverflowAttr (_ebgg ,_bcba ));
case "\u0078":_feddb .SetPos (_eaca .parseFloatAttr (_ebgg ,_bcba ),_feddb ._ccde );case "\u0079":_feddb .SetPos (_feddb ._cabcd ,_eaca .parseFloatAttr (_ebgg ,_bcba ));case "\u0061\u006e\u0067l\u0065":_feddb .SetAngle (_eaca .parseFloatAttr (_ebgg ,_bcba ));
default:_eaca .nodeLogDebug (_abcff ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ebgg );
};};return _feddb ,nil ;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_acbbd *Ellipse )FillOpacity ()float64 {return _acbbd ._baae };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_baccc *Creator )SetForms (form *_gd .PdfAcroForm )error {_baccc ._bdac =form ;return nil };

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _fb .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_cb .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_gd .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_gd .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_fbb .ChartRenderable ;};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_gbae *LinearShading )SetBackgroundColor (backgroundColor Color ){_gbae ._faee .SetBackgroundColor (backgroundColor );};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_fafbf *Table )MultiCell (rowspan ,colspan int )*TableCell {_fafbf ._eaeec ++;_dede :=(_fafbf .moveToNextAvailableCell ()-1)%(_fafbf ._cafcb )+1;_dgaaa :=(_fafbf ._eaeec -1)/_fafbf ._cafcb +1;for _dgaaa > _fafbf ._addf {_fafbf ._addf ++;_fafbf ._gadc =append (_fafbf ._gadc ,_fafbf ._aedbd );
};_bebae :=&TableCell {};_bebae ._fgcga =_dgaaa ;_bebae ._gggbbd =_dede ;_bebae ._adeb =5;_bebae ._bddcf =CellBorderStyleNone ;_bebae ._aecgdc =_ddb .LineStyleSolid ;_bebae ._bebbe =CellHorizontalAlignmentLeft ;_bebae ._bdcca =CellVerticalAlignmentTop ;
_bebae ._debdc =0;_bebae ._acdc =0;_bebae ._gecc =0;_bebae ._efec =0;_fgde :=ColorBlack ;_bebae ._edgac =_fgde ;_bebae ._daea =_fgde ;_bebae ._cada =_fgde ;_bebae ._agcef =_fgde ;if rowspan < 1{_ca .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_dgbbb :=_fafbf ._addf -(_bebae ._fgcga -1);if rowspan > _dgbbb {_ca .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_dgbbb );
_fafbf ._addf +=rowspan -1;for _fcca :=0;_fcca <=rowspan -_dgbbb ;_fcca ++{_fafbf ._gadc =append (_fafbf ._gadc ,_fafbf ._aedbd );};};for _ddfbg :=0;_ddfbg < colspan &&_dede +_ddfbg -1< len (_fafbf ._gaad );_ddfbg ++{_fafbf ._gaad [_dede +_ddfbg -1]=rowspan -1;
};_bebae ._edegf =rowspan ;if colspan < 1{_ca .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_geda :=_fafbf ._cafcb -(_bebae ._gggbbd -1);if colspan > _geda {_ca .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_geda );
colspan =_geda ;};_bebae ._ffebf =colspan ;_fafbf ._eaeec +=colspan -1;_fafbf ._gedg =append (_fafbf ._gedg ,_bebae );_bebae ._gabb =_fafbf ;return _bebae ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_ba *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ec :=_cbe .IdentityMatrix ();_ccc ,_db :=_ba .Width (),_ba .Height ();if _ba ._agg .IsRelative (){_ec =_ec .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_db );}else {_ec =_ec .Translate (_ba ._eg ,ctx .PageHeight -_ba ._bge -_db );
};_fbe :=_db ;if _ba ._ac !=0{_ec =_ec .Translate (_ccc /2,_db /2).Rotate (_ba ._ac *_ff .Pi /180.0).Translate (-_ccc /2,-_db /2);_ ,_fbe =_ba .RotatedSize ();};if _ba ._agg .IsRelative (){ctx .Y +=_fbe ;};_bf :=_eag .NewContentCreator ();_bf .Add_cm (_ec [0],_ec [1],_ec [3],_ec [4],_ec [6],_ec [7]);
_afc :=_ba .duplicate ();_adb :=append (*_bf .Operations (),*_afc ._ge ...);_adb .WrapIfNeeded ();_afc ._ge =&_adb ;for _ ,_da :=range _ba ._bdc {_gab ,_fag :=_be .GetArray (_da .Rect );if !_fag ||_gab .Len ()!=4{_ca .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_da .Rect );
continue ;};_caf ,_ada :=_gd .NewPdfRectangle (*_gab );if _ada !=nil {_ca .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_ada );
continue ;};_caf .Transform (_ec );_da .Rect =_caf .ToPdfObject ();};return []*Block {_afc },ctx ,nil ;};

// Height returns the total height of all rows.
func (_ffge *Table )Height ()float64 {_gebf :=float64 (0.0);for _ ,_bdgc :=range _ffge ._gadc {_gebf +=_bdgc ;};return _gebf ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_bagc *RadialShading )SetExtends (start bool ,end bool ){_bagc ._ffcg .SetExtends (start ,end )};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_afecf *Image )SetPos (x ,y float64 ){_afecf ._dbafc =PositionAbsolute ;_afecf ._aeae =x ;_afecf ._bgabe =y ;};func (_ddgce *RadialShading )shadingModel ()*_gd .PdfShadingType3 {_fcfce ,_aaac ,_dgdb :=_ddgce ._ffcg ._bbdfc .ToRGB ();var _ccccb _ddb .Point ;
switch _ddgce ._cgdec {case AnchorBottomLeft :_ccccb =_ddb .Point {X :_ddgce ._gagb .Llx ,Y :_ddgce ._gagb .Lly };case AnchorBottomRight :_ccccb =_ddb .Point {X :_ddgce ._gagb .Urx ,Y :_ddgce ._gagb .Ury -_ddgce ._gagb .Height ()};case AnchorTopLeft :_ccccb =_ddb .Point {X :_ddgce ._gagb .Llx ,Y :_ddgce ._gagb .Lly +_ddgce ._gagb .Height ()};
case AnchorTopRight :_ccccb =_ddb .Point {X :_ddgce ._gagb .Urx ,Y :_ddgce ._gagb .Ury };case AnchorLeft :_ccccb =_ddb .Point {X :_ddgce ._gagb .Llx ,Y :_ddgce ._gagb .Lly +_ddgce ._gagb .Height ()/2};case AnchorTop :_ccccb =_ddb .Point {X :_ddgce ._gagb .Llx +_ddgce ._gagb .Width ()/2,Y :_ddgce ._gagb .Ury };
case AnchorRight :_ccccb =_ddb .Point {X :_ddgce ._gagb .Urx ,Y :_ddgce ._gagb .Lly +_ddgce ._gagb .Height ()/2};case AnchorBottom :_ccccb =_ddb .Point {X :_ddgce ._gagb .Urx +_ddgce ._gagb .Width ()/2,Y :_ddgce ._gagb .Lly };default:_ccccb =_ddb .NewPoint (_ddgce ._gagb .Llx +_ddgce ._gagb .Width ()/2,_ddgce ._gagb .Lly +_ddgce ._gagb .Height ()/2);
};_gaac :=_ddgce ._dabe ;_ccgfa :=_ddgce ._bbbc ;_fedc :=_ccccb .X +_ddgce ._edfe ;_abad :=_ccccb .Y +_ddgce ._dcgb ;if _gaac ==-1.0{_gaac =0.0;};if _ccgfa ==-1.0{var _dcbee []float64 ;_gaec :=_ff .Pow (_fedc -_ddgce ._gagb .Llx ,2)+_ff .Pow (_abad -_ddgce ._gagb .Lly ,2);
_dcbee =append (_dcbee ,_ff .Abs (_gaec ));_gabae :=_ff .Pow (_fedc -_ddgce ._gagb .Llx ,2)+_ff .Pow (_ddgce ._gagb .Lly +_ddgce ._gagb .Height ()-_abad ,2);_dcbee =append (_dcbee ,_ff .Abs (_gabae ));_ffaba :=_ff .Pow (_ddgce ._gagb .Urx -_fedc ,2)+_ff .Pow (_abad -_ddgce ._gagb .Ury -_ddgce ._gagb .Height (),2);
_dcbee =append (_dcbee ,_ff .Abs (_ffaba ));_fcccc :=_ff .Pow (_ddgce ._gagb .Urx -_fedc ,2)+_ff .Pow (_ddgce ._gagb .Ury -_abad ,2);_dcbee =append (_dcbee ,_ff .Abs (_fcccc ));_d .Slice (_dcbee ,func (_ebfd ,_caba int )bool {return _ebfd > _caba });_ccgfa =_ff .Sqrt (_dcbee [0]);
};_acge :=&_gd .PdfRectangle {Llx :_fedc -_ccgfa ,Lly :_abad -_ccgfa ,Urx :_fedc +_ccgfa ,Ury :_abad +_ccgfa };_afeg :=_gd .NewPdfShadingType3 ();_afeg .PdfShading .ShadingType =_be .MakeInteger (3);_afeg .PdfShading .ColorSpace =_gd .NewPdfColorspaceDeviceRGB ();
_afeg .PdfShading .Background =_be .MakeArrayFromFloats ([]float64 {_fcfce ,_aaac ,_dgdb });_afeg .PdfShading .BBox =_acge ;_afeg .PdfShading .AntiAlias =_be .MakeBool (_ddgce ._ffcg ._fdda );_afeg .Coords =_be .MakeArrayFromFloats ([]float64 {_fedc ,_abad ,_gaac ,_fedc ,_abad ,_ccgfa });
_afeg .Domain =_be .MakeArrayFromFloats ([]float64 {0.0,1.0});_afeg .Extend =_be .MakeArray (_be .MakeBool (_ddgce ._ffcg ._gecd [0]),_be .MakeBool (_ddgce ._ffcg ._gecd [1]));_afeg .Function =_ddgce ._ffcg .generatePdfFunctions ();return _afeg ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_fdgc *LinearShading )SetExtends (start bool ,end bool ){_fdgc ._faee .SetExtends (start ,end )};

// SetColorLeft sets border color for left.
func (_bgff *border )SetColorLeft (col Color ){_bgff ._fed =col };

// DrawFooter sets a function to draw a footer on created output pages.
func (_eggb *Creator )DrawFooter (drawFooterFunc func (_ccb *Block ,_ggac FooterFunctionArgs )){_eggb ._fdc =drawFooterFunc ;};func (_dbda *Table )clone ()*Table {_dgec :=*_dbda ;_dgec ._gadc =make ([]float64 ,len (_dbda ._gadc ));copy (_dgec ._gadc ,_dbda ._gadc );
_dgec ._faae =make ([]float64 ,len (_dbda ._faae ));copy (_dgec ._faae ,_dbda ._faae );_dgec ._gedg =make ([]*TableCell ,0,len (_dbda ._gedg ));for _ ,_beaga :=range _dbda ._gedg {_edda :=*_beaga ;_edda ._gabb =&_dgec ;_dgec ._gedg =append (_dgec ._gedg ,&_edda );
};return &_dgec ;};func (_debf *Paragraph )getTextMetrics ()(_gdbgc ,_geeb ,_cadg float64 ){_ffeab :=_ecdbd (_debf ._caccd ,_debf ._geac );if _ffeab ._edgacc > _gdbgc {_gdbgc =_ffeab ._edgacc ;};if _ffeab ._gfcgf < _cadg {_cadg =_ffeab ._gfcgf ;};if _fgda :=_debf ._geac ;
_fgda > _geeb {_geeb =_fgda ;};return _gdbgc ,_geeb ,_cadg ;};func (_abde *Table )wrapContent (_edae DrawContext )error {if _abde ._ffeag {return nil ;};_abde .sortCells ();_fdaeeb :=func (_gdca *TableCell ,_fggg int ,_bggdg int ,_fdfc int )(_daafb int ){if _fdfc < 1{return -1;
};_fdegd :=0;for _dfgg :=_bggdg +1;_dfgg < len (_abde ._gedg )-1;_dfgg ++{_dacde :=_abde ._gedg [_dfgg ];if _dacde ._fgcga ==_fdfc &&_fdegd !=_bggdg {_fdegd =_dfgg ;if (_dacde ._gggbbd < _gdca ._gggbbd &&_abde ._cafcb > _dacde ._gggbbd )||_gdca ._gggbbd < _abde ._cafcb {continue ;
};break ;};};_beefg :=float64 (0.0);for _cgecg :=0;_cgecg < _gdca ._edegf ;_cgecg ++{_beefg +=_abde ._gadc [_gdca ._fgcga +_cgecg -1];};_cdbgc :=_gdca .width (_abde ._faae ,_edae .Width );var (_caeda VectorDrawable ;_aacce =false ;);switch _dcce :=_gdca ._bdea .(type ){case *StyledParagraph :_bggfe :=_edae ;
_bggfe .Height =_ff .Floor (_beefg -_dcce ._affa .Top -_dcce ._affa .Bottom -0.5*_dcce .getTextHeight ());_bggfe .Width =_cdbgc ;_eecf ,_aecf ,_acdcd :=_dcce .split (_bggfe );if _acdcd !=nil {_ca .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_acdcd .Error ());
};if _eecf !=nil &&_aecf !=nil {_abde ._gedg [_bggdg ]._bdea =_eecf ;_caeda =_aecf ;_aacce =true ;};};_abde ._gedg [_bggdg ]._edegf =_gdca ._edegf ;_edae .Height =_edae .PageHeight -_edae .Margins .Top -_edae .Margins .Bottom ;_bedfb :=_gdca .cloneProps (nil );
if _aacce {_bedfb ._bdea =_caeda ;};_bedfb ._edegf =_fggg ;_bedfb ._fgcga =_fdfc +1;_bedfb ._gggbbd =_gdca ._gggbbd ;if _bedfb ._fgcga +_bedfb ._edegf -1> _abde ._addf {for _cfdc :=_abde ._addf ;_cfdc < _bedfb ._fgcga +_bedfb ._edegf -1;_cfdc ++{_abde ._addf ++;
_abde ._gadc =append (_abde ._gadc ,_abde ._aedbd );};};_abde ._gedg =append (_abde ._gedg [:_fdegd +1],append ([]*TableCell {_bedfb },_abde ._gedg [_fdegd +1:]...)...);return _fdegd +1;};_gegg :=func (_agag *TableCell ,_bebcf int ,_eeagf int ,_efaf float64 )(_fdcad int ){_cdda :=_agag .width (_abde ._faae ,_edae .Width );
_feeb :=_efaf ;_ecggf :=1;_gedff :=_edae .Height ;if _gedff > 0{for _feeb > _gedff {_feeb -=_edae .Height ;_gedff =_edae .PageHeight -_edae .Margins .Top -_edae .Margins .Bottom ;_ecggf ++;};};var (_fgefa VectorDrawable ;_gdaa =false ;);switch _dfebd :=_agag ._bdea .(type ){case *StyledParagraph :_adgba :=_edae ;
_adgba .Height =_ff .Floor (_edae .Height -_dfebd ._affa .Top -_dfebd ._affa .Bottom -0.5*_dfebd .getTextHeight ());_adgba .Width =_cdda ;_gbdag ,_efebf ,_afcf :=_dfebd .split (_adgba );if _afcf !=nil {_ca .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_afcf .Error ());
};if _gbdag !=nil &&_efebf !=nil {_abde ._gedg [_bebcf ]._bdea =_gbdag ;_fgefa =_efebf ;_gdaa =true ;};};if _ecggf < 2{return -1;};if _abde ._gedg [_bebcf ]._fgcga +_ecggf -1> _abde ._addf {for _bbba :=0;_bbba < _ecggf ;_bbba ++{_abde ._addf ++;_abde ._gadc =append (_abde ._gadc ,_abde ._aedbd );
};};_dbfgb :=_efaf /float64 (_ecggf );for _cgabd :=0;_cgabd < _ecggf ;_cgabd ++{_abde ._gadc [_eeagf +_cgabd -1]=_dbfgb ;};_edae .Height =_edae .PageHeight -_edae .Margins .Top -_edae .Margins .Bottom ;_fegge :=_agag .cloneProps (nil );if _gdaa {_fegge ._bdea =_fgefa ;
};_fegge ._edegf =1;_fegge ._fgcga =_eeagf +_ecggf -1;_fegge ._gggbbd =_agag ._gggbbd ;_abde ._gedg =append (_abde ._gedg ,_fegge );return len (_abde ._gedg );};_gefdc :=1;_bffcb :=-1;for _aeaa :=0;_aeaa < len (_abde ._gedg );_aeaa ++{_cade :=_abde ._gedg [_aeaa ];
if _bffcb ==_aeaa {_gefdc =_cade ._fgcga ;};if _cade ._edegf < 2{if _ddcf :=_abde ._gadc [_cade ._fgcga -1];_ddcf > _edae .Height {_bffcb =_gegg (_cade ,_aeaa ,_cade ._fgcga ,_ddcf );continue ;};continue ;};_ffdfg :=float64 (0);for _abacf :=0;_abacf < _cade ._edegf ;
_abacf ++{_ffdfg +=_abde ._gadc [_cade ._fgcga +_abacf -1];};_ffgag :=float64 (0);for _eaebb :=_gefdc -1;_eaebb < _cade ._fgcga -1;_eaebb ++{_ffgag +=_abde ._gadc [_eaebb ];};if _ffdfg <=(_edae .Height -_ffgag ){continue ;};_edefc :=float64 (0.0);_aebd :=_cade ._edegf ;
_bcaf :=-1;_ccdg :=1;for _gcccb :=1;_gcccb <=_cade ._edegf ;_gcccb ++{if (_edefc +_abde ._gadc [_cade ._fgcga +_gcccb -2])> (_edae .Height -_ffgag ){_ccdg --;break ;};_bcaf =_cade ._fgcga +_gcccb -1;_aebd =_cade ._edegf -_gcccb ;_edefc +=_abde ._gadc [_cade ._fgcga +_gcccb -2];
_ccdg ++;};if _cade ._edegf ==_aebd {_edae .Height =_edae .PageHeight -_edae .Margins .Top -_edae .Margins .Bottom ;_gefdc =_cade ._fgcga ;_aeaa --;continue ;};if _aebd > 0&&_cade ._edegf > _ccdg {_cade ._edegf =_ccdg ;_bffcb =_fdaeeb (_cade ,_aebd ,_aeaa ,_bcaf );
if _aeaa +1==_bffcb {_aeaa --;};};_gefdc =_cade ._fgcga ;};_abde .sortCells ();return nil ;};

// SetLanguage sets the language identifier that will be stored inside document catalog.
func (_cgc *Creator )SetLanguage (language string ){_cgc ._ggfag =language };func (_egce *Invoice )drawAddress (_eebcb *InvoiceAddress )[]*StyledParagraph {var _gbba []*StyledParagraph ;if _eebcb .Heading !=""{_dafe :=_aedcd (_egce ._fefc );_dafe .SetMargins (0,0,0,7);
_dafe .Append (_eebcb .Heading );_gbba =append (_gbba ,_dafe );};_bgffa :=_aedcd (_egce ._gdga );_bgffa .SetLineHeight (1.2);_aege :=_eebcb .Separator ;if _aege ==""{_aege =_egce ._gggd ;};_cbbb :=_eebcb .City ;if _eebcb .State !=""{if _cbbb !=""{_cbbb +=_aege ;
};_cbbb +=_eebcb .State ;};if _eebcb .Zip !=""{if _cbbb !=""{_cbbb +=_aege ;};_cbbb +=_eebcb .Zip ;};if _eebcb .Name !=""{_bgffa .Append (_eebcb .Name +"\u000a");};if _eebcb .Street !=""{_bgffa .Append (_eebcb .Street +"\u000a");};if _eebcb .Street2 !=""{_bgffa .Append (_eebcb .Street2 +"\u000a");
};if _cbbb !=""{_bgffa .Append (_cbbb +"\u000a");};if _eebcb .Country !=""{_bgffa .Append (_eebcb .Country +"\u000a");};_ffdf :=_aedcd (_egce ._gdga );_ffdf .SetLineHeight (1.2);_ffdf .SetMargins (0,0,7,0);if _eebcb .Phone !=""{_ffdf .Append (_eebcb .fmtLine (_eebcb .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_eebcb .HidePhoneLabel ));
};if _eebcb .Email !=""{_ffdf .Append (_eebcb .fmtLine (_eebcb .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_eebcb .HideEmailLabel ));};_gbba =append (_gbba ,_bgffa ,_ffdf );return _gbba ;};

// SetMarkedContentID sets marked content ID.
func (_fdfe *GraphicSVG )SetMarkedContentID (mcid int64 )*_gd .KDict {_fdfe ._dcfc =&mcid ;_dbcb :=_gd .NewKDictionary ();_dbcb .S =_be .MakeName (_gd .StructureTypeFigure );_dbcb .K =_be .MakeInteger (mcid );return _dbcb ;};func _dbaf (_deae *Chapter ,_bace *TOC ,_ebe *_gd .Outline ,_abd string ,_bdbb int ,_faf TextStyle )*Chapter {var _gggb uint =1;
if _deae !=nil {_gggb =_deae ._ecgg +1;};_bbca :=&Chapter {_gag :_bdbb ,_fagc :_abd ,_dge :true ,_addc :true ,_bae :_deae ,_bbg :_bace ,_acbg :_ebe ,_agef :[]Drawable {},_ecgg :_gggb };_ebac :=_dafab (_bbca .headingText (),_faf );_ebac .SetFont (_faf .Font );
_ebac .SetFontSize (_faf .FontSize );_bbca ._adbf =_ebac ;return _bbca ;};func (_cdagb *templateProcessor )parseLinkAttr (_aagg ,_ffcfg string )*_gd .PdfAnnotation {_ffcfg =_ddf .TrimSpace (_ffcfg );if _ddf .HasPrefix (_ffcfg ,"\u0075\u0072\u006c(\u0027")&&_ddf .HasSuffix (_ffcfg ,"\u0027\u0029")&&len (_ffcfg )> 7{return _cgdd (_ffcfg [5:len (_ffcfg )-2]);
};if _ddf .HasPrefix (_ffcfg ,"\u0070\u0061\u0067e\u0028")&&_ddf .HasSuffix (_ffcfg ,"\u0029")&&len (_ffcfg )> 6{var (_adfgf error ;_efgbg int64 ;_dggaa float64 ;_acba float64 ;_fgddc =1.0;_ecbbc =_ddf .Split (_ffcfg [5:len (_ffcfg )-1],"\u002c"););_efgbg ,_adfgf =_fd .ParseInt (_ddf .TrimSpace (_ecbbc [0]),10,64);
if _adfgf !=nil {_ca .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_adfgf );return nil ;};if len (_ecbbc )>=2{_dggaa ,_adfgf =_fd .ParseFloat (_ddf .TrimSpace (_ecbbc [1]),64);
if _adfgf !=nil {_ca .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_adfgf );
return nil ;};};if len (_ecbbc )>=3{_acba ,_adfgf =_fd .ParseFloat (_ddf .TrimSpace (_ecbbc [2]),64);if _adfgf !=nil {_ca .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_adfgf );
return nil ;};};if len (_ecbbc )>=4{_fgddc ,_adfgf =_fd .ParseFloat (_ddf .TrimSpace (_ecbbc [3]),64);if _adfgf !=nil {_ca .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_adfgf );
return nil ;};};return _egded (_efgbg -1,_dggaa ,_acba ,_fgddc );};return nil ;};func (_cfdac *TextChunk )Highlight (color Color ,alpha float64 )*_gd .PdfAnnotation {_acfdd ,_gcccc ,_gccde :=color .ToRGB ();_dcgaf :=_gd .NewPdfAnnotationHighlight ();_dcgaf .C =_be .MakeArrayFromFloats ([]float64 {_acfdd ,_gcccc ,_gccde });
_dcgaf .CA =_be .MakeFloat (alpha );_cfdac .AddAnnotation (_dcgaf .PdfAnnotation );return _dcgaf .PdfAnnotation ;};func (_baeda *StyledParagraph )appendChunk (_gbgc *TextChunk )*TextChunk {_baeda ._bcbc =append (_baeda ._bcbc ,_gbgc );_baeda .wrapText ();
return _gbgc ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_cdfc *Image )SetMargins (left ,right ,top ,bottom float64 ){_cdfc ._fcad .Left =left ;_cdfc ._fcad .Right =right ;_cdfc ._fcad .Top =top ;_cdfc ._fcad .Bottom =bottom ;};

// BorderColor returns the border color of the rectangle.
func (_cdca *Rectangle )BorderColor ()Color {return _cdca ._aagf };

// Indent returns the left offset of the list when nested into another list.
func (_cddb *List )Indent ()float64 {return _cddb ._eeccg };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_bcfe []*_gd .PdfAnnotation ;_dgdde []bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;};

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_ffcg *shading ;_gagb *_gd .PdfRectangle ;_cgdec AnchorPoint ;_edfe float64 ;_dcgb float64 ;_dabe float64 ;_bbbc float64 ;};

// Height returns the height of the chart.
func (_egeg *Chart )Height ()float64 {return float64 (_egeg ._bgcd .Height ())};func _ebeaed (_bcdggb string )([]string ,error ){var (_faacc []string ;_dfgcc []rune ;);for _ ,_ggba :=range _bcdggb {if _ggba =='\u000A'{if len (_dfgcc )> 0{_faacc =append (_faacc ,string (_dfgcc ));
};_faacc =append (_faacc ,string (_ggba ));_dfgcc =nil ;continue ;};_dfgcc =append (_dfgcc ,_ggba );};if len (_dfgcc )> 0{_faacc =append (_faacc ,string (_dfgcc ));};var _fefg []string ;for _ ,_egbgca :=range _faacc {_daaag :=[]rune (_egbgca );_aadaa :=_af .NewScanner (_daaag );
var _eebcf []rune ;for _ddeag :=0;_ddeag < len (_daaag );_ddeag ++{_ ,_cfea ,_edfd :=_aadaa .Next ();if _edfd !=nil {return nil ,_edfd ;};if _cfea ==_af .BreakProhibited ||_ab .IsSpace (_daaag [_ddeag ]){_eebcf =append (_eebcf ,_daaag [_ddeag ]);if _ab .IsSpace (_daaag [_ddeag ]){_fefg =append (_fefg ,string (_eebcf ));
_eebcf =[]rune {};};continue ;}else {if len (_eebcf )> 0{_fefg =append (_fefg ,string (_eebcf ));};_eebcf =[]rune {_daaag [_ddeag ]};};};if len (_eebcf )> 0{_fefg =append (_fefg ,string (_eebcf ));};};return _fefg ,nil ;};

// SetWidth sets line width.
func (_gcea *Curve )SetWidth (width float64 ){_gcea ._bdag =width };

// SkipRows skips over a specified number of rows in the table.
func (_aeac *Table )SkipRows (num int ){_adafd :=num *_aeac ._cafcb -1;if _adafd < 0{_ca .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _beef :=0;_beef < _adafd ;_beef ++{_aeac .NewCell ();};};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_fgb *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _cbgb (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// SetWidthBottom sets border width for bottom.
func (_dbff *border )SetWidthBottom (bw float64 ){_dbff ._fcec =bw };

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;

// SetText sets the text content of the Paragraph.
func (_bgdad *Paragraph )SetText (text string ){_bgdad ._bcgag =text };

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_aebg *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aebg ._agdb .Left ,_aebg ._agdb .Right ,_aebg ._agdb .Top ,_aebg ._agdb .Bottom ;};func (_ecec *TextChunk )clone ()*TextChunk {_bgbe :=*_ecec ;_bgbe ._bcfe =_aagc (_ecec ._bcfe );
return &_bgbe ;};func _egded (_ccaa int64 ,_aegb ,_deac ,_agega float64 )*_gd .PdfAnnotation {_eagaf :=_gd .NewPdfAnnotationLink ();_eagag :=_gd .NewBorderStyle ();_eagag .SetBorderWidth (0);_eagaf .BS =_eagag .ToPdfObject ();if _ccaa < 0{_ccaa =0;};_eagaf .Dest =_be .MakeArray (_be .MakeInteger (_ccaa ),_be .MakeName ("\u0058\u0059\u005a"),_be .MakeFloat (_aegb ),_be .MakeFloat (_deac ),_be .MakeFloat (_agega ));
return _eagaf .PdfAnnotation ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_fbeb *TOC )SetShowLinks (showLinks bool ){_fbeb ._daded =showLinks };func _acaec (_aafa ,_gfedgg ,_ddgbf int )[]int {_bbdfg :=[]int {};for _cfdad :=_aafa ;_cfdad <=_ddgbf ;_cfdad +=_gfedgg {_bbdfg =append (_bbdfg ,_cfdad );};return _bbdfg ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_abe *Block )ScaleToHeight (h float64 ){_fbgc :=h /_abe ._ad ;_abe .Scale (_fbgc ,_fbgc )};func (_bgbc *Creator )getActivePage ()*_gd .PdfPage {if _bgbc ._cafc ==nil {if len (_bgbc ._bee )==0{return nil ;};return _bgbc ._bee [len (_bgbc ._bee )-1];
};return _bgbc ._cafc ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_ebgf *Invoice )AddressHeadingStyle ()TextStyle {return _ebgf ._ddba };

// SetColorTop sets border color for top.
func (_bddc *border )SetColorTop (col Color ){_bddc ._ed =col };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_aabcg *Invoice )SetNoteStyle (style TextStyle ){_aabcg ._degfg =style };

// SetWidthLeft sets border width for left.
func (_gfb *border )SetWidthLeft (bw float64 ){_gfb ._cgd =bw };

// SetBorderWidth sets the border width.
func (_ddag *Polygon )SetBorderWidth (borderWidth float64 ){_ddag ._dbfd .BorderWidth =borderWidth };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_aadf *StyledParagraph )Height ()float64 {_aadf .wrapText ();var _bacca float64 ;for _ ,_cbbfc :=range _aadf ._ccae {var _cafd float64 ;for _ ,_ffbea :=range _cbbfc {_cgca :=_aadf ._bcde *_ffbea .Style .FontSize ;if _cgca > _cafd {_cafd =_cgca ;};
};_bacca +=_cafd ;};return _bacca ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_bfdb *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _fc .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _fc .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _fc .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_bfdb ._fbbbb =true ;_bfdb ._bccfd =startRow ;_bfdb ._deceb =endRow ;return nil ;};

// Scale scales Image by a constant factor, both width and height.
func (_ebae *Image )Scale (xFactor ,yFactor float64 ){_ebae ._dcbe =xFactor *_ebae ._dcbe ;_ebae ._fae =yFactor *_ebae ._fae ;};func (_dbbbc *templateProcessor )parseTextAlignmentAttr (_ecbfe ,_begba string )TextAlignment {_ca .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ecbfe ,_begba );
_bcfg :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_begba ];
return _bcfg ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_fgdce *Paragraph )SetTextAlignment (align TextAlignment ){_fgdce ._eced =align };

// Scale scales the ellipse dimensions by the specified factors.
func (_bbcae *Ellipse )Scale (xFactor ,yFactor float64 ){_bbcae ._gbea =xFactor *_bbcae ._gbea ;_bbcae ._fgbb =yFactor *_bbcae ._fgbb ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_gag int ;_fagc string ;_adbf *Paragraph ;_agef []Drawable ;_eec int ;_dge bool ;_addc bool ;_adba Positioning ;_ecg ,_fgd float64 ;_dfdg Margins ;_bae *Chapter ;_bbg *TOC ;_acbg *_gd .Outline ;_edge *_gd .OutlineItem ;_ecgg uint ;};
var _dfbbf =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_bfbgb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bdafc :_gfdba },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_bfbgb :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_bdafc :_cdae },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_bfbgb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bdafc :_fdaf },"\u0074\u0061\u0062l\u0065":&templateTag {_bfbgb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bdafc :_ddcfb },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_bfbgb :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_bdafc :_gdece },"\u006c\u0069\u006e\u0065":&templateTag {_bfbgb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bdafc :_fcde },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_bfbgb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bdafc :_dddf },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_bfbgb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bdafc :_dacbg },"\u0069\u006d\u0061g\u0065":&templateTag {_bfbgb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bdafc :_abadb },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_bfbgb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bdafc :_cfebg },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_bfbgb :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bdafc :_fbfgd },"\u0063\u0068\u0061r\u0074":&templateTag {_bfbgb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bdafc :_bggfea },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_bfbgb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bdafc :_baddb },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_bfbgb :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_bdafc :_caacc },"\u006c\u0069\u0073\u0074":&templateTag {_bfbgb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bdafc :_efafa },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_bfbgb :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_bdafc :_fedcb },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_bfbgb :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bdafc :_gfged }};
func (_dcba *StyledParagraph )getTextWidth ()float64 {var _gbbcd float64 ;_acddg :=len (_dcba ._bcbc );for _ceae ,_egcgg :=range _dcba ._bcbc {_gegd :=&_egcgg .Style ;_daaf :=len (_egcgg .Text );for _ccab ,_abfa :=range _egcgg .Text {if _abfa =='\u000A'{continue ;
};_efed ,_edef :=_gegd .Font .GetRuneMetrics (_abfa );if !_edef {_ca .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_abfa );
return -1;};_gbbcd +=_gegd .FontSize *_efed .Wx *_gegd .horizontalScale ();if _abfa !=' '&&(_ceae !=_acddg -1||_ccab !=_daaf -1){_gbbcd +=_gegd .CharSpacing *1000.0;};};};return _gbbcd ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_bgc *Block )Draw (d Drawable )error {_gce :=DrawContext {};_gce .Width =_bgc ._de ;_gce .Height =_bgc ._ad ;_gce .PageWidth =_bgc ._de ;_gce .PageHeight =_bgc ._ad ;_gce .X =0;_gce .Y =0;_bfe ,_ ,_ggd :=d .GeneratePageBlocks (_gce );if _ggd !=nil {return _ggd ;
};if len (_bfe )!=1{return ErrContentNotFit ;};for _ ,_ffg :=range _bfe {if _aed :=_bgc .mergeBlocks (_ffg );_aed !=nil {return _aed ;};};return nil ;};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_cccg Drawable )(Drawable ,error );};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_dgcfd *LinearShading )AddShadingResource (block *Block )(_agafg _be .PdfObjectName ,_fbeac error ){_bcabc :=1;_agafg =_be .PdfObjectName ("\u0053\u0068"+_fd .Itoa (_bcabc ));for block ._fa .HasShadingByName (_agafg ){_bcabc ++;_agafg =_be .PdfObjectName ("\u0053\u0068"+_fd .Itoa (_bcabc ));
};if _dfdd :=block ._fa .SetShadingByName (_agafg ,_dgcfd .shadingModel ().ToPdfObject ());_dfdd !=nil {return "",_dfdd ;};return _agafg ,nil ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ge *_eag .ContentStreamOperations ;_fa *_gd .PdfPageResources ;_agg Positioning ;_eg ,_bge float64 ;_de float64 ;_ad float64 ;_ac float64 ;_bc Margins ;_bdc []*_gd .PdfAnnotation ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_aafe *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbea :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dbdb ,_ ,_gcdd :=_aafe .draw (_cbea ,"");if _gcdd !=nil {return nil ,ctx ,_gcdd ;};_gcdd =_cbea .addContentsByString (string (_dbdb ));
if _gcdd !=nil {return nil ,ctx ,_gcdd ;};return []*Block {_cbea },ctx ,nil ;};type templateNode struct{_fdfd interface{};_eccfd _b .StartElement ;_ddbbd *templateNode ;_gbdd int ;_ggcca int ;_afdda int64 ;};func _fgfcf (_bbab float64 ,_bgcbg float64 )float64 {return _ff .Round (_bbab /_bgcbg )*_bgcbg };


// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_abg *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _cfgc (xc ,yc ,width ,height );};func _agfg (_fgdc string )(*GraphicSVG ,error ){_fbdeg ,_gfcg :=_ea .ParseFromString (_fgdc );if _gfcg !=nil {return nil ,_gfcg ;};return _badfd (_fbdeg );
};func (_bgfd *Block )duplicate ()*Block {_cgg :=&Block {};*_cgg =*_bgfd ;_gf :=_eag .ContentStreamOperations {};_gf =append (_gf ,*_bgfd ._ge ...);_cgg ._ge =&_gf ;return _cgg ;};func _febba (_cabc []_ddb .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_bgdab :&_ddb .PolyBezierCurve {Curves :_cabc ,BorderColor :_gd .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_dcfbf :1.0,_acfb :1.0};
};

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_bffd *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bffd ._ddfgb .Left ,_bffd ._ddfgb .Right ,_bffd ._ddfgb .Top ,_bffd ._ddfgb .Bottom ;};

// SetBorderWidth sets the border width of the ellipse.
func (_ggde *Ellipse )SetBorderWidth (bw float64 ){_ggde ._fdcc =bw };

// The Image type is used to draw an image onto PDF.
type Image struct{_cbaag *_gd .XObjectImage ;_dgaaf *_gd .Image ;_bfbga string ;_afgb float64 ;_dcbe ,_fae float64 ;_dade ,_abecc float64 ;_dbafc Positioning ;_ggaca HorizontalAlignment ;_aeae float64 ;_bgabe float64 ;_fgec float64 ;_fcad Margins ;_cdfa ,_ecag float64 ;
_bdeb _be .StreamEncoder ;_gfba FitMode ;_bfbd bool ;_cebad *int64 ;};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline ,_bcfe :[]*_gd .PdfAnnotation {},_dgdde :[]bool {}};};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_fdeb float64 ;_fefcd float64 ;_dacdg float64 ;_ddccd float64 ;_dbdf Positioning ;_gffbd Color ;_aadb float64 ;_aagf Color ;_bcdgg float64 ;_ggge float64 ;_dfegd float64 ;_afgd float64 ;_ebddb float64 ;_fcgc float64 ;_ddfgb Margins ;
_dfgc FitMode ;_bcee *int64 ;};

// Horizontal returns total horizontal (left + right) margin.
func (_ccceb *Margins )Horizontal ()float64 {return _ccceb .Left +_ccceb .Right };

// SetMargins sets the Paragraph's margins.
func (_eefg *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_eefg ._affa .Left =left ;_eefg ._affa .Right =right ;_eefg ._affa .Top =top ;_eefg ._affa .Bottom =bottom ;};

// FitMode returns the fit mode of the rectangle.
func (_ccfg *Rectangle )FitMode ()FitMode {return _ccfg ._dfgc };func _dafab (_baeb string ,_cfaf TextStyle )*Paragraph {_gffce :=&Paragraph {_bcgag :_baeb ,_caccd :_cfaf .Font ,_geac :_cfaf .FontSize ,_agdbb :1.0,_abaa :true ,_aagb :true ,_eced :TextAlignmentLeft ,_ggc :0,_babg :1,_bcadb :1,_adfd :PositionRelative ,_fbbdg :""};
_gffce .SetColor (_cfaf .Color );return _gffce ;};func _agcee (_cdcaf interface{})(interface{},error ){switch _cbaab :=_cdcaf .(type ){case uint8 :return int64 (_cbaab ),nil ;case int8 :return int64 (_cbaab ),nil ;case uint16 :return int64 (_cbaab ),nil ;
case int16 :return int64 (_cbaab ),nil ;case uint32 :return int64 (_cbaab ),nil ;case int32 :return int64 (_cbaab ),nil ;case uint64 :return int64 (_cbaab ),nil ;case int64 :return _cbaab ,nil ;case int :return int64 (_cbaab ),nil ;case float32 :return float64 (_cbaab ),nil ;
case float64 :return _cbaab ,nil ;};return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0076\u0061\u006c\u0075\u0065\u002c\u0020\u0025\u0076\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072",_cdcaf );
};

// SetSideBorderStyle sets the cell's side border style.
func (_cdebg *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_cdebg ._gcccg =style ;_cdebg ._dgag =style ;_cdebg ._bddcf =style ;_cdebg ._deef =style ;case CellBorderSideTop :_cdebg ._gcccg =style ;
case CellBorderSideBottom :_cdebg ._dgag =style ;case CellBorderSideLeft :_cdebg ._bddcf =style ;case CellBorderSideRight :_cdebg ._deef =style ;};};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_cfffa *TOC )SetLineSeparator (separator string ){_cfffa ._gffbbe =separator };func (_cagb *templateProcessor )parseFloatArray (_fbgf ,_fead string )[]float64 {_ca .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fbgf ,_fead );
_fadgg :=_ddf .Fields (_fead );_befbb :=make ([]float64 ,0,len (_fadgg ));for _ ,_dgeg :=range _fadgg {_fdgfb ,_ :=_fd .ParseFloat (_dgeg ,64);_befbb =append (_befbb ,_fdgfb );};return _befbb ;};

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_cgcb *Division )SetMargins (left ,right ,top ,bottom float64 ){_cgcb ._fceg .Left =left ;_cgcb ._fceg .Right =right ;_cgcb ._fceg .Top =top ;_cgcb ._fceg .Bottom =bottom ;};type componentRenderer interface{Draw (_afga Drawable )error ;};func _cgdd (_fcgd string )*_gd .PdfAnnotation {_gcec :=_gd .NewPdfAnnotationLink ();
_beedc :=_gd .NewBorderStyle ();_beedc .SetBorderWidth (0);_gcec .BS =_beedc .ToPdfObject ();_gbbab :=_gd .NewPdfActionURI ();_gbbab .URI =_be .MakeString (_fcgd );_gcec .SetAction (_gbbab .PdfAction );return _gcec .PdfAnnotation ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_gebb *Chapter )GetHeading ()*Paragraph {return _gebb ._adbf };func _dddf (_efgc *templateProcessor ,_befae *templateNode )(interface{},error ){return _efgc .parseRectangle (_befae );};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_bfbee *TOCLine )SetStyle (style TextStyle ){_bfbee .Number .Style =style ;_bfbee .Title .Style =style ;_bfbee .Separator .Style =style ;_bfbee .Page .Style =style ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_bgf *Block )AddAnnotation (annotation *_gd .PdfAnnotation ){for _ ,_eeb :=range _bgf ._bdc {if _eeb ==annotation {return ;};};_bgf ._bdc =append (_bgf ._bdc ,annotation );};

// SetFillColor sets background color for border.
func (_fca *border )SetFillColor (col Color ){_fca ._agaab =col };type grayColor struct{_ddcc float64 };

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_eaggd *Line )SetFitMode (fitMode FitMode ){_eaggd ._aedgf =fitMode };

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _cgeb (color ,point )};

// Inline returns whether the inline mode of the division is active.
func (_acaf *Division )Inline ()bool {return _acaf ._dccc };func (_dgfff *templateProcessor )parseDivision (_cgdc *templateNode )(interface{},error ){_acdf :=_dgfff .creator .NewDivision ();for _ ,_bdbed :=range _cgdc ._eccfd .Attr {_geaff :=_bdbed .Value ;
switch _dfgd :=_bdbed .Name .Local ;_dfgd {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_acdf .EnablePageWrap (_dgfff .parseBoolAttr (_dfgd ,_geaff ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_edbg :=_dgfff .parseMarginAttr (_dfgd ,_geaff );
_acdf .SetMargins (_edbg .Left ,_edbg .Right ,_edbg .Top ,_edbg .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_bgbbf :=_dgfff .parseMarginAttr (_dfgd ,_geaff );_acdf .SetPadding (_bgbbf .Left ,_bgbbf .Right ,_bgbbf .Top ,_bgbbf .Bottom );default:_dgfff .nodeLogDebug (_cgdc ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dfgd );
};};return _acdf ,nil ;};

// NewCellProps returns the default properties of an invoice cell.
func (_bbfac *Invoice )NewCellProps ()InvoiceCellProps {_ccacb :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_bbfac ._bdae ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_ccacb ,BorderColor :_ccacb ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_fbea *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _acbe (x ,y ,width ,height );};

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_daeec *Rectangle )BorderOpacity ()float64 {return _daeec ._ggge };

// SetWidth sets the width of the rectangle.
func (_dbgf *Rectangle )SetWidth (width float64 ){_dbgf ._dacdg =width };func (_gdfe *Image )rotatedSize ()(float64 ,float64 ){_fgae :=_gdfe ._dcbe ;_cee :=_gdfe ._fae ;_cacb :=_gdfe ._afgb ;if _cacb ==0{return _fgae ,_cee ;};_adaa :=_ddb .Path {Points :[]_ddb .Point {_ddb .NewPoint (0,0).Rotate (_cacb ),_ddb .NewPoint (_fgae ,0).Rotate (_cacb ),_ddb .NewPoint (0,_cee ).Rotate (_cacb ),_ddb .NewPoint (_fgae ,_cee ).Rotate (_cacb )}}.GetBoundingBox ();
return _adaa .Width ,_adaa .Height ;};func _eefca (_bggda ,_ggbbc ,_ebafb string ,_feadd uint ,_cebgec TextStyle )*TOCLine {return _gcaeg (TextChunk {Text :_bggda ,Style :_cebgec },TextChunk {Text :_ggbbc ,Style :_cebgec },TextChunk {Text :_ebafb ,Style :_cebgec },_feadd ,_cebgec );
};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_cgab :_ff .Max (_ff .Min (c ,1.0),0.0),_bfdc :_ff .Max (_ff .Min (m ,1.0),0.0),_fec :_ff .Max (_ff .Min (y ,1.0),0.0),_febg :_ff .Max (_ff .Min (k ,1.0),0.0)};};

// SetColor sets the line color.
func (_cbgd *Curve )SetColor (col Color ){_cbgd ._gffeeb =col };var PPMM =float64 (72*1.0/25.4);

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_eefa *TableCell )SetContent (vd VectorDrawable )error {switch _efga :=vd .(type ){case *Paragraph :if _efga ._aagb {_efga ._abaa =true ;};_eefa ._bdea =vd ;case *StyledParagraph :if _efga ._baceb {_efga ._egbgc =true ;};_eefa ._bdea =vd ;case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_eefa ._bdea =vd ;
default:_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _be .ErrTypeError ;};return nil ;};func (_aff *Creator )setActivePage (_acda *_gd .PdfPage ){_aff ._cafc =_acda };func (_afad *Division )ctxHeight (_bdfa float64 )float64 {_bdfa -=_afad ._fceg .Left +_afad ._fceg .Right +_afad ._dcfb .Left +_afad ._dcfb .Right ;
var _adag float64 ;for _ ,_fegc :=range _afad ._cggf {_adag +=_ccac (_fegc ,_bdfa );};return _adag ;};

// NewTable create a new Table with a specified number of columns.
func (_aacb *Creator )NewTable (cols int )*Table {return _gdcg (cols )};func _cfbbd (_eebcg *_gd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_eebcg ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_egeee *TOC )SetHeading (text string ,style TextStyle ){_cced :=_egeee .Heading ();_cced .Reset ();_dbga :=_cced .Append (text );_dbga .Style =style ;};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_eebd *Division )EnablePageWrap (enable bool ){_eebd ._adbb =enable };

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_dbec *Rectangle )FillOpacity ()float64 {return _dbec ._aadb };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_daeef *Image )SetEncoder (encoder _be .StreamEncoder ){_daeef ._bdeb =encoder };func (_fcd *Block )transform (_fcb _cbe .Matrix ){_bgfb :=_eag .NewContentCreator ().Add_cm (_fcb [0],_fcb [1],_fcb [3],_fcb [4],_fcb [6],_fcb [7]).Operations ();*_fcd ._ge =append (*_bgfb ,*_fcd ._ge ...);
_fcd ._ge .WrapIfNeeded ();};type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// GeneratePageBlocks generates a page break block.
func (_eaec *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cecee :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_gfecb :=ctx ;_gfecb .Y =ctx .Margins .Top ;
_gfecb .X =ctx .Margins .Left ;_gfecb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_gfecb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_gfecb ;return _cecee ,ctx ,nil ;};

// SetBorderRadius sets the radius of the background corners.
func (_ga *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_ga .BorderRadiusTopLeft =topLeft ;_ga .BorderRadiusTopRight =topRight ;_ga .BorderRadiusBottomLeft =bottomLeft ;_ga .BorderRadiusBottomRight =bottomRight ;};

// CurCol returns the currently active cell's column number.
func (_fefed *Table )CurCol ()int {_dfeab :=(_fefed ._eaeec -1)%(_fefed ._cafcb )+1;return _dfeab };

// SetMargins sets the margins of the chart component.
func (_fbbc *Chart )SetMargins (left ,right ,top ,bottom float64 ){_fbbc ._aabg .Left =left ;_fbbc ._aabg .Right =right ;_fbbc ._aabg .Top =top ;_fbbc ._aabg .Bottom =bottom ;};

// SetBorderColor sets the border color for the path.
func (_eeed *FilledCurve )SetBorderColor (color Color ){_eeed ._aebe =color };

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_cbf *Chapter )Add (d Drawable )error {if Drawable (_cbf )==d {_ca .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _fc .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _cef :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_cbf ._agef =append (_cbf ._agef ,d );case containerDrawable :_bgb ,_bga :=_cef .ContainerComponent (_cbf );
if _bga !=nil {return _bga ;};_cbf ._agef =append (_cbf ._agef ,_bgb );default:_ca .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _fc .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// GeneratePageBlocks draws the chart onto a block.
func (_accd *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aba :=ctx ;_bcc :=_accd ._eebg .IsRelative ();var _bgd []*Block ;if _bcc {_cafg :=1.0;_agf :=_accd ._aabg .Top ;if float64 (_accd ._bgcd .Height ())> ctx .Height -_accd ._aabg .Top {_bgd =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _cgge error ;if _ ,ctx ,_cgge =_addgg ().GeneratePageBlocks (ctx );_cgge !=nil {return nil ,ctx ,_cgge ;};_agf =0;};ctx .X +=_accd ._aabg .Left +_cafg ;ctx .Y +=_agf ;ctx .Width -=_accd ._aabg .Left +_accd ._aabg .Right +2*_cafg ;ctx .Height -=_agf ;
_accd ._bgcd .SetWidth (int (ctx .Width ));}else {ctx .X =_accd ._cfca ;ctx .Y =_accd ._badb ;};_gda :=_eag .NewContentCreator ();if _accd ._gcge !=nil {_gda .Add_BDC (*_be .MakeName (_gd .StructureTypeFigure ),map[string ]_be .PdfObject {"\u004d\u0043\u0049\u0044":_be .MakeInteger (*_accd ._gcge )});
};_gda .Translate (0,ctx .PageHeight );_gda .Scale (1,-1);_gda .Translate (ctx .X ,ctx .Y );_afb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_accd ._bgcd .Render (_bd .NewRenderer (_gda ,_afb ._fa ),nil );if _accd ._gcge !=nil {_gda .Add_EMC ();};if _efdb :=_afb .addContentsByString (_gda .String ());
_efdb !=nil {return nil ,ctx ,_efdb ;};if _bcc {_ffe :=_accd .Height ()+_accd ._aabg .Bottom ;ctx .Y +=_ffe ;ctx .Height -=_ffe ;}else {ctx =_aba ;};_bgd =append (_bgd ,_afb );return _bgd ,ctx ,nil ;};

// Title returns the title of the invoice.
func (_daaa *Invoice )Title ()string {return _daaa ._bgfbda };

// FillColor returns the fill color of the rectangle.
func (_aeee *Rectangle )FillColor ()Color {return _aeee ._gffbd };func _abadb (_gdgce *templateProcessor ,_ebec *templateNode )(interface{},error ){return _gdgce .parseImage (_ebec );};func _fedcb (_fcdd *templateProcessor ,_defcf *templateNode )(interface{},error ){return _fcdd .parseListItem (_defcf );
};

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_cgde *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _dgdg (x ,y ,innerRadius ,outerRadius ,colorPoints );};func (_dfcged *templateProcessor )parseLine (_gbaf *templateNode )(interface{},error ){_gaga :=_dfcged .creator .NewLine (0,0,0,0);
for _ ,_bbdfd :=range _gbaf ._eccfd .Attr {_adfgg :=_bbdfd .Value ;switch _defb :=_bbdfd .Name .Local ;_defb {case "\u0078\u0031":_gaga ._cbagd =_dfcged .parseFloatAttr (_defb ,_adfgg );case "\u0079\u0031":_gaga ._efeb =_dfcged .parseFloatAttr (_defb ,_adfgg );
case "\u0078\u0032":_gaga ._agbba =_dfcged .parseFloatAttr (_defb ,_adfgg );case "\u0079\u0032":_gaga ._dcga =_dfcged .parseFloatAttr (_defb ,_adfgg );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_gaga .SetLineWidth (_dfcged .parseFloatAttr (_defb ,_adfgg ));
case "\u0063\u006f\u006co\u0072":_gaga .SetColor (_dfcged .parseColorAttr (_defb ,_adfgg ));case "\u0073\u0074\u0079l\u0065":_gaga .SetStyle (_dfcged .parseLineStyleAttr (_defb ,_adfgg ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_gaga .SetDashPattern (_dfcged .parseInt64Array (_defb ,_adfgg ),_gaga ._aaed );
case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_gaga .SetDashPattern (_gaga ._cccd ,_dfcged .parseInt64Attr (_defb ,_adfgg ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_gaga .SetOpacity (_dfcged .parseFloatAttr (_defb ,_adfgg ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_gaga .SetPositioning (_dfcged .parsePositioningAttr (_defb ,_adfgg ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_gaga .SetFitMode (_dfcged .parseFitModeAttr (_defb ,_adfgg ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_caeb :=_dfcged .parseMarginAttr (_defb ,_adfgg );
_gaga .SetMargins (_caeb .Left ,_caeb .Right ,_caeb .Top ,_caeb .Bottom );default:_dfcged .nodeLogDebug (_gbaf ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_defb );
};};return _gaga ,nil ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_ecaf *Creator )PageFinalize (pageFinalizeFunc func (_gcfa PageFinalizeFunctionArgs )error ){_ecaf ._bdfe =pageFinalizeFunc ;};func (_gcffc *templateProcessor )parseListItem (_bgbcc *templateNode )(interface{},error ){if _bgbcc ._ddbbd ==nil {_gcffc .nodeLogError (_bgbcc ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_eeeee ;};_gfaf ,_dgac :=_bgbcc ._ddbbd ._fdfd .(*List );if !_dgac {_gcffc .nodeLogError (_bgbcc ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_eeeee ;};_dgbc :=_dfcd ();_dgbc ._gdeca =_gfaf ._cacc ;return _dgbc ,nil ;};type templateTag struct{_bfbgb map[string ]struct{};_bdafc func (*templateProcessor ,*templateNode )(interface{},error );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gfgf *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _ggef float64 ;var _cfaaf []*StyledParagraph ;for _ ,_ccca :=range _gfgf ._fadf {_acaef :=_aedcd (_gfgf ._edga );_acaef .SetEnableWrap (false );_acaef .SetTextAlignment (TextAlignmentRight );
_acaef .Append (_ccca ._gdeca .Text ).Style =_ccca ._gdeca .Style ;_daddg :=_acaef .getTextWidth ()/1000.0/ctx .Width ;if _ggef < _daddg {_ggef =_daddg ;};_cfaaf =append (_cfaaf ,_acaef );};_geg :=_gdcg (2);_geg .SetColumnWidths (_ggef ,1-_ggef );_geg .SetMargins (_gfgf ._edgdc .Left +_gfgf ._eeccg ,_gfgf ._edgdc .Right ,_gfgf ._edgdc .Top ,_gfgf ._edgdc .Bottom );
_geg .EnableRowWrap (true );for _bcga ,_gfbe :=range _gfgf ._fadf {_ebba :=_geg .NewCell ();_ebba .SetIndent (0);_ebba .SetContent (_cfaaf [_bcga ]);_ebba =_geg .NewCell ();_ebba .SetIndent (0);_ebba .SetContent (_gfbe ._cfec );};return _geg .GeneratePageBlocks (ctx );
};

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_faee *shading ;_ddfb *_gd .PdfRectangle ;_cfebd float64 ;};

// LineWidth returns the width of the line.
func (_ceeb *Line )LineWidth ()float64 {return _ceeb ._adcb };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_dbaea *TOC )SetLineSeparatorStyle (style TextStyle ){_dbaea ._daffbe =style };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_adeab *shading )SetBackgroundColor (backgroundColor Color ){_adeab ._bbdfc =backgroundColor };func _bgca (_gcdfe *Creator ,_cdab _cb .Reader ,_dggde interface{},_aade *TemplateOptions ,_dbfef componentRenderer )error {if _gcdfe ==nil {_ca .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _dgaba ;};_cddce :="";if _ccfc ,_bcaee :=_cdab .(*_e .File );_bcaee {_cddce =_ccfc .Name ();};_cdfcf :=_cc .NewBuffer (nil );if _ ,_bedae :=_cb .Copy (_cdfcf ,_cdab );_bedae !=nil {return _bedae ;};_fbef :=_fb .FuncMap {"\u0064\u0069\u0063\u0074":_aegcb ,"\u0061\u0064\u0064":_adebe ,"\u0061\u0072\u0072a\u0079":_cddab ,"\u0065\u0078\u0074\u0065\u006e\u0064\u0044\u0069\u0063\u0074":_cgfa ,"\u006da\u006b\u0065\u0053\u0065\u0071":_acaec };
if _aade !=nil &&_aade .HelperFuncMap !=nil {for _ddcad ,_cgcbfc :=range _aade .HelperFuncMap {if _ ,_eagd :=_fbef [_ddcad ];_eagd {_ca .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ddcad );
continue ;};_fbef [_ddcad ]=_cgcbfc ;};};_aegc ,_ffeca :=_fb .New ("").Funcs (_fbef ).Parse (_cdfcf .String ());if _ffeca !=nil {return _ffeca ;};if _aade !=nil &&_aade .SubtemplateMap !=nil {for _aafgb ,_ebcde :=range _aade .SubtemplateMap {if _aafgb ==""{_ca .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _ebcde ==nil {_ca .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_cegae :=_cc .NewBuffer (nil );if _ ,_cgcbd :=_cb .Copy (_cegae ,_ebcde );_cgcbd !=nil {return _cgcbd ;};if _ ,_dbdeb :=_aegc .New (_aafgb ).Parse (_cegae .String ());_dbdeb !=nil {return _dbdeb ;};};};_cdfcf .Reset ();if _begc :=_aegc .Execute (_cdfcf ,_dggde );
_begc !=nil {return _begc ;};return _bdda (_gcdfe ,_cddce ,_cdfcf .Bytes (),_aade ,_dbfef ).run ();};func (_eedg *List )split (_aggcd DrawContext )(_baca ,_gagg *List ){var (_dcfg float64 ;_eede ,_cdadd []*listItem ;);_acbgb :=_aggcd .Width -_eedg ._edgdc .Horizontal ()-_eedg ._eeccg -_eedg .markerWidth ();
_ebea :=_eedg .markerWidth ();for _cggc ,_cgf :=range _eedg ._fadf {_fcfg :=_cgf .ctxHeight (_acbgb );_dcfg +=_fcfg ;if _dcfg <=_aggcd .Height {_eede =append (_eede ,_cgf );}else {switch _cgce :=_cgf ._cfec .(type ){case *List :_dcbbe :=_aggcd ;_dcbbe .Height =_ff .Floor (_fcfg -(_dcfg -_aggcd .Height ));
_feeeb ,_bfca :=_cgce .split (_dcbbe );if _feeeb !=nil {_defe :=_dfcd ();_defe ._gdeca =_cgf ._gdeca ;_defe ._cfec =_feeeb ;_eede =append (_eede ,_defe );};if _bfca !=nil {_ddbe :=_cgce ._cacc .Style .FontSize ;_ecab ,_bfgg :=_cgce ._cacc .Style .Font .GetRuneMetrics (' ');
if _bfgg {_ddbe =_cgce ._cacc .Style .FontSize *_ecab .Wx *_cgce ._cacc .Style .horizontalScale ()/1000.0;};_eabc :=_ddf .Repeat ("\u0020",int (_ebea /_ddbe ));_gefdf :=_dfcd ();_gefdf ._gdeca =*NewTextChunk (_eabc ,_cgce ._cacc .Style );_gefdf ._cfec =_bfca ;
_cdadd =append (_cdadd ,_gefdf );_cdadd =append (_cdadd ,_eedg ._fadf [_cggc +1:]...);};default:_cdadd =_eedg ._fadf [_cggc :];};if len (_cdadd )> 0{break ;};};};if len (_eede )> 0{_baca =_bacfg (_eedg ._edga );*_baca =*_eedg ;_baca ._fadf =_eede ;};if len (_cdadd )> 0{_gagg =_bacfg (_eedg ._edga );
*_gagg =*_eedg ;_gagg ._fadf =_cdadd ;};return _baca ,_gagg ;};

// Scale scales the rectangle dimensions by the specified factors.
func (_ccad *Rectangle )Scale (xFactor ,yFactor float64 ){_ccad ._dacdg =xFactor *_ccad ._dacdg ;_ccad ._ddccd =yFactor *_ccad ._ddccd ;};

// SetDueDate sets the due date of the invoice.
func (_fcede *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_fcede ._fgfe [1].Value =dueDate ;return _fcede ._fgfe [0],_fcede ._fgfe [1];};

// SetMargins sets the margins TOC line.
func (_fcaaa *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_fcaaa ._gdcff =left ;_gabf :=&_fcaaa ._ecfeg ._affa ;_gabf .Left =_fcaaa ._gdcff +float64 (_fcaaa ._bfcf -1)*_fcaaa ._gedeb ;_gabf .Right =right ;_gabf .Top =top ;_gabf .Bottom =bottom ;
};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_afffg *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_afffg ._bebbe =halign ;};

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_ecddf *LinearShading )SetAngle (angle float64 ){_ecddf ._cfebd =angle };

// SetBorderWidth sets the border width.
func (_ggag *CurvePolygon )SetBorderWidth (borderWidth float64 ){_ggag ._fbff .BorderWidth =borderWidth };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fbbbff *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gefca :=ctx ;_afega ,ctx ,_fcgdb :=_fbbbff ._ecfeg .GeneratePageBlocks (ctx );if _fcgdb !=nil {return _afega ,ctx ,_fcgdb ;};if _fbbbff ._cdfed .IsRelative (){ctx .X =_gefca .X ;
};if _fbbbff ._cdfed .IsAbsolute (){return _afega ,_gefca ,nil ;};return _afega ,ctx ,nil ;};

// SetCoords sets the center coordinates of the ellipse.
func (_afda *Ellipse )SetCoords (xc ,yc float64 ){_afda ._dbeb =xc ;_afda ._caaf =yc };

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_cca *Block )DrawTemplate (c *Creator ,r _cb .Reader ,data interface{},options *TemplateOptions )error {return _bgca (c ,r ,data ,options ,_cca );};func (_aeaed *templateProcessor )parseTextRenderingModeAttr (_faaf ,_bedbc string )TextRenderingMode {_ca .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_faaf ,_bedbc );
_edgdb :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_bedbc ];
return _edgdb ;};

// SetWidth sets the width of the ellipse.
func (_efdc *Ellipse )SetWidth (width float64 ){_efdc ._gbea =width };func (_gafgf *templateProcessor )parseTextOverflowAttr (_adebc ,_eedea string )TextOverflow {_ca .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_adebc ,_eedea );
_becb :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_eedea ];return _becb ;};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_gcdf *Creator )NewPolyBezierCurve (curves []_ddb .CubicBezierCurve )*PolyBezierCurve {return _febba (curves );};func _cgeb (_efbad Color ,_febbb float64 )*ColorPoint {return &ColorPoint {_ccfgb :_efbad ,_aeeb :_febbb };};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_bgcd _fbb .ChartRenderable ;_eebg Positioning ;_cfca float64 ;_badb float64 ;_aabg Margins ;_gcge *int64 ;};func (_gfeded *templateProcessor )parseTableCell (_bddaa *templateNode )(interface{},error ){if _bddaa ._ddbbd ==nil {_gfeded .nodeLogError (_bddaa ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_eeeee ;};_fafcca ,_ecgbf :=_bddaa ._ddbbd ._fdfd .(*Table );if !_ecgbf {_gfeded .nodeLogError (_bddaa ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_bddaa ._ddbbd ._fdfd );
return nil ,_eeeee ;};var _beeee ,_dabbf int64 ;for _ ,_beccg :=range _bddaa ._eccfd .Attr {_ggceg :=_beccg .Value ;switch _dbafcg :=_beccg .Name .Local ;_dbafcg {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_beeee =_gfeded .parseInt64Attr (_dbafcg ,_ggceg );
case "\u0072o\u0077\u0073\u0070\u0061\u006e":_dabbf =_gfeded .parseInt64Attr (_dbafcg ,_ggceg );};};if _beeee <=0{_beeee =1;};if _dabbf <=0{_dabbf =1;};_bgaga :=_fafcca .MultiCell (int (_dabbf ),int (_beeee ));for _ ,_cdcba :=range _bddaa ._eccfd .Attr {_aefdf :=_cdcba .Value ;
switch _fdgf :=_cdcba .Name .Local ;_fdgf {case "\u0069\u006e\u0064\u0065\u006e\u0074":_bgaga .SetIndent (_gfeded .parseFloatAttr (_fdgf ,_aefdf ));case "\u0061\u006c\u0069g\u006e":_bgaga .SetHorizontalAlignment (_gfeded .parseCellAlignmentAttr (_fdgf ,_aefdf ));
case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_bgaga .SetVerticalAlignment (_gfeded .parseCellVerticalAlignmentAttr (_fdgf ,_aefdf ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_bgaga .SetSideBorderStyle (CellBorderSideAll ,_gfeded .parseCellBorderStyleAttr (_fdgf ,_aefdf ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_bgaga .SetSideBorderStyle (CellBorderSideTop ,_gfeded .parseCellBorderStyleAttr (_fdgf ,_aefdf ));case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_bgaga .SetSideBorderStyle (CellBorderSideBottom ,_gfeded .parseCellBorderStyleAttr (_fdgf ,_aefdf ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_bgaga .SetSideBorderStyle (CellBorderSideLeft ,_gfeded .parseCellBorderStyleAttr (_fdgf ,_aefdf ));case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_bgaga .SetSideBorderStyle (CellBorderSideRight ,_gfeded .parseCellBorderStyleAttr (_fdgf ,_aefdf ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_bgaga .SetSideBorderWidth (CellBorderSideAll ,_gfeded .parseFloatAttr (_fdgf ,_aefdf ));case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_bgaga .SetSideBorderWidth (CellBorderSideTop ,_gfeded .parseFloatAttr (_fdgf ,_aefdf ));
case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_bgaga .SetSideBorderWidth (CellBorderSideBottom ,_gfeded .parseFloatAttr (_fdgf ,_aefdf ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_bgaga .SetSideBorderWidth (CellBorderSideLeft ,_gfeded .parseFloatAttr (_fdgf ,_aefdf ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_bgaga .SetSideBorderWidth (CellBorderSideRight ,_gfeded .parseFloatAttr (_fdgf ,_aefdf ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_bgaga .SetSideBorderColor (CellBorderSideAll ,_gfeded .parseColorAttr (_fdgf ,_aefdf ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_bgaga .SetSideBorderColor (CellBorderSideTop ,_gfeded .parseColorAttr (_fdgf ,_aefdf ));case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_bgaga .SetSideBorderColor (CellBorderSideBottom ,_gfeded .parseColorAttr (_fdgf ,_aefdf ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_bgaga .SetSideBorderColor (CellBorderSideLeft ,_gfeded .parseColorAttr (_fdgf ,_aefdf ));case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_bgaga .SetSideBorderColor (CellBorderSideRight ,_gfeded .parseColorAttr (_fdgf ,_aefdf ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_bgaga .SetBorderLineStyle (_gfeded .parseLineStyleAttr (_fdgf ,_aefdf ));case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_bgaga .SetBackgroundColor (_gfeded .parseColorAttr (_fdgf ,_aefdf ));
case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;default:_gfeded .nodeLogDebug (_bddaa ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_fdgf );
};};return _bgaga ,nil ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_ced *Creator )MoveRight (dx float64 ){_ced ._ecfb .X +=dx };func (_bdfac *templateProcessor )parseLinearGradientAttr (creator *Creator ,_caag string )Color {_fbae :=ColorBlack ;if _caag ==""{return _fbae ;};_dgdaf :=creator .NewLinearGradientColor ([]*ColorPoint {});
_dgdaf .SetExtends (true ,true );var (_adab =_ddf .Split (_caag [16:len (_caag )-1],"\u002c");_fcccf =_ddf .TrimSpace (_adab [0]););if _ddf .HasSuffix (_fcccf ,"\u0064\u0065\u0067"){_bcgcfg ,_eafe :=_fd .ParseFloat (_fcccf [:len (_fcccf )-3],64);if _eafe !=nil {_ca .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_eafe );
}else {_dgdaf .SetAngle (_bcgcfg );};_adab =_adab [1:];};_eedeg ,_dggb :=_bdfac .processGradientColorPair (_adab );if _eedeg ==nil ||_dggb ==nil {return _fbae ;};for _ccgfg :=0;_ccgfg < len (_eedeg );_ccgfg ++{_dgdaf .AddColorStop (_eedeg [_ccgfg ],_dggb [_ccgfg ]);
};return _dgdaf ;};

// SellerAddress returns the seller address used in the invoice template.
func (_gbfa *Invoice )SellerAddress ()*InvoiceAddress {return _gbfa ._afbf };

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_bcdg *GraphicSVG )Scale (xFactor ,yFactor float64 ){_bcdg ._dddg .Width =xFactor *_bcdg ._dddg .Width ;_bcdg ._dddg .Height =yFactor *_bcdg ._dddg .Height ;_bcdg ._dddg .SetScaling (xFactor ,yFactor );};

// Width returns the Block's width.
func (_cafb *Block )Width ()float64 {return _cafb ._de };

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_edgd *Division )Add (d VectorDrawable )error {switch _bddbd :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_ddcbf ,_ecgc :=_bddbd .ContainerComponent (_edgd );
if _ecgc !=nil {return _ecgc ;};_afa ,_efce :=_ddcbf .(VectorDrawable );if !_efce {return _f .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_ddcbf );
};d =_afa ;default:return _fc .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_edgd ._cggf =append (_edgd ._cggf ,d );return nil ;};func _dgdg (_efae float64 ,_dfbd float64 ,_dgfba float64 ,_ddcg float64 ,_bdbg []*ColorPoint )*RadialShading {return &RadialShading {_ffcg :&shading {_bbdfc :ColorWhite ,_fdda :false ,_gecd :[]bool {false ,false },_agcac :_bdbg },_edfe :_efae ,_dcgb :_dfbd ,_dabe :_dgfba ,_bbbc :_ddcg ,_cgdec :AnchorCenter };
};

// Height returns Image's document height.
func (_ddgb *Image )Height ()float64 {return _ddgb ._fae };

// Link returns link information for this line.
func (_abefa *TOCLine )Link ()(_gecg int64 ,_ebag ,_fecc float64 ){return _abefa ._bfabf ,_abefa ._bfcae ,_abefa ._geaed ;};

// GeneratePageBlocks implements drawable interface.
func (_gffe *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dgfbb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_add :=_gffe ._ffa ;_cegf :=ctx .PageHeight -_gffe ._cbc ;if _gffe ._agaab !=nil {_afca :=_ddb .Rectangle {Opacity :1.0,X :_gffe ._ffa ,Y :ctx .PageHeight -_gffe ._cbc -_gffe ._ggb ,Height :_gffe ._ggb ,Width :_gffe ._dc };
_afca .FillEnabled =true ;_dead :=_fac (_gffe ._agaab );_ffag :=_gaea (_dgfbb ,_dead ,_gffe ._agaab ,func ()Rectangle {return Rectangle {_fdeb :_afca .X ,_fefcd :_afca .Y ,_dacdg :_afca .Width ,_ddccd :_afca .Height };});if _ffag !=nil {return nil ,ctx ,_ffag ;
};_afca .FillColor =_dead ;_afca .BorderEnabled =false ;_aeeg ,_ ,_ffag :=_afca .Draw ("");if _ffag !=nil {return nil ,ctx ,_ffag ;};_ffag =_dgfbb .addContentsByString (string (_aeeg ));if _ffag !=nil {return nil ,ctx ,_ffag ;};};_eca :=_gffe ._egeb ;_cdd :=_gffe ._fcec ;
_cag :=_gffe ._cgd ;_dbcf :=_gffe ._dggc ;_edg :=_gffe ._egeb ;if _gffe ._gdgg ==CellBorderStyleDouble {_edg +=2*_eca ;};_bbd :=_gffe ._fcec ;if _gffe ._dcd ==CellBorderStyleDouble {_bbd +=2*_cdd ;};_bbdc :=_gffe ._cgd ;if _gffe ._fgfc ==CellBorderStyleDouble {_bbdc +=2*_cag ;
};_fcae :=_gffe ._dggc ;if _gffe ._cbgf ==CellBorderStyleDouble {_fcae +=2*_dbcf ;};_cgef :=(_edg -_bbdc )/2;_gcb :=(_edg -_fcae )/2;_gcf :=(_bbd -_bbdc )/2;_fab :=(_bbd -_fcae )/2;if _gffe ._egeb !=0{_eaed :=_add ;_dfcc :=_cegf ;if _gffe ._gdgg ==CellBorderStyleDouble {_dfcc -=_eca ;
_dce :=_ddb .BasicLine {LineColor :_fac (_gffe ._ed ),Opacity :1.0,LineWidth :_gffe ._egeb ,LineStyle :_gffe .LineStyle ,X1 :_eaed -_edg /2+_cgef ,Y1 :_dfcc +2*_eca ,X2 :_eaed +_edg /2-_gcb +_gffe ._dc ,Y2 :_dfcc +2*_eca };_ggbg ,_ ,_bbda :=_dce .Draw ("");
if _bbda !=nil {return nil ,ctx ,_bbda ;};_bbda =_dgfbb .addContentsByString (string (_ggbg ));if _bbda !=nil {return nil ,ctx ,_bbda ;};};_ede :=_ddb .BasicLine {LineWidth :_gffe ._egeb ,Opacity :1.0,LineColor :_fac (_gffe ._ed ),LineStyle :_gffe .LineStyle ,X1 :_eaed -_edg /2+_cgef +(_bbdc -_gffe ._cgd ),Y1 :_dfcc ,X2 :_eaed +_edg /2-_gcb +_gffe ._dc -(_fcae -_gffe ._dggc ),Y2 :_dfcc };
_ccg ,_ ,_eeg :=_ede .Draw ("");if _eeg !=nil {return nil ,ctx ,_eeg ;};_eeg =_dgfbb .addContentsByString (string (_ccg ));if _eeg !=nil {return nil ,ctx ,_eeg ;};};if _gffe ._fcec !=0{_gge :=_add ;_def :=_cegf -_gffe ._ggb ;if _gffe ._dcd ==CellBorderStyleDouble {_def +=_cdd ;
_gfec :=_ddb .BasicLine {LineWidth :_gffe ._fcec ,Opacity :1.0,LineColor :_fac (_gffe ._bfde ),LineStyle :_gffe .LineStyle ,X1 :_gge -_bbd /2+_gcf ,Y1 :_def -2*_cdd ,X2 :_gge +_bbd /2-_fab +_gffe ._dc ,Y2 :_def -2*_cdd };_bgg ,_ ,_geb :=_gfec .Draw ("");
if _geb !=nil {return nil ,ctx ,_geb ;};_geb =_dgfbb .addContentsByString (string (_bgg ));if _geb !=nil {return nil ,ctx ,_geb ;};};_cbb :=_ddb .BasicLine {LineWidth :_gffe ._fcec ,Opacity :1.0,LineColor :_fac (_gffe ._bfde ),LineStyle :_gffe .LineStyle ,X1 :_gge -_bbd /2+_gcf +(_bbdc -_gffe ._cgd ),Y1 :_def ,X2 :_gge +_bbd /2-_fab +_gffe ._dc -(_fcae -_gffe ._dggc ),Y2 :_def };
_baf ,_ ,_bcd :=_cbb .Draw ("");if _bcd !=nil {return nil ,ctx ,_bcd ;};_bcd =_dgfbb .addContentsByString (string (_baf ));if _bcd !=nil {return nil ,ctx ,_bcd ;};};if _gffe ._cgd !=0{_agb :=_add ;_afcc :=_cegf ;if _gffe ._fgfc ==CellBorderStyleDouble {_agb +=_cag ;
_bec :=_ddb .BasicLine {LineWidth :_gffe ._cgd ,Opacity :1.0,LineColor :_fac (_gffe ._fed ),LineStyle :_gffe .LineStyle ,X1 :_agb -2*_cag ,Y1 :_afcc +_bbdc /2+_cgef ,X2 :_agb -2*_cag ,Y2 :_afcc -_bbdc /2-_gcf -_gffe ._ggb };_cff ,_ ,_cad :=_bec .Draw ("");
if _cad !=nil {return nil ,ctx ,_cad ;};_cad =_dgfbb .addContentsByString (string (_cff ));if _cad !=nil {return nil ,ctx ,_cad ;};};_agc :=_ddb .BasicLine {LineWidth :_gffe ._cgd ,Opacity :1.0,LineColor :_fac (_gffe ._fed ),LineStyle :_gffe .LineStyle ,X1 :_agb ,Y1 :_afcc +_bbdc /2+_cgef -(_edg -_gffe ._egeb ),X2 :_agb ,Y2 :_afcc -_bbdc /2-_gcf -_gffe ._ggb +(_bbd -_gffe ._fcec )};
_dfa ,_ ,_deg :=_agc .Draw ("");if _deg !=nil {return nil ,ctx ,_deg ;};_deg =_dgfbb .addContentsByString (string (_dfa ));if _deg !=nil {return nil ,ctx ,_deg ;};};if _gffe ._dggc !=0{_dbcg :=_add +_gffe ._dc ;_efdg :=_cegf ;if _gffe ._cbgf ==CellBorderStyleDouble {_dbcg -=_dbcf ;
_egf :=_ddb .BasicLine {LineWidth :_gffe ._dggc ,Opacity :1.0,LineColor :_fac (_gffe ._gcg ),LineStyle :_gffe .LineStyle ,X1 :_dbcg +2*_dbcf ,Y1 :_efdg +_fcae /2+_gcb ,X2 :_dbcg +2*_dbcf ,Y2 :_efdg -_fcae /2-_fab -_gffe ._ggb };_bda ,_ ,_bggc :=_egf .Draw ("");
if _bggc !=nil {return nil ,ctx ,_bggc ;};_bggc =_dgfbb .addContentsByString (string (_bda ));if _bggc !=nil {return nil ,ctx ,_bggc ;};};_eggd :=_ddb .BasicLine {LineWidth :_gffe ._dggc ,Opacity :1.0,LineColor :_fac (_gffe ._gcg ),LineStyle :_gffe .LineStyle ,X1 :_dbcg ,Y1 :_efdg +_fcae /2+_gcb -(_edg -_gffe ._egeb ),X2 :_dbcg ,Y2 :_efdg -_fcae /2-_fab -_gffe ._ggb +(_bbd -_gffe ._fcec )};
_eab ,_ ,_gbe :=_eggd .Draw ("");if _gbe !=nil {return nil ,ctx ,_gbe ;};_gbe =_dgfbb .addContentsByString (string (_eab ));if _gbe !=nil {return nil ,ctx ,_gbe ;};};return []*Block {_dgfbb },ctx ,nil ;};func (_feaba *StyledParagraph )wrapWordChunks (){if !_feaba ._fecad {return ;
};var (_fdca []*TextChunk ;_dcbbee *_gd .PdfFont ;);for _ ,_ebbgc :=range _feaba ._bcbc {_decc :=[]rune (_ebbgc .Text );if _dcbbee ==nil {_dcbbee =_ebbgc .Style .Font ;};_cggdg :=_ebbgc ._bcfe ;_cfgf :=_ebbgc .VerticalAlignment ;if len (_fdca )> 0{if len (_decc )==1&&_ab .IsPunct (_decc [0])&&_ebbgc .Style .Font ==_dcbbee {_dabc :=[]rune (_fdca [len (_fdca )-1].Text );
_fdca [len (_fdca )-1].Text =string (append (_dabc ,_decc [0]));continue ;}else {_ ,_egca :=_fd .Atoi (_ebbgc .Text );if _egca ==nil {_dfdab :=[]rune (_fdca [len (_fdca )-1].Text );_dbggf :=len (_dfdab );if _dbggf >=2{_ ,_beeaf :=_fd .Atoi (string (_dfdab [_dbggf -2]));
if _beeaf ==nil &&_ab .IsPunct (_dfdab [_dbggf -1]){_fdca [len (_fdca )-1].Text =string (append (_dfdab ,_decc ...));continue ;};};};};};_ggce ,_adgea :=_ebeaed (_ebbgc .Text );if _adgea !=nil {_ca .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_adgea );
_ggce =[]string {_ebbgc .Text };};for _ ,_faaad :=range _ggce {_bcgcf :=NewTextChunk (_faaad ,_ebbgc .Style );_bcgcf ._bcfe =_aagc (_cggdg );_bcgcf .VerticalAlignment =_cfgf ;_fdca =append (_fdca ,_bcgcf );};_dcbbee =_ebbgc .Style .Font ;};if len (_fdca )> 0{_feaba ._bcbc =_fdca ;
};};func (_bfafe *Paragraph )getTextLineWidth (_ceee string )float64 {var _cfcb float64 ;for _ ,_dcgc :=range _ceee {if _dcgc =='\u000A'{continue ;};_ecgcg ,_ccaca :=_bfafe ._caccd .GetRuneMetrics (_dcgc );if !_ccaca {_ca .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_dcgc ,_dcgc );
return -1;};_cfcb +=_bfafe ._geac *_ecgcg .Wx ;};return _cfcb ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_bffc *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_bffc ._cafcb {_ca .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _fc .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bffc ._faae =widths ;return nil ;};func (_eafd *Creator )initContext (){_eafd ._ecfb .X =_eafd ._gffac .Left ;_eafd ._ecfb .Y =_eafd ._gffac .Top ;
_eafd ._ecfb .Width =_eafd ._baec -_eafd ._gffac .Right -_eafd ._gffac .Left ;_eafd ._ecfb .Height =_eafd ._defa -_eafd ._gffac .Bottom -_eafd ._gffac .Top ;_eafd ._ecfb .PageHeight =_eafd ._defa ;_eafd ._ecfb .PageWidth =_eafd ._baec ;_eafd ._ecfb .Margins =_eafd ._gffac ;
_eafd ._ecfb ._ebeg =_eafd .UnsupportedCharacterReplacement ;};func (_agfgc *templateProcessor )parseTable (_abdbg *templateNode )(interface{},error ){var _ffcgg int64 ;for _ ,_afcff :=range _abdbg ._eccfd .Attr {_dgffd :=_afcff .Value ;switch _edfb :=_afcff .Name .Local ;
_edfb {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_ffcgg =_agfgc .parseInt64Attr (_edfb ,_dgffd );};};if _ffcgg <=0{_agfgc .nodeLogDebug (_abdbg ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_ffcgg );
_ffcgg =1;};_ebbad :=_agfgc .creator .NewTable (int (_ffcgg ));for _ ,_gdceg :=range _abdbg ._eccfd .Attr {_gaeda :=_gdceg .Value ;switch _ccfd :=_gdceg .Name .Local ;_ccfd {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_ebbad .SetColumnWidths (_agfgc .parseFloatArray (_ccfd ,_gaeda )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_bbfeb :=_agfgc .parseMarginAttr (_ccfd ,_gaeda );_ebbad .SetMargins (_bbfeb .Left ,_bbfeb .Right ,_bbfeb .Top ,_bbfeb .Bottom );case "\u0078":_ebbad .SetPos (_agfgc .parseFloatAttr (_ccfd ,_gaeda ),_ebbad ._aeff );
case "\u0079":_ebbad .SetPos (_ebbad ._dece ,_agfgc .parseFloatAttr (_ccfd ,_gaeda ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_ebbad ._bccfd =int (_agfgc .parseInt64Attr (_ccfd ,_gaeda ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_ebbad ._deceb =int (_agfgc .parseInt64Attr (_ccfd ,_gaeda ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_ebbad .EnableRowWrap (_agfgc .parseBoolAttr (_ccfd ,_gaeda ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_ebbad .EnablePageWrap (_agfgc .parseBoolAttr (_ccfd ,_gaeda ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_agfgc .nodeLogDebug (_abdbg ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_ccfd );
};};if _ebbad ._bccfd !=0&&_ebbad ._deceb !=0{_ddccdc :=_ebbad .SetHeaderRows (_ebbad ._bccfd ,_ebbad ._deceb );if _ddccdc !=nil {_agfgc .nodeLogDebug (_abdbg ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_ddccdc );
};}else {_ebbad ._bccfd =0;_ebbad ._deceb =0;};return _ebbad ,nil ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_cefdf []_ddb .CubicBezierCurve ;FillEnabled bool ;_gdge Color ;BorderEnabled bool ;BorderWidth float64 ;_aebe Color ;_gfecd *int64 ;};func (_egadf *TemplateOptions )init (){if _egadf .SubtemplateMap ==nil {_egadf .SubtemplateMap =map[string ]_cb .Reader {};
};if _egadf .FontMap ==nil {_egadf .FontMap =map[string ]*_gd .PdfFont {};};if _egadf .ImageMap ==nil {_egadf .ImageMap =map[string ]*_gd .Image {};};if _egadf .ColorMap ==nil {_egadf .ColorMap =map[string ]Color {};};if _egadf .ChartMap ==nil {_egadf .ChartMap =map[string ]_fbb .ChartRenderable {};
};};

// SetOpacity sets the opacity of the line (0-1).
func (_fafcc *Line )SetOpacity (opacity float64 ){_fafcc ._gbfc =opacity };

// SetMarkedContentID sets the marked content ID.
func (_edee *Rectangle )SetMarkedContentID (mcid int64 )*_gd .KDict {_edee ._bcee =&mcid ;_bcabf :=_gd .NewKDictionary ();_bcabf .S =_be .MakeName (_gd .StructureTypeFigure );_bcabf .K =_be .MakeInteger (mcid );return _bcabf ;};func (_bgfgf *StyledParagraph )getTextHeight ()float64 {var _cecec float64 ;
for _ ,_afba :=range _bgfgf ._bcbc {_effg :=_afba .Style .FontSize *_bgfgf ._bcde ;if _effg > _cecec {_cecec =_effg ;};};return _cecec ;};

// SetFillColor sets the fill color.
func (_beg *CurvePolygon )SetFillColor (color Color ){_beg ._fdbd =color ;_beg ._fbff .FillColor =_fac (color );};

// Padding returns the padding of the component.
func (_cfce *Division )Padding ()(_addcf ,_dbfg ,_cdag ,_cafbg float64 ){return _cfce ._dcfb .Left ,_cfce ._dcfb .Right ,_cfce ._dcfb .Top ,_cfce ._dcfb .Bottom ;};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_cggf []VectorDrawable ;_fbfc Positioning ;_fceg Margins ;_dcfb Margins ;_dccc bool ;_adbb bool ;_bacfc *Background ;};

// SetWidthTop sets border width for top.
func (_efd *border )SetWidthTop (bw float64 ){_efd ._egeb =bw };func _gcee (_fefa []_ddb .Point )*Polyline {return &Polyline {_gcaf :&_ddb .Polyline {Points :_fefa ,LineColor :_gd .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_aegga :1.0};};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_bee []*_gd .PdfPage ;_fafg map[*_gd .PdfPage ]*Block ;_gaf map[*_gd .PdfPage ]*pageTransformations ;_cafc *_gd .PdfPage ;_gfed PageSize ;_ecfb DrawContext ;_gffac Margins ;_baec ,_defa float64 ;_agdg int ;_bbde func (_gafd FrontpageFunctionArgs );
_bef func (_eac *TOC )error ;_eee func (_bcg *Block ,_cddd HeaderFunctionArgs );_fdc func (_dgaf *Block ,_bgab FooterFunctionArgs );_bdfe func (_gcgf PageFinalizeFunctionArgs )error ;_eaa func (_bbcf *_gd .PdfWriter )error ;_gbg bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_dda *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_eagf *_gd .Outline ;_dfac *_gd .PdfOutlineTreeNode ;_bdac *_gd .PdfAcroForm ;_ddad _be .PdfObject ;_bfg _gd .Optimizer ;_dgad []*_gd .PdfFont ;_fbbd *_gd .PdfFont ;_gafc *_gd .PdfFont ;_fgc *_gd .StructTreeRoot ;_ggfa *_gd .ViewerPreferences ;
_ggfag string ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_eged *Creator )SetPageSize (size PageSize ){_eged ._gfed =size ;_eged ._baec =size [0];_eged ._defa =size [1];_bgfe :=0.1*_eged ._baec ;_eged ._gffac .Left =_bgfe ;_eged ._gffac .Right =_bgfe ;_eged ._gffac .Top =_bgfe ;_eged ._gffac .Bottom =_bgfe ;
};func (_gbfef *TOCLine )prepareParagraph (_bdfacf *StyledParagraph ,_befee DrawContext ){_fdgcc :=_gbfef .Title .Text ;if _gbfef .Number .Text !=""{_fdgcc ="\u0020"+_fdgcc ;};_fdgcc +="\u0020";_caca :=_gbfef .Page .Text ;if _caca !=""{_caca ="\u0020"+_caca ;
};_ecdcba :=[]*_gd .PdfAnnotation {};_ddbc :=_gbfef .getLineLink ();if _ddbc !=nil {_ecdcba =append (_ecdcba ,_ddbc );};_bdfacf ._bcbc =[]*TextChunk {{Text :_gbfef .Number .Text ,Style :_gbfef .Number .Style ,_bcfe :_ecdcba },{Text :_fdgcc ,Style :_gbfef .Title .Style ,_bcfe :_ecdcba },{Text :_caca ,Style :_gbfef .Page .Style ,_bcfe :_ecdcba }};
_bdfacf .wrapText ();_ddagb :=len (_bdfacf ._ccae );if _ddagb ==0{return ;};_faeg :=_befee .Width *1000-_bdfacf .getTextLineWidth (_bdfacf ._ccae [_ddagb -1]);_dffeb :=_bdfacf .getTextLineWidth ([]*TextChunk {&_gbfef .Separator });_ggca :=int (_faeg /_dffeb );
_aaca :=_ddf .Repeat (_gbfef .Separator .Text ,_ggca );_debgc :=_gbfef .Separator .Style ;_abfc :=_bdfacf .Insert (2,_aaca );_abfc .Style =_debgc ;_abfc .SetAnnotation (_gbfef .getLineLink ());_faeg =_faeg -float64 (_ggca )*_dffeb ;if _faeg > 500{_cadb ,_dbfbb :=_debgc .Font .GetRuneMetrics (' ');
if _dbfbb &&_faeg > _cadb .Wx {_gfdbc :=int (_faeg /_cadb .Wx );if _gfdbc > 0{_efge :=_debgc ;_efge .FontSize =1;_abfc =_bdfacf .Insert (2,_ddf .Repeat ("\u0020",_gfdbc ));_abfc .Style =_efge ;_abfc .SetAnnotation (_gbfef .getLineLink ());};};};};const (PositionRelative Positioning =iota ;
PositionAbsolute ;);

// NewCell returns a new invoice table cell.
func (_ceef *Invoice )NewCell (value string )*InvoiceCell {return _ceef .newCell (value ,_ceef .NewCellProps ());};

// MoveX moves the drawing context to absolute position x.
func (_eaga *Creator )MoveX (x float64 ){_eaga ._ecfb .X =x };

// SetBackground sets the background properties of the component.
func (_dbae *Division )SetBackground (background *Background ){_dbae ._bacfc =background };

// SetStyleTop sets border style for top side.
func (_aae *border )SetStyleTop (style CellBorderStyle ){_aae ._gdgg =style };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_aacbd *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _gcaeg (number ,title ,page ,level ,style );};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// SetBorderOpacity sets the border opacity.
func (_aabcd *Polygon )SetBorderOpacity (opacity float64 ){_aabcd ._gcdg =opacity };

// Crop crops the Image to the specified bounds.
func (_cbbag *Image )Crop (x0 ,y0 ,x1 ,y1 int ){_ggae ,_cdad :=_cbbag ._dgaaf .ToGoImage ();if _cdad !=nil {_bg .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0074o\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_cdad );
};var _abdf _dd .Image ;_acac :=_dd .Rect (x0 ,y0 ,x1 ,y1 );if _cgac :=_acac .Intersect (_ggae .Bounds ());!_acac .Empty (){_fegg :=_dd .NewRGBA (_dd .Rect (0,0,_acac .Dx (),_acac .Dy ()));for _fbac :=_cgac .Min .Y ;_fbac < _cgac .Max .Y ;_fbac ++{for _cegd :=_cgac .Min .X ;
_cegd < _cgac .Max .X ;_cegd ++{_fegg .Set (_cegd -_cgac .Min .X ,_fbac -_cgac .Min .Y ,_ggae .At (_cegd ,_fbac ));};};_abdf =_fegg ;}else {_abdf =&_dd .RGBA {};};_ddegb ,_cdad :=_gd .ImageHandling .NewImageFromGoImage (_abdf );if _cdad !=nil {_bg .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0066\u0072\u006fm\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_cdad );
};_begg :=float64 (_ddegb .Width );_gddf :=float64 (_ddegb .Height );_cbbag ._dgaaf =_ddegb ;_cbbag ._dade =_begg ;_cbbag ._abecc =_gddf ;_cbbag ._dcbe =_begg ;_cbbag ._fae =_gddf ;};

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_cged *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_adbac []*Block ;_ebef =NewBlock (ctx .PageWidth ,ctx .PageHeight );_afbb =ctx ;);_fedd :=_cged ._gbbf .IsRelative ();if _fedd {_cged .applyFitMode (ctx .Width );
ctx .X +=_cged ._dffg .Left ;ctx .Y +=_cged ._dffg .Top ;ctx .Width -=_cged ._dffg .Left +_cged ._dffg .Right ;ctx .Height -=_cged ._dffg .Top +_cged ._dffg .Bottom ;if _cged ._fgbb > ctx .Height {_adbac =append (_adbac ,_ebef );_ebef =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_fdaef :=ctx ;_fdaef .Y =ctx .Margins .Top +_cged ._dffg .Top ;_fdaef .X =ctx .Margins .Left +_cged ._dffg .Left ;_fdaef .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_cged ._dffg .Top -_cged ._dffg .Bottom ;_fdaef .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cged ._dffg .Left -_cged ._dffg .Right ;
ctx =_fdaef ;};}else {ctx .X =_cged ._dbeb -_cged ._gbea /2;ctx .Y =_cged ._caaf -_cged ._fgbb /2;};_gffd :=_ddb .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_cged ._fgbb ,Width :_cged ._gbea ,Height :_cged ._fgbb ,BorderWidth :_cged ._fdcc ,Opacity :1.0};
if _cged ._cgcbc !=nil {_gffd .FillEnabled =true ;_dcbc :=_fac (_cged ._cgcbc );_fdad :=_gaea (_ebef ,_dcbc ,_cged ._cgcbc ,func ()Rectangle {return Rectangle {_fdeb :_gffd .X ,_fefcd :_gffd .Y ,_dacdg :_gffd .Width ,_ddccd :_gffd .Height };});if _fdad !=nil {return nil ,ctx ,_fdad ;
};_gffd .FillColor =_dcbc ;};if _cged ._bfgf !=nil {_gffd .BorderEnabled =false ;if _cged ._fdcc > 0{_gffd .BorderEnabled =true ;};_gffd .BorderColor =_fac (_cged ._bfgf );_gffd .BorderWidth =_cged ._fdcc ;};_bcae ,_fbead :=_ebef .setOpacity (_cged ._baae ,_cged ._egegc );
if _fbead !=nil {return nil ,ctx ,_fbead ;};_bcca ,_ ,_fbead :=_gffd .MarkedDraw (_bcae ,_cged ._ecdc );if _fbead !=nil {return nil ,ctx ,_fbead ;};_fbead =_ebef .addContentsByString (string (_bcca ));if _fbead !=nil {return nil ,ctx ,_fbead ;};if _fedd {ctx .X =_afbb .X ;
ctx .Width =_afbb .Width ;ctx .Y +=_cged ._fgbb +_cged ._dffg .Bottom ;ctx .Height -=_cged ._fgbb ;}else {ctx =_afbb ;};_adbac =append (_adbac ,_ebef );return _adbac ,ctx ,nil ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_bfadc *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ffeac :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cce ,_cfga :=_ffeac .setOpacity (_bfadc ._dcfbf ,_bfadc ._acfb );if _cfga !=nil {return nil ,ctx ,_cfga ;
};_dbfc :=_bfadc ._bgdab ;_dbfc .FillEnabled =_dbfc .FillColor !=nil ;var (_accfe =ctx .PageHeight ;_gefdff =_dbfc .Curves ;_ebdd =make ([]_ddb .CubicBezierCurve ,0,len (_dbfc .Curves )););_cdgfd :=_gd .PdfRectangle {};for _eaggg :=range _dbfc .Curves {_cgfe :=_gefdff [_eaggg ];
_cgfe .P0 .Y =_accfe -_cgfe .P0 .Y ;_cgfe .P1 .Y =_accfe -_cgfe .P1 .Y ;_cgfe .P2 .Y =_accfe -_cgfe .P2 .Y ;_cgfe .P3 .Y =_accfe -_cgfe .P3 .Y ;_ebdd =append (_ebdd ,_cgfe );_faac :=_cgfe .GetBounds ();if _eaggg ==0{_cdgfd =_faac ;}else {_cdgfd .Llx =_ff .Min (_cdgfd .Llx ,_faac .Llx );
_cdgfd .Lly =_ff .Min (_cdgfd .Lly ,_faac .Lly );_cdgfd .Urx =_ff .Max (_cdgfd .Urx ,_faac .Urx );_cdgfd .Ury =_ff .Max (_cdgfd .Ury ,_faac .Ury );};};_dbfc .Curves =_ebdd ;defer func (){_dbfc .Curves =_gefdff }();if _dbfc .FillEnabled {_bgdg :=_gaea (_ffeac ,_bfadc ._bgdab .FillColor ,_bfadc ._gfde ,func ()Rectangle {return Rectangle {_fdeb :_cdgfd .Llx ,_fefcd :_cdgfd .Lly ,_dacdg :_cdgfd .Width (),_ddccd :_cdgfd .Height ()};
});if _bgdg !=nil {return nil ,ctx ,_bgdg ;};};_gfegc ,_ ,_cfga :=_dbfc .MarkedDraw (_cce ,_bfadc ._bgadb );if _cfga !=nil {return nil ,ctx ,_cfga ;};if _cfga =_ffeac .addContentsByString (string (_gfegc ));_cfga !=nil {return nil ,ctx ,_cfga ;};return []*Block {_ffeac },ctx ,nil ;
};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_ega :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_ca .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ega ;
};var _dgfg ,_fcc ,_cgec int ;if len (hexStr )==4{var _aaeg ,_bedg ,_dcee int ;_acf ,_bccc :=_f .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_aaeg ,&_bedg ,&_dcee );if _bccc !=nil {_ca .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_bccc );
return _ega ;};if _acf !=3{_ca .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ega ;};_dgfg =_aaeg *16+_aaeg ;_fcc =_bedg *16+_bedg ;_cgec =_dcee *16+_dcee ;}else {_gffee ,_cac :=_f .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_dgfg ,&_fcc ,&_cgec );
if _cac !=nil {_ca .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ega ;};if _gffee !=3{_ca .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_gffee );
return _ega ;};};_adaf :=float64 (_dgfg )/255.0;_bbe :=float64 (_fcc )/255.0;_acd :=float64 (_cgec )/255.0;_ega ._afd =_adaf ;_ega ._fef =_bbe ;_ega ._cbbf =_acd ;return _ega ;};

// TextAlignment options for paragraph.
type TextAlignment int ;

// Lazy gets the lazy mode for the image.
func (_agac *Image )Lazy ()bool {return _agac ._bfbd };func (_dfcgb *TableCell )height (_gdefb float64 )float64 {var _adfdf float64 ;switch _eaedg :=_dfcgb ._bdea .(type ){case *Paragraph :if _eaedg ._abaa {_eaedg .SetWidth (_gdefb -_dfcgb ._adeb -_eaedg ._cgacg .Left -_eaedg ._cgacg .Right );
};_adfdf =_eaedg .Height ()+_eaedg ._cgacg .Top +_eaedg ._cgacg .Bottom ;if !_dfcgb ._gabb ._ggab {_adfdf +=(0.5*_eaedg ._geac *_eaedg ._agdbb );};case *StyledParagraph :if _eaedg ._egbgc {_eaedg .SetWidth (_gdefb -_dfcgb ._adeb -_eaedg ._affa .Left -_eaedg ._affa .Right );
};_adfdf =_eaedg .Height ()+_eaedg ._affa .Top +_eaedg ._affa .Bottom ;if !_dfcgb ._gabb ._ggab {_adfdf +=(0.5*_eaedg .getTextHeight ());};case *Image :_eaedg .applyFitMode (_gdefb -_dfcgb ._adeb );_adfdf =_eaedg .Height ()+_eaedg ._fcad .Top +_eaedg ._fcad .Bottom ;
case *Table :_eaedg .updateRowHeights (_gdefb -_dfcgb ._adeb -_eaedg ._ccecg .Left -_eaedg ._ccecg .Right );_adfdf =_eaedg .Height ()+_eaedg ._ccecg .Top +_eaedg ._ccecg .Bottom ;case *List :_adfdf =_eaedg .ctxHeight (_gdefb -_dfcgb ._adeb )+_eaedg ._edgdc .Top +_eaedg ._edgdc .Bottom ;
case *Division :_adfdf =_eaedg .ctxHeight (_gdefb -_dfcgb ._adeb )+_eaedg ._fceg .Top +_eaedg ._fceg .Bottom +_eaedg ._dcfb .Top +_eaedg ._dcfb .Bottom ;case *Chart :_adfdf =_eaedg .Height ()+_eaedg ._aabg .Top +_eaedg ._aabg .Bottom ;case *Rectangle :_eaedg .applyFitMode (_gdefb -_dfcgb ._adeb );
_adfdf =_eaedg .Height ()+_eaedg ._ddfgb .Top +_eaedg ._ddfgb .Bottom +_eaedg ._bcdgg ;case *Ellipse :_eaedg .applyFitMode (_gdefb -_dfcgb ._adeb );_adfdf =_eaedg .Height ()+_eaedg ._dffg .Top +_eaedg ._dffg .Bottom ;case *Line :_adfdf =_eaedg .Height ()+_eaedg ._cbeb .Top +_eaedg ._cbeb .Bottom ;
};return _adfdf ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_cbebg *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cbebg ._cgacg .Left ,_cbebg ._cgacg .Right ,_cbebg ._cgacg .Top ,_cbebg ._cgacg .Bottom ;};

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_dfebf *Line )Width ()float64 {return _ff .Abs (_dfebf ._agbba -_dfebf ._cbagd )};func _faadb (_caaae *_gd .PdfAnnotationHighlight )*_gd .PdfAnnotationHighlight {if _caaae ==nil {return nil ;};_fgfg :=_gd .NewPdfAnnotationHighlight ();_fgfg .C =_caaae .C ;
_fgfg .CA =_caaae .CA ;_fgfg .Rect =_caaae .Rect ;_fgfg .QuadPoints =_caaae .QuadPoints ;return _fgfg ;};func _abfae (_bddcg *_b .Decoder )(int ,int ){return 0,0};

// Width returns the current page width.
func (_geff *Creator )Width ()float64 {return _geff ._baec };

// NewPolygon creates a new polygon.
func (_fcg *Creator )NewPolygon (points [][]_ddb .Point )*Polygon {return _ebdg (points )};

// Color returns the color of the line.
func (_agdc *Line )Color ()Color {return _agdc ._ffga };

// SetBorderColor sets the border color of the ellipse.
func (_cfgca *Ellipse )SetBorderColor (col Color ){_cfgca ._bfgf =col };

// SetMarkedContentID sets marked content ID.
func (_fcfb *TOC )SetMarkedContentID (mcid int64 )*_gd .KDict {return nil };func (_aaef *templateProcessor )processGradientColorPair (_edbd []string )(_gffbb []Color ,_egdc []float64 ){for _ ,_bgacb :=range _edbd {var (_gfdff =_ddf .Fields (_bgacb );_faddb =len (_gfdff );
);if _faddb ==0{continue ;};_aacg :="";if _faddb > 1{_aacg =_ddf .TrimSpace (_gfdff [1]);};_gbff :=-1.0;if _ddf .HasSuffix (_aacg ,"\u0025"){_dfgag ,_dbcee :=_fd .ParseFloat (_aacg [:len (_aacg )-1],64);if _dbcee !=nil {_ca .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_dbcee );
};_gbff =_dfgag /100.0;};_effb :=_aaef .parseColor (_ddf .TrimSpace (_gfdff [0]));if _effb !=nil {_gffbb =append (_gffbb ,_effb );_egdc =append (_egdc ,_gbff );};};if len (_gffbb )!=len (_egdc ){_ca .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_afef :=-1;_ggfae :=0.0;for _ddacf ,_ggeg :=range _egdc {if _ggeg ==-1.0{if _ddacf ==0{_ggeg =0.0;_egdc [_ddacf ]=0.0;continue ;};_afef ++;if _ddacf < len (_egdc )-1{continue ;}else {_ggeg =1.0;_egdc [_ddacf ]=1.0;};};_cdcd :=_afef +1;
for _aebf :=_ddacf -_afef ;_aebf < _ddacf ;_aebf ++{_egdc [_aebf ]=_ggfae +(float64 (_aebf )*(_ggeg -_ggfae )/float64 (_cdcd ));};_ggfae =_ggeg ;_afef =-1;};return _gffbb ,_egdc ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_cbeaf *Invoice )SetTitleStyle (style TextStyle ){_cbeaf ._fcbed =style };

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_fcbe *Creator )AddPage (page *_gd .PdfPage )error {_dcg ,_bfa :=_fcbe .wrapPageIfNeeded (page );if _bfa !=nil {return _bfa ;};if _dcg !=nil {page =_dcg ;};_geae ,_bfa :=page .GetMediaBox ();if _bfa !=nil {_ca .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_bfa );
return _bfa ;};_geae .Normalize ();_cfb ,_cdff :=_geae .Llx ,_geae .Lly ;_bggea :=_geae ;if _eeea :=page .CropBox ;_eeea !=nil &&*_eeea !=*_geae {_eeea .Normalize ();_cfb ,_cdff =_eeea .Llx ,_eeea .Lly ;_bggea =_eeea ;};_fffd :=_cbe .IdentityMatrix ();
_efbb ,_bfa :=page .GetRotate ();if _bfa !=nil {_ca .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_bfa .Error ());
};_gggg :=_efbb %360!=0&&_efbb %90==0;if _gggg {_aeca :=float64 ((360+_efbb %360)%360);if _aeca ==90{_fffd =_fffd .Translate (_bggea .Width (),0);}else if _aeca ==180{_fffd =_fffd .Translate (_bggea .Width (),_bggea .Height ());}else if _aeca ==270{_fffd =_fffd .Translate (0,_bggea .Height ());
};_fffd =_fffd .Mult (_cbe .RotationMatrix (_aeca *_ff .Pi /180));_fffd =_fffd .Round (0.000001);_ecfg :=_dgeb (_bggea ,_fffd );_bggea =_ecfg ;_bggea .Normalize ();};if _cfb !=0||_cdff !=0{_fffd =_cbe .TranslationMatrix (_cfb ,_cdff ).Mult (_fffd );};if !_fffd .Identity (){_fffd =_fffd .Round (0.000001);
_fcbe ._gaf [page ]=&pageTransformations {_agce :&_fffd };};_fcbe ._baec =_bggea .Width ();_fcbe ._defa =_bggea .Height ();_fcbe .initContext ();_fcbe ._bee =append (_fcbe ._bee ,page );_fcbe ._ecfb .Page ++;return nil ;};

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_fgfbe *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_fgfbe ._fcga =textOverflow ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_adfg *StyledParagraph )SetText (text string )*TextChunk {_adfg .Reset ();return _adfg .Append (text );};func _cga (_aede *_eag .ContentStreamOperations ,_bfd *_gd .PdfPageResources ,_ggf *_eag .ContentStreamOperations ,_fddg *_gd .PdfPageResources )error {_cd :=map[_be .PdfObjectName ]_be .PdfObjectName {};
_ggg :=map[_be .PdfObjectName ]_be .PdfObjectName {};_bed :=map[_be .PdfObjectName ]_be .PdfObjectName {};_gfg :=map[_be .PdfObjectName ]_be .PdfObjectName {};_fdg :=map[_be .PdfObjectName ]_be .PdfObjectName {};_bb :=map[_be .PdfObjectName ]_be .PdfObjectName {};
for _ ,_fbf :=range *_ggf {switch _fbf .Operand {case "\u0044\u006f":if len (_fbf .Params )==1{if _adg ,_aab :=_fbf .Params [0].(*_be .PdfObjectName );_aab {if _ ,_agd :=_cd [*_adg ];!_agd {var _ecfe _be .PdfObjectName ;_dgge ,_ :=_fddg .GetXObjectByName (*_adg );
if _dgge !=nil {_ecfe =*_adg ;for {_daa ,_ :=_bfd .GetXObjectByName (_ecfe );if _daa ==nil ||_daa ==_dgge {break ;};_ecfe =*_be .MakeName (_efb (_ecfe .String ()));};};_bfd .SetXObjectByName (_ecfe ,_dgge );_cd [*_adg ]=_ecfe ;};_deb :=_cd [*_adg ];_fbf .Params [0]=&_deb ;
};};case "\u0054\u0066":if len (_fbf .Params )==2{if _ddc ,_ecb :=_fbf .Params [0].(*_be .PdfObjectName );_ecb {if _ ,_dfc :=_ggg [*_ddc ];!_dfc {_aea ,_fga :=_fddg .GetFontByName (*_ddc );_decf :=*_ddc ;if _fga &&_aea !=nil {_decf =_eff (_ddc .String (),_aea ,_bfd );
};_bfd .SetFontByName (_decf ,_aea );_ggg [*_ddc ]=_decf ;};_gcc :=_ggg [*_ddc ];_fbf .Params [0]=&_gcc ;};};case "\u0043\u0053","\u0063\u0073":if len (_fbf .Params )==1{if _gffa ,_gdg :=_fbf .Params [0].(*_be .PdfObjectName );_gdg {if _ ,_ccce :=_bed [*_gffa ];
!_ccce {var _ffd _be .PdfObjectName ;_ddca ,_egb :=_fddg .GetColorspaceByName (*_gffa );if _egb {_ffd =*_gffa ;for {_cde ,_aedb :=_bfd .GetColorspaceByName (_ffd );if !_aedb ||_ddca ==_cde {break ;};_ffd =*_be .MakeName (_efb (_ffd .String ()));};_bfd .SetColorspaceByName (_ffd ,_ddca );
_bed [*_gffa ]=_ffd ;}else {_ca .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _dbgd ,_gdd :=_bed [*_gffa ];_gdd {_fbf .Params [0]=&_dbgd ;}else {_ca .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_gffa );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_fbf .Params )==1{if _dfe ,_gfe :=_fbf .Params [0].(*_be .PdfObjectName );_gfe {if _ ,_bac :=_gfg [*_dfe ];!_bac {var _dba _be .PdfObjectName ;_gfc ,_fbbb :=_fddg .GetPatternByName (*_dfe );if _fbbb {_dba =*_dfe ;
for {_aga ,_fddgf :=_bfd .GetPatternByName (_dba );if !_fddgf ||_aga ==_gfc {break ;};_dba =*_be .MakeName (_efb (_dba .String ()));};_cdc :=_bfd .SetPatternByName (_dba ,_gfc .ToPdfObject ());if _cdc !=nil {return _cdc ;};_gfg [*_dfe ]=_dba ;};};if _gefd ,_gdc :=_gfg [*_dfe ];
_gdc {_fbf .Params [0]=&_gefd ;};};};case "\u0073\u0068":if len (_fbf .Params )==1{if _cbd ,_baa :=_fbf .Params [0].(*_be .PdfObjectName );_baa {if _ ,_dbaa :=_fdg [*_cbd ];!_dbaa {var _eeba _be .PdfObjectName ;_fcda ,_dbb :=_fddg .GetShadingByName (*_cbd );
if _dbb {_eeba =*_cbd ;for {_bbc ,_fce :=_bfd .GetShadingByName (_eeba );if !_fce ||_fcda ==_bbc {break ;};_eeba =*_be .MakeName (_efb (_eeba .String ()));};_agaa :=_bfd .SetShadingByName (_eeba ,_fcda .ToPdfObject ());if _agaa !=nil {_ca .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_agaa );
return _agaa ;};_fdg [*_cbd ]=_eeba ;}else {_ca .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _gceb ,_cbaa :=_fdg [*_cbd ];_cbaa {_fbf .Params [0]=&_gceb ;}else {_ca .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_cbd );
};};};case "\u0067\u0073":if len (_fbf .Params )==1{if _eef ,_faa :=_fbf .Params [0].(*_be .PdfObjectName );_faa {if _ ,_ddgc :=_bb [*_eef ];!_ddgc {var _dbc _be .PdfObjectName ;_dae ,_fff :=_fddg .GetExtGState (*_eef );if _fff {_dbc =*_eef ;for {_gdcf ,_ffde :=_bfd .GetExtGState (_dbc );
if !_ffde ||_dae ==_gdcf {break ;};_dbc =*_be .MakeName (_efb (_dbc .String ()));};};_bfd .AddExtGState (_dbc ,_dae );_bb [*_eef ]=_dbc ;};_efa :=_bb [*_eef ];_fbf .Params [0]=&_efa ;};};};*_aede =append (*_aede ,_fbf );};return nil ;};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_debba *LinearShading )AddPatternResource (block *Block )(_gebbg _be .PdfObjectName ,_gece error ){_cbecg :=1;_bdbdd :=_be .PdfObjectName ("\u0050"+_fd .Itoa (_cbecg ));for block ._fa .HasPatternByName (_bdbdd ){_cbecg ++;_bdbdd =_be .PdfObjectName ("\u0050"+_fd .Itoa (_cbecg ));
};if _dcdc :=block ._fa .SetPatternByName (_bdbdd ,_debba .ToPdfShadingPattern ().ToPdfObject ());_dcdc !=nil {return "",_dcdc ;};return _bdbdd ,nil ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_cegfb *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_cegfb .Text },nil ;};var _dege []string ;var _ffgd []rune ;var _afdcba float64 ;var _defd []float64 ;_aafcf :=_cegfb .Style ;_egfeg :=_bdcfa (_cegfb .Text );
for _ ,_bead :=range _cegfb .Text {if _bead =='\u000A'{_fbacc :=_ebaa (string (_ffgd ),_egfeg );_dege =append (_dege ,_ddf .TrimRightFunc (_fbacc ,_ab .IsSpace )+string (_bead ));_ffgd =nil ;_afdcba =0;_defd =nil ;continue ;};_bgcde :=_bead ==' ';_acfbd ,_bfeea :=_aafcf .Font .GetRuneMetrics (_bead );
if !_bfeea {_ca .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_bead ,_bead ,_aafcf .Font .BaseFont (),_aafcf .Font .Subtype ());
_ca .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_aafcf .Font );_ca .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_aafcf .Font .Encoder ());return nil ,_fc .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_ebbcf :=_aafcf .FontSize *_acfbd .Wx ;_bbfcb :=_ebbcf ;if !_bgcde {_bbfcb =_ebbcf +_aafcf .CharSpacing *1000.0;};if _afdcba +_ebbcf > width *1000.0{_gaca :=-1;if !_bgcde {for _cbebfd :=len (_ffgd )-1;_cbebfd >=0;_cbebfd --{if _ffgd [_cbebfd ]==' '{_gaca =_cbebfd ;
break ;};};};_edcc :=string (_ffgd );if _gaca > 0{_edcc =string (_ffgd [0:_gaca +1]);_ffgd =append (_ffgd [_gaca +1:],_bead );_defd =append (_defd [_gaca +1:],_bbfcb );_afdcba =0;for _ ,_afabb :=range _defd {_afdcba +=_afabb ;};}else {if _bgcde {_ffgd =[]rune {};
_defd =[]float64 {};_afdcba =0;}else {_ffgd =[]rune {_bead };_defd =[]float64 {_bbfcb };_afdcba =_bbfcb ;};};_edcc =_ebaa (_edcc ,_egfeg );_dege =append (_dege ,_ddf .TrimRightFunc (_edcc ,_ab .IsSpace ));}else {_ffgd =append (_ffgd ,_bead );_afdcba +=_bbfcb ;
_defd =append (_defd ,_bbfcb );};};if len (_ffgd )> 0{_fgada :=string (_ffgd );_fgada =_ebaa (_fgada ,_egfeg );_dege =append (_dege ,_fgada );};return _dege ,nil ;};func (_defcbe *templateProcessor )nodeLogDebug (_deccb *templateNode ,_dded string ,_cddcc ...interface{}){_ca .Log .Debug (_defcbe .getNodeErrorLocation (_deccb ,_dded ,_cddcc ...));
};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_fcbbaa *TOCLine )SetLevelOffset (levelOffset float64 ){_fcbbaa ._gedeb =levelOffset ;_fcbbaa ._ecfeg ._affa .Left =_fcbbaa ._gdcff +float64 (_fcbbaa ._bfcf -1)*_fcbbaa ._gedeb ;};func (_fadb *templateProcessor )addNodeText (_ggeed *templateNode ,_afdfg string )error {_ebca :=_ggeed ._fdfd ;
if _ebca ==nil {return nil ;};switch _afdbg :=_ebca .(type ){case *TextChunk :_afdbg .Text =_afdfg ;case *Paragraph :switch _ggeed ._eccfd .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _ggeed ._ddbbd !=nil {if _cefgb ,_beffe :=_ggeed ._ddbbd ._fdfd .(*Chapter );
_beffe {_cefgb ._fagc =_afdfg ;_afdbg .SetText (_cefgb .headingText ());};};default:_afdbg .SetText (_afdfg );};};return nil ;};

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_gbc *Image )SetFitMode (fitMode FitMode ){_gbc ._gfba =fitMode };func _cffg (_dfgcg float64 ,_fgegf int )float64 {_gbeaa :=_ff .Pow10 (_fgegf );return _ff .Round (_gbeaa *_dfgcg )/_gbeaa ;};func _adcc (_aec ,_cea *_gd .PdfPageResources )error {_dfcg ,_ :=_aec .GetColorspaces ();
if _dfcg !=nil &&len (_dfcg .Colorspaces )> 0{for _feb ,_agad :=range _dfcg .Colorspaces {_egbf :=*_be .MakeName (_feb );if _cea .HasColorspaceByName (_egbf ){continue ;};_eccg :=_cea .SetColorspaceByName (_egbf ,_agad );if _eccg !=nil {return _eccg ;};
};};return nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_bcbe *StyledParagraph )SetLineHeight (lineheight float64 ){_bcbe ._bcde =lineheight };func _dgeb (_dgcgg *_gd .PdfRectangle ,_bfeabd _cbe .Matrix )*_gd .PdfRectangle {var _bcafg _gd .PdfRectangle ;_bcafg .Llx ,_bcafg .Lly =_bfeabd .Transform (_dgcgg .Llx ,_dgcgg .Lly );
_bcafg .Urx ,_bcafg .Ury =_bfeabd .Transform (_dgcgg .Urx ,_dgcgg .Ury );_bcafg .Normalize ();return &_bcafg ;};func (_eggbe *templateProcessor )parseInt64Attr (_edeed ,_fbbbf string )int64 {_ca .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_edeed ,_fbbbf );
_caabc ,_ :=_fd .ParseInt (_fbbbf ,10,64);return _caabc ;};

// GetCoords returns coordinates of border.
func (_efab *border )GetCoords ()(float64 ,float64 ){return _efab ._ffa ,_efab ._cbc };

// Lines returns all the lines the table of contents has.
func (_efdd *TOC )Lines ()[]*TOCLine {return _efdd ._gfcc };

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_bfba *GraphicSVG )ScaleToWidth (w float64 ){_ece :=_bfba ._dddg .Height /_bfba ._dddg .Width ;_bfba ._dddg .Width =w ;_bfba ._dddg .Height =w *_ece ;_bfba ._dddg .SetScaling (_ece ,_ece );};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_daec *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _cegb (x1 ,y1 ,x2 ,y2 )};func _badfd (_bab *_ea .GraphicSVG )(*GraphicSVG ,error ){return &GraphicSVG {_dddg :_bab ,_cdgd :PositionRelative ,_agdb :Margins {Top :10,Bottom :10}},nil ;
};func (_bdf *Block )SetMarkedContentID (id int64 )*_gd .KDict {return nil };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);func (_bfegc *templateProcessor )getNodeErrorLocation (_gfgg *templateNode ,_cfff string ,_aagae ...interface{})string {_afdcb :=_f .Sprintf (_cfff ,_aagae ...);
_cfba :=_f .Sprintf ("\u0025\u0064",_gfgg ._afdda );if _gfgg ._gbdd !=0{_cfba =_f .Sprintf ("\u0025\u0064\u003a%\u0064",_gfgg ._gbdd ,_gfgg ._ggcca );};if _bfegc ._cabb !=""{return _f .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_afdcb ,_bfegc ._cabb ,_cfba );
};return _f .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_afdcb ,_cfba );};func _ddcfb (_eefaa *templateProcessor ,_acgg *templateNode )(interface{},error ){return _eefaa .parseTable (_acgg );};func _cddab (_edeca ...interface{})[]interface{}{return _edeca };


// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_ecfeg *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_gdcff float64 ;_bfcf uint ;_gedeb float64 ;_cdfed Positioning ;_bfcae float64 ;_geaed float64 ;_bfabf int64 ;};func _aagc (_gbedg []*_gd .PdfAnnotation )[]*_gd .PdfAnnotation {var _bfbc []*_gd .PdfAnnotation ;for _ ,_bdfg :=range _gbedg {_bfbc =append (_bfbc ,_cebge (_bdfg ));
};return _bfbc ;};

// Rows returns the total number of rows the table has.
func (_eafbd *Table )Rows ()int {return _eafbd ._addf };func _baddb (_gbed *templateProcessor ,_eagdb *templateNode )(interface{},error ){return _gbed .parsePageBreak (_eagdb );};func _aegcb (_gcdb ...interface{})(map[string ]interface{},error ){_cffff :=len (_gcdb );
if _cffff %2!=0{_ca .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_cffff );
return nil ,_be .ErrRangeError ;};_aegf :=map[string ]interface{}{};for _cbfffc :=0;_cbfffc < _cffff ;_cbfffc +=2{_abdd ,_ddge :=_gcdb [_cbfffc ].(string );if !_ddge {_ca .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_gcdb [_cbfffc ]);
return nil ,_be .ErrTypeError ;};_aegf [_abdd ]=_gcdb [_cbfffc +1];};return _aegf ,nil ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_gfd *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abec :=ctx ;if _gfd ._adba .IsRelative (){ctx .X +=_gfd ._dfdg .Left ;ctx .Y +=_gfd ._dfdg .Top ;ctx .Width -=_gfd ._dfdg .Left +_gfd ._dfdg .Right ;ctx .Height -=_gfd ._dfdg .Top ;
};_decg ,_cbbg ,_fced :=_gfd ._adbf .GeneratePageBlocks (ctx );if _fced !=nil {return _decg ,ctx ,_fced ;};ctx =_cbbg ;_cdg :=ctx .X ;_aabc :=ctx .Y -_gfd ._adbf .Height ();_egcb :=int64 (ctx .Page );_bdde :=_gfd .headingNumber ();_dgaa :=_gfd .headingText ();
if _gfd ._addc {_dab :=_gfd ._bbg .Add (_bdde ,_gfd ._fagc ,_fd .FormatInt (_egcb ,10),_gfd ._ecgg );if _gfd ._bbg ._daded {_dab .SetLink (_egcb ,_cdg ,_aabc );};};if _gfd ._edge ==nil {_gfd ._edge =_gd .NewOutlineItem (_dgaa ,_gd .NewOutlineDest (_egcb -1,_cdg ,_aabc ));
if _gfd ._bae !=nil {_gfd ._bae ._edge .Add (_gfd ._edge );}else {_gfd ._acbg .Add (_gfd ._edge );};}else {_bce :=&_gfd ._edge .Dest ;_bce .Page =_egcb -1;_bce .X =_cdg ;_bce .Y =_aabc ;};for _ ,_dca :=range _gfd ._agef {_effd ,_fgdd ,_acbb :=_dca .GeneratePageBlocks (ctx );
if _acbb !=nil {return _decg ,ctx ,_acbb ;};if len (_effd )< 1{continue ;};_decg [len (_decg )-1].mergeBlocks (_effd [0]);_decg =append (_decg ,_effd [1:]...);ctx =_fgdd ;};if _gfd ._adba .IsRelative (){ctx .X =_abec .X ;};if _gfd ._adba .IsAbsolute (){return _decg ,_abec ,nil ;
};return _decg ,ctx ,nil ;};func (_abgff *TOCLine )getLineLink ()*_gd .PdfAnnotation {if _abgff ._bfabf <=0{return nil ;};return _egded (_abgff ._bfabf -1,_abgff ._bfcae ,_abgff ._geaed ,0);};

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_abc *Rectangle )SetCoords (x ,y float64 ){_abc ._fdeb =x ;_abc ._fefcd =y };func (_aaccb *Table )wrapRow (_cefe int ,_fegf DrawContext ,_ecbf float64 )(bool ,error ){if !_aaccb ._ffeag {return false ,nil ;};var (_eaef =_aaccb ._gedg [_cefe ];_ggbge =-1;
_efbd []*TableCell ;_cgefd float64 ;_gcaa bool ;_gbgcb =make ([]float64 ,0,len (_aaccb ._faae )););_ddbed :=func (_gcgfc *TableCell ,_cgad VectorDrawable ,_adbd bool )*TableCell {_gefad :=*_gcgfc ;_gefad ._bdea =_cgad ;if _adbd {_gefad ._fgcga ++;};return &_gefad ;
};_bffff :=func (_feffc int ,_egbaf VectorDrawable ){var _gfdb float64 =-1;if _egbaf ==nil {if _cdge :=_gbgcb [_feffc -_cefe ];_cdge > _fegf .Height {_egbaf =_aaccb ._gedg [_feffc ]._bdea ;_aaccb ._gedg [_feffc ]._bdea =nil ;_gbgcb [_feffc -_cefe ]=0;_gfdb =_cdge ;
};};_acedf :=_ddbed (_aaccb ._gedg [_feffc ],_egbaf ,true );_efbd =append (_efbd ,_acedf );if _gfdb < 0{_gfdb =_acedf .height (_fegf .Width );};if _gfdb > _cgefd {_cgefd =_gfdb ;};};for _cdfca :=_cefe ;_cdfca < len (_aaccb ._gedg );_cdfca ++{_eecb :=_aaccb ._gedg [_cdfca ];
if _eaef ._fgcga !=_eecb ._fgcga {_ggbge =_cdfca ;break ;};_fegf .Width =_eecb .width (_aaccb ._faae ,_ecbf );_ebgb :=_eecb .height (_fegf .Width );var _bacga VectorDrawable ;switch _bfeab :=_eecb ._bdea .(type ){case *StyledParagraph :if _ebgb > _fegf .Height {_gege :=_fegf ;
_gege .Height =_ff .Floor (_fegf .Height -_bfeab ._affa .Top -_bfeab ._affa .Bottom -0.5*_bfeab .getTextHeight ());_ddbdba ,_eggbb ,_baaa :=_bfeab .split (_gege );if _baaa !=nil {return false ,_baaa ;};if _ddbdba !=nil &&_eggbb !=nil {_bfeab =_ddbdba ;
_eecb =_ddbed (_eecb ,_ddbdba ,false );_aaccb ._gedg [_cdfca ]=_eecb ;_bacga =_eggbb ;_gcaa =true ;};_ebgb =_eecb .height (_fegf .Width );};case *Division :if _ebgb > _fegf .Height {_fdgg :=_fegf ;_fdgg .Height =_ff .Floor (_fegf .Height -_bfeab ._fceg .Top -_bfeab ._fceg .Bottom );
_abgf ,_dfccg :=_bfeab .split (_fdgg );if _abgf !=nil &&_dfccg !=nil {_bfeab =_abgf ;_eecb =_ddbed (_eecb ,_abgf ,false );_aaccb ._gedg [_cdfca ]=_eecb ;_bacga =_dfccg ;_gcaa =true ;if _abgf ._bacfc !=nil {_abgf ._bacfc .BorderRadiusBottomLeft =0;_abgf ._bacfc .BorderRadiusBottomRight =0;
};if _dfccg ._bacfc !=nil {_dfccg ._bacfc .BorderRadiusTopLeft =0;_dfccg ._bacfc .BorderRadiusTopRight =0;};_ebgb =_eecb .height (_fegf .Width );};};case *List :if _ebgb > _fegf .Height {_deeg :=_fegf ;_deeg .Height =_ff .Floor (_fegf .Height -_bfeab ._edgdc .Vertical ());
_edebf ,_agdgg :=_bfeab .split (_deeg );if _edebf !=nil {_bfeab =_edebf ;_eecb =_ddbed (_eecb ,_edebf ,false );_aaccb ._gedg [_cdfca ]=_eecb ;};if _agdgg !=nil {_bacga =_agdgg ;_gcaa =true ;};_ebgb =_eecb .height (_fegf .Width );};};_gbgcb =append (_gbgcb ,_ebgb );
if _gcaa {if _efbd ==nil {_efbd =make ([]*TableCell ,0,len (_aaccb ._faae ));for _decaf :=_cefe ;_decaf < _cdfca ;_decaf ++{_bffff (_decaf ,nil );};};_bffff (_cdfca ,_bacga );};};var _bffgg float64 ;for _ ,_cefg :=range _gbgcb {if _cefg > _bffgg {_bffgg =_cefg ;
};};if _gcaa &&_bffgg < _fegf .Height {if _ggbge < 0{_ggbge =len (_aaccb ._gedg );};_gceaa :=_aaccb ._gedg [_ggbge -1]._fgcga +_aaccb ._gedg [_ggbge -1]._edegf -1;for _dfbg :=_ggbge ;_dfbg < len (_aaccb ._gedg );_dfbg ++{_aaccb ._gedg [_dfbg ]._fgcga ++;
};_aaccb ._gedg =append (_aaccb ._gedg [:_ggbge ],append (_efbd ,_aaccb ._gedg [_ggbge :]...)...);_aaccb ._gadc =append (_aaccb ._gadc [:_gceaa ],append ([]float64 {_cgefd },_aaccb ._gadc [_gceaa :]...)...);_aaccb ._gadc [_eaef ._fgcga +_eaef ._edegf -2]=_bffgg ;
};return _gcaa ,nil ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_bcbc []*TextChunk ;_cggd TextStyle ;_debd TextStyle ;_abff TextAlignment ;_eeedb TextVerticalAlignment ;_bcde float64 ;_egbgc bool ;_cbcb float64 ;_fecad bool ;_baceb bool ;_fcga TextOverflow ;_cbace float64 ;_affa Margins ;
_abab Positioning ;_cabcd float64 ;_ccde float64 ;_efea float64 ;_abag float64 ;_ccae [][]*TextChunk ;_bfbe func (_ffdd *StyledParagraph ,_ecee DrawContext );_gbdb *int64 ;_abce string ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_aafb *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aafb ._affa .Left ,_aafb ._affa .Right ,_aafb ._affa .Top ,_aafb ._affa .Bottom ;};func _cbgb (_fdf ,_dgda ,_gfga ,_fdeg ,_fafd ,_ebaf float64 )*Curve {_egef :=&Curve {};
_egef ._eded =_fdf ;_egef ._dbcd =_dgda ;_egef ._efdba =_gfga ;_egef ._bacf =_fdeg ;_egef ._ffea =_fafd ;_egef ._agefe =_ebaf ;_egef ._gffeeb =ColorBlack ;_egef ._bdag =1.0;return _egef ;};func (_addad *templateProcessor )parseList (_ecfc *templateNode )(interface{},error ){_fdag :=_addad .creator .NewList ();
for _ ,_cefgc :=range _ecfc ._eccfd .Attr {_gadf :=_cefgc .Value ;switch _dcda :=_cefgc .Name .Local ;_dcda {case "\u0069\u006e\u0064\u0065\u006e\u0074":_fdag .SetIndent (_addad .parseFloatAttr (_dcda ,_gadf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_fgee :=_addad .parseMarginAttr (_dcda ,_gadf );
_fdag .SetMargins (_fgee .Left ,_fgee .Right ,_fgee .Top ,_fgee .Bottom );default:_addad .nodeLogDebug (_ecfc ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dcda );
};};return _fdag ,nil ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_bgfbd *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_bgfbd ._dda =toc ;};func _dacbg (_bfae *templateProcessor ,_fadaf *templateNode )(interface{},error ){return _bfae .parseEllipse (_fadaf );};

// SetRowHeight sets the height for a specified row.
func (_dbfb *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_dbfb ._gadc ){return _fc .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dbfb ._gadc [row -1]=h ;return nil ;
};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_cbfc *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_bedd []*Block ;_afccg =NewBlock (ctx .PageWidth ,ctx .PageHeight );_baafd =ctx ;_agabb =_cbfc ._bcdgg /2;);_fgff :=_cbfc ._dbdf .IsRelative ();if _fgff {_cbfc .applyFitMode (ctx .Width );
ctx .X +=_cbfc ._ddfgb .Left +_agabb ;ctx .Y +=_cbfc ._ddfgb .Top +_agabb ;ctx .Width -=_cbfc ._ddfgb .Left +_cbfc ._ddfgb .Right ;ctx .Height -=_cbfc ._ddfgb .Top +_cbfc ._ddfgb .Bottom ;if _cbfc ._ddccd > ctx .Height {_bedd =append (_bedd ,_afccg );_afccg =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_cdcb :=ctx ;_cdcb .Y =ctx .Margins .Top +_cbfc ._ddfgb .Top +_agabb ;_cdcb .X =ctx .Margins .Left +_cbfc ._ddfgb .Left +_agabb ;_cdcb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_cbfc ._ddfgb .Top -_cbfc ._ddfgb .Bottom ;
_cdcb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cbfc ._ddfgb .Left -_cbfc ._ddfgb .Right ;ctx =_cdcb ;};}else {ctx .X =_cbfc ._fdeb ;ctx .Y =_cbfc ._fefcd ;};_dffe :=_ddb .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_cbfc ._ddccd ,Width :_cbfc ._dacdg ,Height :_cbfc ._ddccd ,BorderRadiusTopLeft :_cbfc ._dfegd ,BorderRadiusTopRight :_cbfc ._afgd ,BorderRadiusBottomLeft :_cbfc ._ebddb ,BorderRadiusBottomRight :_cbfc ._fcgc ,Opacity :1.0};
if _cbfc ._gffbd !=nil {_dffe .FillEnabled =true ;_efee :=_fac (_cbfc ._gffbd );_bgcb :=_gaea (_afccg ,_efee ,_cbfc ._gffbd ,func ()Rectangle {return Rectangle {_fdeb :_dffe .X ,_fefcd :_dffe .Y ,_dacdg :_dffe .Width ,_ddccd :_dffe .Height };});if _bgcb !=nil {return nil ,ctx ,_bgcb ;
};_dffe .FillColor =_efee ;};if _cbfc ._aagf !=nil &&_cbfc ._bcdgg > 0{_dffe .BorderEnabled =true ;_dffe .BorderColor =_fac (_cbfc ._aagf );_dffe .BorderWidth =_cbfc ._bcdgg ;};_egbfc ,_eaae :=_afccg .setOpacity (_cbfc ._aadb ,_cbfc ._ggge );if _eaae !=nil {return nil ,ctx ,_eaae ;
};_dggd ,_ ,_eaae :=_dffe .MarkedDraw (_egbfc ,_cbfc ._bcee );if _eaae !=nil {return nil ,ctx ,_eaae ;};if _eaae =_afccg .addContentsByString (string (_dggd ));_eaae !=nil {return nil ,ctx ,_eaae ;};if _fgff {ctx .X =_baafd .X ;ctx .Width =_baafd .Width ;
_beed :=_cbfc ._ddccd +_agabb ;ctx .Y +=_beed +_cbfc ._ddfgb .Bottom ;ctx .Height -=_beed ;}else {ctx =_baafd ;};_bedd =append (_bedd ,_afccg );return _bedd ,ctx ,nil ;};

// SetAnchor set gradient position anchor.
// Default to center.
func (_fccb *RadialShading )SetAnchor (anchor AnchorPoint ){_fccb ._cgdec =anchor };

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_dcgce *TOC )SetLineTitleStyle (style TextStyle ){_dcgce ._eebgb =style };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_fage *Paragraph )SetMaxLines (maxLines int ){_fage ._gdef =maxLines ;_fage .wrapText ()};

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_feab *Ellipse )ScaleToHeight (h float64 ){_afdb :=_feab ._gbea /_feab ._fgbb ;_feab ._fgbb =h ;_feab ._gbea =h *_afdb ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dcbbf *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _dcbbf ._fgfe [0],_dcbbf ._fgfe [1];};

// Style returns the style of the line.
func (_gfa *Line )Style ()_ddb .LineStyle {return _gfa ._dddcg };

// Positioning returns the type of positioning the rectangle is set to use.
func (_beeec *Rectangle )Positioning ()Positioning {return _beeec ._dbdf };func (_facg *Paragraph )getMaxLineWidth ()float64 {if _facg ._beag ==nil ||(_facg ._beag !=nil &&len (_facg ._beag )==0){_facg .wrapText ();};var _dgdc float64 ;for _ ,_accce :=range _facg ._beag {_bbbfe :=_facg .getTextLineWidth (_accce );
if _bbbfe > _dgdc {_dgdc =_bbbfe ;};};return _dgdc ;};

// ColorGrayFromArithmetic creates a Color from a grayscale value (0-1).
// Example:
//
//	gray := ColorGrayFromArithmetic(0.7)
func ColorGrayFromArithmetic (g float64 )Color {return grayColor {g }};

// SetFillOpacity sets the fill opacity.
func (_dfcbd *CurvePolygon )SetFillOpacity (opacity float64 ){_dfcbd ._bgabd =opacity };var (_ebeae =_g .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");_dgaba =_fc .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");
_eeeee =_fc .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");_deegg =_fc .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");
_fababg =_fc .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e"););func (_gbdee *templateProcessor )loadImageFromSrc (_deaeb string )(*Image ,error ){if _deaeb ==""{_ca .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_fababg ;};_dadg :=_ddf .Split (_deaeb ,"\u002c");for _ ,_ebead :=range _dadg {_ebead =_ddf .TrimSpace (_ebead );if _ebead ==""{continue ;};_cafba ,_bfeaa :=_gbdee ._agabg .ImageMap [_ebead ];if _bfeaa {return _bddd (_cafba );};if _eadd :=_gbdee .parseAttrPropList (_ebead );
len (_eadd )> 0{if _gafge ,_ggadc :=_eadd ["\u0070\u0061\u0074\u0068"];_ggadc {if _fbab ,_eade :=_dgc (_gafge );_eade !=nil {_ca .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_gafge ,_eade );
}else {return _fbab ,nil ;};};};};_ca .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_deaeb );return nil ,_fababg ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_feff *Creator )SetOptimizer (optimizer _gd .Optimizer ){_feff ._bfg =optimizer };

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_affb *Paragraph )SetLanguageIdentifier (id string ){_affb ._fbbdg =id };

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _agfg (svgStr )};func _fbfgd (_dedb *templateProcessor ,_gacbe *templateNode )(interface{},error ){return _dedb .parseChapterHeading (_gacbe );};

// SetEnableWrap sets the line wrapping enabled flag.
func (_bafb *Paragraph )SetEnableWrap (enableWrap bool ){_bafb ._abaa =enableWrap ;_bafb ._aagb =false };

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_fgbbd *GraphicSVG )ScaleToHeight (h float64 ){_daff :=_fgbbd ._dddg .Width /_fgbbd ._dddg .Height ;_fgbbd ._dddg .Height =h ;_fgbbd ._dddg .Width =h *_daff ;_fgbbd ._dddg .SetScaling (_daff ,_daff );};

// SetColPosition sets cell column position.
func (_gddee *TableCell )SetColPosition (col int ){_gddee ._gggbbd =col };

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_cdeb *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_cdeb ._ddfgb .Left =left ;_cdeb ._ddfgb .Right =right ;_cdeb ._ddfgb .Top =top ;_cdeb ._ddfgb .Bottom =bottom ;};func (_cbag *Invoice )setCellBorder (_dcfd *TableCell ,_deaf *InvoiceCell ){for _ ,_dddca :=range _deaf .BorderSides {_dcfd .SetBorder (_dddca ,CellBorderStyleSingle ,_deaf .BorderWidth );
};_dcfd .SetBorderColor (_deaf .BorderColor );};func _baead (_feggf *_gd .PdfRectangle ,_dbcfa float64 )[4]_ddb .Point {_fbaed :=_dbcfa *_ff .Pi /180.0;_dcccc :=_feggf .Width ();_edfbdd :=_feggf .Height ();_fgegc :=_ff .Sin (_fbaed );_ccfag :=_ff .Cos (_fbaed );
_dccf :=[4]_ddb .Point {{X :_cffg (_feggf .Llx ,3),Y :_cffg (_feggf .Lly ,3)},{X :_cffg (_feggf .Llx +_dcccc *_ccfag ,3),Y :_cffg (_feggf .Lly +_dcccc *_fgegc ,3)},{X :_cffg (_feggf .Llx +_dcccc *_ccfag -_edfbdd *_fgegc ,3),Y :_cffg (_feggf .Lly +_dcccc *_fgegc +_edfbdd *_ccfag ,3)},{X :_cffg (_feggf .Llx -_edfbdd *_fgegc ,3),Y :_cffg (_feggf .Lly +_edfbdd *_ccfag ,3)}};
return _dccf ;};func (_beaab *templateProcessor )parseHorizontalAlignmentAttr (_baea ,_cdecd string )HorizontalAlignment {_ca .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_baea ,_cdecd );
_bgabeg :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_cdecd ];return _bgabeg ;};

// CreateFrontPage sets a function to generate a front Page.
func (_cdgg *Creator )CreateFrontPage (genFrontPageFunc func (_aage FrontpageFunctionArgs )){_cdgg ._bbde =genFrontPageFunc ;};

// ColorGrayFrom8bit creates a Color from 8-bit (0-255) gray values.
// Example:
//
//	gray := ColorGrayFrom8bit(255, 0, 0)
func ColorGrayFrom8bit (g byte )Color {return grayColor {float64 (g )/255.0}};func (_gc *Block )addContents (_cge *_eag .ContentStreamOperations ){_gc ._ge .WrapIfNeeded ();_cge .WrapIfNeeded ();*_gc ._ge =append (*_gc ._ge ,*_cge ...);};const (CellBorderSideLeft CellBorderSide =iota ;
CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// SetMargins sets the margins of the graphic svg component.
func (_gcbe *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_gcbe ._agdb .Left =left ;_gcbe ._agdb .Right =right ;_gcbe ._agdb .Top =top ;_gcbe ._agdb .Bottom =bottom ;};

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_acg *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _bgaf (colorPoints );};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetSideBorderColor sets the cell's side border color.
func (_efcb *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_efcb ._agcef =col ;_efcb ._daea =col ;_efcb ._edgac =col ;_efcb ._cada =col ;case CellBorderSideTop :_efcb ._agcef =col ;case CellBorderSideBottom :_efcb ._daea =col ;
case CellBorderSideLeft :_efcb ._edgac =col ;case CellBorderSideRight :_efcb ._cada =col ;};};

// SkipOver skips over a specified number of rows and cols.
func (_eacd *Table )SkipOver (rows ,cols int ){_ccdb :=rows *_eacd ._cafcb +cols -1;if _ccdb < 0{_ca .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _fddgb :=0;_fddgb < _ccdb ;_fddgb ++{_eacd .NewCell ();};};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_cfcc *Creator )NewPage ()*_gd .PdfPage {_afg :=_cfcc .newPage ();_cfcc ._bee =append (_cfcc ._bee ,_afg );_cfcc ._ecfb .Page ++;return _afg ;};

// NewDivision returns a new Division container component.
func (_dee *Creator )NewDivision ()*Division {return _cfgb ()};func (_bbcbc *templateProcessor )parseBackground (_fgcge *templateNode )(interface{},error ){_dggae :=&Background {};for _ ,_dcfcc :=range _fgcge ._eccfd .Attr {_ggcd :=_dcfcc .Value ;switch _ccgca :=_dcfcc .Name .Local ;
_ccgca {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_dggae .FillColor =_bbcbc .parseColorAttr (_ccgca ,_ggcd );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_dggae .BorderColor =_bbcbc .parseColorAttr (_ccgca ,_ggcd );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_dggae .BorderSize =_bbcbc .parseFloatAttr (_ccgca ,_ggcd );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_dddgc ,_egggf ,_gaeeg ,_aeagg :=_bbcbc .parseBorderRadiusAttr (_ccgca ,_ggcd );
_dggae .SetBorderRadius (_dddgc ,_egggf ,_aeagg ,_gaeeg );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_dggae .BorderRadiusTopLeft =_bbcbc .parseFloatAttr (_ccgca ,_ggcd );
case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_dggae .BorderRadiusTopRight =_bbcbc .parseFloatAttr (_ccgca ,_ggcd );case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_dggae .BorderRadiusBottomLeft =_bbcbc .parseFloatAttr (_ccgca ,_ggcd );
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_dggae .BorderRadiusBottomRight =_bbcbc .parseFloatAttr (_ccgca ,_ggcd );default:_bbcbc .nodeLogDebug (_fgcge ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_ccgca );
};};return _dggae ,nil ;};

// Level returns the indentation level of the TOC line.
func (_baddc *TOCLine )Level ()uint {return _baddc ._bfcf };

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//
//	red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_afd :float64 (r )/255.0,_fef :float64 (g )/255.0,_cbbf :float64 (b )/255.0};};type cmykColor struct{_cgab ,_bfdc ,_fec ,_febg float64 };const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;
CellBorderStyleDouble ;);func (_bacgc *templateProcessor )parseChapterHeading (_gggec *templateNode )(interface{},error ){if _gggec ._ddbbd ==nil {_bacgc .nodeLogError (_gggec ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_eeeee ;};_geffg ,_affdfe :=_gggec ._ddbbd ._fdfd .(*Chapter );if !_affdfe {_bacgc .nodeLogError (_gggec ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_gggec ._ddbbd ._fdfd );
return nil ,_eeeee ;};_ffff :=_geffg .GetHeading ();if _ ,_cgfg :=_bacgc .parseParagraph (_gggec ,_ffff );_cgfg !=nil {return nil ,_cgfg ;};return _ffff ,nil ;};func (_ecggd *InvoiceAddress )fmtLine (_fabf ,_gdbg string ,_ffec bool )string {if _ffec {_gdbg ="";
};return _f .Sprintf ("\u0025\u0073\u0025s\u000a",_gdbg ,_fabf );};

// SetFillOpacity sets the fill opacity.
func (_cgbc *PolyBezierCurve )SetFillOpacity (opacity float64 ){_cgbc ._dcfbf =opacity };func (_aeag *Invoice )newCell (_agab string ,_cfed InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_cfed ,_agab };};func (_ged *Block )drawToPage (_bff *_gd .PdfPage )error {_eba :=&_eag .ContentStreamOperations {};
if _bff .Resources ==nil {_bff .Resources =_gd .NewPdfPageResources ();};_eebb :=_cga (_eba ,_bff .Resources ,_ged ._ge ,_ged ._fa );if _eebb !=nil {return _eebb ;};if _eebb =_adcc (_ged ._fa ,_bff .Resources );_eebb !=nil {return _eebb ;};if _eebb =_bff .AppendContentBytes (_eba .Bytes (),true );
_eebb !=nil {return _eebb ;};for _ ,_cbg :=range _ged ._bdc {_bff .AddAnnotation (_cbg );};return nil ;};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_gagcg *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfeca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_beaaf ,_eeebd :=_cfeca .setOpacity (_gagcg ._aegga ,_gagcg ._aegga );if _eeebd !=nil {return nil ,ctx ,_eeebd ;
};_cadgd :=_gagcg ._gcaf .Points ;for _cgbe :=range _cadgd {_edgf :=&_cadgd [_cgbe ];_edgf .Y =ctx .PageHeight -_edgf .Y ;};_aebga ,_ ,_eeebd :=_gagcg ._gcaf .MarkedDraw (_beaaf ,_gagcg ._ecga );if _eeebd !=nil {return nil ,ctx ,_eeebd ;};if _eeebd =_cfeca .addContentsByString (string (_aebga ));
_eeebd !=nil {return nil ,ctx ,_eeebd ;};return []*Block {_cfeca },ctx ,nil ;};

// Text sets the text content of the Paragraph.
func (_egba *Paragraph )Text ()string {return _egba ._bcgag };

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_edff *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _edff ._cbaag ==nil {if _cega :=_edff .makeXObject ();_cega !=nil {return nil ,ctx ,_cega ;};};var _egcc []*Block ;_bafe :=ctx ;_fcgb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _edff ._dbafc .IsRelative (){_edff .applyFitMode (ctx .Width );ctx .X +=_edff ._fcad .Left ;ctx .Y +=_edff ._fcad .Top ;ctx .Width -=_edff ._fcad .Left +_edff ._fcad .Right ;ctx .Height -=_edff ._fcad .Top +_edff ._fcad .Bottom ;if _edff ._fae > ctx .Height {_egcc =append (_egcc ,_fcgb );
_fcgb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cgbf :=ctx ;_cgbf .Y =ctx .Margins .Top +_edff ._fcad .Top ;_cgbf .X =ctx .Margins .Left +_edff ._fcad .Left ;_cgbf .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_edff ._fcad .Top -_edff ._fcad .Bottom ;
_cgbf .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_edff ._fcad .Left -_edff ._fcad .Right ;ctx =_cgbf ;};}else {ctx .X =_edff ._aeae ;ctx .Y =_edff ._bgabe ;};ctx ,_dabb :=_bdab (_fcgb ,_edff ,ctx );if _dabb !=nil {return nil ,ctx ,_dabb ;
};_egcc =append (_egcc ,_fcgb );if _edff ._dbafc .IsAbsolute (){ctx =_bafe ;}else {ctx .X =_bafe .X ;ctx .Width =_bafe .Width ;ctx .Y +=_edff ._fcad .Bottom ;};return _egcc ,ctx ,nil ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_ceff *TOC )SetLinePageStyle (style TextStyle ){_ceff ._ccffd =style };

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;func _ebcd (_fcgg [][]_ddb .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_fbff :&_ddb .CurvePolygon {Rings :_fcgg },_bgabd :1.0,_acfa :1.0};};func _ccbgg (_bgag ,_gded TextStyle )*Invoice {_addg :=&Invoice {_bgfbda :"\u0049N\u0056\u004f\u0049\u0043\u0045",_gggd :"\u002c\u0020",_bdae :_bgag ,_ddba :_gded };
_addg ._afbf =&InvoiceAddress {Separator :_addg ._gggd };_addg ._adbcd =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_addg ._gggd };_efe :=ColorRGBFrom8bit (245,245,245);_faba :=ColorRGBFrom8bit (155,155,155);_addg ._fcbed =_gded ;
_addg ._fcbed .Color =_faba ;_addg ._fcbed .FontSize =20;_addg ._gdga =_bgag ;_addg ._fefc =_gded ;_addg ._degfg =_bgag ;_addg ._begb =_gded ;_addg ._ffda =_addg .NewCellProps ();_addg ._ffda .BackgroundColor =_efe ;_addg ._ffda .TextStyle =_gded ;_addg ._dbbfd =_addg .NewCellProps ();
_addg ._dbbfd .TextStyle =_gded ;_addg ._dbbfd .BackgroundColor =_efe ;_addg ._dbbfd .BorderColor =_efe ;_addg ._ddce =_addg .NewCellProps ();_addg ._ddce .BorderColor =_efe ;_addg ._ddce .BorderSides =[]CellBorderSide {CellBorderSideBottom };_addg ._ddce .Alignment =CellHorizontalAlignmentRight ;
_addg ._aabdc =_addg .NewCellProps ();_addg ._aabdc .Alignment =CellHorizontalAlignmentRight ;_addg ._eeffg =[2]*InvoiceCell {_addg .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_addg ._ffda ),_addg .newCell ("",_addg ._ffda )};
_addg ._cegfg =[2]*InvoiceCell {_addg .newCell ("\u0044\u0061\u0074\u0065",_addg ._ffda ),_addg .newCell ("",_addg ._ffda )};_addg ._fgfe =[2]*InvoiceCell {_addg .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_addg ._ffda ),_addg .newCell ("",_addg ._ffda )};
_addg ._ffce =[2]*InvoiceCell {_addg .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_addg ._aabdc ),_addg .newCell ("",_addg ._aabdc )};_dbbb :=_addg ._aabdc ;_dbbb .TextStyle =_gded ;_dbbb .BackgroundColor =_efe ;_dbbb .BorderColor =_efe ;
_addg ._cecdb =[2]*InvoiceCell {_addg .newCell ("\u0054\u006f\u0074a\u006c",_dbbb ),_addg .newCell ("",_dbbb )};_addg ._cdbg =[2]string {"\u004e\u006f\u0074e\u0073",""};_addg ._acae =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_addg ._gbbc =[]*InvoiceCell {_addg .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_addg .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_addg .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_addg .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _addg ;};type fontMetrics struct{_edgacc float64 ;_daeb float64 ;_gecf float64 ;_gfcgf float64 ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_faad *Creator )EnableFontSubsetting (font *_gd .PdfFont ){_faad ._dgad =append (_faad ._dgad ,font );};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_aabgg *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aabgg ._fcad .Left ,_aabgg ._fcad .Right ,_aabgg ._fcad .Top ,_aabgg ._fcad .Bottom ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_ddee *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_eeecec ,_ebaea :=_ddee .Wrap (width );if _ebaea !=nil {return nil ,_ebaea ;};_dcagb :=int (height /_ddee .Style .FontSize );if _dcagb >=len (_eeecec ){return nil ,nil ;};_gccd :="\u000a";
_ddee .Text =_ddf .Replace (_ddf .Join (_eeecec [:_dcagb ],"\u0020"),_gccd +"\u0020",_gccd ,-1);_baab :=_ddf .Replace (_ddf .Join (_eeecec [_dcagb :],"\u0020"),_gccd +"\u0020",_gccd ,-1);return NewTextChunk (_baab ,_ddee .Style ),nil ;};func _adebe (_egaaf ,_bbgb interface{})(interface{},error ){_bbedd ,_ddabf :=_agcee (_egaaf );
if _ddabf !=nil {return nil ,_ddabf ;};switch _faebc :=_bbedd .(type ){case int64 :_fgfbd ,_cddfe :=_agcee (_bbgb );if _cddfe !=nil {return nil ,_cddfe ;};switch _cbffc :=_fgfbd .(type ){case int64 :return _faebc +_cbffc ,nil ;case float64 :return float64 (_faebc )+_cbffc ,nil ;
};case float64 :_eaeef ,_bbbdg :=_agcee (_bbgb );if _bbbdg !=nil {return nil ,_bbbdg ;};switch _dcfge :=_eaeef .(type ){case int64 :return _faebc +float64 (_dcfge ),nil ;case float64 :return _faebc +_dcfge ,nil ;};};return nil ,_f .Errorf ("\u0066\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0025\u0076\u0020\u0061\u006e\u0064\u0020\u0025\u0076",_egaaf ,_bbgb );
};func _eff (_dbf string ,_afcd _be .PdfObject ,_bbf *_gd .PdfPageResources )_be .PdfObjectName {_gfeg :=_ddf .TrimRightFunc (_ddf .TrimSpace (_dbf ),func (_adbe rune )bool {return _ab .IsNumber (_adbe )});if _gfeg ==""{_gfeg ="\u0046\u006f\u006e\u0074";
};_bdb :=0;_gdbc :=_be .PdfObjectName (_dbf );for {_eaf ,_ccf :=_bbf .GetFontByName (_gdbc );if !_ccf ||_eaf ==_afcd {break ;};_bdb ++;_gdbc =_be .PdfObjectName (_f .Sprintf ("\u0025\u0073\u0025\u0064",_gfeg ,_bdb ));};return _gdbc ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_dced *Creator )MoveTo (x ,y float64 ){_dced ._ecfb .X =x ;_dced ._ecfb .Y =y };

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_fbbcg *Creator )DrawTemplate (r _cb .Reader ,data interface{},options *TemplateOptions )error {return _bgca (_fbbcg ,r ,data ,options ,_fbbcg );};

// NewColumn returns a new column for the line items invoice table.
func (_fbca *Invoice )NewColumn (description string )*InvoiceCell {return _fbca .newColumn (description ,CellHorizontalAlignmentLeft );};func (_fcfcb *templateProcessor )parseTextChunk (_bfac *templateNode ,_ffcecc *TextChunk )(interface{},error ){if _bfac ._ddbbd ==nil {_fcfcb .nodeLogError (_bfac ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_eeeee ;};var (_bdfbd =_fcfcb .creator .NewTextStyle ();_gdcge bool ;);for _ ,_fgga :=range _bfac ._eccfd .Attr {if _fgga .Name .Local =="\u006c\u0069\u006e\u006b"{_dfff ,_ccfcb :=_bfac ._ddbbd ._fdfd .(*StyledParagraph );if !_ccfcb {_fcfcb .nodeLogError (_bfac ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_gdcge =true ;}else {_bdfbd =_dfff ._debd ;};break ;};};if _ffcecc ==nil {_ffcecc =NewTextChunk ("",_bdfbd );};for _ ,_ecgbc :=range _bfac ._eccfd .Attr {_dfbae :=_ecgbc .Value ;switch _dedaa :=_ecgbc .Name .Local ;_dedaa {case "\u0063\u006f\u006co\u0072":_ffcecc .Style .Color =_fcfcb .parseColorAttr (_dedaa ,_dfbae );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_ffcecc .Style .OutlineColor =_fcfcb .parseColorAttr (_dedaa ,_dfbae );case "\u0066\u006f\u006e\u0074":_ffcecc .Style .Font =_fcfcb .parseFontAttr (_dedaa ,_dfbae );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_ffcecc .Style .FontSize =_fcfcb .parseFloatAttr (_dedaa ,_dfbae );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_ffcecc .Style .OutlineSize =_fcfcb .parseFloatAttr (_dedaa ,_dfbae );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_ffcecc .Style .CharSpacing =_fcfcb .parseFloatAttr (_dedaa ,_dfbae );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_ffcecc .Style .HorizontalScaling =_fcfcb .parseFloatAttr (_dedaa ,_dfbae );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_ffcecc .Style .RenderingMode =_fcfcb .parseTextRenderingModeAttr (_dedaa ,_dfbae );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_ffcecc .Style .Underline =_fcfcb .parseBoolAttr (_dedaa ,_dfbae );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_ffcecc .Style .UnderlineStyle .Color =_fcfcb .parseColorAttr (_dedaa ,_dfbae );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_ffcecc .Style .UnderlineStyle .Offset =_fcfcb .parseFloatAttr (_dedaa ,_dfbae );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_ffcecc .Style .UnderlineStyle .Thickness =_fcfcb .parseFloatAttr (_dedaa ,_dfbae );
case "\u006c\u0069\u006e\u006b":if !_gdcge {_ffcecc .AddAnnotation (_fcfcb .parseLinkAttr (_dedaa ,_dfbae ));};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_ffcecc .Style .TextRise =_fcfcb .parseFloatAttr (_dedaa ,_dfbae );default:_fcfcb .nodeLogDebug (_bfac ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_dedaa );
};};return _ffcecc ,nil ;};func _acbe (_eeaa ,_becgf ,_eeead ,_gfce float64 )*Rectangle {return &Rectangle {_fdeb :_eeaa ,_fefcd :_becgf ,_dacdg :_eeead ,_ddccd :_gfce ,_dbdf :PositionAbsolute ,_aadb :1.0,_aagf :ColorBlack ,_bcdgg :1.0,_ggge :1.0};};func (_abfgb *Rectangle )applyFitMode (_gdgcd float64 ){_gdgcd -=_abfgb ._ddfgb .Left +_abfgb ._ddfgb .Right +_abfgb ._bcdgg ;
switch _abfgb ._dfgc {case FitModeFillWidth :_abfgb .ScaleToWidth (_gdgcd );};};

// SetMarkedContentID sets the marked content id for the line.
func (_dabg *Line )SetMarkedContentID (mcid int64 )*_gd .KDict {_dabg ._afac =&mcid ;_efdf :=_gd .NewKDictionary ();_efdf .S =_be .MakeName (_gd .StructureTypeFigure );_efdf .K =_be .MakeInteger (mcid );return _efdf ;};

// Height returns the height of the line.
func (_cebadd *Line )Height ()float64 {_cffa :=_cebadd ._adcb ;if _cebadd ._cbagd ==_cebadd ._agbba {_cffa /=2;};return _ff .Abs (_cebadd ._dcga -_cebadd ._efeb )+_cffa ;};func (_bdccd *shading )generatePdfFunctions ()[]_gd .PdfFunction {if len (_bdccd ._agcac )==0{return nil ;
}else if len (_bdccd ._agcac )<=2{_egfgb ,_gfdf ,_bgbf :=_bdccd ._agcac [0]._ccfgb .ToRGB ();_ccdd ,_bgfdg ,_cecb :=_bdccd ._agcac [len (_bdccd ._agcac )-1]._ccfgb .ToRGB ();return []_gd .PdfFunction {&_gd .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_egfgb ,_gfdf ,_bgbf },C1 :[]float64 {_ccdd ,_bgfdg ,_cecb }}};
}else {_ffcec :=[]_gd .PdfFunction {};_dgcf :=[]float64 {};for _ggfagf :=0;_ggfagf < len (_bdccd ._agcac )-1;_ggfagf ++{_fbcg ,_fcaab ,_bbeg :=_bdccd ._agcac [_ggfagf ]._ccfgb .ToRGB ();_egead ,_gbda ,_dgaefg :=_bdccd ._agcac [_ggfagf +1]._ccfgb .ToRGB ();
_cgbb :=&_gd .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_fbcg ,_fcaab ,_bbeg },C1 :[]float64 {_egead ,_gbda ,_dgaefg }};_ffcec =append (_ffcec ,_cgbb );if _ggfagf > 0{_dgcf =append (_dgcf ,_bdccd ._agcac [_ggfagf ]._aeeb );
};};_adff :=[]float64 {};for range _ffcec {_adff =append (_adff ,[]float64 {0.0,1.0}...);};return []_gd .PdfFunction {&_gd .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_ffcec ,Bounds :_dgcf ,Encode :_adff }};
};};func _bgaf (_bdada []*ColorPoint )*LinearShading {return &LinearShading {_faee :&shading {_bbdfc :ColorWhite ,_fdda :false ,_gecd :[]bool {false ,false },_agcac :_bdada },_ddfb :&_gd .PdfRectangle {}};};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_dbd *Creator )Draw (d Drawable )error {if _dbd .getActivePage ()==nil {_dbd .NewPage ();};_bfbg ,_gbf ,_eabg :=d .GeneratePageBlocks (_dbd ._ecfb );if _eabg !=nil {return _eabg ;};if len (_gbf ._ebbc )> 0{_dbd .Errors =append (_dbd .Errors ,_gbf ._ebbc ...);
};for _bgfg ,_aced :=range _bfbg {if _bgfg > 0{_dbd .NewPage ();};_adf :=_dbd .getActivePage ();if _cbec ,_becd :=_dbd ._fafg [_adf ];_becd {if _fcfc :=_cbec .mergeBlocks (_aced );_fcfc !=nil {return _fcfc ;};if _edf :=_adcc (_aced ._fa ,_cbec ._fa );_edf !=nil {return _edf ;
};}else {_dbd ._fafg [_adf ]=_aced ;};};_dbd ._ecfb .X =_gbf .X ;_dbd ._ecfb .Y =_gbf .Y ;_dbd ._ecfb .Height =_gbf .PageHeight -_gbf .Y -_gbf .Margins .Bottom ;return nil ;};

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_gdab *Ellipse )GetCoords ()(float64 ,float64 ){return _gdab ._dbeb ,_gdab ._caaf };func _gdbcg (_gfgb _dd .Image )(*Image ,error ){_geed ,_fdab :=_gd .ImageHandling .NewImageFromGoImage (_gfgb );if _fdab !=nil {return nil ,_fdab ;};return _bddd (_geed );
};