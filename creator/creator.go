//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
package creator ;import (_ab "bytes";_g "encoding/xml";_ac "errors";_a "fmt";_ebd "github.com/gorilla/i18n/linebreak";_ef "github.com/unidoc/unichart/render";_da "github.com/unidoc/unipdf/v3/common";_ee "github.com/unidoc/unipdf/v3/contentstream";_ebc "github.com/unidoc/unipdf/v3/contentstream/draw";
_bdg "github.com/unidoc/unipdf/v3/core";_fc "github.com/unidoc/unipdf/v3/internal/graphic2d/svg";_de "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_daf "github.com/unidoc/unipdf/v3/internal/license";_df "github.com/unidoc/unipdf/v3/internal/precision";
_gc "github.com/unidoc/unipdf/v3/internal/transform";_bdd "github.com/unidoc/unipdf/v3/model";_ccd "golang.org/x/text/unicode/bidi";_b "image";_ebf "io";_cc "log";_bd "math";_ccf "os";_db "path/filepath";_ca "regexp";_e "sort";_eb "strconv";_fa "strings";
_d "text/template";_bg "unicode";_f "unicode/utf8";);

// WriteToFile writes the Creator output to file specified by path.
func (_aaeg *Creator )WriteToFile (outputPath string )error {_fbaf ,_efga :=_ccf .Create (outputPath );if _efga !=nil {return _efga ;};defer _fbaf .Close ();return _aaeg .Write (_fbaf );};

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_ccga *Paragraph )SetColor (col Color ){_ccga ._eabe =col };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_bcgg *TOC )SetHeading (text string ,style TextStyle ){_fbdb :=_bcgg .Heading ();_fbdb .Reset ();_gagba :=_fbdb .Append (text );_gagba .Style =style ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_fbd *Creator )DrawHeader (drawHeaderFunc func (_gcdb *Block ,_fbeg HeaderFunctionArgs )){_fbd ._cfe =drawHeaderFunc ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_bcdc *Chapter )NewSubchapter (title string )*Chapter {_ebbe :=_cdcbe (_bcdc ._ccbe ._gfac );_ebbe .FontSize =14;_bcdc ._bcee ++;_gega :=_edbb (_bcdc ,_bcdc ._fefe ,_bcdc ._effb ,title ,_bcdc ._bcee ,_ebbe );_bcdc .Add (_gega );return _gega ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_bgbdg *LinearShading )ToPdfShadingPattern ()*_bdd .PdfShadingPatternType2 {_fgfca ,_abcc ,_gbfad :=_bgbdg ._bdbcd ._ddec .ToRGB ();_acba :=_bgbdg .shadingModel ();_acba .PdfShading .Background =_bdg .MakeArrayFromFloats ([]float64 {_fgfca ,_abcc ,_gbfad });
_ggdg :=_bdd .NewPdfShadingPatternType2 ();_ggdg .Shading =_acba ;return _ggdg ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_bfdda *RadialShading )SetAntiAlias (enable bool ){_bfdda ._eddc .SetAntiAlias (enable )};

// NewImageFromData creates an Image from image data.
func (_fdbc *Creator )NewImageFromData (data []byte )(*Image ,error ){return _aebc (data )};

// SetMargins sets the Paragraph's margins.
func (_cfea *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_cfea ._cgfa .Left =left ;_cfea ._cgfa .Right =right ;_cfea ._cgfa .Top =top ;_cfea ._cgfa .Bottom =bottom ;};

// SetFillOpacity sets the fill opacity.
func (_dbcf *PolyBezierCurve )SetFillOpacity (opacity float64 ){_dbcf ._efef =opacity };func (_bfgcg *TextChunk )Highlight (color Color ,alpha float64 )*_bdd .PdfAnnotation {_edcgd ,_aacf ,_bbdab :=color .ToRGB ();_bfefcf :=_bdd .NewPdfAnnotationHighlight ();
_bfefcf .C =_bdg .MakeArrayFromFloats ([]float64 {_edcgd ,_aacf ,_bbdab });_bfefcf .CA =_bdg .MakeFloat (alpha );_bfgcg .AddAnnotation (_bfefcf .PdfAnnotation );return _bfefcf .PdfAnnotation ;};func _gdga (_bbac ,_gcgd ,_feee ,_cccf float64 )*Ellipse {return &Ellipse {_afdf :_bbac ,_dgade :_gcgd ,_bfddf :_feee ,_cce :_cccf ,_fgac :PositionAbsolute ,_fgbc :1.0,_dage :ColorBlack ,_bffg :1.0,_ffaeg :1.0};
};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0);
);func (_gbd *Block )transform (_aeab _gc .Matrix ){_acg :=_ee .NewContentCreator ().Add_cm (_aeab [0],_aeab [1],_aeab [3],_aeab [4],_aeab [6],_aeab [7]).Operations ();*_gbd ._ae =append (*_acg ,*_gbd ._ae ...);_gbd ._ae .WrapIfNeeded ();};

// Width returns the width of the graphic svg.
func (_ecgb *GraphicSVG )Width ()float64 {return _ecgb ._bac .Width };func _fbgfg (_bebdd *Block ,_bdabb *Paragraph ,_gddde DrawContext )(DrawContext ,error ){_bdaab :=1;_cfbeg :=_bdg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_eb .Itoa (_bdaab ));for _bebdd ._fb .HasFontByName (_cfbeg ){_bdaab ++;
_cfbeg =_bdg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_eb .Itoa (_bdaab ));};_ccdcc :=_bebdd ._fb .SetFontByName (_cfbeg ,_bdabb ._gfac .ToPdfObject ());if _ccdcc !=nil {return _gddde ,_ccdcc ;};_bdabb .wrapText ();_fbeaf :=_ee .NewContentCreator ();
_fbeaf .Add_q ();_ccec :=_gddde .PageHeight -_gddde .Y -_bdabb ._ccdc *_bdabb ._gfaa ;_fbeaf .Translate (_gddde .X ,_ccec );if _bdabb ._gfaae !=0{_fbeaf .RotateDeg (_bdabb ._gfaae );};_eeec :=_ddfd (_bdabb ._eabe );_ccdcc =_fcgdf (_bebdd ,_eeec ,_bdabb ._eabe ,func ()Rectangle {return Rectangle {_cbcfa :_gddde .X ,_ffdf :_ccec ,_efdd :_bdabb .getMaxLineWidth ()/1000.0,_bbae :_bdabb .Height ()};
});if _ccdcc !=nil {return _gddde ,_ccdcc ;};_fbeaf .Add_BT ();_cbgc :=map[string ]_bdg .PdfObject {};if _bdabb ._defae !=nil {_cbgc ["\u004d\u0043\u0049\u0044"]=_bdg .MakeInteger (*_bdabb ._defae );};if _bdabb ._cdedda !=""{_cbgc ["\u004c\u0061\u006e\u0067"]=_bdg .MakeString (_bdabb ._cdedda );
};if len (_cbgc )> 0{_fbeaf .Add_BDC (*_bdg .MakeName (_bdd .StructureTypeParagraph ),_cbgc );};_fbeaf .SetNonStrokingColor (_eeec ).Add_Tf (_cfbeg ,_bdabb ._ccdc ).Add_TL (_bdabb ._ccdc *_bdabb ._gfaa );for _gbcda ,_aadd :=range _bdabb ._fcffe {if _gbcda !=0{_fbeaf .Add_Tstar ();
};_fabcg :=[]rune (_aadd );_efeb :=0.0;_bfeaf :=0;for _agcf ,_daca :=range _fabcg {if _daca ==' '{_bfeaf ++;continue ;};if _daca =='\u000A'{continue ;};_cace ,_bagb :=_bdabb ._gfac .GetRuneMetrics (_daca );if !_bagb {_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_agcf ,_daca ,_daca ,_bdabb ._gfac .BaseFont (),_bdabb ._gfac .Subtype ());
return _gddde ,_ac .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_efeb +=_bdabb ._ccdc *_cace .Wx ;};var _aff []_bdg .PdfObject ;_fbee ,_cedd :=_bdabb ._gfac .GetRuneMetrics (' ');
if !_cedd {return _gddde ,_ac .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_eggg :=_fbee .Wx ;switch _bdabb ._dgcd {case TextAlignmentJustify :if _bfeaf > 0&&_gbcda < len (_bdabb ._fcffe )-1{_eggg =(_bdabb ._bbag *1000.0-_efeb )/float64 (_bfeaf )/_bdabb ._ccdc ;
};case TextAlignmentCenter :_dbgdb :=_efeb +float64 (_bfeaf )*_eggg *_bdabb ._ccdc ;_fagb :=(_bdabb ._bbag *1000.0-_dbgdb )/2/_bdabb ._ccdc ;_aff =append (_aff ,_bdg .MakeFloat (-_fagb ));case TextAlignmentRight :_gcdcb :=_efeb +float64 (_bfeaf )*_eggg *_bdabb ._ccdc ;
_febd :=(_bdabb ._bbag *1000.0-_gcdcb )/_bdabb ._ccdc ;_aff =append (_aff ,_bdg .MakeFloat (-_febd ));};_gbddd :=_bdabb ._gfac .Encoder ();var _bede []byte ;for _ ,_adcfg :=range _fabcg {if _adcfg =='\u000A'{continue ;};if _adcfg ==' '{if len (_bede )> 0{_aff =append (_aff ,_bdg .MakeStringFromBytes (_bede ));
_bede =nil ;};_aff =append (_aff ,_bdg .MakeFloat (-_eggg ));}else {if _ ,_aagb :=_gbddd .RuneToCharcode (_adcfg );!_aagb {_ccdcc =UnsupportedRuneError {Message :_a .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_adcfg ,_adcfg ),Rune :_adcfg };
_gddde ._aaegd =append (_gddde ._aaegd ,_ccdcc );_da .Log .Debug (_ccdcc .Error ());if _gddde ._fdee <=0{continue ;};_adcfg =_gddde ._fdee ;};_bede =append (_bede ,_gbddd .Encode (string (_adcfg ))...);};};if len (_bede )> 0{_aff =append (_aff ,_bdg .MakeStringFromBytes (_bede ));
};_fbeaf .Add_TJ (_aff ...);};if len (_cbgc )> 0{_fbeaf .Add_EMC ();};_fbeaf .Add_ET ();_fbeaf .Add_Q ();_edabf :=_fbeaf .Operations ();_edabf .WrapIfNeeded ();_bebdd .addContents (_edabf );if _bdabb ._abcfeg .IsRelative (){_gcagf :=_bdabb .Height ();_gddde .Y +=_gcagf ;
_gddde .Height -=_gcagf ;if _gddde .Inline {_gddde .X +=_bdabb .Width ()+_bdabb ._defec .Right ;};};return _gddde ,nil ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// Width returns the width of the Paragraph.
func (_ccbf *StyledParagraph )Width ()float64 {if _ccbf ._bcdbe &&int (_ccbf ._fcdc )> 0{return _ccbf ._fcdc ;};return _ccbf .getTextWidth ()/1000.0;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_agbf *Invoice )Notes ()(string ,string ){return _agbf ._eabd [0],_agbf ._eabd [1]};

// Inline returns whether the inline mode of the division is active.
func (_bcgd *Division )Inline ()bool {return _bcgd ._gcag };func (_dc *Block )SetMarkedContentID (id int64 )*_bdd .KDict {return nil };const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;AnchorTopLeft ;AnchorTopRight ;AnchorCenter ;AnchorLeft ;
AnchorRight ;AnchorTop ;AnchorBottom ;);func (_acbb *templateProcessor )parseTable (_ebccf *templateNode )(interface{},error ){var _eeffc int64 ;for _ ,_afdgc :=range _ebccf ._edag .Attr {_cddcee :=_afdgc .Value ;switch _caeag :=_afdgc .Name .Local ;_caeag {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_eeffc =_acbb .parseInt64Attr (_caeag ,_cddcee );
};};if _eeffc <=0{_acbb .nodeLogDebug (_ebccf ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_eeffc );
_eeffc =1;};_bbgbc :=_acbb .creator .NewTable (int (_eeffc ));for _ ,_cdabf :=range _ebccf ._edag .Attr {_eaaa :=_cdabf .Value ;switch _defea :=_cdabf .Name .Local ;_defea {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_bbgbc .SetColumnWidths (_acbb .parseFloatArray (_defea ,_eaaa )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_ebgcddd :=_acbb .parseMarginAttr (_defea ,_eaaa );_bbgbc .SetMargins (_ebgcddd .Left ,_ebgcddd .Right ,_ebgcddd .Top ,_ebgcddd .Bottom );case "\u0078":_bbgbc .SetPos (_acbb .parseFloatAttr (_defea ,_eaaa ),_bbgbc ._bcab );
case "\u0079":_bbgbc .SetPos (_bbgbc ._fcbca ,_acbb .parseFloatAttr (_defea ,_eaaa ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_bbgbc ._abeef =int (_acbb .parseInt64Attr (_defea ,_eaaa ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_bbgbc ._cdfg =int (_acbb .parseInt64Attr (_defea ,_eaaa ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_bbgbc .EnableRowWrap (_acbb .parseBoolAttr (_defea ,_eaaa ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_bbgbc .EnablePageWrap (_acbb .parseBoolAttr (_defea ,_eaaa ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_acbb .nodeLogDebug (_ebccf ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_defea );
};};if _bbgbc ._abeef !=0&&_bbgbc ._cdfg !=0{_geff :=_bbgbc .SetHeaderRows (_bbgbc ._abeef ,_bbgbc ._cdfg );if _geff !=nil {_acbb .nodeLogDebug (_ebccf ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_geff );
};}else {_bbgbc ._abeef =0;_bbgbc ._cdfg =0;};return _bbgbc ,nil ;};func (_gddf *templateProcessor )parseChapter (_ggad *templateNode )(interface{},error ){_bdc :=_gddf .creator .NewChapter ;if _ggad ._fcdcc !=nil {if _acfg ,_gcbcd :=_ggad ._fcdcc ._cdab .(*Chapter );
_gcbcd {_bdc =_acfg .NewSubchapter ;};};_gabee :=_bdc ("");for _ ,_fdeff :=range _ggad ._edag .Attr {_fbba :=_fdeff .Value ;switch _gebeb :=_fdeff .Name .Local ;_gebeb {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_gabee .SetShowNumbering (_gddf .parseBoolAttr (_gebeb ,_fbba ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_gabee .SetIncludeInTOC (_gddf .parseBoolAttr (_gebeb ,_fbba ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_eade :=_gddf .parseMarginAttr (_gebeb ,_fbba );_gabee .SetMargins (_eade .Left ,_eade .Right ,_eade .Top ,_eade .Bottom );
default:_gddf .nodeLogDebug (_ggad ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gebeb );
};};return _gabee ,nil ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;
);

// SetMarkedContentID sets marked content ID.
func (_decgf *CurvePolygon )SetMarkedContentID (mcid int64 )*_bdd .KDict {_decgf ._eefe =&mcid ;_efgb :=_bdd .NewKDictionary ();_efgb .S =_bdg .MakeName (_bdd .StructureTypeFigure );_efgb .K =_bdg .MakeInteger (mcid );return _efgb ;};func _gcdc (_gccg VectorDrawable ,_gcbg float64 )float64 {switch _ddad :=_gccg .(type ){case *Paragraph :if _ddad ._ceaa {_ddad .SetWidth (_gcbg -_ddad ._defec .Left -_ddad ._defec .Right );
};return _ddad .Height ()+_ddad ._defec .Top +_ddad ._defec .Bottom +(0.5*_ddad ._ccdc *_ddad ._gfaa );case *StyledParagraph :if _ddad ._bcdbe {_ddad .SetWidth (_gcbg -_ddad ._cgfa .Left -_ddad ._cgfa .Right );};return _ddad .Height ()+_ddad ._cgfa .Top +_ddad ._cgfa .Bottom +(0.5*_ddad .getTextHeight ());
case *Image :_ddad .applyFitMode (_gcbg );return _ddad .Height ()+_ddad ._aedc .Top +_ddad ._aedc .Bottom ;case *Rectangle :_ddad .applyFitMode (_gcbg );return _ddad .Height ()+_ddad ._abae .Top +_ddad ._abae .Bottom +_ddad ._agad ;case *Ellipse :_ddad .applyFitMode (_gcbg );
return _ddad .Height ()+_ddad ._gcbd .Top +_ddad ._gcbd .Bottom ;case *Division :return _ddad .ctxHeight (_gcbg )+_ddad ._egba .Top +_ddad ._egba .Bottom +_ddad ._gcfg .Top +_ddad ._gcfg .Bottom ;case *Table :_ddad .updateRowHeights (_gcbg -_ddad ._geefd .Left -_ddad ._geefd .Right );
return _ddad .Height ()+_ddad ._geefd .Top +_ddad ._geefd .Bottom ;case *List :return _ddad .ctxHeight (_gcbg )+_ddad ._eaag .Top +_ddad ._eaag .Bottom ;case marginDrawable :_ ,_ ,_aeba ,_fedg :=_ddad .GetMargins ();return _ddad .Height ()+_aeba +_fedg ;
default:return _ddad .Height ();};};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_bfag *Creator )SetPageLabels (pageLabels _bdg .PdfObject ){_bfag ._febc =pageLabels };

// AppendCurve appends a Bezier curve to the filled curve.
func (_egdb *FilledCurve )AppendCurve (curve _ebc .CubicBezierCurve )*FilledCurve {_egdb ._bgecc =append (_egdb ._bgecc ,curve );return _egdb ;};

// Append adds a new text chunk to the paragraph.
func (_fafb *StyledParagraph )Append (text string )*TextChunk {_cdga :=NewTextChunk (text ,_fafb ._bgge );return _fafb .appendChunk (_cdga );};func (_bebad *Invoice )generateNoteBlocks (_eeacf DrawContext )([]*Block ,DrawContext ,error ){_fbgc :=_dccb ();
_dgfb :=append ([][2]string {_bebad ._eabd ,_bebad ._ggbee },_bebad ._gbac ...);for _ ,_bfbf :=range _dgfb {if _bfbf [1]!=""{_fgacf :=_bebad .drawSection (_bfbf [0],_bfbf [1]);for _ ,_bggcb :=range _fgacf {_fbgc .Add (_bggcb );};_ffeb :=_accf (_bebad ._fcaa );
_ffeb .SetMargins (0,0,10,0);_fbgc .Add (_ffeb );};};return _fbgc .GeneratePageBlocks (_eeacf );};

// SetBorderColor sets the cell's border color.
func (_aac *TableCell )SetBorderColor (col Color ){_aac ._dbbbd =col ;_aac ._gccfc =col ;_aac ._fedcf =col ;_aac ._bcga =col ;};

// SkipRows skips over a specified number of rows in the table.
func (_bagab *Table )SkipRows (num int ){_cfef :=num *_bagab ._ccdbbe -1;if _cfef < 0{_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _efed :=0;_efed < _cfef ;_efed ++{_bagab .NewCell ();};};

// Write output of creator to io.Writer interface.
func (_cfda *Creator )Write (ws _ebf .Writer )error {if _gddd :=_cfda .Finalize ();_gddd !=nil {return _gddd ;};_fdaf :="";if _eebd ,_dcge :=ws .(*_ccf .File );_dcge {_fdaf =_eebd .Name ();};_cedg :=_bdd .NewPdfWriter ();_cedg .SetOptimizer (_cfda ._becg );
_cedg .SetFileName (_fdaf );if _cfda ._cbd !=nil {_bbdb :=_cedg .SetForms (_cfda ._cbd );if _bbdb !=nil {_da .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bbdb );return _bbdb ;};};if _cfda ._fdbf !=nil {_cedg .AddOutlineTree (_cfda ._fdbf );
}else if _cfda ._bgce !=nil &&_cfda .AddOutlines {_cedg .AddOutlineTree (&_cfda ._bgce .ToPdfOutline ().PdfOutlineTreeNode );};if _cfda ._febc !=nil {if _aeea :=_cedg .SetPageLabels (_cfda ._febc );_aeea !=nil {_da .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_aeea );
return _aeea ;};};if _cfda ._ffa !=nil {for _ ,_abbca :=range _cfda ._ffa {_fafc :=_abbca .SubsetRegistered ();if _fafc !=nil {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_fafc );
return _fafc ;};};};if _cfda ._daad !=nil {_gafc :=_cfda ._daad (&_cedg );if _gafc !=nil {_da .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_gafc );return _gafc ;};};for _efeeb ,_decb :=range _cfda ._bcdf {_efgd :=_cedg .AddPage (_decb );
if _efgd !=nil {_da .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_efgd );return _efgd ;};if _cfda ._agfd !=nil {_cddf :=_cfda ._agfd .K ;_cabgc ,_egff :=_cedg .GetPageIndirectObject (_efeeb );
if _egff !=nil {_da .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0043\u006fu\u006c\u0064\u0020n\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061ge\u0020\u0069\u006ed\u0069\u0072e\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074 \u0025\u0076",_egff );
};var _fadfa func (_eacb *_bdd .KDict );_fadfa =func (_ebbd *_bdd .KDict ){if _ebbd ==nil {return ;};if _ebbd .GetPageNumber ()-1==int64 (_efeeb ){_ebbd .SetPage (_cabgc );};for _ ,_cbcda :=range _ebbd .GetChildren (){if _edbeg :=_cbcda .GetKDict ();_edbeg !=nil {_fadfa (_edbeg );
};};};for _ ,_cfdc :=range _cddf {_fadfa (_cfdc );};};};if _cfda ._agfd !=nil {if _baf :=_cedg .SetCatalogStructTreeRoot (_cfda ._agfd .ToPdfObject ());_baf !=nil {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020n\u006f\u0074\u0020\u0073\u0065\u0074 \u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065\u0065\u0052\u006f\u006ft\u003a\u0020\u0025\u0076",_baf );
return _baf ;};};if _cfda ._afbe !=nil {if _gecfc :=_cedg .SetCatalogViewerPreferences (_cfda ._afbe .ToPdfObject ());_gecfc !=nil {_da .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065\u0074\u0020\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073\u003a\u0020\u0025\u0076",_gecfc );
return _gecfc ;};};if _cfda ._faeb !=""{if _gecd :=_cedg .SetCatalogLanguage (_bdg .MakeString (_cfda ._faeb ));_gecd !=nil {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065t\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u006c\u0061\u006e\u0067\u0075\u0061\u0067\u0065\u003a\u0020\u0025\u0076",_gecd );
return _gecd ;};};_cedc :=_cedg .Write (ws );if _cedc !=nil {return _cedc ;};return nil ;};

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_fggg *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fggg ._ggfgf .Left ,_fggg ._ggfgf .Right ,_fggg ._ggfgf .Top ,_fggg ._ggfgf .Bottom ;};

// Indent returns the left offset of the list when nested into another list.
func (_aebcb *List )Indent ()float64 {return _aebcb ._ccgdf };func _efdgf (_cegae ,_dgfbe ,_acffd TextChunk ,_edegg uint ,_fedfd TextStyle )*TOCLine {_abfaf :=_accf (_fedfd );_abfaf .SetEnableWrap (true );_abfaf .SetTextAlignment (TextAlignmentLeft );_abfaf .SetMargins (0,0,2,2);
_fgbb :=&TOCLine {_cgcbd :_abfaf ,Number :_cegae ,Title :_dgfbe ,Page :_acffd ,Separator :TextChunk {Text :"\u002e",Style :_fedfd },_afgca :0,_edcf :_edegg ,_cdbd :10,_fcge :PositionRelative };_abfaf ._cgfa .Left =_fgbb ._afgca +float64 (_fgbb ._edcf -1)*_fgbb ._cdbd ;
_abfaf ._dbab =_fgbb .prepareParagraph ;return _fgbb ;};

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_bcff float64 ;_cagcf float64 ;_cbdf float64 ;_begf float64 ;_ceecf Color ;_cbeb _ebc .LineStyle ;_ecga float64 ;_dacf []int64 ;_ggcc int64 ;_dedd float64 ;_bgad Positioning ;_ecfe FitMode ;_agbfd Margins ;_acfe *int64 ;};

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_afgcd *GraphicSVG )Scale (xFactor ,yFactor float64 ){_afgcd ._bac .Width =xFactor *_afgcd ._bac .Width ;_afgcd ._bac .Height =yFactor *_afgcd ._bac .Height ;_afgcd ._bac .SetScaling (xFactor ,yFactor );};func _cdbb (_fgcb *_bdd .Image )(*Image ,error ){_gece :=float64 (_fgcb .Width );
_fcff :=float64 (_fgcb .Height );return &Image {_cebb :_fgcb ,_adge :_gece ,_ceeac :_fcff ,_fgbd :_gece ,_eedg :_fcff ,_gdccb :0,_dcbbb :1.0,_edeb :PositionRelative },nil ;};

// SetColorRight sets border color for right.
func (_efee *border )SetColorRight (col Color ){_efee ._dag =col };

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_ceeg *Invoice )AddressStyle ()TextStyle {return _ceeg ._bdaa };

// Height returns the height of the ellipse.
func (_ggaf *Ellipse )Height ()float64 {return _ggaf ._cce };

// NewList creates a new list.
func (_fdff *Creator )NewList ()*List {return _geeea (_fdff .NewTextStyle ())};

// SetWidthRight sets border width for right.
func (_cff *border )SetWidthRight (bw float64 ){_cff ._gea =bw };

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_gcfddf *TOCLine )SetStyle (style TextStyle ){_gcfddf .Number .Style =style ;_gcfddf .Title .Style =style ;_gcfddf .Separator .Style =style ;_gcfddf .Page .Style =style ;};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };
PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// SetMarkedContentID sets the marked content ID for the text chunk.
func (_adfeee *TextChunk )SetMarkedContentID (mcid int64 )*_bdd .KDict {_adfeee ._eeebc =&mcid ;_cdedea :=_bdd .NewKDictionary ();_cdedea .S =_bdg .MakeName ("\u0053\u0070\u0061\u006e");_cdedea .K =_bdg .MakeInteger (mcid );return _cdedea ;};

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_gbdga *Rectangle )Width ()float64 {return _gbdga ._efdd };

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_fdc *Chapter )SetIncludeInTOC (includeInTOC bool ){_fdc ._gdag =includeInTOC };func _dabgg (_baea *templateProcessor ,_dbfg *templateNode )(interface{},error ){return _baea .parseTableCell (_dbfg );};func _bbgaa (_bgdeb []*_bdd .PdfAnnotation )[]*_bdd .PdfAnnotation {var _afcc []*_bdd .PdfAnnotation ;
for _ ,_dffcd :=range _bgdeb {_afcc =append (_afcc ,_bgeca (_dffcd ));};return _afcc ;};

// SetLineColor sets the line color.
func (_bdac *Polyline )SetLineColor (color Color ){_bdac ._cddce .LineColor =_ddfd (color )};

// SetWidth sets the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_gbdb *Paragraph )SetWidth (width float64 ){_gbdb ._bbag =width ;_gbdb .wrapText ()};

// SetAngle sets the rotation angle of the text.
func (_ebad *Paragraph )SetAngle (angle float64 ){_ebad ._gfaae =angle };

// NewPolyline creates a new polyline.
func (_dafdf *Creator )NewPolyline (points []_ebc .Point )*Polyline {return _edgb (points )};

// Length calculates and returns the length of the line.
func (_fdad *Line )Length ()float64 {return _bd .Sqrt (_bd .Pow (_fdad ._cbdf -_fdad ._bcff ,2.0)+_bd .Pow (_fdad ._begf -_fdad ._cagcf ,2.0));};

// SetSideBorderWidth sets the cell's side border width.
func (_bbbe *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_bbbe ._cdgea =width ;_bbbe ._fedgc =width ;_bbbe ._bgfd =width ;_bbbe ._ebcc =width ;case CellBorderSideTop :_bbbe ._cdgea =width ;case CellBorderSideBottom :_bbbe ._fedgc =width ;
case CellBorderSideLeft :_bbbe ._bgfd =width ;case CellBorderSideRight :_bbbe ._ebcc =width ;};};

// BorderWidth returns the border width of the ellipse.
func (_fadfae *Ellipse )BorderWidth ()float64 {return _fadfae ._bffg };

// SetBorderOpacity sets the border opacity.
func (_efbf *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_efbf ._bgdga =opacity };

// NewPageBreak create a new page break.
func (_aagd *Creator )NewPageBreak ()*PageBreak {return _ffdbg ()};

// SetLineHeight sets the line height (1.0 default).
func (_cbce *Paragraph )SetLineHeight (lineheight float64 ){_cbce ._gfaa =lineheight };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_caeff *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cgfc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bfbcd ,_cced :=_cgfc .setOpacity (_caeff ._efef ,_caeff ._bgdga );if _cced !=nil {return nil ,ctx ,_cced ;
};_cbaff :=_caeff ._edaef ;_cbaff .FillEnabled =_cbaff .FillColor !=nil ;var (_geedd =ctx .PageHeight ;_ddgab =_cbaff .Curves ;_dgba =make ([]_ebc .CubicBezierCurve ,0,len (_cbaff .Curves )););_gcfe :=_bdd .PdfRectangle {};for _bfgd :=range _cbaff .Curves {_ccecd :=_ddgab [_bfgd ];
_ccecd .P0 .Y =_geedd -_ccecd .P0 .Y ;_ccecd .P1 .Y =_geedd -_ccecd .P1 .Y ;_ccecd .P2 .Y =_geedd -_ccecd .P2 .Y ;_ccecd .P3 .Y =_geedd -_ccecd .P3 .Y ;_dgba =append (_dgba ,_ccecd );_dcfab :=_ccecd .GetBounds ();if _bfgd ==0{_gcfe =_dcfab ;}else {_gcfe .Llx =_bd .Min (_gcfe .Llx ,_dcfab .Llx );
_gcfe .Lly =_bd .Min (_gcfe .Lly ,_dcfab .Lly );_gcfe .Urx =_bd .Max (_gcfe .Urx ,_dcfab .Urx );_gcfe .Ury =_bd .Max (_gcfe .Ury ,_dcfab .Ury );};};_cbaff .Curves =_dgba ;defer func (){_cbaff .Curves =_ddgab }();if _cbaff .FillEnabled {_caebf :=_fcgdf (_cgfc ,_caeff ._edaef .FillColor ,_caeff ._fabcgb ,func ()Rectangle {return Rectangle {_cbcfa :_gcfe .Llx ,_ffdf :_gcfe .Lly ,_efdd :_gcfe .Width (),_bbae :_gcfe .Height ()};
});if _caebf !=nil {return nil ,ctx ,_caebf ;};};_ebeeg ,_ ,_cced :=_cbaff .MarkedDraw (_bfbcd ,_caeff ._adfag );if _cced !=nil {return nil ,ctx ,_cced ;};if _cced =_cgfc .addContentsByString (string (_ebeeg ));_cced !=nil {return nil ,ctx ,_cced ;};return []*Block {_cgfc },ctx ,nil ;
};

// Angle returns the block rotation angle in degrees.
func (_af *Block )Angle ()float64 {return _af ._daa };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_egfc *Creator )SetForms (form *_bdd .PdfAcroForm )error {_egfc ._cbd =form ;return nil };

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_cdegb *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_ebga []*Block ;_eced bool ;_bdff error ;_cbfg =_cdegb ._gag .IsRelative ();_cfff =_cdegb ._egba .Top ;);if _cbfg &&!_cdegb ._gadg &&!_cdegb ._gcag {_fbb :=_cdegb .ctxHeight (ctx .Width );
if _fbb > ctx .Height -_cdegb ._egba .Top &&_fbb <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _ebga ,ctx ,_bdff =_ffdbg ().GeneratePageBlocks (ctx );_bdff !=nil {return nil ,ctx ,_bdff ;};_eced =true ;_cfff =0;};};_ffgc :=ctx ;_dde :=ctx ;
if _cbfg {ctx .X +=_cdegb ._egba .Left ;ctx .Y +=_cfff ;ctx .Width -=_cdegb ._egba .Left +_cdegb ._egba .Right ;ctx .Height -=_cfff ;_dde =ctx ;ctx .X +=_cdegb ._gcfg .Left ;ctx .Y +=_cdegb ._gcfg .Top ;ctx .Width -=_cdegb ._gcfg .Left +_cdegb ._gcfg .Right ;
ctx .Height -=_cdegb ._gcfg .Top ;ctx .Margins .Top +=_cdegb ._gcfg .Top ;ctx .Margins .Bottom +=_cdegb ._gcfg .Bottom ;ctx .Margins .Left +=_cdegb ._egba .Left +_cdegb ._gcfg .Left ;ctx .Margins .Right +=_cdegb ._egba .Right +_cdegb ._gcfg .Right ;};ctx .Inline =_cdegb ._gcag ;
_bfba :=ctx ;_eca :=ctx ;var _aaafc float64 ;for _ ,_cdcb :=range _cdegb ._gbfd {if ctx .Inline {if (ctx .X -_bfba .X )+_cdcb .Width ()<=ctx .Width {ctx .Y =_eca .Y ;ctx .Height =_eca .Height ;}else {ctx .X =_bfba .X ;ctx .Width =_bfba .Width ;_eca .Y +=_aaafc ;
_eca .Height -=_aaafc ;_aaafc =0;};};_cegg ,_egcd ,_gbfb :=_cdcb .GeneratePageBlocks (ctx );if _gbfb !=nil {_da .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_gbfb );
return nil ,ctx ,_gbfb ;};if len (_cegg )< 1{continue ;};if len (_ebga )> 0{_ebga [len (_ebga )-1].mergeBlocks (_cegg [0]);_ebga =append (_ebga ,_cegg [1:]...);}else {if _gbcd :=_cegg [0]._ae ;_gbcd ==nil ||len (*_gbcd )==0{_eced =true ;};_ebga =append (_ebga ,_cegg [0:]...);
};_eegg :=0.0;switch _cbge :=_cdcb .(type ){case *Paragraph :_eegg =(0.5*_cbge ._ccdc *_cbge ._gfaa );case *StyledParagraph :_eegg =(0.5*_cbge .getTextHeight ());};_egcd .Y +=_eegg ;_egcd .Height -=_eegg ;if ctx .Inline {if ctx .Page !=_egcd .Page {_bfba .Y =ctx .Margins .Top ;
_bfba .Height =ctx .PageHeight -ctx .Margins .Top ;_eca .Y =_bfba .Y ;_eca .Height =_bfba .Height ;_aaafc =_egcd .Height -_bfba .Height ;}else {if _dfdf :=ctx .Height -_egcd .Height ;_dfdf > _aaafc {_aaafc =_dfdf ;};};}else {_egcd .X =ctx .X ;};ctx =_egcd ;
};if len (_cdegb ._gbfd )==0{_bbgg :=NewBlock (ctx .Width ,0);_ebga =append (_ebga ,_bbgg );};ctx .Inline =_ffgc .Inline ;ctx .Margins =_ffgc .Margins ;if _cbfg {ctx .X =_ffgc .X ;ctx .Width =_ffgc .Width ;ctx .Y +=_cdegb ._gcfg .Bottom ;ctx .Height -=_cdegb ._gcfg .Bottom ;
};if _cdegb ._accgd !=nil {_ebga ,_bdff =_cdegb .drawBackground (_ebga ,_dde ,ctx ,_eced );if _bdff !=nil {return nil ,ctx ,_bdff ;};};if _cdegb ._gag .IsAbsolute (){return _ebga ,_ffgc ,nil ;};ctx .Y +=_cdegb ._egba .Bottom ;ctx .Height -=_cdegb ._egba .Bottom ;
return _ebga ,ctx ,nil ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_dggda *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dggda ._geefd .Left ,_dggda ._geefd .Right ,_dggda ._geefd .Top ,_dggda ._geefd .Bottom ;};

// SetTitle sets the title of the invoice.
func (_cceb *Invoice )SetTitle (title string ){_cceb ._cbgeg =title };

// SetFillColor sets the fill color of the rectangle.
func (_fbbg *Rectangle )SetFillColor (col Color ){_fbbg ._ddgb =col };

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_ccgcg *Invoice )NoteHeadingStyle ()TextStyle {return _ccgcg ._bddd };

// SetWidthTop sets border width for top.
func (_bcf *border )SetWidthTop (bw float64 ){_bcf ._fagd =bw };

// LevelOffset returns the amount of space an indentation level occupies.
func (_caae *TOCLine )LevelOffset ()float64 {return _caae ._cdbd };

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_gecdf *Table )MultiColCell (colspan int )*TableCell {return _gecdf .MultiCell (1,colspan )};

// Height returns Image's document height.
func (_dece *Image )Height ()float64 {return _dece ._eedg };

// SetPositioning sets the positioning of the line (absolute or relative).
func (_bgef *Line )SetPositioning (positioning Positioning ){_bgef ._bgad =positioning };

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_abcf :_bd .Max (_bd .Min (r ,1.0),0.0),_eae :_bd .Max (_bd .Min (g ,1.0),0.0),_gfg :_bd .Max (_bd .Min (b ,1.0),0.0)};};func (_dbbb *StyledParagraph )wrapWordChunks (){if !_dbbb ._cbbg {return ;
};var (_dbfb []*TextChunk ;_aafc *_bdd .PdfFont ;);for _ ,_cdce :=range _dbbb ._adebd {_gfae :=[]rune (_cdce .Text );if _aafc ==nil {_aafc =_cdce .Style .Font ;};_fcfcg :=_cdce ._gfgcff ;_ggbcg :=_cdce .VerticalAlignment ;if len (_dbfb )> 0{if len (_gfae )==1&&_bg .IsPunct (_gfae [0])&&_cdce .Style .Font ==_aafc {_feeca :=[]rune (_dbfb [len (_dbfb )-1].Text );
_dbfb [len (_dbfb )-1].Text =string (append (_feeca ,_gfae [0]));continue ;}else {_ ,_ddffg :=_eb .Atoi (_cdce .Text );if _ddffg ==nil {_ebgbb :=[]rune (_dbfb [len (_dbfb )-1].Text );_gccgc :=len (_ebgbb );if _gccgc >=2{_ ,_gfgg :=_eb .Atoi (string (_ebgbb [_gccgc -2]));
if _gfgg ==nil &&_bg .IsPunct (_ebgbb [_gccgc -1]){_dbfb [len (_dbfb )-1].Text =string (append (_ebgbb ,_gfae ...));continue ;};};};};};_bbff ,_bbggb :=_dfcaf (_cdce .Text );if _bbggb !=nil {_da .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_bbggb );
_bbff =[]string {_cdce .Text };};for _ ,_gbcc :=range _bbff {_bded :=NewTextChunk (_gbcc ,_cdce .Style );_bded ._gfgcff =_bbgaa (_fcfcg );_bded .VerticalAlignment =_ggbcg ;_dbfb =append (_dbfb ,_bded );};_aafc =_cdce .Style .Font ;};if len (_dbfb )> 0{_dbbb ._adebd =_dbfb ;
};};var PPMM =float64 (72*1.0/25.4);

// NewTOCLine creates a new table of contents line with the default style.
func (_fadg *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _gdcb (number ,title ,page ,level ,_fadg .NewTextStyle ());};func _gfga (_abbf *_bdd .PdfAnnotationLink )*_bdd .PdfAnnotationLink {if _abbf ==nil {return nil ;};
_fgeaf :=_bdd .NewPdfAnnotationLink ();_fgeaf .BS =_abbf .BS ;_fgeaf .A =_abbf .A ;if _geddgb ,_bbefa :=_abbf .GetAction ();_bbefa ==nil &&_geddgb !=nil {_fgeaf .SetAction (_geddgb );};if _affea ,_bfbd :=_abbf .Dest .(*_bdg .PdfObjectArray );_bfbd {_fgeaf .Dest =_bdg .MakeArray (_affea .Elements ()...);
};return _fgeaf ;};

// Logo returns the logo of the invoice.
func (_gggfb *Invoice )Logo ()*Image {return _gggfb ._ddac };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//
//	[number] [title]      [separator] [page]
//
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_aafbcf *StyledParagraph ;_cfecf []*TOCLine ;_caec TextStyle ;_cfad TextStyle ;_gdggf TextStyle ;_cdbed TextStyle ;_agdgdc string ;_faadb float64 ;_badg Margins ;_fbcdfa Positioning ;_fddgb TextStyle ;_egbac bool ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_gbef :_bd .Max (_bd .Min (c ,1.0),0.0),_gcg :_bd .Max (_bd .Min (m ,1.0),0.0),_gab :_bd .Max (_bd .Min (y ,1.0),0.0),_bgfg :_bd .Max (_bd .Min (k ,1.0),0.0)};};const (CellBorderStyleNone CellBorderStyle =iota ;
CellBorderStyleSingle ;CellBorderStyleDouble ;);

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_ggbf *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ggbf ._cgfa .Left ,_ggbf ._cgfa .Right ,_ggbf ._cgfa .Top ,_ggbf ._cgfa .Bottom ;};func _dcgea (_adcfd *Block ,_cgec *Image ,_beag DrawContext )(DrawContext ,error ){_fddf :=_beag ;
_feeg :=1;_gfcc :=_bdg .PdfObjectName (_a .Sprintf ("\u0049\u006d\u0067%\u0064",_feeg ));for _adcfd ._fb .HasXObjectByName (_gfcc ){_feeg ++;_gfcc =_bdg .PdfObjectName (_a .Sprintf ("\u0049\u006d\u0067%\u0064",_feeg ));};_dgbc :=_adcfd ._fb .SetXObjectImageByNameLazy (_gfcc ,_cgec ._gdddd ,_cgec ._egca );
if _dgbc !=nil {return _beag ,_dgbc ;};_acac :=0;_ebgc :=_bdg .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_acac ));for _adcfd ._fb .HasExtGState (_ebgc ){_acac ++;_ebgc =_bdg .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_acac ));
};_efaf :=_bdg .MakeDict ();_efaf .Set ("\u0042\u004d",_bdg .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _cgec ._dcbbb < 1.0{_efaf .Set ("\u0043\u0041",_bdg .MakeFloat (_cgec ._dcbbb ));_efaf .Set ("\u0063\u0061",_bdg .MakeFloat (_cgec ._dcbbb ));
};_dgbc =_adcfd ._fb .AddExtGState (_ebgc ,_bdg .MakeIndirectObject (_efaf ));if _dgbc !=nil {return _beag ,_dgbc ;};_adbb :=_cgec .Width ();_fbcc :=_cgec .Height ();_ ,_fdage :=_cgec .rotatedSize ();_abg :=_beag .X ;_abaf :=_beag .PageHeight -_beag .Y -_fbcc ;
if _cgec ._edeb .IsRelative (){_abaf -=(_fdage -_fbcc )/2;switch _cgec ._cafee {case HorizontalAlignmentCenter :_abg +=(_beag .Width -_adbb )/2;case HorizontalAlignmentRight :_abg =_beag .PageWidth -_beag .Margins .Right -_cgec ._aedc .Right -_adbb ;};
};_aeef :=_cgec ._gdccb ;_cagff :=_ee .NewContentCreator ();if _cgec ._bebfb !=nil {_cagff .Add_BDC (*_bdg .MakeName (_bdd .StructureTypeFigure ),map[string ]_bdg .PdfObject {"\u004d\u0043\u0049\u0044":_bdg .MakeInteger (*_cgec ._bebfb )});};_cagff .Add_gs (_ebgc );
_cagff .Translate (_abg ,_abaf );if _aeef !=0{_cagff .Translate (_adbb /2,_fbcc /2);_cagff .RotateDeg (_aeef );_cagff .Translate (-_adbb /2,-_fbcc /2);};_cagff .Scale (_adbb ,_fbcc ).Add_Do (_gfcc );if _cgec ._bebfb !=nil {_cagff .Add_EMC ();};_decfc :=_cagff .Operations ();
_decfc .WrapIfNeeded ();_adcfd .addContents (_decfc );if _cgec ._edeb .IsRelative (){_beag .Y +=_fdage ;_beag .Height -=_fdage ;return _beag ,nil ;};return _fddf ,nil ;};

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_bfge *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _ecebf (x ,y ,innerRadius ,outerRadius ,colorPoints );};

// SetTitleStyle sets the style properties of the invoice title.
func (_abgd *Invoice )SetTitleStyle (style TextStyle ){_abgd ._ggceg =style };func (_gaee *templateProcessor )parseStyledParagraph (_bcbbg *templateNode )(interface{},error ){_ccgdfd :=_gaee .creator .NewStyledParagraph ();for _ ,_beeac :=range _bcbbg ._edag .Attr {_adgf :=_beeac .Value ;
switch _dcfaa :=_beeac .Name .Local ;_dcfaa {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_ccgdfd .SetTextAlignment (_gaee .parseTextAlignmentAttr (_dcfaa ,_adgf ));case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_ccgdfd .SetTextVerticalAlignment (_gaee .parseTextVerticalAlignmentAttr (_dcfaa ,_adgf ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_ccgdfd .SetLineHeight (_gaee .parseFloatAttr (_dcfaa ,_adgf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_gcbcc :=_gaee .parseMarginAttr (_dcfaa ,_adgf );_ccgdfd .SetMargins (_gcbcc .Left ,_gcbcc .Right ,_gcbcc .Top ,_gcbcc .Bottom );
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_ccgdfd .SetEnableWrap (_gaee .parseBoolAttr (_dcfaa ,_adgf ));case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_ccgdfd .EnableWordWrap (_gaee .parseBoolAttr (_dcfaa ,_adgf ));
case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_ccgdfd .SetTextOverflow (_gaee .parseTextOverflowAttr (_dcfaa ,_adgf ));case "\u0078":_ccgdfd .SetPos (_gaee .parseFloatAttr (_dcfaa ,_adgf ),_ccgdfd ._cdgdb );case "\u0079":_ccgdfd .SetPos (_ccgdfd ._ccbea ,_gaee .parseFloatAttr (_dcfaa ,_adgf ));
case "\u0061\u006e\u0067l\u0065":_ccgdfd .SetAngle (_gaee .parseFloatAttr (_dcfaa ,_adgf ));default:_gaee .nodeLogDebug (_bcbbg ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dcfaa );
};};return _ccgdfd ,nil ;};func (_gafg *Creator )initContext (){_gafg ._ebce .X =_gafg ._ebcd .Left ;_gafg ._ebce .Y =_gafg ._ebcd .Top ;_gafg ._ebce .Width =_gafg ._bccc -_gafg ._ebcd .Right -_gafg ._ebcd .Left ;_gafg ._ebce .Height =_gafg ._adfe -_gafg ._ebcd .Bottom -_gafg ._ebcd .Top ;
_gafg ._ebce .PageHeight =_gafg ._adfe ;_gafg ._ebce .PageWidth =_gafg ._bccc ;_gafg ._ebce .Margins =_gafg ._ebcd ;_gafg ._ebce ._fdee =_gafg .UnsupportedCharacterReplacement ;};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_bebg *Ellipse )SetPositioning (position Positioning ){_bebg ._fgac =position };func _dccb ()*Division {return &Division {_gadg :true }};

// NewColumn returns a new column for the line items invoice table.
func (_eace *Invoice )NewColumn (description string )*InvoiceCell {return _eace .newColumn (description ,CellHorizontalAlignmentLeft );};

// SetLazy sets the lazy mode for the image.
func (_bedf *Image )SetLazy (lazy bool ){_bedf ._egca =lazy };

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_abbc *Creator )Flip (flipH ,flipV bool )error {_debc :=_abbc .getActivePage ();if _debc ==nil {return _ac .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_geag ,_fdbg :=_abbc ._acff [_debc ];if !_fdbg {_geag =&pageTransformations {};
_abbc ._acff [_debc ]=_geag ;};_geag ._cedb =flipH ;_geag ._aeb =flipV ;return nil ;};

// SetBorderOpacity sets the border opacity.
func (_egfbc *CurvePolygon )SetBorderOpacity (opacity float64 ){_egfbc ._efde =opacity };

// SetOpacity sets the opacity of the line (0-1).
func (_gccb *Line )SetOpacity (opacity float64 ){_gccb ._ecga =opacity };

// SetLanguage sets the language identifier that will be stored inside document catalog.
func (_dbae *Creator )SetLanguage (language string ){_dbae ._faeb =language };

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;

// Width returns the cell's width based on the input draw context.
func (_ceffg *TableCell )Width (ctx DrawContext )float64 {_cccfb :=float64 (0.0);for _bcbeg :=0;_bcbeg < _ceffg ._decgd ;_bcbeg ++{_cccfb +=_ceffg ._bdffe ._aabdd [_ceffg ._gacfd +_bcbeg -1];};_dgecf :=ctx .Width *_cccfb ;return _dgecf ;};func (_cccfd *Invoice )drawInformation ()*Table {_abfd :=_fbcee (2);
_ebgfa :=append ([][2]*InvoiceCell {_cccfd ._bfbbc ,_cccfd ._egec ,_cccfd ._ecbb },_cccfd ._beeae ...);for _ ,_beba :=range _ebgfa {_eafd ,_aeff :=_beba [0],_beba [1];if _aeff .Value ==""{continue ;};_ddae :=_abfd .NewCell ();_ddae .SetBackgroundColor (_eafd .BackgroundColor );
_cccfd .setCellBorder (_ddae ,_eafd );_bfcg :=_accf (_eafd .TextStyle );_bfcg .Append (_eafd .Value );_bfcg .SetMargins (0,0,2,1);_ddae .SetContent (_bfcg );_ddae =_abfd .NewCell ();_ddae .SetBackgroundColor (_aeff .BackgroundColor );_cccfd .setCellBorder (_ddae ,_aeff );
_bfcg =_accf (_aeff .TextStyle );_bfcg .Append (_aeff .Value );_bfcg .SetMargins (0,0,2,1);_ddae .SetContent (_bfcg );};return _abfd ;};

// NewImageFromFile creates an Image from a file.
func (_cgfd *Creator )NewImageFromFile (path string )(*Image ,error ){return _fecd (path )};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_cgcb *Block )DrawTemplate (c *Creator ,r _ebf .Reader ,data interface{},options *TemplateOptions )error {return _bcbegg (c ,r ,data ,options ,_cgcb );};

// AddLine appends a new line to the invoice line items table.
func (_fgag *Invoice )AddLine (values ...string )[]*InvoiceCell {_defe :=len (_fgag ._abbcg );var _fccaf []*InvoiceCell ;for _dggd ,_cggd :=range values {_eabbe :=_fgag .newCell (_cggd ,_fgag ._dgfgd );if _dggd < _defe {_eabbe .Alignment =_fgag ._abbcg [_dggd ].Alignment ;
};_fccaf =append (_fccaf ,_eabbe );};_fgag ._dbebc =append (_fgag ._dbebc ,_fccaf );return _fccaf ;};

// Lazy gets the lazy mode for the image.
func (_dffcc *Image )Lazy ()bool {return _dffcc ._egca };

// SetBorder sets the cell's border style.
func (_gdceg *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_gdceg ._ggae =CellBorderStyleSingle ;_gdceg ._bgfd =width ;_gdceg ._dgdb =CellBorderStyleSingle ;
_gdceg ._fedgc =width ;_gdceg ._feeaf =CellBorderStyleSingle ;_gdceg ._ebcc =width ;_gdceg ._dafa =CellBorderStyleSingle ;_gdceg ._cdgea =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_gdceg ._ggae =CellBorderStyleDouble ;_gdceg ._bgfd =width ;
_gdceg ._dgdb =CellBorderStyleDouble ;_gdceg ._fedgc =width ;_gdceg ._feeaf =CellBorderStyleDouble ;_gdceg ._ebcc =width ;_gdceg ._dafa =CellBorderStyleDouble ;_gdceg ._cdgea =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_gdceg ._ggae =style ;
_gdceg ._bgfd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_gdceg ._dgdb =style ;_gdceg ._fedgc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_gdceg ._feeaf =style ;
_gdceg ._ebcc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_gdceg ._dafa =style ;_gdceg ._cdgea =width ;};};

// Text sets the text content of the Paragraph.
func (_eadg *Paragraph )Text ()string {return _eadg ._dddfg };

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_cf *Block )Draw (d Drawable )error {_efbg :=DrawContext {};_efbg .Width =_cf ._ccb ;_efbg .Height =_cf ._cb ;_efbg .PageWidth =_cf ._ccb ;_efbg .PageHeight =_cf ._cb ;_efbg .X =0;_efbg .Y =0;_fe ,_ ,_bgga :=d .GeneratePageBlocks (_efbg );if _bgga !=nil {return _bgga ;
};if len (_fe )!=1{return ErrContentNotFit ;};for _ ,_fec :=range _fe {if _baa :=_cf .mergeBlocks (_fec );_baa !=nil {return _baa ;};};return nil ;};

// SetFillOpacity sets the fill opacity of the rectangle.
func (_dagga *Rectangle )SetFillOpacity (opacity float64 ){_dagga ._cdebe =opacity };

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// SetOpacity sets opacity for border in range 0-1.
func (_gee *border )SetOpacity (opacity float64 ){_gee ._beb =opacity };var PPI float64 =72;

// SetMarkedContentID sets the marked content ID.
func (_gedd *PageBreak )SetMarkedContentID (id int64 )*_bdd .KDict {return nil };

// SetEnableWrap sets the line wrapping enabled flag.
func (_ggfcg *Paragraph )SetEnableWrap (enableWrap bool ){_ggfcg ._ceaa =enableWrap ;_ggfcg ._egeaa =false ;};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_cdfc *LinearShading )AddPatternResource (block *Block )(_fdea _bdg .PdfObjectName ,_fedc error ){_efff :=1;_babgf :=_bdg .PdfObjectName ("\u0050"+_eb .Itoa (_efff ));for block ._fb .HasPatternByName (_babgf ){_efff ++;_babgf =_bdg .PdfObjectName ("\u0050"+_eb .Itoa (_efff ));
};if _fdda :=block ._fb .SetPatternByName (_babgf ,_cdfc .ToPdfShadingPattern ().ToPdfObject ());_fdda !=nil {return "",_fdda ;};return _babgf ,nil ;};

// SetColorTop sets border color for top.
func (_bb *border )SetColorTop (col Color ){_bb ._gcfd =col };

// SetStructTreeRoot sets the structure tree root to be appended in the document that will be created.
func (_faag *Creator )SetStructTreeRoot (structTreeRoot *_bdd .StructTreeRoot ){_faag ._agfd =structTreeRoot ;};func (_ecbf *Table )resetColumnWidths (){_ecbf ._aabdd =[]float64 {};_gedbc :=float64 (1.0)/float64 (_ecbf ._ccdbbe );for _bcbag :=0;_bcbag < _ecbf ._ccdbbe ;
_bcbag ++{_ecbf ._aabdd =append (_ecbf ._aabdd ,_gedbc );};};

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_beae *LinearShading )SetAngle (angle float64 ){_beae ._dgabd =angle };

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_cfbg *RadialShading )SetExtends (start bool ,end bool ){_cfbg ._eddc .SetExtends (start ,end )};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_afagg *Line )SetMargins (left ,right ,top ,bottom float64 ){_afagg ._agbfd .Left =left ;_afagg ._agbfd .Right =right ;_afagg ._agbfd .Top =top ;_afagg ._agbfd .Bottom =bottom ;};func _cdd (_dcgb ,_dgff ,_acb ,_dgd float64 )*border {_fgd :=&border {};
_fgd ._fgca =_dcgb ;_fgd ._gdf =_dgff ;_fgd ._abce =_acb ;_fgd ._ggc =_dgd ;_fgd ._gcfd =ColorBlack ;_fgd ._fed =ColorBlack ;_fgd ._aeg =ColorBlack ;_fgd ._dag =ColorBlack ;_fgd ._fagd =0;_fgd ._cca =0;_fgd ._bgb =0;_fgd ._gea =0;_fgd ._beb =1.0;_fgd .LineStyle =_ebc .LineStyleSolid ;
return _fgd ;};

// SetMarkedContentID sets the marked content id for the list.
func (_fceb *List )SetMarkedContentID (id int64 )*_bdd .KDict {return nil };

// SetOpacity sets opacity for Image.
func (_aafab *Image )SetOpacity (opacity float64 ){_aafab ._dcbbb =opacity };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_gaed *Chapter )SetShowNumbering (show bool ){_gaed ._dgfc =show ;_gaed ._ccbe .SetText (_gaed .headingText ());};

// DrawFooter sets a function to draw a footer on created output pages.
func (_befc *Creator )DrawFooter (drawFooterFunc func (_fce *Block ,_dbbc FooterFunctionArgs )){_befc ._cacg =drawFooterFunc ;};

// SetHeight sets the Image's document height to specified h.
func (_ddadb *Image )SetHeight (h float64 ){_ddadb ._eedg =h };

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetStyleLeft sets border style for left side.
func (_fggc *border )SetStyleLeft (style CellBorderStyle ){_fggc ._dacg =style };

// SetCoords sets the center coordinates of the ellipse.
func (_bfgb *Ellipse )SetCoords (xc ,yc float64 ){_bfgb ._afdf =xc ;_bfgb ._dgade =yc };var (ErrContentNotFit =_ac .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
);func _gdecac (_dgbgd ...interface{})(map[string ]interface{},error ){_bcce :=len (_dgbgd );if _bcce %2!=0{_da .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_bcce );
return nil ,_bdg .ErrRangeError ;};_dbece :=map[string ]interface{}{};for _gdcde :=0;_gdcde < _bcce ;_gdcde +=2{_fcbag ,_fgddc :=_dgbgd [_gdcde ].(string );if !_fgddc {_da .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_dgbgd [_gdcde ]);
return nil ,_bdg .ErrTypeError ;};_dbece [_fcbag ]=_dgbgd [_gdcde +1];};return _dbece ,nil ;};

// GetIndent get the cell's left indent.
func (_fcag *TableCell )GetIndent ()float64 {return _fcag ._gdfaa };

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_bgfgb *Rectangle )GetCoords ()(float64 ,float64 ){return _bgfgb ._cbcfa ,_bgfgb ._ffdf };

// Height returns the Block's height.
func (_ffg *Block )Height ()float64 {return _ffg ._cb };

// NewTable create a new Table with a specified number of columns.
func (_eedb *Creator )NewTable (cols int )*Table {return _fbcee (cols )};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_bddc *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_bddc ._ccdbbe {_da .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _ac .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bddc ._aabdd =widths ;return nil ;};func (_ggce *Image )makeXObject ()error {_ceec ,_ffgf :=_bdd .NewXObjectImageFromImageLazy (_ggce ._cebb ,nil ,_ggce ._feed ,_ggce ._egca );
if _ffgf !=nil {_da .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ffgf );return _ffgf ;};_ggce ._gdddd =_ceec ;
return nil ;};

// SetPos sets absolute positioning with specified coordinates.
func (_dfce *StyledParagraph )SetPos (x ,y float64 ){_dfce ._geae =PositionAbsolute ;_dfce ._ccbea =x ;_dfce ._cdgdb =y ;};

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_fgdee *Rectangle )FillOpacity ()float64 {return _fgdee ._cdebe };

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_ccgba *Invoice )NoteStyle ()TextStyle {return _ccgba ._addg };func (_faeac *Invoice )drawSection (_daaa ,_fccd string )[]*StyledParagraph {var _adce []*StyledParagraph ;if _daaa !=""{_gggaa :=_accf (_faeac ._bddd );_gggaa .SetMargins (0,0,0,5);_gggaa .Append (_daaa );
_adce =append (_adce ,_gggaa );};if _fccd !=""{_gdbbd :=_accf (_faeac ._addg );_gdbbd .Append (_fccd );_adce =append (_adce ,_gdbbd );};return _adce ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//
//	red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_gbef :_bd .Min (float64 (c ),100)/100.0,_gcg :_bd .Min (float64 (m ),100)/100.0,_gab :_bd .Min (float64 (y ),100)/100.0,_bgfg :_bd .Min (float64 (k ),100)/100.0};};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// The Image type is used to draw an image onto PDF.
type Image struct{_gdddd *_bdd .XObjectImage ;_cebb *_bdd .Image ;_afdc string ;_gdccb float64 ;_fgbd ,_eedg float64 ;_adge ,_ceeac float64 ;_edeb Positioning ;_cafee HorizontalAlignment ;_eeff float64 ;_bacd float64 ;_dcbbb float64 ;_aedc Margins ;_aeag ,_cacdf float64 ;
_feed _bdg .StreamEncoder ;_bbbde FitMode ;_egca bool ;_bebfb *int64 ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_addae *Creator )DrawTemplate (r _ebf .Reader ,data interface{},options *TemplateOptions )error {return _bcbegg (_addae ,r ,data ,options ,_addae );};

// GetCoords returns coordinates of border.
func (_fbae *border )GetCoords ()(float64 ,float64 ){return _fbae ._fgca ,_fbae ._gdf };func (_gbec *Invoice )newColumn (_beagd string ,_aecf CellHorizontalAlignment )*InvoiceCell {_bcad :=&InvoiceCell {_gbec ._dgfa ,_beagd };_bcad .Alignment =_aecf ;return _bcad ;
};

// SetFillColor sets the fill color of the ellipse.
func (_cfged *Ellipse )SetFillColor (col Color ){_cfged ._dagdd =col };

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_bfgc *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_gead []*Block ;_gged =NewBlock (ctx .PageWidth ,ctx .PageHeight );_agff =ctx ;);_afa :=_bfgc ._fgac .IsRelative ();if _afa {_bfgc .applyFitMode (ctx .Width );
ctx .X +=_bfgc ._gcbd .Left ;ctx .Y +=_bfgc ._gcbd .Top ;ctx .Width -=_bfgc ._gcbd .Left +_bfgc ._gcbd .Right ;ctx .Height -=_bfgc ._gcbd .Top +_bfgc ._gcbd .Bottom ;if _bfgc ._cce > ctx .Height {_gead =append (_gead ,_gged );_gged =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_efca :=ctx ;_efca .Y =ctx .Margins .Top +_bfgc ._gcbd .Top ;_efca .X =ctx .Margins .Left +_bfgc ._gcbd .Left ;_efca .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_bfgc ._gcbd .Top -_bfgc ._gcbd .Bottom ;_efca .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_bfgc ._gcbd .Left -_bfgc ._gcbd .Right ;
ctx =_efca ;};}else {ctx .X =_bfgc ._afdf -_bfgc ._bfddf /2;ctx .Y =_bfgc ._dgade -_bfgc ._cce /2;};_fgbcf :=_ebc .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_bfgc ._cce ,Width :_bfgc ._bfddf ,Height :_bfgc ._cce ,BorderWidth :_bfgc ._bffg ,Opacity :1.0};
if _bfgc ._dagdd !=nil {_fgbcf .FillEnabled =true ;_ccgc :=_ddfd (_bfgc ._dagdd );_fffd :=_fcgdf (_gged ,_ccgc ,_bfgc ._dagdd ,func ()Rectangle {return Rectangle {_cbcfa :_fgbcf .X ,_ffdf :_fgbcf .Y ,_efdd :_fgbcf .Width ,_bbae :_fgbcf .Height };});if _fffd !=nil {return nil ,ctx ,_fffd ;
};_fgbcf .FillColor =_ccgc ;};if _bfgc ._dage !=nil {_fgbcf .BorderEnabled =false ;if _bfgc ._bffg > 0{_fgbcf .BorderEnabled =true ;};_fgbcf .BorderColor =_ddfd (_bfgc ._dage );_fgbcf .BorderWidth =_bfgc ._bffg ;};_afag ,_cbb :=_gged .setOpacity (_bfgc ._fgbc ,_bfgc ._ffaeg );
if _cbb !=nil {return nil ,ctx ,_cbb ;};_acae ,_ ,_cbb :=_fgbcf .MarkedDraw (_afag ,_bfgc ._fgbf );if _cbb !=nil {return nil ,ctx ,_cbb ;};_cbb =_gged .addContentsByString (string (_acae ));if _cbb !=nil {return nil ,ctx ,_cbb ;};if _afa {ctx .X =_agff .X ;
ctx .Width =_agff .Width ;ctx .Y +=_bfgc ._cce +_bfgc ._gcbd .Bottom ;ctx .Height -=_bfgc ._cce ;}else {ctx =_agff ;};_gead =append (_gead ,_gged );return _gead ,ctx ,nil ;};func (_bcbgb *templateProcessor )parseColorAttr (_cgbfa ,_aadf string )Color {_da .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_cgbfa ,_aadf );
_aadf =_fa .TrimSpace (_aadf );if _fa .HasPrefix (_aadf ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_fa .HasSuffix (_aadf ,"\u0029")&&len (_aadf )> 17{return _bcbgb .parseLinearGradientAttr (_bcbgb .creator ,_aadf );
};if _fa .HasPrefix (_aadf ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_fa .HasSuffix (_aadf ,"\u0029")&&len (_aadf )> 17{return _bcbgb .parseRadialGradientAttr (_bcbgb .creator ,_aadf );};if _cbafc :=_bcbgb .parseColor (_aadf );
_cbafc !=nil {return _cbafc ;};return ColorBlack ;};func (_gdbcd *templateProcessor )parsePositioningAttr (_egfcg ,_afaf string )Positioning {_da .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_egfcg ,_afaf );
_beeaeg :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_afaf ];return _beeaeg ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_afdf float64 ;_dgade float64 ;_bfddf float64 ;_cce float64 ;_fgac Positioning ;_dagdd Color ;_fgbc float64 ;_dage Color ;_bffg float64 ;_ffaeg float64 ;_gcbd Margins ;_gdce FitMode ;_fgbf *int64 ;};

// Columns returns all the columns in the invoice line items table.
func (_gfeb *Invoice )Columns ()[]*InvoiceCell {return _gfeb ._abbcg };

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_aegf *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gfef :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cdebf ,_agbb :=_gfef .setOpacity (_aegf ._cfeb ,_aegf ._efde );if _agbb !=nil {return nil ,ctx ,_agbb ;
};_geeg :=_aegf ._gfd ;_geeg .FillEnabled =_geeg .FillColor !=nil ;_geeg .BorderEnabled =_geeg .BorderColor !=nil &&_geeg .BorderWidth > 0;var (_gegc =ctx .PageHeight ;_cbgb =_geeg .Rings ;_dgedb =make ([][]_ebc .CubicBezierCurve ,0,len (_geeg .Rings ));
);_gfge :=_bdd .PdfRectangle {};if len (_cbgb )> 0&&len (_cbgb [0])> 0{_febcg :=_cbgb [0][0];_febcg .P0 .Y =_gegc -_febcg .P0 .Y ;_febcg .P1 .Y =_gegc -_febcg .P1 .Y ;_febcg .P2 .Y =_gegc -_febcg .P2 .Y ;_febcg .P3 .Y =_gegc -_febcg .P3 .Y ;_gfge =_febcg .GetBounds ();
};for _ ,_cdcc :=range _cbgb {_caa :=make ([]_ebc .CubicBezierCurve ,0,len (_cdcc ));for _ ,_cbf :=range _cdcc {_fee :=_cbf ;_fee .P0 .Y =_gegc -_fee .P0 .Y ;_fee .P1 .Y =_gegc -_fee .P1 .Y ;_fee .P2 .Y =_gegc -_fee .P2 .Y ;_fee .P3 .Y =_gegc -_fee .P3 .Y ;
_caa =append (_caa ,_fee );_gbfa :=_fee .GetBounds ();_gfge .Llx =_bd .Min (_gfge .Llx ,_gbfa .Llx );_gfge .Lly =_bd .Min (_gfge .Lly ,_gbfa .Lly );_gfge .Urx =_bd .Max (_gfge .Urx ,_gbfa .Urx );_gfge .Ury =_bd .Max (_gfge .Ury ,_gbfa .Ury );};_dgedb =append (_dgedb ,_caa );
};_geeg .Rings =_dgedb ;defer func (){_geeg .Rings =_cbgb }();if _geeg .FillEnabled {_ebbc :=_fcgdf (_gfef ,_aegf ._gfd .FillColor ,_aegf ._eabcg ,func ()Rectangle {return Rectangle {_cbcfa :_gfge .Llx ,_ffdf :_gfge .Lly ,_efdd :_gfge .Width (),_bbae :_gfge .Height ()};
});if _ebbc !=nil {return nil ,ctx ,_ebbc ;};};_aeeg ,_ ,_agbb :=_geeg .MarkedDraw (_cdebf ,_aegf ._eefe );if _agbb !=nil {return nil ,ctx ,_agbb ;};if _agbb =_gfef .addContentsByString (string (_aeeg ));_agbb !=nil {return nil ,ctx ,_agbb ;};return []*Block {_gfef },ctx ,nil ;
};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_fgfc *Division )SetPadding (left ,right ,top ,bottom float64 ){_fgfc ._gcfg .Left =left ;_fgfc ._gcfg .Right =right ;_fgfc ._gcfg .Top =top ;_fgfc ._gcfg .Bottom =bottom ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_eeaf *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _eeaf ._eaag .Left ,_eeaf ._eaag .Right ,_eeaf ._eaag .Top ,_eeaf ._eaag .Bottom ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_facb *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _facb ._gdddd ==nil {if _fgcbg :=_facb .makeXObject ();_fgcbg !=nil {return nil ,ctx ,_fgcbg ;};};var _ddcg []*Block ;_fdfaa :=ctx ;_aefd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _facb ._edeb .IsRelative (){_facb .applyFitMode (ctx .Width );ctx .X +=_facb ._aedc .Left ;ctx .Y +=_facb ._aedc .Top ;ctx .Width -=_facb ._aedc .Left +_facb ._aedc .Right ;ctx .Height -=_facb ._aedc .Top +_facb ._aedc .Bottom ;if _facb ._eedg > ctx .Height {_ddcg =append (_ddcg ,_aefd );
_aefd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_efbbb :=ctx ;_efbbb .Y =ctx .Margins .Top +_facb ._aedc .Top ;_efbbb .X =ctx .Margins .Left +_facb ._aedc .Left ;_efbbb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_facb ._aedc .Top -_facb ._aedc .Bottom ;
_efbbb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_facb ._aedc .Left -_facb ._aedc .Right ;ctx =_efbbb ;};}else {ctx .X =_facb ._eeff ;ctx .Y =_facb ._bacd ;};ctx ,_bbfc :=_dcgea (_aefd ,_facb ,ctx );if _bbfc !=nil {return nil ,ctx ,_bbfc ;
};_ddcg =append (_ddcg ,_aefd );if _facb ._edeb .IsAbsolute (){ctx =_fdfaa ;}else {ctx .X =_fdfaa .X ;ctx .Width =_fdfaa .Width ;ctx .Y +=_facb ._aedc .Bottom ;};return _ddcg ,ctx ,nil ;};func _ffffd ()*listItem {return &listItem {}};

// SetLineHeight sets the line height (1.0 default).
func (_gaca *StyledParagraph )SetLineHeight (lineheight float64 ){_gaca ._adbbc =lineheight };

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_fbacd *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};type listItem struct{_ffda VectorDrawable ;_baee TextChunk ;};

// LineWidth returns the width of the line.
func (_dfea *Line )LineWidth ()float64 {return _dfea ._dedd };

// SetBorderWidth sets the border width.
func (_fadeb *Polygon )SetBorderWidth (borderWidth float64 ){_fadeb ._bcgb .BorderWidth =borderWidth };

// Lines returns all the rows of the invoice line items table.
func (_fdbde *Invoice )Lines ()[][]*InvoiceCell {return _fdbde ._dbebc };func _aedga (_ccgdfa string ,_edfdf TextStyle )*Paragraph {_cfee :=&Paragraph {_dddfg :_ccgdfa ,_gfac :_edfdf .Font ,_ccdc :_edfdf .FontSize ,_gfaa :1.0,_ceaa :true ,_egeaa :true ,_dgcd :TextAlignmentLeft ,_gfaae :0,_dbag :1,_ccag :1,_abcfeg :PositionRelative ,_cdedda :""};
_cfee .SetColor (_edfdf .Color );return _cfee ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_cgbg *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_cgbg ._bfefc =&_bdd .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_fdag *Ellipse )SetFitMode (fitMode FitMode ){_fdag ._gdce =fitMode };func _gdafg (_bfdb string ,_ddadf ,_dcfge TextStyle )*TOC {_cabdf :=_dcfge ;_cabdf .FontSize =14;_caeef :=_accf (_cabdf );_caeef .SetEnableWrap (true );_caeef .SetTextAlignment (TextAlignmentLeft );
_caeef .SetMargins (0,0,0,5);_gbddcd :=_caeef .Append (_bfdb );_gbddcd .Style =_cabdf ;return &TOC {_aafbcf :_caeef ,_cfecf :[]*TOCLine {},_caec :_ddadf ,_cfad :_ddadf ,_gdggf :_ddadf ,_cdbed :_ddadf ,_agdgdc :"\u002e",_faadb :10,_badg :Margins {0,0,2,2},_fbcdfa :PositionRelative ,_fddgb :_ddadf ,_egbac :true };
};func (_dgee *TOCLine )getLineLink ()*_bdd .PdfAnnotation {if _dgee ._ddbe <=0{return nil ;};return _fegcc (_dgee ._ddbe -1,_dgee ._adbf ,_dgee ._cagac ,0);};func (_dcdcb *templateProcessor )parseParagraph (_fcfeb *templateNode ,_cfddb *Paragraph )(interface{},error ){if _cfddb ==nil {_cfddb =_dcdcb .creator .NewParagraph ("");
};for _ ,_ffbg :=range _fcfeb ._edag .Attr {_egef :=_ffbg .Value ;switch _aefb :=_ffbg .Name .Local ;_aefb {case "\u0066\u006f\u006e\u0074":_cfddb .SetFont (_dcdcb .parseFontAttr (_aefb ,_egef ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_cfddb .SetFontSize (_dcdcb .parseFloatAttr (_aefb ,_egef ));
case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_cfddb .SetTextAlignment (_dcdcb .parseTextAlignmentAttr (_aefb ,_egef ));case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_cfddb .SetLineHeight (_dcdcb .parseFloatAttr (_aefb ,_egef ));
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_cfddb .SetEnableWrap (_dcdcb .parseBoolAttr (_aefb ,_egef ));case "\u0063\u006f\u006co\u0072":_cfddb .SetColor (_dcdcb .parseColorAttr (_aefb ,_egef ));case "\u0078":_cfddb .SetPos (_dcdcb .parseFloatAttr (_aefb ,_egef ),_cfddb ._gadge );
case "\u0079":_cfddb .SetPos (_cfddb ._edac ,_dcdcb .parseFloatAttr (_aefb ,_egef ));case "\u0061\u006e\u0067l\u0065":_cfddb .SetAngle (_dcdcb .parseFloatAttr (_aefb ,_egef ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_dacfd :=_dcdcb .parseMarginAttr (_aefb ,_egef );
_cfddb .SetMargins (_dacfd .Left ,_dacfd .Right ,_dacfd .Top ,_dacfd .Bottom );case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_cfddb .SetMaxLines (int (_dcdcb .parseInt64Attr (_aefb ,_egef )));default:_dcdcb .nodeLogDebug (_fcfeb ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_aefb );
};};return _cfddb ,nil ;};

// Scale scales the ellipse dimensions by the specified factors.
func (_badc *Ellipse )Scale (xFactor ,yFactor float64 ){_badc ._bfddf =xFactor *_badc ._bfddf ;_badc ._cce =yFactor *_badc ._cce ;};func _aaafb (_beef string )*_bdd .PdfAnnotation {_edcbe :=_bdd .NewPdfAnnotationLink ();_fdefc :=_bdd .NewBorderStyle ();
_fdefc .SetBorderWidth (0);_edcbe .BS =_fdefc .ToPdfObject ();_ccadb :=_bdd .NewPdfActionURI ();_ccadb .URI =_bdg .MakeString (_beef );_edcbe .SetAction (_ccadb .PdfAction );return _edcbe .PdfAnnotation ;};func (_agg *Chapter )headingText ()string {_ede :=_agg ._fad ;
if _bccf :=_agg .headingNumber ();_bccf !=""{_ede =_a .Sprintf ("\u0025\u0073\u0020%\u0073",_bccf ,_ede );};return _ede ;};

// AddTotalLine adds a new line in the invoice totals table.
func (_gdbb *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_ggda :=&InvoiceCell {_gdbb ._ffcge ,desc };_cfbab :=&InvoiceCell {_gdbb ._ffcge ,value };_gdbb ._fbce =append (_gdbb ._fbce ,[2]*InvoiceCell {_ggda ,_cfbab });return _ggda ,_cfbab ;
};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_adfee *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_afad *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aabf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gaec ,_cebc :=_aabf .setOpacity (_afad ._fgcee ,_afad ._fgcee );if _cebc !=nil {return nil ,ctx ,_cebc ;};_fdbcd :=_afad ._cddce .Points ;
for _adbe :=range _fdbcd {_bebff :=&_fdbcd [_adbe ];_bebff .Y =ctx .PageHeight -_bebff .Y ;};_bfef ,_ ,_cebc :=_afad ._cddce .MarkedDraw (_gaec ,_afad ._acgdd );if _cebc !=nil {return nil ,ctx ,_cebc ;};if _cebc =_aabf .addContentsByString (string (_bfef ));
_cebc !=nil {return nil ,ctx ,_cebc ;};return []*Block {_aabf },ctx ,nil ;};func _cffa (_ddgd ,_gdfeg TextStyle )*Invoice {_fegc :=&Invoice {_cbgeg :"\u0049N\u0056\u004f\u0049\u0043\u0045",_dfdg :"\u002c\u0020",_fcaa :_ddgd ,_ecgg :_gdfeg };_fegc ._bccg =&InvoiceAddress {Separator :_fegc ._dfdg };
_fegc ._cceff =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_fegc ._dfdg };_bgdg :=ColorRGBFrom8bit (245,245,245);_cgg :=ColorRGBFrom8bit (155,155,155);_fegc ._ggceg =_gdfeg ;_fegc ._ggceg .Color =_cgg ;_fegc ._ggceg .FontSize =20;
_fegc ._bdaa =_ddgd ;_fegc ._afde =_gdfeg ;_fegc ._addg =_ddgd ;_fegc ._bddd =_gdfeg ;_fegc ._dadd =_fegc .NewCellProps ();_fegc ._dadd .BackgroundColor =_bgdg ;_fegc ._dadd .TextStyle =_gdfeg ;_fegc ._dgfa =_fegc .NewCellProps ();_fegc ._dgfa .TextStyle =_gdfeg ;
_fegc ._dgfa .BackgroundColor =_bgdg ;_fegc ._dgfa .BorderColor =_bgdg ;_fegc ._dgfgd =_fegc .NewCellProps ();_fegc ._dgfgd .BorderColor =_bgdg ;_fegc ._dgfgd .BorderSides =[]CellBorderSide {CellBorderSideBottom };_fegc ._dgfgd .Alignment =CellHorizontalAlignmentRight ;
_fegc ._ffcge =_fegc .NewCellProps ();_fegc ._ffcge .Alignment =CellHorizontalAlignmentRight ;_fegc ._bfbbc =[2]*InvoiceCell {_fegc .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_fegc ._dadd ),_fegc .newCell ("",_fegc ._dadd )};
_fegc ._egec =[2]*InvoiceCell {_fegc .newCell ("\u0044\u0061\u0074\u0065",_fegc ._dadd ),_fegc .newCell ("",_fegc ._dadd )};_fegc ._ecbb =[2]*InvoiceCell {_fegc .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_fegc ._dadd ),_fegc .newCell ("",_fegc ._dadd )};
_fegc ._cfgg =[2]*InvoiceCell {_fegc .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_fegc ._ffcge ),_fegc .newCell ("",_fegc ._ffcge )};_dbca :=_fegc ._ffcge ;_dbca .TextStyle =_gdfeg ;_dbca .BackgroundColor =_bgdg ;_dbca .BorderColor =_bgdg ;
_fegc ._afgg =[2]*InvoiceCell {_fegc .newCell ("\u0054\u006f\u0074a\u006c",_dbca ),_fegc .newCell ("",_dbca )};_fegc ._eabd =[2]string {"\u004e\u006f\u0074e\u0073",""};_fegc ._ggbee =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_fegc ._abbcg =[]*InvoiceCell {_fegc .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_fegc .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_fegc .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_fegc .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _fegc ;};

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _dab (svgStr )};

// SetLineOpacity sets the line opacity.
func (_cgdgd *Polyline )SetLineOpacity (opacity float64 ){_cgdgd ._fgcee =opacity };

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_accgc *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _accgc ._abae .Left ,_accgc ._abae .Right ,_accgc ._abae .Top ,_accgc ._abae .Bottom ;};func (_gdaag *Image )rotatedSize ()(float64 ,float64 ){_cda :=_gdaag ._fgbd ;_acgd :=_gdaag ._eedg ;
_faac :=_gdaag ._gdccb ;if _faac ==0{return _cda ,_acgd ;};_egedd :=_ebc .Path {Points :[]_ebc .Point {_ebc .NewPoint (0,0).Rotate (_faac ),_ebc .NewPoint (_cda ,0).Rotate (_faac ),_ebc .NewPoint (0,_acgd ).Rotate (_faac ),_ebc .NewPoint (_cda ,_acgd ).Rotate (_faac )}}.GetBoundingBox ();
return _egedd .Width ,_egedd .Height ;};

// SetMargins sets the margins of the graphic svg component.
func (_gbad *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_gbad ._ggfgf .Left =left ;_gbad ._ggfgf .Right =right ;_gbad ._ggfgf .Top =top ;_gbad ._ggfgf .Bottom =bottom ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};type templateNode struct{_cdab interface{};_edag _g .StartElement ;_fcdcc *templateNode ;
_fabf int ;_ebcf int ;_cbcfd int64 ;};func (_edbf *listItem )ctxHeight (_aeda float64 )float64 {var _acdc float64 ;switch _daaf :=_edbf ._ffda .(type ){case *Paragraph :if _daaf ._ceaa {_daaf .SetWidth (_aeda -_daaf ._defec .Horizontal ());};_acdc =_daaf .Height ()+_daaf ._defec .Vertical ();
_acdc +=0.5*_daaf ._ccdc *_daaf ._gfaa ;case *StyledParagraph :if _daaf ._bcdbe {_daaf .SetWidth (_aeda -_daaf ._cgfa .Horizontal ());};_acdc =_daaf .Height ()+_daaf ._cgfa .Vertical ();_acdc +=0.5*_daaf .getTextHeight ();case *List :_fcceg :=_aeda -_edbf ._baee .Width ()-_daaf ._eaag .Horizontal ()-_daaf ._ccgdf ;
_acdc =_daaf .ctxHeight (_fcceg )+_daaf ._eaag .Vertical ();case *Image :_acdc =_daaf .Height ()+_daaf ._aedc .Vertical ();case *Division :_effed :=_aeda -_edbf ._baee .Width ()-_daaf ._egba .Horizontal ();_acdc =_daaf .ctxHeight (_effed )+_daaf ._egba .Vertical ();
case *Table :_bcfdff :=_aeda -_edbf ._baee .Width ()-_daaf ._geefd .Horizontal ();_daaf .updateRowHeights (_bcfdff );_acdc =_daaf .Height ()+_daaf ._geefd .Vertical ();default:_acdc =_edbf ._ffda .Height ();};return _acdc ;};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_efbgc _ef .ChartRenderable ;_fae Positioning ;_gcbc float64 ;_fda float64 ;_ccae Margins ;_edca *int64 ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_fg *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_def :=_gc .IdentityMatrix ();_abd ,_fab :=_fg .Width (),_fg .Height ();if _fg ._ce .IsRelative (){_def =_def .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_fab );}else {_def =_def .Translate (_fg ._ed ,ctx .PageHeight -_fg ._dfa -_fab );
};_dbb :=_fab ;if _fg ._daa !=0{_def =_def .Translate (_abd /2,_fab /2).Rotate (_fg ._daa *_bd .Pi /180.0).Translate (-_abd /2,-_fab /2);_ ,_dbb =_fg .RotatedSize ();};if _fg ._ce .IsRelative (){ctx .Y +=_dbb ;};_dbe :=_ee .NewContentCreator ();_dbe .Add_cm (_def [0],_def [1],_def [3],_def [4],_def [6],_def [7]);
_dda :=_fg .duplicate ();_ea :=append (*_dbe .Operations (),*_dda ._ae ...);_ea .WrapIfNeeded ();_dda ._ae =&_ea ;for _ ,_ba :=range _fg ._ceg {_efb ,_ec :=_bdg .GetArray (_ba .Rect );if !_ec ||_efb .Len ()!=4{_da .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_ba .Rect );
continue ;};_bgf ,_dcc :=_bdd .NewPdfRectangle (*_efb );if _dcc !=nil {_da .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_dcc );
continue ;};_bgf .Transform (_def );_ba .Rect =_bgf .ToPdfObject ();};return []*Block {_dda },ctx ,nil ;};

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_geed *Division )SetMargins (left ,right ,top ,bottom float64 ){_geed ._egba .Left =left ;_geed ._egba .Right =right ;_geed ._egba .Top =top ;_geed ._egba .Bottom =bottom ;};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_bcbg *Division )EnablePageWrap (enable bool ){_bcbg ._gadg =enable };

// SetBuyerAddress sets the buyer address of the invoice.
func (_cgagb *Invoice )SetBuyerAddress (address *InvoiceAddress ){_cgagb ._cceff =address };

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_egcgb *Rectangle )BorderOpacity ()float64 {return _egcgb ._ecfdd };type templateTag struct{_cgadf map[string ]struct{};_bgae func (*templateProcessor ,*templateNode )(interface{},error );};

// SetWidthBottom sets border width for bottom.
func (_eag *border )SetWidthBottom (bw float64 ){_eag ._cca =bw };func (_aec *Block )addContents (_dcg *_ee .ContentStreamOperations ){_aec ._ae .WrapIfNeeded ();_dcg .WrapIfNeeded ();*_aec ._ae =append (*_aec ._ae ,*_dcg ...);};func (_bfg *pageTransformations )applyFlip (_fbgf *_bdd .PdfPage )error {_eggd ,_cagc :=_bfg ._cedb ,_bfg ._aeb ;
if !_eggd &&!_cagc {return nil ;};if _fbgf ==nil {return _ac .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_dagd ,_fbf :=_fbgf .GetMediaBox ();if _fbf !=nil {return _fbf ;};_gdg ,_gdcc :=_dagd .Width (),_dagd .Height ();
_ddga ,_fbf :=_fbgf .GetRotate ();if _fbf !=nil {_da .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_fbf .Error ());
};if _debe :=_ddga %360!=0&&_ddga %90==0;_debe {if _cefb :=(360+_ddga %360)%360;_cefb ==90||_cefb ==270{_eggd ,_cagc =_cagc ,_eggd ;};};_cabg ,_agc :=1.0,0.0;if _eggd {_cabg ,_agc =-1.0,-_gdg ;};_fddb ,_eabc :=1.0,0.0;if _cagc {_fddb ,_eabc =-1.0,-_gdcc ;
};_gddb :=_ee .NewContentCreator ().Scale (_cabg ,_fddb ).Translate (_agc ,_eabc );_ceca ,_fbf :=_bdg .MakeStream (_gddb .Bytes (),_bdg .NewFlateEncoder ());if _fbf !=nil {return _fbf ;};_gdfe :=_bdg .MakeArray (_ceca );_gdfe .Append (_fbgf .GetContentStreamObjs ()...);
_fbgf .Contents =_gdfe ;return nil ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dafb *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _dafb ._afgg [0],_dafb ._afgg [1]};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_eac *Creator )PageFinalize (pageFinalizeFunc func (_fceg PageFinalizeFunctionArgs )error ){_eac ._bbd =pageFinalizeFunc ;};func (_cgaed *templateProcessor )nodeLogDebug (_ecffa *templateNode ,_abedc string ,_acgac ...interface{}){_da .Log .Debug (_cgaed .getNodeErrorLocation (_ecffa ,_abedc ,_acgac ...));
};func _dfca (_faadf *templateProcessor ,_gcgg *templateNode )(interface{},error ){return _faadf .parseLine (_gcgg );};

// Rows returns the total number of rows the table has.
func (_bgbc *Table )Rows ()int {return _bgbc ._adfc };type cmykColor struct{_gbef ,_gcg ,_gab ,_bgfg float64 };

// Width returns the current page width.
func (_dbd *Creator )Width ()float64 {return _dbd ._bccc };

// Scale scales Image by a constant factor, both width and height.
func (_bdga *Image )Scale (xFactor ,yFactor float64 ){_bdga ._fgbd =xFactor *_bdga ._fgbd ;_bdga ._eedg =yFactor *_bdga ._eedg ;};func _bgaeg (_ebdg *templateProcessor ,_aace *templateNode )(interface{},error ){return _ebdg .parseTable (_aace );};func (_gggd *Invoice )setCellBorder (_cgcga *TableCell ,_bgdge *InvoiceCell ){for _ ,_ged :=range _bgdge .BorderSides {_cgcga .SetBorder (_ged ,CellBorderStyleSingle ,_bgdge .BorderWidth );
};_cgcga .SetBorderColor (_bgdge .BorderColor );};type templateProcessor struct{creator *Creator ;_bead []byte ;_cggc *TemplateOptions ;_efede componentRenderer ;_abfe string ;};func (_eeeb *Image )applyFitMode (_bbgb float64 ){_bbgb -=_eeeb ._aedc .Left +_eeeb ._aedc .Right ;
switch _eeeb ._bbbde {case FitModeFillWidth :_eeeb .ScaleToWidth (_bbgb );};};func (_fff *Chapter )headingNumber ()string {var _fgda string ;if _fff ._dgfc {if _fff ._gfee !=0{_fgda =_eb .Itoa (_fff ._gfee )+"\u002e";};if _fff ._ggbe !=nil {_ffc :=_fff ._ggbe .headingNumber ();
if _ffc !=""{_fgda =_ffc +_fgda ;};};};return _fgda ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func (_dfecg *templateProcessor )parseCellAlignmentAttr (_bcbac ,_cfbd string )CellHorizontalAlignment {_da .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bcbac ,_cfbd );
_ebcec :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_cfbd ];return _ebcec ;
};

// SetMarkedContentID sets the marked content ID for the image.
func (_ffcg *Image )SetMarkedContentID (mcid int64 )*_bdd .KDict {_ffcg ._bebfb =&mcid ;_cafdd :=_bdd .NewKDictionary ();_cafdd .S =_bdg .MakeName (_bdd .StructureTypeFigure );_cafdd .K =_bdg .MakeInteger (mcid );return _cafdd ;};

// FitMode returns the fit mode of the line.
func (_ddff *Line )FitMode ()FitMode {return _ddff ._ecfe };

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_cfffe *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_cfffe .Text },nil ;};var _eaceg []string ;var _adefd []rune ;var _fddgg float64 ;var _cgba []float64 ;_ffacg :=_cfffe .Style ;_bbeg :=_dfaaaa (_cfffe .Text );
for _ ,_bedgag :=range _cfffe .Text {if _bedgag =='\u000A'{_ffag :=_dfcea (string (_adefd ),_bbeg );_eaceg =append (_eaceg ,_fa .TrimRightFunc (_ffag ,_bg .IsSpace )+string (_bedgag ));_adefd =nil ;_fddgg =0;_cgba =nil ;continue ;};_bgcfg :=_bedgag ==' ';
_dgfbg ,_abgdc :=_ffacg .Font .GetRuneMetrics (_bedgag );if !_abgdc {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_bedgag ,_bedgag ,_ffacg .Font .BaseFont (),_ffacg .Font .Subtype ());
_da .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_ffacg .Font );_da .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_ffacg .Font .Encoder ());return nil ,_ac .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_ebbff :=_ffacg .FontSize *_dgfbg .Wx ;_cccgf :=_ebbff ;if !_bgcfg {_cccgf =_ebbff +_ffacg .CharSpacing *1000.0;};if _fddgg +_ebbff > width *1000.0{_ccabg :=-1;if !_bgcfg {for _fccfg :=len (_adefd )-1;_fccfg >=0;_fccfg --{if _adefd [_fccfg ]==' '{_ccabg =_fccfg ;
break ;};};};_ddgac :=string (_adefd );if _ccabg > 0{_ddgac =string (_adefd [0:_ccabg +1]);_adefd =append (_adefd [_ccabg +1:],_bedgag );_cgba =append (_cgba [_ccabg +1:],_cccgf );_fddgg =0;for _ ,_ecac :=range _cgba {_fddgg +=_ecac ;};}else {if _bgcfg {_adefd =[]rune {};
_cgba =[]float64 {};_fddgg =0;}else {_adefd =[]rune {_bedgag };_cgba =[]float64 {_cccgf };_fddgg =_cccgf ;};};_ddgac =_dfcea (_ddgac ,_bbeg );_eaceg =append (_eaceg ,_fa .TrimRightFunc (_ddgac ,_bg .IsSpace ));}else {_adefd =append (_adefd ,_bedgag );_fddgg +=_cccgf ;
_cgba =append (_cgba ,_cccgf );};};if len (_adefd )> 0{_bfgf :=string (_adefd );_bfgf =_dfcea (_bfgf ,_bbeg );_eaceg =append (_eaceg ,_bfgf );};return _eaceg ,nil ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_eaeb *LinearShading )SetAntiAlias (enable bool ){_eaeb ._bdbcd .SetAntiAlias (enable )};

// SetBorderOpacity sets the border opacity of the rectangle.
func (_bcba *Rectangle )SetBorderOpacity (opacity float64 ){_bcba ._ecfdd =opacity };

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_facde *TOC )SetLinePageStyle (style TextStyle ){_facde ._cdbed =style };

// SetBorderOpacity sets the border opacity of the ellipse.
func (_gggf *Ellipse )SetBorderOpacity (opacity float64 ){_gggf ._ffaeg =opacity };const (FitModeNone FitMode =iota ;FitModeFillWidth ;);func (_dgf *Block )setOpacity (_gcb float64 ,_cec float64 )(string ,error ){if (_gcb < 0||_gcb >=1.0)&&(_cec < 0||_cec >=1.0){return "",nil ;
};_abc :=0;_bc :=_a .Sprintf ("\u0047\u0053\u0025\u0064",_abc );for _dgf ._fb .HasExtGState (_bdg .PdfObjectName (_bc )){_abc ++;_bc =_a .Sprintf ("\u0047\u0053\u0025\u0064",_abc );};_cg :=_bdg .MakeDict ();if _gcb >=0&&_gcb < 1.0{_cg .Set ("\u0063\u0061",_bdg .MakeFloat (_gcb ));
};if _cec >=0&&_cec < 1.0{_cg .Set ("\u0043\u0041",_bdg .MakeFloat (_cec ));};_dac :=_dgf ._fb .AddExtGState (_bdg .PdfObjectName (_bc ),_cg );if _dac !=nil {return "",_dac ;};return _bc ,nil ;};

// SetSideBorderStyle sets the cell's side border style.
func (_cefed *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_cefed ._dafa =style ;_cefed ._dgdb =style ;_cefed ._ggae =style ;_cefed ._feeaf =style ;case CellBorderSideTop :_cefed ._dafa =style ;
case CellBorderSideBottom :_cefed ._dgdb =style ;case CellBorderSideLeft :_cefed ._ggae =style ;case CellBorderSideRight :_cefed ._feeaf =style ;};};

// ClearAnnotations clears any existing annotations.
func (_abab *TextChunk )ClearAnnotations (){_abab ._gfgcff =[]*_bdd .PdfAnnotation {}};

// TitleStyle returns the style properties used to render the invoice title.
func (_cbdc *Invoice )TitleStyle ()TextStyle {return _cbdc ._ggceg };

// InsertColumn inserts a column in the line items table at the specified index.
func (_cegc *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_fafe :=uint (len (_cegc ._abbcg ));if index > _fafe {index =_fafe ;};_fadfe :=_cegc .NewColumn (description );_cegc ._abbcg =append (_cegc ._abbcg [:index ],append ([]*InvoiceCell {_fadfe },_cegc ._abbcg [index :]...)...);
return _fadfe ;};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_ddaag *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbggd :=ctx ;var _ecbg []*Block ;_bagc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _ddaag ._abcfeg .IsRelative (){ctx .X +=_ddaag ._defec .Left ;ctx .Y +=_ddaag ._defec .Top ;
ctx .Width -=_ddaag ._defec .Left +_ddaag ._defec .Right ;ctx .Height -=_ddaag ._defec .Top ;_ddaag .SetWidth (ctx .Width );if _ddaag .Height ()> ctx .Height {_ecbg =append (_ecbg ,_bagc );_bagc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;
_cebbe :=ctx ;_cebbe .Y =ctx .Margins .Top ;_cebbe .X =ctx .Margins .Left +_ddaag ._defec .Left ;_cebbe .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_cebbe .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ddaag ._defec .Left -_ddaag ._defec .Right ;
ctx =_cebbe ;};}else {if int (_ddaag ._bbag )<=0{_ddaag .SetWidth (_ddaag .getTextWidth ());};ctx .X =_ddaag ._edac ;ctx .Y =_ddaag ._gadge ;};ctx ,_bgcaf :=_fbgfg (_bagc ,_ddaag ,ctx );if _bgcaf !=nil {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bgcaf );
return nil ,ctx ,_bgcaf ;};_ecbg =append (_ecbg ,_bagc );if _ddaag ._abcfeg .IsRelative (){ctx .Y +=_ddaag ._defec .Bottom ;ctx .Height -=_ddaag ._defec .Bottom ;if !ctx .Inline {ctx .X =_bbggd .X ;ctx .Width =_bbggd .Width ;};return _ecbg ,ctx ,nil ;};
return _ecbg ,_bbggd ,nil ;};func (_eggb *pageTransformations )transformPage (_ebde *_bdd .PdfPage )error {if _ddfe :=_eggb .applyFlip (_ebde );_ddfe !=nil {return _ddfe ;};return nil ;};

// SetMarkedContentID sets marked content ID.
func (_bcgc *GraphicSVG )SetMarkedContentID (mcid int64 )*_bdd .KDict {_bcgc ._bebf =&mcid ;_dcbc :=_bdd .NewKDictionary ();_dcbc .S =_bdg .MakeName (_bdd .StructureTypeFigure );_dcbc .K =_bdg .MakeInteger (mcid );return _dcbc ;};

// SetMarkedContentID sets the marked content ID.
func (_afef *PolyBezierCurve )SetMarkedContentID (mcid int64 )*_bdd .KDict {_afef ._adfag =&mcid ;_gdfc :=_bdd .NewKDictionary ();_gdfc .S =_bdg .MakeName (_bdd .StructureTypeFigure );_gdfc .K =_bdg .MakeInteger (mcid );return _gdfc ;};

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_aaba *Ellipse )ScaleToWidth (w float64 ){_dbfa :=_aaba ._cce /_aaba ._bfddf ;_aaba ._bfddf =w ;_aaba ._cce =w *_dbfa ;};

// Horizontal returns total horizontal (left + right) margin.
func (_cdeg *Margins )Horizontal ()float64 {return _cdeg .Left +_cdeg .Right };func _edcbf (_gfccd *_bdd .PdfRectangle ,_dgagc float64 )[4]_ebc .Point {_dfde :=_dgagc *_bd .Pi /180.0;_gcgdeg :=_gfccd .Width ();_abdf :=_gfccd .Height ();_cgbfac :=_bd .Sin (_dfde );
_gbcge :=_bd .Cos (_dfde );_bdgf :=[4]_ebc .Point {{X :_df .RoundFloat (_gfccd .Llx ,3),Y :_df .RoundFloat (_gfccd .Lly ,3)},{X :_df .RoundFloat (_gfccd .Llx +_gcgdeg *_gbcge ,3),Y :_df .RoundFloat (_gfccd .Lly +_gcgdeg *_cgbfac ,3)},{X :_df .RoundFloat (_gfccd .Llx +_gcgdeg *_gbcge -_abdf *_cgbfac ,3),Y :_df .RoundFloat (_gfccd .Lly +_gcgdeg *_cgbfac +_abdf *_gbcge ,3)},{X :_df .RoundFloat (_gfccd .Llx -_abdf *_cgbfac ,3),Y :_df .RoundFloat (_gfccd .Lly +_abdf *_gbcge ,3)}};
return _bdgf ;};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_aceb *LinearShading )SetBackgroundColor (backgroundColor Color ){_aceb ._bdbcd .SetBackgroundColor (backgroundColor );};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_ggdb *Creator )Finalize ()error {if _ggdb ._ecc {return nil ;};_dbeb :=len (_ggdb ._bcdf );_daae :=0;if _ggdb ._edd !=nil {_aggd :=*_ggdb ;_ggdb ._bcdf =nil ;_ggdb ._agbc =nil ;_ggdb .initContext ();_cgdf :=FrontpageFunctionArgs {PageNum :1,TotalPages :_dbeb };
_ggdb ._edd (_cgdf );_daae +=len (_ggdb ._bcdf );_ggdb ._bcdf =_aggd ._bcdf ;_ggdb ._agbc =_aggd ._agbc ;};if _ggdb .AddTOC {_ggdb .initContext ();_ggdb ._ebce .Page =_daae +1;if _ggdb .CustomTOC &&_ggdb ._gde !=nil {_ggef :=*_ggdb ;_ggdb ._bcdf =nil ;
_ggdb ._agbc =nil ;if _fbff :=_ggdb ._gde (_ggdb ._fgde );_fbff !=nil {return _fbff ;};_daae +=len (_ggdb ._bcdf );_ggdb ._bcdf =_ggef ._bcdf ;_ggdb ._agbc =_ggef ._agbc ;}else {if _ggdb ._gde !=nil {if _aga :=_ggdb ._gde (_ggdb ._fgde );_aga !=nil {return _aga ;
};};_fgce ,_ ,_dbda :=_ggdb ._fgde .GeneratePageBlocks (_ggdb ._ebce );if _dbda !=nil {_da .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_dbda );
return _dbda ;};_daae +=len (_fgce );};_cdeb :=_ggdb ._fgde .Lines ();for _ ,_gfcf :=range _cdeb {_cfd ,_gdaab :=_eb .Atoi (_gfcf .Page .Text );if _gdaab !=nil {continue ;};_gfcf .Page .Text =_eb .Itoa (_cfd +_daae );_gfcf ._ddbe +=int64 (_daae );};};_cgf :=false ;
var _ccgb []*_bdd .PdfPage ;if _ggdb ._edd !=nil {_bca :=*_ggdb ;_ggdb ._bcdf =nil ;_ggdb ._agbc =nil ;_fffc :=FrontpageFunctionArgs {PageNum :1,TotalPages :_dbeb };_ggdb ._edd (_fffc );_dbeb +=len (_ggdb ._bcdf );_ccgb =_ggdb ._bcdf ;_ggdb ._bcdf =append (_ggdb ._bcdf ,_bca ._bcdf ...);
_ggdb ._agbc =_bca ._agbc ;_cgf =true ;};var _dfd []*_bdd .PdfPage ;if _ggdb .AddTOC {_ggdb .initContext ();if _ggdb .CustomTOC &&_ggdb ._gde !=nil {_bfac :=*_ggdb ;_ggdb ._bcdf =nil ;_ggdb ._agbc =nil ;if _bde :=_ggdb ._gde (_ggdb ._fgde );_bde !=nil {_da .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_bde );
return _bde ;};_dfd =_ggdb ._bcdf ;_dbeb +=len (_dfd );_ggdb ._bcdf =_bfac ._bcdf ;_ggdb ._agbc =_bfac ._agbc ;}else {if _ggdb ._gde !=nil {if _ggec :=_ggdb ._gde (_ggdb ._fgde );_ggec !=nil {_da .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_ggec );
return _ggec ;};};_addb ,_ ,_ :=_ggdb ._fgde .GeneratePageBlocks (_ggdb ._ebce );for _ ,_afbed :=range _addb {_afbed .SetPos (0,0);_dbeb ++;_aeabg :=_ggdb .newPage ();_dfd =append (_dfd ,_aeabg );_ggdb .setActivePage (_aeabg );_ggdb .Draw (_afbed );};};
if _cgf {_fdcb :=_ccgb ;_cega :=_ggdb ._bcdf [len (_ccgb ):];_ggdb ._bcdf =append ([]*_bdd .PdfPage {},_fdcb ...);_ggdb ._bcdf =append (_ggdb ._bcdf ,_dfd ...);_ggdb ._bcdf =append (_ggdb ._bcdf ,_cega ...);}else {_ggdb ._bcdf =append (_dfd ,_ggdb ._bcdf ...);
};};if _ggdb ._bgce !=nil &&_ggdb .AddOutlines {var _geea func (_cafc *_bdd .OutlineItem );_geea =func (_gbdd *_bdd .OutlineItem ){_gbdd .Dest .Page +=int64 (_daae );if _cecd :=int (_gbdd .Dest .Page );_cecd >=0&&_cecd < len (_ggdb ._bcdf ){_gbdd .Dest .PageObj =_ggdb ._bcdf [_cecd ].GetPageAsIndirectObject ();
}else {_da .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_cecd );
};_gbdd .Dest .Y =_ggdb ._adfe -_gbdd .Dest .Y ;_fdfg :=_gbdd .Items ();for _ ,_aae :=range _fdfg {_geea (_aae );};};_gcef :=_ggdb ._bgce .Items ();for _ ,_decf :=range _gcef {_geea (_decf );};if _ggdb .AddTOC {var _cfab int ;if _cgf {_cfab =len (_ccgb );
};_befg :=_bdd .NewOutlineDest (int64 (_cfab ),0,_ggdb ._adfe );if _cfab >=0&&_cfab < len (_ggdb ._bcdf ){_befg .PageObj =_ggdb ._bcdf [_cfab ].GetPageAsIndirectObject ();}else {_da .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_cfab );
};_ggdb ._bgce .Insert (0,_bdd .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_befg ));};};for _fdg ,_fdfa :=range _ggdb ._bcdf {_ggdb .setActivePage (_fdfa );if _ggdb ._bbd !=nil {_gfgd ,_gdad ,_eegb :=_fdfa .Size ();
if _eegb !=nil {return _eegb ;};_cge :=PageFinalizeFunctionArgs {PageNum :_fdg +1,PageWidth :_gfgd ,PageHeight :_gdad ,TOCPages :len (_dfd ),TotalPages :_dbeb };if _cddb :=_ggdb ._bbd (_cge );_cddb !=nil {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_cddb );
return _cddb ;};};if _ggdb ._cfe !=nil {_befgb :=NewBlock (_ggdb ._bccc ,_ggdb ._ebcd .Top );_cafg :=HeaderFunctionArgs {PageNum :_fdg +1,TotalPages :_dbeb };_ggdb ._cfe (_befgb ,_cafg );_befgb .SetPos (0,0);if _dcgd :=_ggdb .Draw (_befgb );_dcgd !=nil {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_dcgd );
return _dcgd ;};};if _ggdb ._cacg !=nil {_bgcc :=NewBlock (_ggdb ._bccc ,_ggdb ._ebcd .Bottom );_dedg :=FooterFunctionArgs {PageNum :_fdg +1,TotalPages :_dbeb };_ggdb ._cacg (_bgcc ,_dedg );_bgcc .SetPos (0,_ggdb ._adfe -_bgcc ._cb );if _gbde :=_ggdb .Draw (_bgcc );
_gbde !=nil {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_gbde );return _gbde ;};};_edcad ,_aaea :=_ggdb ._acff [_fdfa ];if _daag ,_ebge :=_ggdb ._dbce [_fdfa ];
_ebge {if _aaea {_edcad .transformBlock (_daag );};if _eddg :=_daag .drawToPage (_fdfa );_eddg !=nil {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_fdg +1,_eddg );
return _eddg ;};};if _aaea {if _gdae :=_edcad .transformPage (_fdfa );_gdae !=nil {_da .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_gdae );
return _gdae ;};};};_ggdb ._ecc =true ;return nil ;};

// NewInvoice returns an instance of an empty invoice.
func (_ebcb *Creator )NewInvoice ()*Invoice {_gfb :=_ebcb .NewTextStyle ();_gfb .Font =_ebcb ._bbaf ;return _cffa (_ebcb .NewTextStyle (),_gfb );};

// TextAlignment options for paragraph.
type TextAlignment int ;func (_fagcb *StyledParagraph )wrapText ()error {return _fagcb .wrapChunks (true )};

// SetBorderWidth sets the border width.
func (_cccg *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_cccg ._edaef .BorderWidth =borderWidth ;};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_feeaa *Table )EnableRowWrap (enable bool ){_feeaa ._fbab =enable };

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_fece *GraphicSVG )ScaleToWidth (w float64 ){_aafa :=_fece ._bac .Height /_fece ._bac .Width ;_fece ._bac .Width =w ;_fece ._bac .Height =w *_aafa ;_fece ._bac .SetScaling (_aafa ,_aafa );};

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_agef *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _dcgdf (x ,y ,width ,height );};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_ecebc *Invoice )TotalLines ()[][2]*InvoiceCell {_bbcf :=[][2]*InvoiceCell {_ecebc ._cfgg };_bbcf =append (_bbcf ,_ecebc ._fbce ...);return append (_bbcf ,_ecebc ._afgg );};func (_dfcfd *templateProcessor )parseFontAttr (_afefe ,_bfadd string )*_bdd .PdfFont {_da .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_afefe ,_bfadd );
_bedfd :=_dfcfd .creator ._abb ;if _bfadd ==""{return _bedfd ;};_bfccg :=_fa .Split (_bfadd ,"\u002c");for _ ,_cggbbe :=range _bfccg {_cggbbe =_fa .TrimSpace (_cggbbe );if _cggbbe ==""{continue ;};_ggfca ,_fgeeg :=_dfcfd ._cggc .FontMap [_bfadd ];if _fgeeg {return _ggfca ;
};_ccaeb ,_fgeeg :=map[string ]_bdd .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_bdd .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_bdd .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_bdd .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_bdd .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_bdd .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_bdd .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_bdd .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_bdd .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_bdd .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_bdd .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_bdd .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_bdd .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_bdd .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_bdd .TimesBoldItalicName }[_bfadd ];
if _fgeeg {if _ddgcg ,_ecgbg :=_bdd .NewStandard14Font (_ccaeb );_ecgbg ==nil {return _ddgcg ;};};if _gfbda :=_dfcfd .parseAttrPropList (_cggbbe );len (_gfbda )> 0{if _ecfc ,_ccgac :=_gfbda ["\u0070\u0061\u0074\u0068"];_ccgac {_egegaa :=_bdd .NewPdfFontFromTTFFile ;
if _dfcc ,_fcbgg :=_gfbda ["\u0074\u0079\u0070\u0065"];_fcbgg &&_dfcc =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_egegaa =_bdd .NewCompositePdfFontFromTTFFile ;};if _gacd ,_abdb :=_egegaa (_ecfc );_abdb !=nil {_da .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_ecfc ,_abdb );
}else {return _gacd ;};};};};return _bedfd ;};

// Style returns the style of the line.
func (_ffea *Line )Style ()_ebc .LineStyle {return _ffea ._cbeb };

// SetFillColor sets the fill color.
func (_gcdbf *PolyBezierCurve )SetFillColor (color Color ){_gcdbf ._fabcgb =color ;_gcdbf ._edaef .FillColor =_ddfd (color );};

// SetColPosition sets cell column position.
func (_ffee *TableCell )SetColPosition (col int ){_ffee ._gacfd =col };func _eccc (_cacfc *templateProcessor ,_afbfg *templateNode )(interface{},error ){return _cacfc .parseChapterHeading (_afbfg );};

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_cedcd *StyledParagraph )SetLanguageIdentifier (id string ){_cedcd ._cede =id };

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_edgg *Chart )Width ()float64 {return float64 (_edgg ._efbgc .Width ())};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_dgada *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_deag []*Block ;_acfa =NewBlock (ctx .PageWidth ,ctx .PageHeight );_affe =ctx ;_bfgda =_dgada ._agad /2;);_fgcc :=_dgada ._dgdf .IsRelative ();if _fgcc {_dgada .applyFitMode (ctx .Width );
ctx .X +=_dgada ._abae .Left +_bfgda ;ctx .Y +=_dgada ._abae .Top +_bfgda ;ctx .Width -=_dgada ._abae .Left +_dgada ._abae .Right ;ctx .Height -=_dgada ._abae .Top +_dgada ._abae .Bottom ;if _dgada ._bbae > ctx .Height {_deag =append (_deag ,_acfa );_acfa =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_beda :=ctx ;_beda .Y =ctx .Margins .Top +_dgada ._abae .Top +_bfgda ;_beda .X =ctx .Margins .Left +_dgada ._abae .Left +_bfgda ;_beda .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_dgada ._abae .Top -_dgada ._abae .Bottom ;
_beda .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dgada ._abae .Left -_dgada ._abae .Right ;ctx =_beda ;};}else {ctx .X =_dgada ._cbcfa ;ctx .Y =_dgada ._ffdf ;};_dbdc :=_ebc .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_dgada ._bbae ,Width :_dgada ._efdd ,Height :_dgada ._bbae ,BorderRadiusTopLeft :_dgada ._dbdd ,BorderRadiusTopRight :_dgada ._ebfg ,BorderRadiusBottomLeft :_dgada ._bbcg ,BorderRadiusBottomRight :_dgada ._defaa ,Opacity :1.0};
if _dgada ._ddgb !=nil {_dbdc .FillEnabled =true ;_fcgf :=_ddfd (_dgada ._ddgb );_acad :=_fcgdf (_acfa ,_fcgf ,_dgada ._ddgb ,func ()Rectangle {return Rectangle {_cbcfa :_dbdc .X ,_ffdf :_dbdc .Y ,_efdd :_dbdc .Width ,_bbae :_dbdc .Height };});if _acad !=nil {return nil ,ctx ,_acad ;
};_dbdc .FillColor =_fcgf ;};if _dgada ._egbf !=nil &&_dgada ._agad > 0{_dbdc .BorderEnabled =true ;_dbdc .BorderColor =_ddfd (_dgada ._egbf );_dbdc .BorderWidth =_dgada ._agad ;};_fega ,_adcfdf :=_acfa .setOpacity (_dgada ._cdebe ,_dgada ._ecfdd );if _adcfdf !=nil {return nil ,ctx ,_adcfdf ;
};_cfedd ,_ ,_adcfdf :=_dbdc .MarkedDraw (_fega ,_dgada ._ebadc );if _adcfdf !=nil {return nil ,ctx ,_adcfdf ;};if _adcfdf =_acfa .addContentsByString (string (_cfedd ));_adcfdf !=nil {return nil ,ctx ,_adcfdf ;};if _fgcc {ctx .X =_affe .X ;ctx .Width =_affe .Width ;
_cbddb :=_dgada ._bbae +_bfgda ;ctx .Y +=_cbddb +_dgada ._abae .Bottom ;ctx .Height -=_cbddb ;}else {ctx =_affe ;};_deag =append (_deag ,_acfa );return _deag ,ctx ,nil ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_faa *Chapter )GetHeading ()*Paragraph {return _faa ._ccbe };func _dbdca (_ggdgf float64 ,_daeege float64 )float64 {return _bd .Round (_ggdgf /_daeege )*_daeege };

// Insert adds a new text chunk at the specified position in the paragraph.
func (_bddge *StyledParagraph )Insert (index uint ,text string )*TextChunk {_eefef :=uint (len (_bddge ._adebd ));if index > _eefef {index =_eefef ;};_eddcd :=NewTextChunk (text ,_bddge ._bgge );_bddge ._adebd =append (_bddge ._adebd [:index ],append ([]*TextChunk {_eddcd },_bddge ._adebd [index :]...)...);
_bddge .wrapText ();return _eddcd ;};

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_gfbd *Rectangle )SetPositioning (position Positioning ){_gfbd ._dgdf =position };

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_dddc *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_aaafce :=[2]*InvoiceCell {_dddc .newCell (description ,_dddc ._dadd ),_dddc .newCell (value ,_dddc ._dadd )};_dddc ._beeae =append (_dddc ._beeae ,_aaafce );return _aaafce [0],_aaafce [1];
};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_ddcc *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_ddcc ._gff .Left =left ;_ddcc ._gff .Right =right ;_ddcc ._gff .Top =top ;_ddcc ._gff .Bottom =bottom ;};func _febba (_cfdgf *templateProcessor ,_bgedee *templateNode )(interface{},error ){return _cfdgf .parseTextChunk (_bgedee ,nil );
};func (_fcegb *InvoiceAddress )fmtLine (_dbac ,_acbd string ,_ffgg bool )string {if _ffgg {_acbd ="";};return _a .Sprintf ("\u0025\u0073\u0025s\u000a",_acbd ,_dbac );};

// SetMargins sets the Paragraph's margins.
func (_gbbe *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_gbbe ._defec .Left =left ;_gbbe ._defec .Right =right ;_gbbe ._defec .Top =top ;_gbbe ._defec .Bottom =bottom ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_dfec *Invoice )SetTerms (title ,content string ){_dfec ._ggbee =[2]string {title ,content }};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_gbefg *List )Width ()float64 {return 0};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);func (_ecff *Rectangle )applyFitMode (_acga float64 ){_acga -=_ecff ._abae .Left +_ecff ._abae .Right +_ecff ._agad ;switch _ecff ._efbdd {case FitModeFillWidth :_ecff .ScaleToWidth (_acga );
};};type shading struct{_ddec Color ;_faga bool ;_agda []bool ;_decd []*ColorPoint ;};func (_dgde *Invoice )generateHeaderBlocks (_edge DrawContext )([]*Block ,DrawContext ,error ){_bdea :=_accf (_dgde ._ggceg );_bdea .SetEnableWrap (true );_bdea .Append (_dgde ._cbgeg );
_agac :=_fbcee (2);if _dgde ._ddac !=nil {_adeb :=_agac .NewCell ();_adeb .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_adeb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_adeb .SetIndent (0);_adeb .SetContent (_dgde ._ddac );_dgde ._ddac .ScaleToHeight (_bdea .Height ()+20);
}else {_agac .SkipCells (1);};_egcf :=_agac .NewCell ();_egcf .SetHorizontalAlignment (CellHorizontalAlignmentRight );_egcf .SetVerticalAlignment (CellVerticalAlignmentMiddle );_egcf .SetContent (_bdea );return _agac .GeneratePageBlocks (_edge );};

// NewCurvePolygon creates a new curve polygon.
func (_bag *Creator )NewCurvePolygon (rings [][]_ebc .CubicBezierCurve )*CurvePolygon {return _acce (rings );};

// String implements error interface.
func (_dbgd UnsupportedRuneError )Error ()string {return _dbgd .Message };func (_dbga *Division )drawBackground (_egffe []*Block ,_ddfg ,_ccbb DrawContext ,_cbdd bool )([]*Block ,error ){_ecebd :=len (_egffe );if _ecebd ==0||_dbga ._accgd ==nil {return _egffe ,nil ;
};_ggee :=make ([]*Block ,0,len (_egffe ));for _cefe ,_ggcf :=range _egffe {var (_fgbaa =_dbga ._accgd .BorderRadiusTopLeft ;_bbbd =_dbga ._accgd .BorderRadiusTopRight ;_fbfa =_dbga ._accgd .BorderRadiusBottomLeft ;_ggdf =_dbga ._accgd .BorderRadiusBottomRight ;
);_gbdgf :=_ddfg ;_gbdgf .Page +=_cefe ;if _cefe ==0{if _cbdd {_ggee =append (_ggee ,_ggcf );continue ;};if _ecebd ==1{_gbdgf .Height =_ccbb .Y -_ddfg .Y ;};}else {_gbdgf .X =_gbdgf .Margins .Left +_dbga ._egba .Left ;_gbdgf .Y =_gbdgf .Margins .Top ;_gbdgf .Width =_gbdgf .PageWidth -_gbdgf .Margins .Left -_gbdgf .Margins .Right -_dbga ._egba .Left -_dbga ._egba .Right ;
if _cefe ==_ecebd -1{_gbdgf .Height =_ccbb .Y -_gbdgf .Margins .Top -_dbga ._egba .Top ;}else {_gbdgf .Height =_gbdgf .PageHeight -_gbdgf .Margins .Top -_gbdgf .Margins .Bottom ;};if !_cbdd {_fgbaa =0;_bbbd =0;};};if _ecebd > 1&&_cefe !=_ecebd -1{_fbfa =0;
_ggdf =0;};_ggegb :=_dcgdf (_gbdgf .X ,_gbdgf .Y ,_gbdgf .Width ,_gbdgf .Height );_ggegb .SetFillColor (_dbga ._accgd .FillColor );_ggegb .SetBorderColor (_dbga ._accgd .BorderColor );_ggegb .SetBorderWidth (_dbga ._accgd .BorderSize );_ggegb .SetBorderRadius (_fgbaa ,_bbbd ,_fbfa ,_ggdf );
_gggb ,_ ,_eecb :=_ggegb .GeneratePageBlocks (_gbdgf );if _eecb !=nil {return nil ,_eecb ;};if len (_gggb )==0{continue ;};_gdff :=_gggb [0];if _eecb =_gdff .mergeBlocks (_ggcf );_eecb !=nil {return nil ,_eecb ;};_ggee =append (_ggee ,_gdff );};return _ggee ,nil ;
};

// SetMakeredContentID sets the marked content identifier for the ellipse.
func (_afbg *Ellipse )SetMarkedContentID (mcid int64 )*_bdd .KDict {_afbg ._fgbf =&mcid ;_fbag :=_bdd .NewKDictionary ();_fbag .S =_bdg .MakeName (_bdd .StructureTypeFigure );_fbag .K =_bdg .MakeInteger (mcid );return _fbag ;};func _agcc (_ggfc ,_fcee ,_bafe ,_cafa ,_adef ,_fcbc float64 )*Curve {_cddc :=&Curve {};
_cddc ._edgc =_ggfc ;_cddc ._cfdd =_fcee ;_cddc ._decg =_bafe ;_cddc ._ebeb =_cafa ;_cddc ._fde =_adef ;_cddc ._dgg =_fcbc ;_cddc ._aage =ColorBlack ;_cddc ._cdf =1.0;return _cddc ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_gege *Invoice )SetColumns (cols []*InvoiceCell ){_gege ._abbcg =cols };func (_gfcge *templateProcessor )parseInt64Attr (_gbgb ,_cadbd string )int64 {_da .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_gbgb ,_cadbd );
_aefgb ,_ :=_eb .ParseInt (_cadbd ,10,64);return _aefgb ;};

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_faab *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _faab ._gcbd .Left ,_faab ._gcbd .Right ,_faab ._gcbd .Top ,_faab ._gcbd .Bottom ;};

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_dfgb *Rectangle )ScaleToWidth (w float64 ){_bfgg :=_dfgb ._bbae /_dfgb ._efdd ;_dfgb ._efdd =w ;_dfgb ._bbae =w *_bfgg ;};

// SetBorderRadius sets the radius of the background corners.
func (_dg *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_dg .BorderRadiusTopLeft =topLeft ;_dg .BorderRadiusTopRight =topRight ;_dg .BorderRadiusBottomLeft =bottomLeft ;_dg .BorderRadiusBottomRight =bottomRight ;};

// SetStyleTop sets border style for top side.
func (_eff *border )SetStyleTop (style CellBorderStyle ){_eff ._edbe =style };func (_aecca *templateProcessor )parseHorizontalAlignmentAttr (_gffg ,_fecae string )HorizontalAlignment {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_gffg ,_fecae );
_bada :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_fecae ];return _bada ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_fgbg *Creator )NewTextStyle ()TextStyle {return _cdcbe (_fgbg ._abb )};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_defc *Chart )SetPos (x ,y float64 ){_defc ._fae =PositionAbsolute ;_defc ._gcbc =x ;_defc ._fda =y ;};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_abdc *List )Marker ()*TextChunk {return &_abdc ._fdbb };

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ae *_ee .ContentStreamOperations ;_fb *_bdd .PdfPageResources ;_ce Positioning ;_ed ,_dfa float64 ;_ccb float64 ;_cb float64 ;_daa float64 ;_edg Margins ;_ceg []*_bdd .PdfAnnotation ;};

// SetFillColor sets the fill color.
func (_bfab *CurvePolygon )SetFillColor (color Color ){_bfab ._eabcg =color ;_bfab ._gfd .FillColor =_ddfd (color );};func (_dfgaa *templateProcessor )parseBoolAttr (_bagdg ,_gdedd string )bool {_da .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_bagdg ,_gdedd );
_ffdfd ,_ :=_eb .ParseBool (_gdedd );return _gdedd ==""||_ffdfd ;};func (_ecea *Paragraph )getMaxLineWidth ()float64 {if _ecea ._fcffe ==nil ||(_ecea ._fcffe !=nil &&len (_ecea ._fcffe )==0){_ecea .wrapText ();};var _cccd float64 ;for _ ,_abcg :=range _ecea ._fcffe {_acda :=_ecea .getTextLineWidth (_abcg );
if _acda > _cccd {_cccd =_acda ;};};return _cccd ;};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_bbad *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_cgcc :=range subtable ._eafe {_ddda :=&TableCell {};*_ddda =*_cgcc ;_ddda ._bdffe =_bbad ;_ddda ._gacfd +=col -1;if _eadbf :=_bbad ._ccdbbe -(_ddda ._gacfd -1);_eadbf < _ddda ._decgd {_bbad ._ccdbbe +=_ddda ._decgd -_eadbf ;
_bbad .resetColumnWidths ();_da .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_bbad ._ccdbbe );
};_ddda ._deba +=row -1;_aabg :=subtable ._abfdc [_cgcc ._deba -1];if _ddda ._deba > _bbad ._adfc {for _ddda ._deba > _bbad ._adfc {_bbad ._adfc ++;_bbad ._abfdc =append (_bbad ._abfdc ,_bbad ._afdg );};_bbad ._abfdc [_ddda ._deba -1]=_aabg ;}else {_bbad ._abfdc [_ddda ._deba -1]=_bd .Max (_bbad ._abfdc [_ddda ._deba -1],_aabg );
};_bbad ._eafe =append (_bbad ._eafe ,_ddda );};_bbad .sortCells ();};

// GeneratePageBlocks draws the chart onto a block.
func (_fgba *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fbcg :=ctx ;_bebc :=_fgba ._fae .IsRelative ();var _dcbd []*Block ;if _bebc {_bba :=1.0;_ggcg :=_fgba ._ccae .Top ;if float64 (_fgba ._efbgc .Height ())> ctx .Height -_fgba ._ccae .Top {_dcbd =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _bcg error ;if _ ,ctx ,_bcg =_ffdbg ().GeneratePageBlocks (ctx );_bcg !=nil {return nil ,ctx ,_bcg ;};_ggcg =0;};ctx .X +=_fgba ._ccae .Left +_bba ;ctx .Y +=_ggcg ;ctx .Width -=_fgba ._ccae .Left +_fgba ._ccae .Right +2*_bba ;ctx .Height -=_ggcg ;_fgba ._efbgc .SetWidth (int (ctx .Width ));
}else {ctx .X =_fgba ._gcbc ;ctx .Y =_fgba ._fda ;};_eea :=_ee .NewContentCreator ();if _fgba ._edca !=nil {_eea .Add_BDC (*_bdg .MakeName (_bdd .StructureTypeFigure ),map[string ]_bdg .PdfObject {"\u004d\u0043\u0049\u0044":_bdg .MakeInteger (*_fgba ._edca )});
};_eea .Translate (0,ctx .PageHeight );_eea .Scale (1,-1);_eea .Translate (ctx .X ,ctx .Y );_aca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fgba ._efbgc .Render (_de .NewRenderer (_eea ,_aca ._fb ),nil );if _fgba ._edca !=nil {_eea .Add_EMC ();};if _fbcd :=_aca .addContentsByString (_eea .String ());
_fbcd !=nil {return nil ,ctx ,_fbcd ;};if _bebc {_fbea :=_fgba .Height ()+_fgba ._ccae .Bottom ;ctx .Y +=_fbea ;ctx .Height -=_fbea ;}else {ctx =_fbcg ;};_dcbd =append (_dcbd ,_aca );return _dcbd ,ctx ,nil ;};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_ceea *Creator )AddPage (page *_bdd .PdfPage )error {_ggdc ,_gbf :=_ceea .wrapPageIfNeeded (page );if _gbf !=nil {return _gbf ;};if _ggdc !=nil {page =_ggdc ;};_ddd ,_gbf :=page .GetMediaBox ();if _gbf !=nil {_da .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_gbf );
return _gbf ;};_ddd .Normalize ();_efeee ,_bdde :=_ddd .Llx ,_ddd .Lly ;_aaabb :=_ddd ;if _egbd :=page .CropBox ;_egbd !=nil &&*_egbd !=*_ddd {_egbd .Normalize ();_efeee ,_bdde =_egbd .Llx ,_egbd .Lly ;_aaabb =_egbd ;};_addaf :=_gc .IdentityMatrix ();_bbg ,_gbf :=page .GetRotate ();
if _gbf !=nil {_da .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_gbf .Error ());
};_aag :=_bbg %360!=0&&_bbg %90==0;if _aag {_eceb :=float64 ((360+_bbg %360)%360);if _eceb ==90{_addaf =_addaf .Translate (_aaabb .Width (),0);}else if _eceb ==180{_addaf =_addaf .Translate (_aaabb .Width (),_aaabb .Height ());}else if _eceb ==270{_addaf =_addaf .Translate (0,_aaabb .Height ());
};_addaf =_addaf .Mult (_gc .RotationMatrix (_eceb *_bd .Pi /180));_addaf =_addaf .Round (0.000001);_aaga :=_cecca (_aaabb ,_addaf );_aaabb =_aaga ;_aaabb .Normalize ();};if _efeee !=0||_bdde !=0{_addaf =_gc .TranslationMatrix (_efeee ,_bdde ).Mult (_addaf );
};if !_addaf .Identity (){_addaf =_addaf .Round (0.000001);_ceea ._acff [page ]=&pageTransformations {_ggg :&_addaf };};_ceea ._bccc =_aaabb .Width ();_ceea ._adfe =_aaabb .Height ();_ceea .initContext ();_ceea ._bcdf =append (_ceea ._bcdf ,page );_ceea ._ebce .Page ++;
return nil ;};

// SetLineWidth sets the line width.
func (_acdd *Line )SetLineWidth (width float64 ){_acdd ._dedd =width };

// AddHighlightedText adds a new highlighted text to the paragraph.
func (_ffcgf *StyledParagraph )AddHighlightedText (text string ,color Color ,alpha float64 )*TextChunk {_bgeg :=NewTextChunk (text ,_ffcgf ._bgge );_bgeg .Highlight (color ,alpha );return _ffcgf .appendChunk (_bgeg );};func _geeea (_dabf TextStyle )*List {return &List {_fdbb :TextChunk {Text :"\u2022\u0020",Style :_dabf },_ccgdf :0,_fgea :true ,_cfggg :PositionRelative ,_eacd :_dabf };
};

// Positioning returns the type of positioning the rectangle is set to use.
func (_dgaf *Rectangle )Positioning ()Positioning {return _dgaf ._dgdf };func (_efded *templateProcessor )parseFloatAttr (_gfdbf ,_dcbba string )float64 {_da .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_gfdbf ,_dcbba );
_cade ,_ :=_eb .ParseFloat (_dcbba ,64);return _cade ;};func _fgcad (_fdeeg *_g .Decoder )(int ,int ){return 0,0};

// BorderColor returns the border color of the rectangle.
func (_becee *Rectangle )BorderColor ()Color {return _becee ._egbf };func (_cfgc *RadialShading )shadingModel ()*_bdd .PdfShadingType3 {_egfce ,_fdcdc ,_cfec :=_cfgc ._eddc ._ddec .ToRGB ();var _bfeeg _ebc .Point ;switch _cfgc ._eggc {case AnchorBottomLeft :_bfeeg =_ebc .Point {X :_cfgc ._bfefc .Llx ,Y :_cfgc ._bfefc .Lly };
case AnchorBottomRight :_bfeeg =_ebc .Point {X :_cfgc ._bfefc .Urx ,Y :_cfgc ._bfefc .Ury -_cfgc ._bfefc .Height ()};case AnchorTopLeft :_bfeeg =_ebc .Point {X :_cfgc ._bfefc .Llx ,Y :_cfgc ._bfefc .Lly +_cfgc ._bfefc .Height ()};case AnchorTopRight :_bfeeg =_ebc .Point {X :_cfgc ._bfefc .Urx ,Y :_cfgc ._bfefc .Ury };
case AnchorLeft :_bfeeg =_ebc .Point {X :_cfgc ._bfefc .Llx ,Y :_cfgc ._bfefc .Lly +_cfgc ._bfefc .Height ()/2};case AnchorTop :_bfeeg =_ebc .Point {X :_cfgc ._bfefc .Llx +_cfgc ._bfefc .Width ()/2,Y :_cfgc ._bfefc .Ury };case AnchorRight :_bfeeg =_ebc .Point {X :_cfgc ._bfefc .Urx ,Y :_cfgc ._bfefc .Lly +_cfgc ._bfefc .Height ()/2};
case AnchorBottom :_bfeeg =_ebc .Point {X :_cfgc ._bfefc .Urx +_cfgc ._bfefc .Width ()/2,Y :_cfgc ._bfefc .Lly };default:_bfeeg =_ebc .NewPoint (_cfgc ._bfefc .Llx +_cfgc ._bfefc .Width ()/2,_cfgc ._bfefc .Lly +_cfgc ._bfefc .Height ()/2);};_ceafc :=_cfgc ._beaef ;
_ffad :=_cfgc ._dgefe ;_gbbc :=_bfeeg .X +_cfgc ._cedaa ;_fdeg :=_bfeeg .Y +_cfgc ._dbbe ;if _ceafc ==-1.0{_ceafc =0.0;};if _ffad ==-1.0{var _cdebd []float64 ;_bdeb :=_bd .Pow (_gbbc -_cfgc ._bfefc .Llx ,2)+_bd .Pow (_fdeg -_cfgc ._bfefc .Lly ,2);_cdebd =append (_cdebd ,_bd .Abs (_bdeb ));
_ebede :=_bd .Pow (_gbbc -_cfgc ._bfefc .Llx ,2)+_bd .Pow (_cfgc ._bfefc .Lly +_cfgc ._bfefc .Height ()-_fdeg ,2);_cdebd =append (_cdebd ,_bd .Abs (_ebede ));_fadgc :=_bd .Pow (_cfgc ._bfefc .Urx -_gbbc ,2)+_bd .Pow (_fdeg -_cfgc ._bfefc .Ury -_cfgc ._bfefc .Height (),2);
_cdebd =append (_cdebd ,_bd .Abs (_fadgc ));_fged :=_bd .Pow (_cfgc ._bfefc .Urx -_gbbc ,2)+_bd .Pow (_cfgc ._bfefc .Ury -_fdeg ,2);_cdebd =append (_cdebd ,_bd .Abs (_fged ));_e .Slice (_cdebd ,func (_cfca ,_dabdd int )bool {return _cfca > _dabdd });_ffad =_bd .Sqrt (_cdebd [0]);
};_dccc :=&_bdd .PdfRectangle {Llx :_gbbc -_ffad ,Lly :_fdeg -_ffad ,Urx :_gbbc +_ffad ,Ury :_fdeg +_ffad };_cfag :=_bdd .NewPdfShadingType3 ();_cfag .PdfShading .ShadingType =_bdg .MakeInteger (3);_cfag .PdfShading .ColorSpace =_bdd .NewPdfColorspaceDeviceRGB ();
_cfag .PdfShading .Background =_bdg .MakeArrayFromFloats ([]float64 {_egfce ,_fdcdc ,_cfec });_cfag .PdfShading .BBox =_dccc ;_cfag .PdfShading .AntiAlias =_bdg .MakeBool (_cfgc ._eddc ._faga );_cfag .Coords =_bdg .MakeArrayFromFloats ([]float64 {_gbbc ,_fdeg ,_ceafc ,_gbbc ,_fdeg ,_ffad });
_cfag .Domain =_bdg .MakeArrayFromFloats ([]float64 {0.0,1.0});_cfag .Extend =_bdg .MakeArray (_bdg .MakeBool (_cfgc ._eddc ._agda [0]),_bdg .MakeBool (_cfgc ._eddc ._agda [1]));_cfag .Function =_cfgc ._eddc .generatePdfFunctions ();return _cfag ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_bgeda *Paragraph )Height ()float64 {_bgeda .wrapText ();return float64 (len (_bgeda ._fcffe ))*_bgeda ._gfaa *_bgeda ._ccdc ;};

// SetTotal sets the total of the invoice.
func (_ddfc *Invoice )SetTotal (value string ){_ddfc ._afgg [1].Value =value };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};func _bbdd (_faff ,_badag interface{})(interface{},error ){_fdbfe ,_eeede :=_bdddd (_faff );if _eeede !=nil {return nil ,_eeede ;};switch _cdbeb :=_fdbfe .(type ){case int64 :_bggab ,_fccb :=_bdddd (_badag );if _fccb !=nil {return nil ,_fccb ;
};switch _fccbg :=_bggab .(type ){case int64 :return _cdbeb +_fccbg ,nil ;case float64 :return float64 (_cdbeb )+_fccbg ,nil ;};case float64 :_fbcgf ,_caca :=_bdddd (_badag );if _caca !=nil {return nil ,_caca ;};switch _dbbd :=_fbcgf .(type ){case int64 :return _cdbeb +float64 (_dbbd ),nil ;
case float64 :return _cdbeb +_dbbd ,nil ;};};return nil ,_a .Errorf ("\u0066\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0025\u0076\u0020\u0061\u006e\u0064\u0020\u0025\u0076",_faff ,_badag );};

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_abdee *Line )Width ()float64 {return _bd .Abs (_abdee ._cbdf -_abdee ._bcff )};func (_bdfeg *templateProcessor )run ()error {_eacf :=_g .NewDecoder (_ab .NewReader (_bdfeg ._bead ));var _eadf *templateNode ;for {_egbca ,_gbeaf :=_eacf .Token ();
if _gbeaf !=nil {if _gbeaf ==_ebf .EOF {return nil ;};return _gbeaf ;};if _egbca ==nil {break ;};_fgdd ,_ebgcdg :=_fgcad (_eacf );_cgaca :=_eacf .InputOffset ();switch _ddede :=_egbca .(type ){case _g .StartElement :_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_ddede .Name .Local );
_eddca ,_eabec :=_bcdea [_ddede .Name .Local ];if !_eabec {if _bdfeg ._abfe ==""{if _fgdd !=0{_da .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_ddede .Name .Local ,_fgdd ,_ebgcdg );
}else {_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_ddede .Name .Local ,_cgaca );
};}else {if _fgdd !=0{_da .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_ddede .Name .Local ,_bdfeg ._abfe ,_fgdd ,_ebgcdg );
}else {_da .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_ddede .Name .Local ,_bdfeg ._abfe ,_cgaca );
};};continue ;};_eadf =&templateNode {_edag :_ddede ,_fcdcc :_eadf ,_fabf :_fgdd ,_ebcf :_ebgcdg ,_cbcfd :_cgaca };if _baaba :=_eddca ._bgae ;_baaba !=nil {_eadf ._cdab ,_gbeaf =_baaba (_bdfeg ,_eadf );if _gbeaf !=nil {return _gbeaf ;};};case _g .EndElement :_da .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_ddede .Name .Local );
if _eadf !=nil {if _eadf ._cdab !=nil {if _gdcd :=_bdfeg .renderNode (_eadf );_gdcd !=nil {return _gdcd ;};};_eadf =_eadf ._fcdcc ;};case _g .CharData :if _eadf !=nil &&_eadf ._cdab !=nil {if _ccfd :=_bdfeg .addNodeText (_eadf ,string (_ddede ));_ccfd !=nil {return _ccfd ;
};};case _g .Comment :_da .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_ddede ));};};return nil ;};func (_bfgec *Table )sortCells (){_e .Slice (_bfgec ._eafe ,func (_ggggd ,_fcfga int )bool {_faca :=_bfgec ._eafe [_ggggd ]._deba ;
_dbgdg :=_bfgec ._eafe [_fcfga ]._deba ;if _faca < _dbgdg {return true ;};if _faca > _dbgdg {return false ;};return _bfgec ._eafe [_ggggd ]._gacfd < _bfgec ._eafe [_fcfga ]._gacfd ;});};

// Height returns the total height of all rows.
func (_gccgf *Table )Height ()float64 {_ddeg :=float64 (0.0);for _ ,_eaagb :=range _gccgf ._abfdc {_ddeg +=_eaagb ;};return _ddeg ;};

// SetActualText sets the actual text for the text chunk.
func (_fegd *TextChunk )SetActualText (text string ){_fegd ._caeed =&text };func (_dfdcb *Table )wrapContent (_dggdaf DrawContext )error {if _dfdcb ._fbab {return nil ;};_dfdcb .sortCells ();_bacfg :=func (_dfcf *TableCell ,_gaad int ,_ddece int ,_ggdbc int )(_bcag int ){if _ggdbc < 1{return -1;
};_dgcgc :=0;for _bfaf :=_ddece +1;_bfaf < len (_dfdcb ._eafe )-1;_bfaf ++{_abgeg :=_dfdcb ._eafe [_bfaf ];if _abgeg ._deba ==_ggdbc &&_dgcgc !=_ddece {_dgcgc =_bfaf ;if (_abgeg ._gacfd < _dfcf ._gacfd &&_dfdcb ._ccdbbe > _abgeg ._gacfd )||_dfcf ._gacfd < _dfdcb ._ccdbbe {continue ;
};break ;};};_ggecf :=float64 (0.0);for _edfde :=0;_edfde < _dfcf ._acag ;_edfde ++{_ggecf +=_dfdcb ._abfdc [_dfcf ._deba +_edfde -1];};_cfgf :=_dfcf .width (_dfdcb ._aabdd ,_dggdaf .Width );var (_ccgaf VectorDrawable ;_ffggf =false ;);switch _agfb :=_dfcf ._cbbgc .(type ){case *StyledParagraph :_gbgcc :=_dggdaf ;
_gbgcc .Height =_bd .Floor (_ggecf -_agfb ._cgfa .Top -_agfb ._cgfa .Bottom -0.5*_agfb .getTextHeight ());_gbgcc .Width =_cfgf ;_efggd ,_ecef ,_eceba :=_agfb .split (_gbgcc );if _eceba !=nil {_da .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_eceba .Error ());
};if _efggd !=nil &&_ecef !=nil {_dfdcb ._eafe [_ddece ]._cbbgc =_efggd ;_ccgaf =_ecef ;_ffggf =true ;};};_dfdcb ._eafe [_ddece ]._acag =_dfcf ._acag ;_dggdaf .Height =_dggdaf .PageHeight -_dggdaf .Margins .Top -_dggdaf .Margins .Bottom ;_edcb :=_dfcf .cloneProps (nil );
if _ffggf {_edcb ._cbbgc =_ccgaf ;};_edcb ._acag =_gaad ;_edcb ._deba =_ggdbc +1;_edcb ._gacfd =_dfcf ._gacfd ;if _edcb ._deba +_edcb ._acag -1> _dfdcb ._adfc {for _bagbg :=_dfdcb ._adfc ;_bagbg < _edcb ._deba +_edcb ._acag -1;_bagbg ++{_dfdcb ._adfc ++;
_dfdcb ._abfdc =append (_dfdcb ._abfdc ,_dfdcb ._afdg );};};_dfdcb ._eafe =append (_dfdcb ._eafe [:_dgcgc +1],append ([]*TableCell {_edcb },_dfdcb ._eafe [_dgcgc +1:]...)...);return _dgcgc +1;};_egdaa :=func (_adgd *TableCell ,_aedfa int ,_dced int ,_dega float64 )(_bbcd int ){_gafcb :=_adgd .width (_dfdcb ._aabdd ,_dggdaf .Width );
_dfgd :=_dega ;_facc :=1;_fdaff :=_dggdaf .Height ;if _fdaff > 0{for _dfgd > _fdaff {_dfgd -=_dggdaf .Height ;_fdaff =_dggdaf .PageHeight -_dggdaf .Margins .Top -_dggdaf .Margins .Bottom ;_facc ++;};};var (_efdf VectorDrawable ;_feega =false ;);switch _bdgcd :=_adgd ._cbbgc .(type ){case *StyledParagraph :_edeg :=_dggdaf ;
_edeg .Height =_bd .Floor (_dggdaf .Height -_bdgcd ._cgfa .Top -_bdgcd ._cgfa .Bottom -0.5*_bdgcd .getTextHeight ());_edeg .Width =_gafcb ;_fcdbg ,_aeagc ,_cbacb :=_bdgcd .split (_edeg );if _cbacb !=nil {_da .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_cbacb .Error ());
};if _fcdbg !=nil &&_aeagc !=nil {_dfdcb ._eafe [_aedfa ]._cbbgc =_fcdbg ;_efdf =_aeagc ;_feega =true ;};};if _facc < 2{return -1;};if _dfdcb ._eafe [_aedfa ]._deba +_facc -1> _dfdcb ._adfc {for _afcdd :=0;_afcdd < _facc ;_afcdd ++{_dfdcb ._adfc ++;_dfdcb ._abfdc =append (_dfdcb ._abfdc ,_dfdcb ._afdg );
};};_dgcgf :=_dega /float64 (_facc );for _bcaac :=0;_bcaac < _facc ;_bcaac ++{_dfdcb ._abfdc [_dced +_bcaac -1]=_dgcgf ;};_dggdaf .Height =_dggdaf .PageHeight -_dggdaf .Margins .Top -_dggdaf .Margins .Bottom ;_cecgd :=_adgd .cloneProps (nil );if _feega {_cecgd ._cbbgc =_efdf ;
};_cecgd ._acag =1;_cecgd ._deba =_dced +_facc -1;_cecgd ._gacfd =_adgd ._gacfd ;_dfdcb ._eafe =append (_dfdcb ._eafe ,_cecgd );return len (_dfdcb ._eafe );};_egae :=1;_gaac :=-1;for _geddg :=0;_geddg < len (_dfdcb ._eafe );_geddg ++{_aabgf :=_dfdcb ._eafe [_geddg ];
if _gaac ==_geddg {_egae =_aabgf ._deba ;};if _aabgf ._acag < 2{if _baaef :=_dfdcb ._abfdc [_aabgf ._deba -1];_baaef > _dggdaf .Height {_gaac =_egdaa (_aabgf ,_geddg ,_aabgf ._deba ,_baaef );continue ;};continue ;};_ffdbc :=float64 (0);for _bdabf :=0;_bdabf < _aabgf ._acag ;
_bdabf ++{_ffdbc +=_dfdcb ._abfdc [_aabgf ._deba +_bdabf -1];};_dabg :=float64 (0);for _faagc :=_egae -1;_faagc < _aabgf ._deba -1;_faagc ++{_dabg +=_dfdcb ._abfdc [_faagc ];};if _ffdbc <=(_dggdaf .Height -_dabg ){continue ;};_bfca :=float64 (0.0);_fbgff :=_aabgf ._acag ;
_fbgdgd :=-1;_faded :=1;for _cafae :=1;_cafae <=_aabgf ._acag ;_cafae ++{if (_bfca +_dfdcb ._abfdc [_aabgf ._deba +_cafae -2])> (_dggdaf .Height -_dabg ){_faded --;break ;};_fbgdgd =_aabgf ._deba +_cafae -1;_fbgff =_aabgf ._acag -_cafae ;_bfca +=_dfdcb ._abfdc [_aabgf ._deba +_cafae -2];
_faded ++;};if _aabgf ._acag ==_fbgff {_dggdaf .Height =_dggdaf .PageHeight -_dggdaf .Margins .Top -_dggdaf .Margins .Bottom ;_egae =_aabgf ._deba ;_geddg --;continue ;};if _fbgff > 0&&_aabgf ._acag > _faded {_aabgf ._acag =_faded ;_gaac =_bacfg (_aabgf ,_fbgff ,_geddg ,_fbgdgd );
if _geddg +1==_gaac {_geddg --;};};_egae =_aabgf ._deba ;};_dfdcb .sortCells ();return nil ;};func (_ceeb *templateProcessor )parseListMarker (_efefa *templateNode )(interface{},error ){if _efefa ._fcdcc ==nil {_ceeb .nodeLogError (_efefa ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_ggge ;};var _egdac *TextChunk ;switch _edcge :=_efefa ._fcdcc ._cdab .(type ){case *List :_egdac =&_edcge ._fdbb ;case *listItem :_egdac =&_edcge ._baee ;default:_ceeb .nodeLogError (_efefa ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_edcge );
return nil ,_ggge ;};if _ ,_dfgce :=_ceeb .parseTextChunk (_efefa ,_egdac );_dfgce !=nil {_ceeb .nodeLogError (_efefa ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_dfgce );
return nil ,nil ;};return _egdac ,nil ;};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_fbcff *RadialShading )SetBackgroundColor (backgroundColor Color ){_fbcff ._eddc .SetBackgroundColor (backgroundColor );};

// CurRow returns the currently active cell's row number.
func (_cdcef *Table )CurRow ()int {_cefef :=(_cdcef ._gedb -1)/_cdcef ._ccdbbe +1;return _cefef };

// SetText sets the text content of the Paragraph.
func (_dgbed *Paragraph )SetText (text string ){_dgbed ._dddfg =text };

// SetNumber sets the number of the invoice.
func (_gdgab *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_gdgab ._bfbbc [1].Value =number ;return _gdgab ._bfbbc [0],_gdgab ._bfbbc [1];};

// FitMode returns the fit mode of the rectangle.
func (_dcdbe *Rectangle )FitMode ()FitMode {return _dcdbe ._efbdd };

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_ggedf *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_eebb :=_accf (_ggedf ._eacd );_eebb .Append (text );_deeb ,_eadd :=_ggedf .Add (_eebb );return _eebb ,_deeb ,_eadd ;};var _ceee =_ca .MustCompile ("\u005c\u0064\u002b");


// NewPolygon creates a new polygon.
func (_gcad *Creator )NewPolygon (points [][]_ebc .Point )*Polygon {return _afcd (points )};

// Height returns the height of the graphic svg.
func (_bgda *GraphicSVG )Height ()float64 {return _bgda ._bac .Height };

// SetAnnotation sets an annotation on a TextChunk,
// this will replace any existing annotation that has been set.
// Supplying a nil value as parameter would clear all the annotations.
func (_cadd *TextChunk )SetAnnotation (annotation *_bdd .PdfAnnotation ){if annotation ==nil {_cadd .ClearAnnotations ();}else {_cadd ._gfgcff =[]*_bdd .PdfAnnotation {annotation };};};

// BorderWidth returns the border width of the rectangle.
func (_gcfb *Rectangle )BorderWidth ()float64 {return _gcfb ._agad };

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_eeacfg *Rectangle )SetCoords (x ,y float64 ){_eeacfg ._cbcfa =x ;_eeacfg ._ffdf =y };func (_cgac *Line )computeCoords (_fbaeg DrawContext )(_bbaff ,_ddb ,_fdgd ,_effe float64 ){_bbaff =_fbaeg .X ;_fdgd =_bbaff +_cgac ._cbdf -_cgac ._bcff ;_aggc :=_cgac ._dedd ;
if _cgac ._bcff ==_cgac ._cbdf {_aggc /=2;};if _cgac ._cagcf < _cgac ._begf {_ddb =_fbaeg .PageHeight -_fbaeg .Y -_aggc ;_effe =_ddb -_cgac ._begf +_cgac ._cagcf ;}else {_effe =_fbaeg .PageHeight -_fbaeg .Y -_aggc ;_ddb =_effe -_cgac ._cagcf +_cgac ._begf ;
};switch _cgac ._ecfe {case FitModeFillWidth :_fdgd =_bbaff +_fbaeg .Width ;};return _bbaff ,_ddb ,_fdgd ,_effe ;};func _deg (_abde *_fc .GraphicSVG )(*GraphicSVG ,error ){return &GraphicSVG {_bac :_abde ,_bdbc :PositionRelative ,_ggfgf :Margins {Top :10,Bottom :10}},nil ;
};

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_ebgb *Ellipse )FillOpacity ()float64 {return _ebgb ._fgbc };func (_dgbcd *templateProcessor )nodeError (_gddg *templateNode ,_fbddc string ,_gaag ...interface{})error {return _a .Errorf ("\u0025\u0073",_dgbcd .getNodeErrorLocation (_gddg ,_fbddc ,_gaag ...));
};

// AppendColumn appends a column to the line items table.
func (_afdee *Invoice )AppendColumn (description string )*InvoiceCell {_fbbd :=_afdee .NewColumn (description );_afdee ._abbcg =append (_afdee ._abbcg ,_fbbd );return _fbbd ;};

// SetTextExpansion sets the text expansion for the text chunk.
func (_bgccd *TextChunk )SetTextExpansion (text string ){_bgccd ._afbec =&text };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// SetHeight sets the height of the rectangle.
func (_gdcfa *Rectangle )SetHeight (height float64 ){_gdcfa ._bbae =height };func _ccdbf (_afbc *templateProcessor ,_eceaa *templateNode )(interface{},error ){return _afbc .parsePageBreak (_eceaa );};

// SetMarkedContentID sets the marked content ID.
func (_aeca *Rectangle )SetMarkedContentID (mcid int64 )*_bdd .KDict {_aeca ._ebadc =&mcid ;_debfg :=_bdd .NewKDictionary ();_debfg .S =_bdg .MakeName (_bdd .StructureTypeFigure );_debfg .K =_bdg .MakeInteger (mcid );return _debfg ;};

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_fgdg *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _gdga (xc ,yc ,width ,height );};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_efgaa *Creator )NewStyledParagraph ()*StyledParagraph {return _accf (_efgaa .NewTextStyle ())};

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_bdee *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_bdee ._dacf =dashArray ;_bdee ._ggcc =dashPhase ;};

// SetStyle sets the style of the line (solid or dashed).
func (_ceff *Line )SetStyle (style _ebc .LineStyle ){_ceff ._cbeb =style };func (_facf *templateProcessor )parseImageEncoder (_edbbb ,_fadde string )_bdg .StreamEncoder {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074e\u003a\u0020\u0028\u0060\u0025s\u0060\u002c \u0025\u0073\u0029\u002e",_edbbb ,_fadde );
if _fadde =="\u0066\u006c\u0061t\u0065"{return _bdg .NewFlateEncoder ();}else if _fadde =="\u0064\u0063\u0074"{return _bdg .NewDCTEncoder ();};_da .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0076\u0061\u006cu\u0065\u0020\u006f\u0066 \u0065\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u0020\u0066\u006f\u0075\u006e\u0064\u002e",_edbbb ,_fadde );
return nil ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fge *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _fge ._egec [0],_fge ._egec [1]};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_ff :=&Block {};_ff ._ae =&_ee .ContentStreamOperations {};_ff ._fb =_bdd .NewPdfPageResources ();_ff ._ccb =width ;_ff ._cb =height ;return _ff ;};

// SetMarkedContentID sets marked content ID.
func (_bddg *Curve )SetMarkedContentID (mcid int64 )*_bdd .KDict {_bddg ._dcdb =&mcid ;_gegad :=_bdd .NewKDictionary ();_gegad .S =_bdg .MakeName (_bdd .StructureTypeFigure );_gegad .K =_bdg .MakeInteger (mcid );return _gegad ;};func (_ffge *Invoice )newCell (_ceab string ,_efgf InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_efgf ,_ceab };
};

// SetBorderWidth sets the border width of the rectangle.
func (_gegf *Rectangle )SetBorderWidth (bw float64 ){_gegf ._agad =bw };

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_cdbf *Table )MultiCell (rowspan ,colspan int )*TableCell {_cdbf ._gedb ++;_beca :=(_cdbf .moveToNextAvailableCell ()-1)%(_cdbf ._ccdbbe )+1;_dbgaf :=(_cdbf ._gedb -1)/_cdbf ._ccdbbe +1;for _dbgaf > _cdbf ._adfc {_cdbf ._adfc ++;_cdbf ._abfdc =append (_cdbf ._abfdc ,_cdbf ._afdg );
};_becdg :=&TableCell {};_becdg ._deba =_dbgaf ;_becdg ._gacfd =_beca ;_becdg ._gdfaa =5;_becdg ._ggae =CellBorderStyleNone ;_becdg ._dgbg =_ebc .LineStyleSolid ;_becdg ._ddca =CellHorizontalAlignmentLeft ;_becdg ._dbdg =CellVerticalAlignmentTop ;_becdg ._bgfd =0;
_becdg ._fedgc =0;_becdg ._ebcc =0;_becdg ._cdgea =0;_ecbgd :=ColorBlack ;_becdg ._dbbbd =_ecbgd ;_becdg ._gccfc =_ecbgd ;_becdg ._fedcf =_ecbgd ;_becdg ._bcga =_ecbgd ;_becdg ._bdaf =1.0;if rowspan < 1{_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_cbfff :=_cdbf ._adfc -(_becdg ._deba -1);if rowspan > _cbfff {_da .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_cbfff );
_cdbf ._adfc +=rowspan -1;for _baabe :=0;_baabe <=rowspan -_cbfff ;_baabe ++{_cdbf ._abfdc =append (_cdbf ._abfdc ,_cdbf ._afdg );};};for _bbfg :=0;_bbfg < colspan &&_beca +_bbfg -1< len (_cdbf ._ffcdc );_bbfg ++{_cdbf ._ffcdc [_beca +_bbfg -1]=rowspan -1;
};_becdg ._acag =rowspan ;if colspan < 1{_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_ggdfb :=_cdbf ._ccdbbe -(_becdg ._gacfd -1);if colspan > _ggdfb {_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_ggdfb );
colspan =_ggdfb ;};_becdg ._decgd =colspan ;_cdbf ._gedb +=colspan -1;_cdbf ._eafe =append (_cdbf ._eafe ,_becdg );_becdg ._bdffe =_cdbf ;return _becdg ;};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_gebd *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_gebd ._dbdg =valign };func (_eccbb *templateProcessor )parseCellVerticalAlignmentAttr (_geegc ,_dfbg string )CellVerticalAlignment {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_geegc ,_dfbg );
_ffggb :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_dfbg ];return _ffggb ;};
const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);func (_bfggf *Table )getLastCellFromCol (_cgcd int )(int ,*TableCell ){for _dedbff :=len (_bfggf ._eafe )-1;_dedbff >=0;_dedbff --{if _bfggf ._eafe [_dedbff ]._gacfd ==_cgcd {return _dedbff ,_bfggf ._eafe [_dedbff ];
};};return 0,nil ;};

// Height returns the height of the chart.
func (_aee *Chart )Height ()float64 {return float64 (_aee ._efbgc .Height ())};

// SetMarkedContentID sets the marked content id for the paragraph.
func (_adag *Paragraph )SetMarkedContentID (mcid int64 )*_bdd .KDict {_adag ._defae =&mcid ;_ffb :=_bdd .NewKDictionary ();_ffb .S =_bdg .MakeName ("\u0050");_ffb .K =_bdg .MakeInteger (mcid );return _ffb ;};

// NewCell returns a new invoice table cell.
func (_daab *Invoice )NewCell (value string )*InvoiceCell {return _daab .newCell (value ,_daab .NewCellProps ());};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_bgdbd *StyledParagraph )SetTextAlignment (align TextAlignment ){_bgdbd ._egbdb =align };func _edbb (_aaad *Chapter ,_fbc *TOC ,_cacc *_bdd .Outline ,_eba string ,_cfge int ,_ccdbb TextStyle )*Chapter {var _edgf uint =1;if _aaad !=nil {_edgf =_aaad ._ccdb +1;
};_bcbb :=&Chapter {_gfee :_cfge ,_fad :_eba ,_dgfc :true ,_gdag :true ,_ggbe :_aaad ,_fefe :_fbc ,_effb :_cacc ,_aedg :[]Drawable {},_ccdb :_edgf };_afgc :=_aedga (_bcbb .headingText (),_ccdbb );_afgc .SetFont (_ccdbb .Font );_afgc .SetFontSize (_ccdbb .FontSize );
_bcbb ._ccbe =_afgc ;return _bcbb ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_fcde *StyledParagraph )SetEnableWrap (enableWrap bool ){_fcde ._bcdbe =enableWrap ;_fcde ._acffb =false ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_bcgb *_ebc .Polygon ;_gcadc float64 ;_egcfc float64 ;_daaad Color ;_ggab *int64 ;};func (_baac *Creator )newPage ()*_bdd .PdfPage {_aebb :=_bdd .NewPdfPage ();_feff :=_baac ._efg [0];_cbe :=_baac ._efg [1];_eeeg :=_bdd .PdfRectangle {Llx :0,Lly :0,Urx :_feff ,Ury :_cbe };
_aebb .MediaBox =&_eeeg ;_baac ._bccc =_feff ;_baac ._adfe =_cbe ;_baac .initContext ();return _aebb ;};func (_befgg *Invoice )generateTotalBlocks (_ffaa DrawContext )([]*Block ,DrawContext ,error ){_eaa :=_fbcee (4);_eaa .SetMargins (0,0,10,10);_bbef :=[][2]*InvoiceCell {_befgg ._cfgg };
_bbef =append (_bbef ,_befgg ._fbce ...);_bbef =append (_bbef ,_befgg ._afgg );for _ ,_fdec :=range _bbef {_adfa ,_cecc :=_fdec [0],_fdec [1];if _cecc .Value ==""{continue ;};_eaa .SkipCells (2);_egcg :=_eaa .NewCell ();_egcg .SetBackgroundColor (_adfa .BackgroundColor );
_egcg .SetHorizontalAlignment (_cecc .Alignment );_befgg .setCellBorder (_egcg ,_adfa );_abcef :=_accf (_adfa .TextStyle );_abcef .SetMargins (0,0,2,1);_abcef .Append (_adfa .Value );_egcg .SetContent (_abcef );_egcg =_eaa .NewCell ();_egcg .SetBackgroundColor (_cecc .BackgroundColor );
_egcg .SetHorizontalAlignment (_cecc .Alignment );_befgg .setCellBorder (_egcg ,_adfa );_abcef =_accf (_cecc .TextStyle );_abcef .SetMargins (0,0,2,1);_abcef .Append (_cecc .Value );_egcg .SetContent (_abcef );};return _eaa .GeneratePageBlocks (_ffaa );
};func (_bfed *templateProcessor )parseTextVerticalAlignmentAttr (_facff ,_bcgce string )TextVerticalAlignment {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_facff ,_bcgce );
_beeaa :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_bcgce ];return _beeaa ;};func (_cbaf *Invoice )generateLineBlocks (_ddadd DrawContext )([]*Block ,DrawContext ,error ){_cfed :=_fbcee (len (_cbaf ._abbcg ));
_cfed .SetMargins (0,0,25,0);for _ ,_ceeeed :=range _cbaf ._abbcg {_gfbg :=_accf (_ceeeed .TextStyle );_gfbg .SetMargins (0,0,1,0);_gfbg .Append (_ceeeed .Value );_cbeg :=_cfed .NewCell ();_cbeg .SetHorizontalAlignment (_ceeeed .Alignment );_cbeg .SetBackgroundColor (_ceeeed .BackgroundColor );
_cbaf .setCellBorder (_cbeg ,_ceeeed );_cbeg .SetContent (_gfbg );};for _ ,_cfabc :=range _cbaf ._dbebc {for _ ,_adbd :=range _cfabc {_dfgc :=_accf (_adbd .TextStyle );_dfgc .SetMargins (0,0,3,2);_dfgc .Append (_adbd .Value );_faed :=_cfed .NewCell ();
_faed .SetHorizontalAlignment (_adbd .Alignment );_faed .SetBackgroundColor (_adbd .BackgroundColor );_cbaf .setCellBorder (_faed ,_adbd );_faed .SetContent (_dfgc );};};return _cfed .GeneratePageBlocks (_ddadd );};

// Title returns the title of the invoice.
func (_cacde *Invoice )Title ()string {return _cacde ._cbgeg };

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_faad *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _faad ._bcff ,_faad ._cagcf ,_faad ._cbdf ,_faad ._begf ;};

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_bdba Color ;_fbgg float64 ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_fadf *Creator )MoveDown (dy float64 ){_fadf ._ebce .Y +=dy };

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_dgfgg *Creator )NewImageFromGoImage (goimg _b .Image )(*Image ,error ){return _edfd (goimg )};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_cgcbd *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_afgca float64 ;_edcf uint ;_cdbd float64 ;_fcge Positioning ;_adbf float64 ;_cagac float64 ;_ddbe int64 ;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetAlternateText sets the alternate text for the image.
func (_bebd *Image )SetAlternateText (text string ){_bebd ._afdc =text };

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_dgadb *Line )SetFitMode (fitMode FitMode ){_dgadb ._ecfe =fitMode };func (_eddd *TableCell )width (_agaga []float64 ,_edga float64 )float64 {_fcfd :=float64 (0.0);for _gafca :=0;_gafca < _eddd ._decgd ;_gafca ++{_fcfd +=_agaga [_eddd ._gacfd +_gafca -1];
};return _fcfd *_edga ;};func (_fabcf *Table )updateRowHeights (_fbfgb float64 ){for _ ,_adfagd :=range _fabcf ._eafe {_cbgd :=_adfagd .width (_fabcf ._aabdd ,_fbfgb );_bgbea :=_adfagd .height (_cbgd );_bced :=_fabcf ._abfdc [_adfagd ._deba +_adfagd ._acag -2];
if _adfagd ._acag > 1{_gdeb :=0.0;_gbaa :=_fabcf ._abfdc [_adfagd ._deba -1:(_adfagd ._deba +_adfagd ._acag -1)];for _ ,_addc :=range _gbaa {_gdeb +=_addc ;};if _bgbea <=_gdeb {continue ;};};if _bgbea > _bced {_edbegg :=_bgbea /float64 (_adfagd ._acag );
if _edbegg > _bced {for _cdfe :=1;_cdfe <=_adfagd ._acag ;_cdfe ++{if _edbegg > _fabcf ._abfdc [_adfagd ._deba +_cdfe -2]{_fabcf ._abfdc [_adfagd ._deba +_cdfe -2]=_edbegg ;};};};};};};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_adea *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _ac .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _ac .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _ac .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_adea ._eeed =true ;_adea ._abeef =startRow ;_adea ._cdfg =endRow ;return nil ;};func _cafdf (_eabf *templateProcessor ,_eccec *templateNode )(interface{},error ){return _eabf .parseListItem (_eccec );};

// SetMarkedContentID sets marked content ID.
func (_bcfc *Polyline )SetMarkedContentID (mcid int64 )*_bdd .KDict {_bcfc ._acgdd =&mcid ;_gfgcf :=_bdd .NewKDictionary ();_gfgcf .S =_bdg .MakeName (_bdd .StructureTypeFigure );_gfgcf .K =_bdg .MakeInteger (mcid );return _gfgcf ;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_cddce *_ebc .Polyline ;_fgcee float64 ;_acgdd *int64 ;};

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_ccaec *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_ccaec ._cdag =textOverflow ;};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// SetBorderColor sets the border color.
func (_ddfgg *Polygon )SetBorderColor (color Color ){_ddfgg ._bcgb .BorderColor =_ddfd (color )};func (_fcdac *templateProcessor )parseListItem (_dabfg *templateNode )(interface{},error ){if _dabfg ._fcdcc ==nil {_fcdac .nodeLogError (_dabfg ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_ggge ;};_bfeac ,_abfb :=_dabfg ._fcdcc ._cdab .(*List );if !_abfb {_fcdac .nodeLogError (_dabfg ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_ggge ;};_dedbfc :=_ffffd ();_dedbfc ._baee =_bfeac ._fdbb ;return _dedbfc ,nil ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bggaf *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _bggaf ._cfgg [0],_bggaf ._cfgg [1];};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_daee *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _daee ._aedc .Left ,_daee ._aedc .Right ,_daee ._aedc .Top ,_daee ._aedc .Bottom ;};

// SetBorderColor sets the border color.
func (_ebbcg *PolyBezierCurve )SetBorderColor (color Color ){_ebbcg ._edaef .BorderColor =_ddfd (color )};func _acgc (_dcf string )string {_fbe :=_ceee .FindAllString (_dcf ,-1);if len (_fbe )==0{_dcf =_dcf +"\u0030";}else {_gae ,_dba :=_eb .Atoi (_fbe [len (_fbe )-1]);
if _dba !=nil {_da .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_dba );
_dcf =_dcf +"\u0030";}else {_gae ++;_fdd :=_fa .LastIndex (_dcf ,_fbe [len (_fbe )-1]);if _fdd ==-1{_dcf =_a .Sprintf ("\u0025\u0073\u0025\u0064",_dcf [:len (_dcf )-1],_gae );}else {_dcf =_dcf [:_fdd ]+_eb .Itoa (_gae );};};};return _dcf ;};func (_fgbfb *StyledParagraph )getLineMetrics (_afbga int )(_dcaa ,_ccbbb ,_adcc float64 ){if _fgbfb ._acebb ==nil ||(_fgbfb ._acebb !=nil &&len (_fgbfb ._acebb )==0){_fgbfb .wrapText ();
};if _afbga < 0||_afbga > len (_fgbfb ._acebb )-1{_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_afbga );
return 0,0,0;};_cadc :=_fgbfb ._acebb [_afbga ];for _ ,_abad :=range _cadc {_bcdge :=_bbfda (_abad .Style .Font ,_abad .Style .FontSize );if _bcdge ._fdggf > _dcaa {_dcaa =_bcdge ._fdggf ;};if _bcdge ._dbba < _adcc {_adcc =_bcdge ._dbba ;};if _ffab :=_abad .Style .FontSize ;
_ffab > _ccbbb {_ccbbb =_ffab ;};};return _dcaa ,_ccbbb ,_adcc ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_ceccd *shading )SetAntiAlias (enable bool ){_ceccd ._faga =enable };func (_bfee *Invoice )drawAddress (_fdgg *InvoiceAddress )[]*StyledParagraph {var _fada []*StyledParagraph ;if _fdgg .Heading !=""{_gfgf :=_accf (_bfee ._afde );_gfgf .SetMargins (0,0,0,7);
_gfgf .Append (_fdgg .Heading );_fada =append (_fada ,_gfgf );};_efaeb :=_accf (_bfee ._bdaa );_efaeb .SetLineHeight (1.2);_caba :=_fdgg .Separator ;if _caba ==""{_caba =_bfee ._dfdg ;};_fecg :=_fdgg .City ;if _fdgg .State !=""{if _fecg !=""{_fecg +=_caba ;
};_fecg +=_fdgg .State ;};if _fdgg .Zip !=""{if _fecg !=""{_fecg +=_caba ;};_fecg +=_fdgg .Zip ;};if _fdgg .Name !=""{_efaeb .Append (_fdgg .Name +"\u000a");};if _fdgg .Street !=""{_efaeb .Append (_fdgg .Street +"\u000a");};if _fdgg .Street2 !=""{_efaeb .Append (_fdgg .Street2 +"\u000a");
};if _fecg !=""{_efaeb .Append (_fecg +"\u000a");};if _fdgg .Country !=""{_efaeb .Append (_fdgg .Country +"\u000a");};_fcbf :=_accf (_bfee ._bdaa );_fcbf .SetLineHeight (1.2);_fcbf .SetMargins (0,0,7,0);if _fdgg .Phone !=""{_fcbf .Append (_fdgg .fmtLine (_fdgg .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_fdgg .HidePhoneLabel ));
};if _fdgg .Email !=""{_fcbf .Append (_fdgg .fmtLine (_fdgg .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_fdgg .HideEmailLabel ));};_fada =append (_fada ,_efaeb ,_fcbf );return _fada ;};

// DashPattern returns the dash pattern of the line.
func (_ggfe *Line )DashPattern ()(_dgab []int64 ,_ddce int64 ){return _ggfe ._dacf ,_ggfe ._ggcc };

// BorderColor returns the border color of the ellipse.
func (_gga *Ellipse )BorderColor ()Color {return _gga ._dage };func (_egfgg *templateProcessor )parseFitModeAttr (_facaf ,_eagd string )FitMode {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_facaf ,_eagd );
_ffcf :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_eagd ];return _ffcf ;};const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_gbcb *Invoice )SetAddressStyle (style TextStyle ){_gbcb ._bdaa =style };

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_ddf *Block )ScaleToHeight (h float64 ){_dafd :=h /_ddf ._cb ;_ddf .Scale (_dafd ,_dafd )};func _cdcbe (_bgaga *_bdd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_bgaga ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// AddLine adds a new line with the provided style to the table of contents.
func (_dbfcb *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_dbfcb ._cfecf =append (_dbfcb ._cfecf ,line );return line ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cfbea *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbed :=ctx ;_edadb :=[]func (_cbcf DrawContext )([]*Block ,DrawContext ,error ){_cfbea .generateHeaderBlocks ,_cfbea .generateInformationBlocks ,_cfbea .generateLineBlocks ,_cfbea .generateTotalBlocks ,_cfbea .generateNoteBlocks };
var _gfcd []*Block ;for _ ,_efdg :=range _edadb {_dabd ,_ecedf ,_bcdcb :=_efdg (ctx );if _bcdcb !=nil {return _gfcd ,ctx ,_bcdcb ;};if len (_gfcd )==0{_gfcd =_dabd ;}else if len (_dabd )> 0{_gfcd [len (_gfcd )-1].mergeBlocks (_dabd [0]);_gfcd =append (_gfcd ,_dabd [1:]...);
};ctx =_ecedf ;};if _cfbea ._aeec .IsRelative (){ctx .X =_cbed .X ;};if _cfbea ._aeec .IsAbsolute (){return _gfcd ,_cbed ,nil ;};return _gfcd ,ctx ,nil ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_gdea *Creator )NewPage ()*_bdd .PdfPage {_adda :=_gdea .newPage ();_gdea ._bcdf =append (_gdea ._bcdf ,_adda );_gdea ._ebce .Page ++;return _adda ;};func _caga (_addf *_bdd .PdfAnnotationHighlight )*_bdd .PdfAnnotationHighlight {if _addf ==nil {return nil ;
};_acbbd :=_bdd .NewPdfAnnotationHighlight ();_acbbd .C =_addf .C ;_acbbd .CA =_addf .CA ;_acbbd .Rect =_addf .Rect ;_acbbd .QuadPoints =_addf .QuadPoints ;return _acbbd ;};

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_eddc *shading ;_bfefc *_bdd .PdfRectangle ;_eggc AnchorPoint ;_cedaa float64 ;_dbbe float64 ;_beaef float64 ;_dgefe float64 ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_fbeeb *LinearShading )SetExtends (start bool ,end bool ){_fbeeb ._bdbcd .SetExtends (start ,end )};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_bcdf []*_bdd .PdfPage ;_dbce map[*_bdd .PdfPage ]*Block ;_acff map[*_bdd .PdfPage ]*pageTransformations ;_agbc *_bdd .PdfPage ;_efg PageSize ;_ebce DrawContext ;_ebcd Margins ;_bccc ,_adfe float64 ;_fcgd int ;_edd func (_ggbc FrontpageFunctionArgs );
_gde func (_agbca *TOC )error ;_cfe func (_bbfd *Block ,_aeeb HeaderFunctionArgs );_cacg func (_eeg *Block ,_cab FooterFunctionArgs );_bbd func (_adgc PageFinalizeFunctionArgs )error ;_daad func (_dcce *_bdd .PdfWriter )error ;_ecc bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_fgde *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_bgce *_bdd .Outline ;_fdbf *_bdd .PdfOutlineTreeNode ;_cbd *_bdd .PdfAcroForm ;_febc _bdg .PdfObject ;_becg _bdd .Optimizer ;_ffa []*_bdd .PdfFont ;_abb *_bdd .PdfFont ;_bbaf *_bdd .PdfFont ;_agfd *_bdd .StructTreeRoot ;_afbe *_bdd .ViewerPreferences ;
_faeb string ;};

// Scale block by specified factors in the x and y directions.
func (_dee *Block )Scale (sx ,sy float64 ){_cgc :=_ee .NewContentCreator ().Scale (sx ,sy ).Operations ();*_dee ._ae =append (*_cgc ,*_dee ._ae ...);_dee ._ae .WrapIfNeeded ();_dee ._ccb *=sx ;_dee ._cb *=sy ;};

// SetLineWidth sets the line width.
func (_bdfe *Polyline )SetLineWidth (lineWidth float64 ){_bdfe ._cddce .LineWidth =lineWidth };

// SellerAddress returns the seller address used in the invoice template.
func (_fgad *Invoice )SellerAddress ()*InvoiceAddress {return _fgad ._bccg };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_aaedg *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cdgaa :=ctx ;_beed ,ctx ,_accfb :=_aaedg ._cgcbd .GeneratePageBlocks (ctx );if _accfb !=nil {return _beed ,ctx ,_accfb ;};if _aaedg ._fcge .IsRelative (){ctx .X =_cdgaa .X ;
};if _aaedg ._fcge .IsAbsolute (){return _beed ,_cdgaa ,nil ;};return _beed ,ctx ,nil ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_gb *Block )AddAnnotation (annotation *_bdd .PdfAnnotation ){for _ ,_ad :=range _gb ._ceg {if _ad ==annotation {return ;};};_gb ._ceg =append (_gb ._ceg ,annotation );};

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _decge (path )};

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_bdbcd *shading ;_affg *_bdd .PdfRectangle ;_dgabd float64 ;};func (_fcab *LinearShading )shadingModel ()*_bdd .PdfShadingType2 {_fgec :=_ebc .NewPoint (_fcab ._affg .Llx +_fcab ._affg .Width ()/2,_fcab ._affg .Lly +_fcab ._affg .Height ()/2);
_caag :=_ebc .NewPoint (_fcab ._affg .Llx ,_fcab ._affg .Lly +_fcab ._affg .Height ()/2).Add (-_fgec .X ,-_fgec .Y ).Rotate (_fcab ._dgabd ).Add (_fgec .X ,_fgec .Y );_caag =_ebc .NewPoint (_bd .Max (_bd .Min (_caag .X ,_fcab ._affg .Urx ),_fcab ._affg .Llx ),_bd .Max (_bd .Min (_caag .Y ,_fcab ._affg .Ury ),_fcab ._affg .Lly ));
_gggc :=_ebc .NewPoint (_fcab ._affg .Urx ,_fcab ._affg .Lly +_fcab ._affg .Height ()/2).Add (-_fgec .X ,-_fgec .Y ).Rotate (_fcab ._dgabd ).Add (_fgec .X ,_fgec .Y );_gggc =_ebc .NewPoint (_bd .Min (_bd .Max (_gggc .X ,_fcab ._affg .Llx ),_fcab ._affg .Urx ),_bd .Min (_bd .Max (_gggc .Y ,_fcab ._affg .Lly ),_fcab ._affg .Ury ));
_ceaf :=_bdd .NewPdfShadingType2 ();_ceaf .PdfShading .ShadingType =_bdg .MakeInteger (2);_ceaf .PdfShading .ColorSpace =_bdd .NewPdfColorspaceDeviceRGB ();_ceaf .PdfShading .AntiAlias =_bdg .MakeBool (_fcab ._bdbcd ._faga );_ceaf .Coords =_bdg .MakeArrayFromFloats ([]float64 {_caag .X ,_caag .Y ,_gggc .X ,_gggc .Y });
_ceaf .Extend =_bdg .MakeArray (_bdg .MakeBool (_fcab ._bdbcd ._agda [0]),_bdg .MakeBool (_fcab ._bdbcd ._agda [1]));_ceaf .Function =_fcab ._bdbcd .generatePdfFunctions ();return _ceaf ;};

// SetWidth sets the width of the rectangle.
func (_bgecd *Rectangle )SetWidth (width float64 ){_bgecd ._efdd =width };

// SkipOver skips over a specified number of rows and cols.
func (_dgcdg *Table )SkipOver (rows ,cols int ){_defg :=rows *_dgcdg ._ccdbbe +cols -1;if _defg < 0{_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _daef :=0;_daef < _defg ;_daef ++{_dgcdg .NewCell ();};};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_cfage *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_cfage ._abed =align ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_edcaa *TOC )SetLineNumberStyle (style TextStyle ){_edcaa ._caec =style };

// Width returns the width of the ellipse.
func (_dcfea *Ellipse )Width ()float64 {return _dcfea ._bfddf };

// SetMarkedContentID sets marked content ID.
func (_egb *border )SetMarkedContentID (id int64 )*_bdd .KDict {return nil };

// AddColorStop add color stop information for rendering gradient.
func (_ggbeb *shading )AddColorStop (color Color ,point float64 ){_ggbeb ._decd =append (_ggbeb ._decd ,_cdbc (color ,point ));};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_dcdg *Image )ScaleToHeight (h float64 ){_ccgf :=_dcdg ._fgbd /_dcdg ._eedg ;_dcdg ._eedg =h ;_dcdg ._fgbd =h *_ccgf ;};

// Crop crops the Image to the specified bounds.
func (_cefa *Image )Crop (x0 ,y0 ,x1 ,y1 int ){_ffgfe ,_cece :=_cefa ._cebb .ToGoImage ();if _cece !=nil {_cc .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0074o\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_cece );
};var _ecge _b .Image ;_geba :=_b .Rect (x0 ,y0 ,x1 ,y1 );if _faabe :=_geba .Intersect (_ffgfe .Bounds ());!_geba .Empty (){_edbd :=_b .NewRGBA (_b .Rect (0,0,_geba .Dx (),_geba .Dy ()));for _fedgd :=_faabe .Min .Y ;_fedgd < _faabe .Max .Y ;_fedgd ++{for _fbcdb :=_faabe .Min .X ;
_fbcdb < _faabe .Max .X ;_fbcdb ++{_edbd .Set (_fbcdb -_faabe .Min .X ,_fedgd -_faabe .Min .Y ,_ffgfe .At (_fbcdb ,_fedgd ));};};_ecge =_edbd ;}else {_ecge =&_b .RGBA {};};_eeee ,_cece :=_bdd .ImageHandling .NewImageFromGoImage (_ecge );if _cece !=nil {_cc .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0066\u0072\u006fm\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_cece );
};_dcfb :=float64 (_eeee .Width );_adcf :=float64 (_eeee .Height );_cefa ._cebb =_eeee ;_cefa ._adge =_dcfb ;_cefa ._ceeac =_adcf ;_cefa ._fgbd =_dcfb ;_cefa ._eedg =_adcf ;};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_dfdc *Rectangle )Height ()float64 {return _dfdc ._bbae };

// SkipCells skips over a specified number of cells in the table.
func (_aefg *Table )SkipCells (num int ){if num < 0{_da .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _gbea :=0;_gbea < num ;_gbea ++{_aefg .NewCell ();};};func _ddgef (_acdeb ,_cedaad ,_ccbfe float64 )(_aafbf ,_geffe ,_eaafb ,_cfgb float64 ){if _ccbfe ==0{return 0,0,_acdeb ,_cedaad ;};_aebgb :=_ebc .Path {Points :[]_ebc .Point {_ebc .NewPoint (0,0).Rotate (_ccbfe ),_ebc .NewPoint (_acdeb ,0).Rotate (_ccbfe ),_ebc .NewPoint (0,_cedaad ).Rotate (_ccbfe ),_ebc .NewPoint (_acdeb ,_cedaad ).Rotate (_ccbfe )}}.GetBoundingBox ();
return _aebgb .X ,_aebgb .Y ,_aebgb .Width ,_aebgb .Height ;};

// Positioning returns the type of positioning the line is set to use.
func (_cafcb *Line )Positioning ()Positioning {return _cafcb ._bgad };func (_daccd grayColor )ToRGB ()(float64 ,float64 ,float64 ){return _daccd ._ebfd ,_daccd ._ebfd ,_daccd ._ebfd ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_aedf *Creator )NewImage (img *_bdd .Image )(*Image ,error ){return _cdbb (img )};func (_gada *Paragraph )getTextMetrics ()(_gfbf ,_cagd ,_cbba float64 ){_bgede :=_bbfda (_gada ._gfac ,_gada ._ccdc );if _bgede ._fdggf > _gfbf {_gfbf =_bgede ._fdggf ;
};if _bgede ._dbba < _cbba {_cbba =_bgede ._dbba ;};if _ggeb :=_gada ._ccdc ;_ggeb > _cagd {_cagd =_ggeb ;};return _gfbf ,_cagd ,_cbba ;};

// GetRowHeight returns the height of the specified row.
func (_cgddg *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_cgddg ._abfdc ){return 0,_ac .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _cgddg ._abfdc [row -1],nil ;
};

// List represents a list of items.
// The representation of a list item is as follows:
//
//	[marker] [content]
//
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_agcde []*listItem ;_eaag Margins ;_fdbb TextChunk ;_ccgdf float64 ;_fgea bool ;_cfggg Positioning ;_eacd TextStyle ;};

// Lines returns all the lines the table of contents has.
func (_adcfa *TOC )Lines ()[]*TOCLine {return _adcfa ._cfecf };func (_caeg *Paragraph )wrapText ()error {if !_caeg ._ceaa ||int (_caeg ._bbag )<=0{_caeg ._fcffe =[]string {_caeg ._dddfg };return nil ;};_gbfc :=NewTextChunk (_caeg ._dddfg ,TextStyle {Font :_caeg ._gfac ,FontSize :_caeg ._ccdc });
_dbfe ,_bgbd :=_gbfc .Wrap (_caeg ._bbag );if _bgbd !=nil {return _bgbd ;};if _caeg ._gfgde > 0&&len (_dbfe )> _caeg ._gfgde {_dbfe =_dbfe [:_caeg ._gfgde ];};_caeg ._fcffe =_dbfe ;return nil ;};func _ddfd (_fcfc Color )_bdd .PdfColor {if _fcfc ==nil {_fcfc =ColorBlack ;
};switch _ggf :=_fcfc .(type ){case grayColor :return _bdd .NewPdfColorDeviceGray (_ggf ._ebfd );case cmykColor :return _bdd .NewPdfColorDeviceCMYK (_ggf ._gbef ,_ggf ._gcg ,_ggf ._gab ,_ggf ._bgfg );case *LinearShading :return _bdd .NewPdfColorPatternType2 ();
case *RadialShading :return _bdd .NewPdfColorPatternType3 ();};return _bdd .NewPdfColorDeviceRGB (_fcfc .ToRGB ());};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_gfee int ;_fad string ;_ccbe *Paragraph ;_aedg []Drawable ;_bcee int ;_dgfc bool ;_gdag bool ;_geee Positioning ;_bda ,_aaab float64 ;_gff Margins ;_ggbe *Chapter ;_fefe *TOC ;_effb *_bdd .Outline ;_gec *_bdd .OutlineItem ;_ccdb uint ;
};

// SetColor sets the line color.
func (_egfd *Curve )SetColor (col Color ){_egfd ._aage =col };func _ecefg (_efdcb *templateProcessor ,_gbgd *templateNode )(interface{},error ){return _efdcb .parseList (_gbgd );};

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_edbc *GraphicSVG )SetPos (x ,y float64 ){_edbc ._bdbc =PositionAbsolute ;_edbc ._dede =x ;_edbc ._cagf =y ;};

// FitMode returns the fit mode of the ellipse.
func (_gfcb *Ellipse )FitMode ()FitMode {return _gfcb ._gdce };

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_fddd *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abf :=ctx ;if _fddd ._geee .IsRelative (){ctx .X +=_fddd ._gff .Left ;ctx .Y +=_fddd ._gff .Top ;ctx .Width -=_fddd ._gff .Left +_fddd ._gff .Right ;ctx .Height -=_fddd ._gff .Top ;
};_bdge ,_gba ,_gaf :=_fddd ._ccbe .GeneratePageBlocks (ctx );if _gaf !=nil {return _bdge ,ctx ,_gaf ;};ctx =_gba ;_cga :=ctx .X ;_cgag :=ctx .Y -_fddd ._ccbe .Height ();_acge :=int64 (ctx .Page );_dcfe :=_fddd .headingNumber ();_aggf :=_fddd .headingText ();
if _fddd ._gdag {_afd :=_fddd ._fefe .Add (_dcfe ,_fddd ._fad ,_eb .FormatInt (_acge ,10),_fddd ._ccdb );if _fddd ._fefe ._egbac {_afd .SetLink (_acge ,_cga ,_cgag );};};if _fddd ._gec ==nil {_fddd ._gec =_bdd .NewOutlineItem (_aggf ,_bdd .NewOutlineDest (_acge -1,_cga ,_cgag ));
if _fddd ._ggbe !=nil {_fddd ._ggbe ._gec .Add (_fddd ._gec );}else {_fddd ._effb .Add (_fddd ._gec );};}else {_ecf :=&_fddd ._gec .Dest ;_ecf .Page =_acge -1;_ecf .X =_cga ;_ecf .Y =_cgag ;};for _ ,_gecf :=range _fddd ._aedg {_dcdd ,_debb ,_dcb :=_gecf .GeneratePageBlocks (ctx );
if _dcb !=nil {return _bdge ,ctx ,_dcb ;};if len (_dcdd )< 1{continue ;};_bdge [len (_bdge )-1].mergeBlocks (_dcdd [0]);_bdge =append (_bdge ,_dcdd [1:]...);ctx =_debb ;};if _fddd ._geee .IsRelative (){ctx .X =_abf .X ;};if _fddd ._geee .IsAbsolute (){return _bdge ,_abf ,nil ;
};return _bdge ,ctx ,nil ;};func (_dagg cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_ddge :=_dagg ._bgfg ;return 1-(_dagg ._gbef *(1-_ddge )+_ddge ),1-(_dagg ._gcg *(1-_ddge )+_ddge ),1-(_dagg ._gab *(1-_ddge )+_ddge );};

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_bfbe *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_bfbe ._gcbd .Left =left ;_bfbe ._gcbd .Right =right ;_bfbe ._gcbd .Top =top ;_bfbe ._gcbd .Bottom =bottom ;};func _abada (_cdedcd *templateProcessor ,_fbaee *templateNode )(interface{},error ){return _cdedcd .parseImage (_fbaee );
};

// SetMarkedContentID sets marked content ID.
func (_cfbf *Invoice )SetMarkedContentID (id int64 )*_bdd .KDict {return nil };

// SetRowPosition sets cell row position.
func (_gcdca *TableCell )SetRowPosition (row int ){_gcdca ._deba =row };

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_ggdfd *Paragraph )SetLanguageIdentifier (id string ){_ggdfd ._cdedda =id };func (_aaed *StyledParagraph )wrapChunks (_abee bool )error {if !_aaed ._bcdbe ||int (_aaed ._fcdc )<=0{_aaed ._acebb =[][]*TextChunk {_aaed ._adebd };return nil ;};if _aaed ._cbbg {_aaed .wrapWordChunks ();
};_aaed ._acebb =[][]*TextChunk {};var _dfga []*TextChunk ;var _adbc float64 ;_edcg :=_bg .IsSpace ;if !_abee {_edcg =func (rune )bool {return false };};_bceg :=_dbdca (_aaed ._fcdc *1000.0,0.000001);for _ ,_debd :=range _aaed ._adebd {_fbdg :=_debd .Style ;
_cdacf :=_debd ._gfgcff ;_bgedd :=_debd .VerticalAlignment ;var (_deedc []rune ;_gfdb []float64 ;);_cabd :=_dfaaaa (_debd .Text );for _ ,_ggcgf :=range _debd .Text {if _ggcgf =='\u000A'{if !_abee {_deedc =append (_deedc ,_ggcgf );};_dfga =append (_dfga ,&TextChunk {Text :_fa .TrimRightFunc (string (_deedc ),_edcg ),Style :_fbdg ,_gfgcff :_bbgaa (_cdacf ),VerticalAlignment :_bgedd ,_afbec :_debd ._afbec ,_eeebc :_debd ._eeebc ,_caeed :_debd ._caeed });
_aaed ._acebb =append (_aaed ._acebb ,_dfga );_dfga =nil ;_adbc =0;_deedc =nil ;_gfdb =nil ;continue ;};_dabb :=_ggcgf ==' ';_efbff ,_becde :=_fbdg .Font .GetRuneMetrics (_ggcgf );if _efbff .Wx ==0&&_fbdg .MultiFont !=nil ||_fbdg .MultiFont !=nil &&!_becde {_efbff ,_becde =_fbdg .MultiFont .GetRuneMetrics (_ggcgf );
};if !_becde {_da .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ggcgf );return _ac .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_edda :=_fbdg .FontSize *_efbff .Wx *_fbdg .horizontalScale ();_ega :=_edda ;if !_dabb {_ega =_edda +_fbdg .CharSpacing *1000.0;};if _adbc +_edda > _bceg {_eaea :=-1;if !_dabb {for _gbdge :=len (_deedc )-1;_gbdge >=0;_gbdge --{if _deedc [_gbdge ]==' '{_eaea =_gbdge ;
break ;};};};if _aaed ._cbbg {_aege :=len (_dfga );if _aege > 0{_dfga [_aege -1].Text =_fa .TrimRightFunc (_dfga [_aege -1].Text ,_edcg );_aaed ._acebb =append (_aaed ._acebb ,_dfga );_dfga =[]*TextChunk {};};_deedc =append (_deedc ,_ggcgf );_gfdb =append (_gfdb ,_ega );
if _eaea >=0{_deedc =_deedc [_eaea +1:];_gfdb =_gfdb [_eaea +1:];};_adbc =0;for _ ,_dgbf :=range _gfdb {_adbc +=_dgbf ;};if _adbc > _bceg {_caed :=string (_deedc [:len (_deedc )-1]);_caed =_dfcea (_caed ,_cabd );if !_abee &&_dabb {_caed +="\u0020";};_dfga =append (_dfga ,&TextChunk {Text :_fa .TrimRightFunc (_caed ,_edcg ),Style :_fbdg ,_gfgcff :_bbgaa (_cdacf ),VerticalAlignment :_bgedd ,_afbec :_debd ._afbec ,_eeebc :_debd ._eeebc ,_caeed :_debd ._caeed });
_aaed ._acebb =append (_aaed ._acebb ,_dfga );_dfga =[]*TextChunk {};_deedc =[]rune {_ggcgf };_gfdb =[]float64 {_ega };_adbc =_ega ;};continue ;};_ebdcd :=string (_deedc );if _eaea >=0{_ebdcd =string (_deedc [0:_eaea +1]);_deedc =_deedc [_eaea +1:];_deedc =append (_deedc ,_ggcgf );
_gfdb =_gfdb [_eaea +1:];_gfdb =append (_gfdb ,_ega );_adbc =0;for _ ,_gcce :=range _gfdb {_adbc +=_gcce ;};}else {if _dabb {_adbc =0;_deedc =[]rune {};_gfdb =[]float64 {};}else {_adbc =_ega ;_deedc =[]rune {_ggcgf };_gfdb =[]float64 {_ega };};};_ebdcd =_dfcea (_ebdcd ,_cabd );
if !_abee &&_dabb {_ebdcd +="\u0020";};_dfga =append (_dfga ,&TextChunk {Text :_fa .TrimRightFunc (_ebdcd ,_edcg ),Style :_fbdg ,_gfgcff :_bbgaa (_cdacf ),VerticalAlignment :_bgedd ,_afbec :_debd ._afbec ,_eeebc :_debd ._eeebc ,_caeed :_debd ._caeed });
_aaed ._acebb =append (_aaed ._acebb ,_dfga );_dfga =[]*TextChunk {};}else {_adbc +=_ega ;_deedc =append (_deedc ,_ggcgf );_gfdb =append (_gfdb ,_ega );};};if len (_deedc )> 0{_cbcb :=_dfcea (string (_deedc ),_cabd );_dfga =append (_dfga ,&TextChunk {Text :_cbcb ,Style :_fbdg ,_gfgcff :_bbgaa (_cdacf ),VerticalAlignment :_bgedd ,_afbec :_debd ._afbec ,_eeebc :_debd ._eeebc ,_caeed :_debd ._caeed });
};};if len (_dfga )> 0{_aaed ._acebb =append (_aaed ._acebb ,_dfga );};return nil ;};

// ColorGrayFrom8bit creates a Color from 8-bit (0-255) gray values.
// Example:
//
//	gray := ColorGrayFrom8bit(255, 0, 0)
func ColorGrayFrom8bit (g byte )Color {return grayColor {float64 (g )/255.0}};

// AddAnnotation adds an annotation on a TextChunk.
func (_cgcgd *TextChunk )AddAnnotation (annotation *_bdd .PdfAnnotation ){if annotation ==nil {return ;};_cgcgd ._gfgcff =append (_cgcgd ._gfgcff ,annotation );};

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_ebaf *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_ebaf ._abae .Left =left ;_ebaf ._abae .Right =right ;_ebaf ._abae .Top =top ;_ebaf ._abae .Bottom =bottom ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_fefec *Creator )NewParagraph (text string )*Paragraph {return _aedga (text ,_fefec .NewTextStyle ());};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};func (_gafb *Ellipse )applyFitMode (_aadc float64 ){_aadc -=_gafb ._gcbd .Left +_gafb ._gcbd .Right ;
switch _gafb ._gdce {case FitModeFillWidth :_gafb .ScaleToWidth (_aadc );};};type grayColor struct{_ebfd float64 };

// Reset removes all the text chunks the paragraph contains.
func (_dadc *StyledParagraph )Reset (){_dadc ._adebd =[]*TextChunk {}};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_edffc *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_bcbd ,_gdcdc :=_edffc .Wrap (width );if _gdcdc !=nil {return nil ,_gdcdc ;};_egce :=int (height /_edffc .Style .FontSize );if _egce >=len (_bcbd ){return nil ,nil ;};_efbffe :="\u000a";
_edffc .Text =_fa .Replace (_fa .Join (_bcbd [:_egce ],"\u0020"),_efbffe +"\u0020",_efbffe ,-1);_edfga :=_fa .Replace (_fa .Join (_bcbd [_egce :],"\u0020"),_efbffe +"\u0020",_efbffe ,-1);return NewTextChunk (_edfga ,_edffc .Style ),nil ;};

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_bacff *Table )MultiRowCell (rowspan int )*TableCell {return _bacff .MultiCell (rowspan ,1)};

// Scale scales the rectangle dimensions by the specified factors.
func (_bfbec *Rectangle )Scale (xFactor ,yFactor float64 ){_bfbec ._efdd =xFactor *_bfbec ._efdd ;_bfbec ._bbae =yFactor *_bfbec ._bbae ;};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_afff *Table )EnablePageWrap (enable bool ){_afff ._ccebb =enable };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_abeg *StyledParagraph )SetWidth (width float64 ){_abeg ._fcdc =width ;_abeg .wrapText ()};func _edgb (_dgfcc []_ebc .Point )*Polyline {return &Polyline {_cddce :&_ebc .Polyline {Points :_dgfcc ,LineColor :_bdd .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_fgcee :1.0};
};var (_fgdf =_ca .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");_gdadg =_ac .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");
_ggge =_ac .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");_dfaaf =_ac .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");
_feffg =_ac .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e"););

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_ccdf *Ellipse )ScaleToHeight (h float64 ){_efeae :=_ccdf ._bfddf /_ccdf ._cce ;_ccdf ._cce =h ;_ccdf ._bfddf =h *_efeae ;};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_gfd *_ebc .CurvePolygon ;_cfeb float64 ;_efde float64 ;_eabcg Color ;_eefe *int64 ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_fdee rune ;_aaegd []error ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_fbgfb *Invoice )BuyerAddress ()*InvoiceAddress {return _fbgfb ._cceff };

// MoveX moves the drawing context to absolute position x.
func (_bdgb *Creator )MoveX (x float64 ){_bdgb ._ebce .X =x };

// Width returns the width of the Paragraph.
func (_dca *Paragraph )Width ()float64 {if _dca ._ceaa &&int (_dca ._bbag )> 0{return _dca ._bbag ;};return _dca .getTextWidth ()/1000.0;};

// TOC returns the table of contents component of the creator.
func (_caf *Creator )TOC ()*TOC {return _caf ._fgde };

// DrawWithContext draws the Block using the specified drawing context.
func (_edf *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_bfb ,_ ,_baag :=d .GeneratePageBlocks (ctx );if _baag !=nil {return _baag ;};if len (_bfb )!=1{return ErrContentNotFit ;};for _ ,_dad :=range _bfb {if _bea :=_edf .mergeBlocks (_dad );
_bea !=nil {return _bea ;};};return nil ;};

// Height returns the current page height.
func (_efab *Creator )Height ()float64 {return _efab ._adfe };

// Opacity returns the opacity of the line.
func (_bfea *Line )Opacity ()float64 {return _bfea ._ecga };

// Vertical returns total vertical (top + bottom) margin.
func (_cfgea *Margins )Vertical ()float64 {return _cfgea .Bottom +_cfgea .Top };

// NewDivision returns a new Division container component.
func (_gadb *Creator )NewDivision ()*Division {return _dccb ()};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_gfgcff []*_bdd .PdfAnnotation ;_babaa []bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;_eeebc *int64 ;_afbec *string ;_caeed *string ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_ggga *Image )SetMargins (left ,right ,top ,bottom float64 ){_ggga ._aedc .Left =left ;_ggga ._aedc .Right =right ;_ggga ._aedc .Top =top ;_ggga ._aedc .Bottom =bottom ;};

// SetStyleRight sets border style for right side.
func (_bcc *border )SetStyleRight (style CellBorderStyle ){_bcc ._cgb =style };

// SetMargins sets the margins of the paragraph.
func (_gfgc *List )SetMargins (left ,right ,top ,bottom float64 ){_gfgc ._eaag .Left =left ;_gfgc ._eaag .Right =right ;_gfgc ._eaag .Top =top ;_gfgc ._eaag .Bottom =bottom ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_edgc float64 ;_cfdd float64 ;_decg float64 ;_ebeb float64 ;_fde float64 ;_dgg float64 ;_aage Color ;_cdf float64 ;_dcdb *int64 ;};func _accf (_cfaab TextStyle )*StyledParagraph {return &StyledParagraph {_adebd :[]*TextChunk {},_bgge :_cfaab ,_egeg :_badb (_cfaab .Font ),_adbbc :1.0,_egbdb :TextAlignmentLeft ,_bcdbe :true ,_acffb :true ,_cbbg :false ,_eefg :0,_gbddde :1,_beaeg :1,_geae :PositionRelative ,_cede :""};
};

// SetMarkedContentID sets the marked content ID for the chapter.
func (_afb *Chapter )SetMarkedContentID (id int64 )*_bdd .KDict {return nil };func _bbfda (_dacfb *_bdd .PdfFont ,_gebb float64 )*fontMetrics {_ffbf :=&fontMetrics {};if _dacfb ==nil {_da .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");
return _ffbf ;};_fbcfc ,_ebgd :=_dacfb .GetFontDescriptor ();if _ebgd !=nil {_da .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_ebgd );
return _ffbf ;};if _ffbf ._fdggf ,_ebgd =_fbcfc .GetCapHeight ();_ebgd !=nil {_da .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_ebgd );
};if int (_ffbf ._fdggf )<=0{_da .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_ffbf ._fdggf =1000;};_ffbf ._fdggf *=_gebb /1000.0;if _ffbf ._dgecce ,_ebgd =_fbcfc .GetXHeight ();_ebgd !=nil {_da .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_ebgd );
};_ffbf ._dgecce *=_gebb /1000.0;if _ffbf ._beefb ,_ebgd =_fbcfc .GetAscent ();_ebgd !=nil {_da .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_ebgd );
};_ffbf ._beefb *=_gebb /1000.0;if _ffbf ._dbba ,_ebgd =_fbcfc .GetDescent ();_ebgd !=nil {_da .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_ebgd );
};_ffbf ._dbba *=_gebb /1000.0;return _ffbf ;};type border struct{_fgca float64 ;_gdf float64 ;_abce float64 ;_ggc float64 ;_cac Color ;_aeg Color ;_bgb float64 ;_fed Color ;_cca float64 ;_dag Color ;_gea float64 ;_gcfd Color ;_fagd float64 ;LineStyle _ebc .LineStyle ;
_dacg CellBorderStyle ;_cgb CellBorderStyle ;_edbe CellBorderStyle ;_fcc CellBorderStyle ;_beb float64 ;};func (_eecg *templateProcessor )getNodeErrorLocation (_ggcegc *templateNode ,_dfeaa string ,_gdffg ...interface{})string {_acgcd :=_a .Sprintf (_dfeaa ,_gdffg ...);
_ccbdgf :=_a .Sprintf ("\u0025\u0064",_ggcegc ._cbcfd );if _ggcegc ._fabf !=0{_ccbdgf =_a .Sprintf ("\u0025\u0064\u003a%\u0064",_ggcegc ._fabf ,_ggcegc ._ebcf );};if _eecg ._abfe !=""{return _a .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_acgcd ,_eecg ._abfe ,_ccbdgf );
};return _a .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_acgcd ,_ccbdgf );};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;);type marginDrawable interface{VectorDrawable ;
GetMargins ()(float64 ,float64 ,float64 ,float64 );};func _ebeg (_fabdd *templateProcessor ,_agfed *templateNode )(interface{},error ){return _fabdd .parseBackground (_agfed );};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_abdea *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_bedc []*Block ;_feea =NewBlock (ctx .PageWidth ,ctx .PageHeight );_cccfg =ctx ;_bbgc ,_dedb =_abdea ._bcff ,ctx .PageHeight -_abdea ._cagcf ;_ebee ,_egcac =_abdea ._cbdf ,ctx .PageHeight -_abdea ._begf ;
);_fafeb :=_abdea ._bgad .IsRelative ();if _fafeb {ctx .X +=_abdea ._agbfd .Left ;ctx .Y +=_abdea ._agbfd .Top ;ctx .Width -=_abdea ._agbfd .Left +_abdea ._agbfd .Right ;ctx .Height -=_abdea ._agbfd .Top +_abdea ._agbfd .Bottom ;_bbgc ,_dedb ,_ebee ,_egcac =_abdea .computeCoords (ctx );
if _abdea .Height ()> ctx .Height {_bedc =append (_bedc ,_feea );_feea =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dagb :=ctx ;_dagb .Y =ctx .Margins .Top +_abdea ._agbfd .Top ;_dagb .X =ctx .Margins .Left +_abdea ._agbfd .Left ;_dagb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_abdea ._agbfd .Top -_abdea ._agbfd .Bottom ;
_dagb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_abdea ._agbfd .Left -_abdea ._agbfd .Right ;ctx =_dagb ;_bbgc ,_dedb ,_ebee ,_egcac =_abdea .computeCoords (ctx );};};_fcbce :=_ebc .BasicLine {X1 :_bbgc ,Y1 :_dedb ,X2 :_ebee ,Y2 :_egcac ,LineColor :_ddfd (_abdea ._ceecf ),Opacity :_abdea ._ecga ,LineWidth :_abdea ._dedd ,LineStyle :_abdea ._cbeb ,DashArray :_abdea ._dacf ,DashPhase :_abdea ._ggcc };
_cbbc ,_bebbd :=_feea .setOpacity (1.0,_abdea ._ecga );if _bebbd !=nil {return nil ,ctx ,_bebbd ;};_bbbf ,_ ,_bebbd :=_fcbce .MarkedDraw (_cbbc ,_abdea ._acfe );if _bebbd !=nil {return nil ,ctx ,_bebbd ;};if _bebbd =_feea .addContentsByString (string (_bbbf ));
_bebbd !=nil {return nil ,ctx ,_bebbd ;};if _fafeb {ctx .X =_cccfg .X ;ctx .Width =_cccfg .Width ;_gfdag :=_abdea .Height ();ctx .Y +=_gfdag +_abdea ._agbfd .Bottom ;ctx .Height -=_gfdag ;}else {ctx =_cccfg ;};_bedc =append (_bedc ,_feea );return _bedc ,ctx ,nil ;
};

// GeneratePageBlocks draw graphic svg into block.
func (_acec *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cacd :=ctx ;_ggbb :=_acec ._bdbc .IsRelative ();var _acde []*Block ;if _ggbb {_dgcb :=1.0;_dfbb :=_acec ._ggfgf .Top ;if _acec ._bac .Height > ctx .Height -_acec ._ggfgf .Top {_acde =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _cefee error ;if _ ,ctx ,_cefee =_ffdbg ().GeneratePageBlocks (ctx );_cefee !=nil {return nil ,ctx ,_cefee ;};_dfbb =0;};ctx .X +=_acec ._ggfgf .Left +_dgcb ;ctx .Y +=_dfbb ;ctx .Width -=_acec ._ggfgf .Left +_acec ._ggfgf .Right +2*_dgcb ;ctx .Height -=_dfbb ;
}else {ctx .X =_acec ._dede ;ctx .Y =_acec ._cagf ;};_cbda :=_ee .NewContentCreator ();_cbda .Translate (0,ctx .PageHeight );_cbda .Scale (1,-1);_cbda .Translate (ctx .X ,ctx .Y );_aabad :=_acec ._bac .Width /_acec ._bac .ViewBox .W ;_bffeg :=_acec ._bac .Height /_acec ._bac .ViewBox .H ;
_bceag :=0.0;_febcc :=0.0;if _ggbb {_bceag =_acec ._dede -(_acec ._bac .ViewBox .X *_bd .Max (_aabad ,_bffeg ));_febcc =_acec ._cagf -(_acec ._bac .ViewBox .Y *_bd .Max (_aabad ,_bffeg ));};_afc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _acec ._bebf !=nil {_cbda .Add_BDC (*_bdg .MakeName (_bdd .StructureTypeFigure ),map[string ]_bdg .PdfObject {"\u004d\u0043\u0049\u0044":_bdg .MakeInteger (*_acec ._bebf )});
};_acec ._bac .ToContentCreator (_cbda ,_afc ._fb ,_aabad ,_bffeg ,_bceag ,_febcc );if _acec ._bebf !=nil {_cbda .Add_EMC ();};if _gbab :=_afc .addContentsByString (_cbda .String ());_gbab !=nil {return nil ,ctx ,_gbab ;};if _ggbb {_eaga :=_acec .Height ()+_acec ._ggfgf .Bottom ;
ctx .Y +=_eaga ;ctx .Height -=_eaga ;}else {ctx =_cacd ;};_acde =append (_acde ,_afc );return _acde ,ctx ,nil ;};func _ecdb (_gedc *Block ,_acgg *StyledParagraph ,_cbfa [][]*TextChunk ,_gbbea DrawContext )(DrawContext ,[][]*TextChunk ,error ){_agdad :=1;
_gbed :=_bdg .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agdad ));for _gedc ._fb .HasFontByName (_gbed ){_agdad ++;_gbed =_bdg .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agdad ));};_dfaaa :=_gedc ._fb .SetFontByName (_gbed ,_acgg ._bgge .Font .ToPdfObject ());
if _dfaaa !=nil {return _gbbea ,nil ,_dfaaa ;};_agdad ++;_bcbe :=_gbed ;_abdde :=_acgg ._bgge .FontSize ;_dbgcb :=_acgg ._geae .IsRelative ();var _bacfd [][]_bdg .PdfObjectName ;var _dded [][]*TextChunk ;var _dbbg float64 ;for _eccab ,_egegd :=range _cbfa {var _aabb []_bdg .PdfObjectName ;
var _eaff float64 ;if len (_egegd )> 0{_eaff =_egegd [0].Style .FontSize ;};for _ ,_fgade :=range _egegd {_edbcd :=_fgade .Style ;if _fgade .Text !=""&&_edbcd .FontSize > _eaff {_eaff =_edbcd .FontSize ;};if _eaff > _gbbea .PageHeight {return _gbbea ,nil ,_ac .New ("\u0050\u0061\u0072\u0061\u0067\u0072a\u0070\u0068\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u006ca\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0070\u0061\u0067\u0065 \u0068e\u0069\u0067\u0068\u0074");
};_gbed =_bdg .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agdad ));_abge :=_gedc ._fb .SetFontByName (_gbed ,_edbcd .Font .ToPdfObject ());if _abge !=nil {return _gbbea ,nil ,_abge ;};_aabb =append (_aabb ,_gbed );_agdad ++;};_eaff *=_acgg ._adbbc ;
if _dbgcb &&_dbbg +_eaff > _gbbea .Height {_dded =_cbfa [_eccab :];_cbfa =_cbfa [:_eccab ];break ;};_dbbg +=_eaff ;_bacfd =append (_bacfd ,_aabb );};_bgbed ,_dcdac ,_befcb :=_acgg .getLineMetrics (0);_agbd ,_edgfg :=_bgbed *_acgg ._adbbc ,_dcdac *_acgg ._adbbc ;
if len (_cbfa )==0{return _gbbea ,_dded ,nil ;};_cfbff :=_ee .NewContentCreator ();_cfbff .Add_q ();_ffedc :=_edgfg ;if _acgg ._abed ==TextVerticalAlignmentCenter {_ffedc =_dcdac +(_bgbed +_befcb -_dcdac )/2+(_edgfg -_dcdac )/2;};_feca :=_gbbea .PageHeight -_gbbea .Y -_ffedc ;
_cfbff .Translate (_gbbea .X ,_feca );_fegbf :=_feca ;if _acgg ._eefg !=0{_cfbff .RotateDeg (_acgg ._eefg );};if _acgg ._cdag ==TextOverflowHidden {_cfbff .Add_re (0,-_dbbg +_agbd +1,_acgg ._fcdc ,_dbbg ).Add_W ().Add_n ();};_cfbff .Add_BT ();_eeecf :=map[string ]_bdg .PdfObject {};
if _acgg ._fdeb !=nil {_eeecf ["\u004d\u0043\u0049\u0044"]=_bdg .MakeInteger (*_acgg ._fdeb );};if _acgg ._cede !=""{_eeecf ["\u004c\u0061\u006e\u0067"]=_bdg .MakeString (_acgg ._cede );};if len (_eeecf )> 0{_cfbff .Add_BDC (*_bdg .MakeName (_bdd .StructureTypeParagraph ),_eeecf );
};var _dcaf []*_ebc .BasicLine ;for _daed ,_gdec :=range _cbfa {_dbebb :=_gbbea .X ;var _ebec float64 ;if len (_gdec )> 0{_ebec =_gdec [0].Style .FontSize ;};_bgbed ,_ ,_befcb =_acgg .getLineMetrics (_daed );_edgfg =(_bgbed +_befcb );for _ ,_dege :=range _gdec {_fgdb :=&_dege .Style ;
if _dege .Text !=""&&_fgdb .FontSize > _ebec {_ebec =_fgdb .FontSize ;};if _edgfg > _ebec {_ebec =_edgfg ;};};if _daed !=0{_cfbff .Add_TD (0,-_ebec *_acgg ._adbbc );_fegbf -=_ebec *_acgg ._adbbc ;};_cbegd :=_daed ==len (_cbfa )-1;var (_bacc float64 ;_eafc float64 ;
_fgee *fontMetrics ;_gfcg float64 ;_bagbe uint ;);var _bcgbc []float64 ;for _ ,_egeab :=range _gdec {_bgfc :=&_egeab .Style ;if _bgfc .FontSize > _eafc {_eafc =_bgfc .FontSize ;_fgee =_bbfda (_egeab .Style .Font ,_bgfc .FontSize );};if _edgfg > _eafc {_eafc =_edgfg ;
};_ggaaf ,_abdcb :=_bgfc .Font .GetRuneMetrics (' ');if _ggaaf .Wx ==0&&_bgfc .MultiFont !=nil {_ggaaf ,_abdcb =_bgfc .MultiFont .GetRuneMetrics (' ');_bgfc .MultiFont .Reset ();};if !_abdcb {return _gbbea ,nil ,_ac .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _beaege uint ;var _gceg float64 ;_gedf :=len (_egeab .Text );for _agfa ,_fdddc :=range _egeab .Text {if _fdddc ==' '{_beaege ++;continue ;};if _fdddc =='\u000A'{continue ;};_afggf ,_gded :=_bgfc .Font .GetRuneMetrics (_fdddc );if _afggf .Wx ==0&&_bgfc .MultiFont !=nil {_afggf ,_gded =_bgfc .MultiFont .GetRuneMetrics (' ');
_bgfc .MultiFont .Reset ();};if !_gded {_da .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_fdddc );return _gbbea ,nil ,_ac .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");
};_gceg +=_bgfc .FontSize *_afggf .Wx *_bgfc .horizontalScale ();if _agfa !=_gedf -1{_gceg +=_bgfc .CharSpacing *1000.0;};};_bcgbc =append (_bcgbc ,_gceg );_bacc +=_gceg ;_gfcg +=float64 (_beaege )*_ggaaf .Wx *_bgfc .FontSize *_bgfc .horizontalScale ();
_bagbe +=_beaege ;};_eafc *=_acgg ._adbbc ;var _gbgc []_bdg .PdfObject ;_ebedc :=_acgg ._fcdc *1000.0;if _acgg ._egbdb ==TextAlignmentJustify {if _bagbe > 0&&!_cbegd {_gfcg =(_ebedc -_bacc )/float64 (_bagbe )/_abdde ;};}else if _acgg ._egbdb ==TextAlignmentCenter {_eegge :=(_ebedc -_bacc -_gfcg )/2;
_dagbb :=_eegge /_abdde ;_gbgc =append (_gbgc ,_bdg .MakeFloat (-_dagbb ));_dbebb +=_eegge /1000.0;}else if _acgg ._egbdb ==TextAlignmentRight {_gdfg :=(_ebedc -_bacc -_gfcg );_fcdf :=_gdfg /_abdde ;_gbgc =append (_gbgc ,_bdg .MakeFloat (-_fcdf ));_dbebb +=_gdfg /1000.0;
};if len (_gbgc )> 0{_cfbff .Add_Tf (_bcbe ,_abdde ).Add_TL (_abdde *_acgg ._adbbc ).Add_TJ (_gbgc ...);};_fgcf :=0.0;for _addd ,_gabc :=range _gdec {_aaega :=&_gabc .Style ;_cdgda :=_bcbe ;_cfdg :=_abdde ;_cdbbf :=_aaega .OutlineColor !=nil ;_cfgcc :=_aaega .HorizontalScaling !=DefaultHorizontalScaling ;
_bcfdffa :=_aaega .OutlineSize !=1;if _bcfdffa {_cfbff .Add_w (_aaega .OutlineSize );};_cgae :=_aaega .RenderingMode !=TextRenderingModeFill ;if _cgae {_cfbff .Add_Tr (int64 (_aaega .RenderingMode ));};_dafdc :=_aaega .CharSpacing !=0;if _dafdc {_cfbff .Add_Tc (_aaega .CharSpacing );
};_gdfag :=_aaega .TextRise !=0;if _gdfag {_cfbff .Add_Ts (_aaega .TextRise );};if _gabc .VerticalAlignment !=TextVerticalAlignmentBaseline {_aaag :=_bbfda (_gabc .Style .Font ,_aaega .FontSize );switch _gabc .VerticalAlignment {case TextVerticalAlignmentCenter :_fgcf =_fgee ._dgecce /2-_aaag ._dgecce /2;
case TextVerticalAlignmentBottom :_fgcf =_fgee ._dbba -_aaag ._dbba ;case TextVerticalAlignmentTop :_fgcf =_dcdac -_aaega .FontSize ;};if _fgcf !=0.0{_cfbff .Translate (0,_fgcf );};};if _acgg ._egbdb !=TextAlignmentJustify ||_cbegd {_eebbg ,_fddfa :=_aaega .Font .GetRuneMetrics (' ');
if !_fddfa {return _gbbea ,nil ,_ac .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_cdgda =_bacfd [_daed ][_addd ];_cfdg =_aaega .FontSize ;
_gfcg =_eebbg .Wx *_aaega .horizontalScale ();};_dgdea :=_aaega .Font .Encoder ();var _gfaac []byte ;var _ebbee bool ;_ecgbd :=_aaega .Font ;_afbf :=map[string ]_bdg .PdfObject {};if _gabc ._afbec !=nil {_afbf ["\u0045"]=_bdg .MakeString (*_gabc ._afbec );
};if _gabc ._caeed !=nil {_afbf ["\u0041\u0063\u0074\u0075\u0061\u006c\u0054\u0065\u0078\u0074"]=_bdg .MakeString (*_gabc ._caeed );};if _gabc ._eeebc !=nil {_afbf ["\u004d\u0043\u0049\u0044"]=_bdg .MakeInteger (*_gabc ._eeebc );};if len (_afbf )> 0{_cfbff .Add_BDC (*_bdg .MakeName (_bdd .StructureTypeSpan ),_afbf );
};for _ ,_edabd :=range _gabc .Text {if _edabd =='\u000A'{continue ;};if _edabd ==' '{if len (_gfaac )> 0{if _cdbbf {_cfbff .SetStrokingColor (_ddfd (_aaega .OutlineColor ));};if _cfgcc {_cfbff .Add_Tz (_aaega .HorizontalScaling );};_abaa :=_bacfd [_daed ][_addd ];
if _ebbee {_abaa =_bdg .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agdad ));_cead :=_gedc ._fb .SetFontByName (_abaa ,_ecgbd .ToPdfObject ());if _cead !=nil {return _gbbea ,nil ,_cead ;};_agdad ++;_ebbee =false ;_dgdea =_aaega .Font .Encoder ();
};_cfbff .SetNonStrokingColor (_ddfd (_aaega .Color )).Add_Tf (_abaa ,_aaega .FontSize ).Add_TJ ([]_bdg .PdfObject {_bdg .MakeStringFromBytes (_gfaac )}...);_gfaac =nil ;};if _cfgcc {_cfbff .Add_Tz (DefaultHorizontalScaling );};_cfbff .Add_Tf (_cdgda ,_cfdg ).Add_TJ ([]_bdg .PdfObject {_bdg .MakeFloat (-_gfcg )}...);
_bcgbc [_addd ]+=_gfcg *_cfdg ;}else {if _ ,_dbdad :=_dgdea .RuneToCharcode (_edabd );!_dbdad {if _aaega .MultiFont !=nil {_cbfe ,_aefa :=_aaega .MultiFont .Encoder (_edabd );if _aefa {if len (_gfaac )!=0{_cdgf :=_bdg .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agdad ));
_bcgde :=_gedc ._fb .SetFontByName (_cdgda ,_ecgbd .ToPdfObject ());if _bcgde !=nil {return _gbbea ,nil ,_bcgde ;};_cfbff .SetNonStrokingColor (_ddfd (_aaega .Color )).Add_Tf (_cdgf ,_aaega .FontSize ).Add_TJ ([]_bdg .PdfObject {_bdg .MakeStringFromBytes (_gfaac )}...);
_agdad ++;_gfaac =nil ;};_dgdea =_cbfe ;_ebbee =true ;_ecgbd =_aaega .MultiFont .CurrentFont ;};}else {_dfaaa =UnsupportedRuneError {Message :_a .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_edabd ,_edabd ),Rune :_edabd };
_gbbea ._aaegd =append (_gbbea ._aaegd ,_dfaaa );_da .Log .Debug (_dfaaa .Error ());if _gbbea ._fdee <=0{continue ;};_edabd =_gbbea ._fdee ;};};_geadc :=_dgdea .Encode (string (_edabd ));_gfaac =append (_gfaac ,_geadc ...);};if _aaega .MultiFont !=nil {_aaega .MultiFont .Reset ();
};};if len (_gfaac )> 0{if _cdbbf {_cfbff .SetStrokingColor (_ddfd (_aaega .OutlineColor ));};if _cfgcc {_cfbff .Add_Tz (_aaega .HorizontalScaling );};_eaec :=_bacfd [_daed ][_addd ];if _ebbee {_eaec =_bdg .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_agdad ));
_bgdab :=_gedc ._fb .SetFontByName (_eaec ,_ecgbd .ToPdfObject ());if _bgdab !=nil {return _gbbea ,nil ,_bgdab ;};_agdad ++;_ebbee =false ;};_cfbff .SetNonStrokingColor (_ddfd (_aaega .Color )).Add_Tf (_eaec ,_aaega .FontSize ).Add_TJ ([]_bdg .PdfObject {_bdg .MakeStringFromBytes (_gfaac )}...);
};if len (_afbf )> 0{_cfbff .Add_EMC ();};_cbcc :=_bcgbc [_addd ]/1000.0;if _aaega .Underline {_gccf :=_aaega .UnderlineStyle .Color ;if _gccf ==nil {_gccf =_gabc .Style .Color ;};_abda ,_ccgg ,_fafcg :=_gccf .ToRGB ();_bdfc :=_dbebb -_gbbea .X ;_cfeg :=_fegbf -_feca +_aaega .TextRise -_aaega .UnderlineStyle .Offset ;
_dcaf =append (_dcaf ,&_ebc .BasicLine {X1 :_bdfc ,Y1 :_cfeg ,X2 :_bdfc +_cbcc ,Y2 :_cfeg ,LineWidth :_gabc .Style .UnderlineStyle .Thickness ,LineColor :_bdd .NewPdfColorDeviceRGB (_abda ,_ccgg ,_fafcg )});};for _fcaf ,_gbbcb :=range _gabc ._gfgcff {var _ecgc *_bdg .PdfObjectArray ;
if len (_gabc ._babaa )==_fcaf {switch _gbaf :=_gbbcb .GetContext ().(type ){case *_bdd .PdfAnnotationLink :_ecgc =_bdg .MakeArray ();_gbaf .Rect =_ecgc ;_cdbbbg ,_edfg :=_gbaf .Dest .(*_bdg .PdfObjectArray );if _edfg &&_cdbbbg .Len ()==5{_gecg ,_dgge :=_cdbbbg .Get (1).(*_bdg .PdfObjectName );
if _dgge &&_gecg .String ()=="\u0058\u0059\u005a"{_gegfe ,_eaebf :=_bdg .GetNumberAsFloat (_cdbbbg .Get (3));if _eaebf ==nil {_cdbbbg .Set (3,_bdg .MakeFloat (_gbbea .PageHeight -_gegfe ));};};};case *_bdd .PdfAnnotationHighlight :_ecgc =_bdg .MakeArray ();
_gbaf .Rect =_ecgc ;_bdbg :=_dbebb ;_ebfc :=_fegbf +_aaega .TextRise ;_fgaac :=_edcbf (&_bdd .PdfRectangle {Llx :_bdbg ,Lly :_ebfc ,Urx :_bdbg +_cbcc ,Ury :_ebfc +_eafc },_acgg ._eefg );_gbaf .QuadPoints =_bdg .MakeArrayFromFloats ([]float64 {_fgaac [0].X ,_fgaac [0].Y ,_fgaac [1].X ,_fgaac [1].Y ,_fgaac [3].X ,_fgaac [3].Y ,_fgaac [2].X ,_fgaac [2].Y });
};_gabc ._babaa =append (_gabc ._babaa ,true );};if _ecgc !=nil {_agdd :=_ebc .NewPoint (_dbebb -_gbbea .X ,_fegbf +_aaega .TextRise -_feca ).Rotate (_acgg ._eefg );_agdd .X +=_gbbea .X ;_agdd .Y +=_feca ;_aabd ,_cdaf ,_gaab ,_aabbf :=_ddgef (_cbcc ,_eafc ,_acgg ._eefg );
_agdd .X +=_aabd ;_agdd .Y +=_cdaf ;_ecgc .Clear ();_ecgc .Append (_bdg .MakeFloat (_agdd .X ));_ecgc .Append (_bdg .MakeFloat (_agdd .Y ));_ecgc .Append (_bdg .MakeFloat (_agdd .X +_gaab ));_ecgc .Append (_bdg .MakeFloat (_agdd .Y +_aabbf ));};_gedc .AddAnnotation (_gbbcb );
};_dbebb +=_cbcc ;if _bcfdffa {_cfbff .Add_w (1.0);};if _cdbbf {_cfbff .Add_RG (0.0,0.0,0.0);};if _cgae {_cfbff .Add_Tr (int64 (TextRenderingModeFill ));};if _dafdc {_cfbff .Add_Tc (0);};if _gdfag {_cfbff .Add_Ts (0);};if _cfgcc {_cfbff .Add_Tz (DefaultHorizontalScaling );
};if _fgcf !=0.0{_cfbff .Translate (0,-_fgcf );_fgcf =0.0;};};};if len (_eeecf )> 0{_cfbff .Add_EMC ();};_cfbff .Add_ET ();for _ ,_cged :=range _dcaf {_cfbff .SetStrokingColor (_cged .LineColor ).Add_w (_cged .LineWidth ).Add_m (_cged .X1 ,_cged .Y1 ).Add_l (_cged .X2 ,_cged .Y2 ).Add_s ();
};_cfbff .Add_Q ();_dcgbg :=_cfbff .Operations ();_dcgbg .WrapIfNeeded ();_gedc .addContents (_dcgbg );if _dbgcb {_cebg :=_dbbg ;_gbbea .Y +=_cebg ;_gbbea .Height -=_cebg ;if _gbbea .Inline {_gbbea .X +=_acgg .Width ()+_acgg ._cgfa .Right ;};};return _gbbea ,_dded ,nil ;
};func _ecag (_fdafb *_ccf .File )([]*_bdd .PdfPage ,error ){_ddcef ,_gfag :=_bdd .NewPdfReader (_fdafb );if _gfag !=nil {return nil ,_gfag ;};_ddcdd ,_gfag :=_ddcef .GetNumPages ();if _gfag !=nil {return nil ,_gfag ;};var _gbbga []*_bdd .PdfPage ;for _dcgeaf :=0;
_dcgeaf < _ddcdd ;_dcgeaf ++{_befdc ,_dabca :=_ddcef .GetPage (_dcgeaf +1);if _dabca !=nil {return nil ,_dabca ;};_gbbga =append (_gbbga ,_befdc );};return _gbbga ,nil ;};func _aebc (_ccfc []byte )(*Image ,error ){_ccbd :=_ab .NewReader (_ccfc );_fefed ,_gbeec :=_bdd .ImageHandling .Read (_ccbd );
if _gbeec !=nil {_da .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gbeec );return nil ,_gbeec ;};return _cdbb (_fefed );};

// SetMarkedContentID sets the marked content id for the chart.
func (_ccaeg *Chart )SetMarkedContentID (mcid int64 )*_bdd .KDict {_ccaeg ._edca =&mcid ;_ggeg :=_bdd .NewKDictionary ();_ggeg .S =_bdg .MakeName (_bdd .StructureTypeFigure );_ggeg .K =_bdg .MakeInteger (mcid );return _ggeg ;};func _cbbd (_ecdf *templateProcessor ,_gdbdb *templateNode )(interface{},error ){return _ecdf .parseRectangle (_gdbdb );
};func _cfb (_faba ,_efaa *_bdd .PdfPageResources )error {_ffd ,_ :=_faba .GetColorspaces ();if _ffd !=nil &&len (_ffd .Colorspaces )> 0{for _eda ,_gce :=range _ffd .Colorspaces {_efbb :=*_bdg .MakeName (_eda );if _efaa .HasColorspaceByName (_efbb ){continue ;
};_egc :=_efaa .SetColorspaceByName (_efbb ,_gce );if _egc !=nil {return _egc ;};};};return nil ;};

// SetBorderWidth sets the border width of the ellipse.
func (_agfc *Ellipse )SetBorderWidth (bw float64 ){_agfc ._bffg =bw };

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_gcegc *Table )Width ()float64 {return 0};

// SetSellerAddress sets the seller address of the invoice.
func (_eabb *Invoice )SetSellerAddress (address *InvoiceAddress ){_eabb ._bccg =address };func (_agae *templateProcessor )parseDivision (_bdfab *templateNode )(interface{},error ){_gfebda :=_agae .creator .NewDivision ();for _ ,_gcae :=range _bdfab ._edag .Attr {_fgafd :=_gcae .Value ;
switch _gagde :=_gcae .Name .Local ;_gagde {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_gfebda .EnablePageWrap (_agae .parseBoolAttr (_gagde ,_fgafd ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_edgeb :=_agae .parseMarginAttr (_gagde ,_fgafd );
_gfebda .SetMargins (_edgeb .Left ,_edgeb .Right ,_edgeb .Top ,_edgeb .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_faeg :=_agae .parseMarginAttr (_gagde ,_fgafd );_gfebda .SetPadding (_faeg .Left ,_faeg .Right ,_faeg .Top ,_faeg .Bottom );default:_agae .nodeLogDebug (_bdfab ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gagde );
};};return _gfebda ,nil ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_adc *Block )ScaleToWidth (w float64 ){_gcf :=w /_adc ._ccb ;_adc .Scale (_gcf ,_gcf )};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_adaf *Invoice )SetNoteHeadingStyle (style TextStyle ){_adaf ._bddd =style };func _dab (_ebfe string )(*GraphicSVG ,error ){_bbdc ,_fcba :=_fc .ParseFromString (_ebfe );if _fcba !=nil {return nil ,_fcba ;};return _deg (_bbdc );};func _fbcee (_afadb int )*Table {_adab :=&Table {_ccdbbe :_afadb ,_afdg :10.0,_aabdd :[]float64 {},_abfdc :[]float64 {},_eafe :[]*TableCell {},_ffcdc :make ([]int ,_afadb ),_ccebb :true };
_adab .resetColumnWidths ();return _adab ;};

// SetBorderColor sets the border color of the ellipse.
func (_egfdd *Ellipse )SetBorderColor (col Color ){_egfdd ._dage =col };func _fcga (_ccffb ,_dffbb ,_bdbaf int )[]int {_babe :=[]int {};for _aegd :=_ccffb ;_aegd <=_bdbaf ;_aegd +=_dffbb {_babe =append (_babe ,_aegd );};return _babe ;};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_cggbb *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_egdc :=_cggbb ;if _cggbb ._fbab {_egdc =_cggbb .clone ();};return _gcgdb (_egdc ,ctx );};func (_eebbd *StyledParagraph )getTextLineWidth (_dddb []*TextChunk )float64 {var _caaf float64 ;
_eedbc :=len (_dddb );for _dbgc ,_fbbc :=range _dddb {_bacf :=&_fbbc .Style ;_cefeef :=len (_fbbc .Text );for _aaead ,_dgbbb :=range _fbbc .Text {if _dgbbb =='\u000A'{continue ;};_bedga ,_efaabd :=_bacf .Font .GetRuneMetrics (_dgbbb );if !_efaabd {_da .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dgbbb );
return -1;};_caaf +=_bacf .FontSize *_bedga .Wx *_bacf .horizontalScale ();if _dgbbb !=' '&&(_dbgc !=_eedbc -1||_aaead !=_cefeef -1){_caaf +=_bacf .CharSpacing *1000.0;};};};return _caaf ;};

// SetMargins sets the margins TOC line.
func (_afbede *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_afbede ._afgca =left ;_cgef :=&_afbede ._cgcbd ._cgfa ;_cgef .Left =_afbede ._afgca +float64 (_afbede ._edcf -1)*_afbede ._cdbd ;_cgef .Right =right ;_cgef .Top =top ;_cgef .Bottom =bottom ;
};

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_acf *Chapter )Add (d Drawable )error {if Drawable (_acf )==d {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _ac .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _ecg :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_acf ._aedg =append (_acf ._aedg ,d );case containerDrawable :_bggb ,_ebcg :=_ecg .ContainerComponent (_acf );
if _ebcg !=nil {return _ebcg ;};_acf ._aedg =append (_acf ._aedg ,_bggb );default:_da .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _ac .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};const (DefaultHorizontalScaling =100;);func (_aagg *templateProcessor )parsePageBreak (_cgdba *templateNode )(interface{},error ){return _ffdbg (),nil ;};func (_bdbb *Table )moveToNextAvailableCell ()int {_dgafc :=(_bdbb ._gedb -1)%(_bdbb ._ccdbbe )+1;
for {if _dgafc -1>=len (_bdbb ._ffcdc ){if _bdbb ._ffcdc [0]==0{return _dgafc ;};_dgafc =1;}else if _bdbb ._ffcdc [_dgafc -1]==0{return _dgafc ;};_bdbb ._gedb ++;_bdbb ._ffcdc [_dgafc -1]--;_dgafc ++;};};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_fcbg *TableCell )SetContent (vd VectorDrawable )error {switch _ddcb :=vd .(type ){case *Paragraph :if _ddcb ._egeaa {_ddcb ._ceaa =true ;};_fcbg ._cbbgc =vd ;case *StyledParagraph :if _ddcb ._acffb {_ddcb ._bcdbe =true ;};_fcbg ._cbbgc =vd ;case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_fcbg ._cbbgc =vd ;
default:_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _bdg .ErrTypeError ;};return nil ;};func (_faeed *templateProcessor )processGradientColorPair (_eebe []string )(_bcdd []Color ,_bggdc []float64 ){for _ ,_fcgg :=range _eebe {var (_fdcee =_fa .Fields (_fcgg );_baeg =len (_fdcee ););if _baeg ==0{continue ;
};_bebgb :="";if _baeg > 1{_bebgb =_fa .TrimSpace (_fdcee [1]);};_fbfd :=-1.0;if _fa .HasSuffix (_bebgb ,"\u0025"){_ccbbbd ,_gbba :=_eb .ParseFloat (_bebgb [:len (_bebgb )-1],64);if _gbba !=nil {_da .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gbba );
};_fbfd =_ccbbbd /100.0;};_efccd :=_faeed .parseColor (_fa .TrimSpace (_fdcee [0]));if _efccd !=nil {_bcdd =append (_bcdd ,_efccd );_bggdc =append (_bggdc ,_fbfd );};};if len (_bcdd )!=len (_bggdc ){_da .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_fddge :=-1;_cbdg :=0.0;for _ffeed ,_abaeg :=range _bggdc {if _abaeg ==-1.0{if _ffeed ==0{_abaeg =0.0;_bggdc [_ffeed ]=0.0;continue ;};_fddge ++;if _ffeed < len (_bggdc )-1{continue ;}else {_abaeg =1.0;_bggdc [_ffeed ]=1.0;};};_eddbf :=_fddge +1;
for _gade :=_ffeed -_fddge ;_gade < _ffeed ;_gade ++{_bggdc [_gade ]=_cbdg +(float64 (_gade )*(_abaeg -_cbdg )/float64 (_eddbf ));};_cbdg =_abaeg ;_fddge =-1;};return _bcdd ,_bggdc ;};func _fdadc (_ddba *templateProcessor ,_eaaf *templateNode )(interface{},error ){return _ddba .parseEllipse (_eaaf );
};type pageTransformations struct{_ggg *_gc .Matrix ;_cedb bool ;_aeb bool ;};

// SetCompactMode sets the compact mode flag for this table.
//
// By enabling compact mode, table cell that contains Paragraph/StyleParagraph
// would not add extra height when calculating it's height.
//
// The default value is false.
func (_bdgd *Table )SetCompactMode (enable bool ){_bdgd ._afce =enable };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_bcdga *TOCLine )SetLink (page int64 ,x ,y float64 ){_bcdga ._adbf =x ;_bcdga ._cagac =y ;_bcdga ._ddbe =page ;_defb :=_bcdga ._cgcbd ._egeg .Color ;_bcdga .Number .Style .Color =_defb ;_bcdga .Title .Style .Color =_defb ;_bcdga .Separator .Style .Color =_defb ;
_bcdga .Page .Style .Color =_defb ;};

// SetInline sets the inline mode of the division.
func (_beeb *Division )SetInline (inline bool ){_beeb ._gcag =inline };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_afeg *shading )SetBackgroundColor (backgroundColor Color ){_afeg ._ddec =backgroundColor };func (_cccdf *TableCell )height (_cbad float64 )float64 {var _defcc float64 ;switch _efbddc :=_cccdf ._cbbgc .(type ){case *Paragraph :if _efbddc ._ceaa {_efbddc .SetWidth (_cbad -_cccdf ._gdfaa -_efbddc ._defec .Left -_efbddc ._defec .Right );
};_defcc =_efbddc .Height ()+_efbddc ._defec .Top +_efbddc ._defec .Bottom ;if !_cccdf ._bdffe ._afce {_defcc +=(0.5*_efbddc ._ccdc *_efbddc ._gfaa );};case *StyledParagraph :if _efbddc ._bcdbe {_efbddc .SetWidth (_cbad -_cccdf ._gdfaa -_efbddc ._cgfa .Left -_efbddc ._cgfa .Right );
};_defcc =_efbddc .Height ()+_efbddc ._cgfa .Top +_efbddc ._cgfa .Bottom ;if !_cccdf ._bdffe ._afce {_defcc +=(0.5*_efbddc .getTextHeight ());};case *Image :_efbddc .applyFitMode (_cbad -_cccdf ._gdfaa );_defcc =_efbddc .Height ()+_efbddc ._aedc .Top +_efbddc ._aedc .Bottom ;
case *Table :_efbddc .updateRowHeights (_cbad -_cccdf ._gdfaa -_efbddc ._geefd .Left -_efbddc ._geefd .Right );_defcc =_efbddc .Height ()+_efbddc ._geefd .Top +_efbddc ._geefd .Bottom ;case *List :_defcc =_efbddc .ctxHeight (_cbad -_cccdf ._gdfaa )+_efbddc ._eaag .Top +_efbddc ._eaag .Bottom ;
case *Division :_defcc =_efbddc .ctxHeight (_cbad -_cccdf ._gdfaa )+_efbddc ._egba .Top +_efbddc ._egba .Bottom +_efbddc ._gcfg .Top +_efbddc ._gcfg .Bottom ;case *Chart :_defcc =_efbddc .Height ()+_efbddc ._ccae .Top +_efbddc ._ccae .Bottom ;case *Rectangle :_efbddc .applyFitMode (_cbad -_cccdf ._gdfaa );
_defcc =_efbddc .Height ()+_efbddc ._abae .Top +_efbddc ._abae .Bottom +_efbddc ._agad ;case *Ellipse :_efbddc .applyFitMode (_cbad -_cccdf ._gdfaa );_defcc =_efbddc .Height ()+_efbddc ._gcbd .Top +_efbddc ._gcbd .Bottom ;case *Line :_defcc =_efbddc .Height ()+_efbddc ._agbfd .Top +_efbddc ._agbfd .Bottom ;
};return _defcc ;};func _dfgg (_fgf _ef .ChartRenderable )*Chart {return &Chart {_efbgc :_fgf ,_fae :PositionRelative ,_ccae :Margins {Top :10,Bottom :10}};};func _dcgdf (_aadgd ,_bece ,_gcbf ,_ecggc float64 )*Rectangle {return &Rectangle {_cbcfa :_aadgd ,_ffdf :_bece ,_efdd :_gcbf ,_bbae :_ecggc ,_dgdf :PositionAbsolute ,_cdebe :1.0,_egbf :ColorBlack ,_agad :1.0,_ecfdd :1.0};
};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _eaf ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_aafb :=&Creator {};_aafb ._bcdf =[]*_bdd .PdfPage {};_aafb ._dbce =map[*_bdd .PdfPage ]*Block {};_aafb ._acff =map[*_bdd .PdfPage ]*pageTransformations {};
_aafb .SetPageSize (PageSizeLetter );_cfa :=0.1*_aafb ._bccc ;_aafb ._ebcd .Left =_cfa ;_aafb ._ebcd .Right =_cfa ;_aafb ._ebcd .Top =_cfa ;_aafb ._ebcd .Bottom =_cfa ;var _eccg error ;_aafb ._abb ,_eccg =_bdd .NewStandard14Font (_bdd .HelveticaName );
if _eccg !=nil {_aafb ._abb =_bdd .DefaultFont ();};_aafb ._bbaf ,_eccg =_bdd .NewStandard14Font (_bdd .HelveticaBoldName );if _eccg !=nil {_aafb ._abb =_bdd .DefaultFont ();};_aafb ._fgde =_aafb .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");
_aafb .AddOutlines =true ;_aafb ._bgce =_bdd .NewOutline ();_daf .TrackUse (_eaf );return _aafb ;};

// Height returns the height of the list.
func (_gdddf *List )Height ()float64 {var _baad float64 ;for _ ,_gefc :=range _gdddf ._agcde {_baad +=_gefc .ctxHeight (_gdddf .Width ());};return _baad ;};

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_gegab *shading )SetExtends (start bool ,end bool ){_gegab ._agda =[]bool {start ,end }};

// SetIndent sets the left offset of the list when nested into another list.
func (_bdab *List )SetIndent (indent float64 ){_bdab ._ccgdf =indent ;_bdab ._fgea =false };const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// GeneratePageBlocks generates a page break block.
func (_dgfff *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eccb :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_ggccc :=ctx ;_ggccc .Y =ctx .Margins .Top ;
_ggccc .X =ctx .Margins .Left ;_ggccc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_ggccc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_ggccc ;return _eccb ,ctx ,nil ;};

// GeneratePageBlocks implements drawable interface.
func (_aaa *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bged :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_egfb :=_aaa ._fgca ;_efbbc :=ctx .PageHeight -_aaa ._gdf ;if _aaa ._cac !=nil {_agf :=_ebc .Rectangle {Opacity :1.0,X :_aaa ._fgca ,Y :ctx .PageHeight -_aaa ._gdf -_aaa ._ggc ,Height :_aaa ._ggc ,Width :_aaa ._abce };
_agf .FillEnabled =true ;_cef :=_ddfd (_aaa ._cac );_fac :=_fcgdf (_bged ,_cef ,_aaa ._cac ,func ()Rectangle {return Rectangle {_cbcfa :_agf .X ,_ffdf :_agf .Y ,_efdd :_agf .Width ,_bbae :_agf .Height };});if _fac !=nil {return nil ,ctx ,_fac ;};_agf .FillColor =_cef ;
_agf .BorderEnabled =false ;_deef :="";if _aaa ._beb < 1{_fdb :=_bdg .MakeDict ();_fdb .Set ("\u0063\u0061",_bdg .MakeFloat (_aaa ._beb ));_fdb .Set ("\u0043\u0041",_bdg .MakeFloat (_aaa ._beb ));_gge :=_bged ._fb .AddExtGState ("\u0067\u0073\u0031",_fdb );
if _gge ==nil {_deef ="\u0067\u0073\u0031";};};_bga ,_ ,_fac :=_agf .Draw (_deef );if _fac !=nil {return nil ,ctx ,_fac ;};_fac =_bged .addContentsByString (string (_bga ));if _fac !=nil {return nil ,ctx ,_fac ;};};_eeca :=_aaa ._fagd ;_cdc :=_aaa ._cca ;
_cdb :=_aaa ._bgb ;_ccff :=_aaa ._gea ;_cba :=_aaa ._fagd ;if _aaa ._edbe ==CellBorderStyleDouble {_cba +=2*_eeca ;};_ebgf :=_aaa ._cca ;if _aaa ._fcc ==CellBorderStyleDouble {_ebgf +=2*_cdc ;};_dgad :=_aaa ._bgb ;if _aaa ._dacg ==CellBorderStyleDouble {_dgad +=2*_cdb ;
};_fdf :=_aaa ._gea ;if _aaa ._cgb ==CellBorderStyleDouble {_fdf +=2*_ccff ;};_defa :=(_cba -_dgad )/2;_abe :=(_cba -_fdf )/2;_bbb :=(_ebgf -_dgad )/2;_ceeec :=(_ebgf -_fdf )/2;if _aaa ._fagd !=0{_dec :=_egfb ;_ggbg :=_efbbc ;if _aaa ._edbe ==CellBorderStyleDouble {_ggbg -=_eeca ;
_adg :=_ebc .BasicLine {LineColor :_ddfd (_aaa ._gcfd ),Opacity :1.0,LineWidth :_aaa ._fagd ,LineStyle :_aaa .LineStyle ,X1 :_dec -_cba /2+_defa ,Y1 :_ggbg +2*_eeca ,X2 :_dec +_cba /2-_abe +_aaa ._abce ,Y2 :_ggbg +2*_eeca };_fdbd ,_ ,_cdg :=_adg .Draw ("");
if _cdg !=nil {return nil ,ctx ,_cdg ;};_cdg =_bged .addContentsByString (string (_fdbd ));if _cdg !=nil {return nil ,ctx ,_cdg ;};};_aegb :=_ebc .BasicLine {LineWidth :_aaa ._fagd ,Opacity :1.0,LineColor :_ddfd (_aaa ._gcfd ),LineStyle :_aaa .LineStyle ,X1 :_dec -_cba /2+_defa +(_dgad -_aaa ._bgb ),Y1 :_ggbg ,X2 :_dec +_cba /2-_abe +_aaa ._abce -(_fdf -_aaa ._gea ),Y2 :_ggbg };
_ege ,_ ,_gdcf :=_aegb .Draw ("");if _gdcf !=nil {return nil ,ctx ,_gdcf ;};_gdcf =_bged .addContentsByString (string (_ege ));if _gdcf !=nil {return nil ,ctx ,_gdcf ;};};if _aaa ._cca !=0{_gad :=_egfb ;_efeeg :=_efbbc -_aaa ._ggc ;if _aaa ._fcc ==CellBorderStyleDouble {_efeeg +=_cdc ;
_gbe :=_ebc .BasicLine {LineWidth :_aaa ._cca ,Opacity :1.0,LineColor :_ddfd (_aaa ._fed ),LineStyle :_aaa .LineStyle ,X1 :_gad -_ebgf /2+_bbb ,Y1 :_efeeg -2*_cdc ,X2 :_gad +_ebgf /2-_ceeec +_aaa ._abce ,Y2 :_efeeg -2*_cdc };_bed ,_ ,_bgc :=_gbe .Draw ("");
if _bgc !=nil {return nil ,ctx ,_bgc ;};_bgc =_bged .addContentsByString (string (_bed ));if _bgc !=nil {return nil ,ctx ,_bgc ;};};_dacb :=_ebc .BasicLine {LineWidth :_aaa ._cca ,Opacity :1.0,LineColor :_ddfd (_aaa ._fed ),LineStyle :_aaa .LineStyle ,X1 :_gad -_ebgf /2+_bbb +(_dgad -_aaa ._bgb ),Y1 :_efeeg ,X2 :_gad +_ebgf /2-_ceeec +_aaa ._abce -(_fdf -_aaa ._gea ),Y2 :_efeeg };
_bggd ,_ ,_deed :=_dacb .Draw ("");if _deed !=nil {return nil ,ctx ,_deed ;};_deed =_bged .addContentsByString (string (_bggd ));if _deed !=nil {return nil ,ctx ,_deed ;};};if _aaa ._bgb !=0{_cgca :=_egfb ;_bgec :=_efbbc ;if _aaa ._dacg ==CellBorderStyleDouble {_cgca +=_cdb ;
_cbg :=_ebc .BasicLine {LineWidth :_aaa ._bgb ,Opacity :1.0,LineColor :_ddfd (_aaa ._aeg ),LineStyle :_aaa .LineStyle ,X1 :_cgca -2*_cdb ,Y1 :_bgec +_dgad /2+_defa ,X2 :_cgca -2*_cdb ,Y2 :_bgec -_dgad /2-_bbb -_aaa ._ggc };_fcb ,_ ,_cdge :=_cbg .Draw ("");
if _cdge !=nil {return nil ,ctx ,_cdge ;};_cdge =_bged .addContentsByString (string (_fcb ));if _cdge !=nil {return nil ,ctx ,_cdge ;};};_feag :=_ebc .BasicLine {LineWidth :_aaa ._bgb ,Opacity :1.0,LineColor :_ddfd (_aaa ._aeg ),LineStyle :_aaa .LineStyle ,X1 :_cgca ,Y1 :_bgec +_dgad /2+_defa -(_cba -_aaa ._fagd ),X2 :_cgca ,Y2 :_bgec -_dgad /2-_bbb -_aaa ._ggc +(_ebgf -_aaa ._cca )};
_ceb ,_ ,_dcec :=_feag .Draw ("");if _dcec !=nil {return nil ,ctx ,_dcec ;};_dcec =_bged .addContentsByString (string (_ceb ));if _dcec !=nil {return nil ,ctx ,_dcec ;};};if _aaa ._gea !=0{_caeb :=_egfb +_aaa ._abce ;_gdbg :=_efbbc ;if _aaa ._cgb ==CellBorderStyleDouble {_caeb -=_ccff ;
_becd :=_ebc .BasicLine {LineWidth :_aaa ._gea ,Opacity :1.0,LineColor :_ddfd (_aaa ._dag ),LineStyle :_aaa .LineStyle ,X1 :_caeb +2*_ccff ,Y1 :_gdbg +_fdf /2+_abe ,X2 :_caeb +2*_ccff ,Y2 :_gdbg -_fdf /2-_ceeec -_aaa ._ggc };_dgc ,_ ,_bab :=_becd .Draw ("");
if _bab !=nil {return nil ,ctx ,_bab ;};_bab =_bged .addContentsByString (string (_dgc ));if _bab !=nil {return nil ,ctx ,_bab ;};};_dgffb :=_ebc .BasicLine {LineWidth :_aaa ._gea ,Opacity :1.0,LineColor :_ddfd (_aaa ._dag ),LineStyle :_aaa .LineStyle ,X1 :_caeb ,Y1 :_gdbg +_fdf /2+_abe -(_cba -_aaa ._fagd ),X2 :_caeb ,Y2 :_gdbg -_fdf /2-_ceeec -_aaa ._ggc +(_ebgf -_aaa ._cca )};
_effa ,_ ,_bbf :=_dgffb .Draw ("");if _bbf !=nil {return nil ,ctx ,_bbf ;};_bbf =_bged .addContentsByString (string (_effa ));if _bbf !=nil {return nil ,ctx ,_bbf ;};};return []*Block {_bged },ctx ,nil ;};

// SetPos sets absolute positioning with specified coordinates.
func (_fdcc *Paragraph )SetPos (x ,y float64 ){_fdcc ._abcfeg =PositionAbsolute ;_fdcc ._edac =x ;_fdcc ._gadge =y ;};func _acce (_dddf [][]_ebc .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_gfd :&_ebc .CurvePolygon {Rings :_dddf },_cfeb :1.0,_efde :1.0};
};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_geac *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _geac ._ccae .Left ,_geac ._ccae .Right ,_geac ._ccae .Top ,_geac ._ccae .Bottom ;};

// SetWidth sets the width of the ellipse.
func (_aedb *Ellipse )SetWidth (width float64 ){_aedb ._bfddf =width };

// SetMargins sets the Table's left, right, top, bottom margins.
func (_gbfba *Table )SetMargins (left ,right ,top ,bottom float64 ){_gbfba ._geefd .Left =left ;_gbfba ._geefd .Right =right ;_gbfba ._geefd .Top =top ;_gbfba ._geefd .Bottom =bottom ;};func (_fdbfb *templateProcessor )parseImage (_bcgcf *templateNode )(interface{},error ){var _eegbd string ;
for _ ,_ffeaa :=range _bcgcf ._edag .Attr {_dbcd :=_ffeaa .Value ;switch _gedaf :=_ffeaa .Name .Local ;_gedaf {case "\u0073\u0072\u0063":_eegbd =_dbcd ;};};_agga ,_fecdgc :=_fdbfb .loadImageFromSrc (_eegbd );if _fecdgc !=nil {return nil ,_fecdgc ;};var _dcfag _bdg .StreamEncoder ;
_ffbe :=_fa .ToLower (_db .Ext (_eegbd ));if _ffbe =="\u006a\u0070\u0067"||_ffbe =="\u006a\u0070\u0065\u0067"{_dcfag =_bdg .NewDCTEncoder ();}else {_dcfag =_bdg .NewFlateEncoder ();};_agga .SetEncoder (_dcfag );for _ ,_bgba :=range _bcgcf ._edag .Attr {_egeb :=_bgba .Value ;
switch _gacfa :=_bgba .Name .Local ;_gacfa {case "\u0061\u006c\u0069g\u006e":_agga .SetHorizontalAlignment (_fdbfb .parseHorizontalAlignmentAttr (_gacfa ,_egeb ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_agga .SetOpacity (_fdbfb .parseFloatAttr (_gacfa ,_egeb ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_deeae :=_fdbfb .parseMarginAttr (_gacfa ,_egeb );_agga .SetMargins (_deeae .Left ,_deeae .Right ,_deeae .Top ,_deeae .Bottom );case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_agga .SetFitMode (_fdbfb .parseFitModeAttr (_gacfa ,_egeb ));
case "\u0078":_agga .SetPos (_fdbfb .parseFloatAttr (_gacfa ,_egeb ),_agga ._bacd );case "\u0079":_agga .SetPos (_agga ._eeff ,_fdbfb .parseFloatAttr (_gacfa ,_egeb ));case "\u0077\u0069\u0064t\u0068":_agga .SetWidth (_fdbfb .parseFloatAttr (_gacfa ,_egeb ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_agga .SetHeight (_fdbfb .parseFloatAttr (_gacfa ,_egeb ));case "\u0061\u006e\u0067l\u0065":_agga .SetAngle (_fdbfb .parseFloatAttr (_gacfa ,_egeb ));case "\u0065n\u0063\u006f\u0064\u0065\u0072":_dcfag =_fdbfb .parseImageEncoder (_gacfa ,_egeb );
if _dcfag !=nil {_agga .SetEncoder (_dcfag );};case "\u0073\u0072\u0063":break ;default:_fdbfb .nodeLogDebug (_bcgcf ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_gacfa );
};};return _agga ,nil ;};func (_acbc *Paragraph )getTextLineWidth (_bdef string )float64 {var _aadg float64 ;for _ ,_gbge :=range _bdef {if _gbge =='\u000A'{continue ;};_fegb ,_dafe :=_acbc ._gfac .GetRuneMetrics (_gbge );if !_dafe {_da .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_gbge ,_gbge );
return -1;};_aadg +=_acbc ._ccdc *_fegb .Wx ;};return _aadg ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_aebe *Table )SetPos (x ,y float64 ){_aebe ._acggb =PositionAbsolute ;_aebe ._fcbca =x ;_aebe ._bcab =y ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_gg *Block )SetPos (x ,y float64 ){_gg ._ce =PositionAbsolute ;_gg ._ed =x ;_gg ._dfa =y };

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_dadae *LinearShading )AddShadingResource (block *Block )(_gbfe _bdg .PdfObjectName ,_cdac error ){_eecdf :=1;_gbfe =_bdg .PdfObjectName ("\u0053\u0068"+_eb .Itoa (_eecdf ));for block ._fb .HasShadingByName (_gbfe ){_eecdf ++;_gbfe =_bdg .PdfObjectName ("\u0053\u0068"+_eb .Itoa (_eecdf ));
};if _eacdb :=block ._fb .SetShadingByName (_gbfe ,_dadae .shadingModel ().ToPdfObject ());_eacdb !=nil {return "",_eacdb ;};return _gbfe ,nil ;};

// Height returns the height of the line.
func (_bagd *Line )Height ()float64 {_dcbe :=_bagd ._dedd ;if _bagd ._bcff ==_bagd ._cbdf {_dcbe /=2;};return _bd .Abs (_bagd ._begf -_bagd ._cagcf )+_dcbe ;};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_gdbd *RadialShading )AddShadingResource (block *Block )(_adceb _bdg .PdfObjectName ,_bcbge error ){_gacc :=1;_adceb =_bdg .PdfObjectName ("\u0053\u0068"+_eb .Itoa (_gacc ));for block ._fb .HasShadingByName (_adceb ){_gacc ++;_adceb =_bdg .PdfObjectName ("\u0053\u0068"+_eb .Itoa (_gacc ));
};if _eccd :=block ._fb .SetShadingByName (_adceb ,_gdbd .shadingModel ().ToPdfObject ());_eccd !=nil {return "",_eccd ;};return _adceb ,nil ;};func (_dagbd *templateProcessor )parseLinearGradientAttr (creator *Creator ,_efbbg string )Color {_gbddc :=ColorBlack ;
if _efbbg ==""{return _gbddc ;};_aeagg :=creator .NewLinearGradientColor ([]*ColorPoint {});_aeagg .SetExtends (true ,true );var (_caebc =_fa .Split (_efbbg [16:len (_efbbg )-1],"\u002c");_dfae =_fa .TrimSpace (_caebc [0]););if _fa .HasSuffix (_dfae ,"\u0064\u0065\u0067"){_dcgbb ,_aagda :=_eb .ParseFloat (_dfae [:len (_dfae )-3],64);
if _aagda !=nil {_da .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_aagda );}else {_aeagg .SetAngle (_dcgbb );
};_caebc =_caebc [1:];};_acdac ,_fabcga :=_dagbd .processGradientColorPair (_caebc );if _acdac ==nil ||_fabcga ==nil {return _gbddc ;};for _gbaad :=0;_gbaad < len (_acdac );_gbaad ++{_aeagg .AddColorStop (_acdac [_gbaad ],_fabcga [_gbaad ]);};return _aeagg ;
};func _badb (_eegc *_bdd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_eegc ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};};


// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_afefc *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_feba :=NewTextChunk (text ,_afefc ._egeg );_feba .AddAnnotation (_aaafb (url ));return _afefc .appendChunk (_feba );};type componentRenderer interface{Draw (_cgdgg Drawable )error ;
};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);func (_ceeae *templateProcessor )renderNode (_fbead *templateNode )error {_efefac :=_fbead ._cdab ;if _efefac ==nil {return nil ;};_adaa :=_fbead ._edag .Name .Local ;
_bcdfe ,_fabfa :=_bcdea [_adaa ];if !_fabfa {_ceeae .nodeLogDebug (_fbead ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_adaa );return nil ;};var _dcca interface{};
if _fbead ._fcdcc !=nil &&_fbead ._fcdcc ._cdab !=nil {_deded :=_fbead ._fcdcc ._edag .Name .Local ;if _ ,_fabfa =_bcdfe ._cgadf [_deded ];!_fabfa {_ceeae .nodeLogDebug (_fbead ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_deded ,_adaa );
return _ggge ;};_dcca =_fbead ._fcdcc ._cdab ;}else {_adbbe :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _ceeae ._efede .(type ){case *Block :_adbbe ="\u0062\u006c\u006fc\u006b";};if _ ,_fabfa =_bcdfe ._cgadf [_adbbe ];!_fabfa {_ceeae .nodeLogDebug (_fbead ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_adbbe ,_adaa );
return _ggge ;};_dcca =_ceeae ._efede ;};switch _eabcb :=_dcca .(type ){case componentRenderer :_cbdb ,_bdaca :=_efefac .(Drawable );if !_bdaca {_ceeae .nodeLogError (_fbead ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_adaa ,_efefac );
return _dfaaf ;};_bbda :=_eabcb .Draw (_cbdb );if _bbda !=nil {return _ceeae .nodeError (_fbead ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_adaa ,_efefac ,_bbda );
};case *Division :switch _ffgce :=_efefac .(type ){case *Background :_eabcb .SetBackground (_ffgce );case VectorDrawable :_agccdd :=_eabcb .Add (_ffgce );if _agccdd !=nil {return _ceeae .nodeError (_fbead ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_adaa ,_efefac ,_agccdd );
};};case *TableCell :_dggb ,_beeab :=_efefac .(VectorDrawable );if !_beeab {_ceeae .nodeLogError (_fbead ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_adaa ,_efefac );
return _dfaaf ;};_ecbff :=_eabcb .SetContent (_dggb );if _ecbff !=nil {return _ceeae .nodeError (_fbead ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_adaa ,_efefac ,_ecbff );
};case *StyledParagraph :_cafb ,_agdc :=_efefac .(*TextChunk );if !_agdc {_ceeae .nodeLogError (_fbead ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_adaa ,_efefac );
return _dfaaf ;};_eabcb .appendChunk (_cafb );case *Chapter :switch _bfae :=_efefac .(type ){case *Chapter :return nil ;case *Paragraph :if _fbead ._edag .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_cgee :=_eabcb .Add (_bfae );if _cgee !=nil {return _ceeae .nodeError (_fbead ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_adaa ,_efefac ,_cgee );
};case Drawable :_cdedc :=_eabcb .Add (_bfae );if _cdedc !=nil {return _ceeae .nodeError (_fbead ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_adaa ,_efefac ,_cdedc );
};};case *List :switch _gffc :=_efefac .(type ){case *TextChunk :case *listItem :_eabcb ._agcde =append (_eabcb ._agcde ,_gffc );default:_ceeae .nodeLogError (_fbead ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_adaa ,_efefac );
};case *listItem :switch _eabcc :=_efefac .(type ){case *TextChunk :case *StyledParagraph :_eabcb ._ffda =_eabcc ;case *List :if _eabcc ._fgea {_eabcc ._ccgdf =15;};_eabcb ._ffda =_eabcc ;case *Image :_eabcb ._ffda =_eabcc ;case *Division :_eabcb ._ffda =_eabcc ;
case *Table :_eabcb ._ffda =_eabcc ;default:_ceeae .nodeLogError (_fbead ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_adaa ,_efefac );
return _dfaaf ;};};return nil ;};

// SetColorBottom sets border color for bottom.
func (_gcc *border )SetColorBottom (col Color ){_gcc ._fed =col };func _bcb (_efa *_ee .ContentStreamOperations ,_cee *_bdd .PdfPageResources ,_add *_ee .ContentStreamOperations ,_cbc *_bdd .PdfPageResources )error {_fgg :=map[_bdg .PdfObjectName ]_bdg .PdfObjectName {};
_bff :=map[_bdg .PdfObjectName ]_bdg .PdfObjectName {};_efc :=map[_bdg .PdfObjectName ]_bdg .PdfObjectName {};_gfa :=map[_bdg .PdfObjectName ]_bdg .PdfObjectName {};_eee :=map[_bdg .PdfObjectName ]_bdg .PdfObjectName {};_fd :=map[_bdg .PdfObjectName ]_bdg .PdfObjectName {};
for _ ,_bdf :=range *_add {switch _bdf .Operand {case "\u0044\u006f":if len (_bdf .Params )==1{if _dacc ,_aab :=_bdf .Params [0].(*_bdg .PdfObjectName );_aab {if _ ,_afg :=_fgg [*_dacc ];!_afg {var _ge _bdg .PdfObjectName ;_fbg ,_ :=_cbc .GetXObjectByName (*_dacc );
if _fbg !=nil {_ge =*_dacc ;for {_ccg ,_ :=_cee .GetXObjectByName (_ge );if _ccg ==nil ||_ccg ==_fbg {break ;};_ge =*_bdg .MakeName (_acgc (_ge .String ()));};};_cee .SetXObjectByName (_ge ,_fbg );_fgg [*_dacc ]=_ge ;};_gfc :=_fgg [*_dacc ];_bdf .Params [0]=&_gfc ;
};};case "\u0054\u0066":if len (_bdf .Params )==2{if _bgfa ,_dae :=_bdf .Params [0].(*_bdg .PdfObjectName );_dae {if _ ,_dge :=_bff [*_bgfa ];!_dge {_cd ,_aaf :=_cbc .GetFontByName (*_bgfa );_fgc :=*_bgfa ;if _aaf &&_cd !=nil {_fgc =_egg (_bgfa .String (),_cd ,_cee );
};_cee .SetFontByName (_fgc ,_cd );_bff [*_bgfa ]=_fgc ;};_ddg :=_bff [*_bgfa ];_bdf .Params [0]=&_ddg ;};};case "\u0043\u0053","\u0063\u0073":if len (_bdf .Params )==1{if _bfbc ,_gcd :=_bdf .Params [0].(*_bdg .PdfObjectName );_gcd {if _ ,_ag :=_efc [*_bfbc ];
!_ag {var _eeb _bdg .PdfObjectName ;_cgd ,_bcd :=_cbc .GetColorspaceByName (*_bfbc );if _bcd {_eeb =*_bfbc ;for {_gbc ,_cbcd :=_cee .GetColorspaceByName (_eeb );if !_cbcd ||_cgd ==_gbc {break ;};_eeb =*_bdg .MakeName (_acgc (_eeb .String ()));};_cee .SetColorspaceByName (_eeb ,_cgd );
_efc [*_bfbc ]=_eeb ;}else {_da .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _ggb ,_gdc :=_efc [*_bfbc ];_gdc {_bdf .Params [0]=&_ggb ;}else {_da .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_bfbc );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_bdf .Params )==1{if _ace ,_geg :=_bdf .Params [0].(*_bdg .PdfObjectName );_geg {if _ ,_dged :=_gfa [*_ace ];!_dged {var _edff _bdg .PdfObjectName ;_ebe ,_ead :=_cbc .GetPatternByName (*_ace );
if _ead {_edff =*_ace ;for {_fea ,_fcfa :=_cee .GetPatternByName (_edff );if !_fcfa ||_fea ==_ebe {break ;};_edff =*_bdg .MakeName (_acgc (_edff .String ()));};_acc :=_cee .SetPatternByName (_edff ,_ebe .ToPdfObject ());if _acc !=nil {return _acc ;};_gfa [*_ace ]=_edff ;
};};if _dbf ,_ffgb :=_gfa [*_ace ];_ffgb {_bdf .Params [0]=&_dbf ;};};};case "\u0073\u0068":if len (_bdf .Params )==1{if _adcd ,_cadf :=_bdf .Params [0].(*_bdg .PdfObjectName );_cadf {if _ ,_eab :=_eee [*_adcd ];!_eab {var _fef _bdg .PdfObjectName ;_ga ,_bee :=_cbc .GetShadingByName (*_adcd );
if _bee {_fef =*_adcd ;for {_feb ,_dfg :=_cee .GetShadingByName (_fef );if !_dfg ||_ga ==_feb {break ;};_fef =*_bdg .MakeName (_acgc (_fef .String ()));};_efea :=_cee .SetShadingByName (_fef ,_ga .ToPdfObject ());if _efea !=nil {_da .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_efea );
return _efea ;};_eee [*_adcd ]=_fef ;}else {_da .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _fgb ,_bfa :=_eee [*_adcd ];_bfa {_bdf .Params [0]=&_fgb ;}else {_da .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_adcd );
};};};case "\u0067\u0073":if len (_bdf .Params )==1{if _gda ,_agd :=_bdf .Params [0].(*_bdg .PdfObjectName );_agd {if _ ,_agb :=_fd [*_gda ];!_agb {var _dff _bdg .PdfObjectName ;_ffe ,_accd :=_cbc .GetExtGState (*_gda );if _accd {_dff =*_gda ;for {_cde ,_beg :=_cee .GetExtGState (_dff );
if !_beg ||_ffe ==_cde {break ;};_dff =*_bdg .MakeName (_acgc (_dff .String ()));};};_cee .AddExtGState (_dff ,_ffe );_fd [*_gda ]=_dff ;};_ccgd :=_fd [*_gda ];_bdf .Params [0]=&_ccgd ;};};};*_efa =append (*_efa ,_bdf );};return nil ;};func (_aebd *Creator )setActivePage (_bgcf *_bdd .PdfPage ){_aebd ._agbc =_bgcf };


// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// SetMarkedContentID sets marked content ID.
func (_fdgaa *TOC )SetMarkedContentID (mcid int64 )*_bdd .KDict {return nil };

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_ffdd *RadialShading )AddPatternResource (block *Block )(_cecg _bdg .PdfObjectName ,_cceg error ){_eedec :=1;_acea :=_bdg .PdfObjectName ("\u0050"+_eb .Itoa (_eedec ));for block ._fb .HasPatternByName (_acea ){_eedec ++;_acea =_bdg .PdfObjectName ("\u0050"+_eb .Itoa (_eedec ));
};if _egbc :=block ._fb .SetPatternByName (_acea ,_ffdd .ToPdfShadingPattern ().ToPdfObject ());_egbc !=nil {return "",_egbc ;};return _acea ,nil ;};

// AddColorStop add color stop info for rendering gradient color.
func (_bbbgg *LinearShading )AddColorStop (color Color ,point float64 ){_bbbgg ._bdbcd .AddColorStop (color ,point );};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_bcdb *RadialShading )ToPdfShadingPattern ()*_bdd .PdfShadingPatternType3 {_gdcg ,_bgdbe ,_eabga :=_bcdb ._eddc ._ddec .ToRGB ();_cegb :=_bcdb .shadingModel ();_cegb .PdfShading .Background =_bdg .MakeArrayFromFloats ([]float64 {_gdcg ,_bgdbe ,_eabga });
_fccf :=_bdd .NewPdfShadingPatternType3 ();_fccf .Shading =_cegb ;return _fccf ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_facd *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_facd ._affg =&_bdd .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_cbga *Image )SetPos (x ,y float64 ){_cbga ._edeb =PositionAbsolute ;_cbga ._eeff =x ;_cbga ._bacd =y ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_fede *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dedgb :=ctx ;var _cgad []*Block ;_cgde :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _fede ._geae .IsRelative (){ctx .X +=_fede ._cgfa .Left ;ctx .Y +=_fede ._cgfa .Top ;
ctx .Width -=_fede ._cgfa .Left +_fede ._cgfa .Right ;ctx .Height -=_fede ._cgfa .Top ;_fede .SetWidth (ctx .Width );}else {if int (_fede ._fcdc )<=0{_fede .SetWidth (_fede .getTextWidth ()/1000.0);};ctx .X =_fede ._ccbea ;ctx .Y =_fede ._cdgdb ;};if _fede ._dbab !=nil {_fede ._dbab (_fede ,ctx );
};if _fffa :=_fede .wrapText ();_fffa !=nil {return nil ,ctx ,_fffa ;};_gcgde :=_fede ._acebb ;_aebg :=0;for {_dfdgc ,_eadb ,_ecce :=_ecdb (_cgde ,_fede ,_gcgde ,ctx );if _ecce !=nil {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ecce );
return nil ,ctx ,_ecce ;};ctx =_dfdgc ;_cgad =append (_cgad ,_cgde );if _gcgde =_eadb ;len (_eadb )==0{break ;};if len (_eadb )==_aebg {return nil ,ctx ,_ac .New ("\u006e\u006f\u0074\u0020\u0065\u006e\u006f\u0075\u0067\u0068 \u0073\u0070\u0061\u0063\u0065\u0020\u0066o\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068");
};_cgde =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dfdgc =ctx ;_dfdgc .Y =ctx .Margins .Top ;_dfdgc .X =ctx .Margins .Left +_fede ._cgfa .Left ;_dfdgc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_dfdgc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_fede ._cgfa .Left -_fede ._cgfa .Right ;
ctx =_dfdgc ;_aebg =len (_eadb );};if _fede ._geae .IsRelative (){ctx .Y +=_fede ._cgfa .Bottom ;ctx .Height -=_fede ._cgfa .Bottom ;if !ctx .Inline {ctx .X =_dedgb .X ;ctx .Width =_dedgb .Width ;};return _cgad ,ctx ,nil ;};return _cgad ,_dedgb ,nil ;};


// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_gfebd *Invoice )AddressHeadingStyle ()TextStyle {return _gfebd ._ecgg };func (_ggcb *templateProcessor )parseBackground (_effbg *templateNode )(interface{},error ){_dbfc :=&Background {};for _ ,_ccbgbe :=range _effbg ._edag .Attr {_cfac :=_ccbgbe .Value ;
switch _gbbg :=_ccbgbe .Name .Local ;_gbbg {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_dbfc .FillColor =_ggcb .parseColorAttr (_gbbg ,_cfac );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_dbfc .BorderColor =_ggcb .parseColorAttr (_gbbg ,_cfac );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_dbfc .BorderSize =_ggcb .parseFloatAttr (_gbbg ,_cfac );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_gced ,_ccde ,_cdffe ,_dgccc :=_ggcb .parseBorderRadiusAttr (_gbbg ,_cfac );
_dbfc .SetBorderRadius (_gced ,_ccde ,_dgccc ,_cdffe );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_dbfc .BorderRadiusTopLeft =_ggcb .parseFloatAttr (_gbbg ,_cfac );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_dbfc .BorderRadiusTopRight =_ggcb .parseFloatAttr (_gbbg ,_cfac );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_dbfc .BorderRadiusBottomLeft =_ggcb .parseFloatAttr (_gbbg ,_cfac );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_dbfc .BorderRadiusBottomRight =_ggcb .parseFloatAttr (_gbbg ,_cfac );
default:_ggcb .nodeLogDebug (_effbg ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_gbbg );
};};return _dbfc ,nil ;};func _fecd (_fdge string )(*Image ,error ){_eadc ,_cgdd :=_ccf .Open (_fdge );if _cgdd !=nil {return nil ,_cgdd ;};defer _eadc .Close ();_cbfc ,_cgdd :=_bdd .ImageHandling .Read (_eadc );if _cgdd !=nil {_da .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cgdd );
return nil ,_cgdd ;};return _cdbb (_cbfc );};

// RotatedSize returns the width and height of the rotated block.
func (_bae *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_edb ,_gf :=_ddgef (_bae ._ccb ,_bae ._cb ,_bae ._daa );return _edb ,_gf ;};

// SetFont sets the Paragraph's font.
func (_dgef *Paragraph )SetFont (font *_bdd .PdfFont ){_dgef ._gfac =font };

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bcfd *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _bcfd ._bfbbc [0],_bcfd ._bfbbc [1]};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_bgca *Invoice )InfoLines ()[][2]*InvoiceCell {_fecdd :=[][2]*InvoiceCell {_bgca ._bfbbc ,_bgca ._egec ,_bgca ._ecbb };return append (_fecdd ,_bgca ._beeae ...);};

// SetDate sets the date of the invoice.
func (_ffaegb *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_ffaegb ._egec [1].Value =date ;return _ffaegb ._egec [0],_ffaegb ._egec [1];};

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _cdbc (color ,point )};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_abec *Division )Height ()float64 {var _bagg float64 ;for _ ,_febg :=range _abec ._gbfd {switch _geef :=_febg .(type ){case marginDrawable :_ ,_ ,_daggf ,_abdd :=_geef .GetMargins ();_bagg +=_geef .Height ()+_daggf +_abdd ;default:_bagg +=_geef .Height ();
};};return _bagg ;};

// SetMarkedContentID sets the marked content identifier.
func (_acdef *Polygon )SetMarkedContentID (mcid int64 )*_bdd .KDict {_acdef ._ggab =&mcid ;_dgbb :=_bdd .NewKDictionary ();_dgbb .S =_bdg .MakeName (_bdd .StructureTypeFigure );_dgbb .K =_bdg .MakeInteger (mcid );return _dgbb ;};func _ggega (_afae *templateProcessor ,_ebea *templateNode )(interface{},error ){return _afae .parseStyledParagraph (_ebea );
};func (_bdbf *templateProcessor )parseTextOverflowAttr (_fceaa ,_ccdfa string )TextOverflow {_da .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_fceaa ,_ccdfa );
_efac :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_ccdfa ];return _efac ;};func (_fgdcg *templateProcessor )parseChart (_cgcfb *templateNode )(interface{},error ){var _acgfg string ;
for _ ,_fedf :=range _cgcfb ._edag .Attr {_baba :=_fedf .Value ;switch _aebf :=_fedf .Name .Local ;_aebf {case "\u0073\u0072\u0063":_acgfg =_baba ;};};if _acgfg ==""{_fgdcg .nodeLogError (_cgcfb ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_feffg ;};_ccffa ,_efcce :=_fgdcg ._cggc .ChartMap [_acgfg ];if !_efcce {_fgdcg .nodeLogError (_cgcfb ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_acgfg );
return nil ,_feffg ;};_ddgag :=NewChart (_ccffa );for _ ,_dbgf :=range _cgcfb ._edag .Attr {_egdbc :=_dbgf .Value ;switch _cccfbf :=_dbgf .Name .Local ;_cccfbf {case "\u0078":_ddgag .SetPos (_fgdcg .parseFloatAttr (_cccfbf ,_egdbc ),_ddgag ._fda );case "\u0079":_ddgag .SetPos (_ddgag ._gcbc ,_fgdcg .parseFloatAttr (_cccfbf ,_egdbc ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_dbcaa :=_fgdcg .parseMarginAttr (_cccfbf ,_egdbc );_ddgag .SetMargins (_dbcaa .Left ,_dbcaa .Right ,_dbcaa .Top ,_dbcaa .Bottom );case "\u0077\u0069\u0064t\u0068":_ddgag ._efbgc .SetWidth (int (_fgdcg .parseFloatAttr (_cccfbf ,_egdbc )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_ddgag ._efbgc .SetHeight (int (_fgdcg .parseFloatAttr (_cccfbf ,_egdbc )));case "\u0073\u0072\u0063":break ;default:_fgdcg .nodeLogDebug (_cgcfb ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_cccfbf );
};};return _ddgag ,nil ;};

// SetFillOpacity sets the fill opacity of the ellipse.
func (_gabe *Ellipse )SetFillOpacity (opacity float64 ){_gabe ._fgbc =opacity };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline ,_gfgcff :[]*_bdd .PdfAnnotation {},_babaa :[]bool {}};};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_cdbbb *Image )GetHorizontalAlignment ()HorizontalAlignment {return _cdbbb ._cafee };

// Invoice represents a configurable invoice template.
type Invoice struct{_cbgeg string ;_ddac *Image ;_cceff *InvoiceAddress ;_bccg *InvoiceAddress ;_dfdg string ;_bfbbc [2]*InvoiceCell ;_egec [2]*InvoiceCell ;_ecbb [2]*InvoiceCell ;_beeae [][2]*InvoiceCell ;_abbcg []*InvoiceCell ;_dbebc [][]*InvoiceCell ;
_cfgg [2]*InvoiceCell ;_afgg [2]*InvoiceCell ;_fbce [][2]*InvoiceCell ;_eabd [2]string ;_ggbee [2]string ;_gbac [][2]string ;_fcaa TextStyle ;_ecgg TextStyle ;_ggceg TextStyle ;_bdaa TextStyle ;_afde TextStyle ;_addg TextStyle ;_bddd TextStyle ;_dadd InvoiceCellProps ;
_dgfa InvoiceCellProps ;_dgfgd InvoiceCellProps ;_ffcge InvoiceCellProps ;_aeec Positioning ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_deeg *Invoice )Sections ()[][2]string {return _deeg ._gbac };

// GeneratePageBlocks draws the curve onto page blocks.
func (_aaaf *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_egbb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_acgf :=_ee .NewContentCreator ();if _aaaf ._dcdb !=nil {_acgf .Add_BDC (*_bdg .MakeName (_bdd .StructureTypeFigure ),map[string ]_bdg .PdfObject {"\u004d\u0043\u0049\u0044":_bdg .MakeInteger (*_aaaf ._dcdb )});
};_acgf .Add_q ().Add_w (_aaaf ._cdf ).SetStrokingColor (_ddfd (_aaaf ._aage )).Add_m (_aaaf ._edgc ,ctx .PageHeight -_aaaf ._cfdd ).Add_v (_aaaf ._decg ,ctx .PageHeight -_aaaf ._ebeb ,_aaaf ._fde ,ctx .PageHeight -_aaaf ._dgg ).Add_S ().Add_Q ();if _aaaf ._dcdb !=nil {_acgf .Add_EMC ();
};_gdaef :=_egbb .addContentsByString (_acgf .String ());if _gdaef !=nil {return nil ,ctx ,_gdaef ;};return []*Block {_egbb },ctx ,nil ;};func _afcd (_dgcbe [][]_ebc .Point )*Polygon {return &Polygon {_bcgb :&_ebc .Polygon {Points :_dgcbe },_gcadc :1.0,_egcfc :1.0};
};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_gbbb *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_bdgad :=&_gbbb ._cgcbd ._cgfa ;return _gbbb ._afgca ,_bdgad .Right ,_bdgad .Top ,_bdgad .Bottom ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_bdag *TOC )SetShowLinks (showLinks bool ){_bdag ._egbac =showLinks };func (_cad *Block )translate (_ece ,_fcg float64 ){_faf :=_ee .NewContentCreator ().Translate (_ece ,-_fcg ).Operations ();*_cad ._ae =append (*_faf ,*_cad ._ae ...);_cad ._ae .WrapIfNeeded ();
};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_eaddg *Paragraph )SetMaxLines (maxLines int ){_eaddg ._gfgde =maxLines ;_eaddg .wrapText ()};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_gggeb *TOC )SetLineSeparator (separator string ){_gggeb ._agdgdc =separator };

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// MultiFont represents an encoder that accepts multiple fonts and selects the correct font for encoding.
MultiFont *_bdd .MultipleFontEncoder ;

// Font represents the font the text will use.
Font *_bdd .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_ceeee Drawable )(Drawable ,error );};

// CurCol returns the currently active cell's column number.
func (_cdff *Table )CurCol ()int {_agfff :=(_cdff ._gedb -1)%(_cdff ._ccdbbe )+1;return _agfff };

// SetBorderColor sets the border color.
func (_badf *CurvePolygon )SetBorderColor (color Color ){_badf ._gfd .BorderColor =_ddfd (color )};func (_aggbe *TextStyle )horizontalScale ()float64 {return _aggbe .HorizontalScaling /100};

// Level returns the indentation level of the TOC line.
func (_egac *TOCLine )Level ()uint {return _egac ._edcf };func (_fafg *StyledParagraph )split (_baga DrawContext )(_fdef ,_bfgca *StyledParagraph ,_edcae error ){if _edcae =_fafg .wrapChunks (false );_edcae !=nil {return nil ,nil ,_edcae ;};if len (_fafg ._acebb )==1&&_fafg ._adbbc > _baga .Height {return _fafg ,nil ,nil ;
};_aggb :=func (_cgdaf []*TextChunk ,_bdec []*TextChunk )[]*TextChunk {if len (_bdec )==0{return _cgdaf ;};_dcagf :=len (_cgdaf );if _dcagf ==0{return append (_cgdaf ,_bdec ...);};if _cgdaf [_dcagf -1].Style ==_bdec [0].Style {_cgdaf [_dcagf -1].Text +=_bdec [0].Text ;
}else {_cgdaf =append (_cgdaf ,_bdec [0]);};return append (_cgdaf ,_bdec [1:]...);};_gfaed :=func (_dfaf *StyledParagraph ,_fdgc []*TextChunk )*StyledParagraph {if len (_fdgc )==0{return nil ;};_eddaf :=*_dfaf ;_eddaf ._adebd =_fdgc ;return &_eddaf ;};
var (_beeaf float64 ;_dgeg []*TextChunk ;_bcec []*TextChunk ;);for _ ,_cceda :=range _fafg ._acebb {var _adbbcg float64 ;_agdgd :=make ([]*TextChunk ,0,len (_cceda ));for _ ,_dgca :=range _cceda {if _cacge :=_dgca .Style .FontSize ;_cacge > _adbbcg {_adbbcg =_cacge ;
};_agdgd =append (_agdgd ,_dgca .clone ());};_adbbcg *=_fafg ._adbbc ;if _fafg ._geae .IsRelative (){if _beeaf +_adbbcg > _baga .Height {_bcec =_aggb (_bcec ,_agdgd );}else {_dgeg =_aggb (_dgeg ,_agdgd );};};_beeaf +=_adbbcg ;};_fafg ._acebb =nil ;if len (_bcec )==0{return _fafg ,nil ,nil ;
};return _gfaed (_fafg ,_dgeg ),_gfaed (_fafg ,_bcec ),nil ;};func _bcbegg (_cecga *Creator ,_dbgeb _ebf .Reader ,_fcac interface{},_egbfd *TemplateOptions ,_cdccb componentRenderer )error {if _cecga ==nil {_da .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _gdadg ;};_efgff :="";if _cefc ,_ddbc :=_dbgeb .(*_ccf .File );_ddbc {_efgff =_cefc .Name ();};_egfad :=_ab .NewBuffer (nil );if _ ,_bbeb :=_ebf .Copy (_egfad ,_dbgeb );_bbeb !=nil {return _bbeb ;};_gebf :=_d .FuncMap {"\u0064\u0069\u0063\u0074":_gdecac ,"\u0061\u0064\u0064":_bbdd ,"\u0061\u0072\u0072a\u0079":_face ,"\u0065\u0078\u0074\u0065\u006e\u0064\u0044\u0069\u0063\u0074":_aabe ,"\u006da\u006b\u0065\u0053\u0065\u0071":_fcga };
if _egbfd !=nil &&_egbfd .HelperFuncMap !=nil {for _egab ,_agdfg :=range _egbfd .HelperFuncMap {if _ ,_agaf :=_gebf [_egab ];_agaf {_da .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_egab );
continue ;};_gebf [_egab ]=_agdfg ;};};_fdba ,_aefce :=_d .New ("").Funcs (_gebf ).Parse (_egfad .String ());if _aefce !=nil {return _aefce ;};if _egbfd !=nil &&_egbfd .SubtemplateMap !=nil {for _ccbdc ,_bbcc :=range _egbfd .SubtemplateMap {if _ccbdc ==""{_da .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _bbcc ==nil {_da .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_dfff :=_ab .NewBuffer (nil );if _ ,_agfcg :=_ebf .Copy (_dfff ,_bbcc );_agfcg !=nil {return _agfcg ;};if _ ,_gebe :=_fdba .New (_ccbdc ).Parse (_dfff .String ());_gebe !=nil {return _gebe ;};};};_egfad .Reset ();if _dgadbb :=_fdba .Execute (_egfad ,_fcac );
_dgadbb !=nil {return _dgadbb ;};return _ggfb (_cecga ,_efgff ,_egfad .Bytes (),_egbfd ,_cdccb ).run ();};

// SetAngle sets Image rotation angle in degrees.
func (_bebge *Image )SetAngle (angle float64 ){_bebge ._gdccb =angle };func (_gfdg *templateProcessor )parseChapterHeading (_gecac *templateNode )(interface{},error ){if _gecac ._fcdcc ==nil {_gfdg .nodeLogError (_gecac ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_ggge ;};_ggba ,_gagg :=_gecac ._fcdcc ._cdab .(*Chapter );if !_gagg {_gfdg .nodeLogError (_gecac ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_gecac ._fcdcc ._cdab );
return nil ,_ggge ;};_febdb :=_ggba .GetHeading ();if _ ,_ggea :=_gfdg .parseParagraph (_gecac ,_febdb );_ggea !=nil {return nil ,_ggea ;};return _febdb ,nil ;};func _dfcaf (_bgcd string )([]string ,error ){if !_f .ValidString (_bgcd ){return []string {_bgcd },_ac .New ("\u0069n\u0070\u0075\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020v\u0061\u006c\u0069\u0064\u0020\u0055\u0054\u0046\u002d\u0038");
};var (_bfde []string ;_ggdfe []rune ;);for _ ,_cafed :=range _bgcd {if _cafed =='\u000A'{if len (_ggdfe )> 0{_bfde =append (_bfde ,string (_ggdfe ));};_bfde =append (_bfde ,string (_cafed ));_ggdfe =nil ;continue ;};_ggdfe =append (_ggdfe ,_cafed );};
if len (_ggdfe )> 0{_bfde =append (_bfde ,string (_ggdfe ));};var _fgbff []string ;for _ ,_bcae :=range _bfde {_agfdb :=[]rune (_bcae );_egabg :=_ebd .NewScanner (_agfdb );var _dfceb []rune ;for _bcgec :=0;_bcgec < len (_agfdb );_bcgec ++{_ ,_fbace ,_caecf :=_egabg .Next ();
if _caecf !=nil {return nil ,_caecf ;};if _fbace ==_ebd .BreakProhibited ||_bg .IsSpace (_agfdb [_bcgec ]){_dfceb =append (_dfceb ,_agfdb [_bcgec ]);if _bg .IsSpace (_agfdb [_bcgec ]){_fgbff =append (_fgbff ,string (_dfceb ));_dfceb =[]rune {};};continue ;
}else {if len (_dfceb )> 0{_fgbff =append (_fgbff ,string (_dfceb ));};_dfceb =[]rune {_agfdb [_bcgec ]};};};if len (_dfceb )> 0{_fgbff =append (_fgbff ,string (_dfceb ));};};return _fgbff ,nil ;};

// SetOpacity sets the cell's opacity in the range 0-1.
func (_affb *TableCell )SetOpacity (opacity float64 ){_affb ._bdaf =opacity };

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_ebbda *TOC )SetLineTitleStyle (style TextStyle ){_ebbda ._cfad =style };

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_bdd .PdfPage )(*Block ,error ){_ebg :=&Block {};_fcf ,_gd :=page .GetAllContentStreams ();if _gd !=nil {return nil ,_gd ;};_dga :=_ee .NewContentStreamParser (_fcf );_eg ,_gd :=_dga .Parse ();if _gd !=nil {return nil ,_gd ;
};_eg .WrapIfNeeded ();_ebg ._ae =_eg ;if page .Resources !=nil {_ebg ._fb =page .Resources ;}else {_ebg ._fb =_bdd .NewPdfPageResources ();};_gdd ,_gd :=page .GetMediaBox ();if _gd !=nil {return nil ,_gd ;};if _gdd .Llx !=0||_gdd .Lly !=0{_ebg .translate (-_gdd .Llx ,_gdd .Lly );
};_ebg ._ccb =_gdd .Urx -_gdd .Llx ;_ebg ._cb =_gdd .Ury -_gdd .Lly ;if page .Rotate !=nil {_ebg ._daa =-float64 (*page .Rotate );};return _ebg ,nil ;};func (_dgecc *templateProcessor )nodeLogError (_gface *templateNode ,_dcdc string ,_gffb ...interface{}){_da .Log .Error (_dgecc .getNodeErrorLocation (_gface ,_dcdc ,_gffb ...));
};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_ffdc *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ffdc ._agbfd .Left ,_ffdc ._agbfd .Right ,_ffdc ._agbfd .Top ,_ffdc ._agbfd .Bottom ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_adfc int ;_ccdbbe int ;_gedb int ;_aabdd []float64 ;_abfdc []float64 ;_afdg float64 ;_eafe []*TableCell ;_ffcdc []int ;_acggb Positioning ;_fcbca ,_bcab float64 ;_geefd Margins ;_eeed bool ;_abeef int ;_cdfg int ;_fbab bool ;_ccebb bool ;
_afce bool ;};

// IsAbsolute checks if the positioning is absolute.
func (_beea Positioning )IsAbsolute ()bool {return _beea ==PositionAbsolute };

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//
//	red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_abcf :float64 (r )/255.0,_eae :float64 (g )/255.0,_gfg :float64 (b )/255.0};};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_dcff *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _efdgf (number ,title ,page ,level ,style );};func (_baca *TextChunk )clone ()*TextChunk {_ffgca :=*_baca ;_ffgca ._gfgcff =_bbgaa (_baca ._gfgcff );
return &_ffgca ;};func (_cgdb *List )split (_agfg DrawContext )(_bfga ,_efbd *List ){var (_fagg float64 ;_dbffa ,_ebcdf []*listItem ;);_ecbba :=_agfg .Width -_cgdb ._eaag .Horizontal ()-_cgdb ._ccgdf -_cgdb .markerWidth ();_afee :=_cgdb .markerWidth ();
for _dgffc ,_gfdd :=range _cgdb ._agcde {_aade :=_gfdd .ctxHeight (_ecbba );_fagg +=_aade ;if _fagg <=_agfg .Height {_dbffa =append (_dbffa ,_gfdd );}else {switch _ebbae :=_gfdd ._ffda .(type ){case *List :_gbfg :=_agfg ;_gbfg .Height =_bd .Floor (_aade -(_fagg -_agfg .Height ));
_dfee ,_ccad :=_ebbae .split (_gbfg );if _dfee !=nil {_cbeda :=_ffffd ();_cbeda ._baee =_gfdd ._baee ;_cbeda ._ffda =_dfee ;_dbffa =append (_dbffa ,_cbeda );};if _ccad !=nil {_bgccb :=_ebbae ._fdbb .Style .FontSize ;_efcd ,_edfa :=_ebbae ._fdbb .Style .Font .GetRuneMetrics (' ');
if _edfa {_bgccb =_ebbae ._fdbb .Style .FontSize *_efcd .Wx *_ebbae ._fdbb .Style .horizontalScale ()/1000.0;};_dcbca :=_fa .Repeat ("\u0020",int (_afee /_bgccb ));_dada :=_ffffd ();_dada ._baee =*NewTextChunk (_dcbca ,_ebbae ._fdbb .Style );_dada ._ffda =_ccad ;
_ebcdf =append (_ebcdf ,_dada );_ebcdf =append (_ebcdf ,_cgdb ._agcde [_dgffc +1:]...);};default:_ebcdf =_cgdb ._agcde [_dgffc :];};if len (_ebcdf )> 0{break ;};};};if len (_dbffa )> 0{_bfga =_geeea (_cgdb ._eacd );*_bfga =*_cgdb ;_bfga ._agcde =_dbffa ;
};if len (_ebcdf )> 0{_efbd =_geeea (_cgdb ._eacd );*_efbd =*_cgdb ;_efbd ._agcde =_ebcdf ;};return _bfga ,_efbd ;};

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_fdcce *Rectangle )ScaleToHeight (h float64 ){_ddgdd :=_fdcce ._efdd /_fdcce ._bbae ;_fdcce ._bbae =h ;_fdcce ._efdd =h *_ddgdd ;};type fontMetrics struct{_fdggf float64 ;_dgecce float64 ;_beefb float64 ;_dbba float64 ;};func (_dffg *templateProcessor )parseCellBorderStyleAttr (_cbec ,_efag string )CellBorderStyle {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_cbec ,_efag );
_bcgdf :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_efag ];return _bcgdf ;};func (_ddfff *Table )wrapRow (_dggeg int ,_gebc DrawContext ,_fafcgf float64 )(bool ,error ){if !_ddfff ._fbab {return false ,nil ;
};var (_bcdfd =_ddfff ._eafe [_dggeg ];_ccfg =-1;_acgfb []*TableCell ;_bage float64 ;_edbg bool ;_edfad =make ([]float64 ,0,len (_ddfff ._aabdd )););_ecgaa :=func (_gdeg *TableCell ,_efgc VectorDrawable ,_ffac bool )*TableCell {_cedga :=*_gdeg ;_cedga ._cbbgc =_efgc ;
if _ffac {_cedga ._deba ++;};return &_cedga ;};_gdbbc :=func (_ebdfa int ,_daafa VectorDrawable ){var _bbefd float64 =-1;if _daafa ==nil {if _gcab :=_edfad [_ebdfa -_dggeg ];_gcab > _gebc .Height {_daafa =_ddfff ._eafe [_ebdfa ]._cbbgc ;_ddfff ._eafe [_ebdfa ]._cbbgc =nil ;
_edfad [_ebdfa -_dggeg ]=0;_bbefd =_gcab ;};};_cbccf :=_ecgaa (_ddfff ._eafe [_ebdfa ],_daafa ,true );_acgfb =append (_acgfb ,_cbccf );if _bbefd < 0{_bbefd =_cbccf .height (_gebc .Width );};if _bbefd > _bage {_bage =_bbefd ;};};for _daeac :=_dggeg ;_daeac < len (_ddfff ._eafe );
_daeac ++{_abddb :=_ddfff ._eafe [_daeac ];if _bcdfd ._deba !=_abddb ._deba {_ccfg =_daeac ;break ;};_gebc .Width =_abddb .width (_ddfff ._aabdd ,_fafcgf );_afdfc :=_abddb .height (_gebc .Width );var _ddedg VectorDrawable ;switch _eedc :=_abddb ._cbbgc .(type ){case *StyledParagraph :if _afdfc > _gebc .Height {_cbff :=_gebc ;
_cbff .Height =_bd .Floor (_gebc .Height -_eedc ._cgfa .Top -_eedc ._cgfa .Bottom -0.5*_eedc .getTextHeight ());_dbgeg ,_dddgd ,_gcbgg :=_eedc .split (_cbff );if _gcbgg !=nil {return false ,_gcbgg ;};if _dbgeg !=nil &&_dddgd !=nil {_eedc =_dbgeg ;_abddb =_ecgaa (_abddb ,_dbgeg ,false );
_ddfff ._eafe [_daeac ]=_abddb ;_ddedg =_dddgd ;_edbg =true ;};_afdfc =_abddb .height (_gebc .Width );};case *Division :if _afdfc > _gebc .Height {_efgg :=_gebc ;_efgg .Height =_bd .Floor (_gebc .Height -_eedc ._egba .Top -_eedc ._egba .Bottom );_agag ,_bccbb :=_eedc .split (_efgg );
if _agag !=nil &&_bccbb !=nil {_eedc =_agag ;_abddb =_ecgaa (_abddb ,_agag ,false );_ddfff ._eafe [_daeac ]=_abddb ;_ddedg =_bccbb ;_edbg =true ;if _agag ._accgd !=nil {_agag ._accgd .BorderRadiusBottomLeft =0;_agag ._accgd .BorderRadiusBottomRight =0;
};if _bccbb ._accgd !=nil {_bccbb ._accgd .BorderRadiusTopLeft =0;_bccbb ._accgd .BorderRadiusTopRight =0;};_afdfc =_abddb .height (_gebc .Width );};};case *List :if _afdfc > _gebc .Height {_gagc :=_gebc ;_gagc .Height =_bd .Floor (_gebc .Height -_eedc ._eaag .Vertical ());
_bgde ,_ecaa :=_eedc .split (_gagc );if _bgde !=nil {_eedc =_bgde ;_abddb =_ecgaa (_abddb ,_bgde ,false );_ddfff ._eafe [_daeac ]=_abddb ;};if _ecaa !=nil {_ddedg =_ecaa ;_edbg =true ;};_afdfc =_abddb .height (_gebc .Width );};};_edfad =append (_edfad ,_afdfc );
if _edbg {if _acgfb ==nil {_acgfb =make ([]*TableCell ,0,len (_ddfff ._aabdd ));for _acecc :=_dggeg ;_acecc < _daeac ;_acecc ++{_gdbbc (_acecc ,nil );};};_gdbbc (_daeac ,_ddedg );};};var _fgcg float64 ;for _ ,_bgdd :=range _edfad {if _bgdd > _fgcg {_fgcg =_bgdd ;
};};if _edbg &&_fgcg < _gebc .Height {if _ccfg < 0{_ccfg =len (_ddfff ._eafe );};_afgf :=_ddfff ._eafe [_ccfg -1]._deba +_ddfff ._eafe [_ccfg -1]._acag -1;for _eebca :=_ccfg ;_eebca < len (_ddfff ._eafe );_eebca ++{_ddfff ._eafe [_eebca ]._deba ++;};_ddfff ._eafe =append (_ddfff ._eafe [:_ccfg ],append (_acgfb ,_ddfff ._eafe [_ccfg :]...)...);
_ddfff ._abfdc =append (_ddfff ._abfdc [:_afgf ],append ([]float64 {_bage },_ddfff ._abfdc [_afgf :]...)...);_ddfff ._abfdc [_bcdfd ._deba +_bcdfd ._acag -2]=_fgcg ;};return _edbg ,nil ;};

// Cols returns the total number of columns the table has.
func (_faaf *Table )Cols ()int {return _faaf ._ccdbbe };

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default, it occupies the available width in the drawing context.
type Paragraph struct{_dddfg string ;_gfac *_bdd .PdfFont ;_ccdc float64 ;_gfaa float64 ;_eabe Color ;_dgcd TextAlignment ;_ceaa bool ;_bbag float64 ;_gfgde int ;_egeaa bool ;_gfaae float64 ;_defec Margins ;_abcfeg Positioning ;_edac float64 ;_gadge float64 ;
_dbag ,_ccag float64 ;_fcffe []string ;_defae *int64 ;_cdedda string ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_dbec *Invoice )SetAddressHeadingStyle (style TextStyle ){_dbec ._afde =style };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bbedd *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _edae float64 ;var _eagcb []*StyledParagraph ;for _ ,_fgbgg :=range _bbedd ._agcde {_bddb :=_accf (_bbedd ._eacd );_bddb .SetEnableWrap (false );_bddb .SetTextAlignment (TextAlignmentRight );
_bddb .Append (_fgbgg ._baee .Text ).Style =_fgbgg ._baee .Style ;_ccbdg :=_bddb .getTextWidth ()/1000.0/ctx .Width ;if _edae < _ccbdg {_edae =_ccbdg ;};_eagcb =append (_eagcb ,_bddb );};_bbfcg :=_fbcee (2);_bbfcg .SetColumnWidths (_edae ,1-_edae );_bbfcg .SetMargins (_bbedd ._eaag .Left +_bbedd ._ccgdf ,_bbedd ._eaag .Right ,_bbedd ._eaag .Top ,_bbedd ._eaag .Bottom );
_bbfcg .EnableRowWrap (true );for _bbde ,_ddaeg :=range _bbedd ._agcde {_bebadc :=_bbfcg .NewCell ();_bebadc .SetIndent (0);_bebadc .SetContent (_eagcb [_bbde ]);_bebadc =_bbfcg .NewCell ();_bebadc .SetIndent (0);_bebadc .SetContent (_ddaeg ._ffda );};
return _bbfcg .GeneratePageBlocks (ctx );};func (_be *Block )drawToPage (_ebb *_bdd .PdfPage )error {_gbdg :=&_ee .ContentStreamOperations {};if _ebb .Resources ==nil {_ebb .Resources =_bdd .NewPdfPageResources ();};_cag :=_bcb (_gbdg ,_ebb .Resources ,_be ._ae ,_be ._fb );
if _cag !=nil {return _cag ;};if _cag =_cfb (_be ._fb ,_ebb .Resources );_cag !=nil {return _cag ;};if _cag =_ebb .AppendContentBytes (_gbdg .Bytes (),true );_cag !=nil {return _cag ;};for _ ,_cae :=range _be ._ceg {_ebb .AddAnnotation (_cae );};return nil ;
};func (_cdea *templateProcessor )parseLine (_eccgg *templateNode )(interface{},error ){_ddeda :=_cdea .creator .NewLine (0,0,0,0);for _ ,_gbabb :=range _eccgg ._edag .Attr {_cbddg :=_gbabb .Value ;switch _fecdg :=_gbabb .Name .Local ;_fecdg {case "\u0078\u0031":_ddeda ._bcff =_cdea .parseFloatAttr (_fecdg ,_cbddg );
case "\u0079\u0031":_ddeda ._cagcf =_cdea .parseFloatAttr (_fecdg ,_cbddg );case "\u0078\u0032":_ddeda ._cbdf =_cdea .parseFloatAttr (_fecdg ,_cbddg );case "\u0079\u0032":_ddeda ._begf =_cdea .parseFloatAttr (_fecdg ,_cbddg );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_ddeda .SetLineWidth (_cdea .parseFloatAttr (_fecdg ,_cbddg ));
case "\u0063\u006f\u006co\u0072":_ddeda .SetColor (_cdea .parseColorAttr (_fecdg ,_cbddg ));case "\u0073\u0074\u0079l\u0065":_ddeda .SetStyle (_cdea .parseLineStyleAttr (_fecdg ,_cbddg ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_ddeda .SetDashPattern (_cdea .parseInt64Array (_fecdg ,_cbddg ),_ddeda ._ggcc );
case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_ddeda .SetDashPattern (_ddeda ._dacf ,_cdea .parseInt64Attr (_fecdg ,_cbddg ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_ddeda .SetOpacity (_cdea .parseFloatAttr (_fecdg ,_cbddg ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_ddeda .SetPositioning (_cdea .parsePositioningAttr (_fecdg ,_cbddg ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_ddeda .SetFitMode (_cdea .parseFitModeAttr (_fecdg ,_cbddg ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_fceece :=_cdea .parseMarginAttr (_fecdg ,_cbddg );
_ddeda .SetMargins (_fceece .Left ,_fceece .Right ,_fceece .Top ,_fceece .Bottom );default:_cdea .nodeLogDebug (_eccgg ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_fecdg );
};};return _ddeda ,nil ;};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_fcce *List )Add (item VectorDrawable )(*TextChunk ,error ){_ggeeb :=&listItem {_ffda :item ,_baee :_fcce ._fdbb };switch _ccbdb :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _ccbdb ._fgea {_ccbdb ._ccgdf =15;};case *Division :case *Image :case *Table :default:return nil ,_ac .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_fcce ._agcde =append (_fcce ._agcde ,_ggeeb );return &_ggeeb ._baee ,nil ;};

// SetStyleBottom sets border style for bottom side.
func (_fggb *border )SetStyleBottom (style CellBorderStyle ){_fggb ._fcc =style };

// SetBorderColor sets border color of the rectangle.
func (_ggaa *Rectangle )SetBorderColor (col Color ){_ggaa ._egbf =col };

// SetIndent sets the cell's left indent.
func (_dffb *TableCell )SetIndent (indent float64 ){_dffb ._gdfaa =indent };

// Width returns Image's document width.
func (_eede *Image )Width ()float64 {return _eede ._fgbd };

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// Margins returns the margins of the component.
func (_aefc *Division )Margins ()(_cdgg ,_cded ,_eedd ,_cgff float64 ){return _aefc ._egba .Left ,_aefc ._egba .Right ,_aefc ._egba .Top ,_aefc ._egba .Bottom ;};

// Width returns the width of the specified text chunk.
func (_adgec *TextChunk )Width ()float64 {var (_bffgb float64 ;_bddcb =_adgec .Style ;);for _ ,_gaeg :=range _adgec .Text {_adbcd ,_dbdga :=_bddcb .Font .GetRuneMetrics (_gaeg );if !_dbdga {_da .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_gaeg ,_gaeg ,_bddcb .Font .BaseFont (),_bddcb .Font .Subtype ());
_da .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_bddcb .Font );_da .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_bddcb .Font .Encoder ());};_faedd :=_bddcb .FontSize *_adbcd .Wx ;_gegca :=_faedd ;if _gaeg !=' '{_gegca =_faedd +_bddcb .CharSpacing *1000.0;
};_bffgb +=_gegca ;};return _bffgb /1000.0;};func _decge (_dacd string )(*GraphicSVG ,error ){_bccfd ,_gcdg :=_fc .ParseFromFile (_dacd );if _gcdg !=nil {return nil ,_gcdg ;};return _deg (_bccfd );};

// SetAngle sets the rotation angle of the text.
func (_dcfed *StyledParagraph )SetAngle (angle float64 ){_dcfed ._eefg =angle };func _cfcg (_egde *templateProcessor ,_fdbgg *templateNode )(interface{},error ){return _egde .parseChapter (_fdbgg );};func (_gegae *templateProcessor )parseList (_gcac *templateNode )(interface{},error ){_cccfbfg :=_gegae .creator .NewList ();
for _ ,_ccadd :=range _gcac ._edag .Attr {_addgg :=_ccadd .Value ;switch _dfed :=_ccadd .Name .Local ;_dfed {case "\u0069\u006e\u0064\u0065\u006e\u0074":_cccfbfg .SetIndent (_gegae .parseFloatAttr (_dfed ,_addgg ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ddegd :=_gegae .parseMarginAttr (_dfed ,_addgg );
_cccfbfg .SetMargins (_ddegd .Left ,_ddegd .Right ,_ddegd .Top ,_ddegd .Bottom );default:_gegae .nodeLogDebug (_gcac ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dfed );
};};return _cccfbfg ,nil ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_dcbeg *TOC )SetLineStyle (style TextStyle ){_dcbeg .SetLineNumberStyle (style );_dcbeg .SetLineTitleStyle (style );_dcbeg .SetLineSeparatorStyle (style );_dcbeg .SetLinePageStyle (style );};func _fcgdf (_afdca *Block ,_cdgd _bdd .PdfColor ,_gcgf Color ,_gbbef func ()Rectangle )error {switch _bggafc :=_cdgd .(type ){case *_bdd .PdfColorPatternType2 :_fbgdg ,_gbdec :=_gcgf .(*LinearShading );
if !_gbdec {return _a .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_acbdc :=_gbbef ();_fbgdg .SetBoundingBox (_acbdc ._cbcfa ,_acbdc ._ffdf ,_acbdc ._efdd ,_acbdc ._bbae );
_daaeg ,_ebag :=_fbgdg .AddPatternResource (_afdca );if _ebag !=nil {return _a .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_ebag );
};_bggafc .PatternName =_daaeg ;case *_bdd .PdfColorPatternType3 :_dbcef ,_eggf :=_gcgf .(*RadialShading );if !_eggf {return _a .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_cggg :=_gbbef ();_dbcef .SetBoundingBox (_cggg ._cbcfa ,_cggg ._ffdf ,_cggg ._efdd ,_cggg ._bbae );_ebeee ,_fbeed :=_dbcef .AddPatternResource (_afdca );if _fbeed !=nil {return _a .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_fbeed );
};_bggafc .PatternName =_ebeee ;};return nil ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_fgdc *Creator )CreateTableOfContents (genTOCFunc func (_dffc *TOC )error ){_fgdc ._gde =genTOCFunc ;};

// Positioning returns the type of positioning the ellipse is set to use.
func (_edgcf *Ellipse )Positioning ()Positioning {return _edgcf ._fgac };

// SetAngle sets the rotation angle in degrees.
func (_edc *Block )SetAngle (angleDeg float64 ){_edc ._daa =angleDeg };

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_adebd []*TextChunk ;_bgge TextStyle ;_egeg TextStyle ;_egbdb TextAlignment ;_abed TextVerticalAlignment ;_adbbc float64 ;_bcdbe bool ;_fcdc float64 ;_cbbg bool ;_acffb bool ;_cdag TextOverflow ;_eefg float64 ;_cgfa Margins ;
_geae Positioning ;_ccbea float64 ;_cdgdb float64 ;_gbddde float64 ;_beaeg float64 ;_acebb [][]*TextChunk ;_dbab func (_eaad *StyledParagraph ,_bbfe DrawContext );_fdeb *int64 ;_cede string ;};

// SetBackgroundColor sets the cell's background color.
func (_aedgf *TableCell )SetBackgroundColor (col Color ){_aedgf ._ccab =col };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_bafdf *Image )ConvertToBinary ()error {return _bafdf ._cebb .ConvertToBinary ()};

// SetSideBorderColor sets the cell's side border color.
func (_eefd *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_eefd ._bcga =col ;_eefd ._gccfc =col ;_eefd ._dbbbd =col ;_eefd ._fedcf =col ;case CellBorderSideTop :_eefd ._bcga =col ;case CellBorderSideBottom :_eefd ._gccfc =col ;
case CellBorderSideLeft :_eefd ._dbbbd =col ;case CellBorderSideRight :_eefd ._fedcf =col ;};};func (_ffae *Division )ctxHeight (_gfde float64 )float64 {_gfde -=_ffae ._egba .Left +_ffae ._egba .Right +_ffae ._gcfg .Left +_ffae ._gcfg .Right ;var _bggc float64 ;
for _ ,_bedg :=range _ffae ._gbfd {_bggc +=_gcdc (_bedg ,_gfde );};return _bggc ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_edaef *_ebc .PolyBezierCurve ;_efef float64 ;_bgdga float64 ;_fabcgb Color ;_adfag *int64 ;};

// SetBorderRadius sets the radius of the rectangle corners.
func (_fbcce *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_fbcce ._dbdd =topLeft ;_fbcce ._ebfg =topRight ;_fbcce ._bbcg =bottomLeft ;_fbcce ._defaa =bottomRight ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_eagc *Creator )EnableFontSubsetting (font *_bdd .PdfFont ){_eagc ._ffa =append (_eagc ._ffa ,font )};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_bbga *Paragraph )SetTextAlignment (align TextAlignment ){_bbga ._dgcd =align };func _cafd ()*FilledCurve {_cgcg :=FilledCurve {};_cgcg ._bgecc =[]_ebc .CubicBezierCurve {};return &_cgcg ;};func _ggfb (_cecbg *Creator ,_aeefc string ,_gdgaf []byte ,_gfebc *TemplateOptions ,_bgfgg componentRenderer )*templateProcessor {if _gfebc ==nil {_gfebc =&TemplateOptions {};
};_gfebc .init ();if _bgfgg ==nil {_bgfgg =_cecbg ;};return &templateProcessor {creator :_cecbg ,_bead :_gdgaf ,_cggc :_gfebc ,_efede :_bgfgg ,_abfe :_aeefc };};

// FillColor returns the fill color of the ellipse.
func (_dcfa *Ellipse )FillColor ()Color {return _dcfa ._dagdd };func _aabe (_dbbcd map[string ]interface{},_gaaf ...interface{})(map[string ]interface{},error ){_cgace :=len (_gaaf );if _cgace %2!=0{return nil ,_bdg .ErrRangeError ;};for _dbfd :=0;_dbfd < _cgace ;
_dbfd +=2{_cfdagd ,_eaab :=_gaaf [_dbfd ].(string );if !_eaab {return nil ,_bdg .ErrTypeError ;};_dbbcd [_cfdagd ]=_gaaf [_dbfd +1];};return _dbbcd ,nil ;};func (_accg *Creator )getActivePage ()*_bdd .PdfPage {if _accg ._agbc ==nil {if len (_accg ._bcdf )==0{return nil ;
};return _accg ._bcdf [len (_accg ._bcdf )-1];};return _accg ._agbc ;};func (_eeac *Division )split (_bcea DrawContext )(_ddaa ,_gddc *Division ){var (_fdbca float64 ;_abdg ,_dbff []VectorDrawable ;);_gagd :=_bcea .Width -_eeac ._egba .Left -_eeac ._egba .Right -_eeac ._gcfg .Left -_eeac ._gcfg .Right ;
for _fcbe ,_bgdb :=range _eeac ._gbfd {_fdbca +=_gcdc (_bgdb ,_gagd );if _fdbca < _bcea .Height {_abdg =append (_abdg ,_bgdb );}else {_dbff =_eeac ._gbfd [_fcbe :];break ;};};if len (_abdg )> 0{_ddaa =_dccb ();*_ddaa =*_eeac ;_ddaa ._gbfd =_abdg ;if _eeac ._accgd !=nil {_ddaa ._accgd =&Background {};
*_ddaa ._accgd =*_eeac ._accgd ;};};if len (_dbff )> 0{_gddc =_dccb ();*_gddc =*_eeac ;_gddc ._gbfd =_dbff ;if _eeac ._accgd !=nil {_gddc ._accgd =&Background {};*_gddc ._accgd =*_eeac ._accgd ;};};return _ddaa ,_gddc ;};func _bgeca (_agca *_bdd .PdfAnnotation )*_bdd .PdfAnnotation {if _agca ==nil {return nil ;
};var _cgbfd *_bdd .PdfAnnotation ;switch _adbdb :=_agca .GetContext ().(type ){case *_bdd .PdfAnnotationLink :if _ddcd :=_gfga (_adbdb );_ddcd !=nil {_cgbfd =_ddcd .PdfAnnotation ;};case *_bdd .PdfAnnotationHighlight :if _afbdb :=_caga (_adbdb );_afbdb !=nil {_cgbfd =_afbdb .PdfAnnotation ;
};};return _cgbfd ;};

// EnableWordWrap sets the paragraph word wrap flag.
func (_adff *StyledParagraph )EnableWordWrap (val bool ){_adff ._cbbg =val };

// ColorGrayFromHex converts color hex code to gray color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ff -> white.
func ColorGrayFromHex (hexStr string )Color {_dgce :=grayColor {};if (len (hexStr )!=2&&len (hexStr )!=3)||hexStr [0]!='#'{_da .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dgce ;
};var _gdde int ;if len (hexStr )==2{var _fcd int ;_ebed ,_gbcg :=_a .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078",&_fcd );if _gbcg !=nil {_da .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_gbcg );
return _dgce ;};if _ebed !=1{_da .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dgce ;};_gdde =_fcd *16+_fcd ;}else {_bef ,_dcfg :=_a .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078",&_gdde );
if _dcfg !=nil {_da .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dgce ;};if _bef !=1{_da .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_bef );
return _dgce ;};};_dgce ._ebfd =float64 (_gdde )/255.0;return _dgce ;};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_bcbf *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _geda (x1 ,y1 ,x2 ,y2 )};

// ColorGrayFromArithmetic creates a Color from a grayscale value (0-1).
// Example:
//
//	gray := ColorGrayFromArithmetic(0.7)
func ColorGrayFromArithmetic (g float64 )Color {return grayColor {g }};func (_bdgc *Block )addContentsByString (_bgg string )error {_bgd :=_ee .NewContentStreamParser (_bgg );_eec ,_deb :=_bgd .Parse ();if _deb !=nil {return _deb ;};_bdgc ._ae .WrapIfNeeded ();
_eec .WrapIfNeeded ();*_bdgc ._ae =append (*_bdgc ._ae ,*_eec ...);return nil ;};func (_bcde *FilledCurve )draw (_ccef *Block ,_cdedd string )([]byte ,*_bdd .PdfRectangle ,error ){_ffed :=_ebc .NewCubicBezierPath ();for _ ,_caef :=range _bcde ._bgecc {_ffed =_ffed .AppendCurve (_caef );
};creator :=_ee .NewContentCreator ();if _bcde ._agcd !=nil {creator .Add_BDC (*_bdg .MakeName (_bdd .StructureTypeFigure ),map[string ]_bdg .PdfObject {"\u004d\u0043\u0049\u0044":_bdg .MakeInteger (*_bcde ._agcd )});};creator .Add_q ();if _bcde .FillEnabled &&_bcde ._gbdc !=nil {_ffeg :=_ddfd (_bcde ._gbdc );
_abfa :=_fcgdf (_ccef ,_ffeg ,_bcde ._gbdc ,func ()Rectangle {_caac :=_ebc .NewCubicBezierPath ();for _ ,_gdadf :=range _bcde ._bgecc {_caac =_caac .AppendCurve (_gdadf );};_efbe :=_caac .GetBoundingBox ();if _bcde .BorderEnabled {_efbe .Height +=_bcde .BorderWidth ;
_efbe .Width +=_bcde .BorderWidth ;_efbe .X -=_bcde .BorderWidth /2;_efbe .Y -=_bcde .BorderWidth /2;};return Rectangle {_cbcfa :_efbe .X ,_ffdf :_efbe .Y ,_efdd :_efbe .Width ,_bbae :_efbe .Height };});if _abfa !=nil {return nil ,nil ,_abfa ;};creator .SetNonStrokingColor (_ffeg );
};if _bcde .BorderEnabled {if _bcde ._fdafg !=nil {creator .SetStrokingColor (_ddfd (_bcde ._fdafg ));};creator .Add_w (_bcde .BorderWidth );};if len (_cdedd )> 1{creator .Add_gs (_bdg .PdfObjectName (_cdedd ));};_ebc .DrawBezierPathWithCreator (_ffed ,creator );
creator .Add_h ();if _bcde .FillEnabled &&_bcde .BorderEnabled {creator .Add_B ();}else if _bcde .FillEnabled {creator .Add_f ();}else if _bcde .BorderEnabled {creator .Add_S ();};creator .Add_Q ();if _bcde ._agcd !=nil {creator .Add_EMC ();};_dcdf :=_ffed .GetBoundingBox ();
if _bcde .BorderEnabled {_dcdf .Height +=_bcde .BorderWidth ;_dcdf .Width +=_bcde .BorderWidth ;_dcdf .X -=_bcde .BorderWidth /2;_dcdf .Y -=_bcde .BorderWidth /2;};_dcba :=&_bdd .PdfRectangle {};_dcba .Llx =_dcdf .X ;_dcba .Lly =_dcdf .Y ;_dcba .Urx =_dcdf .X +_dcdf .Width ;
_dcba .Ury =_dcdf .Y +_dcdf .Height ;return creator .Bytes (),_dcba ,nil ;};

// SetFontSize sets the font size in document units (points).
func (_bggbd *Paragraph )SetFontSize (fontSize float64 ){_bggbd ._ccdc =fontSize };func (_aaff *templateProcessor )parseBorderRadiusAttr (_efba ,_gbcbb string )(_eeea ,_gadf ,_dbeg ,_eeebd float64 ){_da .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_efba ,_gbcbb );
switch _abbd :=_fa .Fields (_gbcbb );len (_abbd ){case 1:_eeea ,_ =_eb .ParseFloat (_abbd [0],64);_gadf =_eeea ;_dbeg =_eeea ;_eeebd =_eeea ;case 2:_eeea ,_ =_eb .ParseFloat (_abbd [0],64);_dbeg =_eeea ;_gadf ,_ =_eb .ParseFloat (_abbd [1],64);_eeebd =_gadf ;
case 3:_eeea ,_ =_eb .ParseFloat (_abbd [0],64);_gadf ,_ =_eb .ParseFloat (_abbd [1],64);_eeebd =_gadf ;_dbeg ,_ =_eb .ParseFloat (_abbd [2],64);case 4:_eeea ,_ =_eb .ParseFloat (_abbd [0],64);_gadf ,_ =_eb .ParseFloat (_abbd [1],64);_dbeg ,_ =_eb .ParseFloat (_abbd [2],64);
_eeebd ,_ =_eb .ParseFloat (_abbd [3],64);};return _eeea ,_gadf ,_dbeg ,_eeebd ;};func _fegcc (_edfgd int64 ,_gcacc ,_ceddf ,_eebg float64 )*_bdd .PdfAnnotation {_edcac :=_bdd .NewPdfAnnotationLink ();_cacda :=_bdd .NewBorderStyle ();_cacda .SetBorderWidth (0);
_edcac .BS =_cacda .ToPdfObject ();if _edfgd < 0{_edfgd =0;};_edcac .Dest =_bdg .MakeArray (_bdg .MakeInteger (_edfgd ),_bdg .MakeName ("\u0058\u0059\u005a"),_bdg .MakeFloat (_gcacc ),_bdg .MakeFloat (_ceddf ),_bdg .MakeFloat (_eebg ));return _edcac .PdfAnnotation ;
};

// SetWidth sets line width.
func (_eagf *Curve )SetWidth (width float64 ){_eagf ._cdf =width };

// SetMargins sets the margins of the chart component.
func (_baae *Chart )SetMargins (left ,right ,top ,bottom float64 ){_baae ._ccae .Left =left ;_baae ._ccae .Right =right ;_baae ._ccae .Top =top ;_baae ._ccae .Bottom =bottom ;};

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_dddg *Image )SetFitMode (fitMode FitMode ){_dddg ._bbbde =fitMode };

// SetFillColor sets the fill color for the path.
func (_dgfe *FilledCurve )SetFillColor (color Color ){_dgfe ._gbdc =color };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_cdccc *StyledParagraph )Height ()float64 {_cdccc .wrapText ();var _gggcg float64 ;for _ ,_efdgd :=range _cdccc ._acebb {var _abbcc float64 ;for _ ,_bface :=range _efdgd {_gbda :=_cdccc ._adbbc *_bface .Style .FontSize ;if _gbda > _abbcc {_abbcc =_gbda ;
};};_gggcg +=_abbcc ;};return _gggcg ;};func _eddba (_ecbfb *templateProcessor ,_egdag *templateNode )(interface{},error ){return _ecbfb .parseDivision (_egdag );};func (_bgbb *TemplateOptions )init (){if _bgbb .SubtemplateMap ==nil {_bgbb .SubtemplateMap =map[string ]_ebf .Reader {};
};if _bgbb .FontMap ==nil {_bgbb .FontMap =map[string ]*_bdd .PdfFont {};};if _bgbb .ImageMap ==nil {_bgbb .ImageMap =map[string ]*_bdd .Image {};};if _bgbb .ColorMap ==nil {_bgbb .ColorMap =map[string ]Color {};};if _bgbb .ChartMap ==nil {_bgbb .ChartMap =map[string ]_ef .ChartRenderable {};
};};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_gbfd []VectorDrawable ;_gag Positioning ;_egba Margins ;_gcfg Margins ;_gcag bool ;_gadg bool ;_accgd *Background ;};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_bdfa *Creator )SetOutlineTree (outlineTree *_bdd .PdfOutlineTreeNode ){_bdfa ._fdbf =outlineTree };

// Width returns the Block's width.
func (_egf *Block )Width ()float64 {return _egf ._ccb };func _geda (_cbgaf ,_ffcd ,_bbdcd ,_eebc float64 )*Line {return &Line {_bcff :_cbgaf ,_cagcf :_ffcd ,_cbdf :_bbdcd ,_begf :_eebc ,_ceecf :ColorBlack ,_ecga :1.0,_dedd :1.0,_dacf :[]int64 {1,1},_bgad :PositionAbsolute };
};

// NewChapter creates a new chapter with the specified title as the heading.
func (_fcca *Creator )NewChapter (title string )*Chapter {_fcca ._fcgd ++;_fabc :=_fcca .NewTextStyle ();_fabc .FontSize =16;return _edbb (nil ,_fcca ._fgde ,_fcca ._bgce ,title ,_fcca ._fcgd ,_fabc );};func (_cggb *StyledParagraph )getTextHeight ()float64 {var _bgbe float64 ;
for _ ,_cebba :=range _cggb ._adebd {_acab :=_cebba .Style .FontSize *_cggb ._adbbc ;if _acab > _bgbe {_bgbe =_acab ;};};return _bgbe ;};func (_dgcg *Invoice )generateInformationBlocks (_cfc DrawContext )([]*Block ,DrawContext ,error ){_dccf :=_accf (_dgcg ._fcaa );
_dccf .SetMargins (0,0,0,20);_ecca :=_dgcg .drawAddress (_dgcg ._bccg );_ecca =append (_ecca ,_dccf );_ecca =append (_ecca ,_dgcg .drawAddress (_dgcg ._cceff )...);_bcfdf :=_dccb ();for _ ,_gggg :=range _ecca {_bcfdf .Add (_gggg );};_ddcff :=_dgcg .drawInformation ();
_ffged :=_fbcee (2);_ffged .SetMargins (0,0,25,0);_ebgcd :=_ffged .NewCell ();_ebgcd .SetIndent (0);_ebgcd .SetContent (_bcfdf );_ebgcd =_ffged .NewCell ();_ebgcd .SetContent (_ddcff );return _ffged .GeneratePageBlocks (_cfc );};func _cecca (_gdcgf *_bdd .PdfRectangle ,_gfbb _gc .Matrix )*_bdd .PdfRectangle {var _acbac _bdd .PdfRectangle ;
_acbac .Llx ,_acbac .Lly =_gfbb .Transform (_gdcgf .Llx ,_gdcgf .Lly );_acbac .Urx ,_acbac .Ury =_gfbb .Transform (_gdcgf .Urx ,_gdcgf .Ury );_acbac .Normalize ();return &_acbac ;};

// FitMode returns the fit mode of the image.
func (_cadg *Image )FitMode ()FitMode {return _cadg ._bbbde };

// IsRelative checks if the positioning is relative.
func (_ced Positioning )IsRelative ()bool {return _ced ==PositionRelative };

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_daeg *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _daeg ._ecbb [0],_daeg ._ecbb [1]};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _d .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_ebf .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_bdd .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_bdd .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_ef .ChartRenderable ;};

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_efcdd *Rectangle )SetFitMode (fitMode FitMode ){_efcdd ._efbdd =fitMode };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cgeee *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gecfg :=ctx ;_fddba ,ctx ,_dffd :=_cgeee ._aafbcf .GeneratePageBlocks (ctx );if _dffd !=nil {return _fddba ,ctx ,_dffd ;};for _ ,_dacab :=range _cgeee ._cfecf {_abfc :=_dacab ._ddbe ;
if !_cgeee ._egbac {_dacab ._ddbe =0;};_bgegg ,_feaf ,_eabeb :=_dacab .GeneratePageBlocks (ctx );_dacab ._ddbe =_abfc ;if _eabeb !=nil {return _fddba ,ctx ,_eabeb ;};if len (_bgegg )< 1{continue ;};_fddba [len (_fddba )-1].mergeBlocks (_bgegg [0]);_fddba =append (_fddba ,_bgegg [1:]...);
ctx =_feaf ;};if _cgeee ._fbcdfa .IsRelative (){ctx .X =_gecfg .X ;};if _cgeee ._fbcdfa .IsAbsolute (){return _fddba ,_gecfg ,nil ;};return _fddba ,ctx ,nil ;};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_cacf *Division )Width ()float64 {return 0};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_dcd *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dcd ._gff .Left ,_dcd ._gff .Right ,_dcd ._gff .Top ,_dcd ._gff .Bottom ;};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_eedgc *Invoice )SetNoteStyle (style TextStyle ){_eedgc ._addg =style };func (_ebda *templateProcessor )parseLineStyleAttr (_cdef ,_dffba string )_ebc .LineStyle {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_cdef ,_dffba );
_aecg :=map[string ]_ebc .LineStyle {"\u0073\u006f\u006ci\u0064":_ebc .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_ebc .LineStyleDashed }[_dffba ];return _aecg ;};

// NewFilledCurve returns a instance of filled curve.
func (_eecd *Creator )NewFilledCurve ()*FilledCurve {return _cafd ()};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_gagb *Line )SetColor (color Color ){_gagb ._ceecf =color };

// NewCellProps returns the default properties of an invoice cell.
func (_fdac *Invoice )NewCellProps ()InvoiceCellProps {_ffdb :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_fdac ._fcaa ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_ffdb ,BorderColor :_ffdb ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};func (_acbdb *shading )generatePdfFunctions ()[]_bdd .PdfFunction {if len (_acbdb ._decd )==0{return nil ;}else if len (_acbdb ._decd )<=2{_cfaa ,_ebgcdd ,_ecfdf :=_acbdb ._decd [0]._bdba .ToRGB ();_babb ,_eabg ,_fbfc :=_acbdb ._decd [len (_acbdb ._decd )-1]._bdba .ToRGB ();
return []_bdd .PdfFunction {&_bdd .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_cfaa ,_ebgcdd ,_ecfdf },C1 :[]float64 {_babb ,_eabg ,_fbfc }}};}else {_ecda :=[]_bdd .PdfFunction {};_deff :=[]float64 {};
for _cgcge :=0;_cgcge < len (_acbdb ._decd )-1;_cgcge ++{_dgfec ,_fgdae ,_aaec :=_acbdb ._decd [_cgcge ]._bdba .ToRGB ();_bfcgc ,_dcag ,_dgbab :=_acbdb ._decd [_cgcge +1]._bdba .ToRGB ();_gaa :=&_bdd .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_dgfec ,_fgdae ,_aaec },C1 :[]float64 {_bfcgc ,_dcag ,_dgbab }};
_ecda =append (_ecda ,_gaa );if _cgcge > 0{_deff =append (_deff ,_acbdb ._decd [_cgcge ]._fbgg );};};_cabae :=[]float64 {};for range _ecda {_cabae =append (_cabae ,[]float64 {0.0,1.0}...);};return []_bdd .PdfFunction {&_bdd .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_ecda ,Bounds :_deff ,Encode :_cabae }};
};};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_cedgc *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_egda *_bdd .PdfWriter )error ){_cedgc ._daad =pdfWriterAccessFunc ;};func (_aeefe *Paragraph )getTextWidth ()float64 {_fdfac :=0.0;for _ ,_dcgdb :=range _aeefe ._dddfg {if _dcgdb =='\u000A'{continue ;
};_fceec ,_ggdac :=_aeefe ._gfac .GetRuneMetrics (_dcgdb );if !_ggdac {_da .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_dcgdb ,_dcgdb );
return -1;};_fdfac +=_aeefe ._ccdc *_fceec .Wx ;};return _fdfac ;};

// SetMarkedContentID sets the marked content id for the line.
func (_ceda *Line )SetMarkedContentID (mcid int64 )*_bdd .KDict {_ceda ._acfe =&mcid ;_fdcd :=_bdd .NewKDictionary ();_fdcd .S =_bdg .MakeName (_bdd .StructureTypeFigure );_fdcd .K =_bdg .MakeInteger (mcid );return _fdcd ;};

// SetFillColor sets the fill color.
func (_edgcc *Polygon )SetFillColor (color Color ){_edgcc ._daaad =color ;_edgcc ._bcgb .FillColor =_ddfd (color );};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_fbcf DrawContext )([]*Block ,DrawContext ,error );

// SetMarkedContentID sets the marked content id for the drawable.
SetMarkedContentID (_bbed int64 )*_bdd .KDict ;};

// MoveY moves the drawing context to absolute position y.
func (_fdce *Creator )MoveY (y float64 ){_fdce ._ebce .Y =y };

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_bgecc []_ebc .CubicBezierCurve ;FillEnabled bool ;_gbdc Color ;BorderEnabled bool ;BorderWidth float64 ;_fdafg Color ;_agcd *int64 ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_gca *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_gca ._fgde =toc ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_dce *Block )SetMargins (left ,right ,top ,bottom float64 ){_dce ._edg .Left =left ;_dce ._edg .Right =right ;_dce ._edg .Top =top ;_dce ._edg .Bottom =bottom ;};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _ef .ChartRenderable )*Chart {return _dfgg (chart )};

// SetViewerPreferences sets the viewer preferences for the PDF document.
func (_cgdg *Creator )SetViewerPreferences (viewerPreferences *_bdd .ViewerPreferences ){_cgdg ._afbe =viewerPreferences ;};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_adf :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_da .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _adf ;
};var _fca ,_bffe ,_dfggb int ;if len (hexStr )==4{var _age ,_fade ,_daea int ;_bdb ,_dcbg :=_a .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_age ,&_fade ,&_daea );if _dcbg !=nil {_da .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_dcbg );
return _adf ;};if _bdb !=3{_da .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _adf ;};_fca =_age *16+_age ;_bffe =_fade *16+_fade ;_dfggb =_daea *16+_daea ;}else {_deea ,_caea :=_a .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_fca ,&_bffe ,&_dfggb );
if _caea !=nil {_da .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _adf ;};if _deea !=3{_da .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_deea );
return _adf ;};};_agdb :=float64 (_fca )/255.0;_gcec :=float64 (_bffe )/255.0;_bccb :=float64 (_dfggb )/255.0;_adf ._abcf =_agdb ;_adf ._eae =_gcec ;_adf ._gfg =_bccb ;return _adf ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_eceaf *TOC )SetLineSeparatorStyle (style TextStyle ){_eceaf ._gdggf =style };func _gcgdb (_ggbca *Table ,_adafb DrawContext )([]*Block ,DrawContext ,error ){var _edggg []*Block ;_ceddb :=NewBlock (_adafb .PageWidth ,_adafb .PageHeight );_ggbca .updateRowHeights (_adafb .Width -_ggbca ._geefd .Left -_ggbca ._geefd .Right );
_bcgda :=_ggbca ._geefd .Top ;if _ggbca ._acggb .IsRelative ()&&!_ggbca ._ccebb {_fbfaa :=_ggbca .Height ();if _fbfaa > _adafb .Height -_ggbca ._geefd .Top &&_fbfaa <=_adafb .PageHeight -_adafb .Margins .Top -_adafb .Margins .Bottom {_edggg =[]*Block {NewBlock (_adafb .PageWidth ,_adafb .PageHeight -_adafb .Y )};
var _cegd error ;if _ ,_adafb ,_cegd =_ffdbg ().GeneratePageBlocks (_adafb );_cegd !=nil {return nil ,_adafb ,_cegd ;};_bcgda =0;};};_fccef :=_adafb ;if _ggbca ._acggb .IsAbsolute (){_adafb .X =_ggbca ._fcbca ;_adafb .Y =_ggbca ._bcab ;}else {_adafb .X +=_ggbca ._geefd .Left ;
_adafb .Y +=_bcgda ;_adafb .Width -=_ggbca ._geefd .Left +_ggbca ._geefd .Right ;_adafb .Height -=_bcgda ;};_ebgff :=_adafb .Width ;_cggga :=_adafb .X ;_bcaa :=_adafb .Y ;_ggecb :=_adafb .Height ;_cgdae :=0;_aada ,_dbeeg :=-1,-1;if _ggbca ._eeed {for _eaae ,_fbgb :=range _ggbca ._eafe {if _fbgb ._deba < _ggbca ._abeef {continue ;
};if _fbgb ._deba > _ggbca ._cdfg {break ;};if _aada < 0{_aada =_eaae ;};_dbeeg =_eaae ;};};if _gafgg :=_ggbca .wrapContent (_adafb );_gafgg !=nil {return nil ,_adafb ,_gafgg ;};_ggbca .updateRowHeights (_adafb .Width -_ggbca ._geefd .Left -_ggbca ._geefd .Right );
var (_edffa bool ;_bgee int ;_baedf int ;_ccba bool ;_dbge int ;_efbbe error ;);for _dfeg :=0;_dfeg < len (_ggbca ._eafe );_dfeg ++{_ccbae :=_ggbca ._eafe [_dfeg ];if _dedbf ,_agbba :=_ggbca .getLastCellFromCol (_ccbae ._gacfd );_dedbf ==_dfeg {if (_agbba ._deba +_agbba ._acag -1)< _ggbca ._adfc {for _gdfcf :=_ccbae ._deba ;
_gdfcf < _ggbca ._adfc ;_gdfcf ++{_begc :=&TableCell {};_begc ._deba =_gdfcf +1;_begc ._acag =1;_begc ._gacfd =_ccbae ._gacfd ;_ggbca ._eafe =append (_ggbca ._eafe ,_begc );};};};_egbdba :=_ccbae .width (_ggbca ._aabdd ,_ebgff );_gfcfd :=float64 (0.0);
for _cffg :=0;_cffg < _ccbae ._gacfd -1;_cffg ++{_gfcfd +=_ggbca ._aabdd [_cffg ]*_ebgff ;};_dfegc :=float64 (0.0);for _ffffdb :=_cgdae ;_ffffdb < _ccbae ._deba -1;_ffffdb ++{_dfegc +=_ggbca ._abfdc [_ffffdb ];};_adafb .Height =_ggecb -_dfegc ;_eefa :=float64 (0.0);
for _affgd :=0;_affgd < _ccbae ._acag ;_affgd ++{_eefa +=_ggbca ._abfdc [_ccbae ._deba +_affgd -1];};_aabc :=_ccba &&_ccbae ._deba !=_dbge ;_dbge =_ccbae ._deba ;if _aabc ||_eefa > _adafb .Height {if _ggbca ._fbab &&!_ccba {_ccba ,_efbbe =_ggbca .wrapRow (_dfeg ,_adafb ,_ebgff );
if _efbbe !=nil {return nil ,_adafb ,_efbbe ;};if _ccba {_dfeg --;continue ;};};_edggg =append (_edggg ,_ceddb );_ceddb =NewBlock (_adafb .PageWidth ,_adafb .PageHeight );_cggga =_adafb .Margins .Left +_ggbca ._geefd .Left ;_bcaa =_adafb .Margins .Top ;
_adafb .Height =_adafb .PageHeight -_adafb .Margins .Top -_adafb .Margins .Bottom ;_adafb .Page ++;_ggecb =_adafb .Height ;_cgdae =_ccbae ._deba -1;_dfegc =0;_ccba =false ;if _ggbca ._eeed &&_aada >=0{_bgee =_dfeg ;_dfeg =_aada -1;_baedf =_cgdae ;_cgdae =_ggbca ._abeef -1;
_edffa =true ;if _ccbae ._acag > (_ggbca ._adfc -_dbge )||(_ccbae ._acag > 1&&_dfeg < 0){_da .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_edffa =false ;_aada ,_dbeeg =-1,-1;};continue ;};if _aabc {_dfeg --;continue ;};};_adafb .Width =_egbdba ;_adafb .X =_cggga +_gfcfd ;_adafb .Y =_bcaa +_dfegc ;if _eefa > _adafb .PageHeight -_adafb .Margins .Top -_adafb .Margins .Bottom {_eefa =_adafb .PageHeight -_adafb .Margins .Top -_adafb .Margins .Bottom ;
};_deca :=_cdd (_adafb .X ,_adafb .Y ,_egbdba ,_eefa );if _ccbae ._ccab !=nil {_deca .SetFillColor (_ccbae ._ccab );};_deca .SetOpacity (_ccbae ._bdaf );_deca .LineStyle =_ccbae ._dgbg ;_deca ._dacg =_ccbae ._ggae ;_deca ._cgb =_ccbae ._feeaf ;_deca ._edbe =_ccbae ._dafa ;
_deca ._fcc =_ccbae ._dgdb ;if _ccbae ._dbbbd !=nil {_deca .SetColorLeft (_ccbae ._dbbbd );};if _ccbae ._gccfc !=nil {_deca .SetColorBottom (_ccbae ._gccfc );};if _ccbae ._fedcf !=nil {_deca .SetColorRight (_ccbae ._fedcf );};if _ccbae ._bcga !=nil {_deca .SetColorTop (_ccbae ._bcga );
};_deca .SetWidthBottom (_ccbae ._fedgc );_deca .SetWidthLeft (_ccbae ._bgfd );_deca .SetWidthRight (_ccbae ._ebcc );_deca .SetWidthTop (_ccbae ._cdgea );_fabae :=NewBlock (_ceddb ._ccb ,_ceddb ._cb );_fegg :=_ceddb .Draw (_deca );if _fegg !=nil {_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fegg );
};if _ccbae ._cbbgc !=nil {_eddbc :=_ccbae ._cbbgc .Width ();_cfaabg :=_ccbae ._cbbgc .Height ();_abbe :=0.0;switch _adbeg :=_ccbae ._cbbgc .(type ){case *Paragraph :if _adbeg ._ceaa {_eddbc =_adbeg .getMaxLineWidth ()/1000.0;};_fafaf ,_cdca ,_ :=_adbeg .getTextMetrics ();
_efeebf ,_dbgaa :=_fafaf *_adbeg ._gfaa ,_cdca *_adbeg ._gfaa ;_cfaabg =_cfaabg -_dbgaa +_efeebf ;_abbe +=_efeebf -_dbgaa ;_eeabb :=0.5;if _ggbca ._afce {_eeabb =0.3;};switch _ccbae ._dbdg {case CellVerticalAlignmentTop :_abbe +=_efeebf *_eeabb ;case CellVerticalAlignmentBottom :_abbe -=_efeebf *_eeabb ;
};_eddbc +=_adbeg ._defec .Left +_adbeg ._defec .Right ;_cfaabg +=_adbeg ._defec .Top +_adbeg ._defec .Bottom ;case *StyledParagraph :if _adbeg ._bcdbe {_eddbc =_adbeg .getMaxLineWidth ()/1000.0;};_fgeg ,_gdef ,_cfga :=_adbeg .getLineMetrics (0);_fcgdb ,_debfgc :=_fgeg *_adbeg ._adbbc ,_gdef *_adbeg ._adbbc ;
if _adbeg ._abed ==TextVerticalAlignmentCenter {_abbe =_debfgc -(_gdef +(_fgeg +_cfga -_gdef )/2+(_debfgc -_gdef )/2);};if len (_adbeg ._acebb )==1{_cfaabg =_fcgdb ;}else {_cfaabg =_cfaabg -_debfgc +_fcgdb ;};_abbe +=_fcgdb -_debfgc ;switch _ccbae ._dbdg {case CellVerticalAlignmentTop :_abbe +=_fcgdb *0.5;
case CellVerticalAlignmentBottom :_abbe -=_fcgdb *0.5;};_eddbc +=_adbeg ._cgfa .Left +_adbeg ._cgfa .Right ;_cfaabg +=_adbeg ._cgfa .Top +_adbeg ._cgfa .Bottom ;case *Table :_eddbc =_egbdba ;case *List :_eddbc =_egbdba ;case *Division :_eddbc =_egbdba ;
case *Chart :_eddbc =_egbdba ;case *Line :_cfaabg +=_adbeg ._agbfd .Top +_adbeg ._agbfd .Bottom ;_abbe -=_adbeg .Height ()/2;case *Image :_eddbc +=_adbeg ._aedc .Left +_adbeg ._aedc .Right ;_cfaabg +=_adbeg ._aedc .Top +_adbeg ._aedc .Bottom ;};switch _ccbae ._ddca {case CellHorizontalAlignmentLeft :_adafb .X +=_ccbae ._gdfaa ;
_adafb .Width -=_ccbae ._gdfaa ;case CellHorizontalAlignmentCenter :if _afcb :=_egbdba -_eddbc ;_afcb > 0{_adafb .X +=_afcb /2;_adafb .Width -=_afcb /2;};case CellHorizontalAlignmentRight :if _egbdba > _eddbc {_adafb .X =_adafb .X +_egbdba -_eddbc -_ccbae ._gdfaa ;
_adafb .Width -=_ccbae ._gdfaa ;};};_caab :=_adafb .Y ;_dggdb :=_adafb .Height ;_adafb .Y +=_abbe ;switch _ccbae ._dbdg {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _cgfb :=_eefa -_cfaabg ;_cgfb > 0{_adafb .Y +=_cgfb /2;_adafb .Height -=_cgfb /2;
};case CellVerticalAlignmentBottom :if _eefa > _cfaabg {_adafb .Y =_adafb .Y +_eefa -_cfaabg ;_adafb .Height =_eefa ;};};_eeffe :=_ceddb .DrawWithContext (_ccbae ._cbbgc ,_adafb );if _eeffe !=nil {if _ac .Is (_eeffe ,ErrContentNotFit )&&!_aabc {_ceddb =_fabae ;
_aabc =true ;_dfeg --;continue ;};_da .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_eeffe );};_adafb .Y =_caab ;_adafb .Height =_dggdb ;};_adafb .Y +=_eefa ;_adafb .Height -=_eefa ;if _edffa &&_dfeg +1> _dbeeg {_bcaa +=_dfegc +_eefa ;_ggecb -=_eefa +_dfegc ;
_cgdae =_baedf ;_dfeg =_bgee -1;_edffa =false ;};};_edggg =append (_edggg ,_ceddb );if _ggbca ._acggb .IsAbsolute (){return _edggg ,_fccef ,nil ;};_adafb .X =_fccef .X ;_adafb .Width =_fccef .Width ;_adafb .Y +=_ggbca ._geefd .Bottom ;_adafb .Height -=_ggbca ._geefd .Bottom ;
return _edggg ,_adafb ,nil ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_gdgf *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gdgf ._defec .Left ,_gdgf ._defec .Right ,_gdgf ._defec .Top ,_gdgf ._defec .Bottom ;};func _dfcea (_dceab string ,_dcgbf bool )string {_bbdbc :=_dceab ;if _bbdbc ==""{return "";
};_edcgg :=_ccd .Paragraph {};_ ,_eface :=_edcgg .SetString (_dceab );if _eface !=nil {return _bbdbc ;};_ccda ,_eface :=_edcgg .Order ();if _eface !=nil {return _bbdbc ;};_afbae :=_ccda .NumRuns ();_adae :=make ([]string ,_afbae );for _acccc :=0;_acccc < _ccda .NumRuns ();
_acccc ++{_abecf :=_ccda .Run (_acccc );_fcbcc :=_abecf .String ();if _abecf .Direction ()==_ccd .RightToLeft {_fcbcc =_ccd .ReverseString (_fcbcc );};if _dcgbf {_adae [_acccc ]=_fcbcc ;}else {_adae [_afbae -1]=_fcbcc ;};_afbae --;};if len (_adae )!=_ccda .NumRuns (){return _dceab ;
};_bbdbc =_fa .Join (_adae ,"");return _bbdbc ;};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_bgag *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_bcdg :=NewTextChunk (text ,_bgag ._egeg );_bcdg .AddAnnotation (_fegcc (page -1,x ,y ,zoom ));return _bgag .appendChunk (_bcdg );};

// SetNotes sets the notes section of the invoice.
func (_cadb *Invoice )SetNotes (title ,content string ){_cadb ._eabd =[2]string {title ,content }};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_bge *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bge ._edg .Left ,_bge ._edg .Right ,_bge ._edg .Top ,_bge ._edg .Bottom ;};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;func (_cbbcg *templateProcessor )parseAttrPropList (_fbed string )map[string ]string {_agfe :=_fa .Fields (_fbed );if len (_agfe )==0{return nil ;};_ebdae :=map[string ]string {};for _ ,_bfffb :=range _agfe {_efdce :=_fgdf .FindStringSubmatch (_bfffb );
if len (_efdce )< 3{continue ;};_ceae ,_cdbe :=_fa .TrimSpace (_efdce [1]),_efdce [2];if _ceae ==""{continue ;};_ebdae [_ceae ]=_cdbe ;};return _ebdae ;};func (_gegg *templateProcessor )parseTableCell (_cdcf *templateNode )(interface{},error ){if _cdcf ._fcdcc ==nil {_gegg .nodeLogError (_cdcf ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_ggge ;};_fgege ,_eagcc :=_cdcf ._fcdcc ._cdab .(*Table );if !_eagcc {_gegg .nodeLogError (_cdcf ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_cdcf ._fcdcc ._cdab );
return nil ,_ggge ;};var _aecd ,_gebg int64 ;for _ ,_caebd :=range _cdcf ._edag .Attr {_cgcbb :=_caebd .Value ;switch _adfeed :=_caebd .Name .Local ;_adfeed {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_aecd =_gegg .parseInt64Attr (_adfeed ,_cgcbb );case "\u0072o\u0077\u0073\u0070\u0061\u006e":_gebg =_gegg .parseInt64Attr (_adfeed ,_cgcbb );
};};if _aecd <=0{_aecd =1;};if _gebg <=0{_gebg =1;};_ffdde :=_fgege .MultiCell (int (_gebg ),int (_aecd ));for _ ,_geec :=range _cdcf ._edag .Attr {_afec :=_geec .Value ;switch _eagb :=_geec .Name .Local ;_eagb {case "\u0069\u006e\u0064\u0065\u006e\u0074":_ffdde .SetIndent (_gegg .parseFloatAttr (_eagb ,_afec ));
case "\u0061\u006c\u0069g\u006e":_ffdde .SetHorizontalAlignment (_gegg .parseCellAlignmentAttr (_eagb ,_afec ));case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_ffdde .SetVerticalAlignment (_gegg .parseCellVerticalAlignmentAttr (_eagb ,_afec ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_ffdde .SetSideBorderStyle (CellBorderSideAll ,_gegg .parseCellBorderStyleAttr (_eagb ,_afec ));case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_ffdde .SetSideBorderStyle (CellBorderSideTop ,_gegg .parseCellBorderStyleAttr (_eagb ,_afec ));
case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_ffdde .SetSideBorderStyle (CellBorderSideBottom ,_gegg .parseCellBorderStyleAttr (_eagb ,_afec ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_ffdde .SetSideBorderStyle (CellBorderSideLeft ,_gegg .parseCellBorderStyleAttr (_eagb ,_afec ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_ffdde .SetSideBorderStyle (CellBorderSideRight ,_gegg .parseCellBorderStyleAttr (_eagb ,_afec ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_ffdde .SetSideBorderWidth (CellBorderSideAll ,_gegg .parseFloatAttr (_eagb ,_afec ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_ffdde .SetSideBorderWidth (CellBorderSideTop ,_gegg .parseFloatAttr (_eagb ,_afec ));case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_ffdde .SetSideBorderWidth (CellBorderSideBottom ,_gegg .parseFloatAttr (_eagb ,_afec ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_ffdde .SetSideBorderWidth (CellBorderSideLeft ,_gegg .parseFloatAttr (_eagb ,_afec ));case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_ffdde .SetSideBorderWidth (CellBorderSideRight ,_gegg .parseFloatAttr (_eagb ,_afec ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_ffdde .SetSideBorderColor (CellBorderSideAll ,_gegg .parseColorAttr (_eagb ,_afec ));case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_ffdde .SetSideBorderColor (CellBorderSideTop ,_gegg .parseColorAttr (_eagb ,_afec ));
case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_ffdde .SetSideBorderColor (CellBorderSideBottom ,_gegg .parseColorAttr (_eagb ,_afec ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_ffdde .SetSideBorderColor (CellBorderSideLeft ,_gegg .parseColorAttr (_eagb ,_afec ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_ffdde .SetSideBorderColor (CellBorderSideRight ,_gegg .parseColorAttr (_eagb ,_afec ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_ffdde .SetBorderLineStyle (_gegg .parseLineStyleAttr (_eagb ,_afec ));
case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_ffdde .SetBackgroundColor (_gegg .parseColorAttr (_eagb ,_afec ));case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;
default:_gegg .nodeLogDebug (_cdcf ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_eagb );
};};return _ffdde ,nil ;};func (_faee *List )ctxHeight (_fddg float64 )float64 {_fddg -=_faee ._ccgdf ;var _bcgcg float64 ;for _ ,_edggf :=range _faee ._agcde {_bcgcg +=_edggf .ctxHeight (_fddg );};return _bcgcg ;};

// SetMarkedContentID sets the marked content ID for the paragraph.
func (_aaef *StyledParagraph )SetMarkedContentID (mcid int64 )*_bdd .KDict {_aaef ._fdeb =&mcid ;_eafdc :=_bdd .NewKDictionary ();_eafdc .S =_bdg .MakeName ("\u0050");_eafdc .K =_bdg .MakeInteger (mcid );return _eafdc ;};func _feac (_acee []*ColorPoint )*LinearShading {return &LinearShading {_bdbcd :&shading {_ddec :ColorWhite ,_faga :false ,_agda :[]bool {false ,false },_decd :_acee },_affg :&_bdd .PdfRectangle {}};
};

// Add adds a new line with the default style to the table of contents.
func (_acdf *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_eabce :=_acdf .AddLine (_efdgf (TextChunk {Text :number ,Style :_acdf ._caec },TextChunk {Text :title ,Style :_acdf ._cfad },TextChunk {Text :page ,Style :_acdf ._cdbed },level ,_acdf ._fddgb ));
if _eabce ==nil {return nil ;};_cabc :=&_acdf ._badg ;_eabce .SetMargins (_cabc .Left ,_cabc .Right ,_cabc .Top ,_cabc .Bottom );_eabce .SetLevelOffset (_acdf ._faadb );_eabce .Separator .Text =_acdf ._agdgdc ;_eabce .Separator .Style =_acdf ._gdggf ;return _eabce ;
};

// CreateFrontPage sets a function to generate a front Page.
func (_cfbe *Creator )CreateFrontPage (genFrontPageFunc func (_cgcf FrontpageFunctionArgs )){_cfbe ._edd =genFrontPageFunc ;};

// SetHeight sets the height of the ellipse.
func (_gac *Ellipse )SetHeight (height float64 ){_gac ._cce =height };func (_bce *Block )duplicate ()*Block {_dbg :=&Block {};*_dbg =*_bce ;_bf :=_ee .ContentStreamOperations {};_bf =append (_bf ,*_bce ._ae ...);_dbg ._ae =&_bf ;return _dbg ;};

// SetFillColor sets background color for border.
func (_ggd *border )SetFillColor (col Color ){_ggd ._cac =col };func (_fba *Block )mergeBlocks (_aef *Block )error {_ade :=_bcb (_fba ._ae ,_fba ._fb ,_aef ._ae ,_aef ._fb );if _ade !=nil {return _ade ;};for _ ,_efd :=range _aef ._ceg {_fba .AddAnnotation (_efd );
};return nil ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_ccab Color ;_bdaf float64 ;_dgbg _ebc .LineStyle ;_ggae CellBorderStyle ;_dbbbd Color ;_bgfd float64 ;_dgdb CellBorderStyle ;_gccfc Color ;_fedgc float64 ;_feeaf CellBorderStyle ;_fedcf Color ;_ebcc float64 ;_dafa CellBorderStyle ;
_bcga Color ;_cdgea float64 ;_deba ,_gacfd int ;_acag int ;_decgd int ;_cbbgc VectorDrawable ;_ddca CellHorizontalAlignment ;_dbdg CellVerticalAlignment ;_gdfaa float64 ;_bdffe *Table ;};func _gbdeg (_bcaab *templateProcessor ,_cdafg *templateNode )(interface{},error ){return _bcaab .parseChart (_cdafg );
};

// SetMarkedContentID sets marked content ID.
func (_dbcg *FilledCurve )SetMarkedContentID (mcid int64 )*_bdd .KDict {_dbcg ._agcd =&mcid ;_acgcc :=_bdd .NewKDictionary ();_acgcc .S =_bdg .MakeName (_bdd .StructureTypeFigure );_acgcc .K =_bdg .MakeInteger (mcid );return _acgcc ;};

// NewTOC creates a new table of contents.
func (_bdad *Creator )NewTOC (title string )*TOC {_dgcc :=_bdad .NewTextStyle ();_dgcc .Font =_bdad ._bbaf ;return _gdafg (title ,_bdad .NewTextStyle (),_dgcc );};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_fafa *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_fafa ._cafee =alignment };func (_gbdcc *templateProcessor )parseInt64Array (_gfaf ,_daeb string )[]int64 {_da .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gfaf ,_daeb );
_ceffd :=_fa .Fields (_daeb );_dbed :=make ([]int64 ,0,len (_ceffd ));for _ ,_egega :=range _ceffd {_fabe ,_ :=_eb .ParseInt (_egega ,10,64);_dbed =append (_dbed ,_fabe );};return _dbed ;};func (_bfgdc *templateProcessor )parseTextRenderingModeAttr (_dgga ,_cfae string )TextRenderingMode {_da .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dgga ,_cfae );
_afbd :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_cfae ];
return _afbd ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_babg *Image )SetEncoder (encoder _bdg .StreamEncoder ){_babg ._feed =encoder };

// GetOptimizer returns current PDF optimizer.
func (_bdfg *Creator )GetOptimizer ()_bdd .Optimizer {return _bdfg ._becg };func (_feeaac *templateProcessor )parseRectangle (_ebfga *templateNode )(interface{},error ){_ecggb :=_feeaac .creator .NewRectangle (0,0,0,0);for _ ,_bggef :=range _ebfga ._edag .Attr {_adbege :=_bggef .Value ;
switch _gabab :=_bggef .Name .Local ;_gabab {case "\u0078":_ecggb ._cbcfa =_feeaac .parseFloatAttr (_gabab ,_adbege );case "\u0079":_ecggb ._ffdf =_feeaac .parseFloatAttr (_gabab ,_adbege );case "\u0077\u0069\u0064t\u0068":_ecggb .SetWidth (_feeaac .parseFloatAttr (_gabab ,_adbege ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_ecggb .SetHeight (_feeaac .parseFloatAttr (_gabab ,_adbege ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_ecggb .SetFillColor (_feeaac .parseColorAttr (_gabab ,_adbege ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_ecggb .SetFillOpacity (_feeaac .parseFloatAttr (_gabab ,_adbege ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_ecggb .SetBorderColor (_feeaac .parseColorAttr (_gabab ,_adbege ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_ecggb .SetBorderOpacity (_feeaac .parseFloatAttr (_gabab ,_adbege ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_ecggb .SetBorderWidth (_feeaac .parseFloatAttr (_gabab ,_adbege ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_daeae ,_ccbgb ,_dabc ,_aefge :=_feeaac .parseBorderRadiusAttr (_gabab ,_adbege );
_ecggb .SetBorderRadius (_daeae ,_ccbgb ,_aefge ,_dabc );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_ecggb ._dbdd =_feeaac .parseFloatAttr (_gabab ,_adbege );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_ecggb ._ebfg =_feeaac .parseFloatAttr (_gabab ,_adbege );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_ecggb ._bbcg =_feeaac .parseFloatAttr (_gabab ,_adbege );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_ecggb ._defaa =_feeaac .parseFloatAttr (_gabab ,_adbege );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_ecggb .SetPositioning (_feeaac .parsePositioningAttr (_gabab ,_adbege ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_ecggb .SetFitMode (_feeaac .parseFitModeAttr (_gabab ,_adbege ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_bcgac :=_feeaac .parseMarginAttr (_gabab ,_adbege );_ecggb .SetMargins (_bcgac .Left ,_bcgac .Right ,_bcgac .Top ,_bcgac .Bottom );default:_feeaac .nodeLogDebug (_ebfga ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_gabab );
};};return _ecggb ,nil ;};

// FillColor returns the fill color of the rectangle.
func (_fcec *Rectangle )FillColor ()Color {return _fcec ._ddgb };

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_cedf *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _agcc (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// AddSection adds a new content section at the end of the invoice.
func (_ffff *Invoice )AddSection (title ,content string ){_ffff ._gbac =append (_ffff ._gbac ,[2]string {title ,content });};func _ecebf (_afggb float64 ,_fcdb float64 ,_bfcc float64 ,_cffag float64 ,_febgb []*ColorPoint )*RadialShading {return &RadialShading {_eddc :&shading {_ddec :ColorWhite ,_faga :false ,_agda :[]bool {false ,false },_decd :_febgb },_cedaa :_afggb ,_dbbe :_fcdb ,_beaef :_bfcc ,_dgefe :_cffag ,_eggc :AnchorCenter };
};func (_cefd *Creator )wrapPageIfNeeded (_bbc *_bdd .PdfPage )(*_bdd .PdfPage ,error ){_fadec ,_efbc :=_bbc .GetAllContentStreams ();if _efbc !=nil {return nil ,_efbc ;};_cedbg :=_ee .NewContentStreamParser (_fadec );_eddb ,_efbc :=_cedbg .Parse ();if _efbc !=nil {return nil ,_efbc ;
};if !_eddb .HasUnclosedQ (){return nil ,nil ;};_eddb .WrapIfNeeded ();_fbfg ,_efbc :=_bdg .MakeStream (_eddb .Bytes (),_bdg .NewFlateEncoder ());if _efbc !=nil {return nil ,_efbc ;};_bbc .Contents =_bdg .MakeArray (_fbfg );return _bbc ,nil ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_ecb *Creator )RotateDeg (angleDeg int64 )error {_bcca :=_ecb .getActivePage ();if _bcca ==nil {_da .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _ac .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_da .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _ac .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _bbbg int64 ;if _bcca .Rotate !=nil {_bbbg =*(_bcca .Rotate );};_bbbg +=angleDeg ;_bcca .Rotate =&_bbbg ;return nil ;};func (_acef *StyledParagraph )getTextWidth ()float64 {var _cgbf float64 ;
_gbga :=len (_acef ._adebd );for _fgaf ,_cccfgb :=range _acef ._adebd {_gbfac :=&_cccfgb .Style ;_gdgae :=len (_cccfgb .Text );for _accde ,_cfcab :=range _cccfgb .Text {if _cfcab =='\u000A'{continue ;};_baggg ,_cebe :=_gbfac .Font .GetRuneMetrics (_cfcab );
if !_cebe {_da .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_cfcab );return -1;};_cgbf +=_gbfac .FontSize *_baggg .Wx *_gbfac .horizontalScale ();
if _cfcab !=' '&&(_fgaf !=_gbga -1||_accde !=_gdgae -1){_cgbf +=_gbfac .CharSpacing *1000.0;};};};return _cgbf ;};func _face (_eacbb ...interface{})[]interface{}{return _eacbb };func _ffdbg ()*PageBreak {return &PageBreak {}};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_aegc *Division )Add (d VectorDrawable )error {switch _bebb :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_ecgd ,_cdbg :=_bebb .ContainerComponent (_aegc );
if _cdbg !=nil {return _cdbg ;};_fcda ,_ecfd :=_ecgd .(VectorDrawable );if !_ecfd {return _a .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_ecgd );
};d =_fcda ;default:return _ac .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_aegc ._gbfd =append (_aegc ._gbfd ,d );return nil ;};

// SetMarkedContentID sets the marked content identifier.
func (_bafd *Division )SetMarkedContentID (id int64 )*_bdd .KDict {return nil };

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_daec *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_daec ._ddca =halign };

// SetLevel sets the indentation level of the TOC line.
func (_gfcgg *TOCLine )SetLevel (level uint ){_gfcgg ._edcf =level ;_gfcgg ._cgcbd ._cgfa .Left =_gfcgg ._afgca +float64 (_gfcgg ._edcf -1)*_gfcgg ._cdbd ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_agdgg *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_ebgcg :=&_agdgg ._badg ;_ebgcg .Left =left ;_ebgcg .Right =right ;_ebgcg .Top =top ;_ebgcg .Bottom =bottom ;};func (_aded *StyledParagraph )appendChunk (_adefg *TextChunk )*TextChunk {_aded ._adebd =append (_aded ._adebd ,_adefg );
_aded .wrapText ();return _adefg ;};func (_dcde *templateProcessor )parseEllipse (_gbdaa *templateNode )(interface{},error ){_bedgee :=_dcde .creator .NewEllipse (0,0,0,0);for _ ,_geca :=range _gbdaa ._edag .Attr {_cedgcf :=_geca .Value ;switch _egcaa :=_geca .Name .Local ;
_egcaa {case "\u0063\u0078":_bedgee ._afdf =_dcde .parseFloatAttr (_egcaa ,_cedgcf );case "\u0063\u0079":_bedgee ._dgade =_dcde .parseFloatAttr (_egcaa ,_cedgcf );case "\u0077\u0069\u0064t\u0068":_bedgee .SetWidth (_dcde .parseFloatAttr (_egcaa ,_cedgcf ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_bedgee .SetHeight (_dcde .parseFloatAttr (_egcaa ,_cedgcf ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_bedgee .SetFillColor (_dcde .parseColorAttr (_egcaa ,_cedgcf ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_bedgee .SetFillOpacity (_dcde .parseFloatAttr (_egcaa ,_cedgcf ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_bedgee .SetBorderColor (_dcde .parseColorAttr (_egcaa ,_cedgcf ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_bedgee .SetBorderOpacity (_dcde .parseFloatAttr (_egcaa ,_cedgcf ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_bedgee .SetBorderWidth (_dcde .parseFloatAttr (_egcaa ,_cedgcf ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_bedgee .SetPositioning (_dcde .parsePositioningAttr (_egcaa ,_cedgcf ));
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_bedgee .SetFitMode (_dcde .parseFitModeAttr (_egcaa ,_cedgcf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_dcdcf :=_dcde .parseMarginAttr (_egcaa ,_cedgcf );_bedgee .SetMargins (_dcdcf .Left ,_dcdcf .Right ,_dcdcf .Top ,_dcdcf .Bottom );
default:_dcde .nodeLogDebug (_gbdaa ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_egcaa );
};};return _bedgee ,nil ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_cdgfe *TableCell )SetBorderLineStyle (style _ebc .LineStyle ){_cdgfe ._dgbg =style };func _gdcb (_eeegg ,_befd ,_gcee string ,_cbdae uint ,_agbg TextStyle )*TOCLine {return _efdgf (TextChunk {Text :_eeegg ,Style :_agbg },TextChunk {Text :_befd ,Style :_agbg },TextChunk {Text :_gcee ,Style :_agbg },_cbdae ,_agbg );
};func _fbdd (_abbg []_ebc .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_edaef :&_ebc .PolyBezierCurve {Curves :_abbg ,BorderColor :_bdd .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_efef :1.0,_bgdga :1.0};};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_fagc *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acbfg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fbcdf ,_ ,_baed :=_fagc .draw (_acbfg ,"");if _baed !=nil {return nil ,ctx ,_baed ;};_baed =_acbfg .addContentsByString (string (_fbcdf ));
if _baed !=nil {return nil ,ctx ,_baed ;};return []*Block {_acbfg },ctx ,nil ;};func _dfaaaa (_edee string )bool {_fcebd :=func (_deaa rune )bool {return _deaa =='\u000A'};_afgd :=_fa .TrimFunc (_edee ,_fcebd );_cadfd :=_ccd .Paragraph {};_ ,_bfcd :=_cadfd .SetString (_afgd );
if _bfcd !=nil {return true ;};_bcbc ,_bfcd :=_cadfd .Order ();if _bfcd !=nil {return true ;};if _bcbc .NumRuns ()< 1{return true ;};return _cadfd .IsLeftToRight ();};var _bcdea =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_cgadf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bgae :_ggega },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_cgadf :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_bgae :_febba },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_cgadf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bgae :_eddba },"\u0074\u0061\u0062l\u0065":&templateTag {_cgadf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bgae :_bgaeg },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_cgadf :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_bgae :_dabgg },"\u006c\u0069\u006e\u0065":&templateTag {_cgadf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bgae :_dfca },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_cgadf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bgae :_cbbd },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_cgadf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bgae :_fdadc },"\u0069\u006d\u0061g\u0065":&templateTag {_cgadf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bgae :_abada },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_cgadf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bgae :_cfcg },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_cgadf :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bgae :_eccc },"\u0063\u0068\u0061r\u0074":&templateTag {_cgadf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bgae :_gbdeg },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_cgadf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bgae :_ccdbf },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_cgadf :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_bgae :_ebeg },"\u006c\u0069\u0073\u0074":&templateTag {_cgadf :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bgae :_ecefg },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_cgadf :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_bgae :_cafdf },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_cgadf :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bgae :_fcgc }};


// SetFillOpacity sets the fill opacity.
func (_ceccc *Polygon )SetFillOpacity (opacity float64 ){_ceccc ._gcadc =opacity };func (_cbac *StyledParagraph )getMaxLineWidth ()float64 {if _cbac ._acebb ==nil ||(_cbac ._acebb !=nil &&len (_cbac ._acebb )==0){_cbac .wrapText ();};var _cgda float64 ;
for _ ,_cafac :=range _cbac ._acebb {_bedge :=_cbac .getTextLineWidth (_cafac );if _bedge > _cgda {_cgda =_bedge ;};};return _cgda ;};func (_dcdee *templateProcessor )addNodeText (_gdbe *templateNode ,_gdbc string )error {_adgb :=_gdbe ._cdab ;if _adgb ==nil {return nil ;
};switch _cfgab :=_adgb .(type ){case *TextChunk :_cfgab .Text =_gdbc ;case *Paragraph :switch _gdbe ._edag .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _gdbe ._fcdcc !=nil {if _fabdc ,_defge :=_gdbe ._fcdcc ._cdab .(*Chapter );
_defge {_fabdc ._fad =_gdbc ;_cfgab .SetText (_fabdc .headingText ());};};default:_cfgab .SetText (_gdbc );};};return nil ;};func (_acbf *pageTransformations )transformBlock (_aggfa *Block ){if _acbf ._ggg !=nil {_aggfa .transform (*_acbf ._ggg );};};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SetFillOpacity sets the fill opacity.
func (_agdg *CurvePolygon )SetFillOpacity (opacity float64 ){_agdg ._cfeb =opacity };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_bgdda *Table )NewCell ()*TableCell {return _bgdda .MultiCell (1,1)};func _fcgc (_cdace *templateProcessor ,_ecefd *templateNode )(interface{},error ){return _cdace .parseListMarker (_ecefd );};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_fgcec *TOC )SetLineLevelOffset (levelOffset float64 ){_fgcec ._faadb =levelOffset };func _cdbc (_gagbg Color ,_ebdc float64 )*ColorPoint {return &ColorPoint {_bdba :_gagbg ,_fbgg :_ebdc }};func _bdddd (_bgedf interface{})(interface{},error ){switch _babc :=_bgedf .(type ){case uint8 :return int64 (_babc ),nil ;
case int8 :return int64 (_babc ),nil ;case uint16 :return int64 (_babc ),nil ;case int16 :return int64 (_babc ),nil ;case uint32 :return int64 (_babc ),nil ;case int32 :return int64 (_babc ),nil ;case uint64 :return int64 (_babc ),nil ;case int64 :return _babc ,nil ;
case int :return int64 (_babc ),nil ;case float32 :return float64 (_babc ),nil ;case float64 :return _babc ,nil ;};return nil ,_a .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0076\u0061\u006c\u0075\u0065\u002c\u0020\u0025\u0076\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072",_bgedf );
};

// SetBorderColor sets the border color for the path.
func (_ddde *FilledCurve )SetBorderColor (color Color ){_ddde ._fdafg =color };

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_gcfda *GraphicSVG )ScaleToHeight (h float64 ){_fedd :=_gcfda ._bac .Width /_gcfda ._bac .Height ;_gcfda ._bac .Height =h ;_gcfda ._bac .Width =h *_fedd ;_gcfda ._bac .SetScaling (_fedd ,_fedd );};func (_gcaed *templateProcessor )parseMarginAttr (_gdeca ,_cdede string )Margins {_da .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_gdeca ,_cdede );
_fdddd :=Margins {};switch _efdfd :=_fa .Fields (_cdede );len (_efdfd ){case 1:_fdddd .Top ,_ =_eb .ParseFloat (_efdfd [0],64);_fdddd .Bottom =_fdddd .Top ;_fdddd .Left =_fdddd .Top ;_fdddd .Right =_fdddd .Top ;case 2:_fdddd .Top ,_ =_eb .ParseFloat (_efdfd [0],64);
_fdddd .Bottom =_fdddd .Top ;_fdddd .Left ,_ =_eb .ParseFloat (_efdfd [1],64);_fdddd .Right =_fdddd .Left ;case 3:_fdddd .Top ,_ =_eb .ParseFloat (_efdfd [0],64);_fdddd .Left ,_ =_eb .ParseFloat (_efdfd [1],64);_fdddd .Right =_fdddd .Left ;_fdddd .Bottom ,_ =_eb .ParseFloat (_efdfd [2],64);
case 4:_fdddd .Top ,_ =_eb .ParseFloat (_efdfd [0],64);_fdddd .Right ,_ =_eb .ParseFloat (_efdfd [1],64);_fdddd .Bottom ,_ =_eb .ParseFloat (_efdfd [2],64);_fdddd .Left ,_ =_eb .ParseFloat (_efdfd [3],64);};return _fdddd ;};

// Padding returns the padding of the component.
func (_ggfg *Division )Padding ()(_fga ,_debf ,_decbd ,_eecae float64 ){return _ggfg ._gcfg .Left ,_ggfg ._gcfg .Right ,_ggfg ._gcfg .Top ,_ggfg ._gcfg .Bottom ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_cbcfa float64 ;_ffdf float64 ;_efdd float64 ;_bbae float64 ;_dgdf Positioning ;_ddgb Color ;_cdebe float64 ;_egbf Color ;_agad float64 ;_ecfdd float64 ;_dbdd float64 ;_ebfg float64 ;_bbcg float64 ;_defaa float64 ;_abae Margins ;_efbdd FitMode ;
_ebadc *int64 ;};

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_bac *_fc .GraphicSVG ;_bdbc Positioning ;_dede float64 ;_cagf float64 ;_ggfgf Margins ;_bebf *int64 ;};

// SetBorderOpacity sets the border opacity.
func (_ccca *Polygon )SetBorderOpacity (opacity float64 ){_ccca ._egcfc =opacity };func (_gdab *Table )clone ()*Table {_cbgf :=*_gdab ;_cbgf ._abfdc =make ([]float64 ,len (_gdab ._abfdc ));copy (_cbgf ._abfdc ,_gdab ._abfdc );_cbgf ._aabdd =make ([]float64 ,len (_gdab ._aabdd ));
copy (_cbgf ._aabdd ,_gdab ._aabdd );_cbgf ._eafe =make ([]*TableCell ,0,len (_gdab ._eafe ));for _ ,_bbab :=range _gdab ._eafe {_ffca :=*_bbab ;_ffca ._bdffe =&_cbgf ;_cbgf ._eafe =append (_cbgf ._eafe ,&_ffca );};return &_cbgf ;};func (_eef rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _eef ._abcf ,_eef ._eae ,_eef ._gfg };


// SetColorLeft sets border color for left.
func (_ebdf *border )SetColorLeft (col Color ){_ebdf ._aeg =col };func (_efefd *templateProcessor )loadImageFromSrc (_bebgbe string )(*Image ,error ){if _bebgbe ==""{_da .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_feffg ;};_efccg :=_fa .Split (_bebgbe ,"\u002c");for _ ,_egag :=range _efccg {_egag =_fa .TrimSpace (_egag );if _egag ==""{continue ;};_cegda ,_ecfed :=_efefd ._cggc .ImageMap [_egag ];if _ecfed {return _cdbb (_cegda );};if _decfbf :=_efefd .parseAttrPropList (_egag );
len (_decfbf )> 0{if _dcbdc ,_ceebg :=_decfbf ["\u0070\u0061\u0074\u0068"];_ceebg {if _eagca ,_dbcc :=_fecd (_dcbdc );_dbcc !=nil {_da .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_dcbdc ,_dbcc );
}else {return _eagca ,nil ;};};};};_da .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_bebgbe );return nil ,_feffg ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_adgea *Invoice )Terms ()(string ,string ){return _adgea ._ggbee [0],_adgea ._ggbee [1]};func (_acgfa *TOCLine )prepareParagraph (_adbg *StyledParagraph ,_fdcf DrawContext ){_dgfeb :=_acgfa .Title .Text ;if _acgfa .Number .Text !=""{_dgfeb ="\u0020"+_dgfeb ;
};_dgfeb +="\u0020";_aegfc :=_acgfa .Page .Text ;if _aegfc !=""{_aegfc ="\u0020"+_aegfc ;};_ggdaf :=[]*_bdd .PdfAnnotation {};_cdgbg :=_acgfa .getLineLink ();if _cdgbg !=nil {_ggdaf =append (_ggdaf ,_cdgbg );};_adbg ._adebd =[]*TextChunk {{Text :_acgfa .Number .Text ,Style :_acgfa .Number .Style ,_gfgcff :_ggdaf },{Text :_dgfeb ,Style :_acgfa .Title .Style ,_gfgcff :_ggdaf },{Text :_aegfc ,Style :_acgfa .Page .Style ,_gfgcff :_ggdaf }};
_adbg .wrapText ();_edcd :=len (_adbg ._acebb );if _edcd ==0{return ;};_cdec :=_fdcf .Width *1000-_adbg .getTextLineWidth (_adbg ._acebb [_edcd -1]);_acgga :=_adbg .getTextLineWidth ([]*TextChunk {&_acgfa .Separator });_efafg :=int (_cdec /_acgga );_fdcg :=_fa .Repeat (_acgfa .Separator .Text ,_efafg );
_acbaf :=_acgfa .Separator .Style ;_gebgb :=_adbg .Insert (2,_fdcg );_gebgb .Style =_acbaf ;_gebgb .SetAnnotation (_acgfa .getLineLink ());_cdec =_cdec -float64 (_efafg )*_acgga ;if _cdec > 500{_bgbg ,_cbcg :=_acbaf .Font .GetRuneMetrics (' ');if _cbcg &&_cdec > _bgbg .Wx {_egcff :=int (_cdec /_bgbg .Wx );
if _egcff > 0{_fbaaa :=_acbaf ;_fbaaa .FontSize =1;_gebgb =_adbg .Insert (2,_fa .Repeat ("\u0020",_egcff ));_gebgb .Style =_fbaaa ;_gebgb .SetAnnotation (_acgfa .getLineLink ());};};};};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_gdgg *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cacbd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_acaf ,_bgebc :=_cacbd .setOpacity (_gdgg ._gcadc ,_gdgg ._egcfc );if _bgebc !=nil {return nil ,ctx ,_bgebc ;
};_bgcef :=_gdgg ._bcgb ;_bgcef .FillEnabled =_bgcef .FillColor !=nil ;_bgcef .BorderEnabled =_bgcef .BorderColor !=nil &&_bgcef .BorderWidth > 0;_feec :=_bgcef .Points ;_fcfg :=_bdd .PdfRectangle {};_fgaa :=false ;for _dgeb :=range _feec {for _bafdc :=range _feec [_dgeb ]{_cage :=&_feec [_dgeb ][_bafdc ];
_cage .Y =ctx .PageHeight -_cage .Y ;if !_fgaa {_fcfg .Llx =_cage .X ;_fcfg .Lly =_cage .Y ;_fcfg .Urx =_cage .X ;_fcfg .Ury =_cage .Y ;_fgaa =true ;}else {_fcfg .Llx =_bd .Min (_fcfg .Llx ,_cage .X );_fcfg .Lly =_bd .Min (_fcfg .Lly ,_cage .Y );_fcfg .Urx =_bd .Max (_fcfg .Urx ,_cage .X );
_fcfg .Ury =_bd .Max (_fcfg .Ury ,_cage .Y );};};};if _bgcef .FillEnabled {_bbba :=_fcgdf (_cacbd ,_gdgg ._bcgb .FillColor ,_gdgg ._daaad ,func ()Rectangle {return Rectangle {_cbcfa :_fcfg .Llx ,_ffdf :_fcfg .Lly ,_efdd :_fcfg .Width (),_bbae :_fcfg .Height ()};
});if _bbba !=nil {return nil ,ctx ,_bbba ;};};_cecb ,_ ,_bgebc :=_bgcef .MarkedDraw (_acaf ,_gdgg ._ggab );if _bgebc !=nil {return nil ,ctx ,_bgebc ;};if _bgebc =_cacbd .addContentsByString (string (_cecb ));_bgebc !=nil {return nil ,ctx ,_bgebc ;};return []*Block {_cacbd },ctx ,nil ;
};func (_ggac *templateProcessor )parseTextAlignmentAttr (_gbabg ,_abgec string )TextAlignment {_da .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gbabg ,_abgec );
_bccgf :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_abgec ];
return _bccgf ;};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_dcda *Ellipse )BorderOpacity ()float64 {return _dcda ._ffaeg };func (_gcga *templateProcessor )parseColor (_cfece string )Color {if _cfece ==""{return nil ;};_aega ,_fadfad :=_gcga ._cggc .ColorMap [_cfece ];if _fadfad {return _aega ;};if _cfece [0]=='#'{return ColorRGBFromHex (_cfece );
};return nil ;};

// Context returns the current drawing context.
func (_aad *Creator )Context ()DrawContext {return _aad ._ebce };

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_aafg *Creator )MoveTo (x ,y float64 ){_aafg ._ebce .X =x ;_aafg ._ebce .Y =y };func _egg (_dbc string ,_efae _bdg .PdfObject ,_gfe *_bdd .PdfPageResources )_bdg .PdfObjectName {_fbaa :=_fa .TrimRightFunc (_fa .TrimSpace (_dbc ),func (_cea rune )bool {return _bg .IsNumber (_cea )});
if _fbaa ==""{_fbaa ="\u0046\u006f\u006e\u0074";};_dfba :=0;_ded :=_bdg .PdfObjectName (_dbc );for {_ddfb ,_cfg :=_gfe .GetFontByName (_ded );if !_cfg ||_ddfb ==_efae {break ;};_dfba ++;_ded =_bdg .PdfObjectName (_a .Sprintf ("\u0025\u0073\u0025\u0064",_fbaa ,_dfba ));
};return _ded ;};func _edfd (_ebab _b .Image )(*Image ,error ){_cgab ,_gdddg :=_bdd .ImageHandling .NewImageFromGoImage (_ebab );if _gdddg !=nil {return nil ,_gdddg ;};return _cdbb (_cgab );};

// SetDueDate sets the due date of the invoice.
func (_fffb *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_fffb ._ecbb [1].Value =dueDate ;return _fffb ._ecbb [0],_fffb ._ecbb [1];};

// SetWidthLeft sets border width for left.
func (_aed *border )SetWidthLeft (bw float64 ){_aed ._bgb =bw };

// SetLogo sets the logo of the invoice.
func (_dbgb *Invoice )SetLogo (logo *Image ){_dbgb ._ddac =logo };

// Color returns the color of the line.
func (_egfa *Line )Color ()Color {return _egfa ._ceecf };

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_eefc *Image )SetWidth (w float64 ){_eefc ._fgbd =w };func (_edgbg *templateProcessor )parseTextChunk (_fgbdc *templateNode ,_bafed *TextChunk )(interface{},error ){if _fgbdc ._fcdcc ==nil {_edgbg .nodeLogError (_fgbdc ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_ggge ;};var (_egcga =_edgbg .creator .NewTextStyle ();_aecc bool ;);for _ ,_gfdea :=range _fgbdc ._edag .Attr {if _gfdea .Name .Local =="\u006c\u0069\u006e\u006b"{_abced ,_ebdb :=_fgbdc ._fcdcc ._cdab .(*StyledParagraph );if !_ebdb {_edgbg .nodeLogError (_fgbdc ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_aecc =true ;}else {_egcga =_abced ._egeg ;};break ;};};if _bafed ==nil {_bafed =NewTextChunk ("",_egcga );};for _ ,_eaba :=range _fgbdc ._edag .Attr {_fbgga :=_eaba .Value ;switch _bdgca :=_eaba .Name .Local ;_bdgca {case "\u0063\u006f\u006co\u0072":_bafed .Style .Color =_edgbg .parseColorAttr (_bdgca ,_fbgga );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_bafed .Style .OutlineColor =_edgbg .parseColorAttr (_bdgca ,_fbgga );case "\u0066\u006f\u006e\u0074":_bafed .Style .Font =_edgbg .parseFontAttr (_bdgca ,_fbgga );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_bafed .Style .FontSize =_edgbg .parseFloatAttr (_bdgca ,_fbgga );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_bafed .Style .OutlineSize =_edgbg .parseFloatAttr (_bdgca ,_fbgga );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_bafed .Style .CharSpacing =_edgbg .parseFloatAttr (_bdgca ,_fbgga );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_bafed .Style .HorizontalScaling =_edgbg .parseFloatAttr (_bdgca ,_fbgga );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_bafed .Style .RenderingMode =_edgbg .parseTextRenderingModeAttr (_bdgca ,_fbgga );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_bafed .Style .Underline =_edgbg .parseBoolAttr (_bdgca ,_fbgga );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_bafed .Style .UnderlineStyle .Color =_edgbg .parseColorAttr (_bdgca ,_fbgga );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_bafed .Style .UnderlineStyle .Offset =_edgbg .parseFloatAttr (_bdgca ,_fbgga );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_bafed .Style .UnderlineStyle .Thickness =_edgbg .parseFloatAttr (_bdgca ,_fbgga );
case "\u006c\u0069\u006e\u006b":if !_aecc {_bafed .AddAnnotation (_edgbg .parseLinkAttr (_bdgca ,_fbgga ));};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_bafed .Style .TextRise =_edgbg .parseFloatAttr (_bdgca ,_fbgga );default:_edgbg .nodeLogDebug (_fgbdc ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_bdgca );
};};return _bafed ,nil ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_egea *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_egea ._ebcd .Left =left ;_egea ._ebcd .Right =right ;_egea ._ebcd .Top =top ;_egea ._ebcd .Bottom =bottom ;};

// SetRowHeight sets the height for a specified row.
func (_aaeb *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_aaeb ._abfdc ){return _ac .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aaeb ._abfdc [row -1]=h ;return nil ;
};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_dfe *Image )ScaleToWidth (w float64 ){_cgdfc :=_dfe ._eedg /_dfe ._fgbd ;_dfe ._fgbd =w ;_dfe ._eedg =w *_cgdfc ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// Link returns link information for this line.
func (_fdaa *TOCLine )Link ()(_ddgce int64 ,_cdaa ,_ccabb float64 ){return _fdaa ._ddbe ,_fdaa ._adbf ,_fdaa ._cagac ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_gdfa *Creator )SetPageSize (size PageSize ){_gdfa ._efg =size ;_gdfa ._bccc =size [0];_gdfa ._adfe =size [1];_efcc :=0.1*_gdfa ._bccc ;_gdfa ._ebcd .Left =_efcc ;_gdfa ._ebcd .Right =_efcc ;_gdfa ._ebcd .Top =_efcc ;_gdfa ._ebcd .Bottom =_efcc ;
};func (_ebgg *List )markerWidth ()float64 {var _ddaab float64 ;for _ ,_fadd :=range _ebgg ._agcde {_abba :=_accf (_ebgg ._eacd );_abba .SetEnableWrap (false );_abba .SetTextAlignment (TextAlignmentRight );_abba .Append (_fadd ._baee .Text ).Style =_fadd ._baee .Style ;
_gbeg :=_abba .getTextWidth ()/1000.0;if _ddaab < _gbeg {_ddaab =_gbeg ;};};return _ddaab ;};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_gaba *Creator )NewPolyBezierCurve (curves []_ebc .CubicBezierCurve )*PolyBezierCurve {return _fbdd (curves );};

// SetBorderWidth sets the border width.
func (_gbeb *CurvePolygon )SetBorderWidth (borderWidth float64 ){_gbeb ._gfd .BorderWidth =borderWidth };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_bad *Creator )SetOptimizer (optimizer _bdd .Optimizer ){_bad ._becg =optimizer };

// Heading returns the heading component of the table of contents.
func (_accc *TOC )Heading ()*StyledParagraph {return _accc ._aafbcf };func (_bgegf *templateProcessor )parseLinkAttr (_cedfb ,_aefda string )*_bdd .PdfAnnotation {_aefda =_fa .TrimSpace (_aefda );if _fa .HasPrefix (_aefda ,"\u0075\u0072\u006c(\u0027")&&_fa .HasSuffix (_aefda ,"\u0027\u0029")&&len (_aefda )> 7{return _aaafb (_aefda [5:len (_aefda )-2]);
};if _fa .HasPrefix (_aefda ,"\u0070\u0061\u0067e\u0028")&&_fa .HasSuffix (_aefda ,"\u0029")&&len (_aefda )> 6{var (_abdbc error ;_facdb int64 ;_dfdb float64 ;_eaed float64 ;_gagbb =1.0;_dggf =_fa .Split (_aefda [5:len (_aefda )-1],"\u002c"););_facdb ,_abdbc =_eb .ParseInt (_fa .TrimSpace (_dggf [0]),10,64);
if _abdbc !=nil {_da .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_abdbc );return nil ;};if len (_dggf )>=2{_dfdb ,_abdbc =_eb .ParseFloat (_fa .TrimSpace (_dggf [1]),64);
if _abdbc !=nil {_da .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_abdbc );
return nil ;};};if len (_dggf )>=3{_eaed ,_abdbc =_eb .ParseFloat (_fa .TrimSpace (_dggf [2]),64);if _abdbc !=nil {_da .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_abdbc );
return nil ;};};if len (_dggf )>=4{_gagbb ,_abdbc =_eb .ParseFloat (_fa .TrimSpace (_dggf [3]),64);if _abdbc !=nil {_da .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_abdbc );
return nil ;};};return _fegcc (_facdb -1,_dfdb ,_eaed ,_gagbb );};return nil ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_dbde *Creator )MoveRight (dx float64 ){_dbde ._ebce .X +=dx };

// SetBackground sets the background properties of the component.
func (_fffg *Division )SetBackground (background *Background ){_fffg ._accgd =background };

// SetSubtotal sets the subtotal of the invoice.
func (_bagf *Invoice )SetSubtotal (value string ){_bagf ._cfgg [1].Value =value };

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_agafe *TOCLine )SetLevelOffset (levelOffset float64 ){_agafe ._cdbd =levelOffset ;_agafe ._cgcbd ._cgfa .Left =_agafe ._afgca +float64 (_agafe ._edcf -1)*_agafe ._cdbd ;};

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_cfba *Ellipse )GetCoords ()(float64 ,float64 ){return _cfba ._afdf ,_cfba ._dgade };

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_gdgc *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _feac (colorPoints );};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_eed *Creator )Draw (d Drawable )error {if _eed .getActivePage ()==nil {_eed .NewPage ();};_ccc ,_geb ,_bbe :=d .GeneratePageBlocks (_eed ._ebce );if _bbe !=nil {return _bbe ;};if len (_geb ._aaegd )> 0{_eed .Errors =append (_eed .Errors ,_geb ._aaegd ...);
};for _gcfc ,_afe :=range _ccc {if _gcfc > 0{_eed .NewPage ();};_aafbc :=_eed .getActivePage ();if _dbbce ,_bfe :=_eed ._dbce [_aafbc ];_bfe {if _fdcbd :=_dbbce .mergeBlocks (_afe );_fdcbd !=nil {return _fdcbd ;};if _dgbe :=_cfb (_afe ._fb ,_dbbce ._fb );
_dgbe !=nil {return _dgbe ;};}else {_eed ._dbce [_aafbc ]=_afe ;};};_eed ._ebce .X =_geb .X ;_eed ._ebce .Y =_geb .Y ;_eed ._ebce .Height =_geb .PageHeight -_geb .Y -_geb .Margins .Bottom ;return nil ;};

// SetAnchor set gradient position anchor.
// Default to center.
func (_dbcb *RadialShading )SetAnchor (anchor AnchorPoint ){_dbcb ._eggc =anchor };func (_fecf *templateProcessor )parseFloatArray (_dfcb ,_fefa string )[]float64 {_da .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dfcb ,_fefa );
_ecgce :=_fa .Fields (_fefa );_bddf :=make ([]float64 ,0,len (_ecgce ));for _ ,_gdaf :=range _ecgce {_aggaa ,_ :=_eb .ParseFloat (_gdaf ,64);_bddf =append (_bddf ,_aggaa );};return _bddf ;};type rgbColor struct{_abcf ,_eae ,_gfg float64 };

// SetText replaces all the text of the paragraph with the specified one.
func (_ebfde *StyledParagraph )SetText (text string )*TextChunk {_ebfde .Reset ();return _ebfde .Append (text );};func (_dcbdf *templateProcessor )parseRadialGradientAttr (creator *Creator ,_fbfad string )Color {_fdca :=ColorBlack ;if _fbfad ==""{return _fdca ;
};var (_dgfd error ;_dafc =0.0;_gdba =0.0;_ebfb =-1.0;_dgcga =_fa .Split (_fbfad [16:len (_fbfad )-1],"\u002c"););_ceag :=_fa .Fields (_dgcga [0]);if len (_ceag )==2&&_fa .TrimSpace (_ceag [0])[0]!='#'{_dafc ,_dgfd =_eb .ParseFloat (_ceag [0],64);if _dgfd !=nil {_da .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_dgfd );
};_gdba ,_dgfd =_eb .ParseFloat (_ceag [1],64);if _dgfd !=nil {_da .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_dgfd );
};_dgcga =_dgcga [1:];};_gbgg :=_fa .TrimSpace (_dgcga [0]);if _gbgg [0]!='#'{_ebfb ,_dgfd =_eb .ParseFloat (_gbgg ,64);if _dgfd !=nil {_da .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_dgfd );
};_dgcga =_dgcga [1:];};_afceg ,_cebge :=_dcbdf .processGradientColorPair (_dgcga );if _afceg ==nil ||_cebge ==nil {return _fdca ;};_cddg :=creator .NewRadialGradientColor (_dafc ,_gdba ,0,_ebfb ,[]*ColorPoint {});for _fddgd :=0;_fddgd < len (_afceg );
_fddgd ++{_cddg .AddColorStop (_afceg [_fddgd ],_cebge [_fddgd ]);};return _cddg ;};

// AddColorStop add color stop info for rendering gradient color.
func (_decfb *RadialShading )AddColorStop (color Color ,point float64 ){_decfb ._eddc .AddColorStop (color ,point );};func (_bffa *TableCell )cloneProps (_bfad VectorDrawable )*TableCell {_faef :=*_bffa ;_faef ._cbbgc =_bfad ;return &_faef ;};

// SetMakedContentID sets the marked content id for the table.
func (_ceade *Table )SetMarkedContentID (mcid int64 )*_bdd .KDict {return nil };