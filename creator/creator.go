//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
package creator ;import (_g "bytes";_bg "encoding/xml";_ab "errors";_f "fmt";_be "github.com/gorilla/i18n/linebreak";_ege "github.com/unidoc/unichart/render";_d "github.com/unidoc/unipdf/v3/common";_cf "github.com/unidoc/unipdf/v3/contentstream";_fg "github.com/unidoc/unipdf/v3/contentstream/draw";
_ag "github.com/unidoc/unipdf/v3/core";_bgc "github.com/unidoc/unipdf/v3/internal/graphic2d/svg";_gbe "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_ca "github.com/unidoc/unipdf/v3/internal/license";_eaa "github.com/unidoc/unipdf/v3/internal/transform";
_db "github.com/unidoc/unipdf/v3/model";_cb "golang.org/x/text/unicode/bidi";_ea "image";_ba "io";_a "log";_gb "math";_ae "os";_ffd "regexp";_c "sort";_eg "strconv";_cc "strings";_e "text/template";_ff "unicode";);func (_bb *Block )addContents (_fed *_cf .ContentStreamOperations ){_bb ._bag .WrapIfNeeded ();
_fed .WrapIfNeeded ();*_bb ._bag =append (*_bb ._bag ,*_fed ...);};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_gabb *Chapter )SetShowNumbering (show bool ){_gabb ._dggd =show ;_gabb ._gdbe .SetText (_gabb .headingText ());};func (_fcfc *Division )split (_bfga DrawContext )(_aabe ,_edccg *Division ){var (_bdaf float64 ;_aeef ,_babe []VectorDrawable ;);_dbefa :=_bfga .Width -_fcfc ._caeg .Left -_fcfc ._caeg .Right -_fcfc ._cedd .Left -_fcfc ._cedd .Right ;
for _caaf ,_dafbf :=range _fcfc ._gcdd {_bdaf +=_cgd (_dafbf ,_dbefa );if _bdaf < _bfga .Height {_aeef =append (_aeef ,_dafbf );}else {_babe =_fcfc ._gcdd [_caaf :];break ;};};if len (_aeef )> 0{_aabe =_dgfa ();*_aabe =*_fcfc ;_aabe ._gcdd =_aeef ;if _fcfc ._cgeg !=nil {_aabe ._cgeg =&Background {};
*_aabe ._cgeg =*_fcfc ._cgeg ;};};if len (_babe )> 0{_edccg =_dgfa ();*_edccg =*_fcfc ;_edccg ._gcdd =_babe ;if _fcfc ._cgeg !=nil {_edccg ._cgeg =&Background {};*_edccg ._cgeg =*_fcfc ._cgeg ;};};return _aabe ,_edccg ;};func (_acfb *templateProcessor )run ()error {_cefdf :=_bg .NewDecoder (_g .NewReader (_acfb ._cegbe ));
var _fgeffb *templateNode ;for {_faggd ,_bbac :=_cefdf .Token ();if _bbac !=nil {if _bbac ==_ba .EOF {return nil ;};return _bbac ;};if _faggd ==nil {break ;};_bcegb ,_facbd :=_aeaae (_cefdf );_ecfc :=_cefdf .InputOffset ();switch _eggb :=_faggd .(type ){case _bg .StartElement :_d .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_eggb .Name .Local );
_cafc ,_acadb :=_bedc [_eggb .Name .Local ];if !_acadb {if _acfb ._dfcgb ==""{if _bcegb !=0{_d .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_eggb .Name .Local ,_bcegb ,_facbd );
}else {_d .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_eggb .Name .Local ,_ecfc );
};}else {if _bcegb !=0{_d .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_eggb .Name .Local ,_acfb ._dfcgb ,_bcegb ,_facbd );
}else {_d .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_eggb .Name .Local ,_acfb ._dfcgb ,_ecfc );
};};continue ;};_fgeffb =&templateNode {_fabca :_eggb ,_abgfd :_fgeffb ,_cbcfg :_bcegb ,_bdcbd :_facbd ,_gebfb :_ecfc };if _aagagf :=_cafc ._affaee ;_aagagf !=nil {_fgeffb ._dfbaa ,_bbac =_aagagf (_acfb ,_fgeffb );if _bbac !=nil {return _bbac ;};};case _bg .EndElement :_d .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_eggb .Name .Local );
if _fgeffb !=nil {if _fgeffb ._dfbaa !=nil {if _fagd :=_acfb .renderNode (_fgeffb );_fagd !=nil {return _fagd ;};};_fgeffb =_fgeffb ._abgfd ;};case _bg .CharData :if _fgeffb !=nil &&_fgeffb ._dfbaa !=nil {if _agecb :=_acfb .addNodeText (_fgeffb ,string (_eggb ));
_agecb !=nil {return _agecb ;};};case _bg .Comment :_d .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_eggb ));
};};return nil ;};

// SetNotes sets the notes section of the invoice.
func (_cgdf *Invoice )SetNotes (title ,content string ){_cgdf ._dggc =[2]string {title ,content }};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ddcfg *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbgcd :=ctx ;_aeaf ,ctx ,_aabab :=_ddcfg ._gafa .GeneratePageBlocks (ctx );if _aabab !=nil {return _aeaf ,ctx ,_aabab ;};for _ ,_fabcb :=range _ddcfg ._bcaf {_bedef :=_fabcb ._gaecg ;
if !_ddcfg ._ffcgd {_fabcb ._gaecg =0;};_bgbbe ,_dacdc ,_cdbaa :=_fabcb .GeneratePageBlocks (ctx );_fabcb ._gaecg =_bedef ;if _cdbaa !=nil {return _aeaf ,ctx ,_cdbaa ;};if len (_bgbbe )< 1{continue ;};_aeaf [len (_aeaf )-1].mergeBlocks (_bgbbe [0]);_aeaf =append (_aeaf ,_bgbbe [1:]...);
ctx =_dacdc ;};if _ddcfg ._dfcba .IsRelative (){ctx .X =_cbgcd .X ;};if _ddcfg ._dfcba .IsAbsolute (){return _aeaf ,_cbgcd ,nil ;};return _aeaf ,ctx ,nil ;};func (_ebbf *StyledParagraph )getTextLineWidth (_becgd []*TextChunk )float64 {var _cfae float64 ;
_gebga :=len (_becgd );for _bgfc ,_deabe :=range _becgd {_ffdgd :=&_deabe .Style ;_cbgfc :=len (_deabe .Text );for _facf ,_dcfc :=range _deabe .Text {if _dcfc =='\u000A'{continue ;};_ecddg ,_facb :=_ffdgd .Font .GetRuneMetrics (_dcfc );if !_facb {_d .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dcfc );
return -1;};_cfae +=_ffdgd .FontSize *_ecddg .Wx *_ffdgd .horizontalScale ();if _dcfc !=' '&&(_bgfc !=_gebga -1||_facf !=_cbgfc -1){_cfae +=_ffdgd .CharSpacing *1000.0;};};};return _cfae ;};

// SetCompactMode sets the compact mode flag for this table.
//
// By enabling compact mode, table cell that contains Paragraph/StyleParagraph
// would not add extra height when calculating it's height.
//
// The default value is false.
func (_dcbea *Table )SetCompactMode (enable bool ){_dcbea ._cfed =enable };type templateTag struct{_beec map[string ]struct{};_affaee func (*templateProcessor ,*templateNode )(interface{},error );};func (_ddbg *Division )ctxHeight (_bfgd float64 )float64 {_bfgd -=_ddbg ._caeg .Left +_ddbg ._caeg .Right +_ddbg ._cedd .Left +_ddbg ._cedd .Right ;
var _ecdea float64 ;for _ ,_fcbc :=range _ddbg ._gcdd {_ecdea +=_cgd (_fcbc ,_bfgd );};return _ecdea ;};func _bfd (_feg string ,_aea _ag .PdfObject ,_ecgg *_db .PdfPageResources )_ag .PdfObjectName {_dbe :=_cc .TrimRightFunc (_cc .TrimSpace (_feg ),func (_gceb rune )bool {return _ff .IsNumber (_gceb )});
if _dbe ==""{_dbe ="\u0046\u006f\u006e\u0074";};_faa :=0;_cbffa :=_ag .PdfObjectName (_feg );for {_ccb ,_dac :=_ecgg .GetFontByName (_cbffa );if !_dac ||_ccb ==_aea {break ;};_faa ++;_cbffa =_ag .PdfObjectName (_f .Sprintf ("\u0025\u0073\u0025\u0064",_dbe ,_faa ));
};return _cbffa ;};func (_gagbd *templateProcessor )getNodeErrorLocation (_abab *templateNode ,_egdaf string ,_bdba ...interface{})string {_bgfad :=_f .Sprintf (_egdaf ,_bdba ...);_cggaeb :=_f .Sprintf ("\u0025\u0064",_abab ._gebfb );if _abab ._cbcfg !=0{_cggaeb =_f .Sprintf ("\u0025\u0064\u003a%\u0064",_abab ._cbcfg ,_abab ._bdcbd );
};if _gagbd ._dfcgb !=""{return _f .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_bgfad ,_gagbd ._dfcgb ,_cggaeb );};return _f .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_bgfad ,_cggaeb );};func (_bgca *templateProcessor )parseTextRenderingModeAttr (_cgbcf ,_facag string )TextRenderingMode {_d .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_cgbcf ,_facag );
_cbecbd :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_facag ];
return _cbecbd ;};func (_ecg *Block )drawToPage (_ded *_db .PdfPage )error {_gf :=&_cf .ContentStreamOperations {};if _ded .Resources ==nil {_ded .Resources =_db .NewPdfPageResources ();};_edd :=_gee (_gf ,_ded .Resources ,_ecg ._bag ,_ecg ._aef );if _edd !=nil {return _edd ;
};if _edd =_efg (_ecg ._aef ,_ded .Resources );_edd !=nil {return _edd ;};if _edd =_ded .AppendContentBytes (_gf .Bytes (),true );_edd !=nil {return _edd ;};for _ ,_fdf :=range _ecg ._gc {_ded .AddAnnotation (_fdf );};return nil ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_efee *Invoice )AddressStyle ()TextStyle {return _efee ._gegfg };func (_gagda *templateProcessor )parseImage (_bgbdd *templateNode )(interface{},error ){var _efaba string ;for _ ,_fbgffe :=range _bgbdd ._fabca .Attr {_aecd :=_fbgffe .Value ;switch _accdc :=_fbgffe .Name .Local ;
_accdc {case "\u0073\u0072\u0063":_efaba =_aecd ;};};_fdce ,_bbaf :=_gagda .loadImageFromSrc (_efaba );if _bbaf !=nil {return nil ,_bbaf ;};for _ ,_cecdc :=range _bgbdd ._fabca .Attr {_gbdcf :=_cecdc .Value ;switch _dcgce :=_cecdc .Name .Local ;_dcgce {case "\u0061\u006c\u0069g\u006e":_fdce .SetHorizontalAlignment (_gagda .parseHorizontalAlignmentAttr (_dcgce ,_gbdcf ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_fdce .SetOpacity (_gagda .parseFloatAttr (_dcgce ,_gbdcf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ebefb :=_gagda .parseMarginAttr (_dcgce ,_gbdcf );_fdce .SetMargins (_ebefb .Left ,_ebefb .Right ,_ebefb .Top ,_ebefb .Bottom );
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_fdce .SetFitMode (_gagda .parseFitModeAttr (_dcgce ,_gbdcf ));case "\u0078":_fdce .SetPos (_gagda .parseFloatAttr (_dcgce ,_gbdcf ),_fdce ._eede );case "\u0079":_fdce .SetPos (_fdce ._aeed ,_gagda .parseFloatAttr (_dcgce ,_gbdcf ));
case "\u0077\u0069\u0064t\u0068":_fdce .SetWidth (_gagda .parseFloatAttr (_dcgce ,_gbdcf ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_fdce .SetHeight (_gagda .parseFloatAttr (_dcgce ,_gbdcf ));case "\u0061\u006e\u0067l\u0065":_fdce .SetAngle (_gagda .parseFloatAttr (_dcgce ,_gbdcf ));
case "\u0073\u0072\u0063":break ;default:_gagda .nodeLogDebug (_bgbdd ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_dcgce );
};};return _fdce ,nil ;};func _efggd (_gdcf ,_cbaca ,_caacb int )[]int {_aggc :=[]int {};for _ffgg :=_gdcf ;_ffgg <=_caacb ;_ffgg +=_cbaca {_aggc =append (_aggc ,_ffgg );};return _aggc ;};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_dfea *Ellipse )SetPositioning (position Positioning ){_dfea ._baeb =position };

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_daaa *GraphicSVG )ScaleToWidth (w float64 ){_gfda :=_daaa ._gddd .Height /_daaa ._gddd .Width ;_daaa ._gddd .Width =w ;_daaa ._gddd .Height =w *_gfda ;_daaa ._gddd .SetScaling (_gfda ,_gfda );};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;
);

// SetFillOpacity sets the fill opacity of the ellipse.
func (_dgggc *Ellipse )SetFillOpacity (opacity float64 ){_dgggc ._gfgd =opacity };

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_dbgeg float64 ;_gead float64 ;_bccac float64 ;_begbb float64 ;_aacf Positioning ;_debe Color ;_dgab float64 ;_ddde Color ;_ccde float64 ;_ccbd float64 ;_cdbc float64 ;_eaebb float64 ;_fgfgg float64 ;_cdege float64 ;_cbagd Margins ;
_bbc FitMode ;};

// SetMargins sets the margins of the chart component.
func (_ebcg *Chart )SetMargins (left ,right ,top ,bottom float64 ){_ebcg ._ffa .Left =left ;_ebcg ._ffa .Right =right ;_ebcg ._ffa .Top =top ;_ebcg ._ffa .Bottom =bottom ;};

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_dgbg *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dgbg ._fbcgf .Left ,_dgbg ._fbcgf .Right ,_dgbg ._fbcgf .Top ,_dgbg ._fbcgf .Bottom ;};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_efba *Division )SetPadding (left ,right ,top ,bottom float64 ){_efba ._cedd .Left =left ;_efba ._cedd .Right =right ;_efba ._cedd .Top =top ;_efba ._cedd .Bottom =bottom ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_aadf *StyledParagraph )SetTextAlignment (align TextAlignment ){_aadf ._efdff =align };

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_deeb *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _ab .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _ab .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _ab .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_deeb ._eaged =true ;_deeb ._gbag =startRow ;_deeb ._dacb =endRow ;return nil ;};func (_dacc *templateProcessor )parseBoolAttr (_ffedb ,_feedg string )bool {_d .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_ffedb ,_feedg );
_cgdd ,_ :=_eg .ParseBool (_feedg );return _feedg ==""||_cgdd ;};

// SkipCells skips over a specified number of cells in the table.
func (_dbedc *Table )SkipCells (num int ){if num < 0{_d .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _aaaeb :=0;_aaaeb < num ;_aaaeb ++{_dbedc .NewCell ();};};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_bagd *Invoice )SetAddressStyle (style TextStyle ){_bagd ._gegfg =style };func (_dbad *List )markerWidth ()float64 {var _dfgbc float64 ;for _ ,_cffg :=range _dbad ._bdee {_bgac :=_gfbe (_dbad ._fcad );_bgac .SetEnableWrap (false );_bgac .SetTextAlignment (TextAlignmentRight );
_bgac .Append (_cffg ._bdaa .Text ).Style =_cffg ._bdaa .Style ;_bggda :=_bgac .getTextWidth ()/1000.0;if _dfgbc < _bggda {_dfgbc =_bggda ;};};return _dfgbc ;};func (_fbad *templateProcessor )parseRadialGradientAttr (creator *Creator ,_fdfgd string )Color {_bacb :=ColorBlack ;
if _fdfgd ==""{return _bacb ;};var (_gbbdd error ;_ffaeb =0.0;_fggcb =0.0;_fdgg =-1.0;_agcbb =_cc .Split (_fdfgd [16:len (_fdfgd )-1],"\u002c"););_fecfd :=_cc .Fields (_agcbb [0]);if len (_fecfd )==2&&_cc .TrimSpace (_fecfd [0])[0]!='#'{_ffaeb ,_gbbdd =_eg .ParseFloat (_fecfd [0],64);
if _gbbdd !=nil {_d .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_gbbdd );
};_fggcb ,_gbbdd =_eg .ParseFloat (_fecfd [1],64);if _gbbdd !=nil {_d .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_gbbdd );
};_agcbb =_agcbb [1:];};_fdbf :=_cc .TrimSpace (_agcbb [0]);if _fdbf [0]!='#'{_fdgg ,_gbbdd =_eg .ParseFloat (_fdbf ,64);if _gbbdd !=nil {_d .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_gbbdd );
};_agcbb =_agcbb [1:];};_fgbgd ,_gbgbc :=_fbad .processGradientColorPair (_agcbb );if _fgbgd ==nil ||_gbgbc ==nil {return _bacb ;};_bfgab :=creator .NewRadialGradientColor (_ffaeb ,_fggcb ,0,_fdgg ,[]*ColorPoint {});for _aged :=0;_aged < len (_fgbgd );
_aged ++{_bfgab .AddColorStop (_fgbgd [_aged ],_gbgbc [_aged ]);};return _bfgab ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_ecag DrawContext )([]*Block ,DrawContext ,error );};func (_efbf *templateProcessor )addNodeText (_dafbc *templateNode ,_edfbc string )error {_gbea :=_dafbc ._dfbaa ;if _gbea ==nil {return nil ;};switch _adeag :=_gbea .(type ){case *TextChunk :_adeag .Text =_edfbc ;
case *Paragraph :switch _dafbc ._fabca .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _dafbc ._abgfd !=nil {if _fbfdb ,_bbaa :=_dafbc ._abgfd ._dfbaa .(*Chapter );_bbaa {_fbfdb ._dgac =_edfbc ;_adeag .SetText (_fbfdb .headingText ());
};};default:_adeag .SetText (_edfbc );};};return nil ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_geeae *RadialShading )ToPdfShadingPattern ()*_db .PdfShadingPatternType3 {_gfcb ,_dggf ,_adcef :=_geeae ._cgec ._gccca .ToRGB ();_gcaae :=_geeae .shadingModel ();_gcaae .PdfShading .Background =_ag .MakeArrayFromFloats ([]float64 {_gfcb ,_dggf ,_adcef });
_ddge :=_db .NewPdfShadingPatternType3 ();_ddge .Shading =_gcaae ;return _ddge ;};

// SetStyleLeft sets border style for left side.
func (_aec *border )SetStyleLeft (style CellBorderStyle ){_aec ._ccc =style };

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _eefgb (svgStr )};

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_ffcf *Image )SetFitMode (fitMode FitMode ){_ffcf ._gaeef =fitMode };

// TitleStyle returns the style properties used to render the invoice title.
func (_agb *Invoice )TitleStyle ()TextStyle {return _agb ._gbda };

// Insert adds a new text chunk at the specified position in the paragraph.
func (_beeaa *StyledParagraph )Insert (index uint ,text string )*TextChunk {_ggaa :=uint (len (_beeaa ._cdegd ));if index > _ggaa {index =_ggaa ;};_bbcg :=NewTextChunk (text ,_beeaa ._abfe );_beeaa ._cdegd =append (_beeaa ._cdegd [:index ],append ([]*TextChunk {_bbcg },_beeaa ._cdegd [index :]...)...);
_beeaa .wrapText ();return _bbcg ;};

// SetFillOpacity sets the fill opacity.
func (_dcge *PolyBezierCurve )SetFillOpacity (opacity float64 ){_dcge ._bfde =opacity };

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_afegf *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_aadc []*Block ;_debc =NewBlock (ctx .PageWidth ,ctx .PageHeight );_eadgd =ctx ;_cdccb ,_abce =_afegf ._bbae ,ctx .PageHeight -_afegf ._effb ;_gdee ,_bcgb =_afegf ._aafcb ,ctx .PageHeight -_afegf ._affa ;
);_dedaa :=_afegf ._fdgb .IsRelative ();if _dedaa {ctx .X +=_afegf ._gabgd .Left ;ctx .Y +=_afegf ._gabgd .Top ;ctx .Width -=_afegf ._gabgd .Left +_afegf ._gabgd .Right ;ctx .Height -=_afegf ._gabgd .Top +_afegf ._gabgd .Bottom ;_cdccb ,_abce ,_gdee ,_bcgb =_afegf .computeCoords (ctx );
if _afegf .Height ()> ctx .Height {_aadc =append (_aadc ,_debc );_debc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_fffe :=ctx ;_fffe .Y =ctx .Margins .Top +_afegf ._gabgd .Top ;_fffe .X =ctx .Margins .Left +_afegf ._gabgd .Left ;_fffe .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_afegf ._gabgd .Top -_afegf ._gabgd .Bottom ;
_fffe .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_afegf ._gabgd .Left -_afegf ._gabgd .Right ;ctx =_fffe ;_cdccb ,_abce ,_gdee ,_bcgb =_afegf .computeCoords (ctx );};};_eaeb :=_fg .BasicLine {X1 :_cdccb ,Y1 :_abce ,X2 :_gdee ,Y2 :_bcgb ,LineColor :_afb (_afegf ._ccg ),Opacity :_afegf ._edbfcd ,LineWidth :_afegf ._dgfab ,LineStyle :_afegf ._daaf ,DashArray :_afegf ._ggdb ,DashPhase :_afegf ._defa };
_ffbe ,_aefg :=_debc .setOpacity (1.0,_afegf ._edbfcd );if _aefg !=nil {return nil ,ctx ,_aefg ;};_fbgfe ,_ ,_aefg :=_eaeb .Draw (_ffbe );if _aefg !=nil {return nil ,ctx ,_aefg ;};if _aefg =_debc .addContentsByString (string (_fbgfe ));_aefg !=nil {return nil ,ctx ,_aefg ;
};if _dedaa {ctx .X =_eadgd .X ;ctx .Width =_eadgd .Width ;_fgaf :=_afegf .Height ();ctx .Y +=_fgaf +_afegf ._gabgd .Bottom ;ctx .Height -=_fgaf ;}else {ctx =_eadgd ;};_aadc =append (_aadc ,_debc );return _aadc ,ctx ,nil ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_fgedc string ;_ggff *Image ;_ebcgc *InvoiceAddress ;_afa *InvoiceAddress ;_gaed string ;_bebe [2]*InvoiceCell ;_cecd [2]*InvoiceCell ;_bggcf [2]*InvoiceCell ;_cgbg [][2]*InvoiceCell ;_cbfcg []*InvoiceCell ;_ddfgc [][]*InvoiceCell ;
_afcd [2]*InvoiceCell ;_decf [2]*InvoiceCell ;_fgeb [][2]*InvoiceCell ;_dggc [2]string ;_bggce [2]string ;_eadcb [][2]string ;_cafa TextStyle ;_gbff TextStyle ;_gbda TextStyle ;_gegfg TextStyle ;_ggfb TextStyle ;_fbfdc TextStyle ;_geacd TextStyle ;_edafd InvoiceCellProps ;
_bggd InvoiceCellProps ;_ecacb InvoiceCellProps ;_dafd InvoiceCellProps ;_bgfb Positioning ;};func (_fdb *Creator )initContext (){_fdb ._edg .X =_fdb ._bbgd .Left ;_fdb ._edg .Y =_fdb ._bbgd .Top ;_fdb ._edg .Width =_fdb ._gcac -_fdb ._bbgd .Right -_fdb ._bbgd .Left ;
_fdb ._edg .Height =_fdb ._cfaf -_fdb ._bbgd .Bottom -_fdb ._bbgd .Top ;_fdb ._edg .PageHeight =_fdb ._cfaf ;_fdb ._edg .PageWidth =_fdb ._gcac ;_fdb ._edg .Margins =_fdb ._bbgd ;_fdb ._edg ._dfe =_fdb .UnsupportedCharacterReplacement ;};

// FitMode returns the fit mode of the line.
func (_aada *Line )FitMode ()FitMode {return _aada ._dbged };

// Margins returns the margins of the component.
func (_dcaa *Division )Margins ()(_cccd ,_bfce ,_bfbg ,_gccfd float64 ){return _dcaa ._caeg .Left ,_dcaa ._caeg .Right ,_dcaa ._caeg .Top ,_dcaa ._caeg .Bottom ;};func (_dedg *Invoice )generateTotalBlocks (_cbcfb DrawContext )([]*Block ,DrawContext ,error ){_bgagd :=_eedb (4);
_bgagd .SetMargins (0,0,10,10);_addfa :=[][2]*InvoiceCell {_dedg ._afcd };_addfa =append (_addfa ,_dedg ._fgeb ...);_addfa =append (_addfa ,_dedg ._decf );for _ ,_bcga :=range _addfa {_fggee ,_deef :=_bcga [0],_bcga [1];if _deef .Value ==""{continue ;};
_bgagd .SkipCells (2);_abefda :=_bgagd .NewCell ();_abefda .SetBackgroundColor (_fggee .BackgroundColor );_abefda .SetHorizontalAlignment (_deef .Alignment );_dedg .setCellBorder (_abefda ,_fggee );_cbagb :=_gfbe (_fggee .TextStyle );_cbagb .SetMargins (0,0,2,1);
_cbagb .Append (_fggee .Value );_abefda .SetContent (_cbagb );_abefda =_bgagd .NewCell ();_abefda .SetBackgroundColor (_deef .BackgroundColor );_abefda .SetHorizontalAlignment (_deef .Alignment );_dedg .setCellBorder (_abefda ,_fggee );_cbagb =_gfbe (_deef .TextStyle );
_cbagb .SetMargins (0,0,2,1);_cbagb .Append (_deef .Value );_abefda .SetContent (_cbagb );};return _bgagd .GeneratePageBlocks (_cbcfb );};func _egdd (_bbafd ,_dfcfd ,_gdbed float64 )(_bbafb ,_cgbde ,_aaff ,_cddbf float64 ){if _gdbed ==0{return 0,0,_bbafd ,_dfcfd ;
};_ccag :=_fg .Path {Points :[]_fg .Point {_fg .NewPoint (0,0).Rotate (_gdbed ),_fg .NewPoint (_bbafd ,0).Rotate (_gdbed ),_fg .NewPoint (0,_dfcfd ).Rotate (_gdbed ),_fg .NewPoint (_bbafd ,_dfcfd ).Rotate (_gdbed )}}.GetBoundingBox ();return _ccag .X ,_ccag .Y ,_ccag .Width ,_ccag .Height ;
};func (_dfff *pageTransformations )applyFlip (_efb *_db .PdfPage )error {_gccc ,_dbbd :=_dfff ._fcga ,_dfff ._fgcdc ;if !_gccc &&!_dbbd {return nil ;};if _efb ==nil {return _ab .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");
};_bfdc ,_cfgf :=_efb .GetMediaBox ();if _cfgf !=nil {return _cfgf ;};_bde ,_eeae :=_bfdc .Width (),_bfdc .Height ();_bbgdb ,_cfgf :=_efb .GetRotate ();if _cfgf !=nil {_d .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_cfgf .Error ());
};if _cbdf :=_bbgdb %360!=0&&_bbgdb %90==0;_cbdf {if _daeg :=(360+_bbgdb %360)%360;_daeg ==90||_daeg ==270{_gccc ,_dbbd =_dbbd ,_gccc ;};};_fbdb ,_ccfa :=1.0,0.0;if _gccc {_fbdb ,_ccfa =-1.0,-_bde ;};_gbge ,_cbecb :=1.0,0.0;if _dbbd {_gbge ,_cbecb =-1.0,-_eeae ;
};_bggbe :=_cf .NewContentCreator ().Scale (_fbdb ,_gbge ).Translate (_ccfa ,_cbecb );_afeg ,_cfgf :=_ag .MakeStream (_bggbe .Bytes (),_ag .NewFlateEncoder ());if _cfgf !=nil {return _cfgf ;};_baed :=_ag .MakeArray (_afeg );_baed .Append (_efb .GetContentStreamObjs ()...);
_efb .Contents =_baed ;return nil ;};

// SetWidthRight sets border width for right.
func (_bfc *border )SetWidthRight (bw float64 ){_bfc ._cgcg =bw };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_bcag *Creator )NewPolyBezierCurve (curves []_fg .CubicBezierCurve )*PolyBezierCurve {return _bfggd (curves );};func _eedb (_fegc int )*Table {_cafg :=&Table {_cccbd :_fegc ,_gbccbb :10.0,_cfab :[]float64 {},_bebec :[]float64 {},_dgde :[]*TableCell {},_dedgb :make ([]int ,_fegc ),_ceef :true };
_cafg .resetColumnWidths ();return _cafg ;};

// Lines returns all the rows of the invoice line items table.
func (_ceaa *Invoice )Lines ()[][]*InvoiceCell {return _ceaa ._ddfgc };

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_gdcc *shading ;_ggge *_db .PdfRectangle ;_afga float64 ;};

// GetIndent get the cell's left indent.
func (_cgafb *TableCell )GetIndent ()float64 {return _cgafb ._dedb };func (_deegf *Table )getLastCellFromCol (_cecgg int )(int ,*TableCell ){for _gbdgf :=len (_deegf ._dgde )-1;_gbdgf >=0;_gbdgf --{if _deegf ._dgde [_gbdgf ]._bcea ==_cecgg {return _gbdgf ,_deegf ._dgde [_gbdgf ];
};};return 0,nil ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_cdegd []*TextChunk ;_abfe TextStyle ;_abba TextStyle ;_efdff TextAlignment ;_gabbd TextVerticalAlignment ;_gfae float64 ;_bbff bool ;_baaga float64 ;_aegab bool ;_dgcd bool ;_ddade TextOverflow ;_bgbbb float64 ;_acfa Margins ;
_fadf Positioning ;_afceb float64 ;_dadc float64 ;_bdfga float64 ;_gcbd float64 ;_ebgc [][]*TextChunk ;_cabgb func (_baac *StyledParagraph ,_caeed DrawContext );};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_aeeec *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};func (_dbadb *TableCell )height (_egff float64 )float64 {var _aage float64 ;switch _ddca :=_dbadb ._aabd .(type ){case *Paragraph :if _ddca ._aacg {_ddca .SetWidth (_egff -_dbadb ._dedb -_ddca ._fdda .Left -_ddca ._fdda .Right );
};_aage =_ddca .Height ()+_ddca ._fdda .Top +_ddca ._fdda .Bottom ;if !_dbadb ._bfdgf ._cfed {_aage +=(0.5*_ddca ._bbgda *_ddca ._becfe );};case *StyledParagraph :if _ddca ._bbff {_ddca .SetWidth (_egff -_dbadb ._dedb -_ddca ._acfa .Left -_ddca ._acfa .Right );
};_aage =_ddca .Height ()+_ddca ._acfa .Top +_ddca ._acfa .Bottom ;if !_dbadb ._bfdgf ._cfed {_aage +=(0.5*_ddca .getTextHeight ());};case *Image :_ddca .applyFitMode (_egff -_dbadb ._dedb );_aage =_ddca .Height ()+_ddca ._gabc .Top +_ddca ._gabc .Bottom ;
case *Table :_ddca .updateRowHeights (_egff -_dbadb ._dedb -_ddca ._aaec .Left -_ddca ._aaec .Right );_aage =_ddca .Height ()+_ddca ._aaec .Top +_ddca ._aaec .Bottom ;case *List :_aage =_ddca .ctxHeight (_egff -_dbadb ._dedb )+_ddca ._ebdfg .Top +_ddca ._ebdfg .Bottom ;
case *Division :_aage =_ddca .ctxHeight (_egff -_dbadb ._dedb )+_ddca ._caeg .Top +_ddca ._caeg .Bottom +_ddca ._cedd .Top +_ddca ._cedd .Bottom ;case *Chart :_aage =_ddca .Height ()+_ddca ._ffa .Top +_ddca ._ffa .Bottom ;case *Rectangle :_ddca .applyFitMode (_egff -_dbadb ._dedb );
_aage =_ddca .Height ()+_ddca ._cbagd .Top +_ddca ._cbagd .Bottom +_ddca ._ccde ;case *Ellipse :_ddca .applyFitMode (_egff -_dbadb ._dedb );_aage =_ddca .Height ()+_ddca ._fbcgf .Top +_ddca ._fbcgf .Bottom ;case *Line :_aage =_ddca .Height ()+_ddca ._gabgd .Top +_ddca ._gabgd .Bottom ;
};return _aage ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_gad *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gad ._ffa .Left ,_gad ._ffa .Right ,_gad ._ffa .Top ,_gad ._ffa .Bottom ;};func _fdeag (_ecedb *templateProcessor ,_aggeg *templateNode )(interface{},error ){return _ecedb .parseListMarker (_aggeg );
};func _bcgbd (_ceeef string )([]string ,error ){var (_abded []string ;_bafaf []rune ;);for _ ,_ggaf :=range _ceeef {if _ggaf =='\u000A'{if len (_bafaf )> 0{_abded =append (_abded ,string (_bafaf ));};_abded =append (_abded ,string (_ggaf ));_bafaf =nil ;
continue ;};_bafaf =append (_bafaf ,_ggaf );};if len (_bafaf )> 0{_abded =append (_abded ,string (_bafaf ));};var _bdae []string ;for _ ,_deecd :=range _abded {_dcaab :=[]rune (_deecd );_cagde :=_be .NewScanner (_dcaab );var _agabf []rune ;for _afdcc :=0;
_afdcc < len (_dcaab );_afdcc ++{_ ,_ebggg ,_afgaed :=_cagde .Next ();if _afgaed !=nil {return nil ,_afgaed ;};if _ebggg ==_be .BreakProhibited ||_ff .IsSpace (_dcaab [_afdcc ]){_agabf =append (_agabf ,_dcaab [_afdcc ]);if _ff .IsSpace (_dcaab [_afdcc ]){_bdae =append (_bdae ,string (_agabf ));
_agabf =[]rune {};};continue ;}else {if len (_agabf )> 0{_bdae =append (_bdae ,string (_agabf ));};_agabf =[]rune {_dcaab [_afdcc ]};};};if len (_agabf )> 0{_bdae =append (_bdae ,string (_agabf ));};};return _bdae ,nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cdcb *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fabbb :=ctx ;_cdbgb ,ctx ,_gabfa :=_cdcb ._ffcgc .GeneratePageBlocks (ctx );if _gabfa !=nil {return _cdbgb ,ctx ,_gabfa ;};if _cdcb ._efff .IsRelative (){ctx .X =_fabbb .X ;
};if _cdcb ._efff .IsAbsolute (){return _cdbgb ,_fabbb ,nil ;};return _cdbgb ,ctx ,nil ;};func (_eaaad *templateProcessor )parseTableCell (_dagab *templateNode )(interface{},error ){if _dagab ._abgfd ==nil {_eaaad .nodeLogError (_dagab ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_cdfg ;};_cbfce ,_gacc :=_dagab ._abgfd ._dfbaa .(*Table );if !_gacc {_eaaad .nodeLogError (_dagab ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_dagab ._abgfd ._dfbaa );
return nil ,_cdfg ;};var _baabc ,_bgfbc int64 ;for _ ,_cggag :=range _dagab ._fabca .Attr {_accd :=_cggag .Value ;switch _gdbfcf :=_cggag .Name .Local ;_gdbfcf {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_baabc =_eaaad .parseInt64Attr (_gdbfcf ,_accd );
case "\u0072o\u0077\u0073\u0070\u0061\u006e":_bgfbc =_eaaad .parseInt64Attr (_gdbfcf ,_accd );};};if _baabc <=0{_baabc =1;};if _bgfbc <=0{_bgfbc =1;};_edff :=_cbfce .MultiCell (int (_bgfbc ),int (_baabc ));for _ ,_cbgce :=range _dagab ._fabca .Attr {_ccac :=_cbgce .Value ;
switch _aabgc :=_cbgce .Name .Local ;_aabgc {case "\u0069\u006e\u0064\u0065\u006e\u0074":_edff .SetIndent (_eaaad .parseFloatAttr (_aabgc ,_ccac ));case "\u0061\u006c\u0069g\u006e":_edff .SetHorizontalAlignment (_eaaad .parseCellAlignmentAttr (_aabgc ,_ccac ));
case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_edff .SetVerticalAlignment (_eaaad .parseCellVerticalAlignmentAttr (_aabgc ,_ccac ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_edff .SetSideBorderStyle (CellBorderSideAll ,_eaaad .parseCellBorderStyleAttr (_aabgc ,_ccac ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_edff .SetSideBorderStyle (CellBorderSideTop ,_eaaad .parseCellBorderStyleAttr (_aabgc ,_ccac ));case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_edff .SetSideBorderStyle (CellBorderSideBottom ,_eaaad .parseCellBorderStyleAttr (_aabgc ,_ccac ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_edff .SetSideBorderStyle (CellBorderSideLeft ,_eaaad .parseCellBorderStyleAttr (_aabgc ,_ccac ));case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_edff .SetSideBorderStyle (CellBorderSideRight ,_eaaad .parseCellBorderStyleAttr (_aabgc ,_ccac ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_edff .SetSideBorderWidth (CellBorderSideAll ,_eaaad .parseFloatAttr (_aabgc ,_ccac ));case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_edff .SetSideBorderWidth (CellBorderSideTop ,_eaaad .parseFloatAttr (_aabgc ,_ccac ));
case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_edff .SetSideBorderWidth (CellBorderSideBottom ,_eaaad .parseFloatAttr (_aabgc ,_ccac ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_edff .SetSideBorderWidth (CellBorderSideLeft ,_eaaad .parseFloatAttr (_aabgc ,_ccac ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_edff .SetSideBorderWidth (CellBorderSideRight ,_eaaad .parseFloatAttr (_aabgc ,_ccac ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_edff .SetSideBorderColor (CellBorderSideAll ,_eaaad .parseColorAttr (_aabgc ,_ccac ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_edff .SetSideBorderColor (CellBorderSideTop ,_eaaad .parseColorAttr (_aabgc ,_ccac ));case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_edff .SetSideBorderColor (CellBorderSideBottom ,_eaaad .parseColorAttr (_aabgc ,_ccac ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_edff .SetSideBorderColor (CellBorderSideLeft ,_eaaad .parseColorAttr (_aabgc ,_ccac ));case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_edff .SetSideBorderColor (CellBorderSideRight ,_eaaad .parseColorAttr (_aabgc ,_ccac ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_edff .SetBorderLineStyle (_eaaad .parseLineStyleAttr (_aabgc ,_ccac ));case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_edff .SetBackgroundColor (_eaaad .parseColorAttr (_aabgc ,_ccac ));
case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;default:_eaaad .nodeLogDebug (_dagab ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_aabgc );
};};return _edff ,nil ;};func (_ebfgc *templateProcessor )parseStyledParagraph (_egfcg *templateNode )(interface{},error ){_dfbbc :=_ebfgc .creator .NewStyledParagraph ();for _ ,_fcggee :=range _egfcg ._fabca .Attr {_ecec :=_fcggee .Value ;switch _fdccb :=_fcggee .Name .Local ;
_fdccb {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_dfbbc .SetTextAlignment (_ebfgc .parseTextAlignmentAttr (_fdccb ,_ecec ));case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_dfbbc .SetTextVerticalAlignment (_ebfgc .parseTextVerticalAlignmentAttr (_fdccb ,_ecec ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_dfbbc .SetLineHeight (_ebfgc .parseFloatAttr (_fdccb ,_ecec ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bfaad :=_ebfgc .parseMarginAttr (_fdccb ,_ecec );_dfbbc .SetMargins (_bfaad .Left ,_bfaad .Right ,_bfaad .Top ,_bfaad .Bottom );
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_dfbbc .SetEnableWrap (_ebfgc .parseBoolAttr (_fdccb ,_ecec ));case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_dfbbc .EnableWordWrap (_ebfgc .parseBoolAttr (_fdccb ,_ecec ));
case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_dfbbc .SetTextOverflow (_ebfgc .parseTextOverflowAttr (_fdccb ,_ecec ));case "\u0078":_dfbbc .SetPos (_ebfgc .parseFloatAttr (_fdccb ,_ecec ),_dfbbc ._dadc );case "\u0079":_dfbbc .SetPos (_dfbbc ._afceb ,_ebfgc .parseFloatAttr (_fdccb ,_ecec ));
case "\u0061\u006e\u0067l\u0065":_dfbbc .SetAngle (_ebfgc .parseFloatAttr (_fdccb ,_ecec ));default:_ebfgc .nodeLogDebug (_egfcg ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_fdccb );
};};return _dfbbc ,nil ;};

// Scale scales Image by a constant factor, both width and height.
func (_fgce *Image )Scale (xFactor ,yFactor float64 ){_fgce ._daba =xFactor *_fgce ._daba ;_fgce ._gafb =yFactor *_fgce ._gafb ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_dcdc *TOCLine )SetLink (page int64 ,x ,y float64 ){_dcdc ._dfcfa =x ;_dcdc ._gagdf =y ;_dcdc ._gaecg =page ;_daffd :=_dcdc ._ffcgc ._abba .Color ;_dcdc .Number .Style .Color =_daffd ;_dcdc .Title .Style .Color =_daffd ;_dcdc .Separator .Style .Color =_daffd ;
_dcdc .Page .Style .Color =_daffd ;};type componentRenderer interface{Draw (_gdggf Drawable )error ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_gae *Block )AddAnnotation (annotation *_db .PdfAnnotation ){for _ ,_dfc :=range _gae ._gc {if _dfc ==annotation {return ;};};_gae ._gc =append (_gae ._gc ,annotation );};func (_adc cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_dgd :=_adc ._cec ;
return 1-(_adc ._afc *(1-_dgd )+_dgd ),1-(_adc ._dff *(1-_dgd )+_dgd ),1-(_adc ._edea *(1-_dgd )+_dgd );};

// SetHeight sets the height of the ellipse.
func (_feeb *Ellipse )SetHeight (height float64 ){_feeb ._faea =height };

// LevelOffset returns the amount of space an indentation level occupies.
func (_cfbg *TOCLine )LevelOffset ()float64 {return _cfbg ._dgcg };

// SetSubtotal sets the subtotal of the invoice.
func (_fgdb *Invoice )SetSubtotal (value string ){_fgdb ._afcd [1].Value =value };func (_ccfc *templateProcessor )parseCellBorderStyleAttr (_geab ,_daaff string )CellBorderStyle {_d .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_geab ,_daaff );
_bggbfg :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_daaff ];return _bggbfg ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_bbdc *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _bbdc ._agda ==nil {if _dbbe :=_bbdc .makeXObject ();_dbbe !=nil {return nil ,ctx ,_dbbe ;};};var _cdcf []*Block ;_aced :=ctx ;_bfdg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _bbdc ._dfgd .IsRelative (){_bbdc .applyFitMode (ctx .Width );ctx .X +=_bbdc ._gabc .Left ;ctx .Y +=_bbdc ._gabc .Top ;ctx .Width -=_bbdc ._gabc .Left +_bbdc ._gabc .Right ;ctx .Height -=_bbdc ._gabc .Top +_bbdc ._gabc .Bottom ;if _bbdc ._gafb > ctx .Height {_cdcf =append (_cdcf ,_bfdg );
_bfdg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ebcga :=ctx ;_ebcga .Y =ctx .Margins .Top +_bbdc ._gabc .Top ;_ebcga .X =ctx .Margins .Left +_bbdc ._gabc .Left ;_ebcga .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_bbdc ._gabc .Top -_bbdc ._gabc .Bottom ;
_ebcga .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_bbdc ._gabc .Left -_bbdc ._gabc .Right ;ctx =_ebcga ;};}else {ctx .X =_bbdc ._aeed ;ctx .Y =_bbdc ._eede ;};ctx ,_acca :=_cfcd (_bfdg ,_bbdc ,ctx );if _acca !=nil {return nil ,ctx ,_acca ;
};_cdcf =append (_cdcf ,_bfdg );if _bbdc ._dfgd .IsAbsolute (){ctx =_aced ;}else {ctx .X =_aced .X ;ctx .Width =_aced .Width ;ctx .Y +=_bbdc ._gabc .Bottom ;};return _cdcf ,ctx ,nil ;};

// Append adds a new text chunk to the paragraph.
func (_afaa *StyledParagraph )Append (text string )*TextChunk {_aagag :=NewTextChunk (text ,_afaa ._abfe );return _afaa .appendChunk (_aagag );};

// Crop crops the Image to the specified bounds.
func (_ebga *Image )Crop (x0 ,y0 ,x1 ,y1 int ){_dacdg ,_agag :=_ebga ._efbg .ToGoImage ();if _agag !=nil {_a .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0074o\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_agag );
};var _aceg _ea .Image ;_gbf :=_ea .Rect (x0 ,y0 ,x1 ,y1 );if _gadd :=_gbf .Intersect (_dacdg .Bounds ());!_gbf .Empty (){_dbbg :=_ea .NewRGBA (_ea .Rect (0,0,_gbf .Dx (),_gbf .Dy ()));for _abeg :=_gadd .Min .Y ;_abeg < _gadd .Max .Y ;_abeg ++{for _cbdg :=_gadd .Min .X ;
_cbdg < _gadd .Max .X ;_cbdg ++{_dbbg .Set (_cbdg -_gadd .Min .X ,_abeg -_gadd .Min .Y ,_dacdg .At (_cbdg ,_abeg ));};};_aceg =_dbbg ;}else {_aceg =&_ea .RGBA {};};_efaa ,_agag :=_db .ImageHandling .NewImageFromGoImage (_aceg );if _agag !=nil {_a .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0066\u0072\u006fm\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_agag );
};_bbdb :=float64 (_efaa .Width );_gbbdb :=float64 (_efaa .Height );_ebga ._efbg =_efaa ;_ebga ._aag =_bbdb ;_ebga ._dcab =_gbbdb ;_ebga ._daba =_bbdb ;_ebga ._gafb =_gbbdb ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_bgcf *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_ceed :=[2]*InvoiceCell {_bgcf .newCell (description ,_bgcf ._edafd ),_bgcf .newCell (value ,_bgcf ._edafd )};_bgcf ._cgbg =append (_bgcf ._cgbg ,_ceed );return _ceed [0],_ceed [1];
};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _aaf ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_dedd :=&Creator {};_dedd ._caa =[]*_db .PdfPage {};_dedd ._cdcc =map[*_db .PdfPage ]*Block {};_dedd ._fcgg =map[*_db .PdfPage ]*pageTransformations {};_dedd .SetPageSize (PageSizeLetter );
_fggd :=0.1*_dedd ._gcac ;_dedd ._bbgd .Left =_fggd ;_dedd ._bbgd .Right =_fggd ;_dedd ._bbgd .Top =_fggd ;_dedd ._bbgd .Bottom =_fggd ;var _cdb error ;_dedd ._gef ,_cdb =_db .NewStandard14Font (_db .HelveticaName );if _cdb !=nil {_dedd ._gef =_db .DefaultFont ();
};_dedd ._cggc ,_cdb =_db .NewStandard14Font (_db .HelveticaBoldName );if _cdb !=nil {_dedd ._gef =_db .DefaultFont ();};_dedd ._gcad =_dedd .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_dedd .AddOutlines =true ;
_dedd ._gbcf =_db .NewOutline ();_ca .TrackUse (_aaf );return _dedd ;};func (_bebcc *templateProcessor )parseLine (_bccbg *templateNode )(interface{},error ){_bacaf :=_bebcc .creator .NewLine (0,0,0,0);for _ ,_eaec :=range _bccbg ._fabca .Attr {_gdfe :=_eaec .Value ;
switch _dafa :=_eaec .Name .Local ;_dafa {case "\u0078\u0031":_bacaf ._bbae =_bebcc .parseFloatAttr (_dafa ,_gdfe );case "\u0079\u0031":_bacaf ._effb =_bebcc .parseFloatAttr (_dafa ,_gdfe );case "\u0078\u0032":_bacaf ._aafcb =_bebcc .parseFloatAttr (_dafa ,_gdfe );
case "\u0079\u0032":_bacaf ._affa =_bebcc .parseFloatAttr (_dafa ,_gdfe );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_bacaf .SetLineWidth (_bebcc .parseFloatAttr (_dafa ,_gdfe ));case "\u0063\u006f\u006co\u0072":_bacaf .SetColor (_bebcc .parseColorAttr (_dafa ,_gdfe ));
case "\u0073\u0074\u0079l\u0065":_bacaf .SetStyle (_bebcc .parseLineStyleAttr (_dafa ,_gdfe ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_bacaf .SetDashPattern (_bebcc .parseInt64Array (_dafa ,_gdfe ),_bacaf ._defa );case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_bacaf .SetDashPattern (_bacaf ._ggdb ,_bebcc .parseInt64Attr (_dafa ,_gdfe ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_bacaf .SetOpacity (_bebcc .parseFloatAttr (_dafa ,_gdfe ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_bacaf .SetPositioning (_bebcc .parsePositioningAttr (_dafa ,_gdfe ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_bacaf .SetFitMode (_bebcc .parseFitModeAttr (_dafa ,_gdfe ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_gdggff :=_bebcc .parseMarginAttr (_dafa ,_gdfe );_bacaf .SetMargins (_gdggff .Left ,_gdggff .Right ,_gdggff .Top ,_gdggff .Bottom );default:_bebcc .nodeLogDebug (_bccbg ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dafa );
};};return _bacaf ,nil ;};

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_feebb *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _feebb ._cbagd .Left ,_feebb ._cbagd .Right ,_feebb ._cbagd .Top ,_feebb ._cbagd .Bottom ;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_defeg *_fg .Polyline ;_gfdd float64 ;};

// Inline returns whether the inline mode of the division is active.
func (_fagg *Division )Inline ()bool {return _fagg ._eaad };

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_cbbd *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_cbbd ._cbagd .Left =left ;_cbbd ._cbagd .Right =right ;_cbbd ._cbagd .Top =top ;_cbbd ._cbagd .Bottom =bottom ;};

// FillColor returns the fill color of the ellipse.
func (_fdff *Ellipse )FillColor ()Color {return _fdff ._bbad };func (_geff *Table )wrapRow (_gega int ,_cgbeac DrawContext ,_dggb float64 )(bool ,error ){if !_geff ._dcag {return false ,nil ;};var (_eecg =_geff ._dgde [_gega ];_ceefa =-1;_bgeag []*TableCell ;
_bbcc float64 ;_bcagd bool ;_ccec =make ([]float64 ,0,len (_geff ._cfab )););_acegd :=func (_cgffc *TableCell ,_fgaag VectorDrawable ,_agcb bool )*TableCell {_faed :=*_cgffc ;_faed ._aabd =_fgaag ;if _agcb {_faed ._adfd ++;};return &_faed ;};_bgef :=func (_ffage int ,_cgcd VectorDrawable ){var _aafbc float64 =-1;
if _cgcd ==nil {if _bfgc :=_ccec [_ffage -_gega ];_bfgc > _cgbeac .Height {_cgcd =_geff ._dgde [_ffage ]._aabd ;_geff ._dgde [_ffage ]._aabd =nil ;_ccec [_ffage -_gega ]=0;_aafbc =_bfgc ;};};_cdgd :=_acegd (_geff ._dgde [_ffage ],_cgcd ,true );_bgeag =append (_bgeag ,_cdgd );
if _aafbc < 0{_aafbc =_cdgd .height (_cgbeac .Width );};if _aafbc > _bbcc {_bbcc =_aafbc ;};};for _ceefe :=_gega ;_ceefe < len (_geff ._dgde );_ceefe ++{_dbabda :=_geff ._dgde [_ceefe ];if _eecg ._adfd !=_dbabda ._adfd {_ceefa =_ceefe ;break ;};_cgbeac .Width =_dbabda .width (_geff ._cfab ,_dggb );
_gfge :=_dbabda .height (_cgbeac .Width );var _dbbea VectorDrawable ;switch _gefff :=_dbabda ._aabd .(type ){case *StyledParagraph :if _gfge > _cgbeac .Height {_baeag :=_cgbeac ;_baeag .Height =_gb .Floor (_cgbeac .Height -_gefff ._acfa .Top -_gefff ._acfa .Bottom -0.5*_gefff .getTextHeight ());
_cbecd ,_gfff ,_agaf :=_gefff .split (_baeag );if _agaf !=nil {return false ,_agaf ;};if _cbecd !=nil &&_gfff !=nil {_gefff =_cbecd ;_dbabda =_acegd (_dbabda ,_cbecd ,false );_geff ._dgde [_ceefe ]=_dbabda ;_dbbea =_gfff ;_bcagd =true ;};_gfge =_dbabda .height (_cgbeac .Width );
};case *Division :if _gfge > _cgbeac .Height {_fgdc :=_cgbeac ;_fgdc .Height =_gb .Floor (_cgbeac .Height -_gefff ._caeg .Top -_gefff ._caeg .Bottom );_eba ,_ecdeac :=_gefff .split (_fgdc );if _eba !=nil &&_ecdeac !=nil {_gefff =_eba ;_dbabda =_acegd (_dbabda ,_eba ,false );
_geff ._dgde [_ceefe ]=_dbabda ;_dbbea =_ecdeac ;_bcagd =true ;if _eba ._cgeg !=nil {_eba ._cgeg .BorderRadiusBottomLeft =0;_eba ._cgeg .BorderRadiusBottomRight =0;};if _ecdeac ._cgeg !=nil {_ecdeac ._cgeg .BorderRadiusTopLeft =0;_ecdeac ._cgeg .BorderRadiusTopRight =0;
};_gfge =_dbabda .height (_cgbeac .Width );};};case *List :if _gfge > _cgbeac .Height {_fdebg :=_cgbeac ;_fdebg .Height =_gb .Floor (_cgbeac .Height -_gefff ._ebdfg .Vertical ());_gcbfd ,_dgcc :=_gefff .split (_fdebg );if _gcbfd !=nil {_gefff =_gcbfd ;
_dbabda =_acegd (_dbabda ,_gcbfd ,false );_geff ._dgde [_ceefe ]=_dbabda ;};if _dgcc !=nil {_dbbea =_dgcc ;_bcagd =true ;};_gfge =_dbabda .height (_cgbeac .Width );};};_ccec =append (_ccec ,_gfge );if _bcagd {if _bgeag ==nil {_bgeag =make ([]*TableCell ,0,len (_geff ._cfab ));
for _ggfe :=_gega ;_ggfe < _ceefe ;_ggfe ++{_bgef (_ggfe ,nil );};};_bgef (_ceefe ,_dbbea );};};var _baace float64 ;for _ ,_afcc :=range _ccec {if _afcc > _baace {_baace =_afcc ;};};if _bcagd &&_baace < _cgbeac .Height {if _ceefa < 0{_ceefa =len (_geff ._dgde );
};_fbdaf :=_geff ._dgde [_ceefa -1]._adfd +_geff ._dgde [_ceefa -1]._fbeb -1;for _dffcb :=_ceefa ;_dffcb < len (_geff ._dgde );_dffcb ++{_geff ._dgde [_dffcb ]._adfd ++;};_geff ._dgde =append (_geff ._dgde [:_ceefa ],append (_bgeag ,_geff ._dgde [_ceefa :]...)...);
_geff ._bebec =append (_geff ._bebec [:_fbdaf ],append ([]float64 {_bbcc },_geff ._bebec [_fbdaf :]...)...);_geff ._bebec [_eecg ._adfd +_eecg ._fbeb -2]=_baace ;};return _bcagd ,nil ;};

// GeneratePageBlocks generates a page break block.
func (_egb *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eeebc :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_aeabd :=ctx ;_aeabd .Y =ctx .Margins .Top ;
_aeabd .X =ctx .Margins .Left ;_aeabd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_aeabd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_aeabd ;return _eeebc ,ctx ,nil ;};func _agdd ()*listItem {return &listItem {}};
type border struct{_ebfg float64 ;_fca float64 ;_dec float64 ;_gcec float64 ;_eade Color ;_ecd Color ;_dabb float64 ;_fff Color ;_dcdg float64 ;_ccba Color ;_cgcg float64 ;_gcb Color ;_fged float64 ;LineStyle _fg .LineStyle ;_ccc CellBorderStyle ;_bec CellBorderStyle ;
_fbf CellBorderStyle ;_egdc CellBorderStyle ;};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_bacg *List )Marker ()*TextChunk {return &_bacg ._gccff };

// SetBackgroundColor sets the cell's background color.
func (_eefc *TableCell )SetBackgroundColor (col Color ){_eefc ._gdgb =col };

// FillColor returns the fill color of the rectangle.
func (_ceggc *Rectangle )FillColor ()Color {return _ceggc ._debe };func (_cfgg *Table )moveToNextAvailableCell ()int {_aefac :=(_cfgg ._cecaf -1)%(_cfgg ._cccbd )+1;for {if _aefac -1>=len (_cfgg ._dedgb ){if _cfgg ._dedgb [0]==0{return _aefac ;};_aefac =1;
}else if _cfgg ._dedgb [_aefac -1]==0{return _aefac ;};_cfgg ._cecaf ++;_cfgg ._dedgb [_aefac -1]--;_aefac ++;};};

// SetFont sets the Paragraph's font.
func (_efabc *Paragraph )SetFont (font *_db .PdfFont ){_efabc ._bccd =font };

// SetBorderRadius sets the radius of the rectangle corners.
func (_gcecc *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_gcecc ._cdbc =topLeft ;_gcecc ._eaebb =topRight ;_gcecc ._fgfgg =bottomLeft ;_gcecc ._cdege =bottomRight ;};func (_bgeacd *templateProcessor )parseListMarker (_ebfed *templateNode )(interface{},error ){if _ebfed ._abgfd ==nil {_bgeacd .nodeLogError (_ebfed ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_cdfg ;};var _bafe *TextChunk ;switch _decfaa :=_ebfed ._abgfd ._dfbaa .(type ){case *List :_bafe =&_decfaa ._gccff ;case *listItem :_bafe =&_decfaa ._bdaa ;default:_bgeacd .nodeLogError (_ebfed ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_decfaa );
return nil ,_cdfg ;};if _ ,_faegc :=_bgeacd .parseTextChunk (_ebfed ,_bafe );_faegc !=nil {_bgeacd .nodeLogError (_ebfed ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_faegc );
return nil ,nil ;};return _bafe ,nil ;};func _eefgb (_dcf string )(*GraphicSVG ,error ){_bbdf ,_faff :=_bgc .ParseFromString (_dcf );if _faff !=nil {return nil ,_faff ;};return _bfbbc (_bbdf );};

// SetMargins sets the Paragraph's margins.
func (_egfa *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_egfa ._acfa .Left =left ;_egfa ._acfa .Right =right ;_egfa ._acfa .Top =top ;_egfa ._acfa .Bottom =bottom ;};

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_eedg *Rectangle )ScaleToWidth (w float64 ){_cada :=_eedg ._begbb /_eedg ._bccac ;_eedg ._bccac =w ;_eedg ._begbb =w *_cada ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SetDate sets the date of the invoice.
func (_gccfb *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_gccfb ._cecd [1].Value =date ;return _gccfb ._cecd [0],_gccfb ._cecd [1];};

// SetHeight sets the height of the rectangle.
func (_cbfb *Rectangle )SetHeight (height float64 ){_cbfb ._begbb =height };

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_ccecd *Table )MultiColCell (colspan int )*TableCell {return _ccecd .MultiCell (1,colspan )};

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_gddd *_bgc .GraphicSVG ;_eccef Positioning ;_dfac float64 ;_bfe float64 ;_dagb Margins ;};var PPI float64 =72;func (_de *Block )translate (_efc ,_gbc float64 ){_cg :=_cf .NewContentCreator ().Translate (_efc ,-_gbc ).Operations ();
*_de ._bag =append (*_cg ,*_de ._bag ...);_de ._bag .WrapIfNeeded ();};

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_adeea *Rectangle )SetCoords (x ,y float64 ){_adeea ._dbgeg =x ;_adeea ._gead =y };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_cdfb *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _gbgeb (number ,title ,page ,level ,style );};

// SetSideBorderColor sets the cell's side border color.
func (_ebfgf *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_ebfgf ._babeg =col ;_ebfgf ._ddac =col ;_ebfgf ._cfge =col ;_ebfgf ._gbbdf =col ;case CellBorderSideTop :_ebfgf ._babeg =col ;case CellBorderSideBottom :_ebfgf ._ddac =col ;
case CellBorderSideLeft :_ebfgf ._cfge =col ;case CellBorderSideRight :_ebfgf ._gbbdf =col ;};};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_bbcf *LinearShading )SetAntiAlias (enable bool ){_bbcf ._gdcc .SetAntiAlias (enable )};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_fgbd *Image )SetMargins (left ,right ,top ,bottom float64 ){_fgbd ._gabc .Left =left ;_fgbd ._gabc .Right =right ;_fgbd ._gabc .Top =top ;_fgbd ._gabc .Bottom =bottom ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_bfgdb *Invoice )Terms ()(string ,string ){return _bfgdb ._bggce [0],_bfgdb ._bggce [1]};

// SetTotal sets the total of the invoice.
func (_gbga *Invoice )SetTotal (value string ){_gbga ._decf [1].Value =value };

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_gdc *Block )DrawTemplate (c *Creator ,r _ba .Reader ,data interface{},options *TemplateOptions )error {return _defac (c ,r ,data ,options ,_gdc );};func (_edbbc *templateProcessor )parseLinearGradientAttr (creator *Creator ,_beefa string )Color {_gfce :=ColorBlack ;
if _beefa ==""{return _gfce ;};_bcbb :=creator .NewLinearGradientColor ([]*ColorPoint {});_bcbb .SetExtends (true ,true );var (_febg =_cc .Split (_beefa [16:len (_beefa )-1],"\u002c");_cgeab =_cc .TrimSpace (_febg [0]););if _cc .HasSuffix (_cgeab ,"\u0064\u0065\u0067"){_ebcf ,_efda :=_eg .ParseFloat (_cgeab [:len (_cgeab )-3],64);
if _efda !=nil {_d .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_efda );}else {_bcbb .SetAngle (_ebcf );
};_febg =_febg [1:];};_fdded ,_ggggf :=_edbbc .processGradientColorPair (_febg );if _fdded ==nil ||_ggggf ==nil {return _gfce ;};for _cggge :=0;_cggge < len (_fdded );_cggge ++{_bcbb .AddColorStop (_fdded [_cggge ],_ggggf [_cggge ]);};return _bcbb ;};

// SetFillColor sets the fill color.
func (_caad *CurvePolygon )SetFillColor (color Color ){_caad ._aabgb =color ;_caad ._bbdae .FillColor =_afb (color );};

// SetFillColor sets background color for border.
func (_agg *border )SetFillColor (col Color ){_agg ._eade =col };func _dbeb (_dgdea *templateProcessor ,_fgcbg *templateNode )(interface{},error ){return _dgdea .parseLine (_fgcbg );};

// CurRow returns the currently active cell's row number.
func (_fbeca *Table )CurRow ()int {_bgdcd :=(_fbeca ._cecaf -1)/_fbeca ._cccbd +1;return _bgdcd };func _beccfc (_cdfdb ...interface{})[]interface{}{return _cdfdb };

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_eagb *Rectangle )BorderOpacity ()float64 {return _eagb ._ccbd };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_aeece *TOC )SetLineNumberStyle (style TextStyle ){_aeece ._gfdgb =style };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_dabg *TOC )SetHeading (text string ,style TextStyle ){_ddcad :=_dabg .Heading ();_ddcad .Reset ();_gbdga :=_ddcad .Append (text );_gbdga .Style =style ;};func (_aade *templateProcessor )parseLinkAttr (_aecba ,_gbcd string )*_db .PdfAnnotation {_gbcd =_cc .TrimSpace (_gbcd );
if _cc .HasPrefix (_gbcd ,"\u0075\u0072\u006c(\u0027")&&_cc .HasSuffix (_gbcd ,"\u0027\u0029")&&len (_gbcd )> 7{return _agea (_gbcd [5:len (_gbcd )-2]);};if _cc .HasPrefix (_gbcd ,"\u0070\u0061\u0067e\u0028")&&_cc .HasSuffix (_gbcd ,"\u0029")&&len (_gbcd )> 6{var (_efag error ;
_gggd int64 ;_gfdc float64 ;_bedac float64 ;_bbdbdc =1.0;_acecf =_cc .Split (_gbcd [5:len (_gbcd )-1],"\u002c"););_gggd ,_efag =_eg .ParseInt (_cc .TrimSpace (_acecf [0]),10,64);if _efag !=nil {_d .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_efag );
return nil ;};if len (_acecf )>=2{_gfdc ,_efag =_eg .ParseFloat (_cc .TrimSpace (_acecf [1]),64);if _efag !=nil {_d .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_efag );
return nil ;};};if len (_acecf )>=3{_bedac ,_efag =_eg .ParseFloat (_cc .TrimSpace (_acecf [2]),64);if _efag !=nil {_d .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_efag );
return nil ;};};if len (_acecf )>=4{_bbdbdc ,_efag =_eg .ParseFloat (_cc .TrimSpace (_acecf [3]),64);if _efag !=nil {_d .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_efag );
return nil ;};};return _ecead (_gggd -1,_gfdc ,_bedac ,_bbdbdc );};return nil ;};func (_bdcc *templateProcessor )parseTextVerticalAlignmentAttr (_bgfab ,_fcafgg string )TextVerticalAlignment {_d .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bgfab ,_fcafgg );
_fbcad :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_fcafgg ];return _fbcad ;};func (_beace *StyledParagraph )getLineMetrics (_ddfd int )(_cfcag ,_ggfc ,_fcgfb float64 ){if _beace ._ebgc ==nil ||len (_beace ._ebgc )==0{_beace .wrapText ();
};if _ddfd < 0||_ddfd > len (_beace ._ebgc )-1{_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_ddfd );
return 0,0,0;};_afcdg :=_beace ._ebgc [_ddfd ];for _ ,_dagbf :=range _afcdg {_egad :=_agaa (_dagbf .Style .Font ,_dagbf .Style .FontSize );if _egad ._ebdff > _cfcag {_cfcag =_egad ._ebdff ;};if _egad ._ccbag < _fcgfb {_fcgfb =_egad ._ccbag ;};if _acdgc :=_dagbf .Style .FontSize ;
_acdgc > _ggfc {_ggfc =_acdgc ;};};return _cfcag ,_ggfc ,_fcgfb ;};func (_gfccg *Paragraph )getTextLineWidth (_dcege string )float64 {var _cbedd float64 ;for _ ,_adbe :=range _dcege {if _adbe =='\u000A'{continue ;};_cdegg ,_gagb :=_gfccg ._bccd .GetRuneMetrics (_adbe );
if !_gagb {_d .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_adbe ,_adbe );
return -1;};_cbedd +=_gfccg ._bbgda *_cdegg .Wx ;};return _cbedd ;};

// SetWidthLeft sets border width for left.
func (_adf *border )SetWidthLeft (bw float64 ){_adf ._dabb =bw };

// GetCoords returns coordinates of border.
func (_fbg *border )GetCoords ()(float64 ,float64 ){return _fbg ._ebfg ,_fbg ._fca };

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fbgg *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _fbgg ._bggcf [0],_fbgg ._bggcf [1]};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_bcbf *Division )Add (d VectorDrawable )error {switch _bccg :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_dgge ,_dcecf :=_bccg .ContainerComponent (_bcbf );
if _dcecf !=nil {return _dcecf ;};_cbdb ,_bdagc :=_dgge .(VectorDrawable );if !_bdagc {return _f .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_dgge );
};d =_cbdb ;default:return _ab .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_bcbf ._gcdd =append (_bcbf ._gcdd ,d );return nil ;};

// CurCol returns the currently active cell's column number.
func (_ffabd *Table )CurCol ()int {_gebcf :=(_ffabd ._cecaf -1)%(_ffabd ._cccbd )+1;return _gebcf };

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_afg *Block )SetMargins (left ,right ,top ,bottom float64 ){_afg ._add .Left =left ;_afg ._add .Right =right ;_afg ._add .Top =top ;_afg ._add .Bottom =bottom ;};func _eagfb (_ddfcd *templateProcessor ,_gccbf *templateNode )(interface{},error ){return _ddfcd .parseDivision (_gccbf );
};

// SetFontSize sets the font size in document units (points).
func (_aeggg *Paragraph )SetFontSize (fontSize float64 ){_aeggg ._bbgda =fontSize };

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_ceba *GraphicSVG )Scale (xFactor ,yFactor float64 ){_ceba ._gddd .Width =xFactor *_ceba ._gddd .Width ;_ceba ._gddd .Height =yFactor *_ceba ._gddd .Height ;_ceba ._gddd .SetScaling (xFactor ,yFactor );};

// Height returns the height of the graphic svg.
func (_adgc *GraphicSVG )Height ()float64 {return _adgc ._gddd .Height };func (_edce *Creator )getActivePage ()*_db .PdfPage {if _edce ._gge ==nil {if len (_edce ._caa )==0{return nil ;};return _edce ._caa [len (_edce ._caa )-1];};return _edce ._gge ;};


// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_ddcg *Rectangle )ScaleToHeight (h float64 ){_eeda :=_ddcg ._bccac /_ddcg ._begbb ;_ddcg ._begbb =h ;_ddcg ._bccac =h *_eeda ;};

// Logo returns the logo of the invoice.
func (_ecf *Invoice )Logo ()*Image {return _ecf ._ggff };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};func (_fggae *templateProcessor )parseChart (_fagb *templateNode )(interface{},error ){var _fcadg string ;for _ ,_abgg :=range _fagb ._fabca .Attr {_adbd :=_abgg .Value ;switch _cfedd :=_abgg .Name .Local ;_cfedd {case "\u0073\u0072\u0063":_fcadg =_adbd ;
};};if _fcadg ==""{_fggae .nodeLogError (_fagb ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_fedae ;};_cacc ,_afcgg :=_fggae ._cggb .ChartMap [_fcadg ];if !_afcgg {_fggae .nodeLogError (_fagb ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_fcadg );
return nil ,_fedae ;};_deagd :=NewChart (_cacc );for _ ,_bbbeb :=range _fagb ._fabca .Attr {_fdgf :=_bbbeb .Value ;switch _fbgfeg :=_bbbeb .Name .Local ;_fbgfeg {case "\u0078":_deagd .SetPos (_fggae .parseFloatAttr (_fbgfeg ,_fdgf ),_deagd ._acf );case "\u0079":_deagd .SetPos (_deagd ._defe ,_fggae .parseFloatAttr (_fbgfeg ,_fdgf ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_ffda :=_fggae .parseMarginAttr (_fbgfeg ,_fdgf );_deagd .SetMargins (_ffda .Left ,_ffda .Right ,_ffda .Top ,_ffda .Bottom );case "\u0077\u0069\u0064t\u0068":_deagd ._aefd .SetWidth (int (_fggae .parseFloatAttr (_fbgfeg ,_fdgf )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_deagd ._aefd .SetHeight (int (_fggae .parseFloatAttr (_fbgfeg ,_fdgf )));case "\u0073\u0072\u0063":break ;default:_fggae .nodeLogDebug (_fagb ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_fbgfeg );
};};return _deagd ,nil ;};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_fcafd *List )Add (item VectorDrawable )(*TextChunk ,error ){_aeeb :=&listItem {_cbea :item ,_bdaa :_fcafd ._gccff };switch _aadg :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _aadg ._gfbf {_aadg ._adge =15;};case *Division :case *Image :case *Table :default:return nil ,_ab .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_fcafd ._bdee =append (_fcafd ._bdee ,_aeeb );return &_aeeb ._bdaa ,nil ;};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_dagfg *TOCLine )SetStyle (style TextStyle ){_dagfg .Number .Style =style ;_dagfg .Title .Style =style ;_dagfg .Separator .Style =style ;_dagfg .Page .Style =style ;};

// Positioning returns the type of positioning the ellipse is set to use.
func (_acac *Ellipse )Positioning ()Positioning {return _acac ._baeb };

// FitMode returns the fit mode of the ellipse.
func (_dbabc *Ellipse )FitMode ()FitMode {return _dbabc ._bbf };func (_eaaf *Block )transform (_dbf _eaa .Matrix ){_gcgb :=_cf .NewContentCreator ().Add_cm (_dbf [0],_dbf [1],_dbf [3],_dbf [4],_dbf [6],_dbf [7]).Operations ();*_eaaf ._bag =append (*_gcgb ,*_eaaf ._bag ...);
_eaaf ._bag .WrapIfNeeded ();};const (DefaultHorizontalScaling =100;);

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_ddfg *Creator )SetPageLabels (pageLabels _ag .PdfObject ){_ddfg ._eafb =pageLabels };func _gcff (_aaea string )(*GraphicSVG ,error ){_gcccf ,_gbd :=_bgc .ParseFromFile (_aaea );if _gbd !=nil {return nil ,_gbd ;};return _bfbbc (_gcccf );};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_dbdcd *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acag :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ffgb ,_eeac :=_acag .setOpacity (_dbdcd ._dcgf ,_dbdcd ._egaf );if _eeac !=nil {return nil ,ctx ,_eeac ;
};_dacd :=_dbdcd ._bbdae ;_dacd .FillEnabled =_dacd .FillColor !=nil ;_dacd .BorderEnabled =_dacd .BorderColor !=nil &&_dacd .BorderWidth > 0;var (_cgaf =ctx .PageHeight ;_febb =_dacd .Rings ;_abddg =make ([][]_fg .CubicBezierCurve ,0,len (_dacd .Rings ));
);_feabe :=_db .PdfRectangle {};if len (_febb )> 0&&len (_febb [0])> 0{_fcgf :=_febb [0][0];_fcgf .P0 .Y =_cgaf -_fcgf .P0 .Y ;_fcgf .P1 .Y =_cgaf -_fcgf .P1 .Y ;_fcgf .P2 .Y =_cgaf -_fcgf .P2 .Y ;_fcgf .P3 .Y =_cgaf -_fcgf .P3 .Y ;_feabe =_fcgf .GetBounds ();
};for _ ,_bff :=range _febb {_edfe :=make ([]_fg .CubicBezierCurve ,0,len (_bff ));for _ ,_edbc :=range _bff {_cegee :=_edbc ;_cegee .P0 .Y =_cgaf -_cegee .P0 .Y ;_cegee .P1 .Y =_cgaf -_cegee .P1 .Y ;_cegee .P2 .Y =_cgaf -_cegee .P2 .Y ;_cegee .P3 .Y =_cgaf -_cegee .P3 .Y ;
_edfe =append (_edfe ,_cegee );_fbgb :=_cegee .GetBounds ();_feabe .Llx =_gb .Min (_feabe .Llx ,_fbgb .Llx );_feabe .Lly =_gb .Min (_feabe .Lly ,_fbgb .Lly );_feabe .Urx =_gb .Max (_feabe .Urx ,_fbgb .Urx );_feabe .Ury =_gb .Max (_feabe .Ury ,_fbgb .Ury );
};_abddg =append (_abddg ,_edfe );};_dacd .Rings =_abddg ;defer func (){_dacd .Rings =_febb }();if _dacd .FillEnabled {_fdaf :=_edcb (_acag ,_dbdcd ._bbdae .FillColor ,_dbdcd ._aabgb ,func ()Rectangle {return Rectangle {_dbgeg :_feabe .Llx ,_gead :_feabe .Lly ,_bccac :_feabe .Width (),_begbb :_feabe .Height ()};
});if _fdaf !=nil {return nil ,ctx ,_fdaf ;};};_baga ,_ ,_eeac :=_dacd .Draw (_ffgb );if _eeac !=nil {return nil ,ctx ,_eeac ;};if _eeac =_acag .addContentsByString (string (_baga ));_eeac !=nil {return nil ,ctx ,_eeac ;};return []*Block {_acag },ctx ,nil ;
};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);func (_fegdd *templateProcessor )parseFontAttr (_abbag ,_cbddb string )*_db .PdfFont {_d .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_abbag ,_cbddb );
_dggcc :=_fegdd .creator ._gef ;if _cbddb ==""{return _dggcc ;};_bdafg :=_cc .Split (_cbddb ,"\u002c");for _ ,_ecda :=range _bdafg {_ecda =_cc .TrimSpace (_ecda );if _ecda ==""{continue ;};_cacb ,_edgda :=_fegdd ._cggb .FontMap [_cbddb ];if _edgda {return _cacb ;
};_dade ,_edgda :=map[string ]_db .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_db .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_db .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_db .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_db .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_db .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_db .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_db .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_db .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_db .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_db .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_db .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_db .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_db .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_db .TimesBoldItalicName }[_cbddb ];
if _edgda {if _gdff ,_egcde :=_db .NewStandard14Font (_dade );_egcde ==nil {return _gdff ;};};if _febbg :=_fegdd .parseAttrPropList (_ecda );len (_febbg )> 0{if _ggbd ,_badfbg :=_febbg ["\u0070\u0061\u0074\u0068"];_badfbg {_bbeec :=_db .NewPdfFontFromTTFFile ;
if _daafd ,_cdaa :=_febbg ["\u0074\u0079\u0070\u0065"];_cdaa &&_daafd =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_bbeec =_db .NewCompositePdfFontFromTTFFile ;};if _fdcf ,_gfffb :=_bbeec (_ggbd );_gfffb !=nil {_d .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_ggbd ,_gfffb );
}else {return _fdcf ;};};};};return _dggcc ;};

// Add adds a new line with the default style to the table of contents.
func (_gaca *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_defee :=_gaca .AddLine (_gbgeb (TextChunk {Text :number ,Style :_gaca ._gfdgb },TextChunk {Text :title ,Style :_gaca ._becab },TextChunk {Text :page ,Style :_gaca ._fafd },level ,_gaca ._ebfbc ));
if _defee ==nil {return nil ;};_cacda :=&_gaca ._cadb ;_defee .SetMargins (_cacda .Left ,_cacda .Right ,_cacda .Top ,_cacda .Bottom );_defee .SetLevelOffset (_gaca ._egab );_defee .Separator .Text =_gaca ._defdd ;_defee .Separator .Style =_gaca ._eddb ;
return _defee ;};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_gade *Division )Height ()float64 {var _bfbb float64 ;for _ ,_afdb :=range _gade ._gcdd {switch _agac :=_afdb .(type ){case marginDrawable :_ ,_ ,_fedd ,_dfbb :=_agac .GetMargins ();_bfbb +=_agac .Height ()+_fedd +_dfbb ;default:_bfbb +=_agac .Height ();
};};return _bfbb ;};type rgbColor struct{_dcbf ,_accg ,_bgcg float64 };

// DrawWithContext draws the Block using the specified drawing context.
func (_agee *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_dcd ,_ ,_agc :=d .GeneratePageBlocks (ctx );if _agc !=nil {return _agc ;};if len (_dcd )!=1{return ErrContentNotFit ;};for _ ,_efca :=range _dcd {if _dcg :=_agee .mergeBlocks (_efca );
_dcg !=nil {return _dcg ;};};return nil ;};

// SkipRows skips over a specified number of rows in the table.
func (_efdgc *Table )SkipRows (num int ){_dbeff :=num *_efdgc ._cccbd -1;if _dbeff < 0{_d .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _afabc :=0;_afabc < _dbeff ;_afabc ++{_efdgc .NewCell ();};};

// NewImage create a new image from a unidoc image (model.Image).
func (_bed *Creator )NewImage (img *_db .Image )(*Image ,error ){return _aaceg (img )};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// NewPolygon creates a new polygon.
func (_cbcf *Creator )NewPolygon (points [][]_fg .Point )*Polygon {return _gcgc (points )};

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_acdgg *Rectangle )SetPositioning (position Positioning ){_acdgg ._aacf =position };

// SetWidth sets line width.
func (_ecac *Curve )SetWidth (width float64 ){_ecac ._becb =width };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_fddf *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gded :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gebg ,_bbee :=_gded .setOpacity (_fddf ._bcdc ,_fddf ._geeda );if _bbee !=nil {return nil ,ctx ,_bbee ;};_fbbe :=_fddf ._cdfc ;
_fbbe .FillEnabled =_fbbe .FillColor !=nil ;_fbbe .BorderEnabled =_fbbe .BorderColor !=nil &&_fbbe .BorderWidth > 0;_dead :=_fbbe .Points ;_cdg :=_db .PdfRectangle {};_ebbc :=false ;for _agge :=range _dead {for _gdab :=range _dead [_agge ]{_gbeb :=&_dead [_agge ][_gdab ];
_gbeb .Y =ctx .PageHeight -_gbeb .Y ;if !_ebbc {_cdg .Llx =_gbeb .X ;_cdg .Lly =_gbeb .Y ;_cdg .Urx =_gbeb .X ;_cdg .Ury =_gbeb .Y ;_ebbc =true ;}else {_cdg .Llx =_gb .Min (_cdg .Llx ,_gbeb .X );_cdg .Lly =_gb .Min (_cdg .Lly ,_gbeb .Y );_cdg .Urx =_gb .Max (_cdg .Urx ,_gbeb .X );
_cdg .Ury =_gb .Max (_cdg .Ury ,_gbeb .Y );};};};if _fbbe .FillEnabled {_adffe :=_edcb (_gded ,_fddf ._cdfc .FillColor ,_fddf ._cdfa ,func ()Rectangle {return Rectangle {_dbgeg :_cdg .Llx ,_gead :_cdg .Lly ,_bccac :_cdg .Width (),_begbb :_cdg .Height ()};
});if _adffe !=nil {return nil ,ctx ,_adffe ;};};_bdgba ,_ ,_bbee :=_fbbe .Draw (_gebg );if _bbee !=nil {return nil ,ctx ,_bbee ;};if _bbee =_gded .addContentsByString (string (_bdgba ));_bbee !=nil {return nil ,ctx ,_bbee ;};return []*Block {_gded },ctx ,nil ;
};func _ceac (_bfbege *templateProcessor ,_cggce *templateNode )(interface{},error ){return _bfbege .parseTableCell (_cggce );};func (_bdde *InvoiceAddress )fmtLine (_acga ,_agef string ,_bbgde bool )string {if _bbgde {_agef ="";};return _f .Sprintf ("\u0025\u0073\u0025s\u000a",_agef ,_acga );
};

// Positioning returns the type of positioning the rectangle is set to use.
func (_ffaa *Rectangle )Positioning ()Positioning {return _ffaa ._aacf };

// Height returns Image's document height.
func (_deg *Image )Height ()float64 {return _deg ._gafb };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_cae *Creator )SetForms (form *_db .PdfAcroForm )error {_cae ._cgfb =form ;return nil };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);func _abgb (_gcce ,_cfce ,_efbb ,_ebdf ,_beagb ,_ffac float64 )*Curve {_bdca :=&Curve {};
_bdca ._gdgg =_gcce ;_bdca ._edec =_cfce ;_bdca ._edda =_efbb ;_bdca ._bfgg =_ebdf ;_bdca ._geedb =_beagb ;_bdca ._cfdf =_ffac ;_bdca ._ffdb =ColorBlack ;_bdca ._becb =1.0;return _bdca ;};func (_dedde *List )ctxHeight (_egcd float64 )float64 {_egcd -=_dedde ._adge ;
var _bgbd float64 ;for _ ,_fceg :=range _dedde ._bdee {_bgbd +=_fceg .ctxHeight (_egcd );};return _bgbd ;};

// NewImageFromData creates an Image from image data.
func (_dafb *Creator )NewImageFromData (data []byte )(*Image ,error ){return _dbfa (data )};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_efdd *Creator )NewPage ()*_db .PdfPage {_adee :=_efdd .newPage ();_efdd ._caa =append (_efdd ._caa ,_adee );_efdd ._edg .Page ++;return _adee ;};

// SetStyleRight sets border style for right side.
func (_gfe *border )SetStyleRight (style CellBorderStyle ){_gfe ._bec =style };func (_gcebe *templateProcessor )nodeLogError (_cdadb *templateNode ,_gcga string ,_eeeba ...interface{}){_d .Log .Error (_gcebe .getNodeErrorLocation (_cdadb ,_gcga ,_eeeba ...));
};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// Width returns Image's document width.
func (_becf *Image )Width ()float64 {return _becf ._daba };

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_faba *Creator )SetPageSize (size PageSize ){_faba ._fecg =size ;_faba ._gcac =size [0];_faba ._cfaf =size [1];_dbab :=0.1*_faba ._gcac ;_faba ._bbgd .Left =_dbab ;_faba ._bbgd .Right =_dbab ;_faba ._bbgd .Top =_dbab ;_faba ._bbgd .Bottom =_dbab ;
};

// AddColorStop add color stop info for rendering gradient color.
func (_cggae *RadialShading )AddColorStop (color Color ,point float64 ){_cggae ._cgec .AddColorStop (color ,point );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_accf *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _aadgc float64 ;var _caeb []*StyledParagraph ;for _ ,_fgfg :=range _accf ._bdee {_cgbb :=_gfbe (_accf ._fcad );_cgbb .SetEnableWrap (false );_cgbb .SetTextAlignment (TextAlignmentRight );
_cgbb .Append (_fgfg ._bdaa .Text ).Style =_fgfg ._bdaa .Style ;_egfef :=_cgbb .getTextWidth ()/1000.0/ctx .Width ;if _aadgc < _egfef {_aadgc =_egfef ;};_caeb =append (_caeb ,_cgbb );};_bdgb :=_eedb (2);_bdgb .SetColumnWidths (_aadgc ,1-_aadgc );_bdgb .SetMargins (_accf ._ebdfg .Left +_accf ._adge ,_accf ._ebdfg .Right ,_accf ._ebdfg .Top ,_accf ._ebdfg .Bottom );
_bdgb .EnableRowWrap (true );for _cfbfc ,_dfbba :=range _accf ._bdee {_faeeg :=_bdgb .NewCell ();_faeeg .SetIndent (0);_faeeg .SetContent (_caeb [_cfbfc ]);_faeeg =_bdgb .NewCell ();_faeeg .SetIndent (0);_faeeg .SetContent (_dfbba ._cbea );};return _bdgb .GeneratePageBlocks (ctx );
};

// SetBackground sets the background properties of the component.
func (_dbef *Division )SetBackground (background *Background ){_dbef ._cgeg =background };

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_fcde *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_fcde ._ggge =&_db .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_bbae float64 ;_effb float64 ;_aafcb float64 ;_affa float64 ;_ccg Color ;_daaf _fg .LineStyle ;_edbfcd float64 ;_ggdb []int64 ;_defa int64 ;_dgfab float64 ;_fdgb Positioning ;_dbged FitMode ;_gabgd Margins ;};func _aega (_ece ,_baf ,_adgd ,_feaa float64 )*Ellipse {return &Ellipse {_ddag :_ece ,_gabf :_baf ,_bee :_adgd ,_faea :_feaa ,_baeb :PositionAbsolute ,_gfgd :1.0,_geef :ColorBlack ,_gcef :1.0,_gdef :1.0};
};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_bdgde *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_bdgde ._cccbd {_d .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bdgde ._cfab =widths ;return nil ;};

// SetInline sets the inline mode of the division.
func (_abgbb *Division )SetInline (inline bool ){_abgbb ._eaad =inline };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_dcec *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_dcec ._cbfc .Left =left ;_dcec ._cbfc .Right =right ;_dcec ._cbfc .Top =top ;_dcec ._cbfc .Bottom =bottom ;};

// SetSideBorderWidth sets the cell's side border width.
func (_gcbdg *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_gcbdg ._ffbcg =width ;_gcbdg ._bdbe =width ;_gcbdg ._ddda =width ;_gcbdg ._gcfeg =width ;case CellBorderSideTop :_gcbdg ._ffbcg =width ;
case CellBorderSideBottom :_gcbdg ._bdbe =width ;case CellBorderSideLeft :_gcbdg ._ddda =width ;case CellBorderSideRight :_gcbdg ._gcfeg =width ;};};func _gee (_bbe *_cf .ContentStreamOperations ,_bac *_db .PdfPageResources ,_bfac *_cf .ContentStreamOperations ,_fa *_db .PdfPageResources )error {_bbdg :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};
_abe :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};_acd :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};_fcb :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};_abb :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};_dgb :=map[_ag .PdfObjectName ]_ag .PdfObjectName {};
for _ ,_bacd :=range *_bfac {switch _bacd .Operand {case "\u0044\u006f":if len (_bacd .Params )==1{if _cfd ,_bgb :=_bacd .Params [0].(*_ag .PdfObjectName );_bgb {if _ ,_ddf :=_bbdg [*_cfd ];!_ddf {var _fee _ag .PdfObjectName ;_cgf ,_ :=_fa .GetXObjectByName (*_cfd );
if _cgf !=nil {_fee =*_cfd ;for {_fcf ,_ :=_bac .GetXObjectByName (_fee );if _fcf ==nil ||_fcf ==_cgf {break ;};_fee =*_ag .MakeName (_aebg (_fee .String ()));};};_bac .SetXObjectByName (_fee ,_cgf );_bbdg [*_cfd ]=_fee ;};_ddff :=_bbdg [*_cfd ];_bacd .Params [0]=&_ddff ;
};};case "\u0054\u0066":if len (_bacd .Params )==2{if _dedf ,_dbb :=_bacd .Params [0].(*_ag .PdfObjectName );_dbb {if _ ,_acde :=_abe [*_dedf ];!_acde {_gfg ,_cbff :=_fa .GetFontByName (*_dedf );_cbec :=*_dedf ;if _cbff &&_gfg !=nil {_cbec =_bfd (_dedf .String (),_gfg ,_bac );
};_bac .SetFontByName (_cbec ,_gfg );_abe [*_dedf ]=_cbec ;};_cgc :=_abe [*_dedf ];_bacd .Params [0]=&_cgc ;};};case "\u0043\u0053","\u0063\u0073":if len (_bacd .Params )==1{if _eeba ,_bab :=_bacd .Params [0].(*_ag .PdfObjectName );_bab {if _ ,_gea :=_acd [*_eeba ];
!_gea {var _gca _ag .PdfObjectName ;_geg ,_fgc :=_fa .GetColorspaceByName (*_eeba );if _fgc {_gca =*_eeba ;for {_cfb ,_dcc :=_bac .GetColorspaceByName (_gca );if !_dcc ||_geg ==_cfb {break ;};_gca =*_ag .MakeName (_aebg (_gca .String ()));};_bac .SetColorspaceByName (_gca ,_geg );
_acd [*_eeba ]=_gca ;}else {_d .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _gaef ,_fef :=_acd [*_eeba ];_fef {_bacd .Params [0]=&_gaef ;}else {_d .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_eeba );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_bacd .Params )==1{if _bdd ,_edb :=_bacd .Params [0].(*_ag .PdfObjectName );_edb {if _ ,_aac :=_fcb [*_bdd ];!_aac {var _cgg _ag .PdfObjectName ;_cga ,_fea :=_fa .GetPatternByName (*_bdd );if _fea {_cgg =*_bdd ;
for {_dea ,_dce :=_bac .GetPatternByName (_cgg );if !_dce ||_dea ==_cga {break ;};_cgg =*_ag .MakeName (_aebg (_cgg .String ()));};_efd :=_bac .SetPatternByName (_cgg ,_cga .ToPdfObject ());if _efd !=nil {return _efd ;};_fcb [*_bdd ]=_cgg ;};};if _eca ,_cca :=_fcb [*_bdd ];
_cca {_bacd .Params [0]=&_eca ;};};};case "\u0073\u0068":if len (_bacd .Params )==1{if _aace ,_cef :=_bacd .Params [0].(*_ag .PdfObjectName );_cef {if _ ,_bcec :=_abb [*_aace ];!_bcec {var _babf _ag .PdfObjectName ;_eef ,_cce :=_fa .GetShadingByName (*_aace );
if _cce {_babf =*_aace ;for {_egf ,_gfb :=_bac .GetShadingByName (_babf );if !_gfb ||_eef ==_egf {break ;};_babf =*_ag .MakeName (_aebg (_babf .String ()));};_gegb :=_bac .SetShadingByName (_babf ,_eef .ToPdfObject ());if _gegb !=nil {_d .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_gegb );
return _gegb ;};_abb [*_aace ]=_babf ;}else {_d .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _edba ,_ceg :=_abb [*_aace ];_ceg {_bacd .Params [0]=&_edba ;}else {_d .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_aace );
};};};case "\u0067\u0073":if len (_bacd .Params )==1{if _ebda ,_eded :=_bacd .Params [0].(*_ag .PdfObjectName );_eded {if _ ,_gcab :=_dgb [*_ebda ];!_gcab {var _cbc _ag .PdfObjectName ;_eeg ,_aeb :=_fa .GetExtGState (*_ebda );if _aeb {_cbc =*_ebda ;for {_dab ,_fcg :=_bac .GetExtGState (_cbc );
if !_fcg ||_eeg ==_dab {break ;};_cbc =*_ag .MakeName (_aebg (_cbc .String ()));};};_bac .AddExtGState (_cbc ,_eeg );_dgb [*_ebda ]=_cbc ;};_gab :=_dgb [*_ebda ];_bacd .Params [0]=&_gab ;};};};*_bbe =append (*_bbe ,_bacd );};return nil ;};

// SetDueDate sets the due date of the invoice.
func (_cefg *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_cefg ._bggcf [1].Value =dueDate ;return _cefg ._bggcf [0],_cefg ._bggcf [1];};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_ebdd *List )Width ()float64 {return 0};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_agab *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_cgaae :=NewTextChunk (text ,_agab ._abba );_cgaae ._fedb =_ecead (page -1,x ,y ,zoom );return _agab .appendChunk (_cgaae );};

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_bbea *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bbea ._dagb .Left ,_bbea ._dagb .Right ,_bbea ._dagb .Top ,_bbea ._dagb .Bottom ;};func _efg (_gce ,_gfbc *_db .PdfPageResources )error {_dfb ,_ :=_gce .GetColorspaces ();
if _dfb !=nil &&len (_dfb .Colorspaces )> 0{for _eea ,_dee :=range _dfb .Colorspaces {_cdc :=*_ag .MakeName (_eea );if _gfbc .HasColorspaceByName (_cdc ){continue ;};_fae :=_gfbc .SetColorspaceByName (_cdc ,_dee );if _fae !=nil {return _fae ;};};};return nil ;
};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_gbgb *RadialShading )AddShadingResource (block *Block )(_fbgfa _ag .PdfObjectName ,_bcdad error ){_fgefc :=1;_fbgfa =_ag .PdfObjectName ("\u0053\u0068"+_eg .Itoa (_fgefc ));for block ._aef .HasShadingByName (_fbgfa ){_fgefc ++;_fbgfa =_ag .PdfObjectName ("\u0053\u0068"+_eg .Itoa (_fgefc ));
};if _becc :=block ._aef .SetShadingByName (_fbgfa ,_gbgb .shadingModel ().ToPdfObject ());_becc !=nil {return "",_becc ;};return _fbgfa ,nil ;};

// Width returns the width of the Paragraph.
func (_bcdaa *Paragraph )Width ()float64 {if _bcdaa ._aacg &&int (_bcdaa ._cbeda )> 0{return _bcdaa ._cbeda ;};return _bcdaa .getTextWidth ()/1000.0;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_bgeb *Creator )NewChapter (title string )*Chapter {_bgeb ._gcd ++;_dbg :=_bgeb .NewTextStyle ();_dbg .FontSize =16;return _acae (nil ,_bgeb ._gcad ,_bgeb ._gbcf ,title ,_bgeb ._gcd ,_dbg );};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_gbbd *Creator )NewImageFromGoImage (goimg _ea .Image )(*Image ,error ){return _aaab (goimg )};

// SetMargins sets the margins TOC line.
func (_gffcb *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_gffcb ._gaag =left ;_dgfae :=&_gffcb ._ffcgc ._acfa ;_dgfae .Left =_gffcb ._gaag +float64 (_gffcb ._fbgga -1)*_gffcb ._dgcg ;_dgfae .Right =right ;_dgfae .Top =top ;_dgfae .Bottom =bottom ;
};func (_ffe *Block )setOpacity (_age float64 ,_fc float64 )(string ,error ){if (_age < 0||_age >=1.0)&&(_fc < 0||_fc >=1.0){return "",nil ;};_cfg :=0;_dg :=_f .Sprintf ("\u0047\u0053\u0025\u0064",_cfg );for _ffe ._aef .HasExtGState (_ag .PdfObjectName (_dg )){_cfg ++;
_dg =_f .Sprintf ("\u0047\u0053\u0025\u0064",_cfg );};_afe :=_ag .MakeDict ();if _age >=0&&_age < 1.0{_afe .Set ("\u0063\u0061",_ag .MakeFloat (_age ));};if _fc >=0&&_fc < 1.0{_afe .Set ("\u0043\u0041",_ag .MakeFloat (_fc ));};_cbg :=_ffe ._aef .AddExtGState (_ag .PdfObjectName (_dg ),_afe );
if _cbg !=nil {return "",_cbg ;};return _dg ,nil ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_edgd *Image )SetPos (x ,y float64 ){_edgd ._dfgd =PositionAbsolute ;_edgd ._aeed =x ;_edgd ._eede =y ;};

// SetNumber sets the number of the invoice.
func (_geeea *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_geeea ._bebe [1].Value =number ;return _geeea ._bebe [0],_geeea ._bebe [1];};func (_ebaa *templateProcessor )parsePositioningAttr (_dcfa ,_facc string )Positioning {_d .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dcfa ,_facc );
_eabab :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_facc ];return _eabab ;};func (_gaga *shading )generatePdfFunctions ()[]_db .PdfFunction {if len (_gaga ._fgcdg )==0{return nil ;
}else if len (_gaga ._fgcdg )<=2{_cebc ,_abegg ,_dgbe :=_gaga ._fgcdg [0]._fgcba .ToRGB ();_cgfc ,_fecgb ,_afgbg :=_gaga ._fgcdg [len (_gaga ._fgcdg )-1]._fgcba .ToRGB ();return []_db .PdfFunction {&_db .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_cebc ,_abegg ,_dgbe },C1 :[]float64 {_cgfc ,_fecgb ,_afgbg }}};
}else {_aeeee :=[]_db .PdfFunction {};_cabd :=[]float64 {};for _dcgd :=0;_dcgd < len (_gaga ._fgcdg )-1;_dcgd ++{_ffcfa ,_cddf ,_fdca :=_gaga ._fgcdg [_dcgd ]._fgcba .ToRGB ();_cccb ,_ecgf ,_ebgg :=_gaga ._fgcdg [_dcgd +1]._fgcba .ToRGB ();_gbce :=&_db .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_ffcfa ,_cddf ,_fdca },C1 :[]float64 {_cccb ,_ecgf ,_ebgg }};
_aeeee =append (_aeeee ,_gbce );if _dcgd > 0{_cabd =append (_cabd ,_gaga ._fgcdg [_dcgd ]._edcdd );};};_ffcfb :=[]float64 {};for range _aeeee {_ffcfb =append (_ffcfb ,[]float64 {0.0,1.0}...);};return []_db .PdfFunction {&_db .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_aeeee ,Bounds :_cabd ,Encode :_ffcfb }};
};};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_gdgg float64 ;_edec float64 ;_edda float64 ;_bfgg float64 ;_geedb float64 ;_cfdf float64 ;_ffdb Color ;_becb float64 ;};func _cggd (_ffeb _ege .ChartRenderable )*Chart {return &Chart {_aefd :_ffeb ,_aeee :PositionRelative ,_ffa :Margins {Top :10,Bottom :10}};
};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// AddSection adds a new content section at the end of the invoice.
func (_eagc *Invoice )AddSection (title ,content string ){_eagc ._eadcb =append (_eagc ._eadcb ,[2]string {title ,content });};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_geacf *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _geacf ._decf [0],_geacf ._decf [1]};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_ffacc *Invoice )InfoLines ()[][2]*InvoiceCell {_acagd :=[][2]*InvoiceCell {_ffacc ._bebe ,_ffacc ._cecd ,_ffacc ._bggcf };return append (_acagd ,_ffacc ._cgbg ...);};

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_bead *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _dafdb (x ,y ,innerRadius ,outerRadius ,colorPoints );};func _bdcb (_ecaag Color ,_daefg float64 )*ColorPoint {return &ColorPoint {_fgcba :_ecaag ,_edcdd :_daefg };
};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_faaa *Table )MultiCell (rowspan ,colspan int )*TableCell {_faaa ._cecaf ++;_cedaga :=(_faaa .moveToNextAvailableCell ()-1)%(_faaa ._cccbd )+1;_aaddc :=(_faaa ._cecaf -1)/_faaa ._cccbd +1;for _aaddc > _faaa ._dgdc {_faaa ._dgdc ++;_faaa ._bebec =append (_faaa ._bebec ,_faaa ._gbccbb );
};_afbge :=&TableCell {};_afbge ._adfd =_aaddc ;_afbge ._bcea =_cedaga ;_afbge ._dedb =5;_afbge ._gaffc =CellBorderStyleNone ;_afbge ._gbebf =_fg .LineStyleSolid ;_afbge ._ddfgb =CellHorizontalAlignmentLeft ;_afbge ._gdca =CellVerticalAlignmentTop ;_afbge ._ddda =0;
_afbge ._bdbe =0;_afbge ._gcfeg =0;_afbge ._ffbcg =0;_dfcb :=ColorBlack ;_afbge ._cfge =_dfcb ;_afbge ._ddac =_dfcb ;_afbge ._gbbdf =_dfcb ;_afbge ._babeg =_dfcb ;if rowspan < 1{_d .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_daed :=_faaa ._dgdc -(_afbge ._adfd -1);if rowspan > _daed {_d .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_daed );
_faaa ._dgdc +=rowspan -1;for _fgebe :=0;_fgebe <=rowspan -_daed ;_fgebe ++{_faaa ._bebec =append (_faaa ._bebec ,_faaa ._gbccbb );};};for _gfef :=0;_gfef < colspan &&_cedaga +_gfef -1< len (_faaa ._dedgb );_gfef ++{_faaa ._dedgb [_cedaga +_gfef -1]=rowspan -1;
};_afbge ._fbeb =rowspan ;if colspan < 1{_d .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_cbceb :=_faaa ._cccbd -(_afbge ._bcea -1);if colspan > _cbceb {_d .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_cbceb );
colspan =_cbceb ;};_afbge ._egba =colspan ;_faaa ._cecaf +=colspan -1;_faaa ._dgde =append (_faaa ._dgde ,_afbge );_afbge ._bfdgf =_faaa ;return _afbge ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// IsAbsolute checks if the positioning is absolute.
func (_bcaa Positioning )IsAbsolute ()bool {return _bcaa ==PositionAbsolute };

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetBorderColor sets the border color of the ellipse.
func (_dacg *Ellipse )SetBorderColor (col Color ){_dacg ._geef =col };const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_ddag float64 ;_gabf float64 ;_bee float64 ;_faea float64 ;_baeb Positioning ;_bbad Color ;_gfgd float64 ;_geef Color ;_gcef float64 ;_gdef float64 ;_fbcgf Margins ;_bbf FitMode ;};type listItem struct{_cbea VectorDrawable ;_bdaa TextChunk ;
};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_edad *RadialShading )SetExtends (start bool ,end bool ){_edad ._cgec .SetExtends (start ,end )};func (_egfb *TableCell )cloneProps (_dggcg VectorDrawable )*TableCell {_adeed :=*_egfb ;_adeed ._aabd =_dggcg ;return &_adeed ;};func (_eabg *Invoice )generateNoteBlocks (_bcgg DrawContext )([]*Block ,DrawContext ,error ){_ebb :=_dgfa ();
_fecbe :=append ([][2]string {_eabg ._dggc ,_eabg ._bggce },_eabg ._eadcb ...);for _ ,_gbfa :=range _fecbe {if _gbfa [1]!=""{_baage :=_eabg .drawSection (_gbfa [0],_gbfa [1]);for _ ,_ffed :=range _baage {_ebb .Add (_ffed );};_edbda :=_gfbe (_eabg ._cafa );
_edbda .SetMargins (0,0,10,0);_ebb .Add (_edbda );};};return _ebb .GeneratePageBlocks (_bcgg );};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_bceg *Creator )PageFinalize (pageFinalizeFunc func (_gcada PageFinalizeFunctionArgs )error ){_bceg ._ffdd =pageFinalizeFunc ;};

// Scale scales the rectangle dimensions by the specified factors.
func (_gbefe *Rectangle )Scale (xFactor ,yFactor float64 ){_gbefe ._bccac =xFactor *_gbefe ._bccac ;_gbefe ._begbb =yFactor *_gbefe ._begbb ;};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;TextVerticalAlignmentBottom ;
TextVerticalAlignmentTop ;);func (_cbde *Invoice )drawInformation ()*Table {_edcd :=_eedb (2);_cdbb :=append ([][2]*InvoiceCell {_cbde ._bebe ,_cbde ._cecd ,_cbde ._bggcf },_cbde ._cgbg ...);for _ ,_cfdef :=range _cdbb {_efab ,_fbba :=_cfdef [0],_cfdef [1];
if _fbba .Value ==""{continue ;};_bffbg :=_edcd .NewCell ();_bffbg .SetBackgroundColor (_efab .BackgroundColor );_cbde .setCellBorder (_bffbg ,_efab );_bgba :=_gfbe (_efab .TextStyle );_bgba .Append (_efab .Value );_bgba .SetMargins (0,0,2,1);_bffbg .SetContent (_bgba );
_bffbg =_edcd .NewCell ();_bffbg .SetBackgroundColor (_fbba .BackgroundColor );_cbde .setCellBorder (_bffbg ,_fbba );_bgba =_gfbe (_fbba .TextStyle );_bgba .Append (_fbba .Value );_bgba .SetMargins (0,0,2,1);_bffbg .SetContent (_bgba );};return _edcd ;
};

// EnableWordWrap sets the paragraph word wrap flag.
func (_bdad *StyledParagraph )EnableWordWrap (val bool ){_bdad ._aegab =val };

// SetBorderColor sets border color of the rectangle.
func (_cbfd *Rectangle )SetBorderColor (col Color ){_cbfd ._ddde =col };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_bcagb *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _abgb (x1 ,y1 ,cx ,cy ,x2 ,y2 );};var (ErrContentNotFit =_ab .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
);

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_aebc *shading )SetExtends (start bool ,end bool ){_aebc ._gagd =[]bool {start ,end }};

// Notes returns the notes section of the invoice as a title-content pair.
func (_cfee *Invoice )Notes ()(string ,string ){return _cfee ._dggc [0],_cfee ._dggc [1]};

// Width returns the width of the Paragraph.
func (_ffcc *StyledParagraph )Width ()float64 {if _ffcc ._bbff &&int (_ffcc ._baaga )> 0{return _ffcc ._baaga ;};return _ffcc .getTextWidth ()/1000.0;};

// Write output of creator to io.Writer interface.
func (_ggg *Creator )Write (ws _ba .Writer )error {if _eeab :=_ggg .Finalize ();_eeab !=nil {return _eeab ;};_efgd :="";if _edcf ,_eag :=ws .(*_ae .File );_eag {_efgd =_edcf .Name ();};_fdde :=_db .NewPdfWriter ();_fdde .SetOptimizer (_ggg ._egdg );_fdde .SetFileName (_efgd );
if _ggg ._cgfb !=nil {_fdg :=_fdde .SetForms (_ggg ._cgfb );if _fdg !=nil {_d .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_fdg );return _fdg ;};};if _ggg ._bef !=nil {_fdde .AddOutlineTree (_ggg ._bef );}else if _ggg ._gbcf !=nil &&_ggg .AddOutlines {_fdde .AddOutlineTree (&_ggg ._gbcf .ToPdfOutline ().PdfOutlineTreeNode );
};if _ggg ._eafb !=nil {if _ggdf :=_fdde .SetPageLabels (_ggg ._eafb );_ggdf !=nil {_d .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_ggdf );
return _ggdf ;};};if _ggg ._ccbg !=nil {for _ ,_egdgb :=range _ggg ._ccbg {_beab :=_egdgb .SubsetRegistered ();if _beab !=nil {_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_beab );
return _beab ;};};};if _ggg ._bbba !=nil {_cegf :=_ggg ._bbba (&_fdde );if _cegf !=nil {_d .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cegf );return _cegf ;};};for _ ,_fdeb :=range _ggg ._caa {_edcce :=_fdde .AddPage (_fdeb );
if _edcce !=nil {_d .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_edcce );return _edcce ;};};_eadd :=_fdde .Write (ws );if _eadd !=nil {return _eadd ;};return nil ;
};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_gafg *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_bdgd *_db .PdfWriter )error ){_gafg ._bbba =pdfWriterAccessFunc ;};func (_ffcb *TextStyle )horizontalScale ()float64 {return _ffcb .HorizontalScaling /100};

// DrawFooter sets a function to draw a footer on created output pages.
func (_cfaa *Creator )DrawFooter (drawFooterFunc func (_agfd *Block ,_fddc FooterFunctionArgs )){_cfaa ._eec =drawFooterFunc ;};

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_dgda *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _aega (xc ,yc ,width ,height );};func (_eeaca *TableCell )width (_eaac []float64 ,_dedc float64 )float64 {_egda :=float64 (0.0);for _cgecf :=0;_cgecf < _eeaca ._egba ;_cgecf ++{_egda +=_eaac [_eeaca ._bcea +_cgecf -1];
};return _egda *_dedc ;};func (_bcfc *Division )drawBackground (_edecb []*Block ,_ggba ,_fga DrawContext ,_cfba bool )([]*Block ,error ){_gbcfd :=len (_edecb );if _gbcfd ==0||_bcfc ._cgeg ==nil {return _edecb ,nil ;};_bcfb :=make ([]*Block ,0,len (_edecb ));
for _ffddg ,_acaef :=range _edecb {var (_gcee =_bcfc ._cgeg .BorderRadiusTopLeft ;_dbba =_bcfc ._cgeg .BorderRadiusTopRight ;_baca =_bcfc ._cgeg .BorderRadiusBottomLeft ;_bbec =_bcfc ._cgeg .BorderRadiusBottomRight ;);_befce :=_ggba ;_befce .Page +=_ffddg ;
if _ffddg ==0{if _cfba {_bcfb =append (_bcfb ,_acaef );continue ;};if _gbcfd ==1{_befce .Height =_fga .Y -_ggba .Y ;};}else {_befce .X =_befce .Margins .Left +_bcfc ._caeg .Left ;_befce .Y =_befce .Margins .Top ;_befce .Width =_befce .PageWidth -_befce .Margins .Left -_befce .Margins .Right -_bcfc ._caeg .Left -_bcfc ._caeg .Right ;
if _ffddg ==_gbcfd -1{_befce .Height =_fga .Y -_befce .Margins .Top -_bcfc ._caeg .Top ;}else {_befce .Height =_befce .PageHeight -_befce .Margins .Top -_befce .Margins .Bottom ;};if !_cfba {_gcee =0;_dbba =0;};};if _gbcfd > 1&&_ffddg !=_gbcfd -1{_baca =0;
_bbec =0;};_agd :=_cdddd (_befce .X ,_befce .Y ,_befce .Width ,_befce .Height );_agd .SetFillColor (_bcfc ._cgeg .FillColor );_agd .SetBorderColor (_bcfc ._cgeg .BorderColor );_agd .SetBorderWidth (_bcfc ._cgeg .BorderSize );_agd .SetBorderRadius (_gcee ,_dbba ,_baca ,_bbec );
_dgga ,_ ,_edeb :=_agd .GeneratePageBlocks (_befce );if _edeb !=nil {return nil ,_edeb ;};if len (_dgga )==0{continue ;};_cbcfc :=_dgga [0];if _edeb =_cbcfc .mergeBlocks (_acaef );_edeb !=nil {return nil ,_edeb ;};_bcfb =append (_bcfb ,_cbcfc );};return _bcfb ,nil ;
};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_fbfeg *TOC )SetLineTitleStyle (style TextStyle ){_fbfeg ._becab =style };func _faeg ()*FilledCurve {_gedeg :=FilledCurve {};_gedeg ._aae =[]_fg .CubicBezierCurve {};return &_gedeg ;};

// SetPos sets absolute positioning with specified coordinates.
func (_cgdc *Paragraph )SetPos (x ,y float64 ){_cgdc ._bdbg =PositionAbsolute ;_cgdc ._ecaa =x ;_cgdc ._ecega =y ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cddgf *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _cddgf ._afcd [0],_cddgf ._afcd [1];};

// Width returns the width of the specified text chunk.
func (_ecdac *TextChunk )Width ()float64 {var (_eaebfb float64 ;_dcdd =_ecdac .Style ;);for _ ,_bccdc :=range _ecdac .Text {_cfcf ,_cdddc :=_dcdd .Font .GetRuneMetrics (_bccdc );if !_cdddc {_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_bccdc ,_bccdc ,_dcdd .Font .BaseFont (),_dcdd .Font .Subtype ());
_d .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_dcdd .Font );_d .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_dcdd .Font .Encoder ());};_gdada :=_dcdd .FontSize *_cfcf .Wx ;_gcddeb :=_gdada ;if _bccdc !=' '{_gcddeb =_gdada +_dcdd .CharSpacing *1000.0;
};_eaebfb +=_gcddeb ;};return _eaebfb /1000.0;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_bfa *Block )ScaleToHeight (h float64 ){_cdd :=h /_bfa ._ef ;_bfa .Scale (_cdd ,_cdd )};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_adaeb *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _adaeb ._bbae ,_adaeb ._effb ,_adaeb ._aafcb ,_adaeb ._affa ;};

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;func (_addc *StyledParagraph )wrapChunks (_dgfe bool )error {if !_addc ._bbff ||int (_addc ._baaga )<=0{_addc ._ebgc =[][]*TextChunk {_addc ._cdegd };return nil ;};if _addc ._aegab {_addc .wrapWordChunks ();};_addc ._ebgc =[][]*TextChunk {};
var _efde []*TextChunk ;var _cbac float64 ;_cfcga :=_ff .IsSpace ;if !_dgfe {_cfcga =func (rune )bool {return false };};_ebgf :=_ddee (_addc ._baaga *1000.0,0.000001);for _ ,_eecfc :=range _addc ._cdegd {_bfbf :=_eecfc .Style ;_cebaa :=_eecfc ._fedb ;_begg :=_eecfc .VerticalAlignment ;
var (_fgca []rune ;_dcgb []float64 ;);_dbcc :=_afgf (_eecfc .Text );for _ ,_dbgfa :=range _eecfc .Text {if _dbgfa =='\u000A'{if !_dgfe {_fgca =append (_fgca ,_dbgfa );};_efde =append (_efde ,&TextChunk {Text :_cc .TrimRightFunc (string (_fgca ),_cfcga ),Style :_bfbf ,_fedb :_cbfbe (_cebaa ),VerticalAlignment :_begg });
_addc ._ebgc =append (_addc ._ebgc ,_efde );_efde =nil ;_cbac =0;_fgca =nil ;_dcgb =nil ;continue ;};_acad :=_dbgfa ==' ';_dbbde ,_fcebf :=_bfbf .Font .GetRuneMetrics (_dbgfa );if _dbbde .Wx ==0&&_bfbf .MultiFont !=nil ||_bfbf .MultiFont !=nil &&!_fcebf {_dbbde ,_fcebf =_bfbf .MultiFont .GetRuneMetrics (_dbgfa );
};if !_fcebf {_d .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dbgfa );return _ab .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_ebfe :=_bfbf .FontSize *_dbbde .Wx *_bfbf .horizontalScale ();_dgaa :=_ebfe ;if !_acad {_dgaa =_ebfe +_bfbf .CharSpacing *1000.0;};if _cbac +_ebfe > _ebgf {_ebbb :=-1;if !_acad {for _gecb :=len (_fgca )-1;_gecb >=0;_gecb --{if _fgca [_gecb ]==' '{_ebbb =_gecb ;
break ;};};};if _addc ._aegab {_baebb :=len (_efde );if _baebb > 0{_efde [_baebb -1].Text =_cc .TrimRightFunc (_efde [_baebb -1].Text ,_cfcga );_addc ._ebgc =append (_addc ._ebgc ,_efde );_efde =[]*TextChunk {};};_fgca =append (_fgca ,_dbgfa );_dcgb =append (_dcgb ,_dgaa );
if _ebbb >=0{_fgca =_fgca [_ebbb +1:];_dcgb =_dcgb [_ebbb +1:];};_cbac =0;for _ ,_efdg :=range _dcgb {_cbac +=_efdg ;};if _cbac > _ebgf {_dabbd :=string (_fgca [:len (_fgca )-1]);_dabbd =_ebcab (_dabbd ,_dbcc );if !_dgfe &&_acad {_dabbd +="\u0020";};_efde =append (_efde ,&TextChunk {Text :_cc .TrimRightFunc (_dabbd ,_cfcga ),Style :_bfbf ,_fedb :_cbfbe (_cebaa ),VerticalAlignment :_begg });
_addc ._ebgc =append (_addc ._ebgc ,_efde );_efde =[]*TextChunk {};_fgca =[]rune {_dbgfa };_dcgb =[]float64 {_dgaa };_cbac =_dgaa ;};continue ;};_fbbac :=string (_fgca );if _ebbb >=0{_fbbac =string (_fgca [0:_ebbb +1]);_fgca =_fgca [_ebbb +1:];_fgca =append (_fgca ,_dbgfa );
_dcgb =_dcgb [_ebbb +1:];_dcgb =append (_dcgb ,_dgaa );_cbac =0;for _ ,_fagc :=range _dcgb {_cbac +=_fagc ;};}else {if _acad {_cbac =0;_fgca =[]rune {};_dcgb =[]float64 {};}else {_cbac =_dgaa ;_fgca =[]rune {_dbgfa };_dcgb =[]float64 {_dgaa };};};_fbbac =_ebcab (_fbbac ,_dbcc );
if !_dgfe &&_acad {_fbbac +="\u0020";};_efde =append (_efde ,&TextChunk {Text :_cc .TrimRightFunc (_fbbac ,_cfcga ),Style :_bfbf ,_fedb :_cbfbe (_cebaa ),VerticalAlignment :_begg });_addc ._ebgc =append (_addc ._ebgc ,_efde );_efde =[]*TextChunk {};}else {_cbac +=_dgaa ;
_fgca =append (_fgca ,_dbgfa );_dcgb =append (_dcgb ,_dgaa );};};if len (_fgca )> 0{_caadc :=_ebcab (string (_fgca ),_dbcc );_efde =append (_efde ,&TextChunk {Text :_caadc ,Style :_bfbf ,_fedb :_cbfbe (_cebaa ),VerticalAlignment :_begg });};};if len (_efde )> 0{_addc ._ebgc =append (_addc ._ebgc ,_efde );
};return nil ;};

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_gcdgb *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_gcdgb ._fbcgf .Left =left ;_gcdgb ._fbcgf .Right =right ;_gcdgb ._fbcgf .Top =top ;_gcdgb ._fbcgf .Bottom =bottom ;};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_bgaca *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_bgaca ._gdca =valign };

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_cebgg *Rectangle )GetCoords ()(float64 ,float64 ){return _cebgg ._dbgeg ,_cebgg ._gead };

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_cdfc *_fg .Polygon ;_bcdc float64 ;_geeda float64 ;_cdfa Color ;};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_gcdf *Line )SetColor (color Color ){_gcdf ._ccg =color };

// SetBorderOpacity sets the border opacity.
func (_bcfa *CurvePolygon )SetBorderOpacity (opacity float64 ){_bcfa ._egaf =opacity };

// Positioning returns the type of positioning the line is set to use.
func (_ffbc *Line )Positioning ()Positioning {return _ffbc ._fdgb };

// SetMargins sets the margins of the paragraph.
func (_cdddg *List )SetMargins (left ,right ,top ,bottom float64 ){_cdddg ._ebdfg .Left =left ;_cdddg ._ebdfg .Right =right ;_cdddg ._ebdfg .Top =top ;_cdddg ._ebdfg .Bottom =bottom ;};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_ffag *Ellipse )BorderOpacity ()float64 {return _ffag ._gdef };

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_cfa *Chart )SetPos (x ,y float64 ){_cfa ._aeee =PositionAbsolute ;_cfa ._defe =x ;_cfa ._acf =y };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_bgdc *Creator )NewTextStyle ()TextStyle {return _cdca (_bgdc ._gef )};func (_edef *RadialShading )shadingModel ()*_db .PdfShadingType3 {_cbca ,_deee ,_babd :=_edef ._cgec ._gccca .ToRGB ();var _geeab _fg .Point ;switch _edef ._afad {case AnchorBottomLeft :_geeab =_fg .Point {X :_edef ._fbagg .Llx ,Y :_edef ._fbagg .Lly };
case AnchorBottomRight :_geeab =_fg .Point {X :_edef ._fbagg .Urx ,Y :_edef ._fbagg .Ury -_edef ._fbagg .Height ()};case AnchorTopLeft :_geeab =_fg .Point {X :_edef ._fbagg .Llx ,Y :_edef ._fbagg .Lly +_edef ._fbagg .Height ()};case AnchorTopRight :_geeab =_fg .Point {X :_edef ._fbagg .Urx ,Y :_edef ._fbagg .Ury };
case AnchorLeft :_geeab =_fg .Point {X :_edef ._fbagg .Llx ,Y :_edef ._fbagg .Lly +_edef ._fbagg .Height ()/2};case AnchorTop :_geeab =_fg .Point {X :_edef ._fbagg .Llx +_edef ._fbagg .Width ()/2,Y :_edef ._fbagg .Ury };case AnchorRight :_geeab =_fg .Point {X :_edef ._fbagg .Urx ,Y :_edef ._fbagg .Lly +_edef ._fbagg .Height ()/2};
case AnchorBottom :_geeab =_fg .Point {X :_edef ._fbagg .Urx +_edef ._fbagg .Width ()/2,Y :_edef ._fbagg .Lly };default:_geeab =_fg .NewPoint (_edef ._fbagg .Llx +_edef ._fbagg .Width ()/2,_edef ._fbagg .Lly +_edef ._fbagg .Height ()/2);};_bgcb :=_edef ._beea ;
_acdab :=_edef ._edfc ;_gaffb :=_geeab .X +_edef ._cfad ;_efead :=_geeab .Y +_edef ._gabfd ;if _bgcb ==-1.0{_bgcb =0.0;};if _acdab ==-1.0{var _bbeb []float64 ;_dfeg :=_gb .Pow (_gaffb -_edef ._fbagg .Llx ,2)+_gb .Pow (_efead -_edef ._fbagg .Lly ,2);_bbeb =append (_bbeb ,_gb .Abs (_dfeg ));
_dcafc :=_gb .Pow (_gaffb -_edef ._fbagg .Llx ,2)+_gb .Pow (_edef ._fbagg .Lly +_edef ._fbagg .Height ()-_efead ,2);_bbeb =append (_bbeb ,_gb .Abs (_dcafc ));_aegeg :=_gb .Pow (_edef ._fbagg .Urx -_gaffb ,2)+_gb .Pow (_efead -_edef ._fbagg .Ury -_edef ._fbagg .Height (),2);
_bbeb =append (_bbeb ,_gb .Abs (_aegeg ));_ddaf :=_gb .Pow (_edef ._fbagg .Urx -_gaffb ,2)+_gb .Pow (_edef ._fbagg .Ury -_efead ,2);_bbeb =append (_bbeb ,_gb .Abs (_ddaf ));_c .Slice (_bbeb ,func (_faagg ,_agae int )bool {return _faagg > _agae });_acdab =_gb .Sqrt (_bbeb [0]);
};_agbc :=&_db .PdfRectangle {Llx :_gaffb -_acdab ,Lly :_efead -_acdab ,Urx :_gaffb +_acdab ,Ury :_efead +_acdab };_cfcb :=_db .NewPdfShadingType3 ();_cfcb .PdfShading .ShadingType =_ag .MakeInteger (3);_cfcb .PdfShading .ColorSpace =_db .NewPdfColorspaceDeviceRGB ();
_cfcb .PdfShading .Background =_ag .MakeArrayFromFloats ([]float64 {_cbca ,_deee ,_babd });_cfcb .PdfShading .BBox =_agbc ;_cfcb .PdfShading .AntiAlias =_ag .MakeBool (_edef ._cgec ._cgfde );_cfcb .Coords =_ag .MakeArrayFromFloats ([]float64 {_gaffb ,_efead ,_bgcb ,_gaffb ,_efead ,_acdab });
_cfcb .Domain =_ag .MakeArrayFromFloats ([]float64 {0.0,1.0});_cfcb .Extend =_ag .MakeArray (_ag .MakeBool (_edef ._cgec ._gagd [0]),_ag .MakeBool (_edef ._cgec ._gagd [1]));_cfcb .Function =_edef ._cgec .generatePdfFunctions ();return _cfcb ;};

// SetBorderColor sets the border color.
func (_edbdf *CurvePolygon )SetBorderColor (color Color ){_edbdf ._bbdae .BorderColor =_afb (color )};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_acce *Creator )NewStyledParagraph ()*StyledParagraph {return _gfbe (_acce .NewTextStyle ())};func _ebcab (_ceabc string ,_begbg bool )string {_cgfbg :=_ceabc ;if _cgfbg ==""{return "";};_agbg :=_cb .Paragraph {};_ ,_dcegcd :=_agbg .SetString (_ceabc );
if _dcegcd !=nil {return _cgfbg ;};_fbagb ,_dcegcd :=_agbg .Order ();if _dcegcd !=nil {return _cgfbg ;};_afeba :=_fbagb .NumRuns ();_gebcdc :=make ([]string ,_afeba );for _ggfad :=0;_ggfad < _fbagb .NumRuns ();_ggfad ++{_eaddb :=_fbagb .Run (_ggfad );_badb :=_eaddb .String ();
if _eaddb .Direction ()==_cb .RightToLeft {_badb =_cb .ReverseString (_badb );};if _begbg {_gebcdc [_ggfad ]=_badb ;}else {_gebcdc [_afeba -1]=_badb ;};_afeba --;};if len (_gebcdc )!=_fbagb .NumRuns (){return _ceabc ;};_cgfbg =_cc .Join (_gebcdc ,"");return _cgfbg ;
};

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_begc *Table )MultiRowCell (rowspan int )*TableCell {return _begc .MultiCell (rowspan ,1)};

// SetFillOpacity sets the fill opacity.
func (_befced *Polygon )SetFillOpacity (opacity float64 ){_befced ._bcdc =opacity };

// SetFillColor sets the fill color.
func (_ecdd *Polygon )SetFillColor (color Color ){_ecdd ._cdfa =color ;_ecdd ._cdfc .FillColor =_afb (color );};func (_gfdg *Invoice )generateLineBlocks (_gbae DrawContext )([]*Block ,DrawContext ,error ){_abcb :=_eedb (len (_gfdg ._cbfcg ));_abcb .SetMargins (0,0,25,0);
for _ ,_fbgff :=range _gfdg ._cbfcg {_fgeda :=_gfbe (_fbgff .TextStyle );_fgeda .SetMargins (0,0,1,0);_fgeda .Append (_fbgff .Value );_bcca :=_abcb .NewCell ();_bcca .SetHorizontalAlignment (_fbgff .Alignment );_bcca .SetBackgroundColor (_fbgff .BackgroundColor );
_gfdg .setCellBorder (_bcca ,_fbgff );_bcca .SetContent (_fgeda );};for _ ,_baag :=range _gfdg ._ddfgc {for _ ,_cafaf :=range _baag {_cfcad :=_gfbe (_cafaf .TextStyle );_cfcad .SetMargins (0,0,3,2);_cfcad .Append (_cafaf .Value );_bagf :=_abcb .NewCell ();
_bagf .SetHorizontalAlignment (_cafaf .Alignment );_bagf .SetBackgroundColor (_cafaf .BackgroundColor );_gfdg .setCellBorder (_bagf ,_cafaf );_bagf .SetContent (_cfcad );};};return _abcb .GeneratePageBlocks (_gbae );};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// NewPolyline creates a new polyline.
func (_ffg *Creator )NewPolyline (points []_fg .Point )*Polyline {return _bega (points )};

// SetBorderColor sets the border color.
func (_bbgb *Polygon )SetBorderColor (color Color ){_bbgb ._cdfc .BorderColor =_afb (color )};

// CreateTableOfContents sets a function to generate table of contents.
func (_fcgd *Creator )CreateTableOfContents (genTOCFunc func (_fbde *TOC )error ){_fcgd ._gabg =genTOCFunc ;};

// SetColorRight sets border color for right.
func (_bfdd *border )SetColorRight (col Color ){_bfdd ._ccba =col };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_adffb *Image )ScaleToWidth (w float64 ){_aeae :=_adffb ._gafb /_adffb ._daba ;_adffb ._daba =w ;_adffb ._gafb =w *_aeae ;};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_bcdg *Ellipse )SetFitMode (fitMode FitMode ){_bcdg ._bbf =fitMode };

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_bedbg *TOC )SetLineLevelOffset (levelOffset float64 ){_bedbg ._egab =levelOffset };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_dffee *Creator )Finalize ()error {if _dffee ._edge {return nil ;};_eefb :=len (_dffee ._caa );_dfffd :=0;if _dffee ._cecc !=nil {_cdcdd :=*_dffee ;_dffee ._caa =nil ;_dffee ._gge =nil ;_dffee .initContext ();_bfbe :=FrontpageFunctionArgs {PageNum :1,TotalPages :_eefb };
_dffee ._cecc (_bfbe );_dfffd +=len (_dffee ._caa );_dffee ._caa =_cdcdd ._caa ;_dffee ._gge =_cdcdd ._gge ;};if _dffee .AddTOC {_dffee .initContext ();_dffee ._edg .Page =_dfffd +1;if _dffee .CustomTOC &&_dffee ._gabg !=nil {_bgfg :=*_dffee ;_dffee ._caa =nil ;
_dffee ._gge =nil ;if _aafc :=_dffee ._gabg (_dffee ._gcad );_aafc !=nil {return _aafc ;};_dfffd +=len (_dffee ._caa );_dffee ._caa =_bgfg ._caa ;_dffee ._gge =_bgfg ._gge ;}else {if _dffee ._gabg !=nil {if _eaba :=_dffee ._gabg (_dffee ._gcad );_eaba !=nil {return _eaba ;
};};_ced ,_ ,_ffaf :=_dffee ._gcad .GeneratePageBlocks (_dffee ._edg );if _ffaf !=nil {_d .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_ffaf );
return _ffaf ;};_dfffd +=len (_ced );};_gfgc :=_dffee ._gcad .Lines ();for _ ,_fcaf :=range _gfgc {_ffdg ,_geee :=_eg .Atoi (_fcaf .Page .Text );if _geee !=nil {continue ;};_fcaf .Page .Text =_eg .Itoa (_ffdg +_dfffd );_fcaf ._gaecg +=int64 (_dfffd );};
};_aded :=false ;var _dgbcd []*_db .PdfPage ;if _dffee ._cecc !=nil {_bgge :=*_dffee ;_dffee ._caa =nil ;_dffee ._gge =nil ;_edbd :=FrontpageFunctionArgs {PageNum :1,TotalPages :_eefb };_dffee ._cecc (_edbd );_eefb +=len (_dffee ._caa );_dgbcd =_dffee ._caa ;
_dffee ._caa =append (_dffee ._caa ,_bgge ._caa ...);_dffee ._gge =_bgge ._gge ;_aded =true ;};var _beb []*_db .PdfPage ;if _dffee .AddTOC {_dffee .initContext ();if _dffee .CustomTOC &&_dffee ._gabg !=nil {_daga :=*_dffee ;_dffee ._caa =nil ;_dffee ._gge =nil ;
if _cfdd :=_dffee ._gabg (_dffee ._gcad );_cfdd !=nil {_d .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_cfdd );return _cfdd ;};_beb =_dffee ._caa ;
_eefb +=len (_beb );_dffee ._caa =_daga ._caa ;_dffee ._gge =_daga ._gge ;}else {if _dffee ._gabg !=nil {if _bga :=_dffee ._gabg (_dffee ._gcad );_bga !=nil {_d .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_bga );
return _bga ;};};_cdda ,_ ,_ :=_dffee ._gcad .GeneratePageBlocks (_dffee ._edg );for _ ,_aabg :=range _cdda {_aabg .SetPos (0,0);_eefb ++;_cgfbd :=_dffee .newPage ();_beb =append (_beb ,_cgfbd );_dffee .setActivePage (_cgfbd );_dffee .Draw (_aabg );};};
if _aded {_ebcgf :=_dgbcd ;_bgd :=_dffee ._caa [len (_dgbcd ):];_dffee ._caa =append ([]*_db .PdfPage {},_ebcgf ...);_dffee ._caa =append (_dffee ._caa ,_beb ...);_dffee ._caa =append (_dffee ._caa ,_bgd ...);}else {_dffee ._caa =append (_beb ,_dffee ._caa ...);
};};if _dffee ._gbcf !=nil &&_dffee .AddOutlines {var _gede func (_dgea *_db .OutlineItem );_gede =func (_bgfgd *_db .OutlineItem ){_bgfgd .Dest .Page +=int64 (_dfffd );if _bcbc :=int (_bgfgd .Dest .Page );_bcbc >=0&&_bcbc < len (_dffee ._caa ){_bgfgd .Dest .PageObj =_dffee ._caa [_bcbc ].GetPageAsIndirectObject ();
}else {_d .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_bcbc );
};_bgfgd .Dest .Y =_dffee ._cfaf -_bgfgd .Dest .Y ;_afce :=_bgfgd .Items ();for _ ,_bcf :=range _afce {_gede (_bcf );};};_cgcga :=_dffee ._gbcf .Items ();for _ ,_edcc :=range _cgcga {_gede (_edcc );};if _dffee .AddTOC {var _bdcg int ;if _aded {_bdcg =len (_dgbcd );
};_geac :=_db .NewOutlineDest (int64 (_bdcg ),0,_dffee ._cfaf );if _bdcg >=0&&_bdcg < len (_dffee ._caa ){_geac .PageObj =_dffee ._caa [_bdcg ].GetPageAsIndirectObject ();}else {_d .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_bdcg );
};_dffee ._gbcf .Insert (0,_db .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_geac ));};};for _acb ,_cff :=range _dffee ._caa {_dffee .setActivePage (_cff );if _dffee ._ffdd !=nil {_badec ,_dfce ,_aebd :=_cff .Size ();
if _aebd !=nil {return _aebd ;};_ggd :=PageFinalizeFunctionArgs {PageNum :_acb +1,PageWidth :_badec ,PageHeight :_dfce ,TOCPages :len (_beb ),TotalPages :_eefb };if _caf :=_dffee ._ffdd (_ggd );_caf !=nil {_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_caf );
return _caf ;};};if _dffee ._dffe !=nil {_edbe :=NewBlock (_dffee ._gcac ,_dffee ._bbgd .Top );_egc :=HeaderFunctionArgs {PageNum :_acb +1,TotalPages :_eefb };_dffee ._dffe (_edbe ,_egc );_edbe .SetPos (0,0);if _gddc :=_dffee .Draw (_edbe );_gddc !=nil {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_gddc );
return _gddc ;};};if _dffee ._eec !=nil {_cdeg :=NewBlock (_dffee ._gcac ,_dffee ._bbgd .Bottom );_ffafd :=FooterFunctionArgs {PageNum :_acb +1,TotalPages :_eefb };_dffee ._eec (_cdeg ,_ffafd );_cdeg .SetPos (0,_dffee ._cfaf -_cdeg ._ef );if _bebc :=_dffee .Draw (_cdeg );
_bebc !=nil {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_bebc );return _bebc ;};};_adeb ,_gegf :=_dffee ._fcgg [_cff ];if _addf ,_cace :=_dffee ._cdcc [_cff ];
_cace {if _gegf {_adeb .transformBlock (_addf );};if _gbgf :=_addf .drawToPage (_cff );_gbgf !=nil {_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_acb +1,_gbgf );
return _gbgf ;};};if _gegf {if _bccc :=_adeb .transformPage (_cff );_bccc !=nil {_d .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_bccc );
return _bccc ;};};};_dffee ._edge =true ;return nil ;};const (FitModeNone FitMode =iota ;FitModeFillWidth ;);var (_ccfaa =_ffd .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");_ccea =_ab .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");
_cdfg =_ab .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");_ecdeb =_ab .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");
_fedae =_ab .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e"););

// Rows returns the total number of rows the table has.
func (_dcfb *Table )Rows ()int {return _dcfb ._dgdc };

// SetCoords sets the center coordinates of the ellipse.
func (_efegd *Ellipse )SetCoords (xc ,yc float64 ){_efegd ._ddag =xc ;_efegd ._gabf =yc };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_bbda *Creator )MoveRight (dx float64 ){_bbda ._edg .X +=dx };

// NewFilledCurve returns a instance of filled curve.
func (_dbc *Creator )NewFilledCurve ()*FilledCurve {return _faeg ()};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};func _ebff (_dddb TextStyle )*List {return &List {_gccff :TextChunk {Text :"\u2022\u0020",Style :_dddb },_adge :0,_gfbf :true ,_cbgae :PositionRelative ,_fcad :_dddb };};

// Lines returns all the lines the table of contents has.
func (_dcfd *TOC )Lines ()[]*TOCLine {return _dcfd ._bcaf };func (_gbefc *templateProcessor )parseRectangle (_dabd *templateNode )(interface{},error ){_aaefc :=_gbefc .creator .NewRectangle (0,0,0,0);for _ ,_adedd :=range _dabd ._fabca .Attr {_dddbc :=_adedd .Value ;
switch _ddab :=_adedd .Name .Local ;_ddab {case "\u0078":_aaefc ._dbgeg =_gbefc .parseFloatAttr (_ddab ,_dddbc );case "\u0079":_aaefc ._gead =_gbefc .parseFloatAttr (_ddab ,_dddbc );case "\u0077\u0069\u0064t\u0068":_aaefc .SetWidth (_gbefc .parseFloatAttr (_ddab ,_dddbc ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_aaefc .SetHeight (_gbefc .parseFloatAttr (_ddab ,_dddbc ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_aaefc .SetFillColor (_gbefc .parseColorAttr (_ddab ,_dddbc ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_aaefc .SetFillOpacity (_gbefc .parseFloatAttr (_ddab ,_dddbc ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_aaefc .SetBorderColor (_gbefc .parseColorAttr (_ddab ,_dddbc ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_aaefc .SetBorderOpacity (_gbefc .parseFloatAttr (_ddab ,_dddbc ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_aaefc .SetBorderWidth (_gbefc .parseFloatAttr (_ddab ,_dddbc ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_dgcdd ,_cbcg ,_adcag ,_fecdd :=_gbefc .parseBorderRadiusAttr (_ddab ,_dddbc );
_aaefc .SetBorderRadius (_dgcdd ,_cbcg ,_fecdd ,_adcag );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_aaefc ._cdbc =_gbefc .parseFloatAttr (_ddab ,_dddbc );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_aaefc ._eaebb =_gbefc .parseFloatAttr (_ddab ,_dddbc );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_aaefc ._fgfgg =_gbefc .parseFloatAttr (_ddab ,_dddbc );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_aaefc ._cdege =_gbefc .parseFloatAttr (_ddab ,_dddbc );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_aaefc .SetPositioning (_gbefc .parsePositioningAttr (_ddab ,_dddbc ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_aaefc .SetFitMode (_gbefc .parseFitModeAttr (_ddab ,_dddbc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_abfd :=_gbefc .parseMarginAttr (_ddab ,_dddbc );
_aaefc .SetMargins (_abfd .Left ,_abfd .Right ,_abfd .Top ,_abfd .Bottom );default:_gbefc .nodeLogDebug (_dabd ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_ddab );
};};return _aaefc ,nil ;};func (_aaga *Invoice )newColumn (_cefd string ,_bcg CellHorizontalAlignment )*InvoiceCell {_cfcg :=&InvoiceCell {_aaga ._bggd ,_cefd };_cfcg .Alignment =_bcg ;return _cfcg ;};func (_fbgfb *StyledParagraph )wrapText ()error {return _fbgfb .wrapChunks (true )};


// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_efbga *LinearShading )AddPatternResource (block *Block )(_ddadd _ag .PdfObjectName ,_abfb error ){_cgee :=1;_afgae :=_ag .PdfObjectName ("\u0050"+_eg .Itoa (_cgee ));for block ._aef .HasPatternByName (_afgae ){_cgee ++;_afgae =_ag .PdfObjectName ("\u0050"+_eg .Itoa (_cgee ));
};if _eebb :=block ._aef .SetPatternByName (_afgae ,_efbga .ToPdfShadingPattern ().ToPdfObject ());_eebb !=nil {return "",_eebb ;};return _afgae ,nil ;};

// SetColPosition sets cell column position.
func (_fgae *TableCell )SetColPosition (col int ){_fgae ._bcea =col };func _gdae (_ecea string )(*Image ,error ){_deff ,_ceda :=_ae .Open (_ecea );if _ceda !=nil {return nil ,_ceda ;};defer _deff .Close ();_aaae ,_ceda :=_db .ImageHandling .Read (_deff );
if _ceda !=nil {_d .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ceda );return nil ,_ceda ;};return _aaceg (_aaae );};

// IsRelative checks if the positioning is relative.
func (_dcbc Positioning )IsRelative ()bool {return _dcbc ==PositionRelative };

// Horizontal returns total horizontal (left + right) margin.
func (_ebca *Margins )Horizontal ()float64 {return _ebca .Left +_ebca .Right };

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_cfgb *Rectangle )FillOpacity ()float64 {return _cfgb ._dgab };func (_ebef *StyledParagraph )getTextHeight ()float64 {var _adfg float64 ;for _ ,_cggea :=range _ebef ._cdegd {_bacc :=_cggea .Style .FontSize *_ebef ._gfae ;if _bacc > _adfg {_adfg =_bacc ;
};};return _adfg ;};

// NewCurvePolygon creates a new curve polygon.
func (_edeab *Creator )NewCurvePolygon (rings [][]_fg .CubicBezierCurve )*CurvePolygon {return _defc (rings );};

// SetEnableWrap sets the line wrapping enabled flag.
func (_agacb *Paragraph )SetEnableWrap (enableWrap bool ){_agacb ._aacg =enableWrap ;_agacb ._ggbaa =false ;};

// SetLineColor sets the line color.
func (_cdec *Polyline )SetLineColor (color Color ){_cdec ._defeg .LineColor =_afb (color )};func _dbfa (_cegb []byte )(*Image ,error ){_bffb :=_g .NewReader (_cegb );_gegbb ,_bdbb :=_db .ImageHandling .Read (_bffb );if _bdbb !=nil {_d .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bdbb );
return nil ,_bdbb ;};return _aaceg (_gegbb );};

// ColorGrayFromArithmetic creates a Color from a grayscale value (0-1).
// Example:
//
//	gray := ColorGrayFromArithmetic(0.7)
func ColorGrayFromArithmetic (g float64 )Color {return grayColor {g }};var PPMM =float64 (72*1.0/25.4);

// GetOptimizer returns current PDF optimizer.
func (_fdad *Creator )GetOptimizer ()_db .Optimizer {return _fdad ._egdg };

// Scale block by specified factors in the x and y directions.
func (_gd *Block )Scale (sx ,sy float64 ){_ebf :=_cf .NewContentCreator ().Scale (sx ,sy ).Operations ();*_gd ._bag =append (*_ebf ,*_gd ._bag ...);_gd ._bag .WrapIfNeeded ();_gd ._bc *=sx ;_gd ._ef *=sy ;};

// SetStyleBottom sets border style for bottom side.
func (_agca *border )SetStyleBottom (style CellBorderStyle ){_agca ._egdc =style };var _cda =_ffd .MustCompile ("\u005c\u0064\u002b");

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_gfba *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_edecd :=NewTextChunk (text ,_gfba ._abba );_edecd ._fedb =_agea (url );return _gfba .appendChunk (_edecd );};

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_bbef *Rectangle )Width ()float64 {return _bbef ._bccac };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_eceg *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fgbda :=ctx ;_aaed :=[]func (_cggca DrawContext )([]*Block ,DrawContext ,error ){_eceg .generateHeaderBlocks ,_eceg .generateInformationBlocks ,_eceg .generateLineBlocks ,_eceg .generateTotalBlocks ,_eceg .generateNoteBlocks };
var _aeaaf []*Block ;for _ ,_ffedg :=range _aaed {_cddd ,_cgbc ,_eeag :=_ffedg (ctx );if _eeag !=nil {return _aeaaf ,ctx ,_eeag ;};if len (_aeaaf )==0{_aeaaf =_cddd ;}else if len (_cddd )> 0{_aeaaf [len (_aeaaf )-1].mergeBlocks (_cddd [0]);_aeaaf =append (_aeaaf ,_cddd [1:]...);
};ctx =_cgbc ;};if _eceg ._bgfb .IsRelative (){ctx .X =_fgbda .X ;};if _eceg ._bgfb .IsAbsolute (){return _aeaaf ,_fgbda ,nil ;};return _aeaaf ,ctx ,nil ;};

// Length calculates and returns the length of the line.
func (_bcba *Line )Length ()float64 {return _gb .Sqrt (_gb .Pow (_bcba ._aafcb -_bcba ._bbae ,2.0)+_gb .Pow (_bcba ._affa -_bcba ._effb ,2.0));};func (_cea *Creator )newPage ()*_db .PdfPage {_bfca :=_db .NewPdfPage ();_eeeb :=_cea ._fecg [0];_fabc :=_cea ._fecg [1];
_dde :=_db .PdfRectangle {Llx :0,Lly :0,Urx :_eeeb ,Ury :_fabc };_bfca .MediaBox =&_dde ;_cea ._gcac =_eeeb ;_cea ._cfaf =_fabc ;_cea .initContext ();return _bfca ;};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_cabc *shading )SetBackgroundColor (backgroundColor Color ){_cabc ._gccca =backgroundColor };func _bada (_afcb *_db .PdfRectangle ,_gbgcb _eaa .Matrix )*_db .PdfRectangle {var _gcebb _db .PdfRectangle ;_gcebb .Llx ,_gcebb .Lly =_gbgcb .Transform (_afcb .Llx ,_afcb .Lly );
_gcebb .Urx ,_gcebb .Ury =_gbgcb .Transform (_afcb .Urx ,_afcb .Ury );_gcebb .Normalize ();return &_gcebb ;};

// Level returns the indentation level of the TOC line.
func (_dfbf *TOCLine )Level ()uint {return _dfbf ._fbgga };

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_db .PdfPage )(*Block ,error ){_ee :=&Block {};_gbb ,_df :=page .GetAllContentStreams ();if _df !=nil {return nil ,_df ;};_dfa :=_cf .NewContentStreamParser (_gbb );_gac ,_df :=_dfa .Parse ();if _df !=nil {return nil ,_df ;
};_gac .WrapIfNeeded ();_ee ._bag =_gac ;if page .Resources !=nil {_ee ._aef =page .Resources ;}else {_ee ._aef =_db .NewPdfPageResources ();};_cbe ,_df :=page .GetMediaBox ();if _df !=nil {return nil ,_df ;};if _cbe .Llx !=0||_cbe .Lly !=0{_ee .translate (-_cbe .Llx ,_cbe .Lly );
};_ee ._bc =_cbe .Urx -_cbe .Llx ;_ee ._ef =_cbe .Ury -_cbe .Lly ;if page .Rotate !=nil {_ee ._ga =-float64 (*page .Rotate );};return _ee ,nil ;};var _bedc =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_beec :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_affaee :_agfgb },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_beec :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_affaee :_dfcea },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_beec :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_affaee :_eagfb },"\u0074\u0061\u0062l\u0065":&templateTag {_beec :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_affaee :_faefa },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_beec :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_affaee :_ceac },"\u006c\u0069\u006e\u0065":&templateTag {_beec :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_affaee :_dbeb },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_beec :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_affaee :_gcdga },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_beec :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_affaee :_cdbfc },"\u0069\u006d\u0061g\u0065":&templateTag {_beec :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_affaee :_aebb },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_beec :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_affaee :_dcdbdg },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_beec :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_affaee :_bgfbb },"\u0063\u0068\u0061r\u0074":&templateTag {_beec :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_affaee :_ddcfe },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_beec :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_affaee :_dccfe },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_beec :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_affaee :_gcegd },"\u006c\u0069\u0073\u0074":&templateTag {_beec :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_affaee :_acaee },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_beec :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_affaee :_gdgf },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_beec :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_affaee :_fdeag }};


// NewList creates a new list.
func (_bdf *Creator )NewList ()*List {return _ebff (_bdf .NewTextStyle ())};func _dafdb (_cfbec float64 ,_beed float64 ,_ecbef float64 ,_cedag float64 ,_cbgg []*ColorPoint )*RadialShading {return &RadialShading {_cgec :&shading {_gccca :ColorWhite ,_cgfde :false ,_gagd :[]bool {false ,false },_fgcdg :_cbgg },_cfad :_cfbec ,_gabfd :_beed ,_beea :_ecbef ,_edfc :_cedag ,_afad :AnchorCenter };
};

// LineWidth returns the width of the line.
func (_eagd *Line )LineWidth ()float64 {return _eagd ._dgfab };

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_ccfd *Creator )DrawTemplate (r _ba .Reader ,data interface{},options *TemplateOptions )error {return _defac (_ccfd ,r ,data ,options ,_ccfd );};

// SetAnnotation sets a annotation on a TextChunk.
func (_dadb *TextChunk )SetAnnotation (annotation *_db .PdfAnnotation ){_dadb ._fedb =annotation };

// SkipOver skips over a specified number of rows and cols.
func (_gfaef *Table )SkipOver (rows ,cols int ){_cgaac :=rows *_gfaef ._cccbd +cols -1;if _cgaac < 0{_d .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _dbgc :=0;_dbgc < _cgaac ;_dbgc ++{_gfaef .NewCell ();};};

// ColorGrayFromHex converts color hex code to gray color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ff -> white.
func ColorGrayFromHex (hexStr string )Color {_cge :=grayColor {};if (len (hexStr )!=2&&len (hexStr )!=3)||hexStr [0]!='#'{_d .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cge ;
};var _dccb int ;if len (hexStr )==2{var _faf int ;_gabbc ,_edf :=_f .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078",&_faf );if _edf !=nil {_d .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_edf );
return _cge ;};if _gabbc !=1{_d .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cge ;};_dccb =_faf *16+_faf ;}else {_abgf ,_dccf :=_f .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078",&_dccb );
if _dccf !=nil {_d .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _cge ;};if _abgf !=1{_d .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_abgf );
return _cge ;};};_cge ._fffc =float64 (_dccb )/255.0;return _cge ;};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_gfddb *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_gfddb ._gabbd =align ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_gbad *Paragraph )Height ()float64 {_gbad .wrapText ();return float64 (len (_gbad ._fcfba ))*_gbad ._becfe *_gbad ._bbgda ;};func _ceec (_bdge *_ae .File )([]*_db .PdfPage ,error ){_fbcadd ,_ebede :=_db .NewPdfReader (_bdge );if _ebede !=nil {return nil ,_ebede ;
};_gcgfg ,_ebede :=_fbcadd .GetNumPages ();if _ebede !=nil {return nil ,_ebede ;};var _daddc []*_db .PdfPage ;for _dafae :=0;_dafae < _gcgfg ;_dafae ++{_ddgb ,_gabbg :=_fbcadd .GetPage (_dafae +1);if _gabbg !=nil {return nil ,_gabbg ;};_daddc =append (_daddc ,_ddgb );
};return _daddc ,nil ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_aefa *Invoice )SetColumns (cols []*InvoiceCell ){_aefa ._cbfcg =cols };

// SetColorBottom sets border color for bottom.
func (_dfad *border )SetColorBottom (col Color ){_dfad ._fff =col };func _cfeb (_gaff ,_cgbd TextStyle )*Invoice {_fefe :=&Invoice {_fgedc :"\u0049N\u0056\u004f\u0049\u0043\u0045",_gaed :"\u002c\u0020",_cafa :_gaff ,_gbff :_cgbd };_fefe ._afa =&InvoiceAddress {Separator :_fefe ._gaed };
_fefe ._ebcgc =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_fefe ._gaed };_dffd :=ColorRGBFrom8bit (245,245,245);_dbfdd :=ColorRGBFrom8bit (155,155,155);_fefe ._gbda =_cgbd ;_fefe ._gbda .Color =_dbfdd ;_fefe ._gbda .FontSize =20;
_fefe ._gegfg =_gaff ;_fefe ._ggfb =_cgbd ;_fefe ._fbfdc =_gaff ;_fefe ._geacd =_cgbd ;_fefe ._edafd =_fefe .NewCellProps ();_fefe ._edafd .BackgroundColor =_dffd ;_fefe ._edafd .TextStyle =_cgbd ;_fefe ._bggd =_fefe .NewCellProps ();_fefe ._bggd .TextStyle =_cgbd ;
_fefe ._bggd .BackgroundColor =_dffd ;_fefe ._bggd .BorderColor =_dffd ;_fefe ._ecacb =_fefe .NewCellProps ();_fefe ._ecacb .BorderColor =_dffd ;_fefe ._ecacb .BorderSides =[]CellBorderSide {CellBorderSideBottom };_fefe ._ecacb .Alignment =CellHorizontalAlignmentRight ;
_fefe ._dafd =_fefe .NewCellProps ();_fefe ._dafd .Alignment =CellHorizontalAlignmentRight ;_fefe ._bebe =[2]*InvoiceCell {_fefe .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_fefe ._edafd ),_fefe .newCell ("",_fefe ._edafd )};
_fefe ._cecd =[2]*InvoiceCell {_fefe .newCell ("\u0044\u0061\u0074\u0065",_fefe ._edafd ),_fefe .newCell ("",_fefe ._edafd )};_fefe ._bggcf =[2]*InvoiceCell {_fefe .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_fefe ._edafd ),_fefe .newCell ("",_fefe ._edafd )};
_fefe ._afcd =[2]*InvoiceCell {_fefe .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_fefe ._dafd ),_fefe .newCell ("",_fefe ._dafd )};_dagge :=_fefe ._dafd ;_dagge .TextStyle =_cgbd ;_dagge .BackgroundColor =_dffd ;_dagge .BorderColor =_dffd ;
_fefe ._decf =[2]*InvoiceCell {_fefe .newCell ("\u0054\u006f\u0074a\u006c",_dagge ),_fefe .newCell ("",_dagge )};_fefe ._dggc =[2]string {"\u004e\u006f\u0074e\u0073",""};_fefe ._bggce =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_fefe ._cbfcg =[]*InvoiceCell {_fefe .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_fefe .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_fefe .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_fefe .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _fefe ;};func (_dgggb *templateProcessor )parseDivision (_fcca *templateNode )(interface{},error ){_eecfg :=_dgggb .creator .NewDivision ();for _ ,_fbga :=range _fcca ._fabca .Attr {_ggddd :=_fbga .Value ;switch _dbce :=_fbga .Name .Local ;_dbce {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_eecfg .EnablePageWrap (_dgggb .parseBoolAttr (_dbce ,_ggddd ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_ddbd :=_dgggb .parseMarginAttr (_dbce ,_ggddd );_eecfg .SetMargins (_ddbd .Left ,_ddbd .Right ,_ddbd .Top ,_ddbd .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_baff :=_dgggb .parseMarginAttr (_dbce ,_ggddd );
_eecfg .SetPadding (_baff .Left ,_baff .Right ,_baff .Top ,_baff .Bottom );default:_dgggb .nodeLogDebug (_fcca ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dbce );
};};return _eecfg ,nil ;};

// SetBorderWidth sets the border width of the rectangle.
func (_afdf *Rectangle )SetBorderWidth (bw float64 ){_afdf ._ccde =bw };

// Indent returns the left offset of the list when nested into another list.
func (_fdcc *List )Indent ()float64 {return _fdcc ._adge };func _bfbbc (_cdef *_bgc .GraphicSVG )(*GraphicSVG ,error ){return &GraphicSVG {_gddd :_cdef ,_eccef :PositionRelative ,_dagb :Margins {Top :10,Bottom :10}},nil ;};

// Width returns the Block's width.
func (_ec *Block )Width ()float64 {return _ec ._bc };

// SetWidthBottom sets border width for bottom.
func (_ebg *border )SetWidthBottom (bw float64 ){_ebg ._dcdg =bw };

// SetBorderRadius sets the radius of the background corners.
func (_bf *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_bf .BorderRadiusTopLeft =topLeft ;_bf .BorderRadiusTopRight =topRight ;_bf .BorderRadiusBottomLeft =bottomLeft ;_bf .BorderRadiusBottomRight =bottomRight ;};func (_bggc *Image )makeXObject ()error {_fabb ,_bfge :=_db .NewXObjectImageFromImageLazy (_bggc ._efbg ,nil ,_bggc ._cegc ,_bggc ._ddcec );
if _bfge !=nil {_d .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bfge );return _bfge ;};_bggc ._agda =_fabb ;
return nil ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default, it occupies the available width in the drawing context.
type Paragraph struct{_cdaf string ;_bccd *_db .PdfFont ;_bbgda float64 ;_becfe float64 ;_afbce Color ;_ddcf TextAlignment ;_aacg bool ;_cbeda float64 ;_feed int ;_ggbaa bool ;_fgefg float64 ;_fdda Margins ;_bdbg Positioning ;_ecaa float64 ;_ecega float64 ;
_degg ,_afab float64 ;_fcfba []string ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_ddfc *Creator )MoveDown (dy float64 ){_ddfc ._edg .Y +=dy };func _edcb (_aacaf *Block ,_aead _db .PdfColor ,_fbfa Color ,_dcbe func ()Rectangle )error {switch _dbbab :=_aead .(type ){case *_db .PdfColorPatternType2 :_gdbfc ,_abbb :=_fbfa .(*LinearShading );
if !_abbb {return _f .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_cbce :=_dcbe ();_gdbfc .SetBoundingBox (_cbce ._dbgeg ,_cbce ._gead ,_cbce ._bccac ,_cbce ._begbb );
_dffeec ,_eeed :=_gdbfc .AddPatternResource (_aacaf );if _eeed !=nil {return _f .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_eeed );
};_dbbab .PatternName =_dffeec ;case *_db .PdfColorPatternType3 :_bbfb ,_eeef :=_fbfa .(*RadialShading );if !_eeef {return _f .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_faebg :=_dcbe ();_bbfb .SetBoundingBox (_faebg ._dbgeg ,_faebg ._gead ,_faebg ._bccac ,_faebg ._begbb );_aagac ,_fdbe :=_bbfb .AddPatternResource (_aacaf );if _fdbe !=nil {return _f .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_fdbe );
};_dbbab .PatternName =_aagac ;};return nil ;};

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_cddb *GraphicSVG )ScaleToHeight (h float64 ){_eebf :=_cddb ._gddd .Width /_cddb ._gddd .Height ;_cddb ._gddd .Height =h ;_cddb ._gddd .Width =h *_eebf ;_cddb ._gddd .SetScaling (_eebf ,_eebf );};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gefc *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _gefc ._bebe [0],_gefc ._bebe [1]};func (_bcae *Invoice )generateHeaderBlocks (_cfbd DrawContext )([]*Block ,DrawContext ,error ){_agdgb :=_gfbe (_bcae ._gbda );_agdgb .SetEnableWrap (true );
_agdgb .Append (_bcae ._fgedc );_gcbf :=_eedb (2);if _bcae ._ggff !=nil {_fccbd :=_gcbf .NewCell ();_fccbd .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_fccbd .SetVerticalAlignment (CellVerticalAlignmentMiddle );_fccbd .SetIndent (0);_fccbd .SetContent (_bcae ._ggff );
_bcae ._ggff .ScaleToHeight (_agdgb .Height ()+20);}else {_gcbf .SkipCells (1);};_edbfc :=_gcbf .NewCell ();_edbfc .SetHorizontalAlignment (CellHorizontalAlignmentRight );_edbfc .SetVerticalAlignment (CellVerticalAlignmentMiddle );_edbfc .SetContent (_agdgb );
return _gcbf .GeneratePageBlocks (_cfbd );};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_gddg *Line )SetFitMode (fitMode FitMode ){_gddg ._dbged =fitMode };

// Width returns the width of the ellipse.
func (_cdae *Ellipse )Width ()float64 {return _cdae ._bee };

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_gcebc *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdbb :=ctx ;var _gceeb []*Block ;_cfdeb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _gcebc ._fadf .IsRelative (){ctx .X +=_gcebc ._acfa .Left ;ctx .Y +=_gcebc ._acfa .Top ;
ctx .Width -=_gcebc ._acfa .Left +_gcebc ._acfa .Right ;ctx .Height -=_gcebc ._acfa .Top ;_gcebc .SetWidth (ctx .Width );}else {if int (_gcebc ._baaga )<=0{_gcebc .SetWidth (_gcebc .getTextWidth ()/1000.0);};ctx .X =_gcebc ._afceb ;ctx .Y =_gcebc ._dadc ;
};if _gcebc ._cabgb !=nil {_gcebc ._cabgb (_gcebc ,ctx );};if _fcdf :=_gcebc .wrapText ();_fcdf !=nil {return nil ,ctx ,_fcdf ;};_bdfb :=_gcebc ._ebgc ;_cdag :=0;for {_bedb ,_gddb ,_fgff :=_cedeg (_cfdeb ,_gcebc ,_bdfb ,ctx );if _fgff !=nil {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fgff );
return nil ,ctx ,_fgff ;};ctx =_bedb ;_gceeb =append (_gceeb ,_cfdeb );if _bdfb =_gddb ;len (_gddb )==0{break ;};if len (_gddb )==_cdag {return nil ,ctx ,_ab .New ("\u006e\u006f\u0074\u0020\u0065\u006e\u006f\u0075\u0067\u0068 \u0073\u0070\u0061\u0063\u0065\u0020\u0066o\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068");
};_cfdeb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_bedb =ctx ;_bedb .Y =ctx .Margins .Top ;_bedb .X =ctx .Margins .Left +_gcebc ._acfa .Left ;_bedb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_bedb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gcebc ._acfa .Left -_gcebc ._acfa .Right ;
ctx =_bedb ;_cdag =len (_gddb );};if _gcebc ._fadf .IsRelative (){ctx .Y +=_gcebc ._acfa .Bottom ;ctx .Height -=_gcebc ._acfa .Bottom ;if !ctx .Inline {ctx .X =_fdbb .X ;ctx .Width =_fdbb .Width ;};return _gceeb ,ctx ,nil ;};return _gceeb ,_fdbb ,nil ;
};

// NewImageFromFile creates an Image from a file.
func (_gfag *Creator )NewImageFromFile (path string )(*Image ,error ){return _gdae (path )};

// Height returns the current page height.
func (_deab *Creator )Height ()float64 {return _deab ._cfaf };

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_ffcgc *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_gaag float64 ;_fbgga uint ;_dgcg float64 ;_efff Positioning ;_dfcfa float64 ;_gagdf float64 ;_gaecg int64 ;};func (_ccabb *Invoice )drawSection (_cebg ,_aaeae string )[]*StyledParagraph {var _eead []*StyledParagraph ;if _cebg !=""{_gdade :=_gfbe (_ccabb ._geacd );
_gdade .SetMargins (0,0,0,5);_gdade .Append (_cebg );_eead =append (_eead ,_gdade );};if _aaeae !=""{_gceda :=_gfbe (_ccabb ._fbfdc );_gceda .Append (_aaeae );_eead =append (_eead ,_gceda );};return _eead ;};func (_bcece *templateProcessor )nodeError (_faage *templateNode ,_gaeb string ,_fgfee ...interface{})error {return _f .Errorf (_bcece .getNodeErrorLocation (_faage ,_gaeb ,_fgfee ...));
};func _dgbcf (_edecbc ...interface{})(map[string ]interface{},error ){_cdgg :=len (_edecbc );if _cdgg %2!=0{_d .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_cdgg );
return nil ,_ag .ErrRangeError ;};_fdgdg :=map[string ]interface{}{};for _becbb :=0;_becbb < _cdgg ;_becbb +=2{_aebad ,_gbbff :=_edecbc [_becbb ].(string );if !_gbbff {_d .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_edecbc [_becbb ]);
return nil ,_ag .ErrTypeError ;};_fdgdg [_aebad ]=_edecbc [_becbb +1];};return _fdgdg ,nil ;};func (_fcgb *Paragraph )getMaxLineWidth ()float64 {if _fcgb ._fcfba ==nil ||len (_fcgb ._fcfba )==0{_fcgb .wrapText ();};var _aadad float64 ;for _ ,_dgfc :=range _fcgb ._fcfba {_faaef :=_fcgb .getTextLineWidth (_dgfc );
if _faaef > _aadad {_aadad =_faaef ;};};return _aadad ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_cfeca *TOC )SetLineSeparator (separator string ){_cfeca ._defdd =separator };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_edee int ;_dgac string ;_gdbe *Paragraph ;_bgf []Drawable ;_deag int ;_dggd bool ;_eab bool ;_abdg Positioning ;_gcag ,_eebg float64 ;_cbfc Margins ;_cdff *Chapter ;_cegd *TOC ;_daab *_db .Outline ;_bdag *_db .OutlineItem ;_afd uint ;
};

// Columns returns all the columns in the invoice line items table.
func (_feda *Invoice )Columns ()[]*InvoiceCell {return _feda ._cbfcg };

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_aae []_fg .CubicBezierCurve ;FillEnabled bool ;_gebc Color ;BorderEnabled bool ;BorderWidth float64 ;_agdg Color ;};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_ceca *Line )SetMargins (left ,right ,top ,bottom float64 ){_ceca ._gabgd .Left =left ;_ceca ._gabgd .Right =right ;_ceca ._gabgd .Top =top ;_ceca ._gabgd .Bottom =bottom ;};func (_fbce *Table )clone ()*Table {_bdbc :=*_fbce ;_bdbc ._bebec =make ([]float64 ,len (_fbce ._bebec ));
copy (_bdbc ._bebec ,_fbce ._bebec );_bdbc ._cfab =make ([]float64 ,len (_fbce ._cfab ));copy (_bdbc ._cfab ,_fbce ._cfab );_bdbc ._dgde =make ([]*TableCell ,0,len (_fbce ._dgde ));for _ ,_acdag :=range _fbce ._dgde {_eddcg :=*_acdag ;_eddcg ._bfdgf =&_bdbc ;
_bdbc ._dgde =append (_bdbc ._dgde ,&_eddcg );};return &_bdbc ;};

// SetRowPosition sets cell row position.
func (_ggfa *TableCell )SetRowPosition (row int ){_ggfa ._adfd =row };

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// SetFillColor sets the fill color of the rectangle.
func (_daadb *Rectangle )SetFillColor (col Color ){_daadb ._debe =col };

// SetWidth sets the width of the ellipse.
func (_dgfb *Ellipse )SetWidth (width float64 ){_dgfb ._bee =width };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_dag *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dag ._add .Left ,_dag ._add .Right ,_dag ._add .Top ,_dag ._add .Bottom ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gdbdd *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _gdbdd ._cecd [0],_gdbdd ._cecd [1]};

// SetFillColor sets the fill color.
func (_bbab *PolyBezierCurve )SetFillColor (color Color ){_bbab ._fecca =color ;_bbab ._bgfa .FillColor =_afb (color );};func (_beef *Paragraph )getTextWidth ()float64 {_cage :=0.0;for _ ,_edbg :=range _beef ._cdaf {if _edbg =='\u000A'{continue ;};_abfg ,_caab :=_beef ._bccd .GetRuneMetrics (_edbg );
if !_caab {_d .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_edbg ,_edbg );
return -1;};_cage +=_beef ._bbgda *_abfg .Wx ;};return _cage ;};func (_daeag *templateProcessor )parseAttrPropList (_bgggf string )map[string ]string {_fccbc :=_cc .Fields (_bgggf );if len (_fccbc )==0{return nil ;};_daffb :=map[string ]string {};for _ ,_ddgce :=range _fccbc {_fccaa :=_ccfaa .FindStringSubmatch (_ddgce );
if len (_fccaa )< 3{continue ;};_egefa ,_dabaf :=_cc .TrimSpace (_fccaa [1]),_fccaa [2];if _egefa ==""{continue ;};_daffb [_egefa ]=_dabaf ;};return _daffb ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_dcbf :_gb .Max (_gb .Min (r ,1.0),0.0),_accg :_gb .Max (_gb .Min (g ,1.0),0.0),_bgcg :_gb .Max (_gb .Min (b ,1.0),0.0)};};

// SetBorderOpacity sets the border opacity of the ellipse.
func (_cacd *Ellipse )SetBorderOpacity (opacity float64 ){_cacd ._gdef =opacity };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_abef *Creator )SetOutlineTree (outlineTree *_db .PdfOutlineTreeNode ){_abef ._bef =outlineTree };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_agdgf *Paragraph )SetMaxLines (maxLines int ){_agdgf ._feed =maxLines ;_agdgf .wrapText ()};func (_eda *Block )mergeBlocks (_adda *Block )error {_fbc :=_gee (_eda ._bag ,_eda ._aef ,_adda ._bag ,_adda ._aef );if _fbc !=nil {return _fbc ;};for _ ,_fge :=range _adda ._gc {_eda .AddAnnotation (_fge );
};return nil ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_dfe rune ;_ccd []error ;};func (_fdfg *Paragraph )getTextMetrics ()(_cfgfc ,_fgcb ,_eccb float64 ){_eeeea :=_agaa (_fdfg ._bccd ,_fdfg ._bbgda );if _eeeea ._ebdff > _cfgfc {_cfgfc =_eeeea ._ebdff ;};if _eeeea ._ccbag < _eccb {_eccb =_eeeea ._ccbag ;
};if _agbe :=_fdfg ._bbgda ;_agbe > _fgcb {_fgcb =_agbe ;};return _cfgfc ,_fgcb ,_eccb ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_fcgge *StyledParagraph )SetText (text string )*TextChunk {_fcgge .Reset ();return _fcgge .Append (text );};

// SetSellerAddress sets the seller address of the invoice.
func (_agdb *Invoice )SetSellerAddress (address *InvoiceAddress ){_agdb ._afa =address };

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_dfbd *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_bbeg ,_bbega :=_dfbd .Wrap (width );if _bbega !=nil {return nil ,_bbega ;};_begbc :=int (height /_dfbd .Style .FontSize );if _begbc >=len (_bbeg ){return nil ,nil ;};_fecda :="\u000a";
_dfbd .Text =_cc .Replace (_cc .Join (_bbeg [:_begbc ],"\u0020"),_fecda +"\u0020",_fecda ,-1);_abgdf :=_cc .Replace (_cc .Join (_bbeg [_begbc :],"\u0020"),_fecda +"\u0020",_fecda ,-1);return NewTextChunk (_abgdf ,_dfbd .Style ),nil ;};func _cfcd (_gegc *Block ,_gdag *Image ,_gcffg DrawContext )(DrawContext ,error ){_aaac :=_gcffg ;
_faee :=1;_cded :=_ag .PdfObjectName (_f .Sprintf ("\u0049\u006d\u0067%\u0064",_faee ));for _gegc ._aef .HasXObjectByName (_cded ){_faee ++;_cded =_ag .PdfObjectName (_f .Sprintf ("\u0049\u006d\u0067%\u0064",_faee ));};_addgg :=_gegc ._aef .SetXObjectImageByNameLazy (_cded ,_gdag ._agda ,_gdag ._ddcec );
if _addgg !=nil {return _gcffg ,_addgg ;};_bcee :=0;_bgda :=_ag .PdfObjectName (_f .Sprintf ("\u0047\u0053\u0025\u0064",_bcee ));for _gegc ._aef .HasExtGState (_bgda ){_bcee ++;_bgda =_ag .PdfObjectName (_f .Sprintf ("\u0047\u0053\u0025\u0064",_bcee ));
};_bdddd :=_ag .MakeDict ();_bdddd .Set ("\u0042\u004d",_ag .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _gdag ._fdfd < 1.0{_bdddd .Set ("\u0043\u0041",_ag .MakeFloat (_gdag ._fdfd ));_bdddd .Set ("\u0063\u0061",_ag .MakeFloat (_gdag ._fdfd ));
};_addgg =_gegc ._aef .AddExtGState (_bgda ,_ag .MakeIndirectObject (_bdddd ));if _addgg !=nil {return _gcffg ,_addgg ;};_acda :=_gdag .Width ();_fbfdg :=_gdag .Height ();_ ,_ecge :=_gdag .rotatedSize ();_fcfb :=_gcffg .X ;_fgge :=_gcffg .PageHeight -_gcffg .Y -_fbfdg ;
if _gdag ._dfgd .IsRelative (){_fgge -=(_ecge -_fbfdg )/2;switch _gdag ._gcba {case HorizontalAlignmentCenter :_fcfb +=(_gcffg .Width -_acda )/2;case HorizontalAlignmentRight :_fcfb =_gcffg .PageWidth -_gcffg .Margins .Right -_gdag ._gabc .Right -_acda ;
};};_gacg :=_gdag ._edaf ;_dgbgg :=_cf .NewContentCreator ();_dgbgg .Add_gs (_bgda );_dgbgg .Translate (_fcfb ,_fgge );if _gacg !=0{_dgbgg .Translate (_acda /2,_fbfdg /2);_dgbgg .RotateDeg (_gacg );_dgbgg .Translate (-_acda /2,-_fbfdg /2);};_dgbgg .Scale (_acda ,_fbfdg ).Add_Do (_cded );
_cgca :=_dgbgg .Operations ();_cgca .WrapIfNeeded ();_gegc .addContents (_cgca );if _gdag ._dfgd .IsRelative (){_gcffg .Y +=_ecge ;_gcffg .Height -=_ecge ;return _gcffg ,nil ;};return _aaac ,nil ;};func (_ge *Block )duplicate ()*Block {_ffc :=&Block {};
*_ffc =*_ge ;_eb :=_cf .ContentStreamOperations {};_eb =append (_eb ,*_ge ._bag ...);_ffc ._bag =&_eb ;return _ffc ;};func (_ffbd *Invoice )drawAddress (_eebfc *InvoiceAddress )[]*StyledParagraph {var _bfgeb []*StyledParagraph ;if _eebfc .Heading !=""{_gedg :=_gfbe (_ffbd ._ggfb );
_gedg .SetMargins (0,0,0,7);_gedg .Append (_eebfc .Heading );_bfgeb =append (_bfgeb ,_gedg );};_ffae :=_gfbe (_ffbd ._gegfg );_ffae .SetLineHeight (1.2);_gdbf :=_eebfc .Separator ;if _gdbf ==""{_gdbf =_ffbd ._gaed ;};_gggg :=_eebfc .City ;if _eebfc .State !=""{if _gggg !=""{_gggg +=_gdbf ;
};_gggg +=_eebfc .State ;};if _eebfc .Zip !=""{if _gggg !=""{_gggg +=_gdbf ;};_gggg +=_eebfc .Zip ;};if _eebfc .Name !=""{_ffae .Append (_eebfc .Name +"\u000a");};if _eebfc .Street !=""{_ffae .Append (_eebfc .Street +"\u000a");};if _eebfc .Street2 !=""{_ffae .Append (_eebfc .Street2 +"\u000a");
};if _gggg !=""{_ffae .Append (_gggg +"\u000a");};if _eebfc .Country !=""{_ffae .Append (_eebfc .Country +"\u000a");};_aege :=_gfbe (_ffbd ._gegfg );_aege .SetLineHeight (1.2);_aege .SetMargins (0,0,7,0);if _eebfc .Phone !=""{_aege .Append (_eebfc .fmtLine (_eebfc .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_eebfc .HidePhoneLabel ));
};if _eebfc .Email !=""{_aege .Append (_eebfc .fmtLine (_eebfc .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_eebfc .HideEmailLabel ));};_bfgeb =append (_bfgeb ,_ffae ,_aege );return _bfgeb ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_gcbc *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cgebe :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cedb ,_ ,_ccfb :=_gcbc .draw (_cgebe ,"");if _ccfb !=nil {return nil ,ctx ,_ccfb ;};_ccfb =_cgebe .addContentsByString (string (_cedb ));
if _ccfb !=nil {return nil ,ctx ,_ccfb ;};return []*Block {_cgebe },ctx ,nil ;};func (_bgafe *templateProcessor )parseBorderRadiusAttr (_defefe ,_fegdg string )(_eace ,_aadba ,_afca ,_gbbge float64 ){_d .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_defefe ,_fegdg );
switch _cbfgg :=_cc .Fields (_fegdg );len (_cbfgg ){case 1:_eace ,_ =_eg .ParseFloat (_cbfgg [0],64);_aadba =_eace ;_afca =_eace ;_gbbge =_eace ;case 2:_eace ,_ =_eg .ParseFloat (_cbfgg [0],64);_afca =_eace ;_aadba ,_ =_eg .ParseFloat (_cbfgg [1],64);_gbbge =_aadba ;
case 3:_eace ,_ =_eg .ParseFloat (_cbfgg [0],64);_aadba ,_ =_eg .ParseFloat (_cbfgg [1],64);_gbbge =_aadba ;_afca ,_ =_eg .ParseFloat (_cbfgg [2],64);case 4:_eace ,_ =_eg .ParseFloat (_cbfgg [0],64);_aadba ,_ =_eg .ParseFloat (_cbfgg [1],64);_afca ,_ =_eg .ParseFloat (_cbfgg [2],64);
_gbbge ,_ =_eg .ParseFloat (_cbfgg [3],64);};return _eace ,_aadba ,_afca ,_gbbge ;};

// SetColor sets the line color.
func (_bcecd *Curve )SetColor (col Color ){_bcecd ._ffdb =col };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_beae *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_daabd :=ctx ;var _gdaf []*Block ;_ggcd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _beae ._bdbg .IsRelative (){ctx .X +=_beae ._fdda .Left ;ctx .Y +=_beae ._fdda .Top ;
ctx .Width -=_beae ._fdda .Left +_beae ._fdda .Right ;ctx .Height -=_beae ._fdda .Top ;_beae .SetWidth (ctx .Width );if _beae .Height ()> ctx .Height {_gdaf =append (_gdaf ,_ggcd );_ggcd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_bbdac :=ctx ;
_bbdac .Y =ctx .Margins .Top ;_bbdac .X =ctx .Margins .Left +_beae ._fdda .Left ;_bbdac .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_bbdac .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_beae ._fdda .Left -_beae ._fdda .Right ;
ctx =_bbdac ;};}else {if int (_beae ._cbeda )<=0{_beae .SetWidth (_beae .getTextWidth ());};ctx .X =_beae ._ecaa ;ctx .Y =_beae ._ecega ;};ctx ,_cgcgg :=_afgg (_ggcd ,_beae ,ctx );if _cgcgg !=nil {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cgcgg );
return nil ,ctx ,_cgcgg ;};_gdaf =append (_gdaf ,_ggcd );if _beae ._bdbg .IsRelative (){ctx .Y +=_beae ._fdda .Bottom ;ctx .Height -=_beae ._fdda .Bottom ;if !ctx .Inline {ctx .X =_daabd .X ;ctx .Width =_daabd .Width ;};return _gdaf ,ctx ,nil ;};return _gdaf ,_daabd ,nil ;
};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_bgfa *_fg .PolyBezierCurve ;_bfde float64 ;_ceaf float64 ;_fecca Color ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_dgbgf *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dgbgf ._gabc .Left ,_dgbgf ._gabc .Right ,_dgbgf ._gabc .Top ,_dgbgf ._gabc .Bottom ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_bebcg *Invoice )SetTitleStyle (style TextStyle ){_bebcg ._gbda =style };

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_fgcba Color ;_edcdd float64 ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);
ColorYellow =ColorRGBFromArithmetic (1,1,0););

// SetFillColor sets the fill color for the path.
func (_dfgb *FilledCurve )SetFillColor (color Color ){_dfgb ._gebc =color };

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_bcdfg *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_dege *TOC )SetLineStyle (style TextStyle ){_dege .SetLineNumberStyle (style );_dege .SetLineTitleStyle (style );_dege .SetLineSeparatorStyle (style );_dege .SetLinePageStyle (style );};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_dgfed *TableCell )SetContent (vd VectorDrawable )error {switch _edcdb :=vd .(type ){case *Paragraph :if _edcdb ._ggbaa {_edcdb ._aacg =true ;};_dgfed ._aabd =vd ;case *StyledParagraph :if _edcdb ._dgcd {_edcdb ._bbff =true ;};_dgfed ._aabd =vd ;
case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_dgfed ._aabd =vd ;default:_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _ag .ErrTypeError ;};return nil ;};func _ddcfe (_fgefa *templateProcessor ,_dgdca *templateNode )(interface{},error ){return _fgefa .parseChart (_dgdca );};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_aebe *Creator )RotateDeg (angleDeg int64 )error {_gde :=_aebe .getActivePage ();if _gde ==nil {_d .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _ab .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_d .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _aga int64 ;if _gde .Rotate !=nil {_aga =*(_gde .Rotate );};_aga +=angleDeg ;_gde .Rotate =&_aga ;return nil ;};type containerDrawable interface{Drawable ;


// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_fdec Drawable )(Drawable ,error );};

// SetIndent sets the left offset of the list when nested into another list.
func (_fgfe *List )SetIndent (indent float64 ){_fgfe ._adge =indent ;_fgfe ._gfbf =false };

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_bfddc *LinearShading )SetAngle (angle float64 ){_bfddc ._afga =angle };

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_bcaaa *TableCell )SetBorderLineStyle (style _fg .LineStyle ){_bcaaa ._gbebf =style };

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_beaaa *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_ccdf []*Block ;_deec =NewBlock (ctx .PageWidth ,ctx .PageHeight );_effg =ctx ;_gcccb =_beaaa ._ccde /2;);_dgabg :=_beaaa ._aacf .IsRelative ();if _dgabg {_beaaa .applyFitMode (ctx .Width );
ctx .X +=_beaaa ._cbagd .Left +_gcccb ;ctx .Y +=_beaaa ._cbagd .Top +_gcccb ;ctx .Width -=_beaaa ._cbagd .Left +_beaaa ._cbagd .Right ;ctx .Height -=_beaaa ._cbagd .Top +_beaaa ._cbagd .Bottom ;if _beaaa ._begbb > ctx .Height {_ccdf =append (_ccdf ,_deec );
_deec =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_adga :=ctx ;_adga .Y =ctx .Margins .Top +_beaaa ._cbagd .Top +_gcccb ;_adga .X =ctx .Margins .Left +_beaaa ._cbagd .Left +_gcccb ;_adga .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_beaaa ._cbagd .Top -_beaaa ._cbagd .Bottom ;
_adga .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_beaaa ._cbagd .Left -_beaaa ._cbagd .Right ;ctx =_adga ;};}else {ctx .X =_beaaa ._dbgeg ;ctx .Y =_beaaa ._gead ;};_beba :=_fg .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_beaaa ._begbb ,Width :_beaaa ._bccac ,Height :_beaaa ._begbb ,BorderRadiusTopLeft :_beaaa ._cdbc ,BorderRadiusTopRight :_beaaa ._eaebb ,BorderRadiusBottomLeft :_beaaa ._fgfgg ,BorderRadiusBottomRight :_beaaa ._cdege ,Opacity :1.0};
if _beaaa ._debe !=nil {_beba .FillEnabled =true ;_ecbe :=_afb (_beaaa ._debe );_ggcf :=_edcb (_deec ,_ecbe ,_beaaa ._debe ,func ()Rectangle {return Rectangle {_dbgeg :_beba .X ,_gead :_beba .Y ,_bccac :_beba .Width ,_begbb :_beba .Height };});if _ggcf !=nil {return nil ,ctx ,_ggcf ;
};_beba .FillColor =_ecbe ;};if _beaaa ._ddde !=nil &&_beaaa ._ccde > 0{_beba .BorderEnabled =true ;_beba .BorderColor =_afb (_beaaa ._ddde );_beba .BorderWidth =_beaaa ._ccde ;};_bgfd ,_aeea :=_deec .setOpacity (_beaaa ._dgab ,_beaaa ._ccbd );if _aeea !=nil {return nil ,ctx ,_aeea ;
};_adce ,_ ,_aeea :=_beba .Draw (_bgfd );if _aeea !=nil {return nil ,ctx ,_aeea ;};if _aeea =_deec .addContentsByString (string (_adce ));_aeea !=nil {return nil ,ctx ,_aeea ;};if _dgabg {ctx .X =_effg .X ;ctx .Width =_effg .Width ;_beabg :=_beaaa ._begbb +_gcccb ;
ctx .Y +=_beabg +_beaaa ._cbagd .Bottom ;ctx .Height -=_beabg ;}else {ctx =_effg ;};_ccdf =append (_ccdf ,_deec );return _ccdf ,ctx ,nil ;};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// Opacity returns the opacity of the line.
func (_cedf *Line )Opacity ()float64 {return _cedf ._edbfcd };

// NewSubchapter creates a new child chapter with the specified title.
func (_ebgd *Chapter )NewSubchapter (title string )*Chapter {_cab :=_cdca (_ebgd ._gdbe ._bccd );_cab .FontSize =14;_ebgd ._deag ++;_geea :=_acae (_ebgd ,_ebgd ._cegd ,_ebgd ._daab ,title ,_ebgd ._deag ,_cab );_ebgd .Add (_geea );return _geea ;};func _gccef (_gefb string ,_baeda TextStyle )*Paragraph {_fba :=&Paragraph {_cdaf :_gefb ,_bccd :_baeda .Font ,_bbgda :_baeda .FontSize ,_becfe :1.0,_aacg :true ,_ggbaa :true ,_ddcf :TextAlignmentLeft ,_fgefg :0,_degg :1,_afab :1,_bdbg :PositionRelative };
_fba .SetColor (_baeda .Color );return _fba ;};func (_aaba *Table )wrapContent (_fecd DrawContext )error {if _aaba ._dcag {return nil ;};_aaba .sortCells ();_ggfbg :=func (_abeb *TableCell ,_ecggf int ,_gafead int ,_gcead int )(_dggce int ){if _gcead < 1{return -1;
};_agdc :=0;for _afbgd :=_gafead +1;_afbgd < len (_aaba ._dgde )-1;_afbgd ++{_cccg :=_aaba ._dgde [_afbgd ];if _cccg ._adfd ==_gcead &&_agdc !=_gafead {_agdc =_afbgd ;if (_cccg ._bcea < _abeb ._bcea &&_aaba ._cccbd > _cccg ._bcea )||_abeb ._bcea < _aaba ._cccbd {continue ;
};break ;};};_eeffg :=float64 (0.0);for _edfg :=0;_edfg < _abeb ._fbeb ;_edfg ++{_eeffg +=_aaba ._bebec [_abeb ._adfd +_edfg -1];};_gbbdba :=_abeb .width (_aaba ._cfab ,_fecd .Width );var (_bfcg VectorDrawable ;_bafa =false ;);switch _baagef :=_abeb ._aabd .(type ){case *StyledParagraph :_bfbfb :=_fecd ;
_bfbfb .Height =_gb .Floor (_eeffg -_baagef ._acfa .Top -_baagef ._acfa .Bottom -0.5*_baagef .getTextHeight ());_bfbfb .Width =_gbbdba ;_ecgb ,_eada ,_ebfb :=_baagef .split (_bfbfb );if _ebfb !=nil {_d .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_ebfb .Error ());
};if _ecgb !=nil &&_eada !=nil {_aaba ._dgde [_gafead ]._aabd =_ecgb ;_bfcg =_eada ;_bafa =true ;};};_aaba ._dgde [_gafead ]._fbeb =_abeb ._fbeb ;_fecd .Height =_fecd .PageHeight -_fecd .Margins .Top -_fecd .Margins .Bottom ;_bbbaa :=_abeb .cloneProps (nil );
if _bafa {_bbbaa ._aabd =_bfcg ;};_bbbaa ._fbeb =_ecggf ;_bbbaa ._adfd =_gcead +1;_bbbaa ._bcea =_abeb ._bcea ;if _bbbaa ._adfd +_bbbaa ._fbeb -1> _aaba ._dgdc {for _dgdf :=_aaba ._dgdc ;_dgdf < _bbbaa ._adfd +_bbbaa ._fbeb -1;_dgdf ++{_aaba ._dgdc ++;
_aaba ._bebec =append (_aaba ._bebec ,_aaba ._gbccbb );};};_aaba ._dgde =append (_aaba ._dgde [:_agdc +1],append ([]*TableCell {_bbbaa },_aaba ._dgde [_agdc +1:]...)...);return _agdc +1;};_cgdfb :=func (_dccd *TableCell ,_dfbc int ,_abgd int ,_agdf float64 )(_gebfde int ){_dgdcg :=_dccd .width (_aaba ._cfab ,_fecd .Width );
_faef :=_agdf ;_fddefg :=1;_bebg :=_fecd .Height ;if _bebg > 0{for _faef > _bebg {_faef -=_fecd .Height ;_bebg =_fecd .PageHeight -_fecd .Margins .Top -_fecd .Margins .Bottom ;_fddefg ++;};};var (_fdfdd VectorDrawable ;_adced =false ;);switch _gfed :=_dccd ._aabd .(type ){case *StyledParagraph :_fcdb :=_fecd ;
_fcdb .Height =_gb .Floor (_fecd .Height -_gfed ._acfa .Top -_gfed ._acfa .Bottom -0.5*_gfed .getTextHeight ());_fcdb .Width =_dgdcg ;_beda ,_cdbbd ,_fddad :=_gfed .split (_fcdb );if _fddad !=nil {_d .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_fddad .Error ());
};if _beda !=nil &&_cdbbd !=nil {_aaba ._dgde [_dfbc ]._aabd =_beda ;_fdfdd =_cdbbd ;_adced =true ;};};if _fddefg < 2{return -1;};if _aaba ._dgde [_dfbc ]._adfd +_fddefg -1> _aaba ._dgdc {for _gfbd :=0;_gfbd < _fddefg ;_gfbd ++{_aaba ._dgdc ++;_aaba ._bebec =append (_aaba ._bebec ,_aaba ._gbccbb );
};};_egae :=_agdf /float64 (_fddefg );for _baaf :=0;_baaf < _fddefg ;_baaf ++{_aaba ._bebec [_abgd +_baaf -1]=_egae ;};_fecd .Height =_fecd .PageHeight -_fecd .Margins .Top -_fecd .Margins .Bottom ;_fgfbc :=_dccd .cloneProps (nil );if _adced {_fgfbc ._aabd =_fdfdd ;
};_fgfbc ._fbeb =1;_fgfbc ._adfd =_abgd +_fddefg -1;_fgfbc ._bcea =_dccd ._bcea ;_aaba ._dgde =append (_aaba ._dgde ,_fgfbc );return len (_aaba ._dgde );};_agbb :=1;_becad :=-1;for _gcdgc :=0;_gcdgc < len (_aaba ._dgde );_gcdgc ++{_gagbc :=_aaba ._dgde [_gcdgc ];
if _becad ==_gcdgc {_agbb =_gagbc ._adfd ;};if _gagbc ._fbeb < 2{if _cafad :=_aaba ._bebec [_gagbc ._adfd -1];_cafad > _fecd .Height {_becad =_cgdfb (_gagbc ,_gcdgc ,_gagbc ._adfd ,_cafad );continue ;};continue ;};_geag :=float64 (0);for _cgcf :=0;_cgcf < _gagbc ._fbeb ;
_cgcf ++{_geag +=_aaba ._bebec [_gagbc ._adfd +_cgcf -1];};_bfaab :=float64 (0);for _dfcc :=_agbb -1;_dfcc < _gagbc ._adfd -1;_dfcc ++{_bfaab +=_aaba ._bebec [_dfcc ];};if _geag <=(_fecd .Height -_bfaab ){continue ;};_aeagb :=float64 (0.0);_baebe :=_gagbc ._fbeb ;
_ddgag :=-1;_bedbf :=1;for _faedb :=1;_faedb <=_gagbc ._fbeb ;_faedb ++{if (_aeagb +_aaba ._bebec [_gagbc ._adfd +_faedb -2])> (_fecd .Height -_bfaab ){_bedbf --;break ;};_ddgag =_gagbc ._adfd +_faedb -1;_baebe =_gagbc ._fbeb -_faedb ;_aeagb +=_aaba ._bebec [_gagbc ._adfd +_faedb -2];
_bedbf ++;};if _gagbc ._fbeb ==_baebe {_fecd .Height =_fecd .PageHeight -_fecd .Margins .Top -_fecd .Margins .Bottom ;_agbb =_gagbc ._adfd ;_gcdgc --;continue ;};if _baebe > 0&&_gagbc ._fbeb > _bedbf {_gagbc ._fbeb =_bedbf ;_becad =_ggfbg (_gagbc ,_baebe ,_gcdgc ,_ddgag );
if _gcdgc +1==_becad {_gcdgc --;};};_agbb =_gagbc ._adfd ;};_aaba .sortCells ();return nil ;};

// GeneratePageBlocks draw graphic svg into block.
func (_faeb *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_face :=ctx ;_afbb :=_faeb ._eccef .IsRelative ();var _aebgc []*Block ;if _afbb {_cegg :=1.0;_fegg :=_faeb ._dagb .Top ;if _faeb ._gddd .Height > ctx .Height -_faeb ._dagb .Top {_aebgc =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _bgag error ;if _ ,ctx ,_bgag =_cceg ().GeneratePageBlocks (ctx );_bgag !=nil {return nil ,ctx ,_bgag ;};_fegg =0;};ctx .X +=_faeb ._dagb .Left +_cegg ;ctx .Y +=_fegg ;ctx .Width -=_faeb ._dagb .Left +_faeb ._dagb .Right +2*_cegg ;ctx .Height -=_fegg ;
}else {ctx .X =_faeb ._dfac ;ctx .Y =_faeb ._bfe ;};_dccbd :=_cf .NewContentCreator ();_dccbd .Translate (0,ctx .PageHeight );_dccbd .Scale (1,-1);_dccbd .Translate (ctx .X ,ctx .Y );_cdbg :=_faeb ._gddd .Width /_faeb ._gddd .ViewBox .W ;_fddceg :=_faeb ._gddd .Height /_faeb ._gddd .ViewBox .H ;
_dfba :=0.0;_ebcgg :=0.0;if _afbb {_dfba =_faeb ._dfac -(_faeb ._gddd .ViewBox .X *_gb .Max (_cdbg ,_fddceg ));_ebcgg =_faeb ._bfe -(_faeb ._gddd .ViewBox .Y *_gb .Max (_cdbg ,_fddceg ));};_gada :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_faeb ._gddd .ToContentCreator (_dccbd ,_gada ._aef ,_cdbg ,_fddceg ,_dfba ,_ebcgg );
if _bcbd :=_gada .addContentsByString (_dccbd .String ());_bcbd !=nil {return nil ,ctx ,_bcbd ;};if _afbb {_ebee :=_faeb .Height ()+_faeb ._dagb .Bottom ;ctx .Y +=_ebee ;ctx .Height -=_ebee ;}else {ctx =_face ;};_aebgc =append (_aebgc ,_gada );return _aebgc ,ctx ,nil ;
};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_bdeb *Image )SetWidth (w float64 ){_bdeb ._daba =w };const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// SetRowHeight sets the height for a specified row.
func (_bfgb *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_bfgb ._bebec ){return _ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bfgb ._bebec [row -1]=h ;return nil ;
};

// TOC returns the table of contents component of the creator.
func (_fage *Creator )TOC ()*TOC {return _fage ._gcad };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_cfafe *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_cfafe ._fbagg =&_db .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_facd *Paragraph )SetTextAlignment (align TextAlignment ){_facd ._ddcf =align };func (_fcggf *templateProcessor )parseBackground (_bdggg *templateNode )(interface{},error ){_adeaa :=&Background {};for _ ,_eecde :=range _bdggg ._fabca .Attr {_fefde :=_eecde .Value ;
switch _bfaadb :=_eecde .Name .Local ;_bfaadb {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_adeaa .FillColor =_fcggf .parseColorAttr (_bfaadb ,_fefde );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_adeaa .BorderColor =_fcggf .parseColorAttr (_bfaadb ,_fefde );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_adeaa .BorderSize =_fcggf .parseFloatAttr (_bfaadb ,_fefde );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_eedgd ,_fgfcf ,_effd ,_gceg :=_fcggf .parseBorderRadiusAttr (_bfaadb ,_fefde );
_adeaa .SetBorderRadius (_eedgd ,_fgfcf ,_gceg ,_effd );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_adeaa .BorderRadiusTopLeft =_fcggf .parseFloatAttr (_bfaadb ,_fefde );
case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_adeaa .BorderRadiusTopRight =_fcggf .parseFloatAttr (_bfaadb ,_fefde );case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_adeaa .BorderRadiusBottomLeft =_fcggf .parseFloatAttr (_bfaadb ,_fefde );
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_adeaa .BorderRadiusBottomRight =_fcggf .parseFloatAttr (_bfaadb ,_fefde );default:_fcggf .nodeLogDebug (_bdggg ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_bfaadb );
};};return _adeaa ,nil ;};func _gcdga (_cegfb *templateProcessor ,_fdcgg *templateNode )(interface{},error ){return _cegfb .parseRectangle (_fdcgg );};func (_ggdc *Table )updateRowHeights (_agfef float64 ){for _ ,_cabga :=range _ggdc ._dgde {_ebdb :=_cabga .width (_ggdc ._cfab ,_agfef );
_fbdaa :=_cabga .height (_ebdb );_eeeg :=_ggdc ._bebec [_cabga ._adfd +_cabga ._fbeb -2];if _cabga ._fbeb > 1{_bfgga :=0.0;_fabe :=_ggdc ._bebec [_cabga ._adfd -1:(_cabga ._adfd +_cabga ._fbeb -1)];for _ ,_acdfd :=range _fabe {_bfgga +=_acdfd ;};if _fbdaa <=_bfgga {continue ;
};};if _fbdaa > _eeeg {_eeefd :=_fbdaa /float64 (_cabga ._fbeb );if _eeefd > _eeeg {for _ebgce :=1;_ebgce <=_cabga ._fbeb ;_ebgce ++{if _eeefd > _ggdc ._bebec [_cabga ._adfd +_ebgce -2]{_ggdc ._bebec [_cabga ._adfd +_ebgce -2]=_eeefd ;};};};};};};func _gdgf (_bfbba *templateProcessor ,_fdcfc *templateNode )(interface{},error ){return _bfbba .parseListItem (_fdcfc );
};func _cbfbe (_bagacg *_db .PdfAnnotation )*_db .PdfAnnotation {if _bagacg ==nil {return nil ;};var _fbefc *_db .PdfAnnotation ;switch _gcfbd :=_bagacg .GetContext ().(type ){case *_db .PdfAnnotationLink :if _bcbdg :=_fefbe (_gcfbd );_bcbdg !=nil {_fbefc =_bcbdg .PdfAnnotation ;
};};return _fbefc ;};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_bcaeg *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eccg :=_bcaeg ;if _bcaeg ._dcag {_eccg =_bcaeg .clone ();};return _dfggg (_eccg ,ctx );};func _bega (_efgg []_fg .Point )*Polyline {return &Polyline {_defeg :&_fg .Polyline {Points :_efgg ,LineColor :_db .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_gfdd :1.0};
};func (_fddb *templateProcessor )parseHorizontalAlignmentAttr (_ceab ,_aeba string )HorizontalAlignment {_d .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_ceab ,_aeba );
_aecbb :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_aeba ];return _aecbb ;};func _defac (_cgead *Creator ,_gdefg _ba .Reader ,_fcge interface{},_bdebf *TemplateOptions ,_fgaff componentRenderer )error {if _cgead ==nil {_d .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _ccea ;};_adbc :="";if _edfge ,_gdfc :=_gdefg .(*_ae .File );_gdfc {_adbc =_edfge .Name ();};_fafge :=_g .NewBuffer (nil );if _ ,_edag :=_ba .Copy (_fafge ,_gdefg );_edag !=nil {return _edag ;};_badg :=_e .FuncMap {"\u0064\u0069\u0063\u0074":_dgbcf ,"\u0061\u0064\u0064":_bgfgdd ,"\u0061\u0072\u0072a\u0079":_beccfc ,"\u0065\u0078\u0074\u0065\u006e\u0064\u0044\u0069\u0063\u0074":_dgdb ,"\u006da\u006b\u0065\u0053\u0065\u0071":_efggd };
if _bdebf !=nil &&_bdebf .HelperFuncMap !=nil {for _cefef ,_ggfgg :=range _bdebf .HelperFuncMap {if _ ,_begd :=_badg [_cefef ];_begd {_d .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cefef );
continue ;};_badg [_cefef ]=_ggfgg ;};};_gece ,_bccb :=_e .New ("").Funcs (_badg ).Parse (_fafge .String ());if _bccb !=nil {return _bccb ;};if _bdebf !=nil &&_bdebf .SubtemplateMap !=nil {for _cacf ,_fdfdde :=range _bdebf .SubtemplateMap {if _cacf ==""{_d .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _fdfdde ==nil {_d .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_gabdd :=_g .NewBuffer (nil );if _ ,_gdafde :=_ba .Copy (_gabdd ,_fdfdde );_gdafde !=nil {return _gdafde ;};if _ ,_dbfe :=_gece .New (_cacf ).Parse (_gabdd .String ());_dbfe !=nil {return _dbfe ;};};};_fafge .Reset ();if _cagd :=_gece .Execute (_fafge ,_fcge );
_cagd !=nil {return _cagd ;};return _dfgba (_cgead ,_adbc ,_fafge .Bytes (),_bdebf ,_fgaff ).run ();};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_fbca *RadialShading )SetBackgroundColor (backgroundColor Color ){_fbca ._cgec .SetBackgroundColor (backgroundColor );};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_dba *Chapter )GetHeading ()*Paragraph {return _dba ._gdbe };

// SetSideBorderStyle sets the cell's side border style.
func (_cacae *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_cacae ._abed =style ;_cacae ._fddef =style ;_cacae ._gaffc =style ;_cacae ._gcffgc =style ;case CellBorderSideTop :_cacae ._abed =style ;
case CellBorderSideBottom :_cacae ._fddef =style ;case CellBorderSideLeft :_cacae ._gaffc =style ;case CellBorderSideRight :_cacae ._gcffgc =style ;};};func _afgg (_cfcgd *Block ,_bagc *Paragraph ,_badc DrawContext )(DrawContext ,error ){_edecc :=1;_gebf :=_ag .PdfObjectName ("\u0046\u006f\u006e\u0074"+_eg .Itoa (_edecc ));
for _cfcgd ._aef .HasFontByName (_gebf ){_edecc ++;_gebf =_ag .PdfObjectName ("\u0046\u006f\u006e\u0074"+_eg .Itoa (_edecc ));};_baceg :=_cfcgd ._aef .SetFontByName (_gebf ,_bagc ._bccd .ToPdfObject ());if _baceg !=nil {return _badc ,_baceg ;};_bagc .wrapText ();
_edeca :=_cf .NewContentCreator ();_edeca .Add_q ();_cabg :=_badc .PageHeight -_badc .Y -_bagc ._bbgda *_bagc ._becfe ;_edeca .Translate (_badc .X ,_cabg );if _bagc ._fgefg !=0{_edeca .RotateDeg (_bagc ._fgefg );};_eebcd :=_afb (_bagc ._afbce );_baceg =_edcb (_cfcgd ,_eebcd ,_bagc ._afbce ,func ()Rectangle {return Rectangle {_dbgeg :_badc .X ,_gead :_cabg ,_bccac :_bagc .getMaxLineWidth ()/1000.0,_begbb :_bagc .Height ()};
});if _baceg !=nil {return _badc ,_baceg ;};_edeca .Add_BT ().SetNonStrokingColor (_eebcd ).Add_Tf (_gebf ,_bagc ._bbgda ).Add_TL (_bagc ._bbgda *_bagc ._becfe );for _baae ,_adcb :=range _bagc ._fcfba {if _baae !=0{_edeca .Add_Tstar ();};_aedc :=[]rune (_adcb );
_ggbe :=0.0;_gfdf :=0;for _aabec ,_baagg :=range _aedc {if _baagg ==' '{_gfdf ++;continue ;};if _baagg =='\u000A'{continue ;};_fcaed ,_abee :=_bagc ._bccd .GetRuneMetrics (_baagg );if !_abee {_d .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_aabec ,_baagg ,_baagg ,_bagc ._bccd .BaseFont (),_bagc ._bccd .Subtype ());
return _badc ,_ab .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_ggbe +=_bagc ._bbgda *_fcaed .Wx ;};var _fbef []_ag .PdfObject ;_egdgf ,_fceb :=_bagc ._bccd .GetRuneMetrics (' ');
if !_fceb {return _badc ,_ab .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_bggeg :=_egdgf .Wx ;switch _bagc ._ddcf {case TextAlignmentJustify :if _gfdf > 0&&_baae < len (_bagc ._fcfba )-1{_bggeg =(_bagc ._cbeda *1000.0-_ggbe )/float64 (_gfdf )/_bagc ._bbgda ;
};case TextAlignmentCenter :_caee :=_ggbe +float64 (_gfdf )*_bggeg *_bagc ._bbgda ;_ecdfe :=(_bagc ._cbeda *1000.0-_caee )/2/_bagc ._bbgda ;_fbef =append (_fbef ,_ag .MakeFloat (-_ecdfe ));case TextAlignmentRight :_eaca :=_ggbe +float64 (_gfdf )*_bggeg *_bagc ._bbgda ;
_adebd :=(_bagc ._cbeda *1000.0-_eaca )/_bagc ._bbgda ;_fbef =append (_fbef ,_ag .MakeFloat (-_adebd ));};_dabef :=_bagc ._bccd .Encoder ();var _aadb []byte ;for _ ,_fbda :=range _aedc {if _fbda =='\u000A'{continue ;};if _fbda ==' '{if len (_aadb )> 0{_fbef =append (_fbef ,_ag .MakeStringFromBytes (_aadb ));
_aadb =nil ;};_fbef =append (_fbef ,_ag .MakeFloat (-_bggeg ));}else {if _ ,_dafc :=_dabef .RuneToCharcode (_fbda );!_dafc {_baceg =UnsupportedRuneError {Message :_f .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_fbda ,_fbda ),Rune :_fbda };
_badc ._ccd =append (_badc ._ccd ,_baceg );_d .Log .Debug (_baceg .Error ());if _badc ._dfe <=0{continue ;};_fbda =_badc ._dfe ;};_aadb =append (_aadb ,_dabef .Encode (string (_fbda ))...);};};if len (_aadb )> 0{_fbef =append (_fbef ,_ag .MakeStringFromBytes (_aadb ));
};_edeca .Add_TJ (_fbef ...);};_edeca .Add_ET ();_edeca .Add_Q ();_bggfa :=_edeca .Operations ();_bggfa .WrapIfNeeded ();_cfcgd .addContents (_bggfa );if _bagc ._bdbg .IsRelative (){_cbbg :=_bagc .Height ();_badc .Y +=_cbbg ;_badc .Height -=_cbbg ;if _badc .Inline {_badc .X +=_bagc .Width ()+_bagc ._fdda .Right ;
};};return _badc ,nil ;};func _cbaf (_ffede string ,_daeee ,_fgbfe TextStyle )*TOC {_defag :=_fgbfe ;_defag .FontSize =14;_fadb :=_gfbe (_defag );_fadb .SetEnableWrap (true );_fadb .SetTextAlignment (TextAlignmentLeft );_fadb .SetMargins (0,0,0,5);_ceagb :=_fadb .Append (_ffede );
_ceagb .Style =_defag ;return &TOC {_gafa :_fadb ,_bcaf :[]*TOCLine {},_gfdgb :_daeee ,_becab :_daeee ,_eddb :_daeee ,_fafd :_daeee ,_defdd :"\u002e",_egab :10,_cadb :Margins {0,0,2,2},_dfcba :PositionRelative ,_ebfbc :_daeee ,_ffcgd :true };};

// BorderWidth returns the border width of the ellipse.
func (_faag *Ellipse )BorderWidth ()float64 {return _faag ._gcef };

// SetEnableWrap sets the line wrapping enabled flag.
func (_fgfa *StyledParagraph )SetEnableWrap (enableWrap bool ){_fgfa ._bbff =enableWrap ;_fgfa ._dgcd =false ;};

// Height returns the height of the ellipse.
func (_aba *Ellipse )Height ()float64 {return _aba ._faea };

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_gcggg *Image )ScaleToHeight (h float64 ){_abde :=_gcggg ._daba /_gcggg ._gafb ;_gcggg ._gafb =h ;_gcggg ._daba =h *_abde ;};

// AddColorStop add color stop information for rendering gradient.
func (_aggbe *shading )AddColorStop (color Color ,point float64 ){_aggbe ._fgcdg =append (_aggbe ._fgcdg ,_bdcb (color ,point ));};func (_efedg *Rectangle )applyFitMode (_agfc float64 ){_agfc -=_efedg ._cbagd .Left +_efedg ._cbagd .Right +_efedg ._ccde ;
switch _efedg ._bbc {case FitModeFillWidth :_efedg .ScaleToWidth (_agfc );};};

// SetBorderOpacity sets the border opacity.
func (_eaade *Polygon )SetBorderOpacity (opacity float64 ){_eaade ._geeda =opacity };

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_fefa *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_adca :=_gfbe (_fefa ._fcad );_adca .Append (text );_efcaa ,_baeg :=_fefa .Add (_adca );return _adca ,_efcaa ,_baeg ;};func _baea (_agbaa []*ColorPoint )*LinearShading {return &LinearShading {_gdcc :&shading {_gccca :ColorWhite ,_cgfde :false ,_gagd :[]bool {false ,false },_fgcdg :_agbaa },_ggge :&_db .PdfRectangle {}};
};

// BorderWidth returns the border width of the rectangle.
func (_ebba *Rectangle )BorderWidth ()float64 {return _ebba ._ccde };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// Scale scales the ellipse dimensions by the specified factors.
func (_aaa *Ellipse )Scale (xFactor ,yFactor float64 ){_aaa ._bee =xFactor *_aaa ._bee ;_aaa ._faea =yFactor *_aaa ._faea ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_bfg *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bfg ._cbfc .Left ,_bfg ._cbfc .Right ,_bfg ._cbfc .Top ,_bfg ._cbfc .Bottom ;};

// SetLazy sets the lazy mode for the image.
func (_aeccb *Image )SetLazy (lazy bool ){_aeccb ._ddcec =lazy };func (_efecf *templateProcessor )parseColor (_dgdcgd string )Color {if _dgdcgd ==""{return nil ;};_afdc ,_ebac :=_efecf ._cggb .ColorMap [_dgdcgd ];if _ebac {return _afdc ;};if _dgdcgd [0]=='#'{return ColorRGBFromHex (_dgdcgd );
};return nil ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_bbgc *Table )SetPos (x ,y float64 ){_bbgc ._afbg =PositionAbsolute ;_bbgc ._dggde =x ;_bbgc ._gebee =y ;};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_gdgc *Rectangle )Height ()float64 {return _gdgc ._begbb };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_feba *LinearShading )SetBackgroundColor (backgroundColor Color ){_feba ._gdcc .SetBackgroundColor (backgroundColor );};

// GetRowHeight returns the height of the specified row.
func (_eabe *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_eabe ._bebec ){return 0,_ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _eabe ._bebec [row -1],nil ;
};

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_ecef *Paragraph )SetColor (col Color ){_ecef ._afbce =col };func (_ccf rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _ccf ._dcbf ,_ccf ._accg ,_ccf ._bgcg };

// Reset removes all the text chunks the paragraph contains.
func (_aggef *StyledParagraph )Reset (){_aggef ._cdegd =[]*TextChunk {}};

// CreateFrontPage sets a function to generate a front Page.
func (_cgb *Creator )CreateFrontPage (genFrontPageFunc func (_agga FrontpageFunctionArgs )){_cgb ._cecc =genFrontPageFunc ;};

// NewColumn returns a new column for the line items invoice table.
func (_dcad *Invoice )NewColumn (description string )*InvoiceCell {return _dcad .newColumn (description ,CellHorizontalAlignmentLeft );};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_gfcg *Invoice )SetAddressHeadingStyle (style TextStyle ){_gfcg ._ggfb =style };

// NewPageBreak create a new page break.
func (_gcdbc *Creator )NewPageBreak ()*PageBreak {return _cceg ()};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_adgb *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _adgb ._acfa .Left ,_adgb ._acfa .Right ,_adgb ._acfa .Top ,_adgb ._acfa .Bottom ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;
TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);func _acaee (_gaeeg *templateProcessor ,_deffa *templateNode )(interface{},error ){return _gaeeg .parseList (_deffa );
};

// SetLineOpacity sets the line opacity.
func (_badee *Polyline )SetLineOpacity (opacity float64 ){_badee ._gfdd =opacity };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_acdc *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ddcef :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_acegf ,_gdafd :=_ddcef .setOpacity (_acdc ._bfde ,_acdc ._ceaf );if _gdafd !=nil {return nil ,ctx ,_gdafd ;
};_gdda :=_acdc ._bgfa ;_gdda .FillEnabled =_gdda .FillColor !=nil ;var (_dgee =ctx .PageHeight ;_afcge =_gdda .Curves ;_daecc =make ([]_fg .CubicBezierCurve ,0,len (_gdda .Curves )););_gfgcc :=_db .PdfRectangle {};for _dcde :=range _gdda .Curves {_gbbg :=_afcge [_dcde ];
_gbbg .P0 .Y =_dgee -_gbbg .P0 .Y ;_gbbg .P1 .Y =_dgee -_gbbg .P1 .Y ;_gbbg .P2 .Y =_dgee -_gbbg .P2 .Y ;_gbbg .P3 .Y =_dgee -_gbbg .P3 .Y ;_daecc =append (_daecc ,_gbbg );_cede :=_gbbg .GetBounds ();if _dcde ==0{_gfgcc =_cede ;}else {_gfgcc .Llx =_gb .Min (_gfgcc .Llx ,_cede .Llx );
_gfgcc .Lly =_gb .Min (_gfgcc .Lly ,_cede .Lly );_gfgcc .Urx =_gb .Max (_gfgcc .Urx ,_cede .Urx );_gfgcc .Ury =_gb .Max (_gfgcc .Ury ,_cede .Ury );};};_gdda .Curves =_daecc ;defer func (){_gdda .Curves =_afcge }();if _gdda .FillEnabled {_bcdf :=_edcb (_ddcef ,_acdc ._bgfa .FillColor ,_acdc ._fecca ,func ()Rectangle {return Rectangle {_dbgeg :_gfgcc .Llx ,_gead :_gfgcc .Lly ,_bccac :_gfgcc .Width (),_begbb :_gfgcc .Height ()};
});if _bcdf !=nil {return nil ,ctx ,_bcdf ;};};_cddaf ,_ ,_gdafd :=_gdda .Draw (_acegf );if _gdafd !=nil {return nil ,ctx ,_gdafd ;};if _gdafd =_ddcef .addContentsByString (string (_cddaf ));_gdafd !=nil {return nil ,ctx ,_gdafd ;};return []*Block {_ddcef },ctx ,nil ;
};func (_dbd *Block )addContentsByString (_daf string )error {_fd :=_cf .NewContentStreamParser (_daf );_aca ,_egd :=_fd .Parse ();if _egd !=nil {return _egd ;};_dbd ._bag .WrapIfNeeded ();_aca .WrapIfNeeded ();*_dbd ._bag =append (*_dbd ._bag ,*_aca ...);
return nil ;};func (_fecc *Image )applyFitMode (_aagd float64 ){_aagd -=_fecc ._gabc .Left +_fecc ._gabc .Right ;switch _fecc ._gaeef {case FitModeFillWidth :_fecc .ScaleToWidth (_aagd );};};type cmykColor struct{_afc ,_dff ,_edea ,_cec float64 };

// The Image type is used to draw an image onto PDF.
type Image struct{_agda *_db .XObjectImage ;_efbg *_db .Image ;_edaf float64 ;_daba ,_gafb float64 ;_aag ,_dcab float64 ;_dfgd Positioning ;_gcba HorizontalAlignment ;_aeed float64 ;_eede float64 ;_fdfd float64 ;_gabc Margins ;_fegd ,_cccf float64 ;_cegc _ag .StreamEncoder ;
_gaeef FitMode ;_ddcec bool ;};func (_fgcc *StyledParagraph )getTextWidth ()float64 {var _bfbgc float64 ;_ddga :=len (_fgcc ._cdegd );for _ggac ,_aadgb :=range _fgcc ._cdegd {_gdggd :=&_aadgb .Style ;_ceag :=len (_aadgb .Text );for _fbdd ,_fedf :=range _aadgb .Text {if _fedf =='\u000A'{continue ;
};_cbfff ,_deeg :=_gdggd .Font .GetRuneMetrics (_fedf );if !_deeg {_d .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fedf );
return -1;};_bfbgc +=_gdggd .FontSize *_cbfff .Wx *_gdggd .horizontalScale ();if _fedf !=' '&&(_ggac !=_ddga -1||_fbdd !=_ceag -1){_bfbgc +=_gdggd .CharSpacing *1000.0;};};};return _bfbgc ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_cbag *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fce :=_eaa .IdentityMatrix ();_bae ,_dd :=_cbag .Width (),_cbag .Height ();if _cbag ._gg .IsRelative (){_fce =_fce .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_dd );
}else {_fce =_fce .Translate (_cbag ._ad ,ctx .PageHeight -_cbag ._af -_dd );};_cbed :=_dd ;if _cbag ._ga !=0{_fce =_fce .Translate (_bae /2,_dd /2).Rotate (_cbag ._ga *_gb .Pi /180.0).Translate (-_bae /2,-_dd /2);_ ,_cbed =_cbag .RotatedSize ();};if _cbag ._gg .IsRelative (){ctx .Y +=_cbed ;
};_gaf :=_cf .NewContentCreator ();_gaf .Add_cm (_fce [0],_fce [1],_fce [3],_fce [4],_fce [6],_fce [7]);_ed :=_cbag .duplicate ();_efe :=append (*_gaf .Operations (),*_ed ._bag ...);_efe .WrapIfNeeded ();_ed ._bag =&_efe ;for _ ,_da :=range _cbag ._gc {_ace ,_cd :=_ag .GetArray (_da .Rect );
if !_cd ||_ace .Len ()!=4{_d .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_da .Rect );
continue ;};_bad ,_fe :=_db .NewPdfRectangle (*_ace );if _fe !=nil {_d .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_fe );
continue ;};_bad .Transform (_fce );_da .Rect =_bad .ToPdfObject ();};return []*Block {_ed },ctx ,nil ;};

// Height returns the height of the line.
func (_gafcc *Line )Height ()float64 {_edcg :=_gafcc ._dgfab ;if _gafcc ._bbae ==_gafcc ._aafcb {_edcg /=2;};return _gb .Abs (_gafcc ._affa -_gafcc ._effb )+_edcg ;};func (_fgba *TextChunk )clone ()*TextChunk {_cggcf :=*_fgba ;_cggcf ._fedb =_cbfbe (_fgba ._fedb );
return &_cggcf ;};func _cgd (_ceee VectorDrawable ,_dad float64 )float64 {switch _adff :=_ceee .(type ){case *Paragraph :if _adff ._aacg {_adff .SetWidth (_dad -_adff ._fdda .Left -_adff ._fdda .Right );};return _adff .Height ()+_adff ._fdda .Top +_adff ._fdda .Bottom ;
case *StyledParagraph :if _adff ._bbff {_adff .SetWidth (_dad -_adff ._acfa .Left -_adff ._acfa .Right );};return _adff .Height ()+_adff ._acfa .Top +_adff ._acfa .Bottom ;case *Image :_adff .applyFitMode (_dad );return _adff .Height ()+_adff ._gabc .Top +_adff ._gabc .Bottom ;
case *Rectangle :_adff .applyFitMode (_dad );return _adff .Height ()+_adff ._cbagd .Top +_adff ._cbagd .Bottom +_adff ._ccde ;case *Ellipse :_adff .applyFitMode (_dad );return _adff .Height ()+_adff ._fbcgf .Top +_adff ._fbcgf .Bottom ;case *Division :return _adff .ctxHeight (_dad )+_adff ._caeg .Top +_adff ._caeg .Bottom +_adff ._cedd .Top +_adff ._cedd .Bottom ;
case *Table :_adff .updateRowHeights (_dad -_adff ._aaec .Left -_adff ._aaec .Right );return _adff .Height ()+_adff ._aaec .Top +_adff ._aaec .Bottom ;case *List :return _adff .ctxHeight (_dad )+_adff ._ebdfg .Top +_adff ._ebdfg .Bottom ;case marginDrawable :_ ,_ ,_bfbef ,_adad :=_adff .GetMargins ();
return _adff .Height ()+_bfbef +_adad ;default:return _adff .Height ();};};func (_befe *templateProcessor )parseTextOverflowAttr (_ebgdb ,_edfeb string )TextOverflow {_d .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_ebgdb ,_edfeb );
_gcege :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_edfeb ];return _gcege ;};

// ColorGrayFrom8bit creates a Color from 8-bit (0-255) gray values.
// Example:
//
//	gray := ColorGrayFrom8bit(255, 0, 0)
func ColorGrayFrom8bit (g byte )Color {return grayColor {float64 (g )/255.0}};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_gff *Creator )MoveTo (x ,y float64 ){_gff ._edg .X =x ;_gff ._edg .Y =y };

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _gcff (path )};

// Vertical returns total vertical (top + bottom) margin.
func (_ecce *Margins )Vertical ()float64 {return _ecce .Bottom +_ecce .Top };

// SetIndent sets the cell's left indent.
func (_gfdb *TableCell )SetIndent (indent float64 ){_gfdb ._dedb =indent };

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_badf *LinearShading )ToPdfShadingPattern ()*_db .PdfShadingPatternType2 {_dbag ,_gdde ,_ggfd :=_badf ._gdcc ._gccca .ToRGB ();_gffb :=_badf .shadingModel ();_gffb .PdfShading .Background =_ag .MakeArrayFromFloats ([]float64 {_dbag ,_gdde ,_ggfd });
_edgc :=_db .NewPdfShadingPatternType2 ();_edgc .Shading =_gffb ;return _edgc ;};func (_fgfb *Image )rotatedSize ()(float64 ,float64 ){_defg :=_fgfb ._daba ;_fgefe :=_fgfb ._gafb ;_fcace :=_fgfb ._edaf ;if _fcace ==0{return _defg ,_fgefe ;};_gefg :=_fg .Path {Points :[]_fg .Point {_fg .NewPoint (0,0).Rotate (_fcace ),_fg .NewPoint (_defg ,0).Rotate (_fcace ),_fg .NewPoint (0,_fgefe ).Rotate (_fcace ),_fg .NewPoint (_defg ,_fgefe ).Rotate (_fcace )}}.GetBoundingBox ();
return _gefg .Width ,_gefg .Height ;};type templateNode struct{_dfbaa interface{};_fabca _bg .StartElement ;_abgfd *templateNode ;_cbcfg int ;_bdcbd int ;_gebfb int64 ;};

// SetLineWidth sets the line width.
func (_baab *Line )SetLineWidth (width float64 ){_baab ._dgfab =width };func _gbgeb (_degga ,_edcddd ,_fecdf TextChunk ,_beccff uint ,_aacfb TextStyle )*TOCLine {_gfgac :=_gfbe (_aacfb );_gfgac .SetEnableWrap (true );_gfgac .SetTextAlignment (TextAlignmentLeft );
_gfgac .SetMargins (0,0,2,2);_bfef :=&TOCLine {_ffcgc :_gfgac ,Number :_degga ,Title :_edcddd ,Page :_fecdf ,Separator :TextChunk {Text :"\u002e",Style :_aacfb },_gaag :0,_fbgga :_beccff ,_dgcg :10,_efff :PositionRelative };_gfgac ._acfa .Left =_bfef ._gaag +float64 (_bfef ._fbgga -1)*_bfef ._dgcg ;
_gfgac ._cabgb =_bfef .prepareParagraph ;return _bfef ;};func _cdggb (_aeeeec ,_accc ,_bffd string ,_eefbf uint ,_cbdc TextStyle )*TOCLine {return _gbgeb (TextChunk {Text :_aeeeec ,Style :_cbdc },TextChunk {Text :_accc ,Style :_cbdc },TextChunk {Text :_bffd ,Style :_cbdc },_eefbf ,_cbdc );
};func _cedeg (_cbgb *Block ,_dgdd *StyledParagraph ,_gaec [][]*TextChunk ,_dcfg DrawContext )(DrawContext ,[][]*TextChunk ,error ){_fbbed :=1;_daea :=_ag .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fbbed ));for _cbgb ._aef .HasFontByName (_daea ){_fbbed ++;
_daea =_ag .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fbbed ));};_eaaa :=_cbgb ._aef .SetFontByName (_daea ,_dgdd ._abfe .Font .ToPdfObject ());if _eaaa !=nil {return _dcfg ,nil ,_eaaa ;};_fbbed ++;_fcfaf :=_daea ;_gabd :=_dgdd ._abfe .FontSize ;
_cbfde :=_dgdd ._fadf .IsRelative ();var _gcgf [][]_ag .PdfObjectName ;var _aeac [][]*TextChunk ;var _cdgb float64 ;for _fgga ,_egef :=range _gaec {var _aeda []_ag .PdfObjectName ;var _cfbef float64 ;if len (_egef )> 0{_cfbef =_egef [0].Style .FontSize ;
};for _ ,_gcffe :=range _egef {_ffafa :=_gcffe .Style ;if _gcffe .Text !=""&&_ffafa .FontSize > _cfbef {_cfbef =_ffafa .FontSize ;};if _cfbef > _dcfg .PageHeight {return _dcfg ,nil ,_ab .New ("\u0050\u0061\u0072\u0061\u0067\u0072a\u0070\u0068\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u006ca\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0070\u0061\u0067\u0065 \u0068e\u0069\u0067\u0068\u0074");
};_daea =_ag .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fbbed ));_fccbe :=_cbgb ._aef .SetFontByName (_daea ,_ffafa .Font .ToPdfObject ());if _fccbe !=nil {return _dcfg ,nil ,_fccbe ;};_aeda =append (_aeda ,_daea );_fbbed ++;};
_cfbef *=_dgdd ._gfae ;if _cbfde &&_cdgb +_cfbef > _dcfg .Height {_aeac =_gaec [_fgga :];_gaec =_gaec [:_fgga ];break ;};_cdgb +=_cfbef ;_gcgf =append (_gcgf ,_aeda );};_bffe ,_bfgef ,_egcaf :=_dgdd .getLineMetrics (0);_fgfc ,_gcabb :=_bffe *_dgdd ._gfae ,_bfgef *_dgdd ._gfae ;
if len (_gaec )==0{return _dcfg ,_aeac ,nil ;};_gbfc :=_cf .NewContentCreator ();_gbfc .Add_q ();_dgba :=_gcabb ;if _dgdd ._gabbd ==TextVerticalAlignmentCenter {_dgba =_bfgef +(_bffe +_egcaf -_bfgef )/2+(_gcabb -_bfgef )/2;};_aaef :=_dcfg .PageHeight -_dcfg .Y -_dgba ;
_gbfc .Translate (_dcfg .X ,_aaef );_becd :=_aaef ;if _dgdd ._bgbbb !=0{_gbfc .RotateDeg (_dgdd ._bgbbb );};if _dgdd ._ddade ==TextOverflowHidden {_gbfc .Add_re (0,-_cdgb +_fgfc +1,_dgdd ._baaga ,_cdgb ).Add_W ().Add_n ();};_gbfc .Add_BT ();var _fdef []*_fg .BasicLine ;
for _fadd ,_cecg :=range _gaec {_bdec :=_dcfg .X ;var _gcdde float64 ;if len (_cecg )> 0{_gcdde =_cecg [0].Style .FontSize ;};_bffe ,_ ,_egcaf =_dgdd .getLineMetrics (_fadd );_gcabb =(_bffe +_egcaf );for _ ,_edbdc :=range _cecg {_bebcd :=&_edbdc .Style ;
if _edbdc .Text !=""&&_bebcd .FontSize > _gcdde {_gcdde =_bebcd .FontSize ;};if _gcabb > _gcdde {_gcdde =_gcabb ;};};if _fadd !=0{_gbfc .Add_TD (0,-_gcdde *_dgdd ._gfae );_becd -=_gcdde *_dgdd ._gfae ;};_ggdbf :=_fadd ==len (_gaec )-1;var (_dbefe float64 ;
_dbefg float64 ;_bggcg *fontMetrics ;_fgdd float64 ;_dbffbe uint ;);var _gffcd []float64 ;for _ ,_cggg :=range _cecg {_bdff :=&_cggg .Style ;if _bdff .FontSize > _dbefg {_dbefg =_bdff .FontSize ;_bggcg =_agaa (_cggg .Style .Font ,_bdff .FontSize );};if _gcabb > _dbefg {_dbefg =_gcabb ;
};_cdgc ,_dbefaf :=_bdff .Font .GetRuneMetrics (' ');if _cdgc .Wx ==0&&_bdff .MultiFont !=nil {_cdgc ,_dbefaf =_bdff .MultiFont .GetRuneMetrics (' ');_bdff .MultiFont .Reset ();};if !_dbefaf {return _dcfg ,nil ,_ab .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _dbbaf uint ;var _bdea float64 ;_gcea :=len (_cggg .Text );for _aeec ,_fcebd :=range _cggg .Text {if _fcebd ==' '{_dbbaf ++;continue ;};if _fcebd =='\u000A'{continue ;};_ggcg ,_bffg :=_bdff .Font .GetRuneMetrics (_fcebd );if _ggcg .Wx ==0&&_bdff .MultiFont !=nil {_ggcg ,_bffg =_bdff .MultiFont .GetRuneMetrics (' ');
_bdff .MultiFont .Reset ();};if !_bffg {_d .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_fcebd );return _dcfg ,nil ,_ab .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");
};_bdea +=_bdff .FontSize *_ggcg .Wx *_bdff .horizontalScale ();if _aeec !=_gcea -1{_bdea +=_bdff .CharSpacing *1000.0;};};_gffcd =append (_gffcd ,_bdea );_dbefe +=_bdea ;_fgdd +=float64 (_dbbaf )*_cdgc .Wx *_bdff .FontSize *_bdff .horizontalScale ();_dbffbe +=_dbbaf ;
};_dbefg *=_dgdd ._gfae ;var _ceagc []_ag .PdfObject ;_bgbcd :=_dgdd ._baaga *1000.0;if _dgdd ._efdff ==TextAlignmentJustify {if _dbffbe > 0&&!_ggdbf {_fgdd =(_bgbcd -_dbefe )/float64 (_dbffbe )/_gabd ;};}else if _dgdd ._efdff ==TextAlignmentCenter {_gbbf :=(_bgbcd -_dbefe -_fgdd )/2;
_dffc :=_gbbf /_gabd ;_ceagc =append (_ceagc ,_ag .MakeFloat (-_dffc ));_bdec +=_gbbf /1000.0;}else if _dgdd ._efdff ==TextAlignmentRight {_cfdfg :=(_bgbcd -_dbefe -_fgdd );_cdgbd :=_cfdfg /_gabd ;_ceagc =append (_ceagc ,_ag .MakeFloat (-_cdgbd ));_bdec +=_cfdfg /1000.0;
};if len (_ceagc )> 0{_gbfc .Add_Tf (_fcfaf ,_gabd ).Add_TL (_gabd *_dgdd ._gfae ).Add_TJ (_ceagc ...);};_cgbea :=0.0;for _baec ,_dfbe :=range _cecg {_bdcbe :=&_dfbe .Style ;_aeaac :=_fcfaf ;_ddgee :=_gabd ;_bceb :=_bdcbe .OutlineColor !=nil ;_daecd :=_bdcbe .HorizontalScaling !=DefaultHorizontalScaling ;
_dfef :=_bdcbe .OutlineSize !=1;if _dfef {_gbfc .Add_w (_bdcbe .OutlineSize );};_cdfd :=_bdcbe .RenderingMode !=TextRenderingModeFill ;if _cdfd {_gbfc .Add_Tr (int64 (_bdcbe .RenderingMode ));};_ggfg :=_bdcbe .CharSpacing !=0;if _ggfg {_gbfc .Add_Tc (_bdcbe .CharSpacing );
};_cgbcg :=_bdcbe .TextRise !=0;if _cgbcg {_gbfc .Add_Ts (_bdcbe .TextRise );};if _dfbe .VerticalAlignment !=TextVerticalAlignmentBaseline {_ededd :=_agaa (_dfbe .Style .Font ,_bdcbe .FontSize );switch _dfbe .VerticalAlignment {case TextVerticalAlignmentCenter :_cgbea =_bggcg ._bfee /2-_ededd ._bfee /2;
case TextVerticalAlignmentBottom :_cgbea =_bggcg ._ccbag -_ededd ._ccbag ;case TextVerticalAlignmentTop :_cgbea =_bfgef -_bdcbe .FontSize ;};if _cgbea !=0.0{_gbfc .Translate (0,_cgbea );};};if _dgdd ._efdff !=TextAlignmentJustify ||_ggdbf {_gebfd ,_fcbb :=_bdcbe .Font .GetRuneMetrics (' ');
if !_fcbb {return _dcfg ,nil ,_ab .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_aeaac =_gcgf [_fadd ][_baec ];_ddgee =_bdcbe .FontSize ;
_fgdd =_gebfd .Wx *_bdcbe .horizontalScale ();};_aedeg :=_bdcbe .Font .Encoder ();var _geebd []byte ;var _aafb bool ;_eccc :=_bdcbe .Font ;for _ ,_ffce :=range _dfbe .Text {if _ffce =='\u000A'{continue ;};if _ffce ==' '{if len (_geebd )> 0{if _bceb {_gbfc .SetStrokingColor (_afb (_bdcbe .OutlineColor ));
};if _daecd {_gbfc .Add_Tz (_bdcbe .HorizontalScaling );};_eadgc :=_gcgf [_fadd ][_baec ];if _aafb {_eadgc =_ag .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fbbed ));_cdffa :=_cbgb ._aef .SetFontByName (_eadgc ,_eccc .ToPdfObject ());
if _cdffa !=nil {return _dcfg ,nil ,_cdffa ;};_fbbed ++;_aafb =false ;_aedeg =_bdcbe .Font .Encoder ();};_gbfc .SetNonStrokingColor (_afb (_bdcbe .Color )).Add_Tf (_eadgc ,_bdcbe .FontSize ).Add_TJ ([]_ag .PdfObject {_ag .MakeStringFromBytes (_geebd )}...);
_geebd =nil ;};if _daecd {_gbfc .Add_Tz (DefaultHorizontalScaling );};_gbfc .Add_Tf (_aeaac ,_ddgee ).Add_TJ ([]_ag .PdfObject {_ag .MakeFloat (-_fgdd )}...);_gffcd [_baec ]+=_fgdd *_ddgee ;}else {if _ ,_bggbf :=_aedeg .RuneToCharcode (_ffce );!_bggbf {if _bdcbe .MultiFont !=nil {_geeba ,_gccd :=_bdcbe .MultiFont .Encoder (_ffce );
if _gccd {if len (_geebd )!=0{_bbdbd :=_ag .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fbbed ));_gaac :=_cbgb ._aef .SetFontByName (_aeaac ,_eccc .ToPdfObject ());if _gaac !=nil {return _dcfg ,nil ,_gaac ;};_gbfc .SetNonStrokingColor (_afb (_bdcbe .Color )).Add_Tf (_bbdbd ,_bdcbe .FontSize ).Add_TJ ([]_ag .PdfObject {_ag .MakeStringFromBytes (_geebd )}...);
_fbbed ++;_geebd =nil ;};_aedeg =_geeba ;_aafb =true ;_eccc =_bdcbe .MultiFont .CurrentFont ;};}else {_eaaa =UnsupportedRuneError {Message :_f .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ffce ,_ffce ),Rune :_ffce };
_dcfg ._ccd =append (_dcfg ._ccd ,_eaaa );_d .Log .Debug (_eaaa .Error ());if _dcfg ._dfe <=0{continue ;};_ffce =_dcfg ._dfe ;};};_dgcdb :=_aedeg .Encode (string (_ffce ));_geebd =append (_geebd ,_dgcdb ...);};if _bdcbe .MultiFont !=nil {_bdcbe .MultiFont .Reset ();
};};if len (_geebd )> 0{if _bceb {_gbfc .SetStrokingColor (_afb (_bdcbe .OutlineColor ));};if _daecd {_gbfc .Add_Tz (_bdcbe .HorizontalScaling );};_ffff :=_gcgf [_fadd ][_baec ];if _aafb {_ffff =_ag .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fbbed ));
_gccdb :=_cbgb ._aef .SetFontByName (_ffff ,_eccc .ToPdfObject ());if _gccdb !=nil {return _dcfg ,nil ,_gccdb ;};_fbbed ++;_aafb =false ;};_gbfc .SetNonStrokingColor (_afb (_bdcbe .Color )).Add_Tf (_ffff ,_bdcbe .FontSize ).Add_TJ ([]_ag .PdfObject {_ag .MakeStringFromBytes (_geebd )}...);
};_aeebe :=_gffcd [_baec ]/1000.0;if _bdcbe .Underline {_dcdbd :=_bdcbe .UnderlineStyle .Color ;if _dcdbd ==nil {_dcdbd =_dfbe .Style .Color ;};_bagg ,_cadec ,_defgc :=_dcdbd .ToRGB ();_abbg :=_bdec -_dcfg .X ;_ecged :=_becd -_aaef +_bdcbe .TextRise -_bdcbe .UnderlineStyle .Offset ;
_fdef =append (_fdef ,&_fg .BasicLine {X1 :_abbg ,Y1 :_ecged ,X2 :_abbg +_aeebe ,Y2 :_ecged ,LineWidth :_dfbe .Style .UnderlineStyle .Thickness ,LineColor :_db .NewPdfColorDeviceRGB (_bagg ,_cadec ,_defgc )});};if _dfbe ._fedb !=nil {var _fcbcb *_ag .PdfObjectArray ;
if !_dfbe ._edbdff {switch _cbge :=_dfbe ._fedb .GetContext ().(type ){case *_db .PdfAnnotationLink :_fcbcb =_ag .MakeArray ();_cbge .Rect =_fcbcb ;_abdc ,_dcae :=_cbge .Dest .(*_ag .PdfObjectArray );if _dcae &&_abdc .Len ()==5{_dbaa ,_dcdac :=_abdc .Get (1).(*_ag .PdfObjectName );
if _dcdac &&_dbaa .String ()=="\u0058\u0059\u005a"{_dcee ,_gbdf :=_ag .GetNumberAsFloat (_abdc .Get (3));if _gbdf ==nil {_abdc .Set (3,_ag .MakeFloat (_dcfg .PageHeight -_dcee ));};};};};_dfbe ._edbdff =true ;};if _fcbcb !=nil {_geebe :=_fg .NewPoint (_bdec -_dcfg .X ,_becd +_bdcbe .TextRise -_aaef ).Rotate (_dgdd ._bgbbb );
_geebe .X +=_dcfg .X ;_geebe .Y +=_aaef ;_dcgda ,_bdeef ,_dcgfbg ,_ccbgb :=_egdd (_aeebe ,_dbefg ,_dgdd ._bgbbb );_geebe .X +=_dcgda ;_geebe .Y +=_bdeef ;_fcbcb .Clear ();_fcbcb .Append (_ag .MakeFloat (_geebe .X ));_fcbcb .Append (_ag .MakeFloat (_geebe .Y ));
_fcbcb .Append (_ag .MakeFloat (_geebe .X +_dcgfbg ));_fcbcb .Append (_ag .MakeFloat (_geebe .Y +_ccbgb ));};_cbgb .AddAnnotation (_dfbe ._fedb );};_bdec +=_aeebe ;if _dfef {_gbfc .Add_w (1.0);};if _bceb {_gbfc .Add_RG (0.0,0.0,0.0);};if _cdfd {_gbfc .Add_Tr (int64 (TextRenderingModeFill ));
};if _ggfg {_gbfc .Add_Tc (0);};if _cgbcg {_gbfc .Add_Ts (0);};if _daecd {_gbfc .Add_Tz (DefaultHorizontalScaling );};if _cgbea !=0.0{_gbfc .Translate (0,-_cgbea );_cgbea =0.0;};};};_gbfc .Add_ET ();for _ ,_bdeed :=range _fdef {_gbfc .SetStrokingColor (_bdeed .LineColor ).Add_w (_bdeed .LineWidth ).Add_m (_bdeed .X1 ,_bdeed .Y1 ).Add_l (_bdeed .X2 ,_bdeed .Y2 ).Add_s ();
};_gbfc .Add_Q ();_gddab :=_gbfc .Operations ();_gddab .WrapIfNeeded ();_cbgb .addContents (_gddab );if _cbfde {_bfddcd :=_cdgb ;_dcfg .Y +=_bfddcd ;_dcfg .Height -=_bfddcd ;if _dcfg .Inline {_dcfg .X +=_dgdd .Width ()+_dgdd ._acfa .Right ;};};return _dcfg ,_aeac ,nil ;
};func _agea (_fcba string )*_db .PdfAnnotation {_efdab :=_db .NewPdfAnnotationLink ();_acgb :=_db .NewBorderStyle ();_acgb .SetBorderWidth (0);_efdab .BS =_acgb .ToPdfObject ();_bede :=_db .NewPdfActionURI ();_bede .URI =_ag .MakeString (_fcba );_efdab .SetAction (_bede .PdfAction );
return _efdab .PdfAnnotation ;};

// WriteToFile writes the Creator output to file specified by path.
func (_acec *Creator )WriteToFile (outputPath string )error {_abefd ,_gfbg :=_ae .Create (outputPath );if _gfbg !=nil {return _gfbg ;};defer _abefd .Close ();return _acec .Write (_abefd );};func (_edbea *templateProcessor )parseFloatArray (_dbca ,_ccbef string )[]float64 {_d .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dbca ,_ccbef );
_cgfdg :=_cc .Fields (_ccbef );_egeef :=make ([]float64 ,0,len (_cgfdg ));for _ ,_bccgc :=range _cgfdg {_fffg ,_ :=_eg .ParseFloat (_bccgc ,64);_egeef =append (_egeef ,_fffg );};return _egeef ;};func (_eddeg *templateProcessor )parseColorAttr (_efeaf ,_acdaf string )Color {_d .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_efeaf ,_acdaf );
_acdaf =_cc .TrimSpace (_acdaf );if _cc .HasPrefix (_acdaf ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_cc .HasSuffix (_acdaf ,"\u0029")&&len (_acdaf )> 17{return _eddeg .parseLinearGradientAttr (_eddeg .creator ,_acdaf );
};if _cc .HasPrefix (_acdaf ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_cc .HasSuffix (_acdaf ,"\u0029")&&len (_acdaf )> 17{return _eddeg .parseRadialGradientAttr (_eddeg .creator ,_acdaf );};if _efbc :=_eddeg .parseColor (_acdaf );
_efbc !=nil {return _efbc ;};return ColorBlack ;};

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_ecgeg *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_ecgeg ._ggdb =dashArray ;_ecgeg ._defa =dashPhase ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_dced *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_gag []*Block ;_gffc bool ;_gcf error ;_gedd =_dced ._fbe .IsRelative ();_gdadd =_dced ._caeg .Top ;);if _gedd &&!_dced ._eage &&!_dced ._eaad {_bgbc :=_dced .ctxHeight (ctx .Width );
if _bgbc > ctx .Height -_dced ._caeg .Top &&_bgbc <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _gag ,ctx ,_gcf =_cceg ().GeneratePageBlocks (ctx );_gcf !=nil {return nil ,ctx ,_gcf ;};_gffc =true ;_gdadd =0;};};_fbfd :=ctx ;_dbge :=ctx ;
if _gedd {ctx .X +=_dced ._caeg .Left ;ctx .Y +=_gdadd ;ctx .Width -=_dced ._caeg .Left +_dced ._caeg .Right ;ctx .Height -=_gdadd ;_dbge =ctx ;ctx .X +=_dced ._cedd .Left ;ctx .Y +=_dced ._cedd .Top ;ctx .Width -=_dced ._cedd .Left +_dced ._cedd .Right ;
ctx .Height -=_dced ._cedd .Top ;ctx .Margins .Top +=_dced ._cedd .Top ;ctx .Margins .Bottom +=_dced ._cedd .Bottom ;ctx .Margins .Left +=_dced ._caeg .Left +_dced ._cedd .Left ;ctx .Margins .Right +=_dced ._caeg .Right +_dced ._cedd .Right ;};ctx .Inline =_dced ._eaad ;
_eae :=ctx ;_cddgd :=ctx ;var _eaae float64 ;for _ ,_aff :=range _dced ._gcdd {if ctx .Inline {if (ctx .X -_eae .X )+_aff .Width ()<=ctx .Width {ctx .Y =_cddgd .Y ;ctx .Height =_cddgd .Height ;}else {ctx .X =_eae .X ;ctx .Width =_eae .Width ;_cddgd .Y +=_eaae ;
_cddgd .Height -=_eaae ;_eaae =0;};};_cgeb ,_ffab ,_bgcge :=_aff .GeneratePageBlocks (ctx );if _bgcge !=nil {_d .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_bgcge );
return nil ,ctx ,_bgcge ;};if len (_cgeb )< 1{continue ;};if len (_gag )> 0{_gag [len (_gag )-1].mergeBlocks (_cgeb [0]);_gag =append (_gag ,_cgeb [1:]...);}else {if _fgbb :=_cgeb [0]._bag ;_fgbb ==nil ||len (*_fgbb )==0{_gffc =true ;};_gag =append (_gag ,_cgeb [0:]...);
};if ctx .Inline {if ctx .Page !=_ffab .Page {_eae .Y =ctx .Margins .Top ;_eae .Height =ctx .PageHeight -ctx .Margins .Top ;_cddgd .Y =_eae .Y ;_cddgd .Height =_eae .Height ;_eaae =_ffab .Height -_eae .Height ;}else {if _cgaa :=ctx .Height -_ffab .Height ;
_cgaa > _eaae {_eaae =_cgaa ;};};}else {_ffab .X =ctx .X ;};ctx =_ffab ;};if len (_dced ._gcdd )==0{_aeaa :=NewBlock (ctx .Width ,0);_gag =append (_gag ,_aeaa );};ctx .Inline =_fbfd .Inline ;ctx .Margins =_fbfd .Margins ;if _gedd {ctx .X =_fbfd .X ;ctx .Width =_fbfd .Width ;
ctx .Y +=_dced ._cedd .Bottom ;ctx .Height -=_dced ._cedd .Bottom ;};if _dced ._cgeg !=nil {_gag ,_gcf =_dced .drawBackground (_gag ,_dbge ,ctx ,_gffc );if _gcf !=nil {return nil ,ctx ,_gcf ;};};if _dced ._fbe .IsAbsolute (){return _gag ,_fbfd ,nil ;};
ctx .Y +=_dced ._caeg .Bottom ;ctx .Height -=_dced ._caeg .Bottom ;return _gag ,ctx ,nil ;};func (_fcgcf *templateProcessor )parseChapterHeading (_cbgeb *templateNode )(interface{},error ){if _cbgeb ._abgfd ==nil {_fcgcf .nodeLogError (_cbgeb ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_cdfg ;};_ccce ,_gcbcb :=_cbgeb ._abgfd ._dfbaa .(*Chapter );if !_gcbcb {_fcgcf .nodeLogError (_cbgeb ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_cbgeb ._abgfd ._dfbaa );
return nil ,_cdfg ;};_daada :=_ccce .GetHeading ();if _ ,_edccf :=_fcgcf .parseParagraph (_cbgeb ,_daada );_edccf !=nil {return nil ,_edccf ;};return _daada ,nil ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_gbgef *LinearShading )SetExtends (start bool ,end bool ){_gbgef ._gdcc .SetExtends (start ,end )};

// GeneratePageBlocks draws the chart onto a block.
func (_fcfg *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fbfe :=ctx ;_eabb :=_fcfg ._aeee .IsRelative ();var _deed []*Block ;if _eabb {_bgea :=1.0;_cbbf :=_fcfg ._ffa .Top ;if float64 (_fcfg ._aefd .Height ())> ctx .Height -_fcfg ._ffa .Top {_deed =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _aab error ;if _ ,ctx ,_aab =_cceg ().GeneratePageBlocks (ctx );_aab !=nil {return nil ,ctx ,_aab ;};_cbbf =0;};ctx .X +=_fcfg ._ffa .Left +_bgea ;ctx .Y +=_cbbf ;ctx .Width -=_fcfg ._ffa .Left +_fcfg ._ffa .Right +2*_bgea ;ctx .Height -=_cbbf ;_fcfg ._aefd .SetWidth (int (ctx .Width ));
}else {ctx .X =_fcfg ._defe ;ctx .Y =_fcfg ._acf ;};_dbdg :=_cf .NewContentCreator ();_dbdg .Translate (0,ctx .PageHeight );_dbdg .Scale (1,-1);_dbdg .Translate (ctx .X ,ctx .Y );_defd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fcfg ._aefd .Render (_gbe .NewRenderer (_dbdg ,_defd ._aef ),nil );
if _cege :=_defd .addContentsByString (_dbdg .String ());_cege !=nil {return nil ,ctx ,_cege ;};if _eabb {_gfd :=_fcfg .Height ()+_fcfg ._ffa .Bottom ;ctx .Y +=_gfd ;ctx .Height -=_gfd ;}else {ctx =_fbfe ;};_deed =append (_deed ,_defd );return _deed ,ctx ,nil ;
};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_bcce *Creator )SetOptimizer (optimizer _db .Optimizer ){_bcce ._egdg =optimizer };

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_befcd *Table )EnablePageWrap (enable bool ){_befcd ._ceef =enable };func _begb (_ecbgg ,_bdggc ,_afbc ,_cbga float64 )*Line {return &Line {_bbae :_ecbgg ,_effb :_bdggc ,_aafcb :_afbc ,_affa :_cbga ,_ccg :ColorBlack ,_edbfcd :1.0,_dgfab :1.0,_ggdb :[]int64 {1,1},_fdgb :PositionAbsolute };
};

// SetColorLeft sets border color for left.
func (_bfb *border )SetColorLeft (col Color ){_bfb ._ecd =col };func (_bdbf *Creator )wrapPageIfNeeded (_ddef *_db .PdfPage )(*_db .PdfPage ,error ){_bbbc ,_afgb :=_ddef .GetAllContentStreams ();if _afgb !=nil {return nil ,_afgb ;};_aegf :=_cf .NewContentStreamParser (_bbbc );
_agfe ,_afgb :=_aegf .Parse ();if _afgb !=nil {return nil ,_afgb ;};if !_agfe .HasUnclosedQ (){return nil ,nil ;};_agfe .WrapIfNeeded ();_fcfd ,_afgb :=_ag .MakeStream (_agfe .Bytes (),_ag .NewFlateEncoder ());if _afgb !=nil {return nil ,_afgb ;};_ddef .Contents =_ag .MakeArray (_fcfd );
return _ddef ,nil ;};

// Width returns the width of the graphic svg.
func (_fbgf *GraphicSVG )Width ()float64 {return _fbgf ._gddd .Width };const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// Height returns the total height of all rows.
func (_deggd *Table )Height ()float64 {_cbagde :=float64 (0.0);for _ ,_egdcd :=range _deggd ._bebec {_cbagde +=_egdcd ;};return _cbagde ;};

// SetPos sets absolute positioning with specified coordinates.
func (_eecd *StyledParagraph )SetPos (x ,y float64 ){_eecd ._fadf =PositionAbsolute ;_eecd ._afceb =x ;_eecd ._dadc =y ;};

// String implements error interface.
func (_acdf UnsupportedRuneError )Error ()string {return _acdf .Message };func (_eabc *listItem )ctxHeight (_agecc float64 )float64 {var _dcgfb float64 ;switch _gcbca :=_eabc ._cbea .(type ){case *Paragraph :if _gcbca ._aacg {_gcbca .SetWidth (_agecc -_gcbca ._fdda .Horizontal ());
};_dcgfb =_gcbca .Height ()+_gcbca ._fdda .Vertical ();_dcgfb +=0.5*_gcbca ._bbgda *_gcbca ._becfe ;case *StyledParagraph :if _gcbca ._bbff {_gcbca .SetWidth (_agecc -_gcbca ._acfa .Horizontal ());};_dcgfb =_gcbca .Height ()+_gcbca ._acfa .Vertical ();
_dcgfb +=0.5*_gcbca .getTextHeight ();case *List :_cbdea :=_agecc -_eabc ._bdaa .Width ()-_gcbca ._ebdfg .Horizontal ()-_gcbca ._adge ;_dcgfb =_gcbca .ctxHeight (_cbdea )+_gcbca ._ebdfg .Vertical ();case *Image :_dcgfb =_gcbca .Height ()+_gcbca ._gabc .Vertical ();
case *Division :_geefa :=_agecc -_eabc ._bdaa .Width ()-_gcbca ._caeg .Horizontal ();_dcgfb =_gcbca .ctxHeight (_geefa )+_gcbca ._caeg .Vertical ();case *Table :_edcda :=_agecc -_eabc ._bdaa .Width ()-_gcbca ._aaec .Horizontal ();_gcbca .updateRowHeights (_edcda );
_dcgfb =_gcbca .Height ()+_gcbca ._aaec .Vertical ();default:_dcgfb =_eabc ._cbea .Height ();};return _dcgfb ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_gdgb Color ;_gbebf _fg .LineStyle ;_gaffc CellBorderStyle ;_cfge Color ;_ddda float64 ;_fddef CellBorderStyle ;_ddac Color ;_bdbe float64 ;_gcffgc CellBorderStyle ;_gbbdf Color ;_gcfeg float64 ;_abed CellBorderStyle ;_babeg Color ;
_ffbcg float64 ;_adfd ,_bcea int ;_fbeb int ;_egba int ;_aabd VectorDrawable ;_ddfgb CellHorizontalAlignment ;_gdca CellVerticalAlignment ;_dedb float64 ;_bfdgf *Table ;};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//
//	red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_dcbf :float64 (r )/255.0,_accg :float64 (g )/255.0,_bgcg :float64 (b )/255.0};};func (_bggb grayColor )ToRGB ()(float64 ,float64 ,float64 ){return _bggb ._fffc ,_bggb ._fffc ,_bggb ._fffc ;};


// BorderColor returns the border color of the ellipse.
func (_cbdfc *Ellipse )BorderColor ()Color {return _cbdfc ._geef };

// SetAngle sets the rotation angle in degrees.
func (_fb *Block )SetAngle (angleDeg float64 ){_fb ._ga =angleDeg };func (_gbaf *Table )resetColumnWidths (){_gbaf ._cfab =[]float64 {};_aecb :=float64 (1.0)/float64 (_gbaf ._cccbd );for _dcegc :=0;_dcegc < _gbaf ._cccbd ;_dcegc ++{_gbaf ._cfab =append (_gbaf ._cfab ,_aecb );
};};func _bcbde (_acbe interface{})(interface{},error ){switch _fcbab :=_acbe .(type ){case uint8 :return int64 (_fcbab ),nil ;case int8 :return int64 (_fcbab ),nil ;case uint16 :return int64 (_fcbab ),nil ;case int16 :return int64 (_fcbab ),nil ;case uint32 :return int64 (_fcbab ),nil ;
case int32 :return int64 (_fcbab ),nil ;case uint64 :return int64 (_fcbab ),nil ;case int64 :return _fcbab ,nil ;case int :return int64 (_fcbab ),nil ;case float32 :return float64 (_fcbab ),nil ;case float64 :return _fcbab ,nil ;};return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0076\u0061\u006c\u0075\u0065\u002c\u0020\u0025\u0076\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072",_acbe );
};func _gcgc (_bcdcf [][]_fg .Point )*Polygon {return &Polygon {_cdfc :&_fg .Polygon {Points :_bcdcf },_bcdc :1.0,_geeda :1.0};};func _cdbfc (_gcgbf *templateProcessor ,_cdba *templateNode )(interface{},error ){return _gcgbf .parseEllipse (_cdba );};

// FitMode returns the fit mode of the image.
func (_cdcg *Image )FitMode ()FitMode {return _cdcg ._gaeef };func _dfcea (_gagad *templateProcessor ,_dcgcd *templateNode )(interface{},error ){return _gagad .parseTextChunk (_dcgcd ,nil );};func _faefa (_eege *templateProcessor ,_fabcg *templateNode )(interface{},error ){return _eege .parseTable (_fabcg );
};func _aaab (_dbea _ea .Image )(*Image ,error ){_ebge ,_cad :=_db .ImageHandling .NewImageFromGoImage (_dbea );if _cad !=nil {return nil ,_cad ;};return _aaceg (_ebge );};

// Color returns the color of the line.
func (_gdcd *Line )Color ()Color {return _gdcd ._ccg };func _dcdbdg (_beacb *templateProcessor ,_ffge *templateNode )(interface{},error ){return _beacb .parseChapter (_ffge );};

// SetFillOpacity sets the fill opacity.
func (_fgf *CurvePolygon )SetFillOpacity (opacity float64 ){_fgf ._dcgf =opacity };func (_ececa *templateProcessor )parseInt64Array (_badfb ,_aebeb string )[]int64 {_d .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_badfb ,_aebeb );
_bffef :=_cc .Fields (_aebeb );_bgeg :=make ([]int64 ,0,len (_bffef ));for _ ,_egac :=range _bffef {_fgbg ,_ :=_eg .ParseInt (_egac ,10,64);_bgeg =append (_bgeg ,_fgbg );};return _bgeg ;};

// AddLine appends a new line to the invoice line items table.
func (_gaa *Invoice )AddLine (values ...string )[]*InvoiceCell {_fbfgc :=len (_gaa ._cbfcg );var _cegfg []*InvoiceCell ;for _ggde ,_afge :=range values {_dgag :=_gaa .newCell (_afge ,_gaa ._ecacb );if _ggde < _fbfgc {_dgag .Alignment =_gaa ._cbfcg [_ggde ].Alignment ;
};_cegfg =append (_cegfg ,_dgag );};_gaa ._ddfgc =append (_gaa ._ddfgc ,_cegfg );return _cegfg ;};

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_bbbd *GraphicSVG )SetPos (x ,y float64 ){_bbbd ._eccef =PositionAbsolute ;_bbbd ._dfac =x ;_bbbd ._bfe =y ;};

// SetBorderWidth sets the border width.
func (_gdf *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_gdf ._bgfa .BorderWidth =borderWidth ;};func _cdca (_cgddb *_db .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_cgddb ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};func _afgf (_gdec string )bool {_gbgfg :=func (_bedd rune )bool {return _bedd =='\u000A'};_efaf :=_cc .TrimFunc (_gdec ,_gbgfg );_facg :=_cb .Paragraph {};_ ,_fggbb :=_facg .SetString (_efaf );if _fggbb !=nil {return true ;};_afdbe ,_fggbb :=_facg .Order ();
if _fggbb !=nil {return true ;};if _afdbe .NumRuns ()< 1{return true ;};return _facg .IsLeftToRight ();};

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_gdac *Chapter )Add (d Drawable )error {if Drawable (_gdac )==d {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _beg :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_gdac ._bgf =append (_gdac ._bgf ,d );case containerDrawable :_bdb ,_gec :=_beg .ContainerComponent (_gdac );
if _gec !=nil {return _gec ;};_gdac ._bgf =append (_gdac ._bgf ,_bdb );default:_d .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _ab .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};func (_gcgg *Chapter )headingText ()string {_efge :=_gcgg ._dgac ;if _feff :=_gcgg .headingNumber ();_feff !=""{_efge =_f .Sprintf ("\u0025\u0073\u0020%\u0073",_feff ,_efge );};return _efge ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_bddb *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_eeacb :=uint (len (_bddb ._cbfcg ));if index > _eeacb {index =_eeacb ;};_gafba :=_bddb .NewColumn (description );_bddb ._cbfcg =append (_bddb ._cbfcg [:index ],append ([]*InvoiceCell {_gafba },_bddb ._cbfcg [index :]...)...);
return _gafba ;};func (_eggf *templateProcessor )parseFitModeAttr (_eggcb ,_ddgg string )FitMode {_d .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_eggcb ,_ddgg );
_cebd :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_ddgg ];return _cebd ;};

// SetBorderColor sets the cell's border color.
func (_dcedd *TableCell )SetBorderColor (col Color ){_dcedd ._cfge =col ;_dcedd ._ddac =col ;_dcedd ._gbbdf =col ;_dcedd ._babeg =col ;};

// SetHeight sets the Image's document height to specified h.
func (_gba *Image )SetHeight (h float64 ){_gba ._gafb =h };func (_acgd *templateProcessor )parseFloatAttr (_fdfa ,_cdbf string )float64 {_d .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_fdfa ,_cdbf );
_bbdad ,_ :=_eg .ParseFloat (_cdbf ,64);return _bbdad ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_gffa *Invoice )NoteStyle ()TextStyle {return _gffa ._fbfdc };func _bfggd (_dgbf []_fg .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_bgfa :&_fg .PolyBezierCurve {Curves :_dgbf ,BorderColor :_db .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_bfde :1.0,_ceaf :1.0};
};

// List represents a list of items.
// The representation of a list item is as follows:
//
//	[marker] [content]
//
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_bdee []*listItem ;_ebdfg Margins ;_gccff TextChunk ;_adge float64 ;_gfbf bool ;_cbgae Positioning ;_fcad TextStyle ;};

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_ecdf *Ellipse )ScaleToHeight (h float64 ){_ccbc :=_ecdf ._bee /_ecdf ._faea ;_ecdf ._faea =h ;_ecdf ._bee =h *_ccbc ;};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_ecee *Invoice )TotalLines ()[][2]*InvoiceCell {_gcae :=[][2]*InvoiceCell {_ecee ._afcd };_gcae =append (_gcae ,_ecee ._fgeb ...);return append (_gcae ,_ecee ._decf );};

// SetTitle sets the title of the invoice.
func (_ffcg *Invoice )SetTitle (title string ){_ffcg ._fgedc =title };

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// SetWidthTop sets border width for top.
func (_gcaa *border )SetWidthTop (bw float64 ){_gcaa ._fged =bw };func (_efeb *templateProcessor )loadImageFromSrc (_acfca string )(*Image ,error ){if _acfca ==""{_d .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_fedae ;};_beabe :=_cc .Split (_acfca ,"\u002c");for _ ,_fdafb :=range _beabe {_fdafb =_cc .TrimSpace (_fdafb );if _fdafb ==""{continue ;};_fbdg ,_edggf :=_efeb ._cggb .ImageMap [_fdafb ];if _edggf {return _aaceg (_fbdg );};if _faddd :=_efeb .parseAttrPropList (_fdafb );
len (_faddd )> 0{if _bagac ,_bfbde :=_faddd ["\u0070\u0061\u0074\u0068"];_bfbde {if _eced ,_eged :=_gdae (_bagac );_eged !=nil {_d .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_bagac ,_eged );
}else {return _eced ,nil ;};};};};_d .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_acfca );return nil ,_fedae ;};

// Angle returns the block rotation angle in degrees.
func (_cba *Block )Angle ()float64 {return _cba ._ga };

// Lazy gets the lazy mode for the image.
func (_deca *Image )Lazy ()bool {return _deca ._ddcec };

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_bebaf *shading )SetAntiAlias (enable bool ){_bebaf ._cgfde =enable };

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};func _gfbe (_defbd TextStyle )*StyledParagraph {return &StyledParagraph {_cdegd :[]*TextChunk {},_abfe :_defbd ,_abba :_efdfa (_defbd .Font ),_gfae :1.0,_efdff :TextAlignmentLeft ,_bbff :true ,_dgcd :true ,_aegab :false ,_bgbbb :0,_bdfga :1,_gcbd :1,_fadf :PositionRelative };
};func (_cbgd *Paragraph )wrapText ()error {if !_cbgd ._aacg ||int (_cbgd ._cbeda )<=0{_cbgd ._fcfba =[]string {_cbgd ._cdaf };return nil ;};_fbag :=NewTextChunk (_cbgd ._cdaf ,TextStyle {Font :_cbgd ._bccd ,FontSize :_cbgd ._bbgda });_dbeaa ,_bfaa :=_fbag .Wrap (_cbgd ._cbeda );
if _bfaa !=nil {return _bfaa ;};if _cbgd ._feed > 0&&len (_dbeaa )> _cbgd ._feed {_dbeaa =_dbeaa [:_cbgd ._feed ];};_cbgd ._fcfba =_dbeaa ;return nil ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_afda *StyledParagraph )SetWidth (width float64 ){_afda ._baaga =width ;_afda .wrapText ()};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };
PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// TextAlignment options for paragraph.
type TextAlignment int ;

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_fddce *Creator )NewParagraph (text string )*Paragraph {return _gccef (text ,_fddce .NewTextStyle ());};

// NewTOCLine creates a new table of contents line with the default style.
func (_ffb *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _cdggb (number ,title ,page ,level ,_ffb .NewTextStyle ());};func _cdddd (_beaa ,_deada ,_gfac ,_beca float64 )*Rectangle {return &Rectangle {_dbgeg :_beaa ,_gead :_deada ,_bccac :_gfac ,_begbb :_beca ,_aacf :PositionAbsolute ,_dgab :1.0,_ddde :ColorBlack ,_ccde :1.0,_ccbd :1.0};
};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_bcbad *RadialShading )SetAntiAlias (enable bool ){_bcbad ._cgec .SetAntiAlias (enable )};func (_defcd *LinearShading )shadingModel ()*_db .PdfShadingType2 {_bdef :=_fg .NewPoint (_defcd ._ggge .Llx +_defcd ._ggge .Width ()/2,_defcd ._ggge .Lly +_defcd ._ggge .Height ()/2);
_dbfdf :=_fg .NewPoint (_defcd ._ggge .Llx ,_defcd ._ggge .Lly +_defcd ._ggge .Height ()/2).Add (-_bdef .X ,-_bdef .Y ).Rotate (_defcd ._afga ).Add (_bdef .X ,_bdef .Y );_dbfdf =_fg .NewPoint (_gb .Max (_gb .Min (_dbfdf .X ,_defcd ._ggge .Urx ),_defcd ._ggge .Llx ),_gb .Max (_gb .Min (_dbfdf .Y ,_defcd ._ggge .Ury ),_defcd ._ggge .Lly ));
_bbdca :=_fg .NewPoint (_defcd ._ggge .Urx ,_defcd ._ggge .Lly +_defcd ._ggge .Height ()/2).Add (-_bdef .X ,-_bdef .Y ).Rotate (_defcd ._afga ).Add (_bdef .X ,_bdef .Y );_bbdca =_fg .NewPoint (_gb .Min (_gb .Max (_bbdca .X ,_defcd ._ggge .Llx ),_defcd ._ggge .Urx ),_gb .Min (_gb .Max (_bbdca .Y ,_defcd ._ggge .Lly ),_defcd ._ggge .Ury ));
_dcgc :=_db .NewPdfShadingType2 ();_dcgc .PdfShading .ShadingType =_ag .MakeInteger (2);_dcgc .PdfShading .ColorSpace =_db .NewPdfColorspaceDeviceRGB ();_dcgc .PdfShading .AntiAlias =_ag .MakeBool (_defcd ._gdcc ._cgfde );_dcgc .Coords =_ag .MakeArrayFromFloats ([]float64 {_dbfdf .X ,_dbfdf .Y ,_bbdca .X ,_bbdca .Y });
_dcgc .Extend =_ag .MakeArray (_ag .MakeBool (_defcd ._gdcc ._gagd [0]),_ag .MakeBool (_defcd ._gdcc ._gagd [1]));_dcgc .Function =_defcd ._gdcc .generatePdfFunctions ();return _dcgc ;};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_deac *Chart )Width ()float64 {return float64 (_deac ._aefd .Width ())};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _e .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_ba .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_db .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_db .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_ege .ChartRenderable ;};

// SetBorderColor sets the border color.
func (_aacea *PolyBezierCurve )SetBorderColor (color Color ){_aacea ._bgfa .BorderColor =_afb (color )};func _aebb (_efdac *templateProcessor ,_gbcfb *templateNode )(interface{},error ){return _efdac .parseImage (_gbcfb );};func (_dcgca *TOCLine )prepareParagraph (_aebee *StyledParagraph ,_bffdg DrawContext ){_ceae :=_dcgca .Title .Text ;
if _dcgca .Number .Text !=""{_ceae ="\u0020"+_ceae ;};_ceae +="\u0020";_aacad :=_dcgca .Page .Text ;if _aacad !=""{_aacad ="\u0020"+_aacad ;};_aebee ._cdegd =[]*TextChunk {{Text :_dcgca .Number .Text ,Style :_dcgca .Number .Style ,_fedb :_dcgca .getLineLink ()},{Text :_ceae ,Style :_dcgca .Title .Style ,_fedb :_dcgca .getLineLink ()},{Text :_aacad ,Style :_dcgca .Page .Style ,_fedb :_dcgca .getLineLink ()}};
_aebee .wrapText ();_addb :=len (_aebee ._ebgc );if _addb ==0{return ;};_gccbd :=_bffdg .Width *1000-_aebee .getTextLineWidth (_aebee ._ebgc [_addb -1]);_ffabg :=_aebee .getTextLineWidth ([]*TextChunk {&_dcgca .Separator });_becfb :=int (_gccbd /_ffabg );
_fbdgg :=_cc .Repeat (_dcgca .Separator .Text ,_becfb );_dfde :=_dcgca .Separator .Style ;_afef :=_aebee .Insert (2,_fbdgg );_afef .Style =_dfde ;_afef ._fedb =_dcgca .getLineLink ();_gccbd =_gccbd -float64 (_becfb )*_ffabg ;if _gccbd > 500{_cfbdg ,_fffgf :=_dfde .Font .GetRuneMetrics (' ');
if _fffgf &&_gccbd > _cfbdg .Wx {_dcaag :=int (_gccbd /_cfbdg .Wx );if _dcaag > 0{_gadb :=_dfde ;_gadb .FontSize =1;_afef =_aebee .Insert (2,_cc .Repeat ("\u0020",_dcaag ));_afef .Style =_gadb ;_afef ._fedb =_dcgca .getLineLink ();};};};};

// AddColorStop add color stop info for rendering gradient color.
func (_dcbfc *LinearShading )AddColorStop (color Color ,point float64 ){_dcbfc ._gdcc .AddColorStop (color ,point );};

// SetBorderOpacity sets the border opacity.
func (_ecdeg *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_ecdeg ._ceaf =opacity };type templateProcessor struct{creator *Creator ;_cegbe []byte ;_cggb *TemplateOptions ;_cgab componentRenderer ;_dfcgb string ;};type pageTransformations struct{_dbfd *_eaa .Matrix ;
_fcga bool ;_fgcdc bool ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_ceb *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_ceb ._gcad =toc ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_deaga *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edbf :=ctx ;if _deaga ._abdg .IsRelative (){ctx .X +=_deaga ._cbfc .Left ;ctx .Y +=_deaga ._cbfc .Top ;ctx .Width -=_deaga ._cbfc .Left +_deaga ._cbfc .Right ;
ctx .Height -=_deaga ._cbfc .Top ;};_fdd ,_cbae ,_cgff :=_deaga ._gdbe .GeneratePageBlocks (ctx );if _cgff !=nil {return _fdd ,ctx ,_cgff ;};ctx =_cbae ;_ecdc :=ctx .X ;_efdf :=ctx .Y -_deaga ._gdbe .Height ();_gdbdf :=int64 (ctx .Page );_ggab :=_deaga .headingNumber ();
_bade :=_deaga .headingText ();if _deaga ._eab {_dcda :=_deaga ._cegd .Add (_ggab ,_deaga ._dgac ,_eg .FormatInt (_gdbdf ,10),_deaga ._afd );if _deaga ._cegd ._ffcgd {_dcda .SetLink (_gdbdf ,_ecdc ,_efdf );};};if _deaga ._bdag ==nil {_deaga ._bdag =_db .NewOutlineItem (_bade ,_db .NewOutlineDest (_gdbdf -1,_ecdc ,_efdf ));
if _deaga ._cdff !=nil {_deaga ._cdff ._bdag .Add (_deaga ._bdag );}else {_deaga ._daab .Add (_deaga ._bdag );};}else {_adb :=&_deaga ._bdag .Dest ;_adb .Page =_gdbdf -1;_adb .X =_ecdc ;_adb .Y =_efdf ;};for _ ,_bfcd :=range _deaga ._bgf {_bbg ,_gafc ,_dge :=_bfcd .GeneratePageBlocks (ctx );
if _dge !=nil {return _fdd ,ctx ,_dge ;};if len (_bbg )< 1{continue ;};_fdd [len (_fdd )-1].mergeBlocks (_bbg [0]);_fdd =append (_fdd ,_bbg [1:]...);ctx =_gafc ;};if _deaga ._abdg .IsRelative (){ctx .X =_edbf .X ;};if _deaga ._abdg .IsAbsolute (){return _fdd ,_edbf ,nil ;
};return _fdd ,ctx ,nil ;};func (_dgfbc *StyledParagraph )wrapWordChunks (){if !_dgfbc ._aegab {return ;};var (_dafdc []*TextChunk ;_gdfa *_db .PdfFont ;);for _ ,_ggcef :=range _dgfbc ._cdegd {_eaff :=[]rune (_ggcef .Text );if _gdfa ==nil {_gdfa =_ggcef .Style .Font ;
};_decfa :=_ggcef ._fedb ;_bdcac :=_ggcef .VerticalAlignment ;if len (_dafdc )> 0{if len (_eaff )==1&&_ff .IsPunct (_eaff [0])&&_ggcef .Style .Font ==_gdfa {_cedg :=[]rune (_dafdc [len (_dafdc )-1].Text );_dafdc [len (_dafdc )-1].Text =string (append (_cedg ,_eaff [0]));
continue ;}else {_ ,_agce :=_eg .Atoi (_ggcef .Text );if _agce ==nil {_gcfe :=[]rune (_dafdc [len (_dafdc )-1].Text );_aaeg :=len (_gcfe );if _aaeg >=2{_ ,_aeag :=_eg .Atoi (string (_gcfe [_aaeg -2]));if _aeag ==nil &&_ff .IsPunct (_gcfe [_aaeg -1]){_dafdc [len (_dafdc )-1].Text =string (append (_gcfe ,_eaff ...));
continue ;};};};};};_ddbf ,_gggcf :=_bcgbd (_ggcef .Text );if _gggcf !=nil {_d .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_gggcf );
_ddbf =[]string {_ggcef .Text };};for _ ,_deabef :=range _ddbf {_befa :=NewTextChunk (_deabef ,_ggcef .Style );_befa ._fedb =_cbfbe (_decfa );_befa .VerticalAlignment =_bdcac ;_dafdc =append (_dafdc ,_befa );};_gdfa =_ggcef .Style .Font ;};if len (_dafdc )> 0{_dgfbc ._cdegd =_dafdc ;
};};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_aa :=&Block {};_aa ._bag =&_cf .ContentStreamOperations {};_aa ._aef =_db .NewPdfPageResources ();_aa ._bc =width ;_aa ._ef =height ;return _aa ;};func (_bbbef *templateProcessor )processGradientColorPair (_adagg []string )(_dfee []Color ,_gfagf []float64 ){for _ ,_fabcc :=range _adagg {var (_dbdb =_cc .Fields (_fabcc );
_fdgd =len (_dbdb ););if _fdgd ==0{continue ;};_ecbee :="";if _fdgd > 1{_ecbee =_cc .TrimSpace (_dbdb [1]);};_acada :=-1.0;if _cc .HasSuffix (_ecbee ,"\u0025"){_fcbg ,_abca :=_eg .ParseFloat (_ecbee [:len (_ecbee )-1],64);if _abca !=nil {_d .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_abca );
};_acada =_fcbg /100.0;};_baggc :=_bbbef .parseColor (_cc .TrimSpace (_dbdb [0]));if _baggc !=nil {_dfee =append (_dfee ,_baggc );_gfagf =append (_gfagf ,_acada );};};if len (_dfee )!=len (_gfagf ){_d .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_cdbfa :=-1;_bbfee :=0.0;for _ebcad ,_gfde :=range _gfagf {if _gfde ==-1.0{if _ebcad ==0{_gfde =0.0;_gfagf [_ebcad ]=0.0;continue ;};_cdbfa ++;if _ebcad < len (_gfagf )-1{continue ;}else {_gfde =1.0;_gfagf [_ebcad ]=1.0;};};_cafgg :=_cdbfa +1;
for _bbgae :=_ebcad -_cdbfa ;_bbgae < _ebcad ;_bbgae ++{_gfagf [_bbgae ]=_bbfee +(float64 (_bbgae )*(_gfde -_bbfee )/float64 (_cafgg ));};_bbfee =_gfde ;_cdbfa =-1;};return _dfee ,_gfagf ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_dgdc int ;_cccbd int ;_cecaf int ;_cfab []float64 ;_bebec []float64 ;_gbccbb float64 ;_dgde []*TableCell ;_dedgb []int ;_afbg Positioning ;_dggde ,_gebee float64 ;_aaec Margins ;_eaged bool ;_gbag int ;_dacb int ;_dcag bool ;_ceef bool ;
_cfed bool ;};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_dada *LinearShading )AddShadingResource (block *Block )(_cbgc _ag .PdfObjectName ,_debca error ){_ddfgca :=1;_cbgc =_ag .PdfObjectName ("\u0053\u0068"+_eg .Itoa (_ddfgca ));for block ._aef .HasShadingByName (_cbgc ){_ddfgca ++;_cbgc =_ag .PdfObjectName ("\u0053\u0068"+_eg .Itoa (_ddfgca ));
};if _gegdc :=block ._aef .SetShadingByName (_cbgc ,_dada .shadingModel ().ToPdfObject ());_gegdc !=nil {return "",_gegdc ;};return _cbgc ,nil ;};

// NewTOC creates a new table of contents.
func (_gcdb *Creator )NewTOC (title string )*TOC {_cfec :=_gcdb .NewTextStyle ();_cfec .Font =_gcdb ._cggc ;return _cbaf (title ,_gcdb .NewTextStyle (),_cfec );};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_gcdd []VectorDrawable ;_fbe Positioning ;_caeg Margins ;_cedd Margins ;_eaad bool ;_eage bool ;_cgeg *Background ;};

// SetWidth sets the width of the rectangle.
func (_eafc *Rectangle )SetWidth (width float64 ){_eafc ._bccac =width };

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_edde *Ellipse )ScaleToWidth (w float64 ){_egfe :=_edde ._faea /_edde ._bee ;_edde ._bee =w ;_edde ._faea =w *_egfe ;};

// SetBorder sets the cell's border style.
func (_eefbe *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_eefbe ._gaffc =CellBorderStyleSingle ;_eefbe ._ddda =width ;_eefbe ._fddef =CellBorderStyleSingle ;
_eefbe ._bdbe =width ;_eefbe ._gcffgc =CellBorderStyleSingle ;_eefbe ._gcfeg =width ;_eefbe ._abed =CellBorderStyleSingle ;_eefbe ._ffbcg =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_eefbe ._gaffc =CellBorderStyleDouble ;
_eefbe ._ddda =width ;_eefbe ._fddef =CellBorderStyleDouble ;_eefbe ._bdbe =width ;_eefbe ._gcffgc =CellBorderStyleDouble ;_eefbe ._gcfeg =width ;_eefbe ._abed =CellBorderStyleDouble ;_eefbe ._ffbcg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_eefbe ._gaffc =style ;
_eefbe ._ddda =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_eefbe ._fddef =style ;_eefbe ._bdbe =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_eefbe ._gcffgc =style ;
_eefbe ._gcfeg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_eefbe ._abed =style ;_eefbe ._ffbcg =width ;};};func (_cebf *templateProcessor )parseListItem (_eaagc *templateNode )(interface{},error ){if _eaagc ._abgfd ==nil {_cebf .nodeLogError (_eaagc ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_cdfg ;};_bfae ,_dbaab :=_eaagc ._abgfd ._dfbaa .(*List );if !_dbaab {_cebf .nodeLogError (_eaagc ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_cdfg ;};_bfbeg :=_agdd ();_bfbeg ._bdaa =_bfae ._gccff ;return _bfbeg ,nil ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_caaa *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_caaa ._bcaf =append (_caaa ._bcaf ,line );return line ;};func (_dfec *templateProcessor )parseTable (_bfcf *templateNode )(interface{},error ){var _edeff int64 ;for _ ,_faaaa :=range _bfcf ._fabca .Attr {_cdgf :=_faaaa .Value ;
switch _fggc :=_faaaa .Name .Local ;_fggc {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_edeff =_dfec .parseInt64Attr (_fggc ,_cdgf );};};if _edeff <=0{_dfec .nodeLogDebug (_bfcf ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_edeff );
_edeff =1;};_eccba :=_dfec .creator .NewTable (int (_edeff ));for _ ,_eebe :=range _bfcf ._fabca .Attr {_cegdg :=_eebe .Value ;switch _ccgd :=_eebe .Name .Local ;_ccgd {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_eccba .SetColumnWidths (_dfec .parseFloatArray (_ccgd ,_cegdg )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_agdgg :=_dfec .parseMarginAttr (_ccgd ,_cegdg );_eccba .SetMargins (_agdgg .Left ,_agdgg .Right ,_agdgg .Top ,_agdgg .Bottom );case "\u0078":_eccba .SetPos (_dfec .parseFloatAttr (_ccgd ,_cegdg ),_eccba ._gebee );
case "\u0079":_eccba .SetPos (_eccba ._dggde ,_dfec .parseFloatAttr (_ccgd ,_cegdg ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_eccba ._gbag =int (_dfec .parseInt64Attr (_ccgd ,_cegdg ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_eccba ._dacb =int (_dfec .parseInt64Attr (_ccgd ,_cegdg ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_eccba .EnableRowWrap (_dfec .parseBoolAttr (_ccgd ,_cegdg ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_eccba .EnablePageWrap (_dfec .parseBoolAttr (_ccgd ,_cegdg ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_dfec .nodeLogDebug (_bfcf ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_ccgd );
};};if _eccba ._gbag !=0&&_eccba ._dacb !=0{_gfefb :=_eccba .SetHeaderRows (_eccba ._gbag ,_eccba ._dacb );if _gfefb !=nil {_dfec .nodeLogDebug (_bfcf ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_gfefb );
};}else {_eccba ._gbag =0;_eccba ._dacb =0;};return _eccba ,nil ;};func _cceg ()*PageBreak {return &PageBreak {}};func _bgfbb (_adbee *templateProcessor ,_gdbca *templateNode )(interface{},error ){return _adbee .parseChapterHeading (_gdbca );};

// SetFillColor sets the fill color of the ellipse.
func (_cdad *Ellipse )SetFillColor (col Color ){_cdad ._bbad =col };func _dccfe (_dadag *templateProcessor ,_dceac *templateNode )(interface{},error ){return _dadag .parsePageBreak (_dceac );};

// SetBorderWidth sets the border width.
func (_eed *CurvePolygon )SetBorderWidth (borderWidth float64 ){_eed ._bbdae .BorderWidth =borderWidth };func (_aggeb *templateProcessor )renderNode (_afeb *templateNode )error {_eeebg :=_afeb ._dfbaa ;if _eeebg ==nil {return nil ;};_ddeda :=_afeb ._fabca .Name .Local ;
_fagda ,_cgcbd :=_bedc [_ddeda ];if !_cgcbd {_aggeb .nodeLogDebug (_afeb ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_ddeda );return nil ;};var _ddgcc interface{};
if _afeb ._abgfd !=nil &&_afeb ._abgfd ._dfbaa !=nil {_bdada :=_afeb ._abgfd ._fabca .Name .Local ;if _ ,_cgcbd =_fagda ._beec [_bdada ];!_cgcbd {_aggeb .nodeLogDebug (_afeb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_bdada ,_ddeda );
return _cdfg ;};_ddgcc =_afeb ._abgfd ._dfbaa ;}else {_badd :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _aggeb ._cgab .(type ){case *Block :_badd ="\u0062\u006c\u006fc\u006b";};if _ ,_cgcbd =_fagda ._beec [_badd ];!_cgcbd {_aggeb .nodeLogDebug (_afeb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_badd ,_ddeda );
return _cdfg ;};_ddgcc =_aggeb ._cgab ;};switch _cbedc :=_ddgcc .(type ){case componentRenderer :_bfdce ,_eaaec :=_eeebg .(Drawable );if !_eaaec {_aggeb .nodeLogError (_afeb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_ddeda ,_eeebg );
return _ecdeb ;};_cadf :=_cbedc .Draw (_bfdce );if _cadf !=nil {return _aggeb .nodeError (_afeb ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_ddeda ,_eeebg ,_cadf );
};case *Division :switch _fdab :=_eeebg .(type ){case *Background :_cbedc .SetBackground (_fdab );case VectorDrawable :_gffcf :=_cbedc .Add (_fdab );if _gffcf !=nil {return _aggeb .nodeError (_afeb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_ddeda ,_eeebg ,_gffcf );
};};case *TableCell :_dfgfc ,_bdabe :=_eeebg .(VectorDrawable );if !_bdabe {_aggeb .nodeLogError (_afeb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_ddeda ,_eeebg );
return _ecdeb ;};_cecfb :=_cbedc .SetContent (_dfgfc );if _cecfb !=nil {return _aggeb .nodeError (_afeb ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_ddeda ,_eeebg ,_cecfb );
};case *StyledParagraph :_dedce ,_fggcc :=_eeebg .(*TextChunk );if !_fggcc {_aggeb .nodeLogError (_afeb ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_ddeda ,_eeebg );
return _ecdeb ;};_cbedc .appendChunk (_dedce );case *Chapter :switch _dggfa :=_eeebg .(type ){case *Chapter :return nil ;case *Paragraph :if _afeb ._fabca .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_fgeg :=_cbedc .Add (_dggfa );if _fgeg !=nil {return _aggeb .nodeError (_afeb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_ddeda ,_eeebg ,_fgeg );
};case Drawable :_ddaff :=_cbedc .Add (_dggfa );if _ddaff !=nil {return _aggeb .nodeError (_afeb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_ddeda ,_eeebg ,_ddaff );
};};case *List :switch _gdga :=_eeebg .(type ){case *TextChunk :case *listItem :_cbedc ._bdee =append (_cbedc ._bdee ,_gdga );default:_aggeb .nodeLogError (_afeb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ddeda ,_eeebg );
};case *listItem :switch _eabfe :=_eeebg .(type ){case *TextChunk :case *StyledParagraph :_cbedc ._cbea =_eabfe ;case *List :if _eabfe ._gfbf {_eabfe ._adge =15;};_cbedc ._cbea =_eabfe ;case *Image :_cbedc ._cbea =_eabfe ;case *Division :_cbedc ._cbea =_eabfe ;
case *Table :_cbedc ._cbea =_eabfe ;default:_aggeb .nodeLogError (_afeb ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_ddeda ,_eeebg );
return _ecdeb ;};};return nil ;};

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_fcae *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _baea (colorPoints );};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//
//	red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_afc :_gb .Min (float64 (c ),100)/100.0,_dff :_gb .Min (float64 (m ),100)/100.0,_edea :_gb .Min (float64 (y ),100)/100.0,_cec :_gb .Min (float64 (k ),100)/100.0};};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_eagf *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _begb (x1 ,y1 ,x2 ,y2 )};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_fedb *_db .PdfAnnotation ;_edbdff bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_efcc *Table )EnableRowWrap (enable bool ){_efcc ._dcag =enable };

// SetMargins sets the Paragraph's margins.
func (_eabf *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_eabf ._fdda .Left =left ;_eabf ._fdda .Right =right ;_eabf ._fdda .Top =top ;_eabf ._fdda .Bottom =bottom ;};func _aebg (_ade string )string {_fgd :=_cda .FindAllString (_ade ,-1);
if len (_fgd )==0{_ade =_ade +"\u0030";}else {_eac ,_ead :=_eg .Atoi (_fgd [len (_fgd )-1]);if _ead !=nil {_d .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_ead );
_ade =_ade +"\u0030";}else {_eac ++;_agec :=_cc .LastIndex (_ade ,_fgd [len (_fgd )-1]);if _agec ==-1{_ade =_f .Sprintf ("\u0025\u0073\u0025\u0064",_ade [:len (_ade )-1],_eac );}else {_ade =_ade [:_agec ]+_eg .Itoa (_eac );};};};return _ade ;};

// SetAngle sets Image rotation angle in degrees.
func (_affg *Image )SetAngle (angle float64 ){_affg ._edaf =angle };func (_bbacf *templateProcessor )parseTextChunk (_dgafd *templateNode ,_aefb *TextChunk )(interface{},error ){if _dgafd ._abgfd ==nil {_bbacf .nodeLogError (_dgafd ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_cdfg ;};var (_bddg =_bbacf .creator .NewTextStyle ();_fbceb bool ;);for _ ,_ffad :=range _dgafd ._fabca .Attr {if _ffad .Name .Local =="\u006c\u0069\u006e\u006b"{_eeec ,_dgcde :=_dgafd ._abgfd ._dfbaa .(*StyledParagraph );if !_dgcde {_bbacf .nodeLogError (_dgafd ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_fbceb =true ;}else {_bddg =_eeec ._abba ;};break ;};};if _aefb ==nil {_aefb =NewTextChunk ("",_bddg );};for _ ,_ecccb :=range _dgafd ._fabca .Attr {_cabcb :=_ecccb .Value ;switch _ageb :=_ecccb .Name .Local ;_ageb {case "\u0063\u006f\u006co\u0072":_aefb .Style .Color =_bbacf .parseColorAttr (_ageb ,_cabcb );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_aefb .Style .OutlineColor =_bbacf .parseColorAttr (_ageb ,_cabcb );case "\u0066\u006f\u006e\u0074":_aefb .Style .Font =_bbacf .parseFontAttr (_ageb ,_cabcb );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_aefb .Style .FontSize =_bbacf .parseFloatAttr (_ageb ,_cabcb );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_aefb .Style .OutlineSize =_bbacf .parseFloatAttr (_ageb ,_cabcb );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_aefb .Style .CharSpacing =_bbacf .parseFloatAttr (_ageb ,_cabcb );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_aefb .Style .HorizontalScaling =_bbacf .parseFloatAttr (_ageb ,_cabcb );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_aefb .Style .RenderingMode =_bbacf .parseTextRenderingModeAttr (_ageb ,_cabcb );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_aefb .Style .Underline =_bbacf .parseBoolAttr (_ageb ,_cabcb );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_aefb .Style .UnderlineStyle .Color =_bbacf .parseColorAttr (_ageb ,_cabcb );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_aefb .Style .UnderlineStyle .Offset =_bbacf .parseFloatAttr (_ageb ,_cabcb );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_aefb .Style .UnderlineStyle .Thickness =_bbacf .parseFloatAttr (_ageb ,_cabcb );
case "\u006c\u0069\u006e\u006b":if !_fbceb {_aefb ._fedb =_bbacf .parseLinkAttr (_ageb ,_cabcb );};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_aefb .Style .TextRise =_bbacf .parseFloatAttr (_ageb ,_cabcb );default:_bbacf .nodeLogDebug (_dgafd ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_ageb );
};};return _aefb ,nil ;};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_egea *Invoice )SetNoteStyle (style TextStyle ){_egea ._fbfdc =style };

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_gbbc *Image )GetHorizontalAlignment ()HorizontalAlignment {return _gbbc ._gcba };

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_fade *Division )SetMargins (left ,right ,top ,bottom float64 ){_fade ._caeg .Left =left ;_fade ._caeg .Right =right ;_fade ._caeg .Top =top ;_fade ._caeg .Bottom =bottom ;};func (_ffaea *StyledParagraph )appendChunk (_cfbdf *TextChunk )*TextChunk {_ffaea ._cdegd =append (_ffaea ._cdegd ,_cfbdf );
_ffaea .wrapText ();return _cfbdf ;};

// Text sets the text content of the Paragraph.
func (_aadd *Paragraph )Text ()string {return _aadd ._cdaf };func _defc (_efa [][]_fg .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_bbdae :&_fg .CurvePolygon {Rings :_efa },_dcgf :1.0,_egaf :1.0};};func _dfgba (_cbbcg *Creator ,_efdb string ,_degc []byte ,_aeeda *TemplateOptions ,_gdafc componentRenderer )*templateProcessor {if _aeeda ==nil {_aeeda =&TemplateOptions {};
};_aeeda .init ();if _gdafc ==nil {_gdafc =_cbbcg ;};return &templateProcessor {creator :_cbbcg ,_cegbe :_degc ,_cggb :_aeeda ,_cgab :_gdafc ,_dfcgb :_efdb };};func (_fcafg *Invoice )generateInformationBlocks (_ddad DrawContext )([]*Block ,DrawContext ,error ){_gabca :=_gfbe (_fcafg ._cafa );
_gabca .SetMargins (0,0,0,20);_eaed :=_fcafg .drawAddress (_fcafg ._afa );_eaed =append (_eaed ,_gabca );_eaed =append (_eaed ,_fcafg .drawAddress (_fcafg ._ebcgc )...);_aad :=_dgfa ();for _ ,_feddf :=range _eaed {_aad .Add (_feddf );};_geba :=_fcafg .drawInformation ();
_cegge :=_eedb (2);_cegge .SetMargins (0,0,25,0);_ccffg :=_cegge .NewCell ();_ccffg .SetIndent (0);_ccffg .SetContent (_aad );_ccffg =_cegge .NewCell ();_ccffg .SetContent (_geba );return _cegge .GeneratePageBlocks (_ddad );};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_bcab *Invoice )NoteHeadingStyle ()TextStyle {return _bcab ._geacd };func (_babea *templateProcessor )parseInt64Attr (_bbgbe ,_ccbe string )int64 {_d .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_bbgbe ,_ccbe );
_cgade ,_ :=_eg .ParseInt (_ccbe ,10,64);return _cgade ;};func _dgfa ()*Division {return &Division {_eage :true }};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_caa []*_db .PdfPage ;_cdcc map[*_db .PdfPage ]*Block ;_fcgg map[*_db .PdfPage ]*pageTransformations ;_gge *_db .PdfPage ;_fecg PageSize ;_edg DrawContext ;_bbgd Margins ;_gcac ,_cfaf float64 ;_gcd int ;_cecc func (_ebcb FrontpageFunctionArgs );
_gabg func (_fdc *TOC )error ;_dffe func (_ebdg *Block ,_gdad HeaderFunctionArgs );_eec func (_cee *Block ,_fag FooterFunctionArgs );_ffdd func (_bea PageFinalizeFunctionArgs )error ;_bbba func (_cac *_db .PdfWriter )error ;_edge bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_gcad *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gbcf *_db .Outline ;_bef *_db .PdfOutlineTreeNode ;_cgfb *_db .PdfAcroForm ;_eafb _ag .PdfObject ;_egdg _db .Optimizer ;_ccbg []*_db .PdfFont ;_gef *_db .PdfFont ;_cggc *_db .PdfFont ;};func (_gfcc *Ellipse )applyFitMode (_eecf float64 ){_eecf -=_gfcc ._fbcgf .Left +_gfcc ._fbcgf .Right ;
switch _gfcc ._bbf {case FitModeFillWidth :_gfcc .ScaleToWidth (_eecf );};};func (_bbdd *templateProcessor )parseList (_gagg *templateNode )(interface{},error ){_bbgdg :=_bbdd .creator .NewList ();for _ ,_ffbb :=range _gagg ._fabca .Attr {_dagca :=_ffbb .Value ;
switch _gcge :=_ffbb .Name .Local ;_gcge {case "\u0069\u006e\u0064\u0065\u006e\u0074":_bbgdg .SetIndent (_bbdd .parseFloatAttr (_gcge ,_dagca ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cddafd :=_bbdd .parseMarginAttr (_gcge ,_dagca );_bbgdg .SetMargins (_cddafd .Left ,_cddafd .Right ,_cddafd .Top ,_cddafd .Bottom );
default:_bbdd .nodeLogDebug (_gagg ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gcge );
};};return _bbgdg ,nil ;};func _gcegd (_gcgea *templateProcessor ,_gcabd *templateNode )(interface{},error ){return _gcgea .parseBackground (_gcabd );};func _ecead (_egebe int64 ,_agecee ,_eggbe ,_bbabc float64 )*_db .PdfAnnotation {_egefd :=_db .NewPdfAnnotationLink ();
_egeba :=_db .NewBorderStyle ();_egeba .SetBorderWidth (0);_egefd .BS =_egeba .ToPdfObject ();if _egebe < 0{_egebe =0;};_egefd .Dest =_ag .MakeArray (_ag .MakeInteger (_egebe ),_ag .MakeName ("\u0058\u0059\u005a"),_ag .MakeFloat (_agecee ),_ag .MakeFloat (_eggbe ),_ag .MakeFloat (_bbabc ));
return _egefd .PdfAnnotation ;};func _aaceg (_bgcdc *_db .Image )(*Image ,error ){_fcac :=float64 (_bgcdc .Width );_ddaa :=float64 (_bgcdc .Height );return &Image {_efbg :_bgcdc ,_aag :_fcac ,_dcab :_ddaa ,_daba :_fcac ,_gafb :_ddaa ,_edaf :0,_fdfd :1.0,_dfgd :PositionRelative },nil ;
};

// Width returns the cell's width based on the input draw context.
func (_addfae *TableCell )Width (ctx DrawContext )float64 {_bbca :=float64 (0.0);for _dddc :=0;_dddc < _addfae ._egba ;_dddc ++{_bbca +=_addfae ._bfdgf ._cfab [_addfae ._bcea +_dddc -1];};_ebgb :=ctx .Width *_bbca ;return _ebgb ;};func _efdfa (_fdbcc *_db .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_fdbcc ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};type shading struct{_gccca Color ;_cgfde bool ;_gagd []bool ;_fgcdg []*ColorPoint ;};func (_cdbe *templateProcessor )parseMarginAttr (_eecdeg ,_eabad string )Margins {_d .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_eecdeg ,_eabad );
_egcb :=Margins {};switch _gcfb :=_cc .Fields (_eabad );len (_gcfb ){case 1:_egcb .Top ,_ =_eg .ParseFloat (_gcfb [0],64);_egcb .Bottom =_egcb .Top ;_egcb .Left =_egcb .Top ;_egcb .Right =_egcb .Top ;case 2:_egcb .Top ,_ =_eg .ParseFloat (_gcfb [0],64);
_egcb .Bottom =_egcb .Top ;_egcb .Left ,_ =_eg .ParseFloat (_gcfb [1],64);_egcb .Right =_egcb .Left ;case 3:_egcb .Top ,_ =_eg .ParseFloat (_gcfb [0],64);_egcb .Left ,_ =_eg .ParseFloat (_gcfb [1],64);_egcb .Right =_egcb .Left ;_egcb .Bottom ,_ =_eg .ParseFloat (_gcfb [2],64);
case 4:_egcb .Top ,_ =_eg .ParseFloat (_gcfb [0],64);_egcb .Right ,_ =_eg .ParseFloat (_gcfb [1],64);_egcb .Bottom ,_ =_eg .ParseFloat (_gcfb [2],64);_egcb .Left ,_ =_eg .ParseFloat (_gcfb [3],64);};return _egcb ;};

// SetOpacity sets the opacity of the line (0-1).
func (_daef *Line )SetOpacity (opacity float64 ){_daef ._edbfcd =opacity };

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_afgd *Division )EnablePageWrap (enable bool ){_afgd ._eage =enable };

// SetStyle sets the style of the line (solid or dashed).
func (_acab *Line )SetStyle (style _fg .LineStyle ){_acab ._daaf =style };

// AddTotalLine adds a new line in the invoice totals table.
func (_bcbegf *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_faae :=&InvoiceCell {_bcbegf ._dafd ,desc };_adgg :=&InvoiceCell {_bcbegf ._dafd ,value };_bcbegf ._fgeb =append (_bcbegf ._fgeb ,[2]*InvoiceCell {_faae ,_adgg });
return _faae ,_adgg ;};func _fefbe (_gfgg *_db .PdfAnnotationLink )*_db .PdfAnnotationLink {if _gfgg ==nil {return nil ;};_agcg :=_db .NewPdfAnnotationLink ();_agcg .BS =_gfgg .BS ;_agcg .A =_gfgg .A ;if _acaefb ,_fgagd :=_gfgg .GetAction ();_fgagd ==nil &&_acaefb !=nil {_agcg .SetAction (_acaefb );
};if _geeabd ,_fggb :=_gfgg .Dest .(*_ag .PdfObjectArray );_fggb {_agcg .Dest =_ag .MakeArray (_geeabd .Elements ()...);};return _agcg ;};

// FitMode returns the fit mode of the rectangle.
func (_gagf *Rectangle )FitMode ()FitMode {return _gagf ._bbc };

// GetMargins returns the left, right, top, bottom Margins.
func (_gaad *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gaad ._aaec .Left ,_gaad ._aaec .Right ,_gaad ._aaec .Top ,_gaad ._aaec .Bottom ;};

// Style returns the style of the line.
func (_fdae *Line )Style ()_fg .LineStyle {return _fdae ._daaf };

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_bdg *Creator )Flip (flipH ,flipV bool )error {_ddfa :=_bdg .getActivePage ();if _ddfa ==nil {return _ab .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_gdeb ,_fcd :=_bdg ._fcgg [_ddfa ];if !_fcd {_gdeb =&pageTransformations {};
_bdg ._fcgg [_ddfa ]=_gdeb ;};_gdeb ._fcga =flipH ;_gdeb ._fgcdc =flipV ;return nil ;};func (_ffcgf *templateProcessor )nodeLogDebug (_afgba *templateNode ,_eafbd string ,_abefg ...interface{}){_d .Log .Debug (_ffcgf .getNodeErrorLocation (_afgba ,_eafbd ,_abefg ...));
};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_gccf *Creator )Draw (d Drawable )error {if _gccf .getActivePage ()==nil {_gccf .NewPage ();};_gfa ,_cecf ,_geacg :=d .GeneratePageBlocks (_gccf ._edg );if _geacg !=nil {return _geacg ;};if len (_cecf ._ccd )> 0{_gccf .Errors =append (_gccf .Errors ,_cecf ._ccd ...);
};for _eddc ,_ggb :=range _gfa {if _eddc > 0{_gccf .NewPage ();};_aggb :=_gccf .getActivePage ();if _babc ,_gffe :=_gccf ._cdcc [_aggb ];_gffe {if _dbdc :=_babc .mergeBlocks (_ggb );_dbdc !=nil {return _dbdc ;};if _dggdf :=_efg (_ggb ._aef ,_babc ._aef );
_dggdf !=nil {return _dggdf ;};}else {_gccf ._cdcc [_aggb ]=_ggb ;};};_gccf ._edg .X =_cecf .X ;_gccf ._edg .Y =_cecf .Y ;_gccf ._edg .Height =_cecf .PageHeight -_cecf .Y -_cecf .Margins .Bottom ;return nil ;};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_aefd _ege .ChartRenderable ;_aeee Positioning ;_defe float64 ;_acf float64 ;_ffa Margins ;};func (_cedge *TemplateOptions )init (){if _cedge .SubtemplateMap ==nil {_cedge .SubtemplateMap =map[string ]_ba .Reader {};};if _cedge .FontMap ==nil {_cedge .FontMap =map[string ]*_db .PdfFont {};
};if _cedge .ImageMap ==nil {_cedge .ImageMap =map[string ]*_db .Image {};};if _cedge .ColorMap ==nil {_cedge .ColorMap =map[string ]Color {};};if _cedge .ChartMap ==nil {_cedge .ChartMap =map[string ]_ege .ChartRenderable {};};};

// SetAnchor set gradient position anchor.
// Default to center.
func (_cdade *RadialShading )SetAnchor (anchor AnchorPoint ){_cdade ._afad =anchor };const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;AnchorTopLeft ;AnchorTopRight ;AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);func _agaa (_bfdcec *_db .PdfFont ,_eegb float64 )*fontMetrics {_cgfff :=&fontMetrics {};
if _bfdcec ==nil {_d .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");return _cgfff ;};_fgeba ,_cecde :=_bfdcec .GetFontDescriptor ();if _cecde !=nil {_d .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_cecde );
return _cgfff ;};if _cgfff ._ebdff ,_cecde =_fgeba .GetCapHeight ();_cecde !=nil {_d .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_cecde );
};if int (_cgfff ._ebdff )<=0{_d .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_cgfff ._ebdff =1000;};_cgfff ._ebdff *=_eegb /1000.0;if _cgfff ._bfee ,_cecde =_fgeba .GetXHeight ();_cecde !=nil {_d .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_cecde );
};_cgfff ._bfee *=_eegb /1000.0;if _cgfff ._feaab ,_cecde =_fgeba .GetAscent ();_cecde !=nil {_d .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_cecde );
};_cgfff ._feaab *=_eegb /1000.0;if _cgfff ._ccbag ,_cecde =_fgeba .GetDescent ();_cecde !=nil {_d .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_cecde );
};_cgfff ._ccbag *=_eegb /1000.0;return _cgfff ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_bag *_cf .ContentStreamOperations ;_aef *_db .PdfPageResources ;_gg Positioning ;_ad ,_af float64 ;_bc float64 ;_ef float64 ;_ga float64 ;_add Margins ;_gc []*_db .PdfAnnotation ;};

// SetLineHeight sets the line height (1.0 default).
func (_acbb *Paragraph )SetLineHeight (lineheight float64 ){_acbb ._becfe =lineheight };

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_debf *Line )Width ()float64 {return _gb .Abs (_debf ._aafcb -_debf ._bbae )};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_feabeb *Ellipse )FillOpacity ()float64 {return _feabeb ._gfgd };func _ddee (_cgcac float64 ,_fgbba float64 )float64 {return _gb .Round (_cgcac /_fgbba )*_fgbba };

// Height returns the height of the list.
func (_beac *List )Height ()float64 {var _eebc float64 ;for _ ,_gdadb :=range _beac ._bdee {_eebc +=_gdadb .ctxHeight (_beac .Width ());};return _eebc ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_cdeda *Table )SetMargins (left ,right ,top ,bottom float64 ){_cdeda ._aaec .Left =left ;_cdeda ._aaec .Right =right ;_cdeda ._aaec .Top =top ;_cdeda ._aaec .Bottom =bottom ;};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_gabe *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fffcg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_acdb ,_bdab :=_fffcg .setOpacity (_gabe ._gfdd ,_gabe ._gfdd );if _bdab !=nil {return nil ,ctx ,_bdab ;};_ddbc :=_gabe ._defeg .Points ;
for _accb :=range _ddbc {_gcedf :=&_ddbc [_accb ];_gcedf .Y =ctx .PageHeight -_gcedf .Y ;};_ddagf ,_ ,_bdab :=_gabe ._defeg .Draw (_acdb );if _bdab !=nil {return nil ,ctx ,_bdab ;};if _bdab =_fffcg .addContentsByString (string (_ddagf ));_bdab !=nil {return nil ,ctx ,_bdab ;
};return []*Block {_fffcg },ctx ,nil ;};

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_dbdf *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_dbdf ._ddade =textOverflow };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_fgcd *Chapter )SetIncludeInTOC (includeInTOC bool ){_fgcd ._eab =includeInTOC };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_fddd *StyledParagraph )Height ()float64 {_fddd .wrapText ();var _bedf float64 ;for _ ,_fcgbg :=range _fddd ._ebgc {var _fecf float64 ;for _ ,_gdafe :=range _fcgbg {_fcgc :=_fddd ._gfae *_gdafe .Style .FontSize ;if _fcgc > _fecf {_fecf =_fcgc ;};
};_bedf +=_fecf ;};return _bedf ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_cdf *Block )Draw (d Drawable )error {_abc :=DrawContext {};_abc .Width =_cdf ._bc ;_abc .Height =_cdf ._ef ;_abc .PageWidth =_cdf ._bc ;_abc .PageHeight =_cdf ._ef ;_abc .X =0;_abc .Y =0;_aed ,_ ,_gbg :=d .GeneratePageBlocks (_abc );if _gbg !=nil {return _gbg ;
};if len (_aed )!=1{return ErrContentNotFit ;};for _ ,_gdb :=range _aed {if _dae :=_cdf .mergeBlocks (_gdb );_dae !=nil {return _dae ;};};return nil ;};func (_dccdg *templateProcessor )parsePageBreak (_agefa *templateNode )(interface{},error ){return _cceg (),nil ;
};

// GeneratePageBlocks implements drawable interface.
func (_dda *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aeg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ddb :=_dda ._ebfg ;_dagg :=ctx .PageHeight -_dda ._fca ;if _dda ._eade !=nil {_dddf :=_fg .Rectangle {Opacity :1.0,X :_dda ._ebfg ,Y :ctx .PageHeight -_dda ._fca -_dda ._gcec ,Height :_dda ._gcec ,Width :_dda ._dec };
_dddf .FillEnabled =true ;_fab :=_afb (_dda ._eade );_ecgc :=_edcb (_aeg ,_fab ,_dda ._eade ,func ()Rectangle {return Rectangle {_dbgeg :_dddf .X ,_gead :_dddf .Y ,_bccac :_dddf .Width ,_begbb :_dddf .Height };});if _ecgc !=nil {return nil ,ctx ,_ecgc ;
};_dddf .FillColor =_fab ;_dddf .BorderEnabled =false ;_dbbf ,_ ,_ecgc :=_dddf .Draw ("");if _ecgc !=nil {return nil ,ctx ,_ecgc ;};_ecgc =_aeg .addContentsByString (string (_dbbf ));if _ecgc !=nil {return nil ,ctx ,_ecgc ;};};_becg :=_dda ._fged ;_acc :=_dda ._dcdg ;
_cde :=_dda ._dabb ;_egg :=_dda ._cgcg ;_dgg :=_dda ._fged ;if _dda ._fbf ==CellBorderStyleDouble {_dgg +=2*_becg ;};_eee :=_dda ._dcdg ;if _dda ._egdc ==CellBorderStyleDouble {_eee +=2*_acc ;};_eff :=_dda ._dabb ;if _dda ._ccc ==CellBorderStyleDouble {_eff +=2*_cde ;
};_bca :=_dda ._cgcg ;if _dda ._bec ==CellBorderStyleDouble {_bca +=2*_egg ;};_cfbf :=(_dgg -_eff )/2;_dbff :=(_dgg -_bca )/2;_fgg :=(_eee -_eff )/2;_ebc :=(_eee -_bca )/2;if _dda ._fged !=0{_ecgcc :=_ddb ;_efgc :=_dagg ;if _dda ._fbf ==CellBorderStyleDouble {_efgc -=_becg ;
_gdbd :=_fg .BasicLine {LineColor :_afb (_dda ._gcb ),Opacity :1.0,LineWidth :_dda ._fged ,LineStyle :_dda .LineStyle ,X1 :_ecgcc -_dgg /2+_cfbf ,Y1 :_efgc +2*_becg ,X2 :_ecgcc +_dgg /2-_dbff +_dda ._dec ,Y2 :_efgc +2*_becg };_fac ,_ ,_eadeb :=_gdbd .Draw ("");
if _eadeb !=nil {return nil ,ctx ,_eadeb ;};_eadeb =_aeg .addContentsByString (string (_fac ));if _eadeb !=nil {return nil ,ctx ,_eadeb ;};};_ggc :=_fg .BasicLine {LineWidth :_dda ._fged ,Opacity :1.0,LineColor :_afb (_dda ._gcb ),LineStyle :_dda .LineStyle ,X1 :_ecgcc -_dgg /2+_cfbf +(_eff -_dda ._dabb ),Y1 :_efgc ,X2 :_ecgcc +_dgg /2-_dbff +_dda ._dec -(_bca -_dda ._cgcg ),Y2 :_efgc };
_ecc ,_ ,_eacb :=_ggc .Draw ("");if _eacb !=nil {return nil ,ctx ,_eacb ;};_eacb =_aeg .addContentsByString (string (_ecc ));if _eacb !=nil {return nil ,ctx ,_eacb ;};};if _dda ._dcdg !=0{_ega :=_ddb ;_daa :=_dagg -_dda ._gcec ;if _dda ._egdc ==CellBorderStyleDouble {_daa +=_acc ;
_ddce :=_fg .BasicLine {LineWidth :_dda ._dcdg ,Opacity :1.0,LineColor :_afb (_dda ._fff ),LineStyle :_dda .LineStyle ,X1 :_ega -_eee /2+_fgg ,Y1 :_daa -2*_acc ,X2 :_ega +_eee /2-_ebc +_dda ._dec ,Y2 :_daa -2*_acc };_abg ,_ ,_geed :=_ddce .Draw ("");if _geed !=nil {return nil ,ctx ,_geed ;
};_geed =_aeg .addContentsByString (string (_abg ));if _geed !=nil {return nil ,ctx ,_geed ;};};_cgge :=_fg .BasicLine {LineWidth :_dda ._dcdg ,Opacity :1.0,LineColor :_afb (_dda ._fff ),LineStyle :_dda .LineStyle ,X1 :_ega -_eee /2+_fgg +(_eff -_dda ._dabb ),Y1 :_daa ,X2 :_ega +_eee /2-_ebc +_dda ._dec -(_bca -_dda ._cgcg ),Y2 :_daa };
_fec ,_ ,_dga :=_cgge .Draw ("");if _dga !=nil {return nil ,ctx ,_dga ;};_dga =_aeg .addContentsByString (string (_fec ));if _dga !=nil {return nil ,ctx ,_dga ;};};if _dda ._dabb !=0{_cgcb :=_ddb ;_bbb :=_dagg ;if _dda ._ccc ==CellBorderStyleDouble {_cgcb +=_cde ;
_feab :=_fg .BasicLine {LineWidth :_dda ._dabb ,Opacity :1.0,LineColor :_afb (_dda ._ecd ),LineStyle :_dda .LineStyle ,X1 :_cgcb -2*_cde ,Y1 :_bbb +_eff /2+_cfbf ,X2 :_cgcb -2*_cde ,Y2 :_bbb -_eff /2-_fgg -_dda ._gcec };_bda ,_ ,_efed :=_feab .Draw ("");
if _efed !=nil {return nil ,ctx ,_efed ;};_efed =_aeg .addContentsByString (string (_bda ));if _efed !=nil {return nil ,ctx ,_efed ;};};_eadc :=_fg .BasicLine {LineWidth :_dda ._dabb ,Opacity :1.0,LineColor :_afb (_dda ._ecd ),LineStyle :_dda .LineStyle ,X1 :_cgcb ,Y1 :_bbb +_eff /2+_cfbf -(_dgg -_dda ._fged ),X2 :_cgcb ,Y2 :_bbb -_eff /2-_fgg -_dda ._gcec +(_eee -_dda ._dcdg )};
_fbd ,_ ,_gdd :=_eadc .Draw ("");if _gdd !=nil {return nil ,ctx ,_gdd ;};_gdd =_aeg .addContentsByString (string (_fbd ));if _gdd !=nil {return nil ,ctx ,_gdd ;};};if _dda ._cgcg !=0{_baa :=_ddb +_dda ._dec ;_eefg :=_dagg ;if _dda ._bec ==CellBorderStyleDouble {_baa -=_egg ;
_fda :=_fg .BasicLine {LineWidth :_dda ._cgcg ,Opacity :1.0,LineColor :_afb (_dda ._ccba ),LineStyle :_dda .LineStyle ,X1 :_baa +2*_egg ,Y1 :_eefg +_bca /2+_dbff ,X2 :_baa +2*_egg ,Y2 :_eefg -_bca /2-_ebc -_dda ._gcec };_eaf ,_ ,_fcc :=_fda .Draw ("");
if _fcc !=nil {return nil ,ctx ,_fcc ;};_fcc =_aeg .addContentsByString (string (_eaf ));if _fcc !=nil {return nil ,ctx ,_fcc ;};};_fecb :=_fg .BasicLine {LineWidth :_dda ._cgcg ,Opacity :1.0,LineColor :_afb (_dda ._ccba ),LineStyle :_dda .LineStyle ,X1 :_baa ,Y1 :_eefg +_bca /2+_dbff -(_dgg -_dda ._fged ),X2 :_baa ,Y2 :_eefg -_bca /2-_ebc -_dda ._gcec +(_eee -_dda ._dcdg )};
_bfad ,_ ,_cbbc :=_fecb .Draw ("");if _cbbc !=nil {return nil ,ctx ,_cbbc ;};_cbbc =_aeg .addContentsByString (string (_bfad ));if _cbbc !=nil {return nil ,ctx ,_cbbc ;};};return []*Block {_aeg },ctx ,nil ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_agecd *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_agecd ._gcba =alignment };func (_dgeb *templateProcessor )parseTextAlignmentAttr (_aaad ,_cgfac string )TextAlignment {_d .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_aaad ,_cgfac );
_cdfga :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_cgfac ];
return _cdfga ;};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_aaeeb *RadialShading )AddPatternResource (block *Block )(_gace _ag .PdfObjectName ,_adacd error ){_edfcf :=1;_gggc :=_ag .PdfObjectName ("\u0050"+_eg .Itoa (_edfcf ));for block ._aef .HasPatternByName (_gggc ){_edfcf ++;_gggc =_ag .PdfObjectName ("\u0050"+_eg .Itoa (_edfcf ));
};if _cgea :=block ._aef .SetPatternByName (_gggc ,_aaeeb .ToPdfShadingPattern ().ToPdfObject ());_cgea !=nil {return "",_cgea ;};return _gggc ,nil ;};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_cfca *Image )ConvertToBinary ()error {return _cfca ._efbg .ConvertToBinary ()};func _dfggg (_dafg *Table ,_dacgg DrawContext )([]*Block ,DrawContext ,error ){var _bdege []*Block ;_adde :=NewBlock (_dacgg .PageWidth ,_dacgg .PageHeight );_dafg .updateRowHeights (_dacgg .Width -_dafg ._aaec .Left -_dafg ._aaec .Right );
_ebgfb :=_dafg ._aaec .Top ;if _dafg ._afbg .IsRelative ()&&!_dafg ._ceef {_addd :=_dafg .Height ();if _addd > _dacgg .Height -_dafg ._aaec .Top &&_addd <=_dacgg .PageHeight -_dacgg .Margins .Top -_dacgg .Margins .Bottom {_bdege =[]*Block {NewBlock (_dacgg .PageWidth ,_dacgg .PageHeight -_dacgg .Y )};
var _gfcce error ;if _ ,_dacgg ,_gfcce =_cceg ().GeneratePageBlocks (_dacgg );_gfcce !=nil {return nil ,_dacgg ,_gfcce ;};_ebgfb =0;};};_baggd :=_dacgg ;if _dafg ._afbg .IsAbsolute (){_dacgg .X =_dafg ._dggde ;_dacgg .Y =_dafg ._gebee ;}else {_dacgg .X +=_dafg ._aaec .Left ;
_dacgg .Y +=_ebgfb ;_dacgg .Width -=_dafg ._aaec .Left +_dafg ._aaec .Right ;_dacgg .Height -=_ebgfb ;};_gfgf :=_dacgg .Width ;_bcbec :=_dacgg .X ;_gbdg :=_dacgg .Y ;_bafce :=_dacgg .Height ;_bdgdb :=0;_cbeea ,_begaa :=-1,-1;if _dafg ._eaged {for _abad ,_daeae :=range _dafg ._dgde {if _daeae ._adfd < _dafg ._gbag {continue ;
};if _daeae ._adfd > _dafg ._dacb {break ;};if _cbeea < 0{_cbeea =_abad ;};_begaa =_abad ;};};if _cbbee :=_dafg .wrapContent (_dacgg );_cbbee !=nil {return nil ,_dacgg ,_cbbee ;};_dafg .updateRowHeights (_dacgg .Width -_dafg ._aaec .Left -_dafg ._aaec .Right );
var (_bdda bool ;_gfga int ;_efcd int ;_ggggd bool ;_cfdgg int ;_efdc error ;);for _gedgd :=0;_gedgd < len (_dafg ._dgde );_gedgd ++{_gecf :=_dafg ._dgde [_gedgd ];if _daee ,_fgad :=_dafg .getLastCellFromCol (_gecf ._bcea );_daee ==_gedgd {if (_fgad ._adfd +_fgad ._fbeb -1)< _dafg ._dgdc {for _dcegcf :=_gecf ._adfd ;
_dcegcf < _dafg ._dgdc ;_dcegcf ++{_ggacd :=&TableCell {};_ggacd ._adfd =_dcegcf +1;_ggacd ._fbeb =1;_ggacd ._bcea =_gecf ._bcea ;_dafg ._dgde =append (_dafg ._dgde ,_ggacd );};};};_fgbc :=_gecf .width (_dafg ._cfab ,_gfgf );_dgbcg :=float64 (0.0);for _eegf :=0;
_eegf < _gecf ._bcea -1;_eegf ++{_dgbcg +=_dafg ._cfab [_eegf ]*_gfgf ;};_fgbf :=float64 (0.0);for _ccffgg :=_bdgdb ;_ccffgg < _gecf ._adfd -1;_ccffgg ++{_fgbf +=_dafg ._bebec [_ccffgg ];};_dacgg .Height =_bafce -_fgbf ;_gggec :=float64 (0.0);for _cgef :=0;
_cgef < _gecf ._fbeb ;_cgef ++{_gggec +=_dafg ._bebec [_gecf ._adfd +_cgef -1];};_eabea :=_ggggd &&_gecf ._adfd !=_cfdgg ;_cfdgg =_gecf ._adfd ;if _eabea ||_gggec > _dacgg .Height {if _dafg ._dcag &&!_ggggd {_ggggd ,_efdc =_dafg .wrapRow (_gedgd ,_dacgg ,_gfgf );
if _efdc !=nil {return nil ,_dacgg ,_efdc ;};if _ggggd {_gedgd --;continue ;};};_bdege =append (_bdege ,_adde );_adde =NewBlock (_dacgg .PageWidth ,_dacgg .PageHeight );_bcbec =_dacgg .Margins .Left +_dafg ._aaec .Left ;_gbdg =_dacgg .Margins .Top ;_dacgg .Height =_dacgg .PageHeight -_dacgg .Margins .Top -_dacgg .Margins .Bottom ;
_dacgg .Page ++;_bafce =_dacgg .Height ;_bdgdb =_gecf ._adfd -1;_fgbf =0;_ggggd =false ;if _dafg ._eaged &&_cbeea >=0{_gfga =_gedgd ;_gedgd =_cbeea -1;_efcd =_bdgdb ;_bdgdb =_dafg ._gbag -1;_bdda =true ;if _gecf ._fbeb > (_dafg ._dgdc -_cfdgg )||(_gecf ._fbeb > 1&&_gedgd < 0){_d .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_bdda =false ;_cbeea ,_begaa =-1,-1;};continue ;};if _eabea {_gedgd --;continue ;};};_dacgg .Width =_fgbc ;_dacgg .X =_bcbec +_dgbcg ;_dacgg .Y =_gbdg +_fgbf ;if _gggec > _dacgg .PageHeight -_dacgg .Margins .Top -_dacgg .Margins .Bottom {_gggec =_dacgg .PageHeight -_dacgg .Margins .Top -_dacgg .Margins .Bottom ;
};_ddgc :=_def (_dacgg .X ,_dacgg .Y ,_fgbc ,_gggec );if _gecf ._gdgb !=nil {_ddgc .SetFillColor (_gecf ._gdgb );};_ddgc .LineStyle =_gecf ._gbebf ;_ddgc ._ccc =_gecf ._gaffc ;_ddgc ._bec =_gecf ._gcffgc ;_ddgc ._fbf =_gecf ._abed ;_ddgc ._egdc =_gecf ._fddef ;
if _gecf ._cfge !=nil {_ddgc .SetColorLeft (_gecf ._cfge );};if _gecf ._ddac !=nil {_ddgc .SetColorBottom (_gecf ._ddac );};if _gecf ._gbbdf !=nil {_ddgc .SetColorRight (_gecf ._gbbdf );};if _gecf ._babeg !=nil {_ddgc .SetColorTop (_gecf ._babeg );};_ddgc .SetWidthBottom (_gecf ._bdbe );
_ddgc .SetWidthLeft (_gecf ._ddda );_ddgc .SetWidthRight (_gecf ._gcfeg );_ddgc .SetWidthTop (_gecf ._ffbcg );_dcadb :=NewBlock (_adde ._bc ,_adde ._ef );_ccaa :=_adde .Draw (_ddgc );if _ccaa !=nil {_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ccaa );
};if _gecf ._aabd !=nil {_gbed :=_gecf ._aabd .Width ();_bfeaa :=_gecf ._aabd .Height ();_cbdgg :=0.0;switch _bfbd :=_gecf ._aabd .(type ){case *Paragraph :if _bfbd ._aacg {_gbed =_bfbd .getMaxLineWidth ()/1000.0;};_agfcc ,_dfgc ,_ :=_bfbd .getTextMetrics ();
_aaebd ,_cdecb :=_agfcc *_bfbd ._becfe ,_dfgc *_bfbd ._becfe ;_bfeaa =_bfeaa -_cdecb +_aaebd ;_cbdgg +=_aaebd -_cdecb ;_gccdc :=0.5;if _dafg ._cfed {_gccdc =0.3;};switch _gecf ._gdca {case CellVerticalAlignmentTop :_cbdgg +=_aaebd *_gccdc ;case CellVerticalAlignmentBottom :_cbdgg -=_aaebd *_gccdc ;
};_gbed +=_bfbd ._fdda .Left +_bfbd ._fdda .Right ;_bfeaa +=_bfbd ._fdda .Top +_bfbd ._fdda .Bottom ;case *StyledParagraph :if _bfbd ._bbff {_gbed =_bfbd .getMaxLineWidth ()/1000.0;};_bcbdf ,_gcadd ,_gagfg :=_bfbd .getLineMetrics (0);_dfag ,_ggcag :=_bcbdf *_bfbd ._gfae ,_gcadd *_bfbd ._gfae ;
if _bfbd ._gabbd ==TextVerticalAlignmentCenter {_cbdgg =_ggcag -(_gcadd +(_bcbdf +_gagfg -_gcadd )/2+(_ggcag -_gcadd )/2);};if len (_bfbd ._ebgc )==1{_bfeaa =_dfag ;}else {_bfeaa =_bfeaa -_ggcag +_dfag ;};_cbdgg +=_dfag -_ggcag ;switch _gecf ._gdca {case CellVerticalAlignmentTop :_cbdgg +=_dfag *0.5;
case CellVerticalAlignmentBottom :_cbdgg -=_dfag *0.5;};_gbed +=_bfbd ._acfa .Left +_bfbd ._acfa .Right ;_bfeaa +=_bfbd ._acfa .Top +_bfbd ._acfa .Bottom ;case *Table :_gbed =_fgbc ;case *List :_gbed =_fgbc ;case *Division :_gbed =_fgbc ;case *Chart :_gbed =_fgbc ;
case *Line :_bfeaa +=_bfbd ._gabgd .Top +_bfbd ._gabgd .Bottom ;_cbdgg -=_bfbd .Height ()/2;case *Image :_gbed +=_bfbd ._gabc .Left +_bfbd ._gabc .Right ;_bfeaa +=_bfbd ._gabc .Top +_bfbd ._gabc .Bottom ;};switch _gecf ._ddfgb {case CellHorizontalAlignmentLeft :_dacgg .X +=_gecf ._dedb ;
_dacgg .Width -=_gecf ._dedb ;case CellHorizontalAlignmentCenter :if _fefdc :=_fgbc -_gbed ;_fefdc > 0{_dacgg .X +=_fefdc /2;_dacgg .Width -=_fefdc /2;};case CellHorizontalAlignmentRight :if _fgbc > _gbed {_dacgg .X =_dacgg .X +_fgbc -_gbed -_gecf ._dedb ;
_dacgg .Width -=_gecf ._dedb ;};};_bdfa :=_dacgg .Y ;_eggc :=_dacgg .Height ;_dacgg .Y +=_cbdgg ;switch _gecf ._gdca {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _fddec :=_gggec -_bfeaa ;_fddec > 0{_dacgg .Y +=_fddec /2;_dacgg .Height -=_fddec /2;
};case CellVerticalAlignmentBottom :if _gggec > _bfeaa {_dacgg .Y =_dacgg .Y +_gggec -_bfeaa ;_dacgg .Height =_gggec ;};};_edgg :=_adde .DrawWithContext (_gecf ._aabd ,_dacgg );if _edgg !=nil {if _ab .Is (_edgg ,ErrContentNotFit )&&!_eabea {_adde =_dcadb ;
_eabea =true ;_gedgd --;continue ;};_d .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_edgg );};_dacgg .Y =_bdfa ;_dacgg .Height =_eggc ;};_dacgg .Y +=_gggec ;_dacgg .Height -=_gggec ;if _bdda &&_gedgd +1> _begaa {_gbdg +=_fgbf +_gggec ;_bafce -=_gggec +_fgbf ;
_bdgdb =_efcd ;_gedgd =_gfga -1;_bdda =false ;};};_bdege =append (_bdege ,_adde );if _dafg ._afbg .IsAbsolute (){return _bdege ,_baggd ,nil ;};_dacgg .X =_baggd .X ;_dacgg .Width =_baggd .Width ;_dacgg .Y +=_dafg ._aaec .Bottom ;_dacgg .Height -=_dafg ._aaec .Bottom ;
return _bdege ,_dacgg ,nil ;};type fontMetrics struct{_ebdff float64 ;_bfee float64 ;_feaab float64 ;_ccbag float64 ;};

// SetOpacity sets opacity for Image.
func (_dgad *Image )SetOpacity (opacity float64 ){_dgad ._fdfd =opacity };func (_bbbdd *templateProcessor )parseChapter (_feee *templateNode )(interface{},error ){_dfaed :=_bbbdd .creator .NewChapter ;if _feee ._abgfd !=nil {if _bgae ,_bdac :=_feee ._abgfd ._dfbaa .(*Chapter );
_bdac {_dfaed =_bgae .NewSubchapter ;};};_egdgg :=_dfaed ("");for _ ,_bdbaa :=range _feee ._fabca .Attr {_ceaff :=_bdbaa .Value ;switch _debb :=_bdbaa .Name .Local ;_debb {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_egdgg .SetShowNumbering (_bbbdd .parseBoolAttr (_debb ,_ceaff ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_egdgg .SetIncludeInTOC (_bbbdd .parseBoolAttr (_debb ,_ceaff ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_faca :=_bbbdd .parseMarginAttr (_debb ,_ceaff );_egdgg .SetMargins (_faca .Left ,_faca .Right ,_faca .Top ,_faca .Bottom );
default:_bbbdd .nodeLogDebug (_feee ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_debb );
};};return _egdgg ,nil ;};func (_fbfg *FilledCurve )draw (_adac *Block ,_gafe string )([]byte ,*_db .PdfRectangle ,error ){_adfb :=_fg .NewCubicBezierPath ();for _ ,_fafa :=range _fbfg ._aae {_adfb =_adfb .AppendCurve (_fafa );};creator :=_cf .NewContentCreator ();
creator .Add_q ();if _fbfg .FillEnabled &&_fbfg ._gebc !=nil {_ddg :=_afb (_fbfg ._gebc );_cfeg :=_edcb (_adac ,_ddg ,_fbfg ._gebc ,func ()Rectangle {_ddgf :=_fg .NewCubicBezierPath ();for _ ,_dbbad :=range _fbfg ._aae {_ddgf =_ddgf .AppendCurve (_dbbad );
};_eadg :=_ddgf .GetBoundingBox ();if _fbfg .BorderEnabled {_eadg .Height +=_fbfg .BorderWidth ;_eadg .Width +=_fbfg .BorderWidth ;_eadg .X -=_fbfg .BorderWidth /2;_eadg .Y -=_fbfg .BorderWidth /2;};return Rectangle {_dbgeg :_eadg .X ,_gead :_eadg .Y ,_bccac :_eadg .Width ,_begbb :_eadg .Height };
});if _cfeg !=nil {return nil ,nil ,_cfeg ;};creator .SetNonStrokingColor (_ddg );};if _fbfg .BorderEnabled {if _fbfg ._agdg !=nil {creator .SetStrokingColor (_afb (_fbfg ._agdg ));};creator .Add_w (_fbfg .BorderWidth );};if len (_gafe )> 1{creator .Add_gs (_ag .PdfObjectName (_gafe ));
};_fg .DrawBezierPathWithCreator (_adfb ,creator );creator .Add_h ();if _fbfg .FillEnabled &&_fbfg .BorderEnabled {creator .Add_B ();}else if _fbfg .FillEnabled {creator .Add_f ();}else if _fbfg .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_defef :=_adfb .GetBoundingBox ();
if _fbfg .BorderEnabled {_defef .Height +=_fbfg .BorderWidth ;_defef .Width +=_fbfg .BorderWidth ;_defef .X -=_fbfg .BorderWidth /2;_defef .Y -=_fbfg .BorderWidth /2;};_fagf :=&_db .PdfRectangle {};_fagf .Llx =_defef .X ;_fagf .Lly =_defef .Y ;_fagf .Urx =_defef .X +_defef .Width ;
_fagf .Ury =_defef .Y +_defef .Height ;return creator .Bytes (),_fagf ,nil ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_facec *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_facec .Text },nil ;};var _gfbfe []string ;var _dcaec []rune ;var _fdddd float64 ;var _edbec []float64 ;_egeeb :=_facec .Style ;_ebddg :=_afgf (_facec .Text );
for _ ,_bbebe :=range _facec .Text {if _bbebe =='\u000A'{_fagcg :=_ebcab (string (_dcaec ),_ebddg );_gfbfe =append (_gfbfe ,_cc .TrimRightFunc (_fagcg ,_ff .IsSpace )+string (_bbebe ));_dcaec =nil ;_fdddd =0;_edbec =nil ;continue ;};_fgcdd :=_bbebe ==' ';
_acee ,_dgcf :=_egeeb .Font .GetRuneMetrics (_bbebe );if !_dgcf {_d .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_bbebe ,_bbebe ,_egeeb .Font .BaseFont (),_egeeb .Font .Subtype ());
_d .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_egeeb .Font );_d .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_egeeb .Font .Encoder ());return nil ,_ab .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_cggab :=_egeeb .FontSize *_acee .Wx ;_gdfd :=_cggab ;if !_fgcdd {_gdfd =_cggab +_egeeb .CharSpacing *1000.0;};if _fdddd +_cggab > width *1000.0{_egde :=-1;if !_fgcdd {for _bcbac :=len (_dcaec )-1;_bcbac >=0;_bcbac --{if _dcaec [_bcbac ]==' '{_egde =_bcbac ;
break ;};};};_gccce :=string (_dcaec );if _egde > 0{_gccce =string (_dcaec [0:_egde +1]);_dcaec =append (_dcaec [_egde +1:],_bbebe );_edbec =append (_edbec [_egde +1:],_gdfd );_fdddd =0;for _ ,_cfbaa :=range _edbec {_fdddd +=_cfbaa ;};}else {if _fgcdd {_dcaec =[]rune {};
_edbec =[]float64 {};_fdddd =0;}else {_dcaec =[]rune {_bbebe };_edbec =[]float64 {_gdfd };_fdddd =_gdfd ;};};_gccce =_ebcab (_gccce ,_ebddg );_gfbfe =append (_gfbfe ,_cc .TrimRightFunc (_gccce ,_ff .IsSpace ));}else {_dcaec =append (_dcaec ,_bbebe );_fdddd +=_gdfd ;
_edbec =append (_edbec ,_gdfd );};};if len (_dcaec )> 0{_feccc :=string (_dcaec );_feccc =_ebcab (_feccc ,_ebddg );_gfbfe =append (_gfbfe ,_feccc );};return _gfbfe ,nil ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_beag *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_beag ._bbgd .Left =left ;_beag ._bbgd .Right =right ;_beag ._bbgd .Top =top ;_beag ._bbgd .Bottom =bottom ;};func _def (_fgef ,_abd ,_cbgf ,_acdee float64 )*border {_bgg :=&border {};
_bgg ._ebfg =_fgef ;_bgg ._fca =_abd ;_bgg ._dec =_cbgf ;_bgg ._gcec =_acdee ;_bgg ._gcb =ColorBlack ;_bgg ._fff =ColorBlack ;_bgg ._ecd =ColorBlack ;_bgg ._ccba =ColorBlack ;_bgg ._fged =0;_bgg ._dcdg =0;_bgg ._dabb =0;_bgg ._cgcg =0;_bgg .LineStyle =_fg .LineStyleSolid ;
return _bgg ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_fafg *Creator )DrawHeader (drawHeaderFunc func (_aeab *Block ,_efgce HeaderFunctionArgs )){_fafg ._dffe =drawHeaderFunc ;};type grayColor struct{_fffc float64 };func _bgfgdd (_beaag ,_facfc interface{})(interface{},error ){_gfacd ,_gabde :=_bcbde (_beaag );
if _gabde !=nil {return nil ,_gabde ;};switch _ecefa :=_gfacd .(type ){case int64 :_edagc ,_bgfe :=_bcbde (_facfc );if _bgfe !=nil {return nil ,_bgfe ;};switch _ccga :=_edagc .(type ){case int64 :return _ecefa +_ccga ,nil ;case float64 :return float64 (_ecefa )+_ccga ,nil ;
};case float64 :_cfgba ,_ffbef :=_bcbde (_facfc );if _ffbef !=nil {return nil ,_ffbef ;};switch _gddaa :=_cfgba .(type ){case int64 :return _ecefa +float64 (_gddaa ),nil ;case float64 :return _ecefa +_gddaa ,nil ;};};return nil ,_f .Errorf ("\u0066\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0025\u0076\u0020\u0061\u006e\u0064\u0020\u0025\u0076",_beaag ,_facfc );
};

// SetBorderWidth sets the border width of the ellipse.
func (_bcbfd *Ellipse )SetBorderWidth (bw float64 ){_bcbfd ._gcef =bw };

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_bbdae *_fg .CurvePolygon ;_dcgf float64 ;_egaf float64 ;_aabgb Color ;};

// SetAngle sets the rotation angle of the text.
func (_dfgf *StyledParagraph )SetAngle (angle float64 ){_dfgf ._bgbbb =angle };

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_cfc *Block )SetPos (x ,y float64 ){_cfc ._gg =PositionAbsolute ;_cfc ._ad =x ;_cfc ._af =y };

// SetBuyerAddress sets the buyer address of the invoice.
func (_eabbd *Invoice )SetBuyerAddress (address *InvoiceAddress ){_eabbd ._ebcgc =address };

// SetMargins sets the margins of the graphic svg component.
func (_eeee *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_eeee ._dagb .Left =left ;_eeee ._dagb .Right =right ;_eeee ._dagb .Top =top ;_eeee ._dagb .Bottom =bottom ;};

// NewTable create a new Table with a specified number of columns.
func (_cbfg *Creator )NewTable (cols int )*Table {return _eedb (cols )};

// NewInvoice returns an instance of an empty invoice.
func (_gdg *Creator )NewInvoice ()*Invoice {_abdd :=_gdg .NewTextStyle ();_abdd .Font =_gdg ._cggc ;return _cfeb (_gdg .NewTextStyle (),_abdd );};

// SetBorderWidth sets the border width.
func (_ggdfa *Polygon )SetBorderWidth (borderWidth float64 ){_ggdfa ._cdfc .BorderWidth =borderWidth };

// NewCellProps returns the default properties of an invoice cell.
func (_daad *Invoice )NewCellProps ()InvoiceCellProps {_cbdd :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_daad ._cafa ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_cbdd ,BorderColor :_cbdd ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// SetLevel sets the indentation level of the TOC line.
func (_bgcbe *TOCLine )SetLevel (level uint ){_bgcbe ._fbgga =level ;_bgcbe ._ffcgc ._acfa .Left =_bgcbe ._gaag +float64 (_bgcbe ._fbgga -1)*_bgcbe ._dgcg ;};func (_ggda *Invoice )setCellBorder (_dfaee *TableCell ,_cgfd *InvoiceCell ){for _ ,_deda :=range _cgfd .BorderSides {_dfaee .SetBorder (_deda ,CellBorderStyleSingle ,_cgfd .BorderWidth );
};_dfaee .SetBorderColor (_cgfd .BorderColor );};func (_cebfgg *templateProcessor )parseCellVerticalAlignmentAttr (_adbcd ,_fdfdg string )CellVerticalAlignment {_d .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_adbcd ,_fdfdg );
_cgcbg :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_fdfdg ];return _cgcbg ;
};

// RotatedSize returns the width and height of the rotated block.
func (_cbb *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_bge ,_eeb :=_egdd (_cbb ._bc ,_cbb ._ef ,_cbb ._ga );return _bge ,_eeb ;};func (_agabd *templateProcessor )parseLineStyleAttr (_bfcgg ,_dbbdf string )_fg .LineStyle {_d .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bfcgg ,_dbbdf );
_cbfddb :=map[string ]_fg .LineStyle {"\u0073\u006f\u006ci\u0064":_fg .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_fg .LineStyleDashed }[_dbbdf ];return _cbfddb ;};

// Cols returns the total number of columns the table has.
func (_bbdaf *Table )Cols ()int {return _bbdaf ._cccbd };

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_adg *Division )Width ()float64 {return 0};func (_acdg *List )split (_caac DrawContext )(_eega ,_fbdbe *List ){var (_agba float64 ;_caae ,_bbbae []*listItem ;);_afag :=_caac .Width -_acdg ._ebdfg .Horizontal ()-_acdg ._adge -_acdg .markerWidth ();
_abdgb :=_acdg .markerWidth ();for _cgfa ,_bfea :=range _acdg ._bdee {_aefdb :=_bfea .ctxHeight (_afag );_agba +=_aefdb ;if _agba <=_caac .Height {_caae =append (_caae ,_bfea );}else {switch _cfdg :=_bfea ._cbea .(type ){case *List :_cade :=_caac ;_cade .Height =_gb .Floor (_aefdb -(_agba -_caac .Height ));
_fcee ,_aagc :=_cfdg .split (_cade );if _fcee !=nil {_bdeg :=_agdd ();_bdeg ._bdaa =_bfea ._bdaa ;_bdeg ._cbea =_fcee ;_caae =append (_caae ,_bdeg );};if _aagc !=nil {_daeb :=_cfdg ._gccff .Style .FontSize ;_eccf ,_bgeac :=_cfdg ._gccff .Style .Font .GetRuneMetrics (' ');
if _bgeac {_daeb =_cfdg ._gccff .Style .FontSize *_eccf .Wx *_cfdg ._gccff .Style .horizontalScale ()/1000.0;};_eddg :=_cc .Repeat ("\u0020",int (_abdgb /_daeb ));_cecca :=_agdd ();_cecca ._bdaa =*NewTextChunk (_eddg ,_cfdg ._gccff .Style );_cecca ._cbea =_aagc ;
_bbbae =append (_bbbae ,_cecca );_bbbae =append (_bbbae ,_acdg ._bdee [_cgfa +1:]...);};default:_bbbae =_acdg ._bdee [_cgfa :];};if len (_bbbae )> 0{break ;};};};if len (_caae )> 0{_eega =_ebff (_acdg ._fcad );*_eega =*_acdg ;_eega ._bdee =_caae ;};if len (_bbbae )> 0{_fbdbe =_ebff (_acdg ._fcad );
*_fbdbe =*_acdg ;_fbdbe ._bdee =_bbbae ;};return _eega ,_fbdbe ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_afc :_gb .Max (_gb .Min (c ,1.0),0.0),_dff :_gb .Max (_gb .Min (m ,1.0),0.0),_edea :_gb .Max (_gb .Min (y ,1.0),0.0),_cec :_gb .Max (_gb .Min (k ,1.0),0.0)};};

// Context returns the current drawing context.
func (_bggf *Creator )Context ()DrawContext {return _bggf ._edg };

// SetStyleTop sets border style for top side.
func (_agf *border )SetStyleTop (style CellBorderStyle ){_agf ._fbf =style };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_fgag *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_aaced :=range subtable ._dgde {_deabg :=&TableCell {};*_deabg =*_aaced ;_deabg ._bfdgf =_fgag ;_deabg ._bcea +=col -1;if _aedega :=_fgag ._cccbd -(_deabg ._bcea -1);_aedega < _deabg ._egba {_fgag ._cccbd +=_deabg ._egba -_aedega ;
_fgag .resetColumnWidths ();_d .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_fgag ._cccbd );
};_deabg ._adfd +=row -1;_adea :=subtable ._bebec [_aaced ._adfd -1];if _deabg ._adfd > _fgag ._dgdc {for _deabg ._adfd > _fgag ._dgdc {_fgag ._dgdc ++;_fgag ._bebec =append (_fgag ._bebec ,_fgag ._gbccbb );};_fgag ._bebec [_deabg ._adfd -1]=_adea ;}else {_fgag ._bebec [_deabg ._adfd -1]=_gb .Max (_fgag ._bebec [_deabg ._adfd -1],_adea );
};_fgag ._dgde =append (_fgag ._dgde ,_deabg );};_fgag .sortCells ();};

// SetShowLinks sets visibility of links for the TOC lines.
func (_gdabc *TOC )SetShowLinks (showLinks bool ){_gdabc ._ffcgd =showLinks };

// AppendColumn appends a column to the line items table.
func (_gegd *Invoice )AppendColumn (description string )*InvoiceCell {_egaa :=_gegd .NewColumn (description );_gegd ._cbfcg =append (_gegd ._cbfcg ,_egaa );return _egaa ;};func _acae (_ggce *Chapter ,_edc *TOC ,_fgeff *_db .Outline ,_daec string ,_ccab int ,_bdc TextStyle )*Chapter {var _dcb uint =1;
if _ggce !=nil {_dcb =_ggce ._afd +1;};_fdea :=&Chapter {_edee :_ccab ,_dgac :_daec ,_dggd :true ,_eab :true ,_cdff :_ggce ,_cegd :_edc ,_daab :_fgeff ,_bgf :[]Drawable {},_afd :_dcb };_cag :=_gccef (_fdea .headingText (),_bdc );_cag .SetFont (_bdc .Font );
_cag .SetFontSize (_bdc .FontSize );_fdea ._gdbe =_cag ;return _fdea ;};type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// SetBorderOpacity sets the border opacity of the rectangle.
func (_ggbg *Rectangle )SetBorderOpacity (opacity float64 ){_ggbg ._ccbd =opacity };

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_cgec *shading ;_fbagg *_db .PdfRectangle ;_afad AnchorPoint ;_cfad float64 ;_gabfd float64 ;_beea float64 ;_edfc float64 ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_dfd *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aefdg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dbed :=_cf .NewContentCreator ();_dbed .Add_q ().Add_w (_dfd ._becb ).SetStrokingColor (_afb (_dfd ._ffdb )).Add_m (_dfd ._gdgg ,ctx .PageHeight -_dfd ._edec ).Add_v (_dfd ._edda ,ctx .PageHeight -_dfd ._bfgg ,_dfd ._geedb ,ctx .PageHeight -_dfd ._cfdf ).Add_S ().Add_Q ();
_dgf :=_aefdg .addContentsByString (_dbed .String ());if _dgf !=nil {return nil ,ctx ,_dgf ;};return []*Block {_aefdg },ctx ,nil ;};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_fdaa *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_fdaa ._ddfgb =halign };

// AppendCurve appends a Bezier curve to the filled curve.
func (_bcbeg *FilledCurve )AppendCurve (curve _fg .CubicBezierCurve )*FilledCurve {_bcbeg ._aae =append (_bcbeg ._aae ,curve );return _bcbeg ;};

// Heading returns the heading component of the table of contents.
func (_eabada *TOC )Heading ()*StyledParagraph {return _eabada ._gafa };func (_gafea *Invoice )newCell (_ceccd string ,_defbb InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_defbb ,_ceccd };};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_gacd *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gacd ._fdda .Left ,_gacd ._fdda .Right ,_gacd ._fdda .Top ,_gacd ._fdda .Bottom ;};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// MultiFont represents an encoder that accepts multiple fonts and selects the correct font for encoding.
MultiFont *_db .MultipleFontEncoder ;

// Font represents the font the text will use.
Font *_db .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};func _dgdb (_fgage map[string ]interface{},_bdeba ...interface{})(map[string ]interface{},error ){_gdcg :=len (_bdeba );if _gdcg %2!=0{return nil ,_ag .ErrRangeError ;};for _dcdgc :=0;_dcdgc < _gdcg ;_dcdgc +=2{_gefd ,_edgcb :=_bdeba [_dcdgc ].(string );
if !_edgcb {return nil ,_ag .ErrTypeError ;};_fgage [_gefd ]=_bdeba [_dcdgc +1];};return _fgage ,nil ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_bd *Block )ScaleToWidth (w float64 ){_bbd :=w /_bd ._bc ;_bd .Scale (_bbd ,_bbd )};

// SetPositioning sets the positioning of the line (absolute or relative).
func (_egfg *Line )SetPositioning (positioning Positioning ){_egfg ._fdgb =positioning };

// SetWidth sets the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_aede *Paragraph )SetWidth (width float64 ){_aede ._cbeda =width ;_aede .wrapText ()};

// MoveX moves the drawing context to absolute position x.
func (_dceg *Creator )MoveX (x float64 ){_dceg ._edg .X =x };

// SetLineWidth sets the line width.
func (_aefde *Polyline )SetLineWidth (lineWidth float64 ){_aefde ._defeg .LineWidth =lineWidth };

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_aaca *Rectangle )SetFitMode (fitMode FitMode ){_aaca ._bbc =fitMode };

// SetBorderColor sets the border color for the path.
func (_bdga *FilledCurve )SetBorderColor (color Color ){_bdga ._agdg =color };

// Title returns the title of the invoice.
func (_caca *Invoice )Title ()string {return _caca ._fgedc };

// Margins returns the margins of the list: left, right, top, bottom.
func (_gebcd *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _gebcd ._ebdfg .Left ,_gebcd ._ebdfg .Right ,_gebcd ._ebdfg .Top ,_gebcd ._ebdfg .Bottom ;};func (_bgfde *StyledParagraph )split (_ggca DrawContext )(_gbgac ,_acfc *StyledParagraph ,_fgaa error ){if _fgaa =_bgfde .wrapChunks (false );
_fgaa !=nil {return nil ,nil ,_fgaa ;};if len (_bgfde ._ebgc )==1&&_bgfde ._gfae > _ggca .Height {return _bgfde ,nil ,nil ;};_adef :=func (_egcf []*TextChunk ,_bafc []*TextChunk )[]*TextChunk {if len (_bafc )==0{return _egcf ;};_dccba :=len (_egcf );if _dccba ==0{return append (_egcf ,_bafc ...);
};if _egcf [_dccba -1].Style ==_bafc [0].Style {_egcf [_dccba -1].Text +=_bafc [0].Text ;}else {_egcf =append (_egcf ,_bafc [0]);};return append (_egcf ,_bafc [1:]...);};_bfcdg :=func (_abga *StyledParagraph ,_cffe []*TextChunk )*StyledParagraph {if len (_cffe )==0{return nil ;
};_gbdc :=*_abga ;_gbdc ._cdegd =_cffe ;return &_gbdc ;};var (_fdcg float64 ;_agcec []*TextChunk ;_bcdca []*TextChunk ;);for _ ,_eafa :=range _bgfde ._ebgc {var _dfegf float64 ;_geeb :=make ([]*TextChunk ,0,len (_eafa ));for _ ,_bbfc :=range _eafa {if _bcegc :=_bbfc .Style .FontSize ;
_bcegc > _dfegf {_dfegf =_bcegc ;};_geeb =append (_geeb ,_bbfc .clone ());};_dfegf *=_bgfde ._gfae ;if _bgfde ._fadf .IsRelative (){if _fdcg +_dfegf > _ggca .Height {_bcdca =_adef (_bcdca ,_geeb );}else {_agcec =_adef (_agcec ,_geeb );};};_fdcg +=_dfegf ;
};_bgfde ._ebgc =nil ;if len (_bcdca )==0{return _bgfde ,nil ,nil ;};return _bfcdg (_bgfde ,_agcec ),_bfcdg (_bgfde ,_bcdca ),nil ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_ggdd *Invoice )AddressHeadingStyle ()TextStyle {return _ggdd ._gbff };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline };};

// SellerAddress returns the seller address used in the invoice template.
func (_gebe *Invoice )SellerAddress ()*InvoiceAddress {return _gebe ._afa };

// BorderColor returns the border color of the rectangle.
func (_fcfa *Rectangle )BorderColor ()Color {return _fcfa ._ddde };

// SetColorTop sets border color for top.
func (_ccad *border )SetColorTop (col Color ){_ccad ._gcb =col };

// Height returns the height of the chart.
func (_dbfb *Chart )Height ()float64 {return float64 (_dbfb ._aefd .Height ())};

// DashPattern returns the dash pattern of the line.
func (_dbec *Line )DashPattern ()(_bcege []int64 ,_aaeb int64 ){return _dbec ._ggdb ,_dbec ._defa };

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_abf *Invoice )Sections ()[][2]string {return _abf ._eadcb };

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_cbda *Table )Width ()float64 {return 0};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_bbga *Invoice )SetNoteHeadingStyle (style TextStyle ){_bbga ._geacd =style };

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_dfae *Ellipse )GetCoords ()(float64 ,float64 ){return _dfae ._ddag ,_dfae ._gabf };func (_caccd *templateProcessor )parseParagraph (_bbfe *templateNode ,_ggga *Paragraph )(interface{},error ){if _ggga ==nil {_ggga =_caccd .creator .NewParagraph ("");
};for _ ,_gecfb :=range _bbfe ._fabca .Attr {_fcag :=_gecfb .Value ;switch _abdgc :=_gecfb .Name .Local ;_abdgc {case "\u0066\u006f\u006e\u0074":_ggga .SetFont (_caccd .parseFontAttr (_abdgc ,_fcag ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_ggga .SetFontSize (_caccd .parseFloatAttr (_abdgc ,_fcag ));
case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_ggga .SetTextAlignment (_caccd .parseTextAlignmentAttr (_abdgc ,_fcag ));case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_ggga .SetLineHeight (_caccd .parseFloatAttr (_abdgc ,_fcag ));
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_ggga .SetEnableWrap (_caccd .parseBoolAttr (_abdgc ,_fcag ));case "\u0063\u006f\u006co\u0072":_ggga .SetColor (_caccd .parseColorAttr (_abdgc ,_fcag ));case "\u0078":_ggga .SetPos (_caccd .parseFloatAttr (_abdgc ,_fcag ),_ggga ._ecega );
case "\u0079":_ggga .SetPos (_ggga ._ecaa ,_caccd .parseFloatAttr (_abdgc ,_fcag ));case "\u0061\u006e\u0067l\u0065":_ggga .SetAngle (_caccd .parseFloatAttr (_abdgc ,_fcag ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_gcggc :=_caccd .parseMarginAttr (_abdgc ,_fcag );
_ggga .SetMargins (_gcggc .Left ,_gcggc .Right ,_gcggc .Top ,_gcggc .Bottom );case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_ggga .SetMaxLines (int (_caccd .parseInt64Attr (_abdgc ,_fcag )));default:_caccd .nodeLogDebug (_bbfe ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_abdgc );
};};return _ggga ,nil ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//
//	[number] [title]      [separator] [page]
//
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_gafa *StyledParagraph ;_bcaf []*TOCLine ;_gfdgb TextStyle ;_becab TextStyle ;_eddb TextStyle ;_fafd TextStyle ;_defdd string ;_egab float64 ;_cadb Margins ;_dfcba Positioning ;_ebfbc TextStyle ;_ffcgd bool ;};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_gced *Creator )AddPage (page *_db .PdfPage )error {_cfde ,_efcb :=_gced .wrapPageIfNeeded (page );if _efcb !=nil {return _efcb ;};if _cfde !=nil {page =_cfde ;};_egfc ,_efcb :=page .GetMediaBox ();if _efcb !=nil {_d .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_efcb );
return _efcb ;};_egfc .Normalize ();_ebeg ,_bfdda :=_egfc .Llx ,_egfc .Lly ;_bddd :=_egfc ;if _egdf :=page .CropBox ;_egdf !=nil &&*_egdf !=*_egfc {_egdf .Normalize ();_ebeg ,_bfdda =_egdf .Llx ,_egdf .Lly ;_bddd =_egdf ;};_acg :=_eaa .IdentityMatrix ();
_adag ,_efcb :=page .GetRotate ();if _efcb !=nil {_d .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_efcb .Error ());
};_dgbc :=_adag %360!=0&&_adag %90==0;if _dgbc {_fefd :=float64 ((360+_adag %360)%360);if _fefd ==90{_acg =_acg .Translate (_bddd .Width (),0);}else if _fefd ==180{_acg =_acg .Translate (_bddd .Width (),_bddd .Height ());}else if _fefd ==270{_acg =_acg .Translate (0,_bddd .Height ());
};_acg =_acg .Mult (_eaa .RotationMatrix (_fefd *_gb .Pi /180));_acg =_acg .Round (0.000001);_cgga :=_bada (_bddd ,_acg );_bddd =_cgga ;_bddd .Normalize ();};if _ebeg !=0||_bfdda !=0{_acg =_eaa .TranslationMatrix (_ebeg ,_bfdda ).Mult (_acg );};if !_acg .Identity (){_acg =_acg .Round (0.000001);
_gced ._fcgg [page ]=&pageTransformations {_dbfd :&_acg };};_gced ._gcac =_bddd .Width ();_gced ._cfaf =_bddd .Height ();_gced .initContext ();_gced ._caa =append (_gced ._caa ,page );_gced ._edg .Page ++;return nil ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_dabe *Invoice )SetTerms (title ,content string ){_dabe ._bggce =[2]string {title ,content }};

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_fbdbd *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_bgaf []*Block ;_gcbg =NewBlock (ctx .PageWidth ,ctx .PageHeight );_egeb =ctx ;);_fbb :=_fbdbd ._baeb .IsRelative ();if _fbb {_fbdbd .applyFitMode (ctx .Width );
ctx .X +=_fbdbd ._fbcgf .Left ;ctx .Y +=_fbdbd ._fbcgf .Top ;ctx .Width -=_fbdbd ._fbcgf .Left +_fbdbd ._fbcgf .Right ;ctx .Height -=_fbdbd ._fbcgf .Top +_fbdbd ._fbcgf .Bottom ;if _fbdbd ._faea > ctx .Height {_bgaf =append (_bgaf ,_gcbg );_gcbg =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_afcg :=ctx ;_afcg .Y =ctx .Margins .Top +_fbdbd ._fbcgf .Top ;_afcg .X =ctx .Margins .Left +_fbdbd ._fbcgf .Left ;_afcg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_fbdbd ._fbcgf .Top -_fbdbd ._fbcgf .Bottom ;_afcg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_fbdbd ._fbcgf .Left -_fbdbd ._fbcgf .Right ;
ctx =_afcg ;};}else {ctx .X =_fbdbd ._ddag -_fbdbd ._bee /2;ctx .Y =_fbdbd ._gabf -_fbdbd ._faea /2;};_aece :=_fg .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_fbdbd ._faea ,Width :_fbdbd ._bee ,Height :_fbdbd ._faea ,BorderWidth :_fbdbd ._gcef ,Opacity :1.0};
if _fbdbd ._bbad !=nil {_aece .FillEnabled =true ;_cbbe :=_afb (_fbdbd ._bbad );_dfgg :=_edcb (_gcbg ,_cbbe ,_fbdbd ._bbad ,func ()Rectangle {return Rectangle {_dbgeg :_aece .X ,_gead :_aece .Y ,_bccac :_aece .Width ,_begbb :_aece .Height };});if _dfgg !=nil {return nil ,ctx ,_dfgg ;
};_aece .FillColor =_cbbe ;};if _fbdbd ._geef !=nil {_aece .BorderEnabled =false ;if _fbdbd ._gcef > 0{_aece .BorderEnabled =true ;};_aece .BorderColor =_afb (_fbdbd ._geef );_aece .BorderWidth =_fbdbd ._gcef ;};_aegg ,_fcea :=_gcbg .setOpacity (_fbdbd ._gfgd ,_fbdbd ._gdef );
if _fcea !=nil {return nil ,ctx ,_fcea ;};_bcbe ,_ ,_fcea :=_aece .Draw (_aegg );if _fcea !=nil {return nil ,ctx ,_fcea ;};_fcea =_gcbg .addContentsByString (string (_bcbe ));if _fcea !=nil {return nil ,ctx ,_fcea ;};if _fbb {ctx .X =_egeb .X ;ctx .Width =_egeb .Width ;
ctx .Y +=_fbdbd ._faea +_fbdbd ._fbcgf .Bottom ;ctx .Height -=_fbdbd ._faea ;}else {ctx =_egeb ;};_bgaf =append (_bgaf ,_gcbg );return _bgaf ,ctx ,nil ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_gcbga *Image )SetEncoder (encoder _ag .StreamEncoder ){_gcbga ._cegc =encoder };

// MoveY moves the drawing context to absolute position y.
func (_ggf *Creator )MoveY (y float64 ){_ggf ._edg .Y =y };

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _ege .ChartRenderable )*Chart {return _cggd (chart )};

// BuyerAddress returns the buyer address used in the invoice template.
func (_cabb *Invoice )BuyerAddress ()*InvoiceAddress {return _cabb ._ebcgc };

// SetLineHeight sets the line height (1.0 default).
func (_fafe *StyledParagraph )SetLineHeight (lineheight float64 ){_fafe ._gfae =lineheight };

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_geca *TOCLine )SetLevelOffset (levelOffset float64 ){_geca ._dgcg =levelOffset ;_geca ._ffcgc ._acfa .Left =_geca ._gaag +float64 (_geca ._fbgga -1)*_geca ._dgcg ;};

// SetAngle sets the rotation angle of the text.
func (_ddcd *Paragraph )SetAngle (angle float64 ){_ddcd ._fgefg =angle };func _beadb (_bdcgb float64 ,_cacfc int )float64 {_cddaa :=_gb .Pow10 (_cacfc );return _gb .Round (_cddaa *_bdcgb )/_cddaa ;};

// Link returns link information for this line.
func (_faad *TOCLine )Link ()(_fbbee int64 ,_bfab ,_bfdde float64 ){return _faad ._gaecg ,_faad ._dfcfa ,_faad ._gagdf ;};func (_dcbd *pageTransformations )transformBlock (_edbb *Block ){if _dcbd ._dbfd !=nil {_edbb .transform (*_dcbd ._dbfd );};};func (_faac *templateProcessor )parseEllipse (_bcgbg *templateNode )(interface{},error ){_dadd :=_faac .creator .NewEllipse (0,0,0,0);
for _ ,_dfccf :=range _bcgbg ._fabca .Attr {_adgca :=_dfccf .Value ;switch _dbdd :=_dfccf .Name .Local ;_dbdd {case "\u0063\u0078":_dadd ._ddag =_faac .parseFloatAttr (_dbdd ,_adgca );case "\u0063\u0079":_dadd ._gabf =_faac .parseFloatAttr (_dbdd ,_adgca );
case "\u0077\u0069\u0064t\u0068":_dadd .SetWidth (_faac .parseFloatAttr (_dbdd ,_adgca ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_dadd .SetHeight (_faac .parseFloatAttr (_dbdd ,_adgca ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_dadd .SetFillColor (_faac .parseColorAttr (_dbdd ,_adgca ));
case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_dadd .SetFillOpacity (_faac .parseFloatAttr (_dbdd ,_adgca ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_dadd .SetBorderColor (_faac .parseColorAttr (_dbdd ,_adgca ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_dadd .SetBorderOpacity (_faac .parseFloatAttr (_dbdd ,_adgca ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_dadd .SetBorderWidth (_faac .parseFloatAttr (_dbdd ,_adgca ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_dadd .SetPositioning (_faac .parsePositioningAttr (_dbdd ,_adgca ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_dadd .SetFitMode (_faac .parseFitModeAttr (_dbdd ,_adgca ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ecff :=_faac .parseMarginAttr (_dbdd ,_adgca );
_dadd .SetMargins (_ecff .Left ,_ecff .Right ,_ecff .Top ,_ecff .Bottom );default:_faac .nodeLogDebug (_bcgbg ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dbdd );
};};return _dadd ,nil ;};func _agfgb (_decg *templateProcessor ,_fgfff *templateNode )(interface{},error ){return _decg .parseStyledParagraph (_fgfff );};func (_gdfb *StyledParagraph )getMaxLineWidth ()float64 {if _gdfb ._ebgc ==nil ||len (_gdfb ._ebgc )==0{_gdfb .wrapText ();
};var _fefb float64 ;for _ ,_aaebb :=range _gdfb ._ebgc {_dcdb :=_gdfb .getTextLineWidth (_aaebb );if _dcdb > _fefb {_fefb =_dcdb ;};};return _fefb ;};func (_aecc *pageTransformations )transformPage (_gbcc *_db .PdfPage )error {if _deace :=_aecc .applyFlip (_gbcc );
_deace !=nil {return _deace ;};return nil ;};func (_bgcff *Table )sortCells (){_c .Slice (_bgcff ._dgde ,func (_dagc ,_geddf int )bool {_bddf :=_bgcff ._dgde [_dagc ]._adfd ;_agece :=_bgcff ._dgde [_geddf ]._adfd ;if _bddf < _agece {return true ;};if _bddf > _agece {return false ;
};return _bgcff ._dgde [_dagc ]._bcea < _bgcff ._dgde [_geddf ]._bcea ;});};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_dggg :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_d .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dggg ;
};var _adae ,_efea ,_eadf int ;if len (hexStr )==4{var _fad ,_ceff ,_ecad int ;_cdcd ,_bba :=_f .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_fad ,&_ceff ,&_ecad );if _bba !=nil {_d .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_bba );
return _dggg ;};if _cdcd !=3{_d .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dggg ;};_adae =_fad *16+_fad ;_efea =_ceff *16+_ceff ;_eadf =_ecad *16+_ecad ;}else {_ccff ,_gcc :=_f .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_adae ,&_efea ,&_eadf );
if _gcc !=nil {_d .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dggg ;};if _ccff !=3{_d .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_ccff );
return _dggg ;};};_deb :=float64 (_adae )/255.0;_cbd :=float64 (_efea )/255.0;_dagf :=float64 (_eadf )/255.0;_dggg ._dcbf =_deb ;_dggg ._accg =_cbd ;_dggg ._bgcg =_dagf ;return _dggg ;};func (_dgaf *Line )computeCoords (_cfcge DrawContext )(_abaa ,_acdaa ,_ggdbc ,_bdfg float64 ){_abaa =_cfcge .X ;
_ggdbc =_abaa +_dgaf ._aafcb -_dgaf ._bbae ;_cfbe :=_dgaf ._dgfab ;if _dgaf ._bbae ==_dgaf ._aafcb {_cfbe /=2;};if _dgaf ._effb < _dgaf ._affa {_acdaa =_cfcge .PageHeight -_cfcge .Y -_cfbe ;_bdfg =_acdaa -_dgaf ._affa +_dgaf ._effb ;}else {_bdfg =_cfcge .PageHeight -_cfcge .Y -_cfbe ;
_acdaa =_bdfg -_dgaf ._effb +_dgaf ._affa ;};switch _dgaf ._dbged {case FitModeFillWidth :_ggdbc =_abaa +_cfcge .Width ;};return _abaa ,_acdaa ,_ggdbc ,_bdfg ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_cefe *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cefe ._gabgd .Left ,_cefe ._gabgd .Right ,_cefe ._gabgd .Top ,_cefe ._gabgd .Bottom ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_geeff *Table )NewCell ()*TableCell {return _geeff .MultiCell (1,1)};func (_dede *templateProcessor )parseCellAlignmentAttr (_eabd ,_bgead string )CellHorizontalAlignment {_d .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_eabd ,_bgead );
_dfcf :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_bgead ];return _dfcf ;
};

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_cgbe *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _cdddd (x ,y ,width ,height );};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_cccfc *TOC )SetLineSeparatorStyle (style TextStyle ){_cccfc ._eddb =style };

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _bdcb (color ,point )};

// Padding returns the padding of the component.
func (_gcdg *Division )Padding ()(_gcccc ,_efeda ,_gaee ,_dbabd float64 ){return _gcdg ._cedd .Left ,_gcdg ._cedd .Right ,_gcdg ._cedd .Top ,_gcdg ._cedd .Bottom ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_gbcb *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_cdbca :=&_gbcb ._cadb ;_cdbca .Left =left ;_cdbca .Right =right ;_cdbca .Top =top ;_cdbca .Bottom =bottom ;};func (_bcd *Creator )setActivePage (_feb *_db .PdfPage ){_bcd ._gge =_feb };


// NewDivision returns a new Division container component.
func (_bdgg *Creator )NewDivision ()*Division {return _dgfa ()};func _aeaae (_feabb *_bg .Decoder )(int ,int ){return 0,0};func (_eaacc *TOCLine )getLineLink ()*_db .PdfAnnotation {if _eaacc ._gaecg <=0{return nil ;};return _ecead (_eaacc ._gaecg -1,_eaacc ._dfcfa ,_eaacc ._gagdf ,0);
};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_cgad *Creator )EnableFontSubsetting (font *_db .PdfFont ){_cgad ._ccbg =append (_cgad ._ccbg ,font );};

// Height returns the Block's height.
func (_ebd *Block )Height ()float64 {return _ebd ._ef };

// Width returns the current page width.
func (_fbcg *Creator )Width ()float64 {return _fbcg ._gcac };

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// SetFillOpacity sets the fill opacity of the rectangle.
func (_bfbc *Rectangle )SetFillOpacity (opacity float64 ){_bfbc ._dgab =opacity };func (_gbef *Chapter )headingNumber ()string {var _cbad string ;if _gbef ._dggd {if _gbef ._edee !=0{_cbad =_eg .Itoa (_gbef ._edee )+"\u002e";};if _gbef ._cdff !=nil {_aee :=_gbef ._cdff .headingNumber ();
if _aee !=""{_cbad =_aee +_cbad ;};};};return _cbad ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_dcada *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_febbe :=&_dcada ._ffcgc ._acfa ;return _dcada ._gaag ,_febbe .Right ,_febbe .Top ,_febbe .Bottom ;};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// NewCell returns a new invoice table cell.
func (_baef *Invoice )NewCell (value string )*InvoiceCell {return _baef .newCell (value ,_baef .NewCellProps ());};func _afb (_fffb Color )_db .PdfColor {if _fffb ==nil {_fffb =ColorBlack ;};switch _defb :=_fffb .(type ){case grayColor :return _db .NewPdfColorDeviceGray (_defb ._fffc );
case cmykColor :return _db .NewPdfColorDeviceCMYK (_defb ._afc ,_defb ._dff ,_defb ._edea ,_defb ._cec );case *LinearShading :return _db .NewPdfColorPatternType2 ();case *RadialShading :return _db .NewPdfColorPatternType3 ();};return _db .NewPdfColorDeviceRGB (_fffb .ToRGB ());
};

// SetLogo sets the logo of the invoice.
func (_ccca *Invoice )SetLogo (logo *Image ){_ccca ._ggff =logo };

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_daegc *TOC )SetLinePageStyle (style TextStyle ){_daegc ._fafd =style };

// SetText sets the text content of the Paragraph.
func (_dggae *Paragraph )SetText (text string ){_dggae ._cdaf =text };