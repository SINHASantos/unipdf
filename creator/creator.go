//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
package creator ;import (_gc "bytes";_b "encoding/xml";_ga "errors";_a "fmt";_bb "github.com/gorilla/i18n/linebreak";_de "github.com/unidoc/unichart/render";_dc "github.com/unidoc/unipdf/v4/common";_ca "github.com/unidoc/unipdf/v4/contentstream";_fg "github.com/unidoc/unipdf/v4/contentstream/draw";
_bc "github.com/unidoc/unipdf/v4/core";_ff "github.com/unidoc/unipdf/v4/internal/graphic2d";_ec "github.com/unidoc/unipdf/v4/internal/integrations/unichart";_cf "github.com/unidoc/unipdf/v4/internal/license";_aac "github.com/unidoc/unipdf/v4/internal/precision";
_aae "github.com/unidoc/unipdf/v4/internal/transform";_cd "github.com/unidoc/unipdf/v4/model";_ce "golang.org/x/net/html/charset";_gag "golang.org/x/text/unicode/bidi";_eg "image";_ea "io";_c "log";_fb "math";_be "os";_g "path/filepath";_gf "regexp";_da "sort";
_ge "strconv";_gb "strings";_aa "text/template";_f "unicode";_d "unicode/utf8";);

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_eafg *Chapter )SetIncludeInTOC (includeInTOC bool ){_eafg ._eefa =includeInTOC };func (_ebfff *Rectangle )applyFitMode (_gdde float64 ){_gdde -=_ebfff ._egecg .Left +_ebfff ._egecg .Right +_ebfff ._dedg ;switch _ebfff ._agabc {case FitModeFillWidth :_ebfff .ScaleToWidth (_gdde );
};};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_aabfg *Rectangle )Height ()float64 {return _aabfg ._dbab };

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_aaabb float64 ;_adebb float64 ;_dcdaf float64 ;_dbab float64 ;_dgcaf Positioning ;_cgfc Color ;_ddeaec float64 ;_gccag Color ;_dedg float64 ;_gafg float64 ;_fegba float64 ;_gaabc float64 ;_fdccg float64 ;_ccgf float64 ;_egecg Margins ;
_agabc FitMode ;_gfdac *int64 ;};func _bagc (_aceb TextStyle )*List {return &List {_fbfg :TextChunk {Text :"\u2022\u0020",Style :_aceb },_acag :0,_fdeafc :true ,_faab :PositionRelative ,_adcc :_aceb };};func _dfded (_ggbeg *_cd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_ggbeg ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_fcae *shading )SetExtends (start bool ,end bool ){_fcae ._ggefc =[]bool {start ,end }};

// SetWidth sets the width of the ellipse.
func (_face *Ellipse )SetWidth (width float64 ){_face ._gca =width };

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_accf []_fg .CubicBezierCurve ;FillEnabled bool ;_aade Color ;BorderEnabled bool ;BorderWidth float64 ;_dfeeb Color ;_bcbgc *int64 ;};func _bfeb (_gccg _eg .Image )(*Image ,error ){_deag ,_gbcad :=_cd .ImageHandling .NewImageFromGoImage (_gccg );
if _gbcad !=nil {return nil ,_gbcad ;};return _ebgc (_deag );};

// ClearAnnotations clears any existing annotations.
func (_cdfgd *TextChunk )ClearAnnotations (){_cdfgd ._ccbfe =[]*_cd .PdfAnnotation {}};func _ebgc (_dgcc *_cd .Image )(*Image ,error ){_eeea :=float64 (_dgcc .Width );_edddc :=float64 (_dgcc .Height );return &Image {_fbca :_dgcc ,_cddf :_eeea ,_agddd :_edddc ,_gagbb :_eeea ,_cbgg :_edddc ,_adca :0,_fceb :1.0,_fabb :PositionRelative },nil ;
};func (_adfg *commands )isCommand (_cfgeg string )bool {for _ ,_cdcg :=range _adfg ._gcdge {if _gb .ToLower (_cfgeg )==_cdcg {return true ;};};return false ;};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_efaab *List )Width ()float64 {return 0};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_cgbef *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _cgbef ._cdfa ,_cgbef ._eadda ,_cgbef ._fgeg ,_cgbef ._becde ;};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_egge *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _egge ._adbf .Left ,_egge ._adbf .Right ,_egge ._adbf .Top ,_egge ._adbf .Bottom ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_affcb rune ;_caab []error ;};func (_bfda *StyledParagraph )getLineMetrics (_gcffc int )(_bcga ,_gbddd ,_cdbce float64 ){if _bfda ._aeca ==nil ||(_bfda ._aeca !=nil &&len (_bfda ._aeca )==0){_bfda .wrapText ();};if _gcffc < 0||_gcffc > len (_bfda ._aeca )-1{_dc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_gcffc );
return 0,0,0;};_efgbca :=_bfda ._aeca [_gcffc ];for _ ,_fdbcb :=range _efgbca {_baea :=_dfgf (_fdbcb .Style .Font ,_fdbcb .Style .FontSize );if _baea ._faafd > _bcga {_bcga =_baea ._faafd ;};if _baea ._fdfbeg < _cdbce {_cdbce =_baea ._fdfbeg ;};if _dfbb :=_fdbcb .Style .FontSize ;
_dfbb > _gbddd {_gbddd =_dfbb ;};};return _bcga ,_gbddd ,_cdbce ;};var (_bfe =[]string {"\u0063\u006d","\u006d\u006d","\u0070\u0078","\u0070\u0074"};_eagfb =map[string ]float64 {"\u0063\u006d":_egfa ,"\u006d\u006d":_fcdg ,"\u0070\u0078":_ddb ,"\u0070\u0074":1};
);func _edaeca (_daaf ...interface{})(map[string ]interface{},error ){_egad :=len (_daaf );if _egad %2!=0{_dc .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_egad );
return nil ,_bc .ErrRangeError ;};_eadge :=map[string ]interface{}{};for _fegfa :=0;_fegfa < _egad ;_fegfa +=2{_acfeb ,_cfgb :=_daaf [_fegfa ].(string );if !_cfgb {_dc .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_daaf [_fegfa ]);
return nil ,_bc .ErrTypeError ;};_eadge [_acfeb ]=_daaf [_fegfa +1];};return _eadge ,nil ;};func (_ggbab *templateProcessor )parseRadialGradientAttr (creator *Creator ,_bebff string )Color {_fcegg :=ColorBlack ;if _bebff ==""{return _fcegg ;};var (_bgbf error ;
_cegafd =0.0;_gfdcg =0.0;_cafbe =-1.0;_eaaf =_gb .Split (_bebff [16:len (_bebff )-1],"\u002c"););_gcgfe :=_gb .Fields (_eaaf [0]);if len (_gcgfe )==2&&_gb .TrimSpace (_gcgfe [0])[0]!='#'{_cegafd ,_bgbf =_ge .ParseFloat (_gcgfe [0],64);if _bgbf !=nil {_dc .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_bgbf );
};_gfdcg ,_bgbf =_ge .ParseFloat (_gcgfe [1],64);if _bgbf !=nil {_dc .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_bgbf );
};_eaaf =_eaaf [1:];};_acceea :=_gb .TrimSpace (_eaaf [0]);if _acceea [0]!='#'{_cafbe ,_bgbf =_ge .ParseFloat (_acceea ,64);if _bgbf !=nil {_dc .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_bgbf );
};_eaaf =_eaaf [1:];};_aacec ,_cdeea :=_ggbab .processGradientColorPair (_eaaf );if _aacec ==nil ||_cdeea ==nil {return _fcegg ;};_bddbe :=creator .NewRadialGradientColor (_cegafd ,_gfdcg ,0,_cafbe ,[]*ColorPoint {});for _cdca :=0;_cdca < len (_aacec );
_cdca ++{_bddbe .AddColorStop (_aacec [_cdca ],_cdeea [_cdca ]);};return _bddbe ;};

// SetBorderColor sets the border color.
func (_efac *PolyBezierCurve )SetBorderColor (color Color ){_efac ._begb .BorderColor =_dfd (color )};

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_bef *Ellipse )GetCoords ()(float64 ,float64 ){return _bef ._agdd ,_bef ._eebb };

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_fbge *Creator )Flip (flipH ,flipV bool )error {_aedc :=_fbge .getActivePage ();if _aedc ==nil {return _ga .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_ggeae ,_aggd :=_fbge ._dfge [_aedc ];if !_aggd {_ggeae =&pageTransformations {};
_fbge ._dfge [_aedc ]=_ggeae ;};_ggeae ._cecd =flipH ;_ggeae ._ddad =flipV ;return nil ;};

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_bfbc *GraphicSVG )Scale (xFactor ,yFactor float64 ){_bfbc ._dbgf .Width =xFactor *_bfbc ._dbgf .Width ;_bfbc ._dbgf .Height =yFactor *_bfbc ._dbgf .Height ;_bfbc ._dbgf .SetScaling (xFactor ,yFactor );};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_cbfdg *Paragraph )SetTextAlignment (align TextAlignment ){_cbfdg ._aaagb =align };

// SetBackgroundColor sets the cell's background color.
func (_fddfc *TableCell )SetBackgroundColor (col Color ){_fddfc ._geggd =col };

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fgae *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _fgae ._aecde [0],_fgae ._aecde [1]};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_fedfb *shading )SetBackgroundColor (backgroundColor Color ){_fedfb ._bcagg =backgroundColor };

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_eeefc *Table )MultiColCell (colspan int )*TableCell {return _eeefc .MultiCell (1,colspan )};func (_fe *Block )drawToPage (_gdbg *_cd .PdfPage )error {_edg :=&_ca .ContentStreamOperations {};if _gdbg .Resources ==nil {_gdbg .Resources =_cd .NewPdfPageResources ();
};_ced :=_efb (_edg ,_gdbg .Resources ,_fe ._df ,_fe ._bcb );if _ced !=nil {return _ced ;};if _ced =_fgb (_fe ._bcb ,_gdbg .Resources );_ced !=nil {return _ced ;};if _ced =_gdbg .AppendContentBytes (_edg .Bytes (),true );_ced !=nil {return _ced ;};for _ ,_aeb :=range _fe ._dfcc {_gdbg .AddAnnotation (_aeb );
};return nil ;};func (_fcbg grayColor )ToRGB ()(float64 ,float64 ,float64 ){return _fcbg ._bbe ,_fcbg ._bbe ,_fcbg ._bbe };type token struct{_fcag string ;_defg bool ;};type templateNode struct{_bedgb interface{};_egac _b .StartElement ;_fafg *templateNode ;
_fbba int ;_fbfgd int ;_fecbge int64 ;};

// Lines returns all the rows of the invoice line items table.
func (_cccbb *Invoice )Lines ()[][]*InvoiceCell {return _cccbb ._adcac };

// Height returns Image's document height.
func (_ebbg *Image )Height ()float64 {return _ebbg ._cbgg };

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_efbgb *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _efbgb ._ebbed .Left ,_efbgb ._ebbed .Right ,_efbgb ._ebbed .Top ,_efbgb ._ebbed .Bottom ;};func _cagdb (_dfedb string ,_ebgga int )(float64 ,error ){_dafa ,_fffc :=_bfgd (_dfedb );
_ecac ,_faedd :=_ge .ParseFloat (_dafa ,_ebgga );if _faedd !=nil {return 0,_faedd ;};if _baeab ,_begfd :=_eagfb [_fffc ];_begfd {_ecac =_ecac *_baeab ;}else {_ecac =_ecac *_ddb ;};return _ecac ,nil ;};func (_agcb *Invoice )generateInformationBlocks (_fcbe DrawContext )([]*Block ,DrawContext ,error ){_gecag :=_eeff (_agcb ._fdeaf );
_gecag .SetMargins (0,0,0,20);_cdfe :=_agcb .drawAddress (_agcb ._egaec );_cdfe =append (_cdfe ,_gecag );_cdfe =append (_cdfe ,_agcb .drawAddress (_agcb ._cdceb )...);_cdbcd :=_acdf ();for _ ,_baagc :=range _cdfe {_cdbcd .Add (_baagc );};_dgdc :=_agcb .drawInformation ();
_dagde :=_bbab (2);_dagde .SetMargins (0,0,25,0);_abccb :=_dagde .NewCell ();_abccb .SetIndent (0);_abccb .SetContent (_cdbcd );_abccb =_dagde .NewCell ();_abccb .SetContent (_dgdc );return _dagde .GeneratePageBlocks (_fcbe );};

// Cols returns the total number of columns the table has.
func (_bffga *Table )Cols ()int {return _bffga ._gfgc };

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_aedg *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_aedg ._adbcd =textOverflow };func _egefa (_agfc []*ColorPoint )*LinearShading {return &LinearShading {_eadf :&shading {_bcagg :ColorWhite ,_gecagb :false ,_ggefc :[]bool {false ,false },_gacbe :_agfc },_adad :&_cd .PdfRectangle {}};
};

// GridCell defines a cell which can contain a Drawable as content.
type GridCell struct{_gcgc Color ;_dede float64 ;_aabb _fg .LineStyle ;_ffbe CellBorderStyle ;_cbac Color ;_ccfg float64 ;_dffc CellBorderStyle ;_faebf Color ;_cgbed float64 ;_agfbe CellBorderStyle ;_cdfcb Color ;_caadb float64 ;_adeb CellBorderStyle ;
_ddda Color ;_cbec float64 ;_feac VectorDrawable ;_ccaa ,_degg int ;_adggg int ;_fefb int ;_edbg CellHorizontalAlignment ;_cfgf CellVerticalAlignment ;_cbfg float64 ;};

// SetTitle sets the title of the invoice.
func (_cfcag *Invoice )SetTitle (title string ){_cfcag ._dffb =title };const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);type templateProcessor struct{creator *Creator ;_fdbfe []byte ;_cebde *TemplateOptions ;
_fgbad componentRenderer ;_fefbg string ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_gcga *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_afgg :=uint (len (_gcga ._ebafb ));if index > _afgg {index =_afgg ;};_fagaa :=_gcga .NewColumn (description );_gcga ._ebafb =append (_gcga ._ebafb [:index ],append ([]*InvoiceCell {_fagaa },_gcga ._ebafb [index :]...)...);
return _fagaa ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_eecfd *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_gdedf :=&_eecfd ._bebag ._gebac ;return _eecfd ._gecda ,_gdedf .Right ,_gdedf .Top ,_gdedf .Bottom ;};func (_cdge *StyledParagraph )wrapText ()error {return _cdge .wrapChunks (true )};


// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_fgf *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fgf ._fdg .Left ,_fgf ._fdg .Right ,_fgf ._fdg .Top ,_fgf ._fdg .Bottom ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_bbbdc *Creator )DrawTemplate (r _ea .Reader ,data interface{},options *TemplateOptions )error {return _acdb (_bbbdc ,r ,data ,options ,_bbbdc );};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_gedac *TableCell )SetBorderLineStyle (style _fg .LineStyle ){_gedac ._dacd =style };func (_bdff *Creator )newPage ()*_cd .PdfPage {_eccb :=_cd .NewPdfPage ();_feg :=_bdff ._gee [0];_gfe :=_bdff ._gee [1];_ggf :=_cd .PdfRectangle {Llx :0,Lly :0,Urx :_feg ,Ury :_gfe };
_eccb .MediaBox =&_ggf ;_bdff ._gdac =_feg ;_bdff ._gdce =_gfe ;_bdff .initContext ();return _eccb ;};

// WriteToFile writes the Creator output to file specified by path.
func (_efda *Creator )WriteToFile (outputPath string )error {_fcdgc ,_dcff :=_be .Create (outputPath );if _dcff !=nil {return _dcff ;};defer _fcdgc .Close ();return _efda .Write (_fcdgc );};

// NewImage create a new image from a unidoc image (model.Image).
func (_adcb *Creator )NewImage (img *_cd .Image )(*Image ,error ){return _ebgc (img )};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_cd .PdfPage )(*Block ,error ){_ee :=&Block {};_eb ,_ag :=page .GetAllContentStreams ();if _ag !=nil {return nil ,_ag ;};_af :=_ca .NewContentStreamParser (_eb );_fd ,_ag :=_af .Parse ();if _ag !=nil {return nil ,_ag ;};_fd .WrapIfNeeded ();
_ee ._df =_fd ;if page .Resources !=nil {_ee ._bcb =page .Resources ;}else {_ee ._bcb =_cd .NewPdfPageResources ();};_ded ,_ag :=page .GetMediaBox ();if _ag !=nil {return nil ,_ag ;};if _ded .Llx !=0||_ded .Lly !=0{_ee .translate (-_ded .Llx ,_ded .Lly );
};_ee ._cef =_ded .Urx -_ded .Llx ;_ee ._dff =_ded .Ury -_ded .Lly ;if page .Rotate !=nil {_ee ._ecg =-float64 (*page .Rotate );};return _ee ,nil ;};

// Subpath is a collection of Commands, beginning with moveto command and
// usually ending with closepath command.
type Subpath struct{Commands []*Command ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_dffb string ;_deegg *Image ;_cdceb *InvoiceAddress ;_egaec *InvoiceAddress ;_bbgd string ;_bedb [2]*InvoiceCell ;_aecde [2]*InvoiceCell ;_fgcd [2]*InvoiceCell ;_abggd [][2]*InvoiceCell ;_ebafb []*InvoiceCell ;_adcac [][]*InvoiceCell ;
_adfbe [2]*InvoiceCell ;_ccaef [2]*InvoiceCell ;_aeda [][2]*InvoiceCell ;_efec [2]string ;_agagf [2]string ;_edad [][2]string ;_fdeaf TextStyle ;_ecaf TextStyle ;_ggbef TextStyle ;_daacd TextStyle ;_cefda TextStyle ;_cac TextStyle ;_cgbb TextStyle ;_feef InvoiceCellProps ;
_caeaa InvoiceCellProps ;_dcfg InvoiceCellProps ;_afaa InvoiceCellProps ;_eagb Positioning ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_ae *Block )SetMargins (left ,right ,top ,bottom float64 ){_ae ._dfc .Left =left ;_ae ._dfc .Right =right ;_ae ._dfc .Top =top ;_ae ._dfc .Bottom =bottom ;};func (_abcc *GraphicSVGElement )getGradientAngle ()float64 {_aabf ,_acbb :=_abcc .Attributes ["\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0054\u0072\u0061\u006es\u0066\u006f\u0072\u006d"];
if _acbb {_ggfdg :=_gb .Fields (_aabf );for _ ,_ffca :=range _ggfdg {_cagce :=_gb .FieldsFunc (_ffca ,_cccab );if len (_cagce )< 2{continue ;};if _cagce [0]=="\u0072\u006f\u0074\u0061\u0074\u0065"{_gbge ,_acca :=_cbdad (_cagce [1]);if _acca !=nil {_dc .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_aabf );
return 0.0;};return _gbge ;};};};return 0.0;};func (_ebdf *Grid )cloneRow (_ffdc int )*GridRow {_bgfd :=&GridRow {_facac :_ebdf ._ggca ,_gaab :_ffdc +1,_abf :_ebdf };for _ ,_ecdg :=range _ebdf ._dgaa [_ffdc ]._ebec {_fadf ,_ :=_bgfd .NewMultiCell (_ecdg ._fefb ,1);
if _fadf !=nil {_fadf ._gcgc =_ecdg ._gcgc ;_fadf ._faebf =_ecdg ._faebf ;_fadf ._cbac =_ecdg ._cbac ;_fadf ._cdfcb =_ecdg ._cdfcb ;_fadf ._ddda =_ecdg ._ddda ;_fadf ._aabb =_ecdg ._aabb ;_fadf ._dffc =_ecdg ._dffc ;_fadf ._ffbe =_ecdg ._ffbe ;_fadf ._agfbe =_ecdg ._agfbe ;
_fadf ._adeb =_ecdg ._adeb ;_fadf ._cgbed =_ecdg ._cgbed ;_fadf ._ccfg =_ecdg ._ccfg ;_fadf ._caadb =_ecdg ._caadb ;_fadf ._cbec =_ecdg ._cbec ;_fadf ._degg =_ecdg ._degg ;_fadf ._edbg =_ecdg ._edbg ;_fadf ._cbfg =_ecdg ._cbfg ;_fadf ._dede =_ecdg ._dede ;
_fadf ._ccaa =_ffdc +1;_fadf ._cfgf =_ecdg ._cfgf ;};};return _bgfd ;};func _dfd (_adaf Color )_cd .PdfColor {if _adaf ==nil {_adaf =ColorBlack ;};switch _bdbd :=_adaf .(type ){case grayColor :return _cd .NewPdfColorDeviceGray (_bdbd ._bbe );case cmykColor :return _cd .NewPdfColorDeviceCMYK (_bdbd ._fdcca ,_bdbd ._aaac ,_bdbd ._fcda ,_bdbd ._cce );
case *LinearShading :return _cd .NewPdfColorPatternType2 ();case *RadialShading :return _cd .NewPdfColorPatternType3 ();};return _cd .NewPdfColorDeviceRGB (_adaf .ToRGB ());};

// NewSubchapter creates a new child chapter with the specified title.
func (_bccfd *Chapter )NewSubchapter (title string )*Chapter {_afec :=_dfded (_bccfd ._cgcg ._gceca [0].Style .Font );_afec .FontSize =14;_bccfd ._bce ++;_bdfe :=_dagc (_bccfd ,_bccfd ._cag ,_bccfd ._fad ,title ,_bccfd ._bce ,_afec );_bccfd .Add (_bdfe );
return _bdfe ;};func (_dcedd *GraphicSVGElement )drawPolygon (_faabga *_ca .ContentCreator ,_acfdg *_cd .PdfPageResources ){_faabga .Add_q ();_dcedd .Style .toContentStream (_faabga ,_acfdg ,_dcedd );_fcebe ,_efdf :=_cgbeg (_dcedd .Attributes ["\u0070\u006f\u0069\u006e\u0074\u0073"]);
if _efdf !=nil {_dc .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0025\u0076",_efdf );
return ;};if len (_fcebe )%2> 0{_dc .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0069n\u0076\u0061l\u0069\u0064\u0020\u0070\u006f\u0069\u006e\u0074s\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006ce\u006e\u0067\u0074\u0068");return ;
};for _cgda :=0;_cgda < len (_fcebe );{if _cgda ==0{_faabga .Add_m (_fcebe [_cgda ]*_dcedd ._ddccg ,_fcebe [_cgda +1]*_dcedd ._ddccg );}else {_faabga .Add_l (_fcebe [_cgda ]*_dcedd ._ddccg ,_fcebe [_cgda +1]*_dcedd ._ddccg );};_cgda +=2;};_faabga .Add_l (_fcebe [0]*_dcedd ._ddccg ,_fcebe [1]*_dcedd ._ddccg );
_dcedd .Style .fillStroke (_faabga );_faabga .Add_h ();_faabga .Add_Q ();};func _fgfec (_gacdb *_cd .PdfRectangle ,_dfae _aae .Matrix )*_cd .PdfRectangle {var _cfffg _cd .PdfRectangle ;_cfffg .Llx ,_cfffg .Lly =_dfae .Transform (_gacdb .Llx ,_gacdb .Lly );
_cfffg .Urx ,_cfffg .Ury =_dfae .Transform (_gacdb .Urx ,_gacdb .Ury );_cfffg .Normalize ();return &_cfffg ;};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_dacb *RadialShading )AddShadingResource (block *Block )(_fdce _bc .PdfObjectName ,_ceca error ){_ggcad :=1;_fdce =_bc .PdfObjectName ("\u0053\u0068"+_ge .Itoa (_ggcad ));for block ._bcb .HasShadingByName (_fdce ){_ggcad ++;_fdce =_bc .PdfObjectName ("\u0053\u0068"+_ge .Itoa (_ggcad ));
};if _gbffe :=block ._bcb .SetShadingByName (_fdce ,_dacb .shadingModel ().ToPdfObject ());_gbffe !=nil {return "",_gbffe ;};return _fdce ,nil ;};

// SetBorderColor sets the border color for the path.
func (_gbbed *FilledCurve )SetBorderColor (color Color ){_gbbed ._dfeeb =color };

// SetBorderOpacity sets the border opacity.
func (_gcfd *CurvePolygon )SetBorderOpacity (opacity float64 ){_gcfd ._ccb =opacity };

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_edd *Creator )SetPageLabels (pageLabels _bc .PdfObject ){_edd ._aaga =pageLabels };func _baag (_ede *GraphicSVGElement )(*GraphicSVG ,error ){return &GraphicSVG {_dbgf :_ede ,_bffac :PositionRelative ,_ddddf :Margins {Top :10,Bottom :10}},nil ;};


// NewChapter creates a new chapter with the specified title as the heading.
func (_eafa *Creator )NewChapter (title string )*Chapter {_eafa ._becg ++;_begaf :=_eafa .NewTextStyle ();_begaf .FontSize =16;return _dagc (nil ,_eafa ._bga ,_eafa ._daba ,title ,_eafa ._becg ,_begaf );};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline ,_ccbfe :[]*_cd .PdfAnnotation {},_feea :[]bool {}};};

// SetPos sets the grid positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the grid does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_edfb *Grid )SetPos (x ,y float64 ){_edfb ._eddd =PositionAbsolute ;_edfb ._aecd =x ;_edfb ._ccacd =y ;};func _daeg (_dcfc *Block ,_fcdga _cd .PdfColor ,_ebdec Color ,_agcgf func ()Rectangle )error {switch _dcad :=_fcdga .(type ){case *_cd .PdfColorPatternType2 :_bggba ,_dfdga :=_ebdec .(*LinearShading );
if !_dfdga {return _a .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_baeb :=_agcgf ();_bggba .SetBoundingBox (_baeb ._aaabb ,_baeb ._adebb ,_baeb ._dcdaf ,_baeb ._dbab );
_cecb ,_fbdeg :=_bggba .AddPatternResource (_dcfc );if _fbdeg !=nil {return _a .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_fbdeg );
};_dcad .PatternName =_cecb ;case *_cd .PdfColorPatternType3 :_dcgc ,_gfdfe :=_ebdec .(*RadialShading );if !_gfdfe {return _a .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_dcccg :=_agcgf ();_dcgc .SetBoundingBox (_dcccg ._aaabb ,_dcccg ._adebb ,_dcccg ._dcdaf ,_dcccg ._dbab );_feeb ,_dedbe :=_dcgc .AddPatternResource (_dcfc );if _dedbe !=nil {return _a .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_dedbe );
};_dcad .PatternName =_feeb ;};return nil ;};func (_afaeb *Subpath )compare (_geded *Subpath )bool {if len (_afaeb .Commands )!=len (_geded .Commands ){return false ;};for _eeaa ,_bagd :=range _afaeb .Commands {if !_bagd .compare (_geded .Commands [_eeaa ]){return false ;
};};return true ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_fecd *Image )SetEncoder (encoder _bc .StreamEncoder ){_fecd ._baed =encoder };

// Angle returns the block rotation angle in degrees.
func (_egg *Block )Angle ()float64 {return _egg ._ecg };

// SetBorderWidth sets the border width of the ellipse.
func (_aacfg *Ellipse )SetBorderWidth (bw float64 ){_aacfg ._bfd =bw };func (_fcefa *Grid )insertRowAfter (_dfdf int ,_gagbd *GridRow ){_fcefa ._dgaa =append (_fcefa ._dgaa ,&GridRow {});copy (_fcefa ._dgaa [_dfdf +2:],_fcefa ._dgaa [_dfdf +1:]);_fcefa ._dgaa [_dfdf +1]=_gagbd ;
for _adfb ,_dfff :=range _fcefa ._dgaa {if _adfb > _dfdf +1{_dfff ._gaab +=1;for _ ,_abead :=range _dfff ._ebec {_abead ._ccaa +=1;};};};};func _gacgb (_gcbg ,_ebca ,_edf ,_fed float64 )*border {_cedf :=&border {};_cedf ._eea =_gcbg ;_cedf ._gbcc =_ebca ;
_cedf ._bbg =_edf ;_cedf ._ebd =_fed ;_cedf ._aef =ColorBlack ;_cedf ._bgeg =ColorBlack ;_cedf ._aad =ColorBlack ;_cedf ._fbdc =ColorBlack ;_cedf ._addc =0;_cedf ._cbc =0;_cedf ._bebc =0;_cedf ._egb =0;_cedf ._gbca =1.0;_cedf .LineStyle =_fg .LineStyleSolid ;
return _cedf ;};func (_eae *Block )setOpacity (_gaa float64 ,_dd float64 )(string ,error ){if (_gaa < 0||_gaa >=1.0)&&(_dd < 0||_dd >=1.0){return "",nil ;};_eeb :=0;_ffb :=_a .Sprintf ("\u0047\u0053\u0025\u0064",_eeb );for _eae ._bcb .HasExtGState (_bc .PdfObjectName (_ffb )){_eeb ++;
_ffb =_a .Sprintf ("\u0047\u0053\u0025\u0064",_eeb );};_ffd :=_bc .MakeDict ();if _gaa >=0&&_gaa < 1.0{_ffd .Set ("\u0063\u0061",_bc .MakeFloat (_gaa ));};if _dd >=0&&_dd < 1.0{_ffd .Set ("\u0043\u0041",_bc .MakeFloat (_dd ));};_gba :=_eae ._bcb .AddExtGState (_bc .PdfObjectName (_ffb ),_ffd );
if _gba !=nil {return "",_gba ;};return _ffb ,nil ;};

// SetFillColor sets the fill color.
func (_ededf *PolyBezierCurve )SetFillColor (color Color ){_ededf ._aagbc =color ;_ededf ._begb .FillColor =_dfd (color );};func (_bcdfe *templateProcessor )parseChapter (_ddgc *templateNode )(interface{},error ){_dacg :=_bcdfe .creator .NewChapter ;if _ddgc ._fafg !=nil {if _dgdfc ,_abafd :=_ddgc ._fafg ._bedgb .(*Chapter );
_abafd {_dacg =_dgdfc .NewSubchapter ;};};_gaeb :=_dacg ("");for _ ,_bada :=range _ddgc ._egac .Attr {_bbag :=_bada .Value ;switch _egdeb :=_bada .Name .Local ;_egdeb {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_gaeb .SetShowNumbering (_bcdfe .parseBoolAttr (_egdeb ,_bbag ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_gaeb .SetIncludeInTOC (_bcdfe .parseBoolAttr (_egdeb ,_bbag ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bbea :=_bcdfe .parseMarginAttr (_egdeb ,_bbag );_gaeb .SetMargins (_bbea .Left ,_bbea .Right ,_bbea .Top ,_bbea .Bottom );
default:_bcdfe .nodeLogDebug (_ddgc ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_egdeb );
};};return _gaeb ,nil ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_ccdag *Creator )NewPage ()*_cd .PdfPage {_aebg :=_ccdag .newPage ();_ccdag ._cgb =append (_ccdag ._cgb ,_aebg );_ccdag ._cfce .Page ++;return _aebg ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_dddc *shading )SetAntiAlias (enable bool ){_dddc ._gecagb =enable };func (_bdaed *Invoice )newCell (_fddg string ,_ddag InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_ddag ,_fddg };};

// FillColor returns the fill color of the ellipse.
func (_efaf *Ellipse )FillColor ()Color {return _efaf ._dcdf };

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_affg *LinearShading )AddShadingResource (block *Block )(_dabc _bc .PdfObjectName ,_gdff error ){_abbb :=1;_dabc =_bc .PdfObjectName ("\u0053\u0068"+_ge .Itoa (_abbb ));for block ._bcb .HasShadingByName (_dabc ){_abbb ++;_dabc =_bc .PdfObjectName ("\u0053\u0068"+_ge .Itoa (_abbb ));
};if _bggbd :=block ._bcb .SetShadingByName (_dabc ,_affg .shadingModel ().ToPdfObject ());_bggbd !=nil {return "",_bggbd ;};return _dabc ,nil ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func (_eef *Block )addContentsByString (_gagc string )error {_bd :=_ca .NewContentStreamParser (_gagc );_aacf ,_ceg :=_bd .Parse ();if _ceg !=nil {return _ceg ;};_eef ._df .WrapIfNeeded ();_aacf .WrapIfNeeded ();*_eef ._df =append (*_eef ._df ,*_aacf ...);
return nil ;};var (_bfgg =_gf .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");_egfcf =_ga .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");
_bfcee =_ga .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");_dfced =_ga .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");
_degba =_ga .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e"););

// SetBorderOpacity sets the border opacity of the ellipse.
func (_aagc *Ellipse )SetBorderOpacity (opacity float64 ){_aagc ._daaca =opacity };

// IsRelative checks if the positioning is relative.
func (_bbf Positioning )IsRelative ()bool {return _bbf ==PositionRelative };

// Crop crops the Image to the specified bounds.
func (_acad *Image )Crop (x0 ,y0 ,x1 ,y1 int ){_eedfae ,_aebcb :=_acad ._fbca .ToGoImage ();if _aebcb !=nil {_c .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0074o\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_aebcb );
};var _cfcf _eg .Image ;_gbbgc :=_eg .Rect (x0 ,y0 ,x1 ,y1 );if _dfba :=_gbbgc .Intersect (_eedfae .Bounds ());!_gbbgc .Empty (){_beadd :=_eg .NewRGBA (_eg .Rect (0,0,_gbbgc .Dx (),_gbbgc .Dy ()));for _dgfb :=_dfba .Min .Y ;_dgfb < _dfba .Max .Y ;_dgfb ++{for _ccbg :=_dfba .Min .X ;
_ccbg < _dfba .Max .X ;_ccbg ++{_beadd .Set (_ccbg -_dfba .Min .X ,_dgfb -_dfba .Min .Y ,_eedfae .At (_ccbg ,_dgfb ));};};_cfcf =_beadd ;}else {_cfcf =&_eg .RGBA {};};_fgec ,_aebcb :=_cd .ImageHandling .NewImageFromGoImage (_cfcf );if _aebcb !=nil {_c .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0066\u0072\u006fm\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_aebcb );
};_gggf :=float64 (_fgec .Width );_baff :=float64 (_fgec .Height );_acad ._fbca =_fgec ;_acad ._cddf =_gggf ;_acad ._agddd =_baff ;_acad ._gagbb =_gggf ;_acad ._cbgg =_baff ;};func (_aacg *FilledCurve )draw (_dafg *Block ,_efafg string )([]byte ,*_cd .PdfRectangle ,error ){_dgc :=_fg .NewCubicBezierPath ();
for _ ,_fdb :=range _aacg ._accf {_dgc =_dgc .AppendCurve (_fdb );};creator :=_ca .NewContentCreator ();if _aacg ._bcbgc !=nil {creator .Add_BDC (*_bc .MakeName (_cd .StructureTypeFigure ),map[string ]_bc .PdfObject {"\u004d\u0043\u0049\u0044":_bc .MakeInteger (*_aacg ._bcbgc )});
};creator .Add_q ();if _aacg .FillEnabled &&_aacg ._aade !=nil {_bebd :=_dfd (_aacg ._aade );_gfc :=_daeg (_dafg ,_bebd ,_aacg ._aade ,func ()Rectangle {_gafae :=_fg .NewCubicBezierPath ();for _ ,_fafe :=range _aacg ._accf {_gafae =_gafae .AppendCurve (_fafe );
};_gaea :=_gafae .GetBoundingBox ();if _aacg .BorderEnabled {_gaea .Height +=_aacg .BorderWidth ;_gaea .Width +=_aacg .BorderWidth ;_gaea .X -=_aacg .BorderWidth /2;_gaea .Y -=_aacg .BorderWidth /2;};return Rectangle {_aaabb :_gaea .X ,_adebb :_gaea .Y ,_dcdaf :_gaea .Width ,_dbab :_gaea .Height };
});if _gfc !=nil {return nil ,nil ,_gfc ;};creator .SetNonStrokingColor (_bebd );};if _aacg .BorderEnabled {if _aacg ._dfeeb !=nil {creator .SetStrokingColor (_dfd (_aacg ._dfeeb ));};creator .Add_w (_aacg .BorderWidth );};if len (_efafg )> 1{creator .Add_gs (_bc .PdfObjectName (_efafg ));
};_fg .DrawBezierPathWithCreator (_dgc ,creator );creator .Add_h ();if _aacg .FillEnabled &&_aacg .BorderEnabled {creator .Add_B ();}else if _aacg .FillEnabled {creator .Add_f ();}else if _aacg .BorderEnabled {creator .Add_S ();};creator .Add_Q ();if _aacg ._bcbgc !=nil {creator .Add_EMC ();
};_aegf :=_dgc .GetBoundingBox ();if _aacg .BorderEnabled {_aegf .Height +=_aacg .BorderWidth ;_aegf .Width +=_aacg .BorderWidth ;_aegf .X -=_aacg .BorderWidth /2;_aegf .Y -=_aacg .BorderWidth /2;};_gbbff :=&_cd .PdfRectangle {};_gbbff .Llx =_aegf .X ;
_gbbff .Lly =_aegf .Y ;_gbbff .Urx =_aegf .X +_aegf .Width ;_gbbff .Ury =_aegf .Y +_aegf .Height ;return creator .Bytes (),_gbbff ,nil ;};

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_fbbce *Ellipse )FillOpacity ()float64 {return _fbbce ._cece };func (_beeae *templateProcessor )parseStyledParagraph (_bbaa *templateNode )(interface{},error ){_eeace :=_beeae .creator .NewStyledParagraph ();for _ ,_afbab :=range _bbaa ._egac .Attr {_gfaad :=_afbab .Value ;
switch _dfaff :=_afbab .Name .Local ;_dfaff {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_eeace .SetTextAlignment (_beeae .parseTextAlignmentAttr (_dfaff ,_gfaad ));case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_eeace .SetTextVerticalAlignment (_beeae .parseTextVerticalAlignmentAttr (_dfaff ,_gfaad ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_eeace .SetLineHeight (_beeae .parseFloatAttr (_dfaff ,_gfaad ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cabgg :=_beeae .parseMarginAttr (_dfaff ,_gfaad );_eeace .SetMargins (_cabgg .Left ,_cabgg .Right ,_cabgg .Top ,_cabgg .Bottom );
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_eeace .SetEnableWrap (_beeae .parseBoolAttr (_dfaff ,_gfaad ));case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_eeace .EnableWordWrap (_beeae .parseBoolAttr (_dfaff ,_gfaad ));
case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_eeace .SetTextOverflow (_beeae .parseTextOverflowAttr (_dfaff ,_gfaad ));case "\u0078":_eeace .SetPos (_beeae .parseFloatAttr (_dfaff ,_gfaad ),_eeace ._ebffa );case "\u0079":_eeace .SetPos (_eeace ._fcgdfe ,_beeae .parseFloatAttr (_dfaff ,_gfaad ));
case "\u0061\u006e\u0067l\u0065":_eeace .SetAngle (_beeae .parseFloatAttr (_dfaff ,_gfaad ));default:_beeae .nodeLogDebug (_bbaa ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dfaff );
};};return _eeace ,nil ;};

// SetWidthLeft sets border width for left.
func (_fea *border )SetWidthLeft (bw float64 ){_fea ._bebc =bw };

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_ggbc *TOCLine )SetLevelOffset (levelOffset float64 ){_ggbc ._fcegc =levelOffset ;_ggbc ._bebag ._gebac .Left =_ggbc ._gecda +float64 (_ggbc ._bedfe -1)*_ggbc ._fcegc ;};func (_dfeb *Block )mergeBlocks (_eeg *Block )error {_fec :=_efb (_dfeb ._df ,_dfeb ._bcb ,_eeg ._df ,_eeg ._bcb );
if _fec !=nil {return _fec ;};for _ ,_add :=range _eeg ._dfcc {_dfeb .AddAnnotation (_add );};return nil ;};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_dcda *Image )ConvertToBinary ()error {return _dcda ._fbca .ConvertToBinary ()};func (_eaeg *GraphicSVGStyle )fillStroke (_fab *_ca .ContentCreator ){if _eaeg .FillColor !=""&&_eaeg .StrokeColor !=""{_fab .Add_B ();}else if _eaeg .FillColor !=""{_fab .Add_f ();
}else if _eaeg .StrokeColor !=""{_fab .Add_S ();};};

// GridRow defines a row which can contain cells.
type GridRow struct{_ebec []*GridCell ;_facac float64 ;_aeec float64 ;_gaab int ;_abf *Grid ;};func _febc (_cafbc ...interface{})[]interface{}{return _cafbc };

// SetFontSize sets the font size for the paragraph.
func (_fgdd *StyledParagraph )SetFontSize (fontSize float64 ){_fgdd ._fdeab .FontSize =fontSize ;for _ ,_aagbe :=range _fgdd ._gceca {_aagbe .Style .FontSize =fontSize ;};};

// SetMarkedContentID sets the marked content ID.
func (_bafe *PageBreak )SetMarkedContentID (id int64 )*_cd .KDict {return nil };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_fefd *Creator )EnableFontSubsetting (font *_cd .PdfFont ){_fefd ._ggag =append (_fefd ._ggag ,font );};

// RotatedSize returns the width and height of the rotated block.
func (_cbf *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_gcc ,_daeb :=_gaeed (_cbf ._cef ,_cbf ._dff ,_cbf ._ecg );return _gcc ,_daeb ;};

// SetHeight sets the Image's document height to specified h.
func (_dbbbe *Image )SetHeight (h float64 ){_dbbbe ._cbgg =h };

// SetMarkedContentID sets marked content ID.
func (_effc *TOC )SetMarkedContentID (mcid int64 )*_cd .KDict {return nil };

// SetBorderRadius sets the radius of the background corners.
func (_fff *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_fff .BorderRadiusTopLeft =topLeft ;_fff .BorderRadiusTopRight =topRight ;_fff .BorderRadiusBottomLeft =bottomLeft ;_fff .BorderRadiusBottomRight =bottomRight ;
};

// SetInline sets the inline mode of the division.
func (_baca *Division )SetInline (inline bool ){_baca ._ceda =inline };

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_baace *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_baace ._egecg .Left =left ;_baace ._egecg .Right =right ;_baace ._egecg .Top =top ;_baace ._egecg .Bottom =bottom ;};

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_ddfd *Rectangle )ScaleToHeight (h float64 ){_dbce :=_ddfd ._dcdaf /_ddfd ._dbab ;_ddfd ._dbab =h ;_ddfd ._dcdaf =h *_dbce ;};func (_egeg *Table )wrapRow (_faedc int ,_afdc DrawContext ,_fdef float64 )(bool ,error ){if !_egeg ._ccgc {return false ,nil ;
};var (_bbced =_egeg ._bbdb [_faedc ];_ddde =-1;_eaff []*TableCell ;_bgbd float64 ;_bcdag bool ;_cffd =make ([]float64 ,0,len (_egeg ._fbce )););_bcfc :=func (_bdgc *TableCell ,_cbabed VectorDrawable ,_cgfce bool )*TableCell {_cbabc :=*_bdgc ;_cbabc ._fagd =_cbabed ;
if _cgfce {_cbabc ._badcc ++;};return &_cbabc ;};_fgedc :=func (_bfaec int ,_bbdd VectorDrawable ){var _ddcaf float64 =-1;if _bbdd ==nil {if _aagdga :=_cffd [_bfaec -_faedc ];_aagdga > _afdc .Height {_bbdd =_egeg ._bbdb [_bfaec ]._fagd ;_egeg ._bbdb [_bfaec ]._fagd =nil ;
_cffd [_bfaec -_faedc ]=0;_ddcaf =_aagdga ;};};_bggca :=_bcfc (_egeg ._bbdb [_bfaec ],_bbdd ,true );_eaff =append (_eaff ,_bggca );if _ddcaf < 0{_ddcaf =_bggca .height (_afdc .Width );};if _ddcaf > _bgbd {_bgbd =_ddcaf ;};};for _bcaga :=_faedc ;_bcaga < len (_egeg ._bbdb );
_bcaga ++{_bddabe :=_egeg ._bbdb [_bcaga ];if _bbced ._badcc !=_bddabe ._badcc {_ddde =_bcaga ;break ;};_afdc .Width =_bddabe .width (_egeg ._fbce ,_fdef );_eadg :=_bddabe .height (_afdc .Width );var _adafc VectorDrawable ;switch _eeec :=_bddabe ._fagd .(type ){case *StyledParagraph :if _eadg > _afdc .Height {_bfbdg :=_afdc ;
_bfbdg .Height =_fb .Floor (_afdc .Height -_eeec ._gebac .Top -_eeec ._gebac .Bottom -0.5*_eeec .getTextHeight ());_facda ,_ffebg ,_bfff :=_eeec .split (_bfbdg );if _bfff !=nil {return false ,_bfff ;};if _facda !=nil &&_ffebg !=nil {_eeec =_facda ;_bddabe =_bcfc (_bddabe ,_facda ,false );
_egeg ._bbdb [_bcaga ]=_bddabe ;_adafc =_ffebg ;_bcdag =true ;};_eadg =_bddabe .height (_afdc .Width );};case *Division :if _eadg > _afdc .Height {_ebeeb :=_afdc ;_ebeeb .Height =_fb .Floor (_afdc .Height -_eeec ._bdbe .Top -_eeec ._bdbe .Bottom );_ggggd ,_babbf :=_eeec .split (_ebeeb );
if _ggggd !=nil &&_babbf !=nil {_eeec =_ggggd ;_bddabe =_bcfc (_bddabe ,_ggggd ,false );_egeg ._bbdb [_bcaga ]=_bddabe ;_adafc =_babbf ;_bcdag =true ;if _ggggd ._geba !=nil {_ggggd ._geba .BorderRadiusBottomLeft =0;_ggggd ._geba .BorderRadiusBottomRight =0;
};if _babbf ._geba !=nil {_babbf ._geba .BorderRadiusTopLeft =0;_babbf ._geba .BorderRadiusTopRight =0;};_eadg =_bddabe .height (_afdc .Width );};};case *List :if _eadg > _afdc .Height {_bdga :=_afdc ;_bdga .Height =_fb .Floor (_afdc .Height -_eeec ._afbf .Vertical ());
_degbf ,_febde :=_eeec .split (_bdga );if _degbf !=nil {_eeec =_degbf ;_bddabe =_bcfc (_bddabe ,_degbf ,false );_egeg ._bbdb [_bcaga ]=_bddabe ;};if _febde !=nil {_adafc =_febde ;_bcdag =true ;};_eadg =_bddabe .height (_afdc .Width );};};_cffd =append (_cffd ,_eadg );
if _bcdag {if _eaff ==nil {_eaff =make ([]*TableCell ,0,len (_egeg ._fbce ));for _agaa :=_faedc ;_agaa < _bcaga ;_agaa ++{_fgedc (_agaa ,nil );};};_fgedc (_bcaga ,_adafc );};};var _gcge float64 ;for _ ,_gceg :=range _cffd {if _gceg > _gcge {_gcge =_gceg ;
};};if _bcdag &&_gcge < _afdc .Height {if _ddde < 0{_ddde =len (_egeg ._bbdb );};_dcfad :=_egeg ._bbdb [_ddde -1]._badcc +_egeg ._bbdb [_ddde -1]._gddee -1;for _bdddf :=_ddde ;_bdddf < len (_egeg ._bbdb );_bdddf ++{_egeg ._bbdb [_bdddf ]._badcc ++;};_egeg ._bbdb =append (_egeg ._bbdb [:_ddde ],append (_eaff ,_egeg ._bbdb [_ddde :]...)...);
_egeg ._cbaab =append (_egeg ._cbaab [:_dcfad ],append ([]float64 {_bgbd },_egeg ._cbaab [_dcfad :]...)...);_egeg ._cbaab [_bbced ._badcc +_bbced ._gddee -2]=_gcge ;};return _bcdag ,nil ;};func (_agec *Division )split (_gbbf DrawContext )(_gdfgd ,_fgfd *Division ){var (_ggbg float64 ;
_ccac ,_aggc []VectorDrawable ;);_debc :=_gbbf .Width -_agec ._bdbe .Left -_agec ._bdbe .Right -_agec ._egfg .Left -_agec ._egfg .Right ;for _cfde ,_bfce :=range _agec ._bggcg {_ggbg +=_daedc (_bfce ,_debc );if _ggbg < _gbbf .Height {_ccac =append (_ccac ,_bfce );
}else {_aggc =_agec ._bggcg [_cfde :];break ;};};if len (_ccac )> 0{_gdfgd =_acdf ();*_gdfgd =*_agec ;_gdfgd ._bggcg =_ccac ;if _agec ._geba !=nil {_gdfgd ._geba =&Background {};*_gdfgd ._geba =*_agec ._geba ;};};if len (_aggc )> 0{_fgfd =_acdf ();*_fgfd =*_agec ;
_fgfd ._bggcg =_aggc ;if _agec ._geba !=nil {_fgfd ._geba =&Background {};*_fgfd ._geba =*_agec ._geba ;};};return _gdfgd ,_fgfd ;};

// SetIndent sets the cell's left indent.
func (_egcfg *TableCell )SetIndent (indent float64 ){_egcfg ._dccbb =indent };

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_dcga *Image )SetFitMode (fitMode FitMode ){_dcga ._eeba =fitMode };func (_fdeae *List )ctxHeight (_faabg float64 )float64 {_faabg -=_fdeae ._acag ;var _dccc float64 ;for _ ,_edadg :=range _fdeae ._ebfe {_dccc +=_edadg .ctxHeight (_faabg );};return _dccc ;
};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_gedb *GridCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_gedb ._edbg =halign };

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_geggd Color ;_cgfge float64 ;_dacd _fg .LineStyle ;_baef CellBorderStyle ;_cbea Color ;_bfgb float64 ;_cbfdfb CellBorderStyle ;_efffe Color ;_dabfb float64 ;_cbeb CellBorderStyle ;_cefef Color ;_efdac float64 ;_bdeg CellBorderStyle ;
_bcfdc Color ;_ebbgd float64 ;_badcc ,_gdgcb int ;_gddee int ;_abfbd int ;_fagd VectorDrawable ;_fdcfa CellHorizontalAlignment ;_dcgcb CellVerticalAlignment ;_dccbb float64 ;_dgfeac *Table ;};func _efbgcd (_dagb Color ,_cgbedf float64 )*ColorPoint {return &ColorPoint {_cdac :_dagb ,_cdaac :_cgbedf };
};func (_efff *LinearShading )shadingModel ()*_cd .PdfShadingType2 {_bbgdfe :=_fg .NewPoint (_efff ._adad .Llx +_efff ._adad .Width ()/2,_efff ._adad .Lly +_efff ._adad .Height ()/2);_dfag :=_fg .NewPoint (_efff ._adad .Llx ,_efff ._adad .Lly +_efff ._adad .Height ()/2).Add (-_bbgdfe .X ,-_bbgdfe .Y ).Rotate (_efff ._baab ).Add (_bbgdfe .X ,_bbgdfe .Y );
_dfag =_fg .NewPoint (_fb .Max (_fb .Min (_dfag .X ,_efff ._adad .Urx ),_efff ._adad .Llx ),_fb .Max (_fb .Min (_dfag .Y ,_efff ._adad .Ury ),_efff ._adad .Lly ));_bgfb :=_fg .NewPoint (_efff ._adad .Urx ,_efff ._adad .Lly +_efff ._adad .Height ()/2).Add (-_bbgdfe .X ,-_bbgdfe .Y ).Rotate (_efff ._baab ).Add (_bbgdfe .X ,_bbgdfe .Y );
_bgfb =_fg .NewPoint (_fb .Min (_fb .Max (_bgfb .X ,_efff ._adad .Llx ),_efff ._adad .Urx ),_fb .Min (_fb .Max (_bgfb .Y ,_efff ._adad .Lly ),_efff ._adad .Ury ));_aafaf :=_cd .NewPdfShadingType2 ();_aafaf .PdfShading .ShadingType =_bc .MakeInteger (2);
_aafaf .PdfShading .ColorSpace =_cd .NewPdfColorspaceDeviceRGB ();_aafaf .PdfShading .AntiAlias =_bc .MakeBool (_efff ._eadf ._gecagb );_aafaf .Coords =_bc .MakeArrayFromFloats ([]float64 {_dfag .X ,_dfag .Y ,_bgfb .X ,_bgfb .Y });_aafaf .Extend =_bc .MakeArray (_bc .MakeBool (_efff ._eadf ._ggefc [0]),_bc .MakeBool (_efff ._eadf ._ggefc [1]));
_aafaf .Function =_efff ._eadf .generatePdfFunctions ();return _aafaf ;};

// SetBorderColor sets the border color of the ellipse.
func (_aged *Ellipse )SetBorderColor (col Color ){_aged ._bbeba =col };const (_ddb =0.72;_egfa =28.3464;_fcdg =_egfa /10;_aebe =0.551784;_aeg =96;_aebf =16.0;);

// SetBorderOpacity sets the border opacity of the rectangle.
func (_accad *Rectangle )SetBorderOpacity (opacity float64 ){_accad ._gafg =opacity };

// SetFillColor sets background color for border.
func (_eeda *border )SetFillColor (col Color ){_eeda ._bca =col };

// AddLine appends a new line to the invoice line items table.
func (_gfafa *Invoice )AddLine (values ...string )[]*InvoiceCell {_aagdg :=len (_gfafa ._ebafb );var _cgdf []*InvoiceCell ;for _afaaf ,_aagff :=range values {_acfca :=_gfafa .newCell (_aagff ,_gfafa ._dcfg );if _afaaf < _aagdg {_acfca .Alignment =_gfafa ._ebafb [_afaaf ].Alignment ;
};_cgdf =append (_cgdf ,_acfca );};_gfafa ._adcac =append (_gfafa ._adcac ,_cgdf );return _cgdf ;};type Grid struct{_faca int ;_aagd []float64 ;_ggca float64 ;_eddd Positioning ;_aecd ,_ccacd float64 ;_ggbe Margins ;_dgaa []*GridRow ;};func (_aegd *Invoice )drawInformation ()*Table {_fdeag :=_bbab (2);
_bbcg :=append ([][2]*InvoiceCell {_aegd ._bedb ,_aegd ._aecde ,_aegd ._fgcd },_aegd ._abggd ...);for _ ,_fadaf :=range _bbcg {_bdda ,_eedd :=_fadaf [0],_fadaf [1];if _eedd .Value ==""{continue ;};_edaec :=_fdeag .NewCell ();_edaec .SetBackgroundColor (_bdda .BackgroundColor );
_aegd .setCellBorder (_edaec ,_bdda );_gdceg :=_eeff (_bdda .TextStyle );_gdceg .Append (_bdda .Value );_gdceg .SetMargins (0,0,2,1);_edaec .SetContent (_gdceg );_edaec =_fdeag .NewCell ();_edaec .SetBackgroundColor (_eedd .BackgroundColor );_aegd .setCellBorder (_edaec ,_eedd );
_gdceg =_eeff (_eedd .TextStyle );_gdceg .Append (_eedd .Value );_gdceg .SetMargins (0,0,2,1);_edaec .SetContent (_gdceg );};return _fdeag ;};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_deab *Division )Width ()float64 {return 0};func (_acddc *Paragraph )getMaxLineWidth ()float64 {if _acddc ._aeeca ==nil ||(_acddc ._aeeca !=nil &&len (_acddc ._aeeca )==0){_acddc .wrapText ();};var _cfcge float64 ;for _ ,_gfba :=range _acddc ._aeeca {_gebae :=_acddc .getTextLineWidth (_gfba );
if _gebae > _cfcge {_cfcge =_gebae ;};};return _cfcge ;};

// NewPageBreak create a new page break.
func (_dcbf *Creator )NewPageBreak ()*PageBreak {return _bdbb ()};func (_ggba *GraphicSVGElement )drawLine (_addce *_ca .ContentCreator ,_cfff *_cd .PdfPageResources ){_addce .Add_q ();_ggba .Style .toContentStream (_addce ,_cfff ,_ggba );_bffdf ,_fcee :=_cagdb (_ggba .Attributes ["\u0078\u0031"],64);
if _fcee !=nil {_dc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_fcee .Error ());};_begf ,_fcee :=_cagdb (_ggba .Attributes ["\u0079\u0031"],64);
if _fcee !=nil {_dc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_fcee .Error ());};_ggacd ,_fcee :=_cagdb (_ggba .Attributes ["\u0078\u0032"],64);
if _fcee !=nil {_dc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_fcee .Error ());};_edggf ,_fcee :=_cagdb (_ggba .Attributes ["\u0079\u0032"],64);
if _fcee !=nil {_dc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_fcee .Error ());};_addce .Add_m (_bffdf *_ggba ._ddccg ,_begf *_ggba ._ddccg );
_addce .Add_l (_ggacd *_ggba ._ddccg ,_edggf *_ggba ._ddccg );_ggba .Style .fillStroke (_addce );_addce .Add_h ();_addce .Add_Q ();};

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_dfecc *LinearShading )SetAngle (angle float64 ){_dfecc ._baab =angle };

// SetEnableWrap sets the line wrapping enabled flag.
func (_dfbg *Paragraph )SetEnableWrap (enableWrap bool ){_dfbg ._aacba =enableWrap ;_dfbg ._bagg =false ;};

// SetMarkedContentID sets the marked content ID.
func (_dgbc *Rectangle )SetMarkedContentID (mcid int64 )*_cd .KDict {_dgbc ._gfdac =&mcid ;_ecgge :=_cd .NewKDictionary ();_ecgge .S =_bc .MakeName (_cd .StructureTypeFigure );_ecgge .K =_bc .MakeInteger (mcid );return _ecgge ;};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_eddc *Creator )PageFinalize (pageFinalizeFunc func (_cefa PageFinalizeFunctionArgs )error ){_eddc ._acd =pageFinalizeFunc ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_ccga *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_ccga ._bga =toc ;};func _dadc (_efffa string )[]token {var (_cafd []token ;_gbffc string ;);for _ ,_aecgb :=range _efffa {_ffdcc :=string (_aecgb );switch {case _ecbf .isCommand (_ffdcc ):_cafd ,_gbffc =_gaeee (_cafd ,_gbffc );
_cafd =append (_cafd ,token {_ffdcc ,true });case _ffdcc =="\u002e":if _gbffc ==""{_gbffc ="\u0030";};if _gb .Contains (_gbffc ,_ffdcc ){_cafd =append (_cafd ,token {_gbffc ,false });_gbffc ="\u0030";};fallthrough;case _ffdcc >="\u0030"&&_ffdcc <="\u0039"||_ffdcc =="\u0065":_gbffc +=_ffdcc ;
case _ffdcc =="\u002d":if _gb .HasSuffix (_gbffc ,"\u0065"){_gbffc +=_ffdcc ;}else {_cafd ,_ =_gaeee (_cafd ,_gbffc );_gbffc =_ffdcc ;};default:_cafd ,_gbffc =_gaeee (_cafd ,_gbffc );};};_cafd ,_ =_gaeee (_cafd ,_gbffc );return _cafd ;};

// GetCoords returns coordinates of border.
func (_dbfg *border )GetCoords ()(float64 ,float64 ){return _dbfg ._eea ,_dbfg ._gbcc };func _aefd (_aaef []_fg .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_begb :&_fg .PolyBezierCurve {Curves :_aaef ,BorderColor :_cd .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_agac :1.0,_efbdf :1.0};
};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);func (_gfaeg *Command )isAbsolute ()bool {return _gfaeg .Symbol ==_gb .ToUpper (_gfaeg .Symbol )};const (FitModeNone FitMode =iota ;
FitModeFillWidth ;);

// SetTextExpansion sets the text expansion for the text chunk.
func (_eebfe *TextChunk )SetTextExpansion (text string ){_eebfe ._dfcgg =&text };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_dabb *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dabb ._ggaf .Left ,_dabb ._ggaf .Right ,_dabb ._ggaf .Top ,_dabb ._ggaf .Bottom ;};

// String implements error interface.
func (_cbcge UnsupportedRuneError )Error ()string {return _cbcge .Message };

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_cddfc *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_cddfc ._cgef =alignment };

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_agaf *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abdbf :=ctx ;var _dada []*Block ;_aagffc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _agaf ._gaabe .IsRelative (){ctx .X +=_agaf ._gebac .Left ;ctx .Y +=_agaf ._gebac .Top ;
ctx .Width -=_agaf ._gebac .Left +_agaf ._gebac .Right ;ctx .Height -=_agaf ._gebac .Top ;_agaf .SetWidth (ctx .Width );}else {if int (_agaf ._gabb )<=0{_agaf .SetWidth (_agaf .getTextWidth ()/1000.0);};ctx .X =_agaf ._fcgdfe ;ctx .Y =_agaf ._ebffa ;};
if _agaf ._gfeb !=nil {_agaf ._gfeb (_agaf ,ctx );};if _cdcb :=_agaf .wrapText ();_cdcb !=nil {return nil ,ctx ,_cdcb ;};_fggaf :=_agaf ._aeca ;_gebbb :=0;for {_abfc ,_gaaec ,_fbcdg :=_ddec (_aagffc ,_agaf ,_fggaf ,ctx );if _fbcdg !=nil {_dc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fbcdg );
return nil ,ctx ,_fbcdg ;};ctx =_abfc ;_dada =append (_dada ,_aagffc );if _fggaf =_gaaec ;len (_gaaec )==0{break ;};if len (_gaaec )==_gebbb {return nil ,ctx ,_ga .New ("\u006e\u006f\u0074\u0020\u0065\u006e\u006f\u0075\u0067\u0068 \u0073\u0070\u0061\u0063\u0065\u0020\u0066o\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068");
};_aagffc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_abfc =ctx ;_abfc .Y =ctx .Margins .Top ;_abfc .X =ctx .Margins .Left +_agaf ._gebac .Left ;_abfc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_abfc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_agaf ._gebac .Left -_agaf ._gebac .Right ;
ctx =_abfc ;_gebbb =len (_gaaec );};if _agaf ._gaabe .IsRelative (){ctx .Y +=_agaf ._gebac .Bottom ;ctx .Height -=_agaf ._gebac .Bottom ;if !ctx .Inline {ctx .X =_abdbf .X ;ctx .Width =_abdbf .Width ;};return _dada ,ctx ,nil ;};return _dada ,_abdbf ,nil ;
};

// SetFillOpacity sets the fill opacity of the ellipse.
func (_abef *Ellipse )SetFillOpacity (opacity float64 ){_abef ._cece =opacity };

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_dbcef *RadialShading )ToPdfShadingPattern ()*_cd .PdfShadingPatternType3 {_fcgdf ,_cdegc ,_fdacb :=_dbcef ._aaaed ._bcagg .ToRGB ();_fbgc :=_dbcef .shadingModel ();_fbgc .PdfShading .Background =_bc .MakeArrayFromFloats ([]float64 {_fcgdf ,_cdegc ,_fdacb });
_dccbd :=_cd .NewPdfShadingPatternType3 ();_dccbd .Shading =_fbgc ;return _dccbd ;};

// Decode decodes the child elements of element.
func (_abaa *GraphicSVGElement )Decode (decoder *_b .Decoder )error {for {_ddf ,_eeae :=decoder .Token ();if _ddf ==nil &&_eeae ==_ea .EOF {break ;};if _eeae !=nil {return _eeae ;};switch _ebfd :=_ddf .(type ){case _b .StartElement :_cdbg :=_cbe (_ebfd );
_gedf :=_cdbg .Decode (decoder );if _gedf !=nil {return _gedf ;};_abaa .Children =append (_abaa .Children ,_cdbg );case _b .CharData :_fade :=_gb .TrimSpace (string (_ebfd ));if _fade !=""{_abaa .Content =string (_ebfd );};case _b .EndElement :if _ebfd .Name .Local ==_abaa .Name {return nil ;
};};};return nil ;};func _agbdc (_dgbeb *_b .Decoder )(*GraphicSVGElement ,error ){for {_ddfcce ,_gcdbf :=_dgbeb .Token ();if _ddfcce ==nil &&_gcdbf ==_ea .EOF {break ;};if _gcdbf !=nil {return nil ,_gcdbf ;};switch _ggdfg :=_ddfcce .(type ){case _b .StartElement :return _cbe (_ggdfg ),nil ;
};};return &GraphicSVGElement {},nil ;};

// Path is a collection of all the subpaths in 'd' attribute.
type Path struct{Subpaths []*Subpath ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_gdagf *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_dgbbg :=[2]*InvoiceCell {_gdagf .newCell (description ,_gdagf ._feef ),_gdagf .newCell (value ,_gdagf ._feef )};_gdagf ._abggd =append (_gdagf ._abggd ,_dgbbg );return _dgbbg [0],_dgbbg [1];
};func (_fgab *templateProcessor )parseBackground (_fbdcg *templateNode )(interface{},error ){_gaebb :=&Background {};for _ ,_fgeec :=range _fbdcg ._egac .Attr {_ggbac :=_fgeec .Value ;switch _gebda :=_fgeec .Name .Local ;_gebda {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_gaebb .FillColor =_fgab .parseColorAttr (_gebda ,_ggbac );
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_gaebb .BorderColor =_fgab .parseColorAttr (_gebda ,_ggbac );case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_gaebb .BorderSize =_fgab .parseFloatAttr (_gebda ,_ggbac );
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_bcbggb ,_gega ,_ggbacg ,_agad :=_fgab .parseBorderRadiusAttr (_gebda ,_ggbac );_gaebb .SetBorderRadius (_bcbggb ,_gega ,_agad ,_ggbacg );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_gaebb .BorderRadiusTopLeft =_fgab .parseFloatAttr (_gebda ,_ggbac );
case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_gaebb .BorderRadiusTopRight =_fgab .parseFloatAttr (_gebda ,_ggbac );case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_gaebb .BorderRadiusBottomLeft =_fgab .parseFloatAttr (_gebda ,_ggbac );
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_gaebb .BorderRadiusBottomRight =_fgab .parseFloatAttr (_gebda ,_ggbac );default:_fgab .nodeLogDebug (_fbdcg ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_gebda );
};};return _gaebb ,nil ;};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_bgffa *Table )EnableRowWrap (enable bool ){_bgffa ._ccgc =enable };

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_cega *Invoice )NoteStyle ()TextStyle {return _cega ._cac };

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_begag *LinearShading )AddPatternResource (block *Block )(_gccfb _bc .PdfObjectName ,_gabf error ){_ecbgc :=1;_fbacb :=_bc .PdfObjectName ("\u0050"+_ge .Itoa (_ecbgc ));for block ._bcb .HasPatternByName (_fbacb ){_ecbgc ++;_fbacb =_bc .PdfObjectName ("\u0050"+_ge .Itoa (_ecbgc ));
};if _dbfff :=block ._bcb .SetPatternByName (_fbacb ,_begag .ToPdfShadingPattern ().ToPdfObject ());_dbfff !=nil {return "",_dbfff ;};return _fbacb ,nil ;};

// SetHeight sets the height of the rectangle.
func (_abfa *Rectangle )SetHeight (height float64 ){_abfa ._dbab =height };var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);
ColorYellow =ColorRGBFromArithmetic (1,1,0););

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_dcf :_fb .Max (_fb .Min (r ,1.0),0.0),_fagc :_fb .Max (_fb .Min (g ,1.0),0.0),_bac :_fb .Max (_fb .Min (b ,1.0),0.0)};};func _fgcdf (_ddabe string )(*Path ,error ){_ecbf =_fbdbd ();
_eagbe ,_cfeed :=_cdfgae (_dadc (_ddabe ));if _cfeed !=nil {return nil ,_cfeed ;};return _dceed (_eagbe ),nil ;};func _bfgd (_efbcd string )(_fbcad ,_gfefc string ){if _efbcd ==""||(_efbcd [len (_efbcd )-1]>='0'&&_efbcd [len (_efbcd )-1]<='9'){return _efbcd ,"";
};_fbcad =_efbcd ;for _ ,_gcceb :=range _bfe {if _gb .Contains (_fbcad ,_gcceb ){_gfefc =_gcceb ;};_fbcad =_gb .TrimSuffix (_fbcad ,_gcceb );};return ;};

// SetMargins sets the margins of the graphic svg component.
func (_efde *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_efde ._ddddf .Left =left ;_efde ._ddddf .Right =right ;_efde ._ddddf .Top =top ;_efde ._ddddf .Bottom =bottom ;};func _eeeg (_ebdea ,_gcgcg TextStyle )*Invoice {_gbgg :=&Invoice {_dffb :"\u0049N\u0056\u004f\u0049\u0043\u0045",_bbgd :"\u002c\u0020",_fdeaf :_ebdea ,_ecaf :_gcgcg };
_gbgg ._egaec =&InvoiceAddress {Separator :_gbgg ._bbgd };_gbgg ._cdceb =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_gbgg ._bbgd };_cafb :=ColorRGBFrom8bit (245,245,245);_gbccb :=ColorRGBFrom8bit (155,155,155);_gbgg ._ggbef =_gcgcg ;
_gbgg ._ggbef .Color =_gbccb ;_gbgg ._ggbef .FontSize =20;_gbgg ._daacd =_ebdea ;_gbgg ._cefda =_gcgcg ;_gbgg ._cac =_ebdea ;_gbgg ._cgbb =_gcgcg ;_gbgg ._feef =_gbgg .NewCellProps ();_gbgg ._feef .BackgroundColor =_cafb ;_gbgg ._feef .TextStyle =_gcgcg ;
_gbgg ._caeaa =_gbgg .NewCellProps ();_gbgg ._caeaa .TextStyle =_gcgcg ;_gbgg ._caeaa .BackgroundColor =_cafb ;_gbgg ._caeaa .BorderColor =_cafb ;_gbgg ._dcfg =_gbgg .NewCellProps ();_gbgg ._dcfg .BorderColor =_cafb ;_gbgg ._dcfg .BorderSides =[]CellBorderSide {CellBorderSideBottom };
_gbgg ._dcfg .Alignment =CellHorizontalAlignmentRight ;_gbgg ._afaa =_gbgg .NewCellProps ();_gbgg ._afaa .Alignment =CellHorizontalAlignmentRight ;_gbgg ._bedb =[2]*InvoiceCell {_gbgg .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_gbgg ._feef ),_gbgg .newCell ("",_gbgg ._feef )};
_gbgg ._aecde =[2]*InvoiceCell {_gbgg .newCell ("\u0044\u0061\u0074\u0065",_gbgg ._feef ),_gbgg .newCell ("",_gbgg ._feef )};_gbgg ._fgcd =[2]*InvoiceCell {_gbgg .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_gbgg ._feef ),_gbgg .newCell ("",_gbgg ._feef )};
_gbgg ._adfbe =[2]*InvoiceCell {_gbgg .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_gbgg ._afaa ),_gbgg .newCell ("",_gbgg ._afaa )};_gadee :=_gbgg ._afaa ;_gadee .TextStyle =_gcgcg ;_gadee .BackgroundColor =_cafb ;_gadee .BorderColor =_cafb ;
_gbgg ._ccaef =[2]*InvoiceCell {_gbgg .newCell ("\u0054\u006f\u0074a\u006c",_gadee ),_gbgg .newCell ("",_gadee )};_gbgg ._efec =[2]string {"\u004e\u006f\u0074e\u0073",""};_gbgg ._agagf =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_gbgg ._ebafb =[]*InvoiceCell {_gbgg .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_gbgg .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_gbgg .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_gbgg .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _gbgg ;};

// SetSideBorderStyle sets the cell's side border style.
func (_dfceff *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_dfceff ._bdeg =style ;_dfceff ._cbfdfb =style ;_dfceff ._baef =style ;_dfceff ._cbeb =style ;case CellBorderSideTop :_dfceff ._bdeg =style ;
case CellBorderSideBottom :_dfceff ._cbfdfb =style ;case CellBorderSideLeft :_dfceff ._baef =style ;case CellBorderSideRight :_dfceff ._cbeb =style ;};};

// SetMargins sets the Grid's left, right, top, bottom margins.
func (_bddcf *Grid )SetMargins (left ,right ,top ,bottom float64 ){_bddcf ._ggbe .Left =left ;_bddcf ._ggbe .Right =right ;_bddcf ._ggbe .Top =top ;_bddcf ._ggbe .Bottom =bottom ;};

// SetColorLeft sets border color for left.
func (_eefd *border )SetColorLeft (col Color ){_eefd ._aad =col };func _acdbg (_ccgcf string ,_cgdfe ,_gdadg TextStyle )*TOC {_agdbd :=_gdadg ;_agdbd .FontSize =14;_dccaa :=_eeff (_agdbd );_dccaa .SetEnableWrap (true );_dccaa .SetTextAlignment (TextAlignmentLeft );
_dccaa .SetMargins (0,0,0,5);_adbce :=_dccaa .Append (_ccgcf );_adbce .Style =_agdbd ;return &TOC {_cfgfg :_dccaa ,_fdad :[]*TOCLine {},_agcfe :_cgdfe ,_fbfe :_cgdfe ,_fbdd :_cgdfe ,_abdfc :_cgdfe ,_cbbcf :"\u002e",_gfdea :10,_afgga :Margins {0,0,2,2},_dgcg :PositionRelative ,_baeaa :_cgdfe ,_gbeeg :true };
};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_eeabb *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _cgee (x1 ,y1 ,x2 ,y2 )};func (_ddebb *templateProcessor )parseList (_aaagba *templateNode )(interface{},error ){_ccbdc :=_ddebb .creator .NewList ();for _ ,_dcbae :=range _aaagba ._egac .Attr {_bbca :=_dcbae .Value ;
switch _begbe :=_dcbae .Name .Local ;_begbe {case "\u0069\u006e\u0064\u0065\u006e\u0074":_ccbdc .SetIndent (_ddebb .parseFloatAttr (_begbe ,_bbca ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_aabbdc :=_ddebb .parseMarginAttr (_begbe ,_bbca );_ccbdc .SetMargins (_aabbdc .Left ,_aabbdc .Right ,_aabbdc .Top ,_aabbdc .Bottom );
default:_ddebb .nodeLogDebug (_aaagba ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_begbe );
};};return _ccbdc ,nil ;};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_abge *Chart )SetPos (x ,y float64 ){_abge ._edbd =PositionAbsolute ;_abge ._bbcf =x ;_abge ._cfcg =y ;};

// NewPolygon creates a new polygon.
func (_efc *Creator )NewPolygon (points [][]_fg .Point )*Polygon {return _bddab (points )};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_gagb :=&Block {};_gagb ._df =&_ca .ContentStreamOperations {};_gagb ._bcb =_cd .NewPdfPageResources ();_gagb ._cef =width ;_gagb ._dff =height ;return _gagb ;};

// SetBackgroundColor sets the cell's background color.
func (_debfb *GridCell )SetBackgroundColor (col Color ){_debfb ._gcgc =col };

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// Width returns the width of the graphic svg.
func (_ddcg *GraphicSVG )Width ()float64 {return _ddcg ._dbgf .Width };

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_ccgg *Invoice )SetColumns (cols []*InvoiceCell ){_ccgg ._ebafb =cols };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_gebab *Invoice )TotalLines ()[][2]*InvoiceCell {_ddaa :=[][2]*InvoiceCell {_gebab ._adfbe };_ddaa =append (_ddaa ,_gebab ._aeda ...);return append (_ddaa ,_gebab ._ccaef );};func (_egfca *Table )moveToNextAvailableCell ()int {_edge :=(_egfca ._degcf -1)%(_egfca ._gfgc )+1;
for {if _edge -1>=len (_egfca ._degb ){if _egfca ._degb [0]==0{return _edge ;};_edge =1;}else if _egfca ._degb [_edge -1]==0{return _edge ;};_egfca ._degcf ++;_egfca ._degb [_edge -1]--;_edge ++;};};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_ecceg *Grid )SetColumnWidths (widths ...float64 )error {if len (widths )!=_ecceg ._faca {_dc .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _ga .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ecceg ._aagd =widths ;return nil ;};func _eeff (_bdad TextStyle )*StyledParagraph {return &StyledParagraph {_gceca :[]*TextChunk {},_fdeab :_bdad ,_caefe :_bfcec (_bdad .Font ),_gdaeca :1.0,_dddb :TextAlignmentLeft ,_ccbe :true ,_dbcf :true ,_decb :false ,_dcfd :0,_cfcfg :1,_cbbc :1,_gaabe :PositionRelative ,_begca :""};
};

// SetScaling sets scaling value for graphic SVG and maintain the aspect ratio.
func (_bfbe *GraphicSVGElement )SetScaling (xFactor ,yFactor float64 ){_cegb :=_bfbe .Width /_bfbe .ViewBox .W ;_agdg :=_bfbe .Height /_bfbe .ViewBox .H ;_bfbe .setDefaultScaling (_fb .Max (_cegb ,_agdg ));for _ ,_fgcgdc :=range _bfbe .Children {_fgcgdc .SetScaling (xFactor ,yFactor );
};};func (_edfbg *templateProcessor )parseInt64Attr (_ebfge ,_ddebe string )int64 {_dc .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_ebfge ,_ddebe );
_afceb ,_ :=_ge .ParseInt (_ddebe ,10,64);return _afceb ;};func _dcdg (_def string ,_adgg _bc .PdfObject ,_cfd *_cd .PdfPageResources )_bc .PdfObjectName {_bcd :=_gb .TrimRightFunc (_gb .TrimSpace (_def ),func (_ccg rune )bool {return _f .IsNumber (_ccg )});
if _bcd ==""{_bcd ="\u0046\u006f\u006e\u0074";};_cfe :=0;_dcde :=_bc .PdfObjectName (_def );for {_fdeb ,_cg :=_cfd .GetFontByName (_dcde );if !_cg ||_fdeb ==_adgg {break ;};_cfe ++;_dcde =_bc .PdfObjectName (_a .Sprintf ("\u0025\u0073\u0025\u0064",_bcd ,_cfe ));
};return _dcde ;};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _aa .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_ea .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_cd .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_cd .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_de .ChartRenderable ;};

// SetMarkedContentID sets marked content ID.
func (_agdef *Polyline )SetMarkedContentID (mcid int64 )*_cd .KDict {_agdef ._cgfe =&mcid ;_ddfg :=_cd .NewKDictionary ();_ddfg .S =_bc .MakeName (_cd .StructureTypeFigure );_ddfg .K =_bc .MakeInteger (mcid );return _ddfg ;};var PPI float64 =72;

// SetMarkedContentID sets marked content ID.
func (_gecd *Invoice )SetMarkedContentID (id int64 )*_cd .KDict {return nil };

// Scale scales the ellipse dimensions by the specified factors.
func (_feaa *Ellipse )Scale (xFactor ,yFactor float64 ){_feaa ._gca =xFactor *_feaa ._gca ;_feaa ._geeg =yFactor *_feaa ._geeg ;};func (_gace *Grid )updateRowHeights (_gegc float64 ){for _ ,_abbd :=range _gace ._dgaa {_abbd .updateRowHeight (_gegc );};
};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_cbbg DrawContext )([]*Block ,DrawContext ,error );

// SetMarkedContentID sets the marked content id for the drawable.
SetMarkedContentID (_ecba int64 )*_cd .KDict ;};func (_ffeb *Invoice )generateHeaderBlocks (_ffcg DrawContext )([]*Block ,DrawContext ,error ){_befab :=_eeff (_ffeb ._ggbef );_befab .SetEnableWrap (true );_befab .Append (_ffeb ._dffb );_efbgc :=_bbab (2);
if _ffeb ._deegg !=nil {_faac :=_efbgc .NewCell ();_faac .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_faac .SetVerticalAlignment (CellVerticalAlignmentMiddle );_faac .SetIndent (0);_faac .SetContent (_ffeb ._deegg );_ffeb ._deegg .ScaleToHeight (_befab .Height ()+20);
}else {_efbgc .SkipCells (1);};_dgfdb :=_efbgc .NewCell ();_dgfdb .SetHorizontalAlignment (CellHorizontalAlignmentRight );_dgfdb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_dgfdb .SetContent (_befab );return _efbgc .GeneratePageBlocks (_ffcg );
};

// BuyerAddress returns the buyer address used in the invoice template.
func (_acdc *Invoice )BuyerAddress ()*InvoiceAddress {return _acdc ._cdceb };

// SetAngle sets the rotation angle of the text.
func (_bfdga *Paragraph )SetAngle (angle float64 ){_bfdga ._gdaec =angle };type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_cdda Drawable )(Drawable ,error );};

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_fbag *GraphicSVG )ScaleToWidth (w float64 ){_cadg :=_fbag ._dbgf .Height /_fbag ._dbgf .Width ;_fbag ._dbgf .Width =w ;_fbag ._dbgf .Height =w *_cadg ;_fbag ._dbgf .SetScaling (_cadg ,_cadg );};func _cdggd (_gacdff *_cd .PdfAnnotation )*_cd .PdfAnnotation {if _gacdff ==nil {return nil ;
};var _bfbag *_cd .PdfAnnotation ;switch _cfbgc :=_gacdff .GetContext ().(type ){case *_cd .PdfAnnotationLink :if _egab :=_eeafa (_cfbgc );_egab !=nil {_bfbag =_egab .PdfAnnotation ;};case *_cd .PdfAnnotationHighlight :if _fbbaa :=_dfbbb (_cfbgc );_fbbaa !=nil {_bfbag =_fbbaa .PdfAnnotation ;
};};return _bfbag ;};func (_egdea pathParserError )Error ()string {return _egdea ._fdda };

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_ecgcg *RadialShading )SetAntiAlias (enable bool ){_ecgcg ._aaaed .SetAntiAlias (enable )};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_ggeda *Paragraph )Height ()float64 {_ggeda .wrapText ();return _aac .RoundDefault (float64 (len (_ggeda ._aeeca ))*_ggeda ._dbfac *_ggeda ._ebab );};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;
);

// SetOpacity sets the cell's opacity in the range 0-1.
func (_cefde *GridCell )SetOpacity (opacity float64 ){_cefde ._dede =opacity };func (_ceeaga *templateProcessor )run ()error {_ffed :=_b .NewDecoder (_gc .NewReader (_ceeaga ._fdbfe ));var _bddaf *templateNode ;for {_beeg ,_cfef :=_ffed .Token ();if _cfef !=nil {if _cfef ==_ea .EOF {return nil ;
};return _cfef ;};if _beeg ==nil {break ;};_dbeeg ,_ggdd :=_effdg (_ffed );_aegbg :=_ffed .InputOffset ();switch _gdcga :=_beeg .(type ){case _b .StartElement :_dc .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_gdcga .Name .Local );
_ccbf ,_gffg :=_gcadgb [_gdcga .Name .Local ];if !_gffg {if _ceeaga ._fefbg ==""{if _dbeeg !=0{_dc .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_gdcga .Name .Local ,_dbeeg ,_ggdd );
}else {_dc .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_gdcga .Name .Local ,_aegbg );
};}else {if _dbeeg !=0{_dc .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_gdcga .Name .Local ,_ceeaga ._fefbg ,_dbeeg ,_ggdd );
}else {_dc .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_gdcga .Name .Local ,_ceeaga ._fefbg ,_aegbg );
};};continue ;};_bddaf =&templateNode {_egac :_gdcga ,_fafg :_bddaf ,_fbba :_dbeeg ,_fbfgd :_ggdd ,_fecbge :_aegbg };if _fbfbf :=_ccbf ._bedde ;_fbfbf !=nil {_bddaf ._bedgb ,_cfef =_fbfbf (_ceeaga ,_bddaf );if _cfef !=nil {return _cfef ;};};case _b .EndElement :_dc .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_gdcga .Name .Local );
if _bddaf !=nil {if _bddaf ._bedgb !=nil {if _dggbg :=_ceeaga .renderNode (_bddaf );_dggbg !=nil {return _dggbg ;};};_bddaf =_bddaf ._fafg ;};case _b .CharData :if _bddaf !=nil &&_bddaf ._bedgb !=nil {if _ffbaf :=_ceeaga .addNodeText (_bddaf ,string (_gdcga ));
_ffbaf !=nil {return _ffbaf ;};};case _b .Comment :_dc .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_gdcga ));
};};return nil ;};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_gcca *Creator )NewPolyBezierCurve (curves []_fg .CubicBezierCurve )*PolyBezierCurve {return _aefd (curves );};

// SetWidthBottom sets border width for bottom.
func (_cae *border )SetWidthBottom (bw float64 ){_cae ._cbc =bw };func _bdbb ()*PageBreak {return &PageBreak {}};func (_fagae *Invoice )generateTotalBlocks (_gbdg DrawContext )([]*Block ,DrawContext ,error ){_bfag :=_bbab (4);_bfag .SetMargins (0,0,10,10);
_ebdad :=[][2]*InvoiceCell {_fagae ._adfbe };_ebdad =append (_ebdad ,_fagae ._aeda ...);_ebdad =append (_ebdad ,_fagae ._ccaef );for _ ,_gccf :=range _ebdad {_eaddc ,_accd :=_gccf [0],_gccf [1];if _accd .Value ==""{continue ;};_bfag .SkipCells (2);_cded :=_bfag .NewCell ();
_cded .SetBackgroundColor (_eaddc .BackgroundColor );_cded .SetHorizontalAlignment (_accd .Alignment );_fagae .setCellBorder (_cded ,_eaddc );_addcf :=_eeff (_eaddc .TextStyle );_addcf .SetMargins (0,0,2,1);_addcf .Append (_eaddc .Value );_cded .SetContent (_addcf );
_cded =_bfag .NewCell ();_cded .SetBackgroundColor (_accd .BackgroundColor );_cded .SetHorizontalAlignment (_accd .Alignment );_fagae .setCellBorder (_cded ,_eaddc );_addcf =_eeff (_accd .TextStyle );_addcf .SetMargins (0,0,2,1);_addcf .Append (_accd .Value );
_cded .SetContent (_addcf );};return _bfag .GeneratePageBlocks (_gbdg );};

// NewFilledCurve returns a instance of filled curve.
func (_gfda *Creator )NewFilledCurve ()*FilledCurve {return _dac ()};func _cecab (_gbecb *templateProcessor ,_aggcdd *templateNode )(interface{},error ){return _gbecb .parseLine (_aggcdd );};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_cfabf *Invoice )NoteHeadingStyle ()TextStyle {return _cfabf ._cgbb };func (_agbg *Paragraph )getTextMetrics ()(_dccg ,_ggef ,_feacd float64 ){_fddf :=_dfgf (_agbg ._fgef ,_agbg ._ebab );if _fddf ._faafd > _dccg {_dccg =_fddf ._faafd ;};if _fddf ._fdfbeg < _feacd {_feacd =_fddf ._fdfbeg ;
};if _feae :=_agbg ._ebab ;_feae > _ggef {_ggef =_feae ;};return _dccg ,_ggef ,_feacd ;};func _acagc (_ebbeda *templateProcessor ,_dfgge *templateNode )(interface{},error ){return _ebbeda .parseTableCell (_dfgge );};

// SetText sets the text content of the Paragraph.
func (_ebeeg *Paragraph )SetText (text string ){_ebeeg ._ceeaa =text };

// Style returns the style of the line.
func (_cdeg *Line )Style ()_fg .LineStyle {return _cdeg ._ggabf };

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_dgeed *Line )SetColor (color Color ){_dgeed ._baad =color };

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_gfeg *GraphicSVG )ScaleToHeight (h float64 ){_ffec :=_gfeg ._dbgf .Width /_gfeg ._dbgf .Height ;_gfeg ._dbgf .Height =h ;_gfeg ._dbgf .Width =h *_ffec ;_gfeg ._dbgf .SetScaling (_ffec ,_ffec );};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_cfeb *Creator )SetPageSize (size PageSize ){_cfeb ._gee =size ;_cfeb ._gdac =size [0];_cfeb ._gdce =size [1];_gea :=0.1*_cfeb ._gdac ;_cfeb ._gced .Left =_gea ;_cfeb ._gced .Right =_gea ;_cfeb ._gced .Top =_gea ;_cfeb ._gced .Bottom =_gea ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_fde *Block )SetPos (x ,y float64 ){_fde ._cdd =PositionAbsolute ;_fde ._cfg =x ;_fde ._cab =y };

// The Image type is used to draw an image onto PDF.
type Image struct{_gcfb *_cd .XObjectImage ;_fbca *_cd .Image ;_gaba string ;_adca float64 ;_gagbb ,_cbgg float64 ;_cddf ,_agddd float64 ;_fabb Positioning ;_cgef HorizontalAlignment ;_fffe float64 ;_gabc float64 ;_fceb float64 ;_fega Margins ;_cccag ,_dggd float64 ;
_baed _bc .StreamEncoder ;_eeba FitMode ;_eecf bool ;_ffdce *int64 ;};

// SetMarkedContentID sets marked content ID.
func (_bgdge *FilledCurve )SetMarkedContentID (mcid int64 )*_cd .KDict {_bgdge ._bcbgc =&mcid ;_aadaf :=_cd .NewKDictionary ();_aadaf .S =_bc .MakeName (_cd .StructureTypeFigure );_aadaf .K =_bc .MakeInteger (mcid );return _aadaf ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_dbe *Creator )NewImageFromGoImage (goimg _eg .Image )(*Image ,error ){return _bfeb (goimg )};

// SetPositioning sets the positioning of the line (absolute or relative).
func (_aabgf *Line )SetPositioning (positioning Positioning ){_aabgf ._dcac =positioning };

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_gead *Ellipse )ScaleToWidth (w float64 ){_deeg :=_gead ._geeg /_gead ._gca ;_gead ._gca =w ;_gead ._geeg =w *_deeg ;};

// SetBorderColor sets the border color.
func (_dgb *CurvePolygon )SetBorderColor (color Color ){_dgb ._fceg .BorderColor =_dfd (color )};func (_cfeee *templateProcessor )parseChart (_gfga *templateNode )(interface{},error ){var _fgcfc string ;for _ ,_dcabe :=range _gfga ._egac .Attr {_caafd :=_dcabe .Value ;
switch _acbad :=_dcabe .Name .Local ;_acbad {case "\u0073\u0072\u0063":_fgcfc =_caafd ;};};if _fgcfc ==""{_cfeee .nodeLogError (_gfga ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_degba ;};_dgcef ,_afccfg :=_cfeee ._cebde .ChartMap [_fgcfc ];if !_afccfg {_cfeee .nodeLogError (_gfga ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_fgcfc );
return nil ,_degba ;};_dbeec :=NewChart (_dgcef );for _ ,_bedbf :=range _gfga ._egac .Attr {_efcda :=_bedbf .Value ;switch _dbec :=_bedbf .Name .Local ;_dbec {case "\u0078":_dbeec .SetPos (_cfeee .parseFloatAttr (_dbec ,_efcda ),_dbeec ._cfcg );case "\u0079":_dbeec .SetPos (_dbeec ._bbcf ,_cfeee .parseFloatAttr (_dbec ,_efcda ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_efcae :=_cfeee .parseMarginAttr (_dbec ,_efcda );_dbeec .SetMargins (_efcae .Left ,_efcae .Right ,_efcae .Top ,_efcae .Bottom );case "\u0077\u0069\u0064t\u0068":_dbeec ._eegd .SetWidth (int (_cfeee .parseFloatAttr (_dbec ,_efcda )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_dbeec ._eegd .SetHeight (int (_cfeee .parseFloatAttr (_dbec ,_efcda )));case "\u0073\u0072\u0063":break ;default:_cfeee .nodeLogDebug (_gfga ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_dbec );
};};return _dbeec ,nil ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_cgab *Invoice )AddressStyle ()TextStyle {return _cgab ._daacd };

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_agdd float64 ;_eebb float64 ;_gca float64 ;_geeg float64 ;_cddb Positioning ;_dcdf Color ;_cece float64 ;_bbeba Color ;_bfd float64 ;_daaca float64 ;_ebbed Margins ;_aeed FitMode ;_cga *int64 ;};func _ggfeg (_cbbgc *templateProcessor ,_gabcc *templateNode )(interface{},error ){return _cbbgc .parseTable (_gabcc );
};

// FitMode returns the fit mode of the image.
func (_fbbe *Image )FitMode ()FitMode {return _fbbe ._eeba };

// SetBorder sets the cell's border style.
func (_gbag *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_gbag ._baef =CellBorderStyleSingle ;_gbag ._bfgb =width ;_gbag ._cbfdfb =CellBorderStyleSingle ;
_gbag ._dabfb =width ;_gbag ._cbeb =CellBorderStyleSingle ;_gbag ._efdac =width ;_gbag ._bdeg =CellBorderStyleSingle ;_gbag ._ebbgd =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_gbag ._baef =CellBorderStyleDouble ;_gbag ._bfgb =width ;
_gbag ._cbfdfb =CellBorderStyleDouble ;_gbag ._dabfb =width ;_gbag ._cbeb =CellBorderStyleDouble ;_gbag ._efdac =width ;_gbag ._bdeg =CellBorderStyleDouble ;_gbag ._ebbgd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_gbag ._baef =style ;
_gbag ._bfgb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_gbag ._cbfdfb =style ;_gbag ._dabfb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_gbag ._cbeb =style ;
_gbag ._efdac =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_gbag ._bdeg =style ;_gbag ._ebbgd =width ;};};

// SetFillColor sets the fill color of the ellipse.
func (_cdba *Ellipse )SetFillColor (col Color ){_cdba ._dcdf =col };

// ColorGrayFromArithmetic creates a Color from a grayscale value (0-1).
// Example:
//
//	gray := ColorGrayFromArithmetic(0.7)
func ColorGrayFromArithmetic (g float64 )Color {return grayColor {g }};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_defdf *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// SetStyle sets the style of the line (solid or dashed).
func (_fbaf *Line )SetStyle (style _fg .LineStyle ){_fbaf ._ggabf =style };

// Write output of creator to io.Writer interface.
func (_fbdbb *Creator )Write (ws _ea .Writer )error {if _daae :=_fbdbb .Finalize ();_daae !=nil {return _daae ;};_cbfa :="";if _fce ,_bcdf :=ws .(*_be .File );_bcdf {_cbfa =_fce .Name ();};_bega :=_cd .NewPdfWriter ();_bega .SetOptimizer (_fbdbb ._fecff );
_bega .SetFileName (_cbfa );if _fbdbb ._fgaa !=nil {_cgd :=_bega .SetForms (_fbdbb ._fgaa );if _cgd !=nil {_dc .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cgd );return _cgd ;};};if _fbdbb ._bgdg !=nil {_bega .AddOutlineTree (_fbdbb ._bgdg );
}else if _fbdbb ._daba !=nil &&_fbdbb .AddOutlines {_bega .AddOutlineTree (&_fbdbb ._daba .ToPdfOutline ().PdfOutlineTreeNode );};if _fbdbb ._aaga !=nil {if _cccf :=_bega .SetPageLabels (_fbdbb ._aaga );_cccf !=nil {_dc .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_cccf );
return _cccf ;};};if _fbdbb ._ggag !=nil {for _ ,_eddb :=range _fbdbb ._ggag {_eacc :=_eddb .SubsetRegistered ();if _eacc !=nil {_dc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_eacc );
return _eacc ;};};};if _fbdbb ._egd !=nil {_bdffb :=_fbdbb ._egd (&_bega );if _bdffb !=nil {_dc .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bdffb );return _bdffb ;};};for _egca ,_gdfc :=range _fbdbb ._cgb {_geff :=_bega .AddPage (_gdfc );
if _geff !=nil {_dc .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_geff );return _geff ;};if _fbdbb ._fada !=nil {_ecb :=_fbdbb ._fada .K ;_ggc ,_eedf :=_bega .GetPageIndirectObject (_egca );
if _eedf !=nil {_dc .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0043\u006fu\u006c\u0064\u0020n\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061ge\u0020\u0069\u006ed\u0069\u0072e\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074 \u0025\u0076",_eedf );
};var _gfdf func (_geea *_cd .KDict );_gfdf =func (_adde *_cd .KDict ){if _adde ==nil {return ;};if _adde .GetPageNumber ()-1==int64 (_egca ){_adde .SetPage (_ggc );};for _ ,_agag :=range _adde .GetChildren (){if _ffgb :=_agag .GetKDict ();_ffgb !=nil {_gfdf (_ffgb );
};};};for _ ,_agee :=range _ecb {_gfdf (_agee );};};};if _fbdbb ._fada !=nil {if _fcef :=_bega .SetCatalogStructTreeRoot (_fbdbb ._fada .ToPdfObject ());_fcef !=nil {_dc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020n\u006f\u0074\u0020\u0073\u0065\u0074 \u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065\u0065\u0052\u006f\u006ft\u003a\u0020\u0025\u0076",_fcef );
return _fcef ;};};if _fbdbb ._cgg !=nil {if _dbbe :=_bega .SetCatalogViewerPreferences (_fbdbb ._cgg .ToPdfObject ());_dbbe !=nil {_dc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065\u0074\u0020\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073\u003a\u0020\u0025\u0076",_dbbe );
return _dbbe ;};};if _fbdbb ._cbcg !=""{if _gfb :=_bega .SetCatalogLanguage (_bc .MakeString (_fbdbb ._cbcg ));_gfb !=nil {_dc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065t\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u006c\u0061\u006e\u0067\u0075\u0061\u0067\u0065\u003a\u0020\u0025\u0076",_gfb );
return _gfb ;};};_acg :=_bega .Write (ws );if _acg !=nil {return _acg ;};return nil ;};

// SetMargins sets the margins TOC line.
func (_dcdacee *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_dcdacee ._gecda =left ;_cafcc :=&_dcdacee ._bebag ._gebac ;_cafcc .Left =_dcdacee ._gecda +float64 (_dcdacee ._bedfe -1)*_dcdacee ._fcegc ;_cafcc .Right =right ;_cafcc .Top =top ;
_cafcc .Bottom =bottom ;};const (DefaultHorizontalScaling =100;);func (_ffcb *templateProcessor )nodeError (_efbe *templateNode ,_agcf string ,_ggbfe ...interface{})error {return _a .Errorf ("\u0025\u0073",_ffcb .getNodeErrorLocation (_efbe ,_agcf ,_ggbfe ...));
};func (_gcada *templateProcessor )nodeLogError (_caggd *templateNode ,_bcgb string ,_gadgg ...interface{}){_dc .Log .Error (_gcada .getNodeErrorLocation (_caggd ,_bcgb ,_gadgg ...));};func (_afbg *StyledParagraph )getMaxLineWidth ()float64 {if _afbg ._aeca ==nil ||(_afbg ._aeca !=nil &&len (_afbg ._aeca )==0){_afbg .wrapText ();
};var _gaafff float64 ;for _ ,_fccg :=range _afbg ._aeca {_caee :=_afbg .getTextLineWidth (_fccg );if _caee > _gaafff {_gaafff =_caee ;};};return _gaafff ;};

// Height returns the current page height.
func (_gfdd *Creator )Height ()float64 {return _gfdd ._gdce };

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_bcfg *Creator )MoveTo (x ,y float64 ){_bcfg ._cfce .X =x ;_bcfg ._cfce .Y =y };

// NewRow makes a new row and inserts it into the table at the current position.
func (_gffce *Grid )NewRow ()*GridRow {_fgebd :=&GridRow {_facac :_gffce ._ggca ,_gaab :len (_gffce ._dgaa ),_abf :_gffce };_gffce ._dgaa =append (_gffce ._dgaa ,_fgebd );return _fgebd ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_fdca *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_fdca ._adad =&_cd .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// SetFillColor sets the fill color of the rectangle.
func (_fdff *Rectangle )SetFillColor (col Color ){_fdff ._cgfc =col };func (_bfbee *templateProcessor )parseTableCell (_eead *templateNode )(interface{},error ){if _eead ._fafg ==nil {_bfbee .nodeLogError (_eead ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_bfcee ;};_cadga ,_cgfgde :=_eead ._fafg ._bedgb .(*Table );if !_cgfgde {_bfbee .nodeLogError (_eead ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_eead ._fafg ._bedgb );
return nil ,_bfcee ;};var _dadgf ,_bggcad int64 ;for _ ,_eedfg :=range _eead ._egac .Attr {_eecc :=_eedfg .Value ;switch _cefee :=_eedfg .Name .Local ;_cefee {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_dadgf =_bfbee .parseInt64Attr (_cefee ,_eecc );
case "\u0072o\u0077\u0073\u0070\u0061\u006e":_bggcad =_bfbee .parseInt64Attr (_cefee ,_eecc );};};if _dadgf <=0{_dadgf =1;};if _bggcad <=0{_bggcad =1;};_edgde :=_cadga .MultiCell (int (_bggcad ),int (_dadgf ));for _ ,_bedgbc :=range _eead ._egac .Attr {_cceag :=_bedgbc .Value ;
switch _eeaf :=_bedgbc .Name .Local ;_eeaf {case "\u0069\u006e\u0064\u0065\u006e\u0074":_edgde .SetIndent (_bfbee .parseFloatAttr (_eeaf ,_cceag ));case "\u0061\u006c\u0069g\u006e":_edgde .SetHorizontalAlignment (_bfbee .parseCellAlignmentAttr (_eeaf ,_cceag ));
case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_edgde .SetVerticalAlignment (_bfbee .parseCellVerticalAlignmentAttr (_eeaf ,_cceag ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_edgde .SetSideBorderStyle (CellBorderSideAll ,_bfbee .parseCellBorderStyleAttr (_eeaf ,_cceag ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_edgde .SetSideBorderStyle (CellBorderSideTop ,_bfbee .parseCellBorderStyleAttr (_eeaf ,_cceag ));case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_edgde .SetSideBorderStyle (CellBorderSideBottom ,_bfbee .parseCellBorderStyleAttr (_eeaf ,_cceag ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_edgde .SetSideBorderStyle (CellBorderSideLeft ,_bfbee .parseCellBorderStyleAttr (_eeaf ,_cceag ));case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_edgde .SetSideBorderStyle (CellBorderSideRight ,_bfbee .parseCellBorderStyleAttr (_eeaf ,_cceag ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_edgde .SetSideBorderWidth (CellBorderSideAll ,_bfbee .parseFloatAttr (_eeaf ,_cceag ));case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_edgde .SetSideBorderWidth (CellBorderSideTop ,_bfbee .parseFloatAttr (_eeaf ,_cceag ));
case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_edgde .SetSideBorderWidth (CellBorderSideBottom ,_bfbee .parseFloatAttr (_eeaf ,_cceag ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_edgde .SetSideBorderWidth (CellBorderSideLeft ,_bfbee .parseFloatAttr (_eeaf ,_cceag ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_edgde .SetSideBorderWidth (CellBorderSideRight ,_bfbee .parseFloatAttr (_eeaf ,_cceag ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_edgde .SetSideBorderColor (CellBorderSideAll ,_bfbee .parseColorAttr (_eeaf ,_cceag ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_edgde .SetSideBorderColor (CellBorderSideTop ,_bfbee .parseColorAttr (_eeaf ,_cceag ));case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_edgde .SetSideBorderColor (CellBorderSideBottom ,_bfbee .parseColorAttr (_eeaf ,_cceag ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_edgde .SetSideBorderColor (CellBorderSideLeft ,_bfbee .parseColorAttr (_eeaf ,_cceag ));case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_edgde .SetSideBorderColor (CellBorderSideRight ,_bfbee .parseColorAttr (_eeaf ,_cceag ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_edgde .SetBorderLineStyle (_bfbee .parseLineStyleAttr (_eeaf ,_cceag ));case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_edgde .SetBackgroundColor (_bfbee .parseColorAttr (_eeaf ,_cceag ));
case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;default:_bfbee .nodeLogDebug (_eead ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_eeaf );
};};return _edgde ,nil ;};

// AddAnnotation adds an annotation on a TextChunk.
func (_cdacd *TextChunk )AddAnnotation (annotation *_cd .PdfAnnotation ){if annotation ==nil {return ;};_cdacd ._ccbfe =append (_cdacd ._ccbfe ,annotation );};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_eabba *StyledParagraph )SetTextAlignment (align TextAlignment ){_eabba ._dddb =align };

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_bdgac *Table )MultiRowCell (rowspan int )*TableCell {return _bdgac .MultiCell (rowspan ,1)};func _bgadd (_gedee *templateProcessor ,_dbbgf *templateNode )(interface{},error ){return _gedee .parseListItem (_dbbgf );};func (_ggfee *templateProcessor )parseImage (_gfdef *templateNode )(interface{},error ){var _ceebc string ;
for _ ,_fbaa :=range _gfdef ._egac .Attr {_cafde :=_fbaa .Value ;switch _gbae :=_fbaa .Name .Local ;_gbae {case "\u0073\u0072\u0063":_ceebc =_cafde ;};};_fadab ,_ddbg :=_ggfee .loadImageFromSrc (_ceebc );if _ddbg !=nil {return nil ,_ddbg ;};var _bdbgb _bc .StreamEncoder ;
_abga :=_gb .ToLower (_g .Ext (_ceebc ));if _abga =="\u006a\u0070\u0067"||_abga =="\u006a\u0070\u0065\u0067"{_bdbgb =_bc .NewDCTEncoder ();}else {_bdbgb =_bc .NewFlateEncoder ();};_fadab .SetEncoder (_bdbgb );for _ ,_bdgfc :=range _gfdef ._egac .Attr {_dfeba :=_bdgfc .Value ;
switch _dggg :=_bdgfc .Name .Local ;_dggg {case "\u0061\u006c\u0069g\u006e":_fadab .SetHorizontalAlignment (_ggfee .parseHorizontalAlignmentAttr (_dggg ,_dfeba ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_fadab .SetOpacity (_ggfee .parseFloatAttr (_dggg ,_dfeba ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_aabgca :=_ggfee .parseMarginAttr (_dggg ,_dfeba );_fadab .SetMargins (_aabgca .Left ,_aabgca .Right ,_aabgca .Top ,_aabgca .Bottom );case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_fadab .SetFitMode (_ggfee .parseFitModeAttr (_dggg ,_dfeba ));
case "\u0078":_fadab .SetPos (_ggfee .parseFloatAttr (_dggg ,_dfeba ),_fadab ._gabc );case "\u0079":_fadab .SetPos (_fadab ._fffe ,_ggfee .parseFloatAttr (_dggg ,_dfeba ));case "\u0077\u0069\u0064t\u0068":_fadab .SetWidth (_ggfee .parseFloatAttr (_dggg ,_dfeba ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_fadab .SetHeight (_ggfee .parseFloatAttr (_dggg ,_dfeba ));case "\u0061\u006e\u0067l\u0065":_fadab .SetAngle (_ggfee .parseFloatAttr (_dggg ,_dfeba ));case "\u0065n\u0063\u006f\u0064\u0065\u0072":_bdbgb =_ggfee .parseImageEncoder (_dggg ,_dfeba );
if _bdbgb !=nil {_fadab .SetEncoder (_bdbgb );};case "\u0073\u0072\u0063":break ;default:_ggfee .nodeLogDebug (_gfdef ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_dggg );
};};return _fadab ,nil ;};

// NewTOC creates a new table of contents.
func (_aafe *Creator )NewTOC (title string )*TOC {_fgebc :=_aafe .NewTextStyle ();_fgebc .Font =_aafe ._aaeed ;return _acdbg (title ,_aafe .NewTextStyle (),_fgebc );};

// Height returns the height of the line.
func (_ggeg *Line )Height ()float64 {_gacgf :=_ggeg ._beaa ;if _ggeg ._cdfa ==_ggeg ._fgeg {_gacgf /=2;};return _fb .Abs (_ggeg ._becde -_ggeg ._eadda )+_gacgf ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_ged *Block )Draw (d Drawable )error {_egc :=DrawContext {};_egc .Width =_ged ._cef ;_egc .Height =_ged ._dff ;_egc .PageWidth =_ged ._cef ;_egc .PageHeight =_ged ._dff ;_egc .X =0;_egc .Y =0;_bdf ,_ ,_dga :=d .GeneratePageBlocks (_egc );if _dga !=nil {return _dga ;
};if len (_bdf )!=1{return ErrContentNotFit ;};for _ ,_fac :=range _bdf {if _bdb :=_ged .mergeBlocks (_fac );_bdb !=nil {return _bdb ;};};return nil ;};func _ecbbb (_ecdca *templateProcessor ,_fcefe *templateNode )(interface{},error ){return _ecdca .parseEllipse (_fcefe );
};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_eefaf *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_edcgf []*Block ;_cbfb bool ;_cgbc error ;_geac =_eefaf ._ecec .IsRelative ();_gddb =_eefaf ._bdbe .Top ;);if _geac &&!_eefaf ._fcdc &&!_eefaf ._ceda {_cbbd :=_eefaf .ctxHeight (ctx .Width );
if _cbbd > ctx .Height -_eefaf ._bdbe .Top &&_cbbd <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _edcgf ,ctx ,_cgbc =_bdbb ().GeneratePageBlocks (ctx );_cgbc !=nil {return nil ,ctx ,_cgbc ;};_cbfb =true ;_gddb =0;};};_abec :=ctx ;_aba :=ctx ;
if _geac {ctx .X +=_eefaf ._bdbe .Left ;ctx .Y +=_gddb ;ctx .Width -=_eefaf ._bdbe .Left +_eefaf ._bdbe .Right ;ctx .Height -=_gddb ;_aba =ctx ;ctx .X +=_eefaf ._egfg .Left ;ctx .Y +=_eefaf ._egfg .Top ;ctx .Width -=_eefaf ._egfg .Left +_eefaf ._egfg .Right ;
ctx .Height -=_eefaf ._egfg .Top ;ctx .Margins .Top +=_eefaf ._egfg .Top ;ctx .Margins .Bottom +=_eefaf ._egfg .Bottom ;ctx .Margins .Left +=_eefaf ._bdbe .Left +_eefaf ._egfg .Left ;ctx .Margins .Right +=_eefaf ._bdbe .Right +_eefaf ._egfg .Right ;};ctx .Inline =_eefaf ._ceda ;
_bgf :=ctx ;_dbbf :=ctx ;var _cgff float64 ;for _ ,_fedd :=range _eefaf ._bggcg {if ctx .Inline {if (ctx .X -_bgf .X )+_fedd .Width ()<=ctx .Width {ctx .Y =_dbbf .Y ;ctx .Height =_dbbf .Height ;}else {ctx .X =_bgf .X ;ctx .Width =_bgf .Width ;_dbbf .Y +=_cgff ;
_dbbf .Height -=_cgff ;_cgff =0;};};_ddbd ,_egbd ,_efad :=_fedd .GeneratePageBlocks (ctx );if _efad !=nil {_dc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_efad );
return nil ,ctx ,_efad ;};if len (_ddbd )< 1{continue ;};if len (_edcgf )> 0{_edcgf [len (_edcgf )-1].mergeBlocks (_ddbd [0]);_edcgf =append (_edcgf ,_ddbd [1:]...);}else {if _fegf :=_ddbd [0]._df ;_fegf ==nil ||len (*_fegf )==0{_cbfb =true ;};_edcgf =append (_edcgf ,_ddbd [0:]...);
};_egba :=0.0;switch _afde :=_fedd .(type ){case *Paragraph :_egba =(0.5*_afde ._ebab *_afde ._dbfac );case *StyledParagraph :_egba =(0.5*_afde .getTextHeight ());};_egbd .Y +=_egba ;_egbd .Height -=_egba ;if ctx .Inline {if ctx .Page !=_egbd .Page {_bgf .Y =ctx .Margins .Top ;
_bgf .Height =ctx .PageHeight -ctx .Margins .Top ;_dbbf .Y =_bgf .Y ;_dbbf .Height =_bgf .Height ;_cgff =_egbd .Height -_bgf .Height ;}else {if _baf :=ctx .Height -_egbd .Height ;_baf > _cgff {_cgff =_baf ;};};}else {_egbd .X =ctx .X ;};ctx =_egbd ;};if len (_eefaf ._bggcg )==0{_efe :=NewBlock (ctx .Width ,0);
_edcgf =append (_edcgf ,_efe );};ctx .Inline =_abec .Inline ;ctx .Margins =_abec .Margins ;if _geac {ctx .X =_abec .X ;ctx .Width =_abec .Width ;ctx .Y +=_eefaf ._egfg .Bottom ;ctx .Height -=_eefaf ._egfg .Bottom ;};if _eefaf ._geba !=nil {_edcgf ,_cgbc =_eefaf .drawBackground (_edcgf ,_aba ,ctx ,_cbfb );
if _cgbc !=nil {return nil ,ctx ,_cgbc ;};};if _eefaf ._ecec .IsAbsolute (){return _edcgf ,_abec ,nil ;};ctx .Y +=_eefaf ._bdbe .Bottom ;ctx .Height -=_eefaf ._bdbe .Bottom ;return _edcgf ,ctx ,nil ;};func _geab (_cdbgb string )bool {_bade :=func (_ddded rune )bool {return _ddded =='\u000A'};
_eaaac :=_gb .TrimFunc (_cdbgb ,_bade );_egaaa :=_gag .Paragraph {};_ ,_addf :=_egaaa .SetString (_eaaac );if _addf !=nil {return true ;};_bcef ,_addf :=_egaaa .Order ();if _addf !=nil {return true ;};if _bcef .NumRuns ()< 1{return true ;};return _egaaa .IsLeftToRight ();
};

// FitMode returns the fit mode of the ellipse.
func (_gbgae *Ellipse )FitMode ()FitMode {return _gbgae ._aeed };var (ErrContentNotFit =_ga .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
);func (_effg *GridCell )height (_aabd float64 )float64 {var _ggeaf float64 ;switch _ddea :=_effg ._feac .(type ){case *Paragraph :if _ddea ._aacba {_ddea .SetWidth (_aabd -_effg ._cbfg -_ddea ._cafc .Left -_ddea ._cafc .Right );};_ggeaf =_ddea .Height ()+_ddea ._cafc .Top +_ddea ._cafc .Bottom ;
case *StyledParagraph :if _ddea ._ccbe {_ddea .SetWidth (_aabd -_effg ._cbfg -_ddea ._gebac .Left -_ddea ._gebac .Right );};_ggeaf =_ddea .Height ()+_ddea ._gebac .Top +_ddea ._gebac .Bottom ;case *Image :_ddea .applyFitMode (_aabd -_effg ._cbfg );_ggeaf =_ddea .Height ()+_ddea ._fega .Top +_ddea ._fega .Bottom ;
case *Table :_ddea .updateRowHeights (_aabd -_effg ._cbfg -_ddea ._gbdab .Left -_ddea ._gbdab .Right );_ggeaf =_ddea .Height ()+_ddea ._gbdab .Top +_ddea ._gbdab .Bottom ;case *List :_ggeaf =_ddea .ctxHeight (_aabd -_effg ._cbfg )+_ddea ._afbf .Top +_ddea ._afbf .Bottom ;
case *Division :_ggeaf =_ddea .ctxHeight (_aabd -_effg ._cbfg )+_ddea ._bdbe .Top +_ddea ._bdbe .Bottom +_ddea ._egfg .Top +_ddea ._egfg .Bottom ;case *Chart :_ggeaf =_ddea .Height ()+_ddea ._fdg .Top +_ddea ._fdg .Bottom ;case *Rectangle :_ddea .applyFitMode (_aabd -_effg ._cbfg );
_ggeaf =_ddea .Height ()+_ddea ._egecg .Top +_ddea ._egecg .Bottom +_ddea ._dedg ;case *Ellipse :_ddea .applyFitMode (_aabd -_effg ._cbfg );_ggeaf =_ddea .Height ()+_ddea ._ebbed .Top +_ddea ._ebbed .Bottom ;case *Line :_ggeaf =_ddea .Height ()+_ddea ._adbf .Top +_ddea ._adbf .Bottom ;
};return _ggeaf ;};func _efadb (_bfbd ,_cfcac ,_faaa ,_aagf float64 )*Ellipse {return &Ellipse {_agdd :_bfbd ,_eebb :_cfcac ,_gca :_faaa ,_geeg :_aagf ,_cddb :PositionAbsolute ,_cece :1.0,_bbeba :ColorBlack ,_bfd :1.0,_daaca :1.0};};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_aabc *TableCell )SetContent (vd VectorDrawable )error {switch _acdce :=vd .(type ){case *Paragraph :if _acdce ._bagg {_acdce ._aacba =true ;};_aabc ._fagd =vd ;case *StyledParagraph :if _acdce ._dbcf {_acdce ._ccbe =true ;};_aabc ._fagd =vd ;case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_aabc ._fagd =vd ;
default:_dc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _bc .ErrTypeError ;};return nil ;};func _gagfc (_fded string )(*GraphicSVG ,error ){_agfb ,_gdbf :=ParseFromSVGFile (_fded );if _gdbf !=nil {return nil ,_gdbf ;};return _baag (_agfb );};

// NewGrid creates a new Grid with a specified number of columns.
func (_aeeb *Creator )NewGrid (cols int )*Grid {return _adb (cols )};func _bgbbb (_adbfd float64 ,_ccaec float64 )float64 {return _fb .Round (_adbfd /_ccaec )*_ccaec };

// Heading returns the heading component of the table of contents.
func (_bacaf *TOC )Heading ()*StyledParagraph {return _bacaf ._cfgfg };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_caeb *StyledParagraph )Height ()float64 {_caeb .wrapText ();var _ddgde float64 ;for _ ,_gafc :=range _caeb ._aeca {var _dcabb float64 ;for _ ,_bbba :=range _gafc {_eebc :=_caeb ._gdaeca *_bbba .Style .FontSize ;if _eebc > _dcabb {_dcabb =_eebc ;
};};_ddgde +=_dcabb ;};return _ddgde ;};

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_beba *Line )Width ()float64 {return _fb .Abs (_beba ._fgeg -_beba ._cdfa )};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_gaedf *Creator )SetOptimizer (optimizer _cd .Optimizer ){_gaedf ._fecff =optimizer };

// SetWidth sets line width.
func (_bebg *Curve )SetWidth (width float64 ){_bebg ._dbdf =width };

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_gdacd *List )Marker ()*TextChunk {return &_gdacd ._fbfg };func _cdfgae (_gaagc []token )([]*Command ,error ){var (_gfcc []*Command ;_cddbc []float64 ;);for _ebefd :=len (_gaagc )-1;_ebefd >=0;_ebefd --{_gafgg :=_gaagc [_ebefd ];if _gafgg ._defg {_aggdd :=_ecbf ._fabgg [_gb .ToLower (_gafgg ._fcag )];
_dgddf :=len (_cddbc );if _aggdd ==0&&_dgddf ==0{_febe :=&Command {Symbol :_gafgg ._fcag };_gfcc =append ([]*Command {_febe },_gfcc ...);}else if _aggdd !=0&&_dgddf %_aggdd ==0{_aaacgc :=_dgddf /_aggdd ;for _edaa :=0;_edaa < _aaacgc ;_edaa ++{_fbbeb :=_gafgg ._fcag ;
if _fbbeb =="\u006d"&&_edaa < _aaacgc -1{_fbbeb ="\u006c";};if _fbbeb =="\u004d"&&_edaa < _aaacgc -1{_fbbeb ="\u004c";};_edff :=&Command {_fbbeb ,_cbfdf (_cddbc [:_aggdd ])};_gfcc =append ([]*Command {_edff },_gfcc ...);_cddbc =_cddbc [_aggdd :];};}else {_bfdda :=pathParserError {"I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0070\u0061r\u0061\u006d\u0065\u0074\u0065\u0072\u0073\u0020\u0066\u006fr\u0020"+_gafgg ._fcag };
return nil ,_bfdda ;};}else {_dfagf ,_fcaae :=_cagdb (_gafgg ._fcag ,64);if _fcaae !=nil {return nil ,_fcaae ;};_cddbc =append (_cddbc ,_dfagf );};};return _gfcc ,nil ;};func (_faec *GridRow )updateRowHeight (_gffb float64 ){_faec ._aeec =_faec ._facac ;
for _ ,_debe :=range _faec ._ebec {_dggbf :=_debe .width (_faec ._abf ._aagd ,_gffb );_agddc :=_debe .height (_dggbf );if _agddc > _faec ._aeec {_faec ._aeec =_agddc ;};};};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_ddfcc *StyledParagraph )SetEnableWrap (enableWrap bool ){_ddfcc ._ccbe =enableWrap ;_ddfcc ._dbcf =false ;};

// SetWidthTop sets border width for top.
func (_edc *border )SetWidthTop (bw float64 ){_edc ._addc =bw };

// SetMarkedContentID sets the marked content id for the paragraph.
func (_ccec *Paragraph )SetMarkedContentID (mcid int64 )*_cd .KDict {_ccec ._ebcbf =&mcid ;_daag :=_cd .NewKDictionary ();_daag .S =_bc .MakeName ("\u0050");_daag .K =_bc .MakeInteger (mcid );return _daag ;};type rgbColor struct{_dcf ,_fagc ,_bac float64 };
var _adgd =_gf .MustCompile ("\u005c\u0064\u002b");

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_dafd *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gebd :=ctx ;var _gadeb []*Block ;_ebfec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _dafd ._egaac .IsRelative (){ctx .X +=_aac .RoundDefault (_dafd ._cafc .Left );
ctx .Y +=_aac .RoundDefault (_dafd ._cafc .Top );ctx .Width -=_aac .RoundDefault (_dafd ._cafc .Left +_dafd ._cafc .Right );ctx .Height -=_aac .RoundDefault (_dafd ._cafc .Top );_dafd .SetWidth (ctx .Width );if _dafd .Height ()> ctx .Height {_gadeb =append (_gadeb ,_ebfec );
_ebfec =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_baageb :=ctx ;_baageb .Y =_aac .RoundDefault (ctx .Margins .Top );_baageb .X =_aac .RoundDefault (ctx .Margins .Left +_dafd ._cafc .Left );_baageb .Height =_aac .RoundDefault (ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom );
_baageb .Width =_aac .RoundDefault (ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dafd ._cafc .Left -_dafd ._cafc .Right );ctx =_baageb ;};}else {if int (_dafd ._deeb )<=0{_dafd .SetWidth (_dafd .getTextWidth ());};ctx .X =_dafd ._gfec ;ctx .Y =_dafd ._fgffa ;
};ctx ,_fcde :=_gedc (_ebfec ,_dafd ,ctx );if _fcde !=nil {_dc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fcde );return nil ,ctx ,_fcde ;};_gadeb =append (_gadeb ,_ebfec );if _dafd ._egaac .IsRelative (){ctx .Y +=_aac .RoundDefault (_dafd ._cafc .Bottom );
ctx .Height -=_aac .RoundDefault (_dafd ._cafc .Bottom );if !ctx .Inline {ctx .X =_gebd .X ;ctx .Width =_gebd .Width ;};return _gadeb ,ctx ,nil ;};return _gadeb ,_gebd ,nil ;};func (_gbcf *templateProcessor )parseListMarker (_fadc *templateNode )(interface{},error ){if _fadc ._fafg ==nil {_gbcf .nodeLogError (_fadc ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_bfcee ;};var _agecd *TextChunk ;switch _beddbd :=_fadc ._fafg ._bedgb .(type ){case *List :_agecd =&_beddbd ._fbfg ;case *listItem :_agecd =&_beddbd ._geed ;default:_gbcf .nodeLogError (_fadc ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_beddbd );
return nil ,_bfcee ;};if _ ,_cdefd :=_gbcf .parseTextChunk (_fadc ,_agecd );_cdefd !=nil {_gbcf .nodeLogError (_fadc ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_cdefd );
return nil ,nil ;};return _agecd ,nil ;};func (_ggbacd *templateProcessor )parseCellAlignmentAttr (_gabe ,_gedd string )CellHorizontalAlignment {_dc .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gabe ,_gedd );
_adge :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_gedd ];return _adge ;
};var _gcadgb =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_abbdg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bedde :_ecfgc },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_abbdg :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_bedde :_adfab },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_abbdg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bedde :_abaca },"\u0074\u0061\u0062l\u0065":&templateTag {_abbdg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bedde :_ggfeg },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_abbdg :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_bedde :_acagc },"\u006c\u0069\u006e\u0065":&templateTag {_abbdg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bedde :_cecab },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_abbdg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bedde :_dddef },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_abbdg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bedde :_ecbbb },"\u0069\u006d\u0061g\u0065":&templateTag {_abbdg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bedde :_fdagg },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_abbdg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bedde :_fcgcf },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_abbdg :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bedde :_caed },"\u0063\u0068\u0061r\u0074":&templateTag {_abbdg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bedde :_cgde },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_abbdg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_bedde :_aacfgb },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_abbdg :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_bedde :_dedccg },"\u006c\u0069\u0073\u0074":&templateTag {_abbdg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bedde :_baedf },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_abbdg :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_bedde :_bgadd },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_abbdg :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_bedde :_fgfed }};


// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_dbdc *LinearShading )SetBackgroundColor (backgroundColor Color ){_dbdc ._eadf .SetBackgroundColor (backgroundColor );};func (_ggea cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_affd :=_ggea ._cce ;return 1-(_ggea ._fdcca *(1-_affd )+_affd ),1-(_ggea ._aaac *(1-_affd )+_affd ),1-(_ggea ._fcda *(1-_affd )+_affd );
};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// SetAngle sets the rotation angle of the text.
func (_dccfd *StyledParagraph )SetAngle (angle float64 ){_dccfd ._dcfd =angle };

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_gceca []*TextChunk ;_fdeab TextStyle ;_caefe TextStyle ;_dddb TextAlignment ;_dadf TextVerticalAlignment ;_gdaeca float64 ;_ccbe bool ;_gabb float64 ;_decb bool ;_bbbf int ;_dbcf bool ;_adbcd TextOverflow ;_dcfd float64 ;_gebac Margins ;
_gaabe Positioning ;_fcgdfe float64 ;_ebffa float64 ;_cfcfg float64 ;_cbbc float64 ;_aeca [][]*TextChunk ;_gfeb func (_edcc *StyledParagraph ,_ebcae DrawContext );_bfdcc *int64 ;_begca string ;};

// SetStyle sets paragraph style for all chunks.
func (_aeebb *StyledParagraph )SetStyle (style TextStyle ){_aeebb ._fdeab =style ;for _ ,_bdab :=range _aeebb ._gceca {_bdab .Style =style ;};};

// BorderWidth returns the border width of the rectangle.
func (_gfca *Rectangle )BorderWidth ()float64 {return _gfca ._dedg };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ebdd *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _fagg float64 ;var _aefbc []*StyledParagraph ;for _ ,_eebac :=range _ebdd ._ebfe {_eaddg :=_eeff (_ebdd ._adcc );_eaddg .SetEnableWrap (false );_eaddg .SetTextAlignment (TextAlignmentRight );
_eaddg .Append (_eebac ._geed .Text ).Style =_eebac ._geed .Style ;_cdeec :=_eaddg .getTextWidth ()/1000.0/ctx .Width ;if _fagg < _cdeec {_fagg =_cdeec ;};_aefbc =append (_aefbc ,_eaddg );};_aaadd :=_bbab (2);_aaadd .SetColumnWidths (_fagg ,1-_fagg );_aaadd .SetMargins (_ebdd ._afbf .Left +_ebdd ._acag ,_ebdd ._afbf .Right ,_ebdd ._afbf .Top ,_ebdd ._afbf .Bottom );
_aaadd .EnableRowWrap (true );for _cdaa ,_gcgca :=range _ebdd ._ebfe {_bbbg :=_aaadd .NewCell ();_bbbg .SetIndent (0);_bbbg .SetContent (_aefbc [_cdaa ]);_bbbg =_aaadd .NewCell ();_bbbg .SetIndent (0);_bbbg .SetContent (_gcgca ._adfbbg );};return _aaadd .GeneratePageBlocks (ctx );
};

// ParseFromSVGFile creates a GraphicSVG instance from file.
func ParseFromSVGFile (path string )(*GraphicSVGElement ,error ){_cfbf ,_ffda :=_be .Open (path );if _ffda !=nil {return nil ,_ffda ;};defer _cfbf .Close ();return ParseFromSVGStream (_cfbf );};

// SetLineWidth sets the line width.
func (_fgde *Line )SetLineWidth (width float64 ){_fgde ._beaa =width };

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_fabff *Table )SetPos (x ,y float64 ){_fabff ._dgfgd =PositionAbsolute ;_fabff ._geacc =x ;_fabff ._facedb =y ;};func (_dfdfc *Grid )resetColumnWidths (){_dfdfc ._aagd =[]float64 {};_fgdg :=float64 (1.0)/float64 (_dfdfc ._faca );for _gcec :=0;_gcec < _dfdfc ._faca ;
_gcec ++{_dfdfc ._aagd =append (_dfdfc ._aagd ,_fgdg );};};

// AddColorStop add color stop info for rendering gradient color.
func (_ebaa *LinearShading )AddColorStop (color Color ,point float64 ){_ebaa ._eadf .AddColorStop (color ,point );};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_gfaa *Creator )SetOutlineTree (outlineTree *_cd .PdfOutlineTreeNode ){_gfaa ._bgdg =outlineTree };

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_edcf *List )Add (item VectorDrawable )(*TextChunk ,error ){_beed :=&listItem {_adfbbg :item ,_geed :_edcf ._fbfg };switch _bfdf :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _bfdf ._fdeafc {_bfdf ._acag =15;};case *Division :case *Image :case *Table :default:return nil ,_ga .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_edcf ._ebfe =append (_edcf ._ebfe ,_beed );return &_beed ._geed ,nil ;};

// Width returns the cell's width based on the input draw context.
func (_baegg *TableCell )Width (ctx DrawContext )float64 {_geefe :=float64 (0.0);for _accbd :=0;_accbd < _baegg ._abfbd ;_accbd ++{_geefe +=_baegg ._dgfeac ._fbce [_baegg ._gdgcb +_accbd -1];};_baee :=ctx .Width *_geefe ;return _baee ;};

// NewCellProps returns the default properties of an invoice cell.
func (_faae *Invoice )NewCellProps ()InvoiceCellProps {_abbf :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_faae ._fdeaf ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_abbf ,BorderColor :_abbf ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};func (_aebca *Creator )getActivePage ()*_cd .PdfPage {if _aebca ._deg ==nil {if len (_aebca ._cgb )==0{return nil ;};return _aebca ._cgb [len (_aebca ._cgb )-1];};return _aebca ._deg ;};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};func (_gcfa *templateProcessor )parsePositioningAttr (_fedb ,_ggffe string )Positioning {_dc .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fedb ,_ggffe );
_gbfb :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_ggffe ];return _gbfb ;};

// SetMarkedContentID sets marked content ID.
func (_dfde *CurvePolygon )SetMarkedContentID (mcid int64 )*_cd .KDict {_dfde ._cgbe =&mcid ;_ccbd :=_cd .NewKDictionary ();_ccbd .S =_bc .MakeName (_cd .StructureTypeFigure );_ccbd .K =_bc .MakeInteger (mcid );return _ccbd ;};

// SetFontSize sets the font size in document units (points).
func (_fagcae *Paragraph )SetFontSize (fontSize float64 ){_fagcae ._ebab =fontSize };

// SetDueDate sets the due date of the invoice.
func (_acfab *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_acfab ._fgcd [1].Value =dueDate ;return _acfab ._fgcd [0],_acfab ._fgcd [1];};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_gddgef *TOC )SetLineSeparatorStyle (style TextStyle ){_gddgef ._fbdd =style };

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_agedb *Invoice )AddressHeadingStyle ()TextStyle {return _agedb ._ecaf };

// SetFillOpacity sets the fill opacity of the rectangle.
func (_gbdc *Rectangle )SetFillOpacity (opacity float64 ){_gbdc ._ddeaec =opacity };type pageTransformations struct{_ace *_aae .Matrix ;_cecd bool ;_ddad bool ;};func _dceed (_eeaef []*Command )*Path {_baagb :=&Path {};var _ceeea []*Command ;for _aeaf ,_fbed :=range _eeaef {switch _gb .ToLower (_fbed .Symbol ){case _ecbf ._acddf :if len (_ceeea )> 0{_baagb .Subpaths =append (_baagb .Subpaths ,&Subpath {_ceeea });
};_ceeea =[]*Command {_fbed };case _ecbf ._ecedc :_ceeea =append (_ceeea ,_fbed );_baagb .Subpaths =append (_baagb .Subpaths ,&Subpath {_ceeea });_ceeea =[]*Command {};default:_ceeea =append (_ceeea ,_fbed );if len (_eeaef )==_aeaf +1{_baagb .Subpaths =append (_baagb .Subpaths ,&Subpath {_ceeea });
};};};return _baagb ;};

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_fadeg *Rectangle )BorderOpacity ()float64 {return _fadeg ._gafg };

// EnableWordWrap sets the paragraph word wrap flag.
func (_bcbb *StyledParagraph )EnableWordWrap (val bool ){_bcbb ._decb =val };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_ceff *Creator )MoveRight (dx float64 ){_ceff ._cfce .X +=dx };

// SetMarkedContentID sets marked content ID.
func (_gdfd *Curve )SetMarkedContentID (mcid int64 )*_cd .KDict {_gdfd ._accbg =&mcid ;_adab :=_cd .NewKDictionary ();_adab .S =_bc .MakeName (_cd .StructureTypeFigure );_adab .K =_bc .MakeInteger (mcid );return _adab ;};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_cagcb *GridCell )SetVerticalAlignment (valign CellVerticalAlignment ){_cagcb ._cfgf =valign };

// BorderWidth returns the border width of the ellipse.
func (_affb *Ellipse )BorderWidth ()float64 {return _affb ._bfd };func _daedc (_cffg VectorDrawable ,_cad float64 )float64 {switch _debf :=_cffg .(type ){case *Paragraph :if _debf ._aacba {_debf .SetWidth (_cad -_debf ._cafc .Left -_debf ._cafc .Right );
};return _debf .Height ()+_debf ._cafc .Top +_debf ._cafc .Bottom +(0.5*_debf ._ebab *_debf ._dbfac );case *StyledParagraph :if _debf ._ccbe {_debf .SetWidth (_cad -_debf ._gebac .Left -_debf ._gebac .Right );};return _debf .Height ()+_debf ._gebac .Top +_debf ._gebac .Bottom +(0.5*_debf .getTextHeight ());
case *Image :_debf .applyFitMode (_cad );return _debf .Height ()+_debf ._fega .Top +_debf ._fega .Bottom ;case *Rectangle :_debf .applyFitMode (_cad );return _debf .Height ()+_debf ._egecg .Top +_debf ._egecg .Bottom +_debf ._dedg ;case *Ellipse :_debf .applyFitMode (_cad );
return _debf .Height ()+_debf ._ebbed .Top +_debf ._ebbed .Bottom ;case *Division :return _debf .ctxHeight (_cad )+_debf ._bdbe .Top +_debf ._bdbe .Bottom +_debf ._egfg .Top +_debf ._egfg .Bottom ;case *Table :_debf .updateRowHeights (_cad -_debf ._gbdab .Left -_debf ._gbdab .Right );
return _debf .Height ()+_debf ._gbdab .Top +_debf ._gbdab .Bottom ;case *List :return _debf .ctxHeight (_cad )+_debf ._afbf .Top +_debf ._afbf .Bottom ;case marginDrawable :_ ,_ ,_eegdd ,_defc :=_debf .GetMargins ();return _debf .Height ()+_eegdd +_defc ;
default:return _debf .Height ();};};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_baaf *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_baaf ._ggaf .Left =left ;_baaf ._ggaf .Right =right ;_baaf ._ggaf .Top =top ;_baaf ._ggaf .Bottom =bottom ;};func (_cdfd *GraphicSVGElement )drawRect (_bdabe *_ca .ContentCreator ,_acbfb *_cd .PdfPageResources ){_bdabe .Add_q ();
_cdfd .Style .toContentStream (_bdabe ,_acbfb ,_cdfd );_cabab ,_acgfe :=_cagdb (_cdfd .Attributes ["\u0078"],64);if _acgfe !=nil {_dc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0078\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_acgfe .Error ());
};_gaede ,_acgfe :=_cagdb (_cdfd .Attributes ["\u0079"],64);if _acgfe !=nil {_dc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0079\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_acgfe .Error ());
};_cbcgd ,_acgfe :=_cagdb (_cdfd .Attributes ["\u0077\u0069\u0064t\u0068"],64);if _acgfe !=nil {_dc .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0073\u0074\u0072\u006f\u006b\u0065\u0020\u0077\u0069\u0064\u0074\u0068\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_acgfe .Error ());
};_bgebd ,_acgfe :=_cagdb (_cdfd .Attributes ["\u0068\u0065\u0069\u0067\u0068\u0074"],64);if _acgfe !=nil {_dc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0077h\u0069\u006c\u0065 \u0070\u0061\u0072\u0073i\u006e\u0067\u0020\u0073\u0074\u0072\u006f\u006b\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_acgfe .Error ());
};_bdabe .Add_re (_cabab *_cdfd ._ddccg ,_gaede *_cdfd ._ddccg ,_cbcgd *_cdfd ._ddccg ,_bgebd *_cdfd ._ddccg );_cdfd .Style .fillStroke (_bdabe );_bdabe .Add_Q ();};func (_aadeb *templateProcessor )parseLinkAttr (_efaee ,_bcac string )*_cd .PdfAnnotation {_bcac =_gb .TrimSpace (_bcac );
if _gb .HasPrefix (_bcac ,"\u0075\u0072\u006c(\u0027")&&_gb .HasSuffix (_bcac ,"\u0027\u0029")&&len (_bcac )> 7{return _ccggb (_bcac [5:len (_bcac )-2]);};if _gb .HasPrefix (_bcac ,"\u0070\u0061\u0067e\u0028")&&_gb .HasSuffix (_bcac ,"\u0029")&&len (_bcac )> 6{var (_afgee error ;
_geeeb int64 ;_egdcf float64 ;_bfgbd float64 ;_caggc =1.0;_adbcc =_gb .Split (_bcac [5:len (_bcac )-1],"\u002c"););_geeeb ,_afgee =_ge .ParseInt (_gb .TrimSpace (_adbcc [0]),10,64);if _afgee !=nil {_dc .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_afgee );
return nil ;};if len (_adbcc )>=2{_egdcf ,_afgee =_ge .ParseFloat (_gb .TrimSpace (_adbcc [1]),64);if _afgee !=nil {_dc .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_afgee );
return nil ;};};if len (_adbcc )>=3{_bfgbd ,_afgee =_ge .ParseFloat (_gb .TrimSpace (_adbcc [2]),64);if _afgee !=nil {_dc .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_afgee );
return nil ;};};if len (_adbcc )>=4{_caggc ,_afgee =_ge .ParseFloat (_gb .TrimSpace (_adbcc [3]),64);if _afgee !=nil {_dc .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_afgee );
return nil ;};};return _afea (_geeeb -1,_egdcf ,_bfgbd ,_caggc );};return nil ;};func (_ffgf *TextChunk )clone ()*TextChunk {_eddeg :=*_ffgf ;_eddeg ._ccbfe =_gbbef (_ffgf ._ccbfe );return &_eddeg ;};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_gffe *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _abcf (number ,title ,page ,level ,style );};

// SetColorRight sets border color for right.
func (_bf *border )SetColorRight (col Color ){_bf ._fbdc =col };

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_eacg *Division )EnablePageWrap (enable bool ){_eacg ._fcdc =enable };func _adb (_acba int )*Grid {_aebgb :=&Grid {_faca :_acba ,_ggca :10.0,_aagd :[]float64 {}};_aebgb .resetColumnWidths ();return _aebgb ;};

// SetStyleRight sets border style for right side.
func (_ffc *border )SetStyleRight (style CellBorderStyle ){_ffc ._agc =style };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_deec *Chapter )SetShowNumbering (show bool ){_deec ._fbgf =show ;_deec ._cgcg .SetText (_deec .headingText ());};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// Scale block by specified factors in the x and y directions.
func (_agb *Block )Scale (sx ,sy float64 ){_db :=_ca .NewContentCreator ().Scale (sx ,sy ).Operations ();*_agb ._df =append (*_db ,*_agb ._df ...);_agb ._df .WrapIfNeeded ();_agb ._cef *=sx ;_agb ._dff *=sy ;};type listItem struct{_adfbbg VectorDrawable ;
_geed TextChunk ;};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_cedde *Line )SetFitMode (fitMode FitMode ){_cedde ._bffef =fitMode };

// SetDate sets the date of the invoice.
func (_adfbb *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_adfbb ._aecde [1].Value =date ;return _adfbb ._aecde [0],_adfbb ._aecde [1];};func (_dbde *pageTransformations )transformBlock (_fgge *Block ){if _dbde ._ace !=nil {_fgge .transform (*_dbde ._ace );
};};

// SetMarkedContentID sets the marked content id for the line.
func (_bfeff *Line )SetMarkedContentID (mcid int64 )*_cd .KDict {_bfeff ._ecdga =&mcid ;_gcdfb :=_cd .NewKDictionary ();_gcdfb .S =_bc .MakeName (_cd .StructureTypeFigure );_gcdfb .K =_bc .MakeInteger (mcid );return _gcdfb ;};func _ccggb (_ggdfgb string )*_cd .PdfAnnotation {_cbge :=_cd .NewPdfAnnotationLink ();
_bbfgc :=_cd .NewBorderStyle ();_bbfgc .SetBorderWidth (0);_cbge .BS =_bbfgc .ToPdfObject ();_gbac :=_cd .NewPdfActionURI ();_gbac .URI =_bc .MakeString (_ggdfgb );_cbge .SetAction (_gbac .PdfAction );return _cbge .PdfAnnotation ;};

// SetMarkedContentID sets the marked content ID.
func (_fdag *PolyBezierCurve )SetMarkedContentID (mcid int64 )*_cd .KDict {_fdag ._afdg =&mcid ;_bffc :=_cd .NewKDictionary ();_bffc .S =_bc .MakeName (_cd .StructureTypeFigure );_bffc .K =_bc .MakeInteger (mcid );return _bffc ;};

// SetMarkedContentID sets marked content ID.
func (_eabe *GraphicSVG )SetMarkedContentID (mcid int64 )*_cd .KDict {_eabe ._dcceb =&mcid ;_fagb :=_cd .NewKDictionary ();_fagb .S =_bc .MakeName (_cd .StructureTypeFigure );_fagb .K =_bc .MakeInteger (mcid );return _fagb ;};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_eafd *Invoice )SetNoteStyle (style TextStyle ){_eafd ._cac =style };

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_cgdg *StyledParagraph )SetLanguageIdentifier (id string ){_cgdg ._begca =id };

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_dbgf *GraphicSVGElement ;_bffac Positioning ;_gdbe float64 ;_abcd float64 ;_ddddf Margins ;_dcceb *int64 ;};

// SetOpacity sets opacity for Image.
func (_cfaae *Image )SetOpacity (opacity float64 ){_cfaae ._fceb =opacity };func (_ggbee *templateProcessor )parseTextChunk (_bcegd *templateNode ,_bddba *TextChunk )(interface{},error ){if _bcegd ._fafg ==nil {_ggbee .nodeLogError (_bcegd ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_bfcee ;};var (_fcfa =_ggbee .creator .NewTextStyle ();_cffc bool ;);for _ ,_adead :=range _bcegd ._egac .Attr {if _adead .Name .Local =="\u006c\u0069\u006e\u006b"{_facdb ,_feeg :=_bcegd ._fafg ._bedgb .(*StyledParagraph );if !_feeg {_ggbee .nodeLogError (_bcegd ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_cffc =true ;}else {_fcfa =_facdb ._caefe ;};break ;};};if _bddba ==nil {_bddba =NewTextChunk ("",_fcfa );};for _ ,_gbec :=range _bcegd ._egac .Attr {_dffe :=_gbec .Value ;switch _degcd :=_gbec .Name .Local ;_degcd {case "\u0063\u006f\u006co\u0072":_bddba .Style .Color =_ggbee .parseColorAttr (_degcd ,_dffe );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_bddba .Style .OutlineColor =_ggbee .parseColorAttr (_degcd ,_dffe );case "\u0066\u006f\u006e\u0074":_bddba .Style .Font =_ggbee .parseFontAttr (_degcd ,_dffe );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_bddba .Style .FontSize =_ggbee .parseFloatAttr (_degcd ,_dffe );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_bddba .Style .OutlineSize =_ggbee .parseFloatAttr (_degcd ,_dffe );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_bddba .Style .CharSpacing =_ggbee .parseFloatAttr (_degcd ,_dffe );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_bddba .Style .HorizontalScaling =_ggbee .parseFloatAttr (_degcd ,_dffe );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_bddba .Style .RenderingMode =_ggbee .parseTextRenderingModeAttr (_degcd ,_dffe );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_bddba .Style .Underline =_ggbee .parseBoolAttr (_degcd ,_dffe );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_bddba .Style .UnderlineStyle .Color =_ggbee .parseColorAttr (_degcd ,_dffe );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_bddba .Style .UnderlineStyle .Offset =_ggbee .parseFloatAttr (_degcd ,_dffe );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_bddba .Style .UnderlineStyle .Thickness =_ggbee .parseFloatAttr (_degcd ,_dffe );
case "\u006c\u0069\u006e\u006b":if !_cffc {_bddba .AddAnnotation (_ggbee .parseLinkAttr (_degcd ,_dffe ));};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_bddba .Style .TextRise =_ggbee .parseFloatAttr (_degcd ,_dffe );default:_ggbee .nodeLogDebug (_bcegd ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_degcd );
};};return _bddba ,nil ;};

// ParseFromSVGString creates a GraphicSVG instance from string SVG.
func ParseFromSVGString (svgStr string )(*GraphicSVGElement ,error ){return ParseFromSVGStream (_gb .NewReader (svgStr ));};

// SetAnnotation sets an annotation on a TextChunk,
// this will replace any existing annotation that has been set.
// Supplying a nil value as parameter would clear all the annotations.
func (_ccedb *TextChunk )SetAnnotation (annotation *_cd .PdfAnnotation ){if annotation ==nil {_ccedb .ClearAnnotations ();}else {_ccedb ._ccbfe =[]*_cd .PdfAnnotation {annotation };};};

// SetStyleBottom sets border style for bottom side.
func (_decd *border )SetStyleBottom (style CellBorderStyle ){_decd ._fage =style };

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_eegd _de .ChartRenderable ;_edbd Positioning ;_bbcf float64 ;_cfcg float64 ;_fdg Margins ;_daa *int64 ;};func _afe (_fbec string )string {_fdc :=_adgd .FindAllString (_fbec ,-1);if len (_fdc )==0{_fbec =_fbec +"\u0030";}else {_ceee ,_afg :=_ge .Atoi (_fdc [len (_fdc )-1]);
if _afg !=nil {_dc .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_afg );
_fbec =_fbec +"\u0030";}else {_ceee ++;_dbf :=_gb .LastIndex (_fbec ,_fdc [len (_fdc )-1]);if _dbf ==-1{_fbec =_a .Sprintf ("\u0025\u0073\u0025\u0064",_fbec [:len (_fbec )-1],_ceee );}else {_fbec =_fbec [:_dbf ]+_ge .Itoa (_ceee );};};};return _fbec ;};


// SetMargins sets the margins of the paragraph.
func (_cffgg *List )SetMargins (left ,right ,top ,bottom float64 ){_cffgg ._afbf .Left =left ;_cffgg ._afbf .Right =right ;_cffgg ._afbf .Top =top ;_cffgg ._afbf .Bottom =bottom ;};func (_gac *Block )SetMarkedContentID (id int64 )*_cd .KDict {return nil };
func _dddef (_cefdg *templateProcessor ,_feecc *templateNode )(interface{},error ){return _cefdg .parseRectangle (_feecc );};

// TitleStyle returns the style properties used to render the invoice title.
func (_bee *Invoice )TitleStyle ()TextStyle {return _bee ._ggbef };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_effa *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _effa ._cafc .Left ,_effa ._cafc .Right ,_effa ._cafc .Top ,_effa ._cafc .Bottom ;};

// SetMaxLines sets the maximum number of lines to be drawn.
func (_faff *StyledParagraph )SetMaxLines (maxLines int ){_faff ._bbbf =maxLines };

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_gcdgf *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_gcdgf ._ebeec =&_cd .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// GetIndent get the cell's left indent.
func (_abafa *TableCell )GetIndent ()float64 {return _abafa ._dccbb };

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_bfde *_fg .Polyline ;_gbcb float64 ;_cgfe *int64 ;};

// SetBorderOpacity sets the border opacity.
func (_adgcb *Polygon )SetBorderOpacity (opacity float64 ){_adgcb ._gcgd =opacity };

// AddTotalLine adds a new line in the invoice totals table.
func (_gggc *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_gbaf :=&InvoiceCell {_gggc ._afaa ,desc };_dcbbec :=&InvoiceCell {_gggc ._afaa ,value };_gggc ._aeda =append (_gggc ._aeda ,[2]*InvoiceCell {_gbaf ,_dcbbec });return _gbaf ,_dcbbec ;
};func (_fbefe *Table )clone ()*Table {_ebfbf :=*_fbefe ;_ebfbf ._cbaab =make ([]float64 ,len (_fbefe ._cbaab ));copy (_ebfbf ._cbaab ,_fbefe ._cbaab );_ebfbf ._fbce =make ([]float64 ,len (_fbefe ._fbce ));copy (_ebfbf ._fbce ,_fbefe ._fbce );_ebfbf ._bbdb =make ([]*TableCell ,0,len (_fbefe ._bbdb ));
for _ ,_fdcae :=range _fbefe ._bbdb {_ggfed :=*_fdcae ;_ggfed ._dgfeac =&_ebfbf ;_ebfbf ._bbdb =append (_ebfbf ._bbdb ,&_ggfed );};return &_ebfbf ;};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_eccf *Ellipse )BorderOpacity ()float64 {return _eccf ._daaca };

// SetNotes sets the notes section of the invoice.
func (_bafa *Invoice )SetNotes (title ,content string ){_bafa ._efec =[2]string {title ,content }};

// ParseFromSVGStream creates a GraphicSVG instance from SVG stream input.
func ParseFromSVGStream (source _ea .Reader )(*GraphicSVGElement ,error ){_gcgcgf :=_b .NewDecoder (source );_gcgcgf .CharsetReader =_ce .NewReaderLabel ;_ceddbb ,_bcabg :=_agbdc (_gcgcgf );if _bcabg !=nil {return nil ,_bcabg ;};if _baagg :=_ceddbb .Decode (_gcgcgf );
_baagg !=nil &&_baagg !=_ea .EOF {return nil ,_baagg ;};return _ceddbb ,nil ;};func _gaeee (_abcgf []token ,_aafag string )([]token ,string ){if _aafag !=""{_abcgf =append (_abcgf ,token {_aafag ,false });_aafag ="";};return _abcgf ,_aafag ;};func (_gdfdea *templateProcessor )parseCellVerticalAlignmentAttr (_ceddc ,_dcafb string )CellVerticalAlignment {_dc .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ceddc ,_dcafb );
_agdbf :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_dcafb ];return _agdbf ;
};

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _dad (svgStr )};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_eafe *Table )Width ()float64 {return 0};func (_ggefb *templateProcessor )parseFloatAttr (_ggbec ,_baecac string )float64 {_dc .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_ggbec ,_baecac );
_cfgd ,_ :=_ge .ParseFloat (_baecac ,64);return _cfgd ;};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_gacc *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gacc ._dfc .Left ,_gacc ._dfc .Right ,_gacc ._dfc .Top ,_gacc ._dfc .Bottom ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_beddb *Creator )DrawHeader (drawHeaderFunc func (_cabfe *Block ,_fgea HeaderFunctionArgs )){_beddb ._aegb =drawHeaderFunc ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_ffce *List )SetIndent (indent float64 ){_ffce ._acag =indent ;_ffce ._fdeafc =false };

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_fdfd *Rectangle )ScaleToWidth (w float64 ){_cfabg :=_fdfd ._dbab /_fdfd ._dcdaf ;_fdfd ._dcdaf =w ;_fdfd ._dbab =w *_cfabg ;};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_aabg *Invoice )SetAddressStyle (style TextStyle ){_aabg ._daacd =style };func (_bacff *StyledParagraph )addLine (_ceffb []*TextChunk )bool {if _bacff ._bbbf > 0&&len (_bacff ._aeca )+1>=_bacff ._bbbf {if len (_ceffb )> 0{_bacff ._aeca =append (_bacff ._aeca ,_ceffb );
};return false ;};_bacff ._aeca =append (_bacff ._aeca ,_ceffb );return true ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_aebef *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _aebef ._adfbe [0],_aebef ._adfbe [1];};func (_gdeec *templateProcessor )parseFloatArray (_afdee ,_gbfe string )[]float64 {_dc .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_afdee ,_gbfe );
_fafgf :=_gb .Fields (_gbfe );_bcdac :=make ([]float64 ,0,len (_fafgf ));for _ ,_dfcad :=range _fafgf {_fbcdbc ,_ :=_ge .ParseFloat (_dfcad ,64);_bcdac =append (_bcdac ,_fbcdbc );};return _bcdac ;};

// Height returns the height of the ellipse.
func (_cea *Ellipse )Height ()float64 {return _cea ._geeg };func (_febb *TableCell )height (_gdbad float64 )float64 {var _cbffe float64 ;switch _afeb :=_febb ._fagd .(type ){case *Paragraph :if _afeb ._aacba {_afeb .SetWidth (_gdbad -_febb ._dccbb -_afeb ._cafc .Left -_afeb ._cafc .Right );
};_cbffe =_afeb .Height ()+_afeb ._cafc .Top +_afeb ._cafc .Bottom ;if !_febb ._dgfeac ._abddd {_cbffe +=(0.5*_afeb ._ebab *_afeb ._dbfac );};case *StyledParagraph :if _afeb ._ccbe {_afeb .SetWidth (_gdbad -_febb ._dccbb -_afeb ._gebac .Left -_afeb ._gebac .Right );
};_cbffe =_afeb .Height ()+_afeb ._gebac .Top +_afeb ._gebac .Bottom ;if !_febb ._dgfeac ._abddd {_cbffe +=(0.5*_afeb .getTextHeight ());};case *Image :_afeb .applyFitMode (_gdbad -_febb ._dccbb );_cbffe =_afeb .Height ()+_afeb ._fega .Top +_afeb ._fega .Bottom ;
case *Table :_afeb .updateRowHeights (_gdbad -_febb ._dccbb -_afeb ._gbdab .Left -_afeb ._gbdab .Right );_cbffe =_afeb .Height ()+_afeb ._gbdab .Top +_afeb ._gbdab .Bottom ;case *List :_cbffe =_afeb .ctxHeight (_gdbad -_febb ._dccbb )+_afeb ._afbf .Top +_afeb ._afbf .Bottom ;
case *Division :_cbffe =_afeb .ctxHeight (_gdbad -_febb ._dccbb )+_afeb ._bdbe .Top +_afeb ._bdbe .Bottom +_afeb ._egfg .Top +_afeb ._egfg .Bottom ;case *Chart :_cbffe =_afeb .Height ()+_afeb ._fdg .Top +_afeb ._fdg .Bottom ;case *Rectangle :_afeb .applyFitMode (_gdbad -_febb ._dccbb );
_cbffe =_afeb .Height ()+_afeb ._egecg .Top +_afeb ._egecg .Bottom +_afeb ._dedg ;case *Ellipse :_afeb .applyFitMode (_gdbad -_febb ._dccbb );_cbffe =_afeb .Height ()+_afeb ._ebbed .Top +_afeb ._ebbed .Bottom ;case *Line :_cbffe =_afeb .Height ()+_afeb ._adbf .Top +_afeb ._adbf .Bottom ;
};return _cbffe ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_abd *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dea :=ctx ;if _abd ._bdc .IsRelative (){ctx .X +=_abd ._ggaf .Left ;ctx .Y +=_abd ._ggaf .Top ;ctx .Width -=_abd ._ggaf .Left +_abd ._ggaf .Right ;ctx .Height -=_abd ._ggaf .Top ;
};_egf ,_fgbd ,_bfb :=_abd ._cgcg .GeneratePageBlocks (ctx );if _bfb !=nil {return _egf ,ctx ,_bfb ;};ctx =_fgbd ;_bgg :=ctx .X ;_efbd :=ctx .Y -_abd ._cgcg .Height ();_eadd :=int64 (ctx .Page );_gda :=_abd .headingNumber ();_age :=_abd .headingText ();
if _abd ._eefa {_daed :=_abd ._cag .Add (_gda ,_abd ._dfcf ,_ge .FormatInt (_eadd ,10),_abd ._gfa );if _abd ._cag ._gbeeg {_daed .SetLink (_eadd ,_bgg ,_efbd );};};if _abd ._ffbb ==nil {_abd ._ffbb =_cd .NewOutlineItem (_age ,_cd .NewOutlineDest (_eadd -1,_bgg ,_efbd ));
if _abd ._bceb !=nil {_abd ._bceb ._ffbb .Add (_abd ._ffbb );}else {_abd ._fad .Add (_abd ._ffbb );};}else {_gebg :=&_abd ._ffbb .Dest ;_gebg .Page =_eadd -1;_gebg .X =_bgg ;_gebg .Y =_efbd ;};for _ ,_ccda :=range _abd ._aed {_fgbg ,_adf ,_dfa :=_ccda .GeneratePageBlocks (ctx );
if _dfa !=nil {return _egf ,ctx ,_dfa ;};if len (_fgbg )< 1{continue ;};_egf [len (_egf )-1].mergeBlocks (_fgbg [0]);_egf =append (_egf ,_fgbg [1:]...);ctx =_adf ;};if _abd ._bdc .IsRelative (){ctx .X =_dea .X ;};if _abd ._bdc .IsAbsolute (){return _egf ,_dea ,nil ;
};return _egf ,ctx ,nil ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_aeced *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_aeced ._fdad =append (_aeced ._fdad ,line );return line ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_adfe *Image )SetMargins (left ,right ,top ,bottom float64 ){_adfe ._fega .Left =left ;_adfe ._fega .Right =right ;_adfe ._fega .Top =top ;_adfe ._fega .Bottom =bottom ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_bdade *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _ga .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _ga .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _ga .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_bdade ._aagga =true ;_bdade ._bfbdae =startRow ;_bdade ._gedae =endRow ;return nil ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_ebbgc *Invoice )SetTerms (title ,content string ){_ebbgc ._agagf =[2]string {title ,content }};func _cbe (_cccfa _b .StartElement )*GraphicSVGElement {_cgfgd :=&GraphicSVGElement {};_bcee :=make (map[string ]string );for _ ,_fged :=range _cccfa .Attr {_bcee [_fged .Name .Local ]=_fged .Value ;
};_cgfgd .Name =_cccfa .Name .Local ;_cgfgd .Attributes =_bcee ;_cgfgd ._ddccg =1;if _cgfgd .Name =="\u0073\u0076\u0067"{_bgad ,_acac :=_cgbeg (_bcee ["\u0076i\u0065\u0077\u0042\u006f\u0078"]);if _acac !=nil {_dc .Log .Debug ("\u0055\u006ea\u0062\u006c\u0065\u0020t\u006f\u0020p\u0061\u0072\u0073\u0065\u0020\u0076\u0069\u0065w\u0042\u006f\u0078\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074e\u003a\u0020\u0025\u0076",_acac );
return nil ;};if len (_bgad )>=4{_cgfgd .ViewBox .X =_bgad [0];_cgfgd .ViewBox .Y =_bgad [1];_cgfgd .ViewBox .W =_bgad [2];_cgfgd .ViewBox .H =_bgad [3];};_cgfgd .Width =_cgfgd .ViewBox .W ;_cgfgd .Height =_cgfgd .ViewBox .H ;if _gfdg ,_ebe :=_bcee ["\u0077\u0069\u0064t\u0068"];
_ebe {if _gb .HasSuffix (_gfdg ,"\u0025"){_befa ,_bfae :=_ge .ParseFloat (_gb .TrimSuffix (_gfdg ,"\u0025"),64);if _bfae !=nil {_dc .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0077\u0069\u0064\u0074\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_bfae );
return nil ;};_cgfgd .Width =_befa *_cgfgd .ViewBox .W ;}else {_agfag ,_gbbfd :=_cagdb (_gfdg ,64);if _gbbfd !=nil {_dc .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0077\u0069\u0064\u0074\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_gbbfd );
return nil ;};_cgfgd .Width =_agfag ;if len (_bgad )< 4{_cgfgd .ViewBox .W =_agfag ;};};};if _dfbf ,_ggg :=_bcee ["\u0068\u0065\u0069\u0067\u0068\u0074"];_ggg {if _gb .HasSuffix (_dfbf ,"\u0025"){_adfa ,_gcad :=_ge .ParseFloat (_gb .TrimSuffix (_dfbf ,"\u0025"),64);
if _gcad !=nil {_dc .Log .Debug ("\u0055\u006eab\u006c\u0065\u0020t\u006f\u0020\u0070\u0061rse\u0020he\u0069\u0067\u0068\u0074\u0020\u0061\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_gcad );return nil ;};_cgfgd .Height =_adfa *_cgfgd .ViewBox .H ;
}else {_dbbg ,_agagc :=_cagdb (_dfbf ,64);if _agagc !=nil {_dc .Log .Debug ("\u0055\u006eab\u006c\u0065\u0020t\u006f\u0020\u0070\u0061rse\u0020he\u0069\u0067\u0068\u0074\u0020\u0061\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_agagc );return nil ;
};_cgfgd .Height =_dbbg ;if len (_bgad )< 4{_cgfgd .ViewBox .H =_dbbg ;};};};if _cgfgd .Width > 0&&_cgfgd .Height > 0{_cgfgd ._ddccg =_cgfgd .Width /_cgfgd .ViewBox .W ;};};return _cgfgd ;};

// SetMargins sets the Paragraph's margins.
func (_fdge *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_fdge ._cafc .Left =left ;_fdge ._cafc .Right =right ;_fdge ._cafc .Top =top ;_fdge ._cafc .Bottom =bottom ;};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);func (_fcfd *GraphicSVGElement )drawCircle (_ebfa *_ca .ContentCreator ,_eccfd *_cd .PdfPageResources ){_ebfa .Add_q ();
_fcfd .Style .toContentStream (_ebfa ,_eccfd ,_fcfd );_ecbbc ,_dabf :=_cagdb (_fcfd .Attributes ["\u0063\u0078"],64);if _dabf !=nil {_dc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_dabf .Error ());
};_eccce ,_dabf :=_cagdb (_fcfd .Attributes ["\u0063\u0079"],64);if _dabf !=nil {_dc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_dabf .Error ());
};_edef ,_dabf :=_cagdb (_fcfd .Attributes ["\u0072"],64);if _dabf !=nil {_dc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0072\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_dabf .Error ());
};_bccga :=_edef *_fcfd ._ddccg ;_abaac :=_edef *_fcfd ._ddccg ;_abfb :=_bccga *_aebe ;_cbdafa :=_abaac *_aebe ;_egcfea :=_fg .NewCubicBezierPath ();_egcfea =_egcfea .AppendCurve (_fg .NewCubicBezierCurve (-_bccga ,0,-_bccga ,_cbdafa ,-_abfb ,_abaac ,0,_abaac ));
_egcfea =_egcfea .AppendCurve (_fg .NewCubicBezierCurve (0,_abaac ,_abfb ,_abaac ,_bccga ,_cbdafa ,_bccga ,0));_egcfea =_egcfea .AppendCurve (_fg .NewCubicBezierCurve (_bccga ,0,_bccga ,-_cbdafa ,_abfb ,-_abaac ,0,-_abaac ));_egcfea =_egcfea .AppendCurve (_fg .NewCubicBezierCurve (0,-_abaac ,-_abfb ,-_abaac ,-_bccga ,-_cbdafa ,-_bccga ,0));
_egcfea =_egcfea .Offset (_ecbbc *_fcfd ._ddccg ,_eccce *_fcfd ._ddccg );if _fcfd .Style .StrokeWidth > 0{_egcfea =_egcfea .Offset (_fcfd .Style .StrokeWidth /2,_fcfd .Style .StrokeWidth /2);};_fg .DrawBezierPathWithCreator (_egcfea ,_ebfa );_fcfd .Style .fillStroke (_ebfa );
_ebfa .Add_h ();_ebfa .Add_Q ();};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_eegg *Creator )SetForms (form *_cd .PdfAcroForm )error {_eegg ._fgaa =form ;return nil };func _dcaf (_dbcd ,_gebfb ,_ffba ,_eabc ,_accb ,_ccdb float64 )*Curve {_bece :=&Curve {};_bece ._bdafe =_dbcd ;_bece ._caff =_gebfb ;_bece ._baeg =_ffba ;_bece ._ebaf =_eabc ;
_bece ._beac =_accb ;_bece ._bggc =_ccdb ;_bece ._acge =ColorBlack ;_bece ._dbdf =1.0;return _bece ;};func _ddab (_facb *Block ,_gfgf *Image ,_acdd DrawContext )(DrawContext ,error ){_bbce :=_acdd ;_beace :=1;_bacf :=_bc .PdfObjectName (_a .Sprintf ("\u0049\u006d\u0067%\u0064",_beace ));
for _facb ._bcb .HasXObjectByName (_bacf ){_beace ++;_bacf =_bc .PdfObjectName (_a .Sprintf ("\u0049\u006d\u0067%\u0064",_beace ));};_ffbba :=_facb ._bcb .SetXObjectImageByNameLazy (_bacf ,_gfgf ._gcfb ,_gfgf ._eecf );if _ffbba !=nil {return _acdd ,_ffbba ;
};_adbc :=0;_cead :=_bc .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_adbc ));for _facb ._bcb .HasExtGState (_cead ){_adbc ++;_cead =_bc .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_adbc ));};_cccg :=_bc .MakeDict ();_cccg .Set ("\u0042\u004d",_bc .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));
if _gfgf ._fceb < 1.0{_cccg .Set ("\u0043\u0041",_bc .MakeFloat (_gfgf ._fceb ));_cccg .Set ("\u0063\u0061",_bc .MakeFloat (_gfgf ._fceb ));};_ffbba =_facb ._bcb .AddExtGState (_cead ,_bc .MakeIndirectObject (_cccg ));if _ffbba !=nil {return _acdd ,_ffbba ;
};_cddea :=_gfgf .Width ();_defa :=_gfgf .Height ();_ ,_decfe :=_gfgf .rotatedSize ();_cdfga :=_acdd .X ;_aeeac :=_acdd .PageHeight -_acdd .Y -_defa ;if _gfgf ._fabb .IsRelative (){_aeeac -=(_decfe -_defa )/2;switch _gfgf ._cgef {case HorizontalAlignmentCenter :_cdfga +=(_acdd .Width -_cddea )/2;
case HorizontalAlignmentRight :_cdfga =_acdd .PageWidth -_acdd .Margins .Right -_gfgf ._fega .Right -_cddea ;};};_bcad :=_gfgf ._adca ;_bgcc :=_ca .NewContentCreator ();if _gfgf ._ffdce !=nil {_bgcc .Add_BDC (*_bc .MakeName (_cd .StructureTypeFigure ),map[string ]_bc .PdfObject {"\u004d\u0043\u0049\u0044":_bc .MakeInteger (*_gfgf ._ffdce )});
};_bgcc .Add_gs (_cead );_bgcc .Translate (_cdfga ,_aeeac );if _bcad !=0{_bgcc .Translate (_cddea /2,_defa /2);_bgcc .RotateDeg (_bcad );_bgcc .Translate (-_cddea /2,-_defa /2);};_bgcc .Scale (_cddea ,_defa ).Add_Do (_bacf );if _gfgf ._ffdce !=nil {_bgcc .Add_EMC ();
};_bffd :=_bgcc .Operations ();_bffd .WrapIfNeeded ();_facb .addContents (_bffd );if _gfgf ._fabb .IsRelative (){_acdd .Y +=_decfe ;_acdd .Height -=_decfe ;return _acdd ,nil ;};return _bbce ,nil ;};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_fgdbb *Table )MultiCell (rowspan ,colspan int )*TableCell {_fgdbb ._degcf ++;_cgcgge :=(_fgdbb .moveToNextAvailableCell ()-1)%(_fgdbb ._gfgc )+1;_cedac :=(_fgdbb ._degcf -1)/_fgdbb ._gfgc +1;for _cedac > _fgdbb ._agga {_fgdbb ._agga ++;_fgdbb ._cbaab =append (_fgdbb ._cbaab ,_fgdbb ._cdgee );
};_gdegb :=&TableCell {};_gdegb ._badcc =_cedac ;_gdegb ._gdgcb =_cgcgge ;_gdegb ._dccbb =5;_gdegb ._baef =CellBorderStyleNone ;_gdegb ._dacd =_fg .LineStyleSolid ;_gdegb ._fdcfa =CellHorizontalAlignmentLeft ;_gdegb ._dcgcb =CellVerticalAlignmentTop ;_gdegb ._bfgb =0;
_gdegb ._dabfb =0;_gdegb ._efdac =0;_gdegb ._ebbgd =0;_gaada :=ColorBlack ;_gdegb ._cbea =_gaada ;_gdegb ._efffe =_gaada ;_gdegb ._cefef =_gaada ;_gdegb ._bcfdc =_gaada ;_gdegb ._cgfge =1.0;if rowspan < 1{_dc .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_ggbf :=_fgdbb ._agga -(_gdegb ._badcc -1);if rowspan > _ggbf {_dc .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_ggbf );
_fgdbb ._agga +=rowspan -1;for _bdbga :=0;_bdbga <=rowspan -_ggbf ;_bdbga ++{_fgdbb ._cbaab =append (_fgdbb ._cbaab ,_fgdbb ._cdgee );};};for _ebabb :=0;_ebabb < colspan &&_cgcgge +_ebabb -1< len (_fgdbb ._degb );_ebabb ++{_fgdbb ._degb [_cgcgge +_ebabb -1]=rowspan -1;
};_gdegb ._gddee =rowspan ;if colspan < 1{_dc .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_ecee :=_fgdbb ._gfgc -(_gdegb ._gdgcb -1);if colspan > _ecee {_dc .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_ecee );
colspan =_ecee ;};_gdegb ._abfbd =colspan ;_fgdbb ._degcf +=colspan -1;_fgdbb ._bbdb =append (_fgdbb ._bbdb ,_gdegb );_gdegb ._dgfeac =_fgdbb ;return _gdegb ;};func _fgaae ()*listItem {return &listItem {}};func (_ffede *templateProcessor )parseImageEncoder (_eaabc ,_eefde string )_bc .StreamEncoder {_dc .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074e\u003a\u0020\u0028\u0060\u0025s\u0060\u002c \u0025\u0073\u0029\u002e",_eaabc ,_eefde );
if _eefde =="\u0066\u006c\u0061t\u0065"{return _bc .NewFlateEncoder ();}else if _eefde =="\u0064\u0063\u0074"{return _bc .NewDCTEncoder ();};_dc .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0076\u0061\u006cu\u0065\u0020\u006f\u0066 \u0065\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u0020\u0066\u006f\u0075\u006e\u0064\u002e",_eaabc ,_eefde );
return nil ;};func (_ebdee rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _ebdee ._dcf ,_ebdee ._fagc ,_ebdee ._bac ;};func (_agaag *templateProcessor )parseFontAttr (_fbdcgc ,_egbeb string )*_cd .PdfFont {_dc .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_fbdcgc ,_egbeb );
_ebcbfd :=_agaag .creator ._becdg ;if _egbeb ==""{return _ebcbfd ;};_dgfcc :=_gb .Split (_egbeb ,"\u002c");for _ ,_bgbg :=range _dgfcc {_bgbg =_gb .TrimSpace (_bgbg );if _bgbg ==""{continue ;};_bdbgge ,_bddf :=_agaag ._cebde .FontMap [_egbeb ];if _bddf {return _bdbgge ;
};_eacb ,_bddf :=map[string ]_cd .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_cd .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_cd .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_cd .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_cd .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_cd .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_cd .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_cd .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_cd .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_cd .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_cd .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_cd .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_cd .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_cd .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_cd .TimesBoldItalicName }[_egbeb ];
if _bddf {if _gffccb ,_ebfeb :=_cd .NewStandard14Font (_eacb );_ebfeb ==nil {return _gffccb ;};};if _gadbb :=_agaag .parseAttrPropList (_bgbg );len (_gadbb )> 0{if _afdge ,_ceceg :=_gadbb ["\u0070\u0061\u0074\u0068"];_ceceg {_gabac :=_cd .NewPdfFontFromTTFFile ;
if _gfafd ,_cdff :=_gadbb ["\u0074\u0079\u0070\u0065"];_cdff &&_gfafd =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_gabac =_cd .NewCompositePdfFontFromTTFFile ;};if _eccbf ,_gadgf :=_gabac (_afdge );_gadgf !=nil {_dc .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_afdge ,_gadgf );
}else {return _eccbf ;};};};};return _ebcbfd ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_cedae *TOC )SetShowLinks (showLinks bool ){_cedae ._gbeeg =showLinks };

// TOC returns the table of contents component of the creator.
func (_agbd *Creator )TOC ()*TOC {return _agbd ._bga };

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_feag *Creator )NewStyledParagraph ()*StyledParagraph {return _eeff (_feag .NewTextStyle ())};func (_eade *Division )ctxHeight (_cbdc float64 )float64 {_cbdc -=_eade ._bdbe .Left +_eade ._bdbe .Right +_eade ._egfg .Left +_eade ._egfg .Right ;var _gbbee float64 ;
for _ ,_dfed :=range _eade ._bggcg {_gbbee +=_daedc (_dfed ,_cbdc );};return _gbbee ;};

// SetRowHeight sets the height for a specified row.
func (_egbcg *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_egbcg ._cbaab ){return _ga .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_egbcg ._cbaab [row -1]=h ;return nil ;
};func (_aeece *Image )rotatedSize ()(float64 ,float64 ){_cebb :=_aeece ._gagbb ;_gebc :=_aeece ._cbgg ;_fbcd :=_aeece ._adca ;if _fbcd ==0{return _cebb ,_gebc ;};_aeae :=_fg .Path {Points :[]_fg .Point {_fg .NewPoint (0,0).Rotate (_fbcd ),_fg .NewPoint (_cebb ,0).Rotate (_fbcd ),_fg .NewPoint (0,_gebc ).Rotate (_fbcd ),_fg .NewPoint (_cebb ,_gebc ).Rotate (_fbcd )}}.GetBoundingBox ();
return _aeae .Width ,_aeae .Height ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_ggad *LinearShading )SetExtends (start bool ,end bool ){_ggad ._eadf .SetExtends (start ,end )};

// SetFont sets the Paragraph's font.
func (_eccfg *Paragraph )SetFont (font *_cd .PdfFont ){_eccfg ._fgef =font };func (_cccfd *GraphicSVGElement )drawPath (_bafc *_ca .ContentCreator ,_acage *_cd .PdfPageResources ){_bafc .Add_q ();_cccfd .Style .toContentStream (_bafc ,_acage ,_cccfd );
_acbff (_cccfd ,_bafc );_eece ,_ccecb :=_fgcdf (_cccfd .Attributes ["\u0064"]);if _ccecb !=nil {_dc .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025s",_ccecb .Error ());};var (_aegcf ,_gdcg =0.0,0.0;_cfgaa ,_ebbea =0.0,0.0;_cbba *Command ;);for _ ,_cddg :=range _eece .Subpaths {for _ ,_abae :=range _cddg .Commands {switch _gb .ToLower (_abae .Symbol ){case "\u006d":_cfgaa ,_ebbea =_abae .Params [0]*_cccfd ._ddccg ,_abae .Params [1]*_cccfd ._ddccg ;
if !_abae .isAbsolute (){_cfgaa ,_ebbea =_aegcf +_cfgaa -_cccfd .ViewBox .X ,_gdcg +_ebbea -_cccfd .ViewBox .Y ;};_bafc .Add_m (_aac .RoundFloat (_cfgaa ,3),_aac .RoundFloat (_ebbea ,3));_aegcf ,_gdcg =_cfgaa ,_ebbea ;case "\u0063":_ebdff ,_deaf ,_befb ,_cadfg ,_eebgc ,_gfece :=_abae .Params [0]*_cccfd ._ddccg ,_abae .Params [1]*_cccfd ._ddccg ,_abae .Params [2]*_cccfd ._ddccg ,_abae .Params [3]*_cccfd ._ddccg ,_abae .Params [4]*_cccfd ._ddccg ,_abae .Params [5]*_cccfd ._ddccg ;
if !_abae .isAbsolute (){_ebdff ,_deaf ,_befb ,_cadfg ,_eebgc ,_gfece =_aegcf +_ebdff ,_gdcg +_deaf ,_aegcf +_befb ,_gdcg +_cadfg ,_aegcf +_eebgc ,_gdcg +_gfece ;};_bafc .Add_c (_aac .RoundFloat (_ebdff ,3),_aac .RoundFloat (_deaf ,3),_aac .RoundFloat (_befb ,3),_aac .RoundFloat (_cadfg ,3),_aac .RoundFloat (_eebgc ,3),_aac .RoundFloat (_gfece ,3));
_aegcf ,_gdcg =_eebgc ,_gfece ;case "\u0073":_bfca ,_cbabe ,_fcbff ,_gbda :=_abae .Params [0]*_cccfd ._ddccg ,_abae .Params [1]*_cccfd ._ddccg ,_abae .Params [2]*_cccfd ._ddccg ,_abae .Params [3]*_cccfd ._ddccg ;if !_abae .isAbsolute (){_bfca ,_cbabe ,_fcbff ,_gbda =_aegcf +_bfca ,_gdcg +_cbabe ,_aegcf +_fcbff ,_gdcg +_gbda ;
};_bafc .Add_c (_aac .RoundFloat (_aegcf ,3),_aac .RoundFloat (_gdcg ,3),_aac .RoundFloat (_bfca ,3),_aac .RoundFloat (_cbabe ,3),_aac .RoundFloat (_fcbff ,3),_aac .RoundFloat (_gbda ,3));_aegcf ,_gdcg =_fcbff ,_gbda ;case "\u006c":_bebgd ,_befg :=_abae .Params [0]*_cccfd ._ddccg ,_abae .Params [1]*_cccfd ._ddccg ;
if !_abae .isAbsolute (){_bebgd ,_befg =_aegcf +_bebgd ,_gdcg +_befg ;};_bafc .Add_l (_aac .RoundFloat (_bebgd ,3),_aac .RoundFloat (_befg ,3));_aegcf ,_gdcg =_bebgd ,_befg ;case "\u0068":_agacg :=_abae .Params [0]*_cccfd ._ddccg ;if !_abae .isAbsolute (){_agacg =_aegcf +_agacg ;
};_bafc .Add_l (_aac .RoundFloat (_agacg ,3),_aac .RoundFloat (_gdcg ,3));_aegcf =_agacg ;case "\u0076":_eagg :=_abae .Params [0]*_cccfd ._ddccg ;if !_abae .isAbsolute (){_eagg =_gdcg +_eagg ;};_bafc .Add_l (_aac .RoundFloat (_aegcf ,3),_aac .RoundFloat (_eagg ,3));
_gdcg =_eagg ;case "\u0071":_dbgd ,_dagca ,_fgfg ,_aebdc :=_abae .Params [0]*_cccfd ._ddccg ,_abae .Params [1]*_cccfd ._ddccg ,_abae .Params [2]*_cccfd ._ddccg ,_abae .Params [3]*_cccfd ._ddccg ;if !_abae .isAbsolute (){_dbgd ,_dagca ,_fgfg ,_aebdc =_aegcf +_dbgd ,_gdcg +_dagca ,_aegcf +_fgfg ,_gdcg +_aebdc ;
};_geage ,_dgafg :=_ff .QuadraticToCubicBezier (_aegcf ,_gdcg ,_dbgd ,_dagca ,_fgfg ,_aebdc );_bafc .Add_c (_aac .RoundFloat (_geage .X ,3),_aac .RoundFloat (_geage .Y ,3),_aac .RoundFloat (_dgafg .X ,3),_aac .RoundFloat (_dgafg .Y ,3),_aac .RoundFloat (_fgfg ,3),_aac .RoundFloat (_aebdc ,3));
_aegcf ,_gdcg =_fgfg ,_aebdc ;case "\u0074":var _gaafd ,_bbbdd _ff .Point ;_ddge ,_cbgc :=_abae .Params [0]*_cccfd ._ddccg ,_abae .Params [1]*_cccfd ._ddccg ;if !_abae .isAbsolute (){_ddge ,_cbgc =_aegcf +_ddge ,_gdcg +_cbgc ;};if _cbba !=nil &&_gb .ToLower (_cbba .Symbol )=="\u0071"{_ebfb :=_ff .Point {X :_cbba .Params [0]*_cccfd ._ddccg ,Y :_cbba .Params [1]*_cccfd ._ddccg };
_cfdeb :=_ff .Point {X :_cbba .Params [2]*_cccfd ._ddccg ,Y :_cbba .Params [3]*_cccfd ._ddccg };_ebed :=_cfdeb .Mul (2.0).Sub (_ebfb );_gaafd ,_bbbdd =_ff .QuadraticToCubicBezier (_aegcf ,_gdcg ,_ebed .X ,_ebed .Y ,_ddge ,_cbgc );};_bafc .Add_c (_aac .RoundFloat (_gaafd .X ,3),_aac .RoundFloat (_gaafd .Y ,3),_aac .RoundFloat (_bbbdd .X ,3),_aac .RoundFloat (_bbbdd .Y ,3),_aac .RoundFloat (_ddge ,3),_aac .RoundFloat (_cbgc ,3));
_aegcf ,_gdcg =_ddge ,_cbgc ;case "\u0061":_edfc ,_dggf :=_abae .Params [0]*_cccfd ._ddccg ,_abae .Params [1]*_cccfd ._ddccg ;_ababg :=_abae .Params [2];_ccgef :=_abae .Params [3]> 0;_egceg :=_abae .Params [4]> 0;_fcgaf ,_eeef :=_abae .Params [5]*_cccfd ._ddccg ,_abae .Params [6]*_cccfd ._ddccg ;
if !_abae .isAbsolute (){_fcgaf ,_eeef =_aegcf +_fcgaf ,_gdcg +_eeef ;};_fefbc :=_ff .EllipseToCubicBeziers (_aegcf ,_gdcg ,_edfc ,_dggf ,_ababg ,_ccgef ,_egceg ,_fcgaf ,_eeef );for _ ,_caaf :=range _fefbc {_bafc .Add_c (_aac .RoundFloat (_caaf [1].X ,3),_aac .RoundFloat ((_caaf [1].Y ),3),_aac .RoundFloat ((_caaf [2].X ),3),_aac .RoundFloat ((_caaf [2].Y ),3),_aac .RoundFloat ((_caaf [3].X ),3),_aac .RoundFloat ((_caaf [3].Y ),3));
};_aegcf ,_gdcg =_fcgaf ,_eeef ;case "\u007a":_bafc .Add_h ();};_cbba =_abae ;};};_cccfd .Style .fillStroke (_bafc );_bafc .Add_h ();_bafc .Add_Q ();};func (_afca *Chapter )headingText ()string {_eda :=_afca ._dfcf ;if _bbgg :=_afca .headingNumber ();_bbgg !=""{_eda =_a .Sprintf ("\u0025\u0073\u0020%\u0073",_bbgg ,_eda );
};return _eda ;};func (_fa *Block )addContents (_abc *_ca .ContentStreamOperations ){_fa ._df .WrapIfNeeded ();_abc .WrapIfNeeded ();*_fa ._df =append (*_fa ._df ,*_abc ...);};

// Lazy gets the lazy mode for the image.
func (_abdbe *Image )Lazy ()bool {return _abdbe ._eecf };

// SetSellerAddress sets the seller address of the invoice.
func (_gacb *Invoice )SetSellerAddress (address *InvoiceAddress ){_gacb ._egaec =address };func _feca (_cdabc []_fg .Point )*Polyline {return &Polyline {_bfde :&_fg .Polyline {Points :_cdabc ,LineColor :_cd .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_gbcb :1.0};
};func _acbff (_gadc *GraphicSVGElement ,_gbee *_ca .ContentCreator ){_gaedgd ,_cddfa :=_gadc .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];if _cddfa {_gdeg :=_gb .Fields (_gaedgd );for _ ,_eecb :=range _gdeg {_gffff :=_gb .FieldsFunc (_eecb ,_cccab );
if len (_gffff )< 3{_dc .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_gaedgd );return ;};_eedg ,_egefe :=_cagdb (_gffff [1],64);
if _egefe !=nil {_dc .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_gaedgd );return ;};_dbcb ,_egefe :=_cagdb (_gffff [2],64);
if _egefe !=nil {_dc .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_gaedgd );return ;};if _gffff [0]=="\u0074r\u0061\u006e\u0073\u006c\u0061\u0074e"{_gbee .Translate (_eedg ,_dbcb );
}else if _gffff [0]=="\u0073\u0063\u0061l\u0065"{_gbee .Scale (_eedg ,_dbcb );}else {_dc .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_gaedgd );
return ;};};};};type grayColor struct{_bbe float64 };func (_baga *TOCLine )getLineLink ()*_cd .PdfAnnotation {if _baga ._agcdg <=0{return nil ;};return _afea (_baga ._agcdg -1,_baga ._acgc ,_baga ._bdegf ,0);};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_fbabb *LinearShading )SetAntiAlias (enable bool ){_fbabb ._eadf .SetAntiAlias (enable )};func (_fffda *templateProcessor )nodeLogDebug (_ggff *templateNode ,_bbfc string ,_fggg ...interface{}){_dc .Log .Debug (_fffda .getNodeErrorLocation (_ggff ,_bbfc ,_fggg ...));
};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_abee *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _abee ._fega .Left ,_abee ._fega .Right ,_abee ._fega .Top ,_abee ._fega .Bottom ;};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_accfe *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// MoveX moves the drawing context to absolute position x.
func (_cfaa *Creator )MoveX (x float64 ){_cfaa ._cfce .X =x };func (_ccbc *Invoice )drawSection (_cegg ,_dcbe string )[]*StyledParagraph {var _fcc []*StyledParagraph ;if _cegg !=""{_aeab :=_eeff (_ccbc ._cgbb );_aeab .SetMargins (0,0,0,5);_aeab .Append (_cegg );
_fcc =append (_fcc ,_aeab );};if _dcbe !=""{_eaded :=_eeff (_ccbc ._cac );_eaded .Append (_dcbe );_fcc =append (_fcc ,_eaded );};return _fcc ;};func _gbbef (_fcacc []*_cd .PdfAnnotation )[]*_cd .PdfAnnotation {var _efef []*_cd .PdfAnnotation ;for _ ,_fgbe :=range _fcacc {_efef =append (_efef ,_cdggd (_fgbe ));
};return _efef ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_gafb *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_efga :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fdcf :=_ca .NewContentCreator ();if _gafb ._accbg !=nil {_fdcf .Add_BDC (*_bc .MakeName (_cd .StructureTypeFigure ),map[string ]_bc .PdfObject {"\u004d\u0043\u0049\u0044":_bc .MakeInteger (*_gafb ._accbg )});
};_fdcf .Add_q ().Add_w (_gafb ._dbdf ).SetStrokingColor (_dfd (_gafb ._acge )).Add_m (_gafb ._bdafe ,ctx .PageHeight -_gafb ._caff ).Add_v (_gafb ._baeg ,ctx .PageHeight -_gafb ._ebaf ,_gafb ._beac ,ctx .PageHeight -_gafb ._bggc ).Add_S ().Add_Q ();if _gafb ._accbg !=nil {_fdcf .Add_EMC ();
};_eebf :=_efga .addContentsByString (_fdcf .String ());if _eebf !=nil {return nil ,ctx ,_eebf ;};return []*Block {_efga },ctx ,nil ;};

// List represents a list of items.
// The representation of a list item is as follows:
//
//	[marker] [content]
//
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_ebfe []*listItem ;_afbf Margins ;_fbfg TextChunk ;_acag float64 ;_fdeafc bool ;_faab Positioning ;_adcc TextStyle ;};

// AddSection adds a new content section at the end of the invoice.
func (_bdgd *Invoice )AddSection (title ,content string ){_bdgd ._edad =append (_bdgd ._edad ,[2]string {title ,content });};func (_gbffa *templateProcessor )loadImageFromSrc (_gefe string )(*Image ,error ){if _gefe ==""{_dc .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_degba ;};_fbdec :=_gb .Split (_gefe ,"\u002c");for _ ,_daeda :=range _fbdec {_daeda =_gb .TrimSpace (_daeda );if _daeda ==""{continue ;};_bbeaea ,_aaaa :=_gbffa ._cebde .ImageMap [_daeda ];if _aaaa {return _ebgc (_bbeaea );};if _bgbb :=_gbffa .parseAttrPropList (_daeda );
len (_bgbb )> 0{if _ffbc ,_acbaa :=_bgbb ["\u0070\u0061\u0074\u0068"];_acbaa {if _dfga ,_dgeae :=_bfad (_ffbc );_dgeae !=nil {_dc .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_ffbc ,_dgeae );
}else {return _dfga ,nil ;};};};};_dc .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_gefe );return nil ,_degba ;};

// NewCell makes a new single cell and inserts it into the row at the current position.
func (_becb *GridRow )NewCell ()(*GridCell ,error ){return _becb .NewMultiCell (1,1)};

// Scale scales Image by a constant factor, both width and height.
func (_ecgf *Image )Scale (xFactor ,yFactor float64 ){_ecgf ._gagbb =xFactor *_ecgf ._gagbb ;_ecgf ._cbgg =yFactor *_ecgf ._cbgg ;};func (_gfge *GraphicSVGElement )setDefaultScaling (_fggd float64 ){_gfge ._ddccg =_fggd ;if _gfge .Style !=nil &&_gfge .Style .StrokeWidth > 0{_gfge .Style .StrokeWidth =_gfge .Style .StrokeWidth *_gfge ._ddccg ;
};for _ ,_caba :=range _gfge .Children {_caba .setDefaultScaling (_fggd );};};func _baedf (_fbcfcg *templateProcessor ,_abggee *templateNode )(interface{},error ){return _fbcfcg .parseList (_abggee );};

// IsAbsolute checks if the positioning is absolute.
func (_aebc Positioning )IsAbsolute ()bool {return _aebc ==PositionAbsolute };

// BorderColor returns the border color of the rectangle.
func (_cafca *Rectangle )BorderColor ()Color {return _cafca ._gccag };func _abaca (_bdbgbb *templateProcessor ,_aaeb *templateNode )(interface{},error ){return _bdbgbb .parseDivision (_aaeb );};

// SetAnchor set gradient position anchor.
// Default to center.
func (_acfeg *RadialShading )SetAnchor (anchor AnchorPoint ){_acfeg ._egcea =anchor };

// SetOpacity sets the opacity of the line (0-1).
func (_bfbg *Line )SetOpacity (opacity float64 ){_bfbg ._gfde =opacity };

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default, it occupies the available width in the drawing context.
//
// Deprecated: This object is deprecated and will be removed in future versions.
//
// Use StyledParagraph instead as it provides more features and is more flexible.
type Paragraph struct{_ceeaa string ;_fgef *_cd .PdfFont ;_ebab float64 ;_dbfac float64 ;_ecfga Color ;_aaagb TextAlignment ;_aacba bool ;_deeb float64 ;_bageg int ;_bagg bool ;_gdaec float64 ;_cafc Margins ;_egaac Positioning ;_gfec float64 ;_fgffa float64 ;
_affff ,_accag float64 ;_aeeca []string ;_ebcbf *int64 ;_dffff string ;};

// Positioning returns the type of positioning the rectangle is set to use.
func (_eeedg *Rectangle )Positioning ()Positioning {return _eeedg ._dgcaf };

// SetMarkedContentID sets the marked content ID for the paragraph.
func (_cebf *StyledParagraph )SetMarkedContentID (mcid int64 )*_cd .KDict {_cebf ._bfdcc =&mcid ;_bcadb :=_cd .NewKDictionary ();_bcadb .S =_bc .MakeName ("\u0050");_bcadb .K =_bc .MakeInteger (mcid );return _bcadb ;};func _cfcb (_fdcac string )([]string ,error ){if !_d .ValidString (_fdcac ){return []string {_fdcac },_ga .New ("\u0069n\u0070\u0075\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020v\u0061\u006c\u0069\u0064\u0020\u0055\u0054\u0046\u002d\u0038");
};var (_eeeea []string ;_fagbd []rune ;);for _ ,_bfefa :=range _fdcac {if _bfefa =='\u000A'{if len (_fagbd )> 0{_eeeea =append (_eeeea ,string (_fagbd ));};_eeeea =append (_eeeea ,string (_bfefa ));_fagbd =nil ;continue ;};_fagbd =append (_fagbd ,_bfefa );
};if len (_fagbd )> 0{_eeeea =append (_eeeea ,string (_fagbd ));};var _dfgb []string ;for _ ,_ebegg :=range _eeeea {_dgddab :=[]rune (_ebegg );_ffcac :=_bb .NewScanner (_dgddab );var _fbbebc []rune ;for _agccg :=0;_agccg < len (_dgddab );_agccg ++{_ ,_fcece ,_eabdg :=_ffcac .Next ();
if _eabdg !=nil {return nil ,_eabdg ;};if _fcece ==_bb .BreakProhibited ||_f .IsSpace (_dgddab [_agccg ]){_fbbebc =append (_fbbebc ,_dgddab [_agccg ]);if _f .IsSpace (_dgddab [_agccg ]){_dfgb =append (_dfgb ,string (_fbbebc ));_fbbebc =[]rune {};};continue ;
}else {if len (_fbbebc )> 0{_dfgb =append (_dfgb ,string (_fbbebc ));};_fbbebc =[]rune {_dgddab [_agccg ]};};};if len (_fbbebc )> 0{_dfgb =append (_dfgb ,string (_fbbebc ));};};return _dfgb ,nil ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_begb *_fg .PolyBezierCurve ;_agac float64 ;_efbdf float64 ;_aagbc Color ;_afdg *int64 ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_cdbcb *Table )NewCell ()*TableCell {return _cdbcb .MultiCell (1,1)};func (_gefc *templateProcessor )parseBoolAttr (_beec ,_dece string )bool {_dc .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_beec ,_dece );
_bcae ,_ :=_ge .ParseBool (_dece );return _dece ==""||_bcae ;};

// Reset removes all the text chunks the paragraph contains.
func (_ddfe *StyledParagraph )Reset (){_ddfe ._gceca =[]*TextChunk {}};

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_dfdc *Paragraph )SetColor (col Color ){_dfdc ._ecfga =col };func (_edbab *Paragraph )wrapText ()error {if !_edbab ._aacba ||int (_edbab ._deeb )<=0{_edbab ._aeeca =[]string {_edbab ._ceeaa };return nil ;};_ggfa :=NewTextChunk (_edbab ._ceeaa ,TextStyle {Font :_edbab ._fgef ,FontSize :_edbab ._ebab });
_dggaa ,_cfge :=_ggfa .Wrap (_edbab ._deeb );if _cfge !=nil {return _cfge ;};if _edbab ._bageg > 0&&len (_dggaa )> _edbab ._bageg {_dggaa =_dggaa [:_edbab ._bageg ];};_edbab ._aeeca =_dggaa ;return nil ;};func (_eebab *templateProcessor )parseEllipse (_bggda *templateNode )(interface{},error ){_eecdc :=_eebab .creator .NewEllipse (0,0,0,0);
for _ ,_gdgg :=range _bggda ._egac .Attr {_fdga :=_gdgg .Value ;switch _ddcbc :=_gdgg .Name .Local ;_ddcbc {case "\u0063\u0078":_eecdc ._agdd =_eebab .parseFloatAttr (_ddcbc ,_fdga );case "\u0063\u0079":_eecdc ._eebb =_eebab .parseFloatAttr (_ddcbc ,_fdga );
case "\u0077\u0069\u0064t\u0068":_eecdc .SetWidth (_eebab .parseFloatAttr (_ddcbc ,_fdga ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_eecdc .SetHeight (_eebab .parseFloatAttr (_ddcbc ,_fdga ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_eecdc .SetFillColor (_eebab .parseColorAttr (_ddcbc ,_fdga ));
case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_eecdc .SetFillOpacity (_eebab .parseFloatAttr (_ddcbc ,_fdga ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_eecdc .SetBorderColor (_eebab .parseColorAttr (_ddcbc ,_fdga ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_eecdc .SetBorderOpacity (_eebab .parseFloatAttr (_ddcbc ,_fdga ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_eecdc .SetBorderWidth (_eebab .parseFloatAttr (_ddcbc ,_fdga ));
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_eecdc .SetPositioning (_eebab .parsePositioningAttr (_ddcbc ,_fdga ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_eecdc .SetFitMode (_eebab .parseFitModeAttr (_ddcbc ,_fdga ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_febed :=_eebab .parseMarginAttr (_ddcbc ,_fdga );
_eecdc .SetMargins (_febed .Left ,_febed .Right ,_febed .Top ,_febed .Bottom );default:_eebab .nodeLogDebug (_bggda ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ddcbc );
};};return _eecdc ,nil ;};func _fdac (_agdgb []byte )(*Image ,error ){_egeb :=_gc .NewReader (_agdgb );_febd ,_eecd :=_cd .ImageHandling .Read (_egeb );if _eecd !=nil {_dc .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_eecd );
return nil ,_eecd ;};return _ebgc (_febd );};func (_bcbdd *templateProcessor )parseTextOverflowAttr (_dafef ,_baada string )TextOverflow {_dc .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_dafef ,_baada );
_bfaa :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_baada ];return _bfaa ;};

// NewCurvePolygon creates a new curve polygon.
func (_ddgd *Creator )NewCurvePolygon (rings [][]_fg .CubicBezierCurve )*CurvePolygon {return _adag (rings );};

// SetSideBorderColor sets the cell's side border color.
func (_ecagd *GridCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_ecagd ._ddda =col ;_ecagd ._faebf =col ;_ecagd ._cbac =col ;_ecagd ._cdfcb =col ;case CellBorderSideTop :_ecagd ._ddda =col ;case CellBorderSideBottom :_ecagd ._faebf =col ;
case CellBorderSideLeft :_ecagd ._cbac =col ;case CellBorderSideRight :_ecagd ._cdfcb =col ;};};

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_eadf *shading ;_adad *_cd .PdfRectangle ;_baab float64 ;};

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _efbgcd (color ,point )};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_bccge *_fg .Polygon ;_adgb float64 ;_gcgd float64 ;_gaaeb Color ;_aagdf *int64 ;};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_ceeag *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bedg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fcgad ,_dcdce :=_bedg .setOpacity (_ceeag ._adgb ,_ceeag ._gcgd );if _dcdce !=nil {return nil ,ctx ,_dcdce ;
};_cbeca :=_ceeag ._bccge ;_cbeca .FillEnabled =_cbeca .FillColor !=nil ;_cbeca .BorderEnabled =_cbeca .BorderColor !=nil &&_cbeca .BorderWidth > 0;_beaad :=_cbeca .Points ;_gdee :=_cd .PdfRectangle {};_gageg :=false ;for _cgfgg :=range _beaad {for _gebcb :=range _beaad [_cgfgg ]{_gdda :=&_beaad [_cgfgg ][_gebcb ];
_gdda .Y =ctx .PageHeight -_gdda .Y ;if !_gageg {_gdee .Llx =_gdda .X ;_gdee .Lly =_gdda .Y ;_gdee .Urx =_gdda .X ;_gdee .Ury =_gdda .Y ;_gageg =true ;}else {_gdee .Llx =_fb .Min (_gdee .Llx ,_gdda .X );_gdee .Lly =_fb .Min (_gdee .Lly ,_gdda .Y );_gdee .Urx =_fb .Max (_gdee .Urx ,_gdda .X );
_gdee .Ury =_fb .Max (_gdee .Ury ,_gdda .Y );};};};if _cbeca .FillEnabled {_dcdd :=_daeg (_bedg ,_ceeag ._bccge .FillColor ,_ceeag ._gaaeb ,func ()Rectangle {return Rectangle {_aaabb :_gdee .Llx ,_adebb :_gdee .Lly ,_dcdaf :_gdee .Width (),_dbab :_gdee .Height ()};
});if _dcdd !=nil {return nil ,ctx ,_dcdd ;};};_adfbec ,_ ,_dcdce :=_cbeca .MarkedDraw (_fcgad ,_ceeag ._aagdf );if _dcdce !=nil {return nil ,ctx ,_dcdce ;};if _dcdce =_bedg .addContentsByString (string (_adfbec ));_dcdce !=nil {return nil ,ctx ,_dcdce ;
};return []*Block {_bedg },ctx ,nil ;};func _eeafa (_fcbae *_cd .PdfAnnotationLink )*_cd .PdfAnnotationLink {if _fcbae ==nil {return nil ;};_acfdc :=_cd .NewPdfAnnotationLink ();_acfdc .BS =_fcbae .BS ;_acfdc .A =_fcbae .A ;if _addcg ,_eaac :=_fcbae .GetAction ();
_eaac ==nil &&_addcg !=nil {_acfdc .SetAction (_addcg );};if _aefbd ,_efce :=_fcbae .Dest .(*_bc .PdfObjectArray );_efce {_acfdc .Dest =_bc .MakeArray (_aefbd .Elements ()...);};return _acfdc ;};func (_gded *Division )drawBackground (_cdfgf []*Block ,_eebfb ,_fbgg DrawContext ,_bbgb bool )([]*Block ,error ){_dced :=len (_cdfgf );
if _dced ==0||_gded ._geba ==nil {return _cdfgf ,nil ;};_eedff :=make ([]*Block ,0,len (_cdfgf ));for _aab ,_cbg :=range _cdfgf {var (_gdfde =_gded ._geba .BorderRadiusTopLeft ;_acb =_gded ._geba .BorderRadiusTopRight ;_fefdd =_gded ._geba .BorderRadiusBottomLeft ;
_cfdf =_gded ._geba .BorderRadiusBottomRight ;);_gbeg :=_eebfb ;_gbeg .Page +=_aab ;if _aab ==0{if _bbgb {_eedff =append (_eedff ,_cbg );continue ;};if _dced ==1{_gbeg .Height =_fbgg .Y -_eebfb .Y ;};}else {_gbeg .X =_gbeg .Margins .Left +_gded ._bdbe .Left ;
_gbeg .Y =_gbeg .Margins .Top ;_gbeg .Width =_gbeg .PageWidth -_gbeg .Margins .Left -_gbeg .Margins .Right -_gded ._bdbe .Left -_gded ._bdbe .Right ;if _aab ==_dced -1{_gbeg .Height =_fbgg .Y -_gbeg .Margins .Top -_gded ._bdbe .Top ;}else {_gbeg .Height =_gbeg .PageHeight -_gbeg .Margins .Top -_gbeg .Margins .Bottom ;
};if !_bbgb {_gdfde =0;_acb =0;};};if _dced > 1&&_aab !=_dced -1{_fefdd =0;_cfdf =0;};_bgeb :=_cada (_gbeg .X ,_gbeg .Y ,_gbeg .Width ,_gbeg .Height );_bgeb .SetFillColor (_gded ._geba .FillColor );_bgeb .SetBorderColor (_gded ._geba .BorderColor );_bgeb .SetBorderWidth (_gded ._geba .BorderSize );
_bgeb .SetBorderRadius (_gdfde ,_acb ,_fefdd ,_cfdf );_dagda ,_ ,_cggf :=_bgeb .GeneratePageBlocks (_gbeg );if _cggf !=nil {return nil ,_cggf ;};if len (_dagda )==0{continue ;};_eedfa :=_dagda [0];if _cggf =_eedfa .mergeBlocks (_cbg );_cggf !=nil {return nil ,_cggf ;
};_eedff =append (_eedff ,_eedfa );};return _eedff ,nil ;};func (_eaeb *Block )translate (_gbe ,_cdc float64 ){_afb :=_ca .NewContentCreator ().Translate (_gbe ,-_cdc ).Operations ();*_eaeb ._df =append (*_afb ,*_eaeb ._df ...);_eaeb ._df .WrapIfNeeded ();
};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_cgb []*_cd .PdfPage ;_bedd map[*_cd .PdfPage ]*Block ;_dfge map[*_cd .PdfPage ]*pageTransformations ;_deg *_cd .PdfPage ;_gee PageSize ;_cfce DrawContext ;_gced Margins ;_gdac ,_gdce float64 ;_becg int ;_gaed func (_ffbd FrontpageFunctionArgs );
_efaa func (_gfff *TOC )error ;_aegb func (_dddd *Block ,_becdf HeaderFunctionArgs );_bdfg func (_fgdb *Block ,_gad FooterFunctionArgs );_acd func (_gagbe PageFinalizeFunctionArgs )error ;_egd func (_dceb *_cd .PdfWriter )error ;_aca bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_bga *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_daba *_cd .Outline ;_bgdg *_cd .PdfOutlineTreeNode ;_fgaa *_cd .PdfAcroForm ;_aaga _bc .PdfObject ;_fecff _cd .Optimizer ;_ggag []*_cd .PdfFont ;_becdg *_cd .PdfFont ;_aaeed *_cd .PdfFont ;_fada *_cd .StructTreeRoot ;_cgg *_cd .ViewerPreferences ;
_cbcg string ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_fdfe *GridCell )SetContent (vd VectorDrawable )error {switch _fbab :=vd .(type ){case *Paragraph :if _fbab ._bagg {_fbab ._aacba =true ;};_fdfe ._feac =vd ;case *StyledParagraph :if _fbab ._dbcf {_fbab ._ccbe =true ;};_fdfe ._feac =vd ;case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_fdfe ._feac =vd ;
default:_dc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _bc .ErrTypeError ;};return nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_afge *StyledParagraph )SetLineHeight (lineheight float64 ){_afge ._gdaeca =lineheight };

// SetFillColor sets the fill color.
func (_gbbe *CurvePolygon )SetFillColor (color Color ){_gbbe ._cefd =color ;_gbbe ._fceg .FillColor =_dfd (color );};

// SetAlternateText sets the alternate text for the image.
func (_dffcg *Image )SetAlternateText (text string ){_dffcg ._gaba =text };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// Scale scales the rectangle dimensions by the specified factors.
func (_gacce *Rectangle )Scale (xFactor ,yFactor float64 ){_gacce ._dcdaf =xFactor *_gacce ._dcdaf ;_gacce ._dbab =yFactor *_gacce ._dbab ;};func (_gacg *Block )transform (_fbc _aae .Matrix ){_fbe :=_ca .NewContentCreator ().Add_cm (_fbc [0],_fbc [1],_fbc [3],_fbc [4],_fbc [6],_fbc [7]).Operations ();
*_gacg ._df =append (*_fbe ,*_gacg ._df ...);_gacg ._df .WrapIfNeeded ();};func (_gdbgf *List )markerWidth ()float64 {var _bgaa float64 ;for _ ,_dbbed :=range _gdbgf ._ebfe {_gbcdf :=_eeff (_gdbgf ._adcc );_gbcdf .SetEnableWrap (false );_gbcdf .SetTextAlignment (TextAlignmentRight );
_gbcdf .Append (_dbbed ._geed .Text ).Style =_dbbed ._geed .Style ;_dcdgf :=_gbcdf .getTextWidth ()/1000.0;if _bgaa < _dcdgf {_bgaa =_dcdgf ;};};return _bgaa ;};func (_dgab *templateProcessor )parseLine (_fbcdf *templateNode )(interface{},error ){_fceaf :=_dgab .creator .NewLine (0,0,0,0);
for _ ,_gbegd :=range _fbcdf ._egac .Attr {_cdgd :=_gbegd .Value ;switch _ebbf :=_gbegd .Name .Local ;_ebbf {case "\u0078\u0031":_fceaf ._cdfa =_dgab .parseFloatAttr (_ebbf ,_cdgd );case "\u0079\u0031":_fceaf ._eadda =_dgab .parseFloatAttr (_ebbf ,_cdgd );
case "\u0078\u0032":_fceaf ._fgeg =_dgab .parseFloatAttr (_ebbf ,_cdgd );case "\u0079\u0032":_fceaf ._becde =_dgab .parseFloatAttr (_ebbf ,_cdgd );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_fceaf .SetLineWidth (_dgab .parseFloatAttr (_ebbf ,_cdgd ));
case "\u0063\u006f\u006co\u0072":_fceaf .SetColor (_dgab .parseColorAttr (_ebbf ,_cdgd ));case "\u0073\u0074\u0079l\u0065":_fceaf .SetStyle (_dgab .parseLineStyleAttr (_ebbf ,_cdgd ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_fceaf .SetDashPattern (_dgab .parseInt64Array (_ebbf ,_cdgd ),_fceaf ._agcc );
case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_fceaf .SetDashPattern (_fceaf ._eebd ,_dgab .parseInt64Attr (_ebbf ,_cdgd ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_fceaf .SetOpacity (_dgab .parseFloatAttr (_ebbf ,_cdgd ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_fceaf .SetPositioning (_dgab .parsePositioningAttr (_ebbf ,_cdgd ));
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_fceaf .SetFitMode (_dgab .parseFitModeAttr (_ebbf ,_cdgd ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_baeff :=_dgab .parseMarginAttr (_ebbf ,_cdgd );_fceaf .SetMargins (_baeff .Left ,_baeff .Right ,_baeff .Top ,_baeff .Bottom );
default:_dgab .nodeLogDebug (_fbcdf ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ebbf );
};};return _fceaf ,nil ;};

// Width returns the width of the Paragraph.
func (_bdcff *Paragraph )Width ()float64 {if _bdcff ._aacba &&int (_bdcff ._deeb )> 0{return _bdcff ._deeb ;};return _bdcff .getTextWidth ()/1000.0;};

// NewMultiCell makes a new cell with given colspan and rowspan and inserts it into the row at the current position.
func (_fagca *GridRow )NewMultiCell (colspan ,rowspan int )(*GridCell ,error ){_acbe :=&GridCell {_degg :len (_fagca ._ebec ),_ccaa :_fagca ._gaab ,_fefb :colspan ,_adggg :rowspan };_acbe ._ccaa =_fagca ._gaab ;_acbe ._degg =0;for _ ,_edae :=range _fagca ._ebec {_acbe ._degg +=_edae ._fefb ;
};for _cbde ,_edcb :=range _fagca ._abf ._dgaa {if _cbde ==_fagca ._gaab +1{break ;};for _ ,_fbdcdg :=range _edcb ._ebec {if _fbdcdg ._ccaa +_fbdcdg ._adggg > _acbe ._ccaa {if _fbdcdg ._degg +_fbdcdg ._fefb > _acbe ._degg {_acbe ._degg =_fbdcdg ._degg +_fbdcdg ._fefb ;
};};};};if _acbe ._degg >=_fagca ._abf ._faca {return nil ,_ga .New ("\u0063\u0061n'\u0074\u0020\u0061d\u0064\u0020\u0061\u006ey m\u006fre\u0020\u0063\u0065\u006c\u006c\u0073\u0020to\u0020\u0074\u0068\u0069\u0073\u0020\u0072o\u0077");};_acbe ._cbfg =5;
_acbe ._ffbe =CellBorderStyleNone ;_acbe ._aabb =_fg .LineStyleSolid ;_acbe ._edbg =CellHorizontalAlignmentLeft ;_acbe ._cfgf =CellVerticalAlignmentTop ;_acbe ._ccfg =0;_acbe ._cgbed =0;_acbe ._caadb =0;_acbe ._cbec =0;_dde :=ColorBlack ;_acbe ._cbac =_dde ;
_acbe ._faebf =_dde ;_acbe ._cdfcb =_dde ;_acbe ._ddda =_dde ;_acbe ._dede =1.0;_fagca ._ebec =append (_fagca ._ebec ,_acbe );return _acbe ,nil ;};

// FillColor returns the fill color of the rectangle.
func (_dfgdf *Rectangle )FillColor ()Color {return _dfgdf ._cgfc };func (_becf *GraphicSVGStyle )toContentStream (_ebcb *_ca .ContentCreator ,_ecga *_cd .PdfPageResources ,_fecbg *GraphicSVGElement ){if _becf ==nil {return ;};if _becf .FillColor !=""{var _bddb ,_cbdb ,_abgc float64 ;
if _egaa ,_fgff :=_ff .ColorMap [_becf .FillColor ];_fgff {_ggabe ,_faeb ,_aegc ,_ :=_egaa .RGBA ();_bddb ,_cbdb ,_abgc =float64 (_ggabe ),float64 (_faeb ),float64 (_aegc );_ebcb .Add_rg (_bddb ,_cbdb ,_abgc );}else if _gb .HasPrefix (_becf .FillColor ,"\u0072\u0067\u0062\u0028"){_bddb ,_cbdb ,_abgc =_bgaac (_becf .FillColor );
_ebcb .Add_rg (_bddb ,_cbdb ,_abgc );}else if _gb .HasPrefix (_becf .FillColor ,"\u0075\u0072\u006c\u0028"){_bafd :=_gb .TrimPrefix (_becf .FillColor ,"\u0075\u0072\u006c\u0028\u0027\u0023");_bafd =_gb .TrimPrefix (_bafd ,"\u0075\u0072\u006c(\u0023");_bafd =_gb .TrimSuffix (_bafd ,"\u0027\u0029");
_bafd =_gb .TrimSuffix (_bafd ,"\u0029");if _fecbg ._afdf [_bafd ]!=nil {_ecga .SetPatternByName (*_bc .MakeName (_bafd ),_fecbg ._afdf [_bafd ].ToPdfShadingPattern ().ToPdfObject ());_ebcb .Add_cs (*_bc .MakeName ("\u0050a\u0074\u0074\u0065\u0072\u006e"));
_ebcb .Add_scn_pattern (*_bc .MakeName (_bafd ));}else if _fecbg ._bgca [_bafd ]!=nil {_ecga .SetPatternByName (*_bc .MakeName (_bafd ),_fecbg ._bgca [_bafd ].ToPdfShadingPattern ().ToPdfObject ());_ebcb .Add_cs (*_bc .MakeName ("\u0050a\u0074\u0074\u0065\u0072\u006e"));
_ebcb .Add_scn_pattern (*_bc .MakeName (_bafd ));};}else {_bddb ,_cbdb ,_abgc =ColorRGBFromHex (_becf .FillColor ).ToRGB ();_ebcb .Add_rg (_bddb ,_cbdb ,_abgc );};};if _becf .FillOpacity < 1.0{_egec :=0;_fbdea :=_bc .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_egec ));
for {_ ,_dbbb :=_ecga .GetExtGState (_fbdea );if !_dbbb {break ;};_egec ++;_fbdea =_bc .PdfObjectName (_a .Sprintf ("\u0047\u0053\u0025\u0064",_egec ));};_dgfd :=_bc .MakeDict ();_dgfd .Set ("\u0063\u0061",_bc .MakeFloat (_becf .FillOpacity ));_fbfb :=_ecga .AddExtGState (_fbdea ,_bc .MakeIndirectObject (_dgfd ));
if _fbfb !=nil {_dc .Log .Debug (_fbfb .Error ());return ;};_ebcb .Add_gs (_fbdea );};if _becf .StrokeColor !=""{var _abgge ,_accbc ,_ddddfe float64 ;if _bcfgd ,_fffg :=_ff .ColorMap [_becf .StrokeColor ];_fffg {_geegg ,_bag ,_fcbbc ,_ :=_bcfgd .RGBA ();
_abgge ,_accbc ,_ddddfe =float64 (_geegg )/255.0,float64 (_bag )/255.0,float64 (_fcbbc )/255.0;}else if _gb .HasPrefix (_becf .FillColor ,"\u0072\u0067\u0062\u0028"){_abgge ,_accbc ,_ddddfe =_bgaac (_becf .FillColor );}else {_abgge ,_accbc ,_ddddfe =ColorRGBFromHex (_becf .StrokeColor ).ToRGB ();
};_ebcb .Add_RG (_abgge ,_accbc ,_ddddfe );};if _becf .StrokeWidth > 0{_ebcb .Add_w (_becf .StrokeWidth );};};func (_gcef *InvoiceAddress )fmtLine (_ecbg ,_gdba string ,_efbgf bool )string {if _efbgf {_gdba ="";};return _a .Sprintf ("\u0025\u0073\u0025s\u000a",_gdba ,_ecbg );
};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
//
// Deprecated: Use NewStyledParagraph instead for better styling options.
func (_cdgc *Creator )NewParagraph (text string )*Paragraph {return _fgeae (text ,_cdgc .NewTextStyle ())};

// Width returns the width of the Paragraph.
func (_cbcgc *StyledParagraph )Width ()float64 {if _cbcgc ._ccbe &&int (_cbcgc ._gabb )> 0{return _cbcgc ._gabb ;};return _cbcgc .getTextWidth ()/1000.0;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_bcabe *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_dacgg ,_faabc :=_bcabe .Wrap (width );if _faabc !=nil {return nil ,_faabc ;};_gdegbbe :=int (height /_bcabe .Style .FontSize );if _gdegbbe >=len (_dacgg ){return nil ,nil ;};_ccag :="\u000a";
_bcabe .Text =_gb .Replace (_gb .Join (_dacgg [:_gdegbbe ],"\u0020"),_ccag +"\u0020",_ccag ,-1);_edcde :=_gb .Replace (_gb .Join (_dacgg [_gdegbbe :],"\u0020"),_ccag +"\u0020",_ccag ,-1);return NewTextChunk (_edcde ,_bcabe .Style ),nil ;};func _bfad (_ecead string )(*Image ,error ){_abff ,_dgbba :=_be .Open (_ecead );
if _dgbba !=nil {return nil ,_dgbba ;};defer _abff .Close ();_fcga ,_dgbba :=_cd .ImageHandling .Read (_abff );if _dgbba !=nil {_dc .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dgbba );
return nil ,_dgbba ;};return _ebgc (_fcga );};

// SetMarkedContentID sets the marked content identifier.
func (_ccgb *Division )SetMarkedContentID (id int64 )*_cd .KDict {return nil };func (_cfgec *templateProcessor )parseInt64Array (_acceb ,_dfbbc string )[]int64 {_dc .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_acceb ,_dfbbc );
_bbae :=_gb .Fields (_dfbbc );_afagd :=make ([]int64 ,0,len (_bbae ));for _ ,_gddg :=range _bbae {_afbb ,_ :=_ge .ParseInt (_gddg ,10,64);_afagd =append (_afagd ,_afbb );};return _afagd ;};func _dfbbb (_ddcde *_cd .PdfAnnotationHighlight )*_cd .PdfAnnotationHighlight {if _ddcde ==nil {return nil ;
};_agecc :=_cd .NewPdfAnnotationHighlight ();_agecc .C =_ddcde .C ;_agecc .CA =_ddcde .CA ;_agecc .Rect =_ddcde .Rect ;_agecc .QuadPoints =_ddcde .QuadPoints ;return _agecc ;};

// SetWidth sets the width of the rectangle.
func (_fcdad *Rectangle )SetWidth (width float64 ){_fcdad ._dcdaf =width };

// SetBorderWidth sets the border width.
func (_fdde *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_fdde ._begb .BorderWidth =borderWidth ;};func (_ffea *templateProcessor )parseColor (_cefdf string )Color {if _cefdf ==""{return nil ;};_dbgda ,_feafb :=_ffea ._cebde .ColorMap [_cefdf ];
if _feafb {return _dbgda ;};if _cefdf [0]=='#'{return ColorRGBFromHex (_cefdf );};return nil ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//
//	[number] [title]      [separator] [page]
//
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_cfgfg *StyledParagraph ;_fdad []*TOCLine ;_agcfe TextStyle ;_fbfe TextStyle ;_fbdd TextStyle ;_abdfc TextStyle ;_cbbcf string ;_gfdea float64 ;_afgga Margins ;_dgcg Positioning ;_baeaa TextStyle ;_gbeeg bool ;};type cmykColor struct{_fdcca ,_aaac ,_fcda ,_cce float64 };
func _cdbca (_cbcab *Table ,_ffbde DrawContext )([]*Block ,DrawContext ,error ){var _bggg []*Block ;_ebag :=NewBlock (_ffbde .PageWidth ,_ffbde .PageHeight );_cbcab .updateRowHeights (_ffbde .Width -_cbcab ._gbdab .Left -_cbcab ._gbdab .Right );_egdcg :=_cbcab ._gbdab .Top ;
if _cbcab ._dgfgd .IsRelative ()&&!_cbcab ._bdbea {_ceadg :=_cbcab .Height ();if _ceadg > _ffbde .Height -_cbcab ._gbdab .Top &&_ceadg <=_ffbde .PageHeight -_ffbde .Margins .Top -_ffbde .Margins .Bottom {_bggg =[]*Block {NewBlock (_ffbde .PageWidth ,_ffbde .PageHeight -_ffbde .Y )};
var _dcfgc error ;if _ ,_ffbde ,_dcfgc =_bdbb ().GeneratePageBlocks (_ffbde );_dcfgc !=nil {return nil ,_ffbde ,_dcfgc ;};_egdcg =0;};};_dbadb :=_ffbde ;if _cbcab ._dgfgd .IsAbsolute (){_ffbde .X =_cbcab ._geacc ;_ffbde .Y =_cbcab ._facedb ;}else {_ffbde .X +=_cbcab ._gbdab .Left ;
_ffbde .Y +=_egdcg ;_ffbde .Width -=_cbcab ._gbdab .Left +_cbcab ._gbdab .Right ;_ffbde .Height -=_egdcg ;};_dbbec :=_ffbde .Width ;_fcfc :=_ffbde .X ;_fbbd :=_ffbde .Y ;_fgba :=_ffbde .Height ;_bcda :=0;_dcaag ,_aafca :=-1,-1;if _cbcab ._aagga {for _bfbdag ,_gbbffc :=range _cbcab ._bbdb {if _gbbffc ._badcc < _cbcab ._bfbdae {continue ;
};if _gbbffc ._badcc > _cbcab ._gedae {break ;};if _dcaag < 0{_dcaag =_bfbdag ;};_aafca =_bfbdag ;};};if _fbcac :=_cbcab .wrapContent (_ffbde );_fbcac !=nil {return nil ,_ffbde ,_fbcac ;};_cbcab .updateRowHeights (_ffbde .Width -_cbcab ._gbdab .Left -_cbcab ._gbdab .Right );
var (_gaaea bool ;_gbeef int ;_aecag int ;_gaca bool ;_adccd int ;_efag error ;);for _dagef :=0;_dagef < len (_cbcab ._bbdb );_dagef ++{_daad :=_cbcab ._bbdb [_dagef ];if _ddeag ,_fbafa :=_cbcab .getLastCellFromCol (_daad ._gdgcb );_ddeag ==_dagef {if (_fbafa ._badcc +_fbafa ._gddee -1)< _cbcab ._agga {for _cgfef :=_daad ._badcc ;
_cgfef < _cbcab ._agga ;_cgfef ++{_fdgd :=&TableCell {};_fdgd ._badcc =_cgfef +1;_fdgd ._gddee =1;_fdgd ._gdgcb =_daad ._gdgcb ;_cbcab ._bbdb =append (_cbcab ._bbdb ,_fdgd );};};};_acdg :=_daad .width (_cbcab ._fbce ,_dbbec );_aeadd :=float64 (0.0);for _cdfbb :=0;
_cdfbb < _daad ._gdgcb -1;_cdfbb ++{_aeadd +=_cbcab ._fbce [_cdfbb ]*_dbbec ;};_ddcd :=float64 (0.0);for _dfab :=_bcda ;_dfab < _daad ._badcc -1;_dfab ++{_ddcd +=_cbcab ._cbaab [_dfab ];};_ffbde .Height =_fgba -_ddcd ;_facc :=float64 (0.0);for _cecfd :=0;
_cecfd < _daad ._gddee ;_cecfd ++{_facc +=_cbcab ._cbaab [_daad ._badcc +_cecfd -1];};_afffg :=_gaca &&_daad ._badcc !=_adccd ;_adccd =_daad ._badcc ;if _afffg ||_facc > _ffbde .Height {if _cbcab ._ccgc &&!_gaca {_gaca ,_efag =_cbcab .wrapRow (_dagef ,_ffbde ,_dbbec );
if _efag !=nil {return nil ,_ffbde ,_efag ;};if _gaca {_dagef --;continue ;};};_bggg =append (_bggg ,_ebag );_ebag =NewBlock (_ffbde .PageWidth ,_ffbde .PageHeight );_fcfc =_ffbde .Margins .Left +_cbcab ._gbdab .Left ;_fbbd =_ffbde .Margins .Top ;_ffbde .Height =_ffbde .PageHeight -_ffbde .Margins .Top -_ffbde .Margins .Bottom ;
_ffbde .Page ++;_fgba =_ffbde .Height ;_bcda =_daad ._badcc -1;_ddcd =0;_gaca =false ;if _cbcab ._aagga &&_dcaag >=0{_gbeef =_dagef ;_dagef =_dcaag -1;_aecag =_bcda ;_bcda =_cbcab ._bfbdae -1;_gaaea =true ;if _daad ._gddee > (_cbcab ._agga -_adccd )||(_daad ._gddee > 1&&_dagef < 0){_dc .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_gaaea =false ;_dcaag ,_aafca =-1,-1;};continue ;};if _afffg {_dagef --;continue ;};};_ffbde .Width =_acdg ;_ffbde .X =_fcfc +_aeadd ;_ffbde .Y =_fbbd +_ddcd ;if _facc > _ffbde .PageHeight -_ffbde .Margins .Top -_ffbde .Margins .Bottom {_facc =_ffbde .PageHeight -_ffbde .Margins .Top -_ffbde .Margins .Bottom ;
};_efge :=_gacgb (_ffbde .X ,_ffbde .Y ,_acdg ,_facc );if _daad ._geggd !=nil {_efge .SetFillColor (_daad ._geggd );};_efge .SetOpacity (_daad ._cgfge );_efge .LineStyle =_daad ._dacd ;_efge ._bbc =_daad ._baef ;_efge ._agc =_daad ._cbeb ;_efge ._dec =_daad ._bdeg ;
_efge ._fage =_daad ._cbfdfb ;if _daad ._cbea !=nil {_efge .SetColorLeft (_daad ._cbea );};if _daad ._efffe !=nil {_efge .SetColorBottom (_daad ._efffe );};if _daad ._cefef !=nil {_efge .SetColorRight (_daad ._cefef );};if _daad ._bcfdc !=nil {_efge .SetColorTop (_daad ._bcfdc );
};_efge .SetWidthBottom (_daad ._dabfb );_efge .SetWidthLeft (_daad ._bfgb );_efge .SetWidthRight (_daad ._efdac );_efge .SetWidthTop (_daad ._ebbgd );_cdbge :=NewBlock (_ebag ._cef ,_ebag ._dff );_edfce :=_ebag .Draw (_efge );if _edfce !=nil {_dc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_edfce );
};if _daad ._fagd !=nil {_ecegc :=_daad ._fagd .Width ();_cbbec :=_daad ._fagd .Height ();_bafec :=0.0;switch _bcdgb :=_daad ._fagd .(type ){case *Paragraph :if _bcdgb ._aacba {_ecegc =_bcdgb .getMaxLineWidth ()/1000.0;};_egcc ,_cbbee ,_ :=_bcdgb .getTextMetrics ();
_faag ,_gfdag :=_egcc *_bcdgb ._dbfac ,_cbbee *_bcdgb ._dbfac ;_cbbec =_cbbec -_gfdag +_faag ;_bafec +=_faag -_gfdag ;_begff :=0.5;if _cbcab ._abddd {_begff =0.3;};switch _daad ._dcgcb {case CellVerticalAlignmentTop :_bafec +=_faag *_begff ;case CellVerticalAlignmentBottom :_bafec -=_faag *_begff ;
};_ecegc +=_bcdgb ._cafc .Left +_bcdgb ._cafc .Right ;_cbbec +=_bcdgb ._cafc .Top +_bcdgb ._cafc .Bottom ;case *StyledParagraph :if _bcdgb ._ccbe {_ecegc =_bcdgb .getMaxLineWidth ()/1000.0;};_cage ,_acga ,_fdae :=_bcdgb .getLineMetrics (0);_ecef ,_gccad :=_cage *_bcdgb ._gdaeca ,_acga *_bcdgb ._gdaeca ;
if _bcdgb ._dadf ==TextVerticalAlignmentCenter {_bafec =_gccad -(_acga +(_cage +_fdae -_acga )/2+(_gccad -_acga )/2);};if len (_bcdgb ._aeca )==1{_cbbec =_ecef ;}else {_cbbec =_cbbec -_gccad +_ecef ;};_bafec +=_ecef -_gccad ;switch _daad ._dcgcb {case CellVerticalAlignmentTop :_bafec +=_ecef *0.5;
case CellVerticalAlignmentBottom :_bafec -=_ecef *0.5;};_ecegc +=_bcdgb ._gebac .Left +_bcdgb ._gebac .Right ;_cbbec +=_bcdgb ._gebac .Top +_bcdgb ._gebac .Bottom ;case *Table :_ecegc =_acdg ;case *List :_ecegc =_acdg ;case *Division :_ecegc =_acdg ;case *Chart :_ecegc =_acdg ;
case *Line :_cbbec +=_bcdgb ._adbf .Top +_bcdgb ._adbf .Bottom ;_bafec -=_bcdgb .Height ()/2;case *Image :_ecegc +=_bcdgb ._fega .Left +_bcdgb ._fega .Right ;_cbbec +=_bcdgb ._fega .Top +_bcdgb ._fega .Bottom ;};switch _daad ._fdcfa {case CellHorizontalAlignmentLeft :_ffbde .X +=_daad ._dccbb ;
_ffbde .Width -=_daad ._dccbb ;case CellHorizontalAlignmentCenter :if _ffdd :=_acdg -_ecegc ;_ffdd > 0{_ffbde .X +=_ffdd /2;_ffbde .Width -=_ffdd /2;};case CellHorizontalAlignmentRight :if _acdg > _ecegc {_ffbde .X =_ffbde .X +_acdg -_ecegc -_daad ._dccbb ;
_ffbde .Width -=_daad ._dccbb ;};};_gdegc :=_ffbde .Y ;_abfd :=_ffbde .Height ;_ffbde .Y +=_bafec ;switch _daad ._dcgcb {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _cbdbf :=_facc -_cbbec ;_cbdbf > 0{_ffbde .Y +=_cbdbf /2;_ffbde .Height -=_cbdbf /2;
};case CellVerticalAlignmentBottom :if _facc > _cbbec {_ffbde .Y =_ffbde .Y +_facc -_cbbec ;_ffbde .Height =_facc ;};};_fabgb :=_ebag .DrawWithContext (_daad ._fagd ,_ffbde );if _fabgb !=nil {if _ga .Is (_fabgb ,ErrContentNotFit )&&!_afffg {_ebag =_cdbge ;
_afffg =true ;_dagef --;continue ;};_dc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fabgb );};_ffbde .Y =_gdegc ;_ffbde .Height =_abfd ;};_ffbde .Y +=_facc ;_ffbde .Height -=_facc ;if _gaaea &&_dagef +1> _aafca {_fbbd +=_ddcd +_facc ;_fgba -=_facc +_ddcd ;
_bcda =_aecag ;_dagef =_gbeef -1;_gaaea =false ;};};_bggg =append (_bggg ,_ebag );if _cbcab ._dgfgd .IsAbsolute (){return _bggg ,_dbadb ,nil ;};_ffbde .X =_dbadb .X ;_ffbde .Width =_dbadb .Width ;_ffbde .Y +=_cbcab ._gbdab .Bottom ;_ffbde .Height -=_cbcab ._gbdab .Bottom ;
return _bggg ,_ffbde ,nil ;};

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_bbeb *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _acagb (x ,y ,innerRadius ,outerRadius ,colorPoints );};func _acagb (_fgdec float64 ,_dbfe float64 ,_gfbad float64 ,_efcb float64 ,_fefc []*ColorPoint )*RadialShading {return &RadialShading {_aaaed :&shading {_bcagg :ColorWhite ,_gecagb :false ,_ggefc :[]bool {false ,false },_gacbe :_fefc },_acgeg :_fgdec ,_gbcbd :_dbfe ,_egbcf :_gfbad ,_adfaa :_efcb ,_egcea :AnchorCenter };
};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_fgga *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _fgga ._gcfb ==nil {if _gcadg :=_fgga .makeXObject ();_gcadg !=nil {return nil ,ctx ,_gcadg ;};};var _cfgg []*Block ;_dbcda :=ctx ;_dbffa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _fgga ._fabb .IsRelative (){_fgga .applyFitMode (ctx .Width );ctx .X +=_fgga ._fega .Left ;ctx .Y +=_fgga ._fega .Top ;ctx .Width -=_fgga ._fega .Left +_fgga ._fega .Right ;ctx .Height -=_fgga ._fega .Top +_fgga ._fega .Bottom ;if _fgga ._cbgg > ctx .Height {_cfgg =append (_cfgg ,_dbffa );
_dbffa =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cgag :=ctx ;_cgag .Y =ctx .Margins .Top +_fgga ._fega .Top ;_cgag .X =ctx .Margins .Left +_fgga ._fega .Left ;_cgag .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_fgga ._fega .Top -_fgga ._fega .Bottom ;
_cgag .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_fgga ._fega .Left -_fgga ._fega .Right ;ctx =_cgag ;};}else {ctx .X =_fgga ._fffe ;ctx .Y =_fgga ._gabc ;};ctx ,_cdbc :=_ddab (_dbffa ,_fgga ,ctx );if _cdbc !=nil {return nil ,ctx ,_cdbc ;
};_cfgg =append (_cfgg ,_dbffa );if _fgga ._fabb .IsAbsolute (){ctx =_dbcda ;}else {ctx .X =_dbcda .X ;ctx .Width =_dbcda .Width ;ctx .Y +=_fgga ._fega .Bottom ;};return _cfgg ,ctx ,nil ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_afecg *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _afecg ._gebac .Left ,_afecg ._gebac .Right ,_afecg ._gebac .Top ,_afecg ._gebac .Bottom ;};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_gcbd *Division )SetPadding (left ,right ,top ,bottom float64 ){_gcbd ._egfg .Left =left ;_gcbd ._egfg .Right =right ;_gcbd ._egfg .Top =top ;_gcbd ._egfg .Bottom =bottom ;};

// SetMarkedContentID sets the marked content id for the grid.
func (_ecfg *Grid )SetMarkedContentID (mcid int64 )*_cd .KDict {return nil };

// ToContentCreator convert SVG and add elements contentstream then returns `contentstream.ContentCreator`.
func (_fedf *GraphicSVGElement )ToContentCreator (cc *_ca .ContentCreator ,res *_cd .PdfPageResources ,scaleX ,scaleY ,translateX ,translateY float64 )*_ca .ContentCreator {if _fedf .Name =="\u0073\u0076\u0067"{_fedf .SetScaling (scaleX ,scaleY );cc .Add_cm (1,0,0,1,translateX ,translateY );
_fedf .setDefaultScaling (_fedf ._ddccg );cc .Add_q ();_egede :=_fb .Max (scaleX ,scaleY );cc .Add_re (_fedf .ViewBox .X *_egede ,_fedf .ViewBox .Y *_egede ,_fedf .ViewBox .W *_egede ,_fedf .ViewBox .H *_egede );cc .Add_W ();cc .Add_n ();_fedf .processDefs ();
for _ ,_gebb :=range _fedf .Children {_gebb .ViewBox =_fedf .ViewBox ;_gebb ._afdf =_fedf ._afdf ;_gebb ._bgca =_fedf ._bgca ;_gebb .toContentStream (cc ,res );};cc .Add_Q ();return cc ;};return nil ;};

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_aaaed *shading ;_ebeec *_cd .PdfRectangle ;_egcea AnchorPoint ;_acgeg float64 ;_gbcbd float64 ;_egbcf float64 ;_adfaa float64 ;};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_ccbfe []*_cd .PdfAnnotation ;_feea []bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;_fdaee *int64 ;_dfcgg *string ;_ccgfa *string ;};

// Width returns the width of the ellipse.
func (_ddac *Ellipse )Width ()float64 {return _ddac ._gca };

// SetBorderWidth sets the border width of the rectangle.
func (_gbff *Rectangle )SetBorderWidth (bw float64 ){_gbff ._dedg =bw };func _bbab (_bgdf int )*Table {_afbcc :=&Table {_gfgc :_bgdf ,_cdgee :10.0,_fbce :[]float64 {},_cbaab :[]float64 {},_bbdb :[]*TableCell {},_degb :make ([]int ,_bgdf ),_bdbea :true };
_afbcc .resetColumnWidths ();return _afbcc ;};

// ColorGrayFrom8bit creates a Color from 8-bit (0-255) gray values.
// Example:
//
//	gray := ColorGrayFrom8bit(255, 0, 0)
func ColorGrayFrom8bit (g byte )Color {return grayColor {float64 (g )/255.0}};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_bddc *Creator )NewTextStyle ()TextStyle {return _dfded (_bddc ._becdg )};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _de .ChartRenderable )*Chart {return _gcg (chart )};

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_deece *Paragraph )SetLanguageIdentifier (id string ){_deece ._dffff =id };

// SetColor sets the line color.
func (_ebbe *Curve )SetColor (col Color ){_ebbe ._acge =col };

// GeneratePageBlocks draws the filled curve on page blocks.
func (_dcce *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdbd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gbfca ,_ ,_aead :=_dcce .draw (_fdbd ,"");if _aead !=nil {return nil ,ctx ,_aead ;};_aead =_fdbd .addContentsByString (string (_gbfca ));
if _aead !=nil {return nil ,ctx ,_aead ;};return []*Block {_fdbd },ctx ,nil ;};

// SetPos sets absolute positioning with specified coordinates.
func (_gdacde *StyledParagraph )SetPos (x ,y float64 ){_gdacde ._gaabe =PositionAbsolute ;_gdacde ._fcgdfe =x ;_gdacde ._ebffa =y ;};func (_babd *templateProcessor )parseTextAlignmentAttr (_abdf ,_cgdc string )TextAlignment {_dc .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_abdf ,_cgdc );
_fbgfc :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_cgdc ];
return _fbgfc ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_bfbdb *Invoice )SetBuyerAddress (address *InvoiceAddress ){_bfbdb ._cdceb =address };func (_acfe *GraphicSVGElement )processDefs (){_acfe ._afdf =make (map[string ]*LinearShading );_acfe ._bgca =make (map[string ]*RadialShading );for _ ,_efbba :=range _acfe .Children {if _efbba .Name =="\u0064\u0065\u0066\u0073"{for _ ,_bbac :=range _efbba .Children {if _bbac .Name =="\u006c\u0069\u006e\u0065\u0061\u0072\u0047\u0072\u0061d\u0069\u0065\u006e\u0074"{_gffc :=_bbac .Attributes ["\u0069\u0064"];
_fece :=_bbac .parseColorPoints ();_fbfd :=_egefa (_fece );_gaafa :=_bbac .getGradientAngle ();_fbfd .SetAngle (-_gaafa );_fbfd .SetExtends (true ,true );_fbfd .SetBoundingBox (0,0,_acfe .Width ,_acfe .Height );_acfe ._afdf [_gffc ]=_fbfd ;}else if _bbac .Name =="\u0072\u0061\u0064\u0069\u0061\u006c\u0047\u0072\u0061d\u0069\u0065\u006e\u0074"{_cgfg :=_bbac .Attributes ["\u0069\u0064"];
_bcce :=_bbac .parseColorPoints ();_cecda :=_acagb (_acfe ._cagc ,_acfe .ViewBox .H ,0,_fb .Min (_acfe .Width ,_acfe .Height )/2,_bcce );_cecda .SetExtends (true ,true );_cecda .SetBoundingBox (0,0,_acfe .Width ,_acfe .Height );_acfe ._bgca [_cgfg ]=_cecda ;
};};};};};

// SetBorderColor sets border color of the rectangle.
func (_ddcf *Rectangle )SetBorderColor (col Color ){_ddcf ._gccag =col };

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_dbeg *Rectangle )SetFitMode (fitMode FitMode ){_dbeg ._agabc =fitMode };

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_fgbdg *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_fgbdg ._ebbed .Left =left ;_fgbdg ._ebbed .Right =right ;_fgbdg ._ebbed .Top =top ;_fgbdg ._ebbed .Bottom =bottom ;};func (_dbae *RadialShading )shadingModel ()*_cd .PdfShadingType3 {_fffag ,_deabd ,_ccbcb :=_dbae ._aaaed ._bcagg .ToRGB ();
var _ebcc _fg .Point ;switch _dbae ._egcea {case AnchorBottomLeft :_ebcc =_fg .Point {X :_dbae ._ebeec .Llx ,Y :_dbae ._ebeec .Lly };case AnchorBottomRight :_ebcc =_fg .Point {X :_dbae ._ebeec .Urx ,Y :_dbae ._ebeec .Ury -_dbae ._ebeec .Height ()};case AnchorTopLeft :_ebcc =_fg .Point {X :_dbae ._ebeec .Llx ,Y :_dbae ._ebeec .Lly +_dbae ._ebeec .Height ()};
case AnchorTopRight :_ebcc =_fg .Point {X :_dbae ._ebeec .Urx ,Y :_dbae ._ebeec .Ury };case AnchorLeft :_ebcc =_fg .Point {X :_dbae ._ebeec .Llx ,Y :_dbae ._ebeec .Lly +_dbae ._ebeec .Height ()/2};case AnchorTop :_ebcc =_fg .Point {X :_dbae ._ebeec .Llx +_dbae ._ebeec .Width ()/2,Y :_dbae ._ebeec .Ury };
case AnchorRight :_ebcc =_fg .Point {X :_dbae ._ebeec .Urx ,Y :_dbae ._ebeec .Lly +_dbae ._ebeec .Height ()/2};case AnchorBottom :_ebcc =_fg .Point {X :_dbae ._ebeec .Urx +_dbae ._ebeec .Width ()/2,Y :_dbae ._ebeec .Lly };default:_ebcc =_fg .NewPoint (_dbae ._ebeec .Llx +_dbae ._ebeec .Width ()/2,_dbae ._ebeec .Lly +_dbae ._ebeec .Height ()/2);
};_dafge :=_dbae ._egbcf ;_cbeeb :=_dbae ._adfaa ;_cffgf :=_ebcc .X +_dbae ._acgeg ;_fgcf :=_ebcc .Y +_dbae ._gbcbd ;if _dafge ==-1.0{_dafge =0.0;};if _cbeeb ==-1.0{var _bcbae []float64 ;_caffb :=_fb .Pow (_cffgf -_dbae ._ebeec .Llx ,2)+_fb .Pow (_fgcf -_dbae ._ebeec .Lly ,2);
_bcbae =append (_bcbae ,_fb .Abs (_caffb ));_ecbd :=_fb .Pow (_cffgf -_dbae ._ebeec .Llx ,2)+_fb .Pow (_dbae ._ebeec .Lly +_dbae ._ebeec .Height ()-_fgcf ,2);_bcbae =append (_bcbae ,_fb .Abs (_ecbd ));_fgcc :=_fb .Pow (_dbae ._ebeec .Urx -_cffgf ,2)+_fb .Pow (_fgcf -_dbae ._ebeec .Ury -_dbae ._ebeec .Height (),2);
_bcbae =append (_bcbae ,_fb .Abs (_fgcc ));_fcdbg :=_fb .Pow (_dbae ._ebeec .Urx -_cffgf ,2)+_fb .Pow (_dbae ._ebeec .Ury -_fgcf ,2);_bcbae =append (_bcbae ,_fb .Abs (_fcdbg ));_da .Slice (_bcbae ,func (_acbf ,_cace int )bool {return _acbf > _cace });_cbeeb =_fb .Sqrt (_bcbae [0]);
};_babg :=&_cd .PdfRectangle {Llx :_cffgf -_cbeeb ,Lly :_fgcf -_cbeeb ,Urx :_cffgf +_cbeeb ,Ury :_fgcf +_cbeeb };_gcffg :=_cd .NewPdfShadingType3 ();_gcffg .PdfShading .ShadingType =_bc .MakeInteger (3);_gcffg .PdfShading .ColorSpace =_cd .NewPdfColorspaceDeviceRGB ();
_gcffg .PdfShading .Background =_bc .MakeArrayFromFloats ([]float64 {_fffag ,_deabd ,_ccbcb });_gcffg .PdfShading .BBox =_babg ;_gcffg .PdfShading .AntiAlias =_bc .MakeBool (_dbae ._aaaed ._gecagb );_gcffg .Coords =_bc .MakeArrayFromFloats ([]float64 {_cffgf ,_fgcf ,_dafge ,_cffgf ,_fgcf ,_cbeeb });
_gcffg .Domain =_bc .MakeArrayFromFloats ([]float64 {0.0,1.0});_gcffg .Extend =_bc .MakeArray (_bc .MakeBool (_dbae ._aaaed ._ggefc [0]),_bc .MakeBool (_dbae ._aaaed ._ggefc [1]));_gcffg .Function =_dbae ._aaaed .generatePdfFunctions ();return _gcffg ;
};

// GeneratePageBlocks implements drawable interface.
func (_deef *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fbg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_agd :=_deef ._eea ;_fbcb :=ctx .PageHeight -_deef ._gbcc ;if _deef ._bca !=nil {_egef :=_fg .Rectangle {Opacity :1.0,X :_deef ._eea ,Y :ctx .PageHeight -_deef ._gbcc -_deef ._ebd ,Height :_deef ._ebd ,Width :_deef ._bbg };
_egef .FillEnabled =true ;_cgf :=_dfd (_deef ._bca );_aaa :=_daeg (_fbg ,_cgf ,_deef ._bca ,func ()Rectangle {return Rectangle {_aaabb :_egef .X ,_adebb :_egef .Y ,_dcdaf :_egef .Width ,_dbab :_egef .Height };});if _aaa !=nil {return nil ,ctx ,_aaa ;};
_egef .FillColor =_cgf ;_egef .BorderEnabled =false ;_caef :="";if _deef ._gbca < 1{_ceddb :=_bc .MakeDict ();_ceddb .Set ("\u0063\u0061",_bc .MakeFloat (_deef ._gbca ));_ceddb .Set ("\u0043\u0041",_bc .MakeFloat (_deef ._gbca ));_acc :=_fbg ._bcb .AddExtGState ("\u0067\u0073\u0031",_ceddb );
if _acc ==nil {_caef ="\u0067\u0073\u0031";};};_ada ,_ ,_aaa :=_egef .Draw (_caef );if _aaa !=nil {return nil ,ctx ,_aaa ;};_aaa =_fbg .addContentsByString (string (_ada ));if _aaa !=nil {return nil ,ctx ,_aaa ;};};_fcb :=_deef ._addc ;_adee :=_deef ._cbc ;
_cgc :=_deef ._bebc ;_cca :=_deef ._egb ;_gcd :=_deef ._addc ;if _deef ._dec ==CellBorderStyleDouble {_gcd +=2*_fcb ;};_cba :=_deef ._cbc ;if _deef ._fage ==CellBorderStyleDouble {_cba +=2*_adee ;};_bgc :=_deef ._bebc ;if _deef ._bbc ==CellBorderStyleDouble {_bgc +=2*_cgc ;
};_ceed :=_deef ._egb ;if _deef ._agc ==CellBorderStyleDouble {_ceed +=2*_cca ;};_bbb :=(_gcd -_bgc )/2;_cfga :=(_gcd -_ceed )/2;_bccd :=(_cba -_bgc )/2;_ccae :=(_cba -_ceed )/2;if _deef ._addc !=0{_bccf :=_agd ;_eaf :=_fbcb ;if _deef ._dec ==CellBorderStyleDouble {_eaf -=_fcb ;
_aea :=_fg .BasicLine {LineColor :_dfd (_deef ._aef ),Opacity :1.0,LineWidth :_deef ._addc ,LineStyle :_deef .LineStyle ,X1 :_bccf -_gcd /2+_bbb ,Y1 :_eaf +2*_fcb ,X2 :_bccf +_gcd /2-_cfga +_deef ._bbg ,Y2 :_eaf +2*_fcb };_facf ,_ ,_edcg :=_aea .Draw ("");
if _edcg !=nil {return nil ,ctx ,_edcg ;};_edcg =_fbg .addContentsByString (string (_facf ));if _edcg !=nil {return nil ,ctx ,_edcg ;};};_aag :=_fg .BasicLine {LineWidth :_deef ._addc ,Opacity :1.0,LineColor :_dfd (_deef ._aef ),LineStyle :_deef .LineStyle ,X1 :_bccf -_gcd /2+_bbb +(_bgc -_deef ._bebc ),Y1 :_eaf ,X2 :_bccf +_gcd /2-_cfga +_deef ._bbg -(_ceed -_deef ._egb ),Y2 :_eaf };
_afac ,_ ,_aga :=_aag .Draw ("");if _aga !=nil {return nil ,ctx ,_aga ;};_aga =_fbg .addContentsByString (string (_afac ));if _aga !=nil {return nil ,ctx ,_aga ;};};if _deef ._cbc !=0{_fgdf :=_agd ;_eac :=_fbcb -_deef ._ebd ;if _deef ._fage ==CellBorderStyleDouble {_eac +=_adee ;
_becd :=_fg .BasicLine {LineWidth :_deef ._cbc ,Opacity :1.0,LineColor :_dfd (_deef ._bgeg ),LineStyle :_deef .LineStyle ,X1 :_fgdf -_cba /2+_bccd ,Y1 :_eac -2*_adee ,X2 :_fgdf +_cba /2-_ccae +_deef ._bbg ,Y2 :_eac -2*_adee };_ccge ,_ ,_gfd :=_becd .Draw ("");
if _gfd !=nil {return nil ,ctx ,_gfd ;};_gfd =_fbg .addContentsByString (string (_ccge ));if _gfd !=nil {return nil ,ctx ,_gfd ;};};_gdc :=_fg .BasicLine {LineWidth :_deef ._cbc ,Opacity :1.0,LineColor :_dfd (_deef ._bgeg ),LineStyle :_deef .LineStyle ,X1 :_fgdf -_cba /2+_bccd +(_bgc -_deef ._bebc ),Y1 :_eac ,X2 :_fgdf +_cba /2-_ccae +_deef ._bbg -(_ceed -_deef ._egb ),Y2 :_eac };
_bdaf ,_ ,_ecd :=_gdc .Draw ("");if _ecd !=nil {return nil ,ctx ,_ecd ;};_ecd =_fbg .addContentsByString (string (_bdaf ));if _ecd !=nil {return nil ,ctx ,_ecd ;};};if _deef ._bebc !=0{_gdg :=_agd ;_cccc :=_fbcb ;if _deef ._bbc ==CellBorderStyleDouble {_gdg +=_cgc ;
_dgeeg :=_fg .BasicLine {LineWidth :_deef ._bebc ,Opacity :1.0,LineColor :_dfd (_deef ._aad ),LineStyle :_deef .LineStyle ,X1 :_gdg -2*_cgc ,Y1 :_cccc +_bgc /2+_bbb ,X2 :_gdg -2*_cgc ,Y2 :_cccc -_bgc /2-_bccd -_deef ._ebd };_gdca ,_ ,_dcdc :=_dgeeg .Draw ("");
if _dcdc !=nil {return nil ,ctx ,_dcdc ;};_dcdc =_fbg .addContentsByString (string (_gdca ));if _dcdc !=nil {return nil ,ctx ,_dcdc ;};};_gbga :=_fg .BasicLine {LineWidth :_deef ._bebc ,Opacity :1.0,LineColor :_dfd (_deef ._aad ),LineStyle :_deef .LineStyle ,X1 :_gdg ,Y1 :_cccc +_bgc /2+_bbb -(_gcd -_deef ._addc ),X2 :_gdg ,Y2 :_cccc -_bgc /2-_bccd -_deef ._ebd +(_cba -_deef ._cbc )};
_ebde ,_ ,_eab :=_gbga .Draw ("");if _eab !=nil {return nil ,ctx ,_eab ;};_eab =_fbg .addContentsByString (string (_ebde ));if _eab !=nil {return nil ,ctx ,_eab ;};};if _deef ._egb !=0{_aee :=_agd +_deef ._bbg ;_cfc :=_fbcb ;if _deef ._agc ==CellBorderStyleDouble {_aee -=_cca ;
_dagd :=_fg .BasicLine {LineWidth :_deef ._egb ,Opacity :1.0,LineColor :_dfd (_deef ._fbdc ),LineStyle :_deef .LineStyle ,X1 :_aee +2*_cca ,Y1 :_cfc +_ceed /2+_cfga ,X2 :_aee +2*_cca ,Y2 :_cfc -_ceed /2-_ccae -_deef ._ebd };_gbef ,_ ,_aafc :=_dagd .Draw ("");
if _aafc !=nil {return nil ,ctx ,_aafc ;};_aafc =_fbg .addContentsByString (string (_gbef ));if _aafc !=nil {return nil ,ctx ,_aafc ;};};_bfg :=_fg .BasicLine {LineWidth :_deef ._egb ,Opacity :1.0,LineColor :_dfd (_deef ._fbdc ),LineStyle :_deef .LineStyle ,X1 :_aee ,Y1 :_cfc +_ceed /2+_cfga -(_gcd -_deef ._addc ),X2 :_aee ,Y2 :_cfc -_ceed /2-_ccae -_deef ._ebd +(_cba -_deef ._cbc )};
_bba ,_ ,_ecea :=_bfg .Draw ("");if _ecea !=nil {return nil ,ctx ,_ecea ;};_ecea =_fbg .addContentsByString (string (_bba ));if _ecea !=nil {return nil ,ctx ,_ecea ;};};return []*Block {_fbg },ctx ,nil ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SkipCells skips over a specified number of cells in the table.
func (_deaaa *Table )SkipCells (num int ){if num < 0{_dc .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _cgbff :=0;_cgbff < num ;_cgbff ++{_deaaa .NewCell ();};};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_ccdeb *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_ccdeb ._fdcfa =halign ;};func (_fggb *GraphicSVGElement )parseColorPoints ()[]*ColorPoint {var _ddfc []*ColorPoint ;var _dbcde error ;for _ ,_dcdca :=range _fggb .Children {if _dcdca .Name =="\u0073\u0074\u006f\u0070"{_agede :=ColorBlack ;
_cabcd :=0.0;for _cbce ,_geeb :=range _dcdca .Attributes {if _cbce =="\u006f\u0066\u0066\u0073\u0065\u0074"{if _gb .HasSuffix (_geeb ,"\u0025"){_gdgb ,_deecb :=_ge .ParseFloat (_gb .TrimSuffix (_geeb ,"\u0025"),64);if _deecb !=nil {continue ;};_cabcd =_gdgb /100;
}else {_cabcd ,_dbcde =_ge .ParseFloat (_geeb ,64);if _dbcde !=nil {continue ;};};}else if _cbce =="\u0073\u0074\u006f\u0070\u002d\u0063\u006f\u006c\u006f\u0072"{if _geeb [0]=='#'{_agede =ColorRGBFromHex (_geeb );}else {_aceg ,_egff :=_ff .ColorMap [_geeb ];
if _egff {_agede =ColorRGBFrom8bit (_aceg .R ,_aceg .G ,_aceg .B );};};};};_ddfc =append (_ddfc ,NewColorPoint (_agede ,_cabcd ));};};return _ddfc ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_fdfbe *Image )SetPos (x ,y float64 ){_fdfbe ._fabb =PositionAbsolute ;_fdfbe ._fffe =x ;_fdfbe ._gabc =y ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_cda *Creator )RotateDeg (angleDeg int64 )error {_gbd :=_cda .getActivePage ();if _gbd ==nil {_dc .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _ga .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_dc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _ga .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _ccca int64 ;if _gbd .Rotate !=nil {_ccca =*(_gbd .Rotate );};_ccca +=angleDeg ;_gbd .Rotate =&_ccca ;return nil ;};func _bcdce (_edbeg interface{})(interface{},error ){switch _dccac :=_edbeg .(type ){case uint8 :return int64 (_dccac ),nil ;
case int8 :return int64 (_dccac ),nil ;case uint16 :return int64 (_dccac ),nil ;case int16 :return int64 (_dccac ),nil ;case uint32 :return int64 (_dccac ),nil ;case int32 :return int64 (_dccac ),nil ;case uint64 :return int64 (_dccac ),nil ;case int64 :return _dccac ,nil ;
case int :return int64 (_dccac ),nil ;case float32 :return float64 (_dccac ),nil ;case float64 :return _dccac ,nil ;};return nil ,_a .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0076\u0061\u006c\u0075\u0065\u002c\u0020\u0025\u0076\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072",_edbeg );
};

// SetPos set position of the element on PDF page
func (_bebb *GraphicSVGElement )SetPos (x ,y float64 ){_bebb ._cagc =x ;_bebb ._agdf =y };

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_gcdb *Image )GetHorizontalAlignment ()HorizontalAlignment {return _gcdb ._cgef };

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_ffgc *Rectangle )Width ()float64 {return _ffgc ._dcdaf };func _fgb (_cec ,_adc *_cd .PdfPageResources )error {_fcd ,_ :=_cec .GetColorspaces ();if _fcd !=nil &&len (_fcd .Colorspaces )> 0{for _eag ,_egaf :=range _fcd .Colorspaces {_aaee :=*_bc .MakeName (_eag );
if _adc .HasColorspaceByName (_aaee ){continue ;};_gae :=_adc .SetColorspaceByName (_aaee ,_egaf );if _gae !=nil {return _gae ;};};};return nil ;};func (_accac *templateProcessor )parsePageBreak (_ecbdb *templateNode )(interface{},error ){return _bdbb (),nil ;
};func (_fecef *TextChunk )Highlight (color Color ,alpha float64 )*_cd .PdfAnnotation {_bafab ,_gdedd ,_cdgg :=color .ToRGB ();_daaed :=_cd .NewPdfAnnotationHighlight ();_daaed .C =_bc .MakeArrayFromFloats ([]float64 {_bafab ,_gdedd ,_cdgg });_daaed .CA =_bc .MakeFloat (alpha );
_fecef .AddAnnotation (_daaed .PdfAnnotation );return _daaed .PdfAnnotation ;};func _ecgfd (_decg *_cd .PdfRectangle ,_badgga float64 )[4]_fg .Point {_ddfbe :=_badgga *_fb .Pi /180.0;_adcbf :=_decg .Width ();_cddgc :=_decg .Height ();_cbfgb :=_fb .Sin (_ddfbe );
_babc :=_fb .Cos (_ddfbe );_gggbg :=[4]_fg .Point {{X :_aac .RoundFloat (_decg .Llx ,3),Y :_aac .RoundFloat (_decg .Lly ,3)},{X :_aac .RoundFloat (_decg .Llx +_adcbf *_babc ,3),Y :_aac .RoundFloat (_decg .Lly +_adcbf *_cbfgb ,3)},{X :_aac .RoundFloat (_decg .Llx +_adcbf *_babc -_cddgc *_cbfgb ,3),Y :_aac .RoundFloat (_decg .Lly +_adcbf *_cbfgb +_cddgc *_babc ,3)},{X :_aac .RoundFloat (_decg .Llx -_cddgc *_cbfgb ,3),Y :_aac .RoundFloat (_decg .Lly +_cddgc *_babc ,3)}};
return _gggbg ;};

// SetAngle sets the rotation angle in degrees.
func (_cc *Block )SetAngle (angleDeg float64 ){_cc ._ecg =angleDeg };

// Width returns the Block's width.
func (_bcc *Block )Width ()float64 {return _bcc ._cef };

// SetMarkedContentID sets the marked content identifier.
func (_fbbf *Polygon )SetMarkedContentID (mcid int64 )*_cd .KDict {_fbbf ._aagdf =&mcid ;_fbea :=_cd .NewKDictionary ();_fbea .S =_bc .MakeName (_cd .StructureTypeFigure );_fbea .K =_bc .MakeInteger (mcid );return _fbea ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_gafa *Creator )CreateTableOfContents (genTOCFunc func (_bfc *TOC )error ){_gafa ._efaa =genTOCFunc ;};

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_cdfa float64 ;_eadda float64 ;_fgeg float64 ;_becde float64 ;_baad Color ;_ggabf _fg .LineStyle ;_gfde float64 ;_eebd []int64 ;_agcc int64 ;_beaa float64 ;_dcac Positioning ;_bffef FitMode ;_adbf Margins ;_ecdga *int64 ;};

// SetColorBottom sets border color for bottom.
func (_ceeb *border )SetColorBottom (col Color ){_ceeb ._bgeg =col };

// SetMargins sets the margins of the chart component.
func (_dgga *Chart )SetMargins (left ,right ,top ,bottom float64 ){_dgga ._fdg .Left =left ;_dgga ._fdg .Right =right ;_dgga ._fdg .Top =top ;_dgga ._fdg .Bottom =bottom ;};func _ecfgc (_abccd *templateProcessor ,_bbbgb *templateNode )(interface{},error ){return _abccd .parseStyledParagraph (_bbbgb );
};

// SetHeight sets the height of the ellipse.
func (_aeaa *Ellipse )SetHeight (height float64 ){_aeaa ._geeg =height };func _acdf ()*Division {return &Division {_fcdc :true }};

// SetRowPosition sets cell row position.
func (_dgbcf *TableCell )SetRowPosition (row int ){_dgbcf ._badcc =row };func (_gfdcf *Invoice )setCellBorder (_cbda *TableCell ,_dfgg *InvoiceCell ){for _ ,_fcbdd :=range _dfgg .BorderSides {_cbda .SetBorder (_fcbdd ,CellBorderStyleSingle ,_dfgg .BorderWidth );
};_cbda .SetBorderColor (_dfgg .BorderColor );};func (_ccgee *listItem )ctxHeight (_aebga float64 )float64 {var _efbag float64 ;switch _aeaae :=_ccgee ._adfbbg .(type ){case *Paragraph :if _aeaae ._aacba {_aeaae .SetWidth (_aebga -_aeaae ._cafc .Horizontal ());
};_efbag =_aeaae .Height ()+_aeaae ._cafc .Vertical ();_efbag +=0.5*_aeaae ._ebab *_aeaae ._dbfac ;case *StyledParagraph :if _aeaae ._ccbe {_aeaae .SetWidth (_aebga -_aeaae ._gebac .Horizontal ());};_efbag =_aeaae .Height ()+_aeaae ._gebac .Vertical ();
_efbag +=0.5*_aeaae .getTextHeight ();case *List :_bdef :=_aebga -_ccgee ._geed .Width ()-_aeaae ._afbf .Horizontal ()-_aeaae ._acag ;_efbag =_aeaae .ctxHeight (_bdef )+_aeaae ._afbf .Vertical ();case *Image :_efbag =_aeaae .Height ()+_aeaae ._fega .Vertical ();
case *Division :_acfb :=_aebga -_ccgee ._geed .Width ()-_aeaae ._bdbe .Horizontal ();_efbag =_aeaae .ctxHeight (_acfb )+_aeaae ._bdbe .Vertical ();case *Table :_gecab :=_aebga -_ccgee ._geed .Width ()-_aeaae ._gbdab .Horizontal ();_aeaae .updateRowHeights (_gecab );
_efbag =_aeaae .Height ()+_aeaae ._gbdab .Vertical ();default:_efbag =_ccgee ._adfbbg .Height ();};return _efbag ;};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_gabcdf *TOC )SetLineTitleStyle (style TextStyle ){_gabcdf ._fbfe =style };func _efb (_bda *_ca .ContentStreamOperations ,_cbb *_cd .PdfPageResources ,_cedd *_ca .ContentStreamOperations ,_ffa *_cd .PdfPageResources )error {_gbfc :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};
_eebg :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};_ceddd :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};_gge :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};_abb :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};_dcb :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};
for _ ,_gcb :=range *_cedd {switch _gcb .Operand {case "\u0044\u006f":if len (_gcb .Params )==1{if _ggb ,_aaf :=_gcb .Params [0].(*_bc .PdfObjectName );_aaf {if _ ,_caf :=_gbfc [*_ggb ];!_caf {var _cdfc _bc .PdfObjectName ;_afa ,_ :=_ffa .GetXObjectByName (*_ggb );
if _afa !=nil {_cdfc =*_ggb ;for {_fc ,_ :=_cbb .GetXObjectByName (_cdfc );if _fc ==nil ||_fc ==_afa {break ;};_cdfc =*_bc .MakeName (_afe (_cdfc .String ()));};};_cbb .SetXObjectByName (_cdfc ,_afa );_gbfc [*_ggb ]=_cdfc ;};_aff :=_gbfc [*_ggb ];_gcb .Params [0]=&_aff ;
};};case "\u0054\u0066":if len (_gcb .Params )==2{if _cbd ,_ebcf :=_gcb .Params [0].(*_bc .PdfObjectName );_ebcf {if _ ,_cefg :=_eebg [*_cbd ];!_cefg {_dcd ,_cfb :=_ffa .GetFontByName (*_cbd );_gaaf :=*_cbd ;if _cfb &&_dcd !=nil {_gaaf =_dcdg (_cbd .String (),_dcd ,_cbb );
};_cbb .SetFontByName (_gaaf ,_dcd );_eebg [*_cbd ]=_gaaf ;};_dgf :=_eebg [*_cbd ];_gcb .Params [0]=&_dgf ;};};case "\u0043\u0053","\u0063\u0073":if len (_gcb .Params )==1{if _dcba ,_fecf :=_gcb .Params [0].(*_bc .PdfObjectName );_fecf {if _ ,_cbfe :=_ceddd [*_dcba ];
!_cbfe {var _adg _bc .PdfObjectName ;_ege ,_dgaf :=_ffa .GetColorspaceByName (*_dcba );if _dgaf {_adg =*_dcba ;for {_fgd ,_gff :=_cbb .GetColorspaceByName (_adg );if !_gff ||_ege ==_fgd {break ;};_adg =*_bc .MakeName (_afe (_adg .String ()));};_cbb .SetColorspaceByName (_adg ,_ege );
_ceddd [*_dcba ]=_adg ;}else {_dc .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _bdg ,_ade :=_ceddd [*_dcba ];_ade {_gcb .Params [0]=&_bdg ;}else {_dc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_dcba );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_gcb .Params )==1{if _dee ,_afc :=_gcb .Params [0].(*_bc .PdfObjectName );_afc {if _ ,_affc :=_gge [*_dee ];!_affc {var _bcbg _bc .PdfObjectName ;_cfbe ,_ccc :=_ffa .GetPatternByName (*_dee );
if _ccc {_bcbg =*_dee ;for {_cccb ,_dgg :=_cbb .GetPatternByName (_bcbg );if !_dgg ||_cccb ==_cfbe {break ;};_bcbg =*_bc .MakeName (_afe (_bcbg .String ()));};_bab :=_cbb .SetPatternByName (_bcbg ,_cfbe .ToPdfObject ());if _bab !=nil {return _bab ;};_gge [*_dee ]=_bcbg ;
};};if _egce ,_gbc :=_gge [*_dee ];_gbc {_gcb .Params [0]=&_egce ;};};};case "\u0073\u0068":if len (_gcb .Params )==1{if _gab ,_ece :=_gcb .Params [0].(*_bc .PdfObjectName );_ece {if _ ,_fge :=_abb [*_gab ];!_fge {var _ccd _bc .PdfObjectName ;_efg ,_bge :=_ffa .GetShadingByName (*_gab );
if _bge {_ccd =*_gab ;for {_ac ,_ebb :=_cbb .GetShadingByName (_ccd );if !_ebb ||_efg ==_ac {break ;};_ccd =*_bc .MakeName (_afe (_ccd .String ()));};_bae :=_cbb .SetShadingByName (_ccd ,_efg .ToPdfObject ());if _bae !=nil {_dc .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_bae );
return _bae ;};_abb [*_gab ]=_ccd ;}else {_dc .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _cbbb ,_fbd :=_abb [*_gab ];_fbd {_gcb .Params [0]=&_cbbb ;}else {_dc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_gab );
};};};case "\u0067\u0073":if len (_gcb .Params )==1{if _gdf ,_dgff :=_gcb .Params [0].(*_bc .PdfObjectName );_dgff {if _ ,_eba :=_dcb [*_gdf ];!_eba {var _faga _bc .PdfObjectName ;_dbb ,_bec :=_ffa .GetExtGState (*_gdf );if _bec {_faga =*_gdf ;for {_ebba ,_ead :=_cbb .GetExtGState (_faga );
if !_ead ||_dbb ==_ebba {break ;};_faga =*_bc .MakeName (_afe (_faga .String ()));};};_cbb .AddExtGState (_faga ,_dbb );_dcb [*_gdf ]=_faga ;};_afae :=_dcb [*_gdf ];_gcb .Params [0]=&_afae ;};};};*_bda =append (*_bda ,_gcb );};return nil ;};func _dedccg (_dafdb *templateProcessor ,_baafbb *templateNode )(interface{},error ){return _dafdb .parseBackground (_baafbb );
};func (_cdgcc *templateProcessor )processGradientColorPair (_dffbd []string )(_gccfe []Color ,_cggfg []float64 ){for _ ,_cbcae :=range _dffbd {var (_bgac =_gb .Fields (_cbcae );_ddae =len (_bgac ););if _ddae ==0{continue ;};_eaef :="";if _ddae > 1{_eaef =_gb .TrimSpace (_bgac [1]);
};_afafa :=-1.0;if _gb .HasSuffix (_eaef ,"\u0025"){_dedcc ,_defe :=_ge .ParseFloat (_eaef [:len (_eaef )-1],64);if _defe !=nil {_dc .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_defe );
};_afafa =_dedcc /100.0;};_ddcbge :=_cdgcc .parseColor (_gb .TrimSpace (_bgac [0]));if _ddcbge !=nil {_gccfe =append (_gccfe ,_ddcbge );_cggfg =append (_cggfg ,_afafa );};};if len (_gccfe )!=len (_cggfg ){_dc .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_dfgcf :=-1;_fcfg :=0.0;for _bdbgg ,_ebae :=range _cggfg {if _ebae ==-1.0{if _bdbgg ==0{_ebae =0.0;_cggfg [_bdbgg ]=0.0;continue ;};_dfgcf ++;if _bdbgg < len (_cggfg )-1{continue ;}else {_ebae =1.0;_cggfg [_bdbgg ]=1.0;};};_ffdbb :=_dfgcf +1;
for _cbagf :=_bdbgg -_dfgcf ;_cbagf < _bdbgg ;_cbagf ++{_cggfg [_cbagf ]=_fcfg +(float64 (_cbagf )*(_ebae -_fcfg )/float64 (_ffdbb ));};_fcfg =_ebae ;_dfgcf =-1;};return _gccfe ,_cggfg ;};

// Rows returns the total number of rows the table has.
func (_abcga *Table )Rows ()int {return _abcga ._agga };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_degcdd *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gcedb :=ctx ;_fcbee ,ctx ,_cdfgc :=_degcdd ._cfgfg .GeneratePageBlocks (ctx );if _cdfgc !=nil {return _fcbee ,ctx ,_cdfgc ;};for _ ,_cbad :=range _degcdd ._fdad {_ddfgd :=_cbad ._agcdg ;
if !_degcdd ._gbeeg {_cbad ._agcdg =0;};_bacef ,_gfgbd ,_ggbbf :=_cbad .GeneratePageBlocks (ctx );_cbad ._agcdg =_ddfgd ;if _ggbbf !=nil {return _fcbee ,ctx ,_ggbbf ;};if len (_bacef )< 1{continue ;};_fcbee [len (_fcbee )-1].mergeBlocks (_bacef [0]);_fcbee =append (_fcbee ,_bacef [1:]...);
ctx =_gfgbd ;};if _degcdd ._dgcg .IsRelative (){ctx .X =_gcedb .X ;};if _degcdd ._dgcg .IsAbsolute (){return _fcbee ,_gcedb ,nil ;};return _fcbee ,ctx ,nil ;};func (_cfae *templateProcessor )parseParagraph (_gaggb *templateNode ,_dcdace *StyledParagraph )(interface{},error ){if _dcdace ==nil {_dcdace =_cfae .creator .NewStyledParagraph ();
};for _ ,_cabgb :=range _gaggb ._egac .Attr {_fbefb :=_cabgb .Value ;switch _fecfd :=_cabgb .Name .Local ;_fecfd {case "\u0066\u006f\u006e\u0074":_dcdace .SetFont (_cfae .parseFontAttr (_fecfd ,_fbefb ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_dcdace .SetFontSize (_cfae .parseFloatAttr (_fecfd ,_fbefb ));
case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_dcdace .SetTextAlignment (_cfae .parseTextAlignmentAttr (_fecfd ,_fbefb ));case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_dcdace .SetLineHeight (_cfae .parseFloatAttr (_fecfd ,_fbefb ));
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_dcdace .SetEnableWrap (_cfae .parseBoolAttr (_fecfd ,_fbefb ));case "\u0063\u006f\u006co\u0072":_dcdace .SetFontColor (_cfae .parseColorAttr (_fecfd ,_fbefb ));case "\u0078":_dcdace .SetPos (_cfae .parseFloatAttr (_fecfd ,_fbefb ),_dcdace ._ebffa );
case "\u0079":_dcdace .SetPos (_dcdace ._fcgdfe ,_cfae .parseFloatAttr (_fecfd ,_fbefb ));case "\u0061\u006e\u0067l\u0065":_dcdace .SetAngle (_cfae .parseFloatAttr (_fecfd ,_fbefb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_feeda :=_cfae .parseMarginAttr (_fecfd ,_fbefb );
_dcdace .SetMargins (_feeda .Left ,_feeda .Right ,_feeda .Top ,_feeda .Bottom );case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_dcdace .SetMaxLines (int (_cfae .parseInt64Attr (_fecfd ,_fbefb )));default:_cfae .nodeLogDebug (_gaggb ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_fecfd );
};};return _dcdace ,nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fdcd *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ecgd :=ctx ;_aagffb :=[]func (_ddeb DrawContext )([]*Block ,DrawContext ,error ){_fdcd .generateHeaderBlocks ,_fdcd .generateInformationBlocks ,_fdcd .generateLineBlocks ,_fdcd .generateTotalBlocks ,_fdcd .generateNoteBlocks };
var _gfdaa []*Block ;for _ ,_eabbe :=range _aagffb {_faced ,_bcgd ,_ccefg :=_eabbe (ctx );if _ccefg !=nil {return _gfdaa ,ctx ,_ccefg ;};if len (_gfdaa )==0{_gfdaa =_faced ;}else if len (_faced )> 0{_gfdaa [len (_gfdaa )-1].mergeBlocks (_faced [0]);_gfdaa =append (_gfdaa ,_faced [1:]...);
};ctx =_bcgd ;};if _fdcd ._eagb .IsRelative (){ctx .X =_ecgd .X ;};if _fdcd ._eagb .IsAbsolute (){return _gfdaa ,_ecgd ,nil ;};return _gfdaa ,ctx ,nil ;};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_cgafb *TOCLine )SetStyle (style TextStyle ){_cgafb .Number .Style =style ;_cgafb .Title .Style =style ;_cgafb .Separator .Style =style ;_cgafb .Page .Style =style ;};

// LineWidth returns the width of the line.
func (_agca *Line )LineWidth ()float64 {return _agca ._beaa };func (_bebcf *StyledParagraph )getTextLineWidth (_egfc []*TextChunk )float64 {var _eggf float64 ;_gaag :=len (_egfc );for _ccbca ,_effd :=range _egfc {_dgfcd :=&_effd .Style ;_abfab :=len (_effd .Text );
for _gdbgc ,_cffe :=range _effd .Text {if _cffe =='\u000A'{continue ;};_aagbf ,_cbaa :=_dgfcd .Font .GetRuneMetrics (_cffe );if !_cbaa {_dc .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_cffe );
return -1;};_eggf +=_dgfcd .FontSize *_aagbf .Wx *_dgfcd .horizontalScale ();if _cffe !=' '&&(_ccbca !=_gaag -1||_gdbgc !=_abfab -1){_eggf +=_dgfcd .CharSpacing *1000.0;};};};return _eggf ;};

// Vertical returns total vertical (top + bottom) margin.
func (_aedb *Margins )Vertical ()float64 {return _aedb .Bottom +_aedb .Top };

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_fbcc *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbbgf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gfad ,_aggf :=_bbbgf .setOpacity (_fbcc ._gbcb ,_fbcc ._gbcb );if _aggf !=nil {return nil ,ctx ,_aggf ;};_fccf :=_fbcc ._bfde .Points ;
for _defd :=range _fccf {_ecaa :=&_fccf [_defd ];_ecaa .Y =ctx .PageHeight -_ecaa .Y ;};_dcbfa ,_ ,_aggf :=_fbcc ._bfde .MarkedDraw (_gfad ,_fbcc ._cgfe );if _aggf !=nil {return nil ,ctx ,_aggf ;};if _aggf =_bbbgf .addContentsByString (string (_dcbfa ));
_aggf !=nil {return nil ,ctx ,_aggf ;};return []*Block {_bbbgf },ctx ,nil ;};func (_bfbeb *templateProcessor )parseMarginAttr (_dbfafa ,_fageb string )Margins {_dc .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_dbfafa ,_fageb );
_ggcec :=Margins {};switch _dbag :=_gb .Fields (_fageb );len (_dbag ){case 1:_ggcec .Top ,_ =_ge .ParseFloat (_dbag [0],64);_ggcec .Bottom =_ggcec .Top ;_ggcec .Left =_ggcec .Top ;_ggcec .Right =_ggcec .Top ;case 2:_ggcec .Top ,_ =_ge .ParseFloat (_dbag [0],64);
_ggcec .Bottom =_ggcec .Top ;_ggcec .Left ,_ =_ge .ParseFloat (_dbag [1],64);_ggcec .Right =_ggcec .Left ;case 3:_ggcec .Top ,_ =_ge .ParseFloat (_dbag [0],64);_ggcec .Left ,_ =_ge .ParseFloat (_dbag [1],64);_ggcec .Right =_ggcec .Left ;_ggcec .Bottom ,_ =_ge .ParseFloat (_dbag [2],64);
case 4:_ggcec .Top ,_ =_ge .ParseFloat (_dbag [0],64);_ggcec .Right ,_ =_ge .ParseFloat (_dbag [1],64);_ggcec .Bottom ,_ =_ge .ParseFloat (_dbag [2],64);_ggcec .Left ,_ =_ge .ParseFloat (_dbag [3],64);};return _ggcec ;};

// AddHighlightedText adds a new highlighted text to the paragraph.
func (_gfaff *StyledParagraph )AddHighlightedText (text string ,color Color ,alpha float64 )*TextChunk {_eddcb :=NewTextChunk (text ,_gfaff ._fdeab );_eddcb .Highlight (color ,alpha );return _gfaff .appendChunk (_eddcb );};

// SetPos sets absolute positioning with specified coordinates.
func (_ddeae *Paragraph )SetPos (x ,y float64 ){_ddeae ._egaac =PositionAbsolute ;_ddeae ._gfec =x ;_ddeae ._fgffa =y ;};func _bddab (_gccd [][]_fg .Point )*Polygon {return &Polygon {_bccge :&_fg .Polygon {Points :_gccd },_adgb :1.0,_gcgd :1.0};};

// SetFillOpacity sets the fill opacity.
func (_dfgc *PolyBezierCurve )SetFillOpacity (opacity float64 ){_dfgc ._agac =opacity };

// NewTOCLine creates a new table of contents line with the default style.
func (_bbfe *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _bedfd (number ,title ,page ,level ,_bbfe .NewTextStyle ());};

// SetColorTop sets border color for top.
func (_cefe *border )SetColorTop (col Color ){_cefe ._aef =col };func _gcaeg (_dadga *_be .File )([]*_cd .PdfPage ,error ){_geadb ,_ddcbe :=_cd .NewPdfReader (_dadga );if _ddcbe !=nil {return nil ,_ddcbe ;};_edaf ,_ddcbe :=_geadb .GetNumPages ();if _ddcbe !=nil {return nil ,_ddcbe ;
};var _ddefg []*_cd .PdfPage ;for _ceeca :=0;_ceeca < _edaf ;_ceeca ++{_eadgbf ,_gcece :=_geadb .GetPage (_ceeca +1);if _gcece !=nil {return nil ,_gcece ;};_ddefg =append (_ddefg ,_eadgbf );};return _ddefg ,nil ;};func _febae (_abaea string )(_cbgf []float64 ,_gdbef error ){var _ceaf float64 ;
_gfefe :=0;_edged :=true ;for _fcfgc ,_cagf :=range _abaea {if _cagf =='.'{if _edged {_edged =false ;continue ;};_ceaf ,_gdbef =_cagdb (_abaea [_gfefe :_fcfgc ],64);if _gdbef !=nil {return ;};_cbgf =append (_cbgf ,_ceaf );_gfefe =_fcfgc ;};};_ceaf ,_gdbef =_cagdb (_abaea [_gfefe :],64);
if _gdbef !=nil {return ;};_cbgf =append (_cbgf ,_ceaf );return ;};func (_bfed *Creator )setActivePage (_eeab *_cd .PdfPage ){_bfed ._deg =_eeab };func (_abbfd *Invoice )newColumn (_cgffg string ,_bage CellHorizontalAlignment )*InvoiceCell {_dddg :=&InvoiceCell {_abbfd ._caeaa ,_cgffg };
_dddg .Alignment =_bage ;return _dddg ;};

// Positioning returns the type of positioning the ellipse is set to use.
func (_cddbf *Ellipse )Positioning ()Positioning {return _cddbf ._cddb };

// Append adds a new text chunk to the paragraph.
func (_dfeg *StyledParagraph )Append (text string )*TextChunk {_gdeab :=NewTextChunk (text ,_dfeg ._fdeab );return _dfeg .appendChunk (_gdeab );};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;type commands struct{_gcdge []string ;_fabgg map[string ]int ;_acddf string ;_ecedc string ;};

// Command is a representation of an SVG path command and its parameters.
type Command struct{Symbol string ;Params []float64 ;};func (_faef *pageTransformations )transformPage (_dbd *_cd .PdfPage )error {if _cegf :=_faef .applyFlip (_dbd );_cegf !=nil {return _cegf ;};return nil ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_fffd int ;_dfcf string ;_cgcg *StyledParagraph ;_aed []Drawable ;_bce int ;_fbgf bool ;_eefa bool ;_bdc Positioning ;_afba ,_gec float64 ;_ggaf Margins ;_bceb *Chapter ;_cag *TOC ;_fad *_cd .Outline ;_ffbb *_cd .OutlineItem ;_gfa uint ;
};func (_eaad *GraphicSVGElement )drawText (_dcfbff *_ca .ContentCreator ,_cfbdf *_cd .PdfPageResources ){_dcfbff .Add_BT ();_bcccb ,_aaaeb :=_cagdb (_eaad .Attributes ["\u0078"],64);if _aaaeb !=nil {_dc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0078\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_aaaeb .Error ());
};_gabfe ,_aaaeb :=_cagdb (_eaad .Attributes ["\u0079"],64);if _aaaeb !=nil {_dc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0079\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_aaaeb .Error ());
};_adec :=_eaad .Attributes ["\u0066\u0069\u006c\u006c"];var _ggbb ,_aebb ,_ecbe float64 ;if _ggdf ,_cfabd :=_ff .ColorMap [_adec ];_cfabd {_dabd ,_egecb ,_beca ,_ :=_ggdf .RGBA ();_ggbb ,_aebb ,_ecbe =float64 (_dabd ),float64 (_egecb ),float64 (_beca );
}else if _gb .HasPrefix (_adec ,"\u0072\u0067\u0062\u0028"){_ggbb ,_aebb ,_ecbe =_bgaac (_adec );}else {_ggbb ,_aebb ,_ecbe =ColorRGBFromHex (_adec ).ToRGB ();};_dcfbff .Add_rg (_ggbb ,_aebb ,_ecbe );_cgea :=_aebf ;if _fgfgb ,_dgae :=_eaad .Attributes ["\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae"];
_dgae {_cgea ,_aaaeb =_ge .ParseFloat (_fgfgb ,64);if _aaaeb !=nil {_dc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067 \u0060\u0066\u006f\u006e\u0074\u002d\u0073\u0069\u007a\u0065\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_aaaeb .Error ());
_cgea =_aebf ;};};_effb :=_eaad ._ddccg *_cgea *PPI /_aeg ;_ebgg :=_bc .PdfObjectName ("\u0053\u0046\u006fn\u0074");_abac :=_cd .DefaultFont ();_eaab ,_aacgg :=_eaad .Attributes ["f\u006f\u006e\u0074\u002d\u0066\u0061\u006d\u0069\u006c\u0079"];if _aacgg {if _bggfg ,_gebcc :=_fbeac (_eaab );
_gebcc ==nil {_abac =_bggfg ;_cade :=1;for _cfbdf .HasFontByName (_ebgg ){_ebgg =_bc .PdfObjectName ("\u0053\u0046\u006fn\u0074"+_ge .Itoa (_cade ));_cade ++;};};};_abce :=0.0;_bcccf ,_aacgg :=_eaad .Attributes ["t\u0065\u0078\u0074\u002d\u0061\u006e\u0063\u0068\u006f\u0072"];
if _aacgg &&_bcccf !="\u0073\u0074\u0061r\u0074"{var _eecfg float64 ;for _ ,_fgca :=range _eaad .Content {_bdcec ,_dfccd :=_abac .GetRuneMetrics (_fgca );if !_dfccd {_dc .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074e\u0064 \u0072u\u006e\u0065\u0020\u0025\u0076\u0020\u0069\u006e\u0020\u0066\u006f\u006e\u0074",_fgca );
};_eecfg +=_bdcec .Wx ;};_eecfg =_eecfg *_effb /1000.0;if _bcccf =="\u006d\u0069\u0064\u0064\u006c\u0065"{_abce =-_eecfg /2;}else if _bcccf =="\u0065\u006e\u0064"{_abce =-_eecfg ;};};_dcfbff .Add_Tm (1,0,0,-1,_bcccb *_eaad ._ddccg +_abce ,_gabfe *_eaad ._ddccg );
_cfbdf .SetFontByName (_ebgg ,_abac .ToPdfObject ());_dcfbff .Add_Tf (_ebgg ,_effb );_adea :=_eaad .Content ;_baeca :=_bc .MakeString (_adea );_dcfbff .Add_Tj (*_baeca );_dcfbff .Add_ET ();};type componentRenderer interface{Draw (_efca Drawable )error ;
};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_efbdfb *LinearShading )ToPdfShadingPattern ()*_cd .PdfShadingPatternType2 {_gcee ,_ecgfa ,_cecdc :=_efbdfb ._eadf ._bcagg .ToRGB ();_aebd :=_efbdfb .shadingModel ();_aebd .PdfShading .Background =_bc .MakeArrayFromFloats ([]float64 {_gcee ,_ecgfa ,_cecdc });
_caae :=_cd .NewPdfShadingPatternType2 ();_caae .Shading =_aebd ;return _caae ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_bccb *Invoice )Sections ()[][2]string {return _bccb ._edad };

// Link returns link information for this line.
func (_dgdec *TOCLine )Link ()(_bagbf int64 ,_bcdfce ,_cdbga float64 ){return _dgdec ._agcdg ,_dgdec ._acgc ,_dgdec ._bdegf ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//
//	red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_fdcca :_fb .Min (float64 (c ),100)/100.0,_aaac :_fb .Min (float64 (m ),100)/100.0,_fcda :_fb .Min (float64 (y ),100)/100.0,_cce :_fb .Min (float64 (k ),100)/100.0};};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_gecbe *RadialShading )SetExtends (start bool ,end bool ){_gecbe ._aaaed .SetExtends (start ,end )};func (_dcca *Table )getLastCellFromCol (_gfbe int )(int ,*TableCell ){for _gfgb :=len (_dcca ._bbdb )-1;_gfgb >=0;_gfgb --{if _dcca ._bbdb [_gfgb ]._gdgcb ==_gfbe {return _gfgb ,_dcca ._bbdb [_gfgb ];
};};return 0,nil ;};

// SetBorderRadius sets the radius of the rectangle corners.
func (_bbfeb *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_bbfeb ._fegba =topLeft ;_bbfeb ._gaabc =topRight ;_bbfeb ._fdccg =bottomLeft ;_bbfeb ._ccgf =bottomRight ;};

// Color returns the color of the line.
func (_ecfb *Line )Color ()Color {return _ecfb ._baad };

// SetFont sets the font for the paragraph.
func (_acebe *StyledParagraph )SetFont (font *_cd .PdfFont ){_acebe ._fdeab .Font =font ;for _ ,_ebeb :=range _acebe ._gceca {_ebeb .Style .Font =font ;};};

// Height returns the total height of all rows.
func (_badd *Grid )Height ()float64 {_agab :=float64 (0.0);for _ ,_becfd :=range _badd ._dgaa {_agab +=_becfd ._facac ;};return _agab ;};

// Margins returns the margins of the component.
func (_aggg *Division )Margins ()(_baae ,_bcdg ,_edgd ,_eagd float64 ){return _aggg ._bdbe .Left ,_aggg ._bdbe .Right ,_aggg ._bdbe .Top ,_aggg ._bdbe .Bottom ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_bebag *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_gecda float64 ;_bedfe uint ;_fcegc float64 ;_gfeca Positioning ;_acgc float64 ;_bdegf float64 ;_agcdg int64 ;};

// NewTable create a new Table with a specified number of columns.
func (_acf *Creator )NewTable (cols int )*Table {return _bbab (cols )};

// BorderColor returns the border color of the ellipse.
func (_acfc *Ellipse )BorderColor ()Color {return _acfc ._bbeba };

// SetMarkedContentID sets the marked content ID for the text chunk.
func (_bfebf *TextChunk )SetMarkedContentID (mcid int64 )*_cd .KDict {_bfebf ._fdaee =&mcid ;_bfefe :=_cd .NewKDictionary ();_bfefe .S =_bc .MakeName ("\u0053\u0070\u0061\u006e");_bfefe .K =_bc .MakeInteger (mcid );return _bfefe ;};func (_feaac *TableCell )width (_eacdg []float64 ,_edcfd float64 )float64 {_acagbf :=float64 (0.0);
for _baeba :=0;_baeba < _feaac ._abfbd ;_baeba ++{_acagbf +=_eacdg [_feaac ._gdgcb +_baeba -1];};return _acagbf *_edcfd ;};func (_gafab *templateProcessor )renderNode (_bceeb *templateNode )error {_eebfa :=_bceeb ._bedgb ;if _eebfa ==nil {return nil ;};
_deca :=_bceeb ._egac .Name .Local ;_egcga ,_ddee :=_gcadgb [_deca ];if !_ddee {_gafab .nodeLogDebug (_bceeb ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_deca );
return nil ;};var _fbcfc interface{};if _bceeb ._fafg !=nil &&_bceeb ._fafg ._bedgb !=nil {_dgea :=_bceeb ._fafg ._egac .Name .Local ;if _ ,_ddee =_egcga ._abbdg [_dgea ];!_ddee {_gafab .nodeLogDebug (_bceeb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_dgea ,_deca );
return _bfcee ;};_fbcfc =_bceeb ._fafg ._bedgb ;}else {_abegf :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _gafab ._fgbad .(type ){case *Block :_abegf ="\u0062\u006c\u006fc\u006b";};if _ ,_ddee =_egcga ._abbdg [_abegf ];!_ddee {_gafab .nodeLogDebug (_bceeb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_abegf ,_deca );
return _bfcee ;};_fbcfc =_gafab ._fgbad ;};switch _fdcfg :=_fbcfc .(type ){case componentRenderer :_fcac ,_efdbdb :=_eebfa .(Drawable );if !_efdbdb {_gafab .nodeLogError (_bceeb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_deca ,_eebfa );
return _dfced ;};_aeede :=_fdcfg .Draw (_fcac );if _aeede !=nil {return _gafab .nodeError (_bceeb ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_deca ,_eebfa ,_aeede );
};case *Division :switch _fgaeb :=_eebfa .(type ){case *Background :_fdcfg .SetBackground (_fgaeb );case VectorDrawable :_beag :=_fdcfg .Add (_fgaeb );if _beag !=nil {return _gafab .nodeError (_bceeb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_deca ,_eebfa ,_beag );
};};case *TableCell :_dggff ,_addb :=_eebfa .(VectorDrawable );if !_addb {_gafab .nodeLogError (_bceeb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_deca ,_eebfa );
return _dfced ;};_fdbag :=_fdcfg .SetContent (_dggff );if _fdbag !=nil {return _gafab .nodeError (_bceeb ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_deca ,_eebfa ,_fdbag );
};case *StyledParagraph :_cced ,_cdae :=_eebfa .(*TextChunk );if !_cdae {_gafab .nodeLogError (_bceeb ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_deca ,_eebfa );
return _dfced ;};_fdcfg .appendChunk (_cced );case *Chapter :switch _dgfbe :=_eebfa .(type ){case *Chapter :return nil ;case *StyledParagraph :if _bceeb ._egac .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_dcfbb :=_fdcfg .Add (_dgfbe );if _dcfbb !=nil {return _gafab .nodeError (_bceeb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_deca ,_eebfa ,_dcfbb );
};case Drawable :_feba :=_fdcfg .Add (_dgfbe );if _feba !=nil {return _gafab .nodeError (_bceeb ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_deca ,_eebfa ,_feba );
};};case *List :switch _fdec :=_eebfa .(type ){case *TextChunk :case *listItem :_fdcfg ._ebfe =append (_fdcfg ._ebfe ,_fdec );default:_gafab .nodeLogError (_bceeb ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_deca ,_eebfa );
};case *listItem :switch _dbbdf :=_eebfa .(type ){case *TextChunk :case *StyledParagraph :_fdcfg ._adfbbg =_dbbdf ;case *List :if _dbbdf ._fdeafc {_dbbdf ._acag =15;};_fdcfg ._adfbbg =_dbbdf ;case *Image :_fdcfg ._adfbbg =_dbbdf ;case *Division :_fdcfg ._adfbbg =_dbbdf ;
case *Table :_fdcfg ._adfbbg =_dbbdf ;default:_gafab .nodeLogError (_bceeb ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_deca ,_eebfa );
return _dfced ;};};return nil ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_feee *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggeaa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_aaacg ,_ffaf :=_ggeaa .setOpacity (_feee ._agac ,_feee ._efbdf );if _ffaf !=nil {return nil ,ctx ,_ffaf ;
};_cagca :=_feee ._begb ;_cagca .FillEnabled =_cagca .FillColor !=nil ;var (_ebcff =ctx .PageHeight ;_cgcgc =_cagca .Curves ;_cbdea =make ([]_fg .CubicBezierCurve ,0,len (_cagca .Curves )););_ddabd :=_cd .PdfRectangle {};for _affbe :=range _cagca .Curves {_ddfa :=_cgcgc [_affbe ];
_ddfa .P0 .Y =_ebcff -_ddfa .P0 .Y ;_ddfa .P1 .Y =_ebcff -_ddfa .P1 .Y ;_ddfa .P2 .Y =_ebcff -_ddfa .P2 .Y ;_ddfa .P3 .Y =_ebcff -_ddfa .P3 .Y ;_cbdea =append (_cbdea ,_ddfa );_bedfc :=_ddfa .GetBounds ();if _affbe ==0{_ddabd =_bedfc ;}else {_ddabd .Llx =_fb .Min (_ddabd .Llx ,_bedfc .Llx );
_ddabd .Lly =_fb .Min (_ddabd .Lly ,_bedfc .Lly );_ddabd .Urx =_fb .Max (_ddabd .Urx ,_bedfc .Urx );_ddabd .Ury =_fb .Max (_ddabd .Ury ,_bedfc .Ury );};};_cagca .Curves =_cbdea ;defer func (){_cagca .Curves =_cgcgc }();if _cagca .FillEnabled {_bcfb :=_daeg (_ggeaa ,_feee ._begb .FillColor ,_feee ._aagbc ,func ()Rectangle {return Rectangle {_aaabb :_ddabd .Llx ,_adebb :_ddabd .Lly ,_dcdaf :_ddabd .Width (),_dbab :_ddabd .Height ()};
});if _bcfb !=nil {return nil ,ctx ,_bcfb ;};};_defag ,_ ,_ffaf :=_cagca .MarkedDraw (_aaacg ,_feee ._afdg );if _ffaf !=nil {return nil ,ctx ,_ffaf ;};if _ffaf =_ggeaa .addContentsByString (string (_defag ));_ffaf !=nil {return nil ,ctx ,_ffaf ;};return []*Block {_ggeaa },ctx ,nil ;
};

// GraphicSVGElement represents SVG instances.
type GraphicSVGElement struct{

// ViewBox represents viewBox value of element.
ViewBox struct{X ,Y ,W ,H float64 ;};

// Name of element.
Name string ;

// Attributes of element.
Attributes map[string ]string ;

// Children elements.
Children []*GraphicSVGElement ;

// Content contains text value of element.
Content string ;

// Style element style attribute.
Style *GraphicSVGStyle ;

// Width of element.
Width float64 ;

// Height of element.
Height float64 ;_ddccg float64 ;_afdf map[string ]*LinearShading ;_bgca map[string ]*RadialShading ;_cagc float64 ;_agdf float64 ;};

// Height returns the total height of all rows.
func (_bedcc *Table )Height ()float64 {_gcgdc :=float64 (0.0);for _ ,_ebgae :=range _bedcc ._cbaab {_gcgdc +=_ebgae ;};return _gcgdc ;};func _afacf (_cafaa ,_cegbf interface{})(interface{},error ){_ddfb ,_ggfb :=_bcdce (_cafaa );if _ggfb !=nil {return nil ,_ggfb ;
};switch _fabbb :=_ddfb .(type ){case int64 :_dgbde ,_bafcg :=_bcdce (_cegbf );if _bafcg !=nil {return nil ,_bafcg ;};switch _aegcfe :=_dgbde .(type ){case int64 :return _fabbb +_aegcfe ,nil ;case float64 :return float64 (_fabbb )+_aegcfe ,nil ;};case float64 :_dcged ,_fgcb :=_bcdce (_cegbf );
if _fgcb !=nil {return nil ,_fgcb ;};switch _aebba :=_dcged .(type ){case int64 :return _fabbb +float64 (_aebba ),nil ;case float64 :return _fabbb +_aebba ,nil ;};};return nil ,_a .Errorf ("\u0066\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0025\u0076\u0020\u0061\u006e\u0064\u0020\u0025\u0076",_cafaa ,_cegbf );
};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_gabfg *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_fccb :=NewTextChunk (text ,_gabfg ._caefe );_fccb .AddAnnotation (_ccggb (url ));return _gabfg .appendChunk (_fccb );};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_eede *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_eede ._dcgcb =valign };

// Title returns the title of the invoice.
func (_acfcd *Invoice )Title ()string {return _acfcd ._dffb };

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_fbdcd *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_bdgb *_cd .PdfWriter )error ){_fbdcd ._egd =pdfWriterAccessFunc ;};

// SetFillColor sets the fill color.
func (_gcbe *Polygon )SetFillColor (color Color ){_gcbe ._gaaeb =color ;_gcbe ._bccge .FillColor =_dfd (color );};func _aacfgb (_acggg *templateProcessor ,_gcab *templateNode )(interface{},error ){return _acggg .parsePageBreak (_gcab );};

// Positioning returns the type of positioning the line is set to use.
func (_agabd *Line )Positioning ()Positioning {return _agabd ._dcac };func (_beeac *templateProcessor )parseTable (_gcbc *templateNode )(interface{},error ){var _begd int64 ;for _ ,_faefde :=range _gcbc ._egac .Attr {_ffdf :=_faefde .Value ;switch _bcafb :=_faefde .Name .Local ;
_bcafb {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_begd =_beeac .parseInt64Attr (_bcafb ,_ffdf );};};if _begd <=0{_beeac .nodeLogDebug (_gcbc ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_begd );
_begd =1;};_fcba :=_beeac .creator .NewTable (int (_begd ));for _ ,_baafb :=range _gcbc ._egac .Attr {_acdff :=_baafb .Value ;switch _egcec :=_baafb .Name .Local ;_egcec {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_fcba .SetColumnWidths (_beeac .parseFloatArray (_egcec ,_acdff )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_ffecf :=_beeac .parseMarginAttr (_egcec ,_acdff );_fcba .SetMargins (_ffecf .Left ,_ffecf .Right ,_ffecf .Top ,_ffecf .Bottom );case "\u0078":_fcba .SetPos (_beeac .parseFloatAttr (_egcec ,_acdff ),_fcba ._facedb );
case "\u0079":_fcba .SetPos (_fcba ._geacc ,_beeac .parseFloatAttr (_egcec ,_acdff ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_fcba ._bfbdae =int (_beeac .parseInt64Attr (_egcec ,_acdff ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_fcba ._gedae =int (_beeac .parseInt64Attr (_egcec ,_acdff ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_fcba .EnableRowWrap (_beeac .parseBoolAttr (_egcec ,_acdff ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_fcba .EnablePageWrap (_beeac .parseBoolAttr (_egcec ,_acdff ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_beeac .nodeLogDebug (_gcbc ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_egcec );
};};if _fcba ._bfbdae !=0&&_fcba ._gedae !=0{_agcbf :=_fcba .SetHeaderRows (_fcba ._bfbdae ,_fcba ._gedae );if _agcbf !=nil {_beeac .nodeLogDebug (_gcbc ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_agcbf );
};}else {_fcba ._bfbdae =0;_fcba ._gedae =0;};return _fcba ,nil ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_baa *Block )ScaleToHeight (h float64 ){_fag :=h /_baa ._dff ;_baa .Scale (_fag ,_fag )};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_bdfdg *TOCLine )SetLink (page int64 ,x ,y float64 ){_bdfdg ._acgc =x ;_bdfdg ._bdegf =y ;_bdfdg ._agcdg =page ;_adfde :=_bdfdg ._bebag ._caefe .Color ;_bdfdg .Number .Style .Color =_adfde ;_bdfdg .Title .Style .Color =_adfde ;_bdfdg .Separator .Style .Color =_adfde ;
_bdfdg .Page .Style .Color =_adfde ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_aaaf *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _aaaf ._bedb [0],_aaaf ._bedb [1]};func _ddec (_gcag *Block ,_bdedb *StyledParagraph ,_adcg [][]*TextChunk ,_gebee DrawContext )(DrawContext ,[][]*TextChunk ,error ){_ddcab :=1;_fgdbc :=_bc .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ddcab ));
for _gcag ._bcb .HasFontByName (_fgdbc ){_ddcab ++;_fgdbc =_bc .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ddcab ));};_aaff :=_gcag ._bcb .SetFontByName (_fgdbc ,_bdedb ._fdeab .Font .ToPdfObject ());if _aaff !=nil {return _gebee ,nil ,_aaff ;
};_ddcab ++;_eagbd :=_fgdbc ;_afccf :=_bdedb ._fdeab .FontSize ;_agdb :=_bdedb ._gaabe .IsRelative ();var _gbccff [][]_bc .PdfObjectName ;var _cdea [][]*TextChunk ;var _acaf float64 ;for _adeg ,_bdcg :=range _adcg {var _bacc []_bc .PdfObjectName ;var _caga float64 ;
if len (_bdcg )> 0{_caga =_bdcg [0].Style .FontSize ;};for _ ,_fbcdb :=range _bdcg {_feff :=_fbcdb .Style ;if _fbcdb .Text !=""&&_feff .FontSize > _caga {_caga =_feff .FontSize ;};if _caga > _gebee .PageHeight {return _gebee ,nil ,_ga .New ("\u0050\u0061\u0072\u0061\u0067\u0072a\u0070\u0068\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u006ca\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0070\u0061\u0067\u0065 \u0068e\u0069\u0067\u0068\u0074");
};_fgdbc =_bc .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ddcab ));_dfbge :=_gcag ._bcb .SetFontByName (_fgdbc ,_feff .Font .ToPdfObject ());if _dfbge !=nil {return _gebee ,nil ,_dfbge ;};_bacc =append (_bacc ,_fgdbc );_ddcab ++;
};_caga *=_bdedb ._gdaeca ;if _agdb &&_acaf +_caga > _gebee .Height {_cdea =_adcg [_adeg :];_adcg =_adcg [:_adeg ];break ;};_acaf +=_caga ;_gbccff =append (_gbccff ,_bacc );};_affbg ,_gebce ,_dbea :=_bdedb .getLineMetrics (0);_edcba ,_agba :=_affbg *_bdedb ._gdaeca ,_gebce *_bdedb ._gdaeca ;
if len (_adcg )==0{return _gebee ,_cdea ,nil ;};_eddg :=_ca .NewContentCreator ();_eddg .Add_q ();_bggee :=_agba ;if _bdedb ._dadf ==TextVerticalAlignmentCenter {_bggee =_gebce +(_affbg +_dbea -_gebce )/2+(_agba -_gebce )/2;};_gfcae :=_gebee .PageHeight -_gebee .Y -_bggee ;
_eddg .Translate (_gebee .X ,_gfcae );_bccc :=_gfcae ;if _bdedb ._dcfd !=0{_eddg .RotateDeg (_bdedb ._dcfd );};if _bdedb ._adbcd ==TextOverflowHidden {_eddg .Add_re (0,-_acaf +_edcba +1,_bdedb ._gabb ,_acaf ).Add_W ().Add_n ();};_eddg .Add_BT ();_beee :=map[string ]_bc .PdfObject {};
if _bdedb ._bfdcc !=nil {_beee ["\u004d\u0043\u0049\u0044"]=_bc .MakeInteger (*_bdedb ._bfdcc );};if _bdedb ._begca !=""{_beee ["\u004c\u0061\u006e\u0067"]=_bc .MakeString (_bdedb ._begca );};if len (_beee )> 0{_eddg .Add_BDC (*_bc .MakeName (_cd .StructureTypeParagraph ),_beee );
};var _dedf []*_fg .BasicLine ;for _gefbf ,_acfabb :=range _adcg {_facef :=_gebee .X ;var _adbfg float64 ;if len (_acfabb )> 0{_adbfg =_acfabb [0].Style .FontSize ;};_affbg ,_ ,_dbea =_bdedb .getLineMetrics (_gefbf );_agba =(_affbg +_dbea );for _ ,_abdd :=range _acfabb {_dafdg :=&_abdd .Style ;
if _abdd .Text !=""&&_dafdg .FontSize > _adbfg {_adbfg =_dafdg .FontSize ;};if _agba > _adbfg {_adbfg =_agba ;};};if _gefbf !=0{_eddg .Add_TD (0,-_adbfg *_bdedb ._gdaeca );_bccc -=_adbfg *_bdedb ._gdaeca ;};_afbca :=_gefbf ==len (_adcg )-1;var (_cbag float64 ;
_cfdb float64 ;_gabbe *fontMetrics ;_eegfc float64 ;_cafe uint ;);var _fggbb []float64 ;for _ ,_dgccc :=range _acfabb {_ecff :=&_dgccc .Style ;if _ecff .FontSize > _cfdb {_cfdb =_ecff .FontSize ;_gabbe =_dfgf (_dgccc .Style .Font ,_ecff .FontSize );};if _agba > _cfdb {_cfdb =_agba ;
};_dafdgc ,_abaga :=_ecff .Font .GetRuneMetrics (' ');if _dafdgc .Wx ==0&&_ecff .MultiFont !=nil {_dafdgc ,_abaga =_ecff .MultiFont .GetRuneMetrics (' ');_ecff .MultiFont .Reset ();};if !_abaga {return _gebee ,nil ,_ga .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _deae uint ;var _gcdc float64 ;_faefd :=len (_dgccc .Text );for _ddaba ,_edgdb :=range _dgccc .Text {if _edgdb ==' '{_deae ++;continue ;};if _edgdb =='\u000A'{continue ;};_aega ,_bcecd :=_ecff .Font .GetRuneMetrics (_edgdb );if _aega .Wx ==0&&_ecff .MultiFont !=nil {_aega ,_bcecd =_ecff .MultiFont .GetRuneMetrics (' ');
_ecff .MultiFont .Reset ();};if !_bcecd {_dc .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_edgdb );return _gebee ,nil ,_ga .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");
};_gcdc +=_ecff .FontSize *_aega .Wx *_ecff .horizontalScale ();if _ddaba !=_faefd -1{_gcdc +=_ecff .CharSpacing *1000.0;};};_fggbb =append (_fggbb ,_gcdc );_cbag +=_gcdc ;_eegfc +=float64 (_deae )*_dafdgc .Wx *_ecff .FontSize *_ecff .horizontalScale ();
_cafe +=_deae ;};_cfdb *=_bdedb ._gdaeca ;var _aefdc []_bc .PdfObject ;_gaaae :=_bdedb ._gabb *1000.0;if _bdedb ._dddb ==TextAlignmentJustify {if _cafe > 0&&!_afbca {_eegfc =(_gaaae -_cbag )/float64 (_cafe )/_afccf ;};}else if _bdedb ._dddb ==TextAlignmentCenter {_deaeb :=(_gaaae -_cbag -_eegfc )/2;
_egcfe :=_deaeb /_afccf ;_aefdc =append (_aefdc ,_bc .MakeFloat (-_egcfe ));_facef +=_deaeb /1000.0;}else if _bdedb ._dddb ==TextAlignmentRight {_cccaa :=(_gaaae -_cbag -_eegfc );_cgac :=_cccaa /_afccf ;_aefdc =append (_aefdc ,_bc .MakeFloat (-_cgac ));
_facef +=_cccaa /1000.0;};if len (_aefdc )> 0{_eddg .Add_Tf (_eagbd ,_afccf ).Add_TL (_afccf *_bdedb ._gdaeca ).Add_TJ (_aefdc ...);};_dccba :=0.0;for _eefdb ,_dfbac :=range _acfabb {_bcbge :=&_dfbac .Style ;_ageec :=_eagbd ;_fgcfe :=_afccf ;_aggcd :=_bcbge .OutlineColor !=nil ;
_fcbf :=_bcbge .HorizontalScaling !=DefaultHorizontalScaling ;_aecae :=_bcbge .OutlineSize !=1;if _aecae {_eddg .Add_w (_bcbge .OutlineSize );};_ecagb :=_bcbge .RenderingMode !=TextRenderingModeFill ;if _ecagb {_eddg .Add_Tr (int64 (_bcbge .RenderingMode ));
};_fbfgf :=_bcbge .CharSpacing !=0;if _fbfgf {_eddg .Add_Tc (_bcbge .CharSpacing );};_edddb :=_bcbge .TextRise !=0;if _edddb {_eddg .Add_Ts (_bcbge .TextRise );};if _dfbac .VerticalAlignment !=TextVerticalAlignmentBaseline {_aebff :=_dfgf (_dfbac .Style .Font ,_bcbge .FontSize );
switch _dfbac .VerticalAlignment {case TextVerticalAlignmentCenter :_dccba =_gabbe ._cgdcd /2-_aebff ._cgdcd /2;case TextVerticalAlignmentBottom :_dccba =_gabbe ._fdfbeg -_aebff ._fdfbeg ;case TextVerticalAlignmentTop :_dccba =_gebce -_bcbge .FontSize ;
};if _dccba !=0.0{_eddg .Translate (0,_dccba );};};if _bdedb ._dddb !=TextAlignmentJustify ||_afbca {_dbadg ,_ffab :=_bcbge .Font .GetRuneMetrics (' ');if !_ffab {return _gebee ,nil ,_ga .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};_ageec =_gbccff [_gefbf ][_eefdb ];_fgcfe =_bcbge .FontSize ;_eegfc =_dbadg .Wx *_bcbge .horizontalScale ();};_abcg :=_bcbge .Font .Encoder ();var _abeeb []byte ;var _badgg bool ;_egcd :=_bcbge .Font ;_eggc :=map[string ]_bc .PdfObject {};if _dfbac ._dfcgg !=nil {_eggc ["\u0045"]=_bc .MakeString (*_dfbac ._dfcgg );
};if _dfbac ._ccgfa !=nil {_eggc ["\u0041\u0063\u0074\u0075\u0061\u006c\u0054\u0065\u0078\u0074"]=_bc .MakeString (*_dfbac ._ccgfa );};if _dfbac ._fdaee !=nil {_eggc ["\u004d\u0043\u0049\u0044"]=_bc .MakeInteger (*_dfbac ._fdaee );};if len (_eggc )> 0{_eddg .Add_BDC (*_bc .MakeName (_cd .StructureTypeSpan ),_eggc );
};for _ ,_bdbg :=range _dfbac .Text {if _bdbg =='\u000A'{continue ;};if _bdbg ==' '{if len (_abeeb )> 0{if _aggcd {_eddg .SetStrokingColor (_dfd (_bcbge .OutlineColor ));};if _fcbf {_eddg .Add_Tz (_bcbge .HorizontalScaling );};_afbe :=_gbccff [_gefbf ][_eefdb ];
if _badgg {_afbe =_bc .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ddcab ));_dgdea :=_gcag ._bcb .SetFontByName (_afbe ,_egcd .ToPdfObject ());if _dgdea !=nil {return _gebee ,nil ,_dgdea ;};_ddcab ++;_badgg =false ;_abcg =_bcbge .Font .Encoder ();
};_eddg .SetNonStrokingColor (_dfd (_bcbge .Color )).Add_Tf (_afbe ,_bcbge .FontSize ).Add_TJ ([]_bc .PdfObject {_bc .MakeStringFromBytes (_abeeb )}...);_abeeb =nil ;};if _fcbf {_eddg .Add_Tz (DefaultHorizontalScaling );};_eddg .Add_Tf (_ageec ,_fgcfe ).Add_TJ ([]_bc .PdfObject {_bc .MakeFloat (-_eegfc )}...);
_fggbb [_eefdb ]+=_eegfc *_fgcfe ;}else {if _ ,_gabaf :=_abcg .RuneToCharcode (_bdbg );!_gabaf {if _bcbge .MultiFont !=nil {_ebebf ,_baedb :=_bcbge .MultiFont .Encoder (_bdbg );if _baedb {if len (_abeeb )!=0{_cgad :=_bc .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ddcab ));
_ffbef :=_gcag ._bcb .SetFontByName (_ageec ,_egcd .ToPdfObject ());if _ffbef !=nil {return _gebee ,nil ,_ffbef ;};_eddg .SetNonStrokingColor (_dfd (_bcbge .Color )).Add_Tf (_cgad ,_bcbge .FontSize ).Add_TJ ([]_bc .PdfObject {_bc .MakeStringFromBytes (_abeeb )}...);
_ddcab ++;_abeeb =nil ;};_abcg =_ebebf ;_badgg =true ;_egcd =_bcbge .MultiFont .CurrentFont ;};}else {_aaff =UnsupportedRuneError {Message :_a .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_bdbg ,_bdbg ),Rune :_bdbg };
_gebee ._caab =append (_gebee ._caab ,_aaff );_dc .Log .Debug (_aaff .Error ());if _gebee ._affcb <=0{continue ;};_bdbg =_gebee ._affcb ;};};_gegg :=_abcg .Encode (string (_bdbg ));_abeeb =append (_abeeb ,_gegg ...);};if _bcbge .MultiFont !=nil {_bcbge .MultiFont .Reset ();
};};if len (_abeeb )> 0{if _aggcd {_eddg .SetStrokingColor (_dfd (_bcbge .OutlineColor ));};if _fcbf {_eddg .Add_Tz (_bcbge .HorizontalScaling );};_bbcb :=_gbccff [_gefbf ][_eefdb ];if _badgg {_bbcb =_bc .PdfObjectName (_a .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ddcab ));
_bace :=_gcag ._bcb .SetFontByName (_bbcb ,_egcd .ToPdfObject ());if _bace !=nil {return _gebee ,nil ,_bace ;};_ddcab ++;_badgg =false ;};_eddg .SetNonStrokingColor (_dfd (_bcbge .Color )).Add_Tf (_bbcb ,_bcbge .FontSize ).Add_TJ ([]_bc .PdfObject {_bc .MakeStringFromBytes (_abeeb )}...);
};if len (_eggc )> 0{_eddg .Add_EMC ();};_dddbg :=_fggbb [_eefdb ]/1000.0;if _bcbge .Underline {_caffe :=_bcbge .UnderlineStyle .Color ;if _caffe ==nil {_caffe =_dfbac .Style .Color ;};_bgcbe ,_afecc ,_bgecg :=_caffe .ToRGB ();_fafd :=_facef -_gebee .X ;
_fbef :=_bccc -_gfcae +_bcbge .TextRise -_bcbge .UnderlineStyle .Offset ;_dedf =append (_dedf ,&_fg .BasicLine {X1 :_fafd ,Y1 :_fbef ,X2 :_fafd +_dddbg ,Y2 :_fbef ,LineWidth :_dfbac .Style .UnderlineStyle .Thickness ,LineColor :_cd .NewPdfColorDeviceRGB (_bgcbe ,_afecc ,_bgecg )});
};for _adafa ,_gdef :=range _dfbac ._ccbfe {var _dbdfb *_bc .PdfObjectArray ;if len (_dfbac ._feea )==_adafa {switch _fgcfef :=_gdef .GetContext ().(type ){case *_cd .PdfAnnotationLink :_dbdfb =_bc .MakeArray ();_fgcfef .Rect =_dbdfb ;_dcfbf ,_ddbbd :=_fgcfef .Dest .(*_bc .PdfObjectArray );
if _ddbbd &&_dcfbf .Len ()==5{_cfebge ,_fbcf :=_dcfbf .Get (1).(*_bc .PdfObjectName );if _fbcf &&_cfebge .String ()=="\u0058\u0059\u005a"{_fbgae ,_dabag :=_bc .GetNumberAsFloat (_dcfbf .Get (3));if _dabag ==nil {_dcfbf .Set (3,_bc .MakeFloat (_gebee .PageHeight -_fbgae ));
};};};case *_cd .PdfAnnotationHighlight :_dbdfb =_bc .MakeArray ();_fgcfef .Rect =_dbdfb ;_edgb :=_facef ;_effef :=_bccc +_bcbge .TextRise ;_afaf :=_ecgfd (&_cd .PdfRectangle {Llx :_edgb ,Lly :_effef ,Urx :_edgb +_dddbg ,Ury :_effef +_cfdb },_bdedb ._dcfd );
_fgcfef .QuadPoints =_bc .MakeArrayFromFloats ([]float64 {_afaf [0].X ,_afaf [0].Y ,_afaf [1].X ,_afaf [1].Y ,_afaf [3].X ,_afaf [3].Y ,_afaf [2].X ,_afaf [2].Y });};_dfbac ._feea =append (_dfbac ._feea ,true );};if _dbdfb !=nil {_dead :=_fg .NewPoint (_facef -_gebee .X ,_bccc +_bcbge .TextRise -_gfcae ).Rotate (_bdedb ._dcfd );
_dead .X +=_gebee .X ;_dead .Y +=_gfcae ;_fdfae ,_dfdd ,_fbeca ,_bcbgb :=_gaeed (_dddbg ,_cfdb ,_bdedb ._dcfd );_dead .X +=_fdfae ;_dead .Y +=_dfdd ;_dbdfb .Clear ();_dbdfb .Append (_bc .MakeFloat (_dead .X ));_dbdfb .Append (_bc .MakeFloat (_dead .Y ));
_dbdfb .Append (_bc .MakeFloat (_dead .X +_fbeca ));_dbdfb .Append (_bc .MakeFloat (_dead .Y +_bcbgb ));};_gcag .AddAnnotation (_gdef );};_facef +=_dddbg ;if _aecae {_eddg .Add_w (1.0);};if _aggcd {_eddg .Add_RG (0.0,0.0,0.0);};if _ecagb {_eddg .Add_Tr (int64 (TextRenderingModeFill ));
};if _fbfgf {_eddg .Add_Tc (0);};if _edddb {_eddg .Add_Ts (0);};if _fcbf {_eddg .Add_Tz (DefaultHorizontalScaling );};if _dccba !=0.0{_eddg .Translate (0,-_dccba );_dccba =0.0;};};};if len (_beee )> 0{_eddg .Add_EMC ();};_eddg .Add_ET ();for _ ,_bdaee :=range _dedf {_eddg .SetStrokingColor (_bdaee .LineColor ).Add_w (_bdaee .LineWidth ).Add_m (_bdaee .X1 ,_bdaee .Y1 ).Add_l (_bdaee .X2 ,_bdaee .Y2 ).Add_s ();
};_eddg .Add_Q ();_dcaa :=_eddg .Operations ();_dcaa .WrapIfNeeded ();_gcag .addContents (_dcaa );if _agdb {_bcdfc :=_acaf ;_gebee .Y +=_bcdfc ;_gebee .Height -=_bcdfc ;if _gebee .Inline {_gebee .X +=_bdedb .Width ()+_bdedb ._gebac .Right ;};};return _gebee ,_cdea ,nil ;
};func _cada (_fdba ,_feed ,_ebabc ,_gafd float64 )*Rectangle {return &Rectangle {_aaabb :_fdba ,_adebb :_feed ,_dcdaf :_ebabc ,_dbab :_gafd ,_dgcaf :PositionAbsolute ,_ddeaec :1.0,_gccag :ColorBlack ,_dedg :1.0,_gafg :1.0};};func (_abed *TextStyle )horizontalScale ()float64 {return _abed .HorizontalScaling /100};


// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_afdb *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_gbde :=NewTextChunk (text ,_afdb ._caefe );_gbde .AddAnnotation (_afea (page -1,x ,y ,zoom ));return _afdb .appendChunk (_gbde );};

// FitMode returns the fit mode of the line.
func (_ffdb *Line )FitMode ()FitMode {return _ffdb ._bffef };

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_dedb *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dedb ._egecg .Left ,_dedb ._egecg .Right ,_dedb ._egecg .Top ,_dedb ._egecg .Bottom ;};

// SetMarkedContentID sets the marked content ID for the chapter.
func (_bcdc *Chapter )SetMarkedContentID (id int64 )*_cd .KDict {return nil };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cfcgc *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dded :=ctx ;_geedg ,ctx ,_bbfgg :=_cfcgc ._bebag .GeneratePageBlocks (ctx );if _bbfgg !=nil {return _geedg ,ctx ,_bbfgg ;};if _cfcgc ._gfeca .IsRelative (){ctx .X =_dded .X ;
};if _cfcgc ._gfeca .IsAbsolute (){return _geedg ,_dded ,nil ;};return _geedg ,ctx ,nil ;};

// NewImageFromData creates an Image from image data.
func (_gfbc *Creator )NewImageFromData (data []byte )(*Image ,error ){return _fdac (data )};

// Level returns the indentation level of the TOC line.
func (_cgefd *TOCLine )Level ()uint {return _cgefd ._bedfe };func (_efeeb *templateProcessor )parseRectangle (_efged *templateNode )(interface{},error ){_dfdfb :=_efeeb .creator .NewRectangle (0,0,0,0);for _ ,_accfc :=range _efged ._egac .Attr {_bdceb :=_accfc .Value ;
switch _ecgbe :=_accfc .Name .Local ;_ecgbe {case "\u0078":_dfdfb ._aaabb =_efeeb .parseFloatAttr (_ecgbe ,_bdceb );case "\u0079":_dfdfb ._adebb =_efeeb .parseFloatAttr (_ecgbe ,_bdceb );case "\u0077\u0069\u0064t\u0068":_dfdfb .SetWidth (_efeeb .parseFloatAttr (_ecgbe ,_bdceb ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_dfdfb .SetHeight (_efeeb .parseFloatAttr (_ecgbe ,_bdceb ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_dfdfb .SetFillColor (_efeeb .parseColorAttr (_ecgbe ,_bdceb ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_dfdfb .SetFillOpacity (_efeeb .parseFloatAttr (_ecgbe ,_bdceb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_dfdfb .SetBorderColor (_efeeb .parseColorAttr (_ecgbe ,_bdceb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_dfdfb .SetBorderOpacity (_efeeb .parseFloatAttr (_ecgbe ,_bdceb ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_dfdfb .SetBorderWidth (_efeeb .parseFloatAttr (_ecgbe ,_bdceb ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_bccdg ,_feebe ,_fdee ,_aeega :=_efeeb .parseBorderRadiusAttr (_ecgbe ,_bdceb );
_dfdfb .SetBorderRadius (_bccdg ,_feebe ,_aeega ,_fdee );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_dfdfb ._fegba =_efeeb .parseFloatAttr (_ecgbe ,_bdceb );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_dfdfb ._gaabc =_efeeb .parseFloatAttr (_ecgbe ,_bdceb );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_dfdfb ._fdccg =_efeeb .parseFloatAttr (_ecgbe ,_bdceb );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_dfdfb ._ccgf =_efeeb .parseFloatAttr (_ecgbe ,_bdceb );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_dfdfb .SetPositioning (_efeeb .parsePositioningAttr (_ecgbe ,_bdceb ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_dfdfb .SetFitMode (_efeeb .parseFitModeAttr (_ecgbe ,_bdceb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_eeaff :=_efeeb .parseMarginAttr (_ecgbe ,_bdceb );
_dfdfb .SetMargins (_eeaff .Left ,_eeaff .Right ,_eeaff .Top ,_eeaff .Bottom );default:_efeeb .nodeLogDebug (_efged ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_ecgbe );
};};return _dfdfb ,nil ;};func (_gd *Block )duplicate ()*Block {_dg :=&Block {};*_dg =*_gd ;_fgc :=_ca .ContentStreamOperations {};_fgc =append (_fgc ,*_gd ._df ...);_dg ._df =&_fgc ;return _dg ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};func (_dcfee *templateProcessor )getNodeErrorLocation (_degeb *templateNode ,_dgbf string ,_cecae ...interface{})string {_aecdc :=_a .Sprintf (_dgbf ,_cecae ...);_dcgg :=_a .Sprintf ("\u0025\u0064",_degeb ._fecbge );
if _degeb ._fbba !=0{_dcgg =_a .Sprintf ("\u0025\u0064\u003a%\u0064",_degeb ._fbba ,_degeb ._fbfgd );};if _dcfee ._fefbg !=""{return _a .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_aecdc ,_dcfee ._fefbg ,_dcgg );};return _a .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_aecdc ,_dcgg );
};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_fceg *_fg .CurvePolygon ;_dfbd float64 ;_ccb float64 ;_cefd Color ;_cgbe *int64 ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_eagc *Creator )DrawFooter (drawFooterFunc func (_baaa *Block ,_aaab FooterFunctionArgs )){_eagc ._bdfg =drawFooterFunc ;};type fontMetrics struct{_faafd float64 ;_cgdcd float64 ;_bffeg float64 ;_fdfbeg float64 ;};func (_bfedg *Table )wrapContent (_edce DrawContext )error {if _bfedg ._ccgc {return nil ;
};_bfedg .sortCells ();_deegc :=func (_gedgd *TableCell ,_ebccf int ,_cafg int ,_efdb int )(_fgee int ){if _efdb < 1{return -1;};_adfd :=0;for _eeac :=_cafg +1;_eeac < len (_bfedg ._bbdb )-1;_eeac ++{_aecga :=_bfedg ._bbdb [_eeac ];if _aecga ._badcc ==_efdb &&_adfd !=_cafg {_adfd =_eeac ;
if (_aecga ._gdgcb < _gedgd ._gdgcb &&_bfedg ._gfgc > _aecga ._gdgcb )||_gedgd ._gdgcb < _bfedg ._gfgc {continue ;};break ;};};_becac :=float64 (0.0);for _bffcg :=0;_bffcg < _gedgd ._gddee ;_bffcg ++{_becac +=_bfedg ._cbaab [_gedgd ._badcc +_bffcg -1];
};_cddae :=_gedgd .width (_bfedg ._fbce ,_edce .Width );var (_bgfa VectorDrawable ;_bbcc =false ;);switch _ffdcg :=_gedgd ._fagd .(type ){case *StyledParagraph :_gggd :=_edce ;_gggd .Height =_fb .Floor (_becac -_ffdcg ._gebac .Top -_ffdcg ._gebac .Bottom -0.5*_ffdcg .getTextHeight ());
_gggd .Width =_cddae ;_bege ,_gaagca ,_dceag :=_ffdcg .split (_gggd );if _dceag !=nil {_dc .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_dceag .Error ());
};if _bege !=nil &&_gaagca !=nil {_bfedg ._bbdb [_cafg ]._fagd =_bege ;_bgfa =_gaagca ;_bbcc =true ;};};_bfedg ._bbdb [_cafg ]._gddee =_gedgd ._gddee ;_edce .Height =_edce .PageHeight -_edce .Margins .Top -_edce .Margins .Bottom ;_gacecg :=_gedgd .cloneProps (nil );
if _bbcc {_gacecg ._fagd =_bgfa ;};_gacecg ._gddee =_ebccf ;_gacecg ._badcc =_efdb +1;_gacecg ._gdgcb =_gedgd ._gdgcb ;if _gacecg ._badcc +_gacecg ._gddee -1> _bfedg ._agga {for _defae :=_bfedg ._agga ;_defae < _gacecg ._badcc +_gacecg ._gddee -1;_defae ++{_bfedg ._agga ++;
_bfedg ._cbaab =append (_bfedg ._cbaab ,_bfedg ._cdgee );};};_bfedg ._bbdb =append (_bfedg ._bbdb [:_adfd +1],append ([]*TableCell {_gacecg },_bfedg ._bbdb [_adfd +1:]...)...);return _adfd +1;};_afbac :=func (_feeea *TableCell ,_gadcg int ,_gadg int ,_abggc float64 )(_fagcc int ){_fcfdg :=_feeea .width (_bfedg ._fbce ,_edce .Width );
_gbfg :=_abggc ;_eddgg :=1;_dfegd :=_edce .Height ;if _dfegd > 0{for _gbfg > _dfegd {_gbfg -=_edce .Height ;_dfegd =_edce .PageHeight -_edce .Margins .Top -_edce .Margins .Bottom ;_eddgg ++;};};var (_abca VectorDrawable ;_bbfa =false ;);switch _abfg :=_feeea ._fagd .(type ){case *StyledParagraph :_acaff :=_edce ;
_acaff .Height =_fb .Floor (_edce .Height -_abfg ._gebac .Top -_abfg ._gebac .Bottom -0.5*_abfg .getTextHeight ());_acaff .Width =_fcfdg ;_bgfe ,_gecg ,_bdbdc :=_abfg .split (_acaff );if _bdbdc !=nil {_dc .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_bdbdc .Error ());
};if _bgfe !=nil &&_gecg !=nil {_bfedg ._bbdb [_gadcg ]._fagd =_bgfe ;_abca =_gecg ;_bbfa =true ;};};if _eddgg < 2{return -1;};if _bfedg ._bbdb [_gadcg ]._badcc +_eddgg -1> _bfedg ._agga {for _afaac :=0;_afaac < _eddgg ;_afaac ++{_bfedg ._agga ++;_bfedg ._cbaab =append (_bfedg ._cbaab ,_bfedg ._cdgee );
};};_agfde :=_abggc /float64 (_eddgg );for _gdgba :=0;_gdgba < _eddgg ;_gdgba ++{_bfedg ._cbaab [_gadg +_gdgba -1]=_agfde ;};_edce .Height =_edce .PageHeight -_edce .Margins .Top -_edce .Margins .Bottom ;_gebca :=_feeea .cloneProps (nil );if _bbfa {_gebca ._fagd =_abca ;
};_gebca ._gddee =1;_gebca ._badcc =_gadg +_eddgg -1;_gebca ._gdgcb =_feeea ._gdgcb ;_bfedg ._bbdb =append (_bfedg ._bbdb ,_gebca );return len (_bfedg ._bbdb );};_afag :=1;_bagb :=-1;for _gafbe :=0;_gafbe < len (_bfedg ._bbdb );_gafbe ++{_fcaga :=_bfedg ._bbdb [_gafbe ];
if _bagb ==_gafbe {_afag =_fcaga ._badcc ;};if _fcaga ._gddee < 2{if _gfea :=_bfedg ._cbaab [_fcaga ._badcc -1];_gfea > _edce .Height {_bagb =_afbac (_fcaga ,_gafbe ,_fcaga ._badcc ,_gfea );continue ;};continue ;};_deaff :=float64 (0);for _ccaf :=0;_ccaf < _fcaga ._gddee ;
_ccaf ++{_deaff +=_bfedg ._cbaab [_fcaga ._badcc +_ccaf -1];};_accee :=float64 (0);for _agbde :=_afag -1;_agbde < _fcaga ._badcc -1;_agbde ++{_accee +=_bfedg ._cbaab [_agbde ];};if _deaff <=(_edce .Height -_accee ){continue ;};_dcbeb :=float64 (0.0);_caag :=_fcaga ._gddee ;
_geafd :=-1;_gbffce :=1;for _ceae :=1;_ceae <=_fcaga ._gddee ;_ceae ++{if (_dcbeb +_bfedg ._cbaab [_fcaga ._badcc +_ceae -2])> (_edce .Height -_accee ){_gbffce --;break ;};_geafd =_fcaga ._badcc +_ceae -1;_caag =_fcaga ._gddee -_ceae ;_dcbeb +=_bfedg ._cbaab [_fcaga ._badcc +_ceae -2];
_gbffce ++;};if _fcaga ._gddee ==_caag {_edce .Height =_edce .PageHeight -_edce .Margins .Top -_edce .Margins .Bottom ;_afag =_fcaga ._badcc ;_gafbe --;continue ;};if _caag > 0&&_fcaga ._gddee > _gbffce {_fcaga ._gddee =_gbffce ;_bagb =_deegc (_fcaga ,_caag ,_gafbe ,_geafd );
if _gafbe +1==_bagb {_gafbe --;};};_afag =_fcaga ._badcc ;};_bfedg .sortCells ();return nil ;};

// SetBorder sets the cell's border style.
func (_ddef *GridCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_ddef ._ffbe =CellBorderStyleSingle ;_ddef ._ccfg =width ;_ddef ._dffc =CellBorderStyleSingle ;_ddef ._cgbed =width ;
_ddef ._agfbe =CellBorderStyleSingle ;_ddef ._caadb =width ;_ddef ._adeb =CellBorderStyleSingle ;_ddef ._cbec =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_ddef ._ffbe =CellBorderStyleDouble ;_ddef ._ccfg =width ;_ddef ._dffc =CellBorderStyleDouble ;
_ddef ._cgbed =width ;_ddef ._agfbe =CellBorderStyleDouble ;_ddef ._caadb =width ;_ddef ._adeb =CellBorderStyleDouble ;_ddef ._cbec =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_ddef ._ffbe =style ;
_ddef ._ccfg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_ddef ._dffc =style ;_ddef ._cgbed =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_ddef ._agfbe =style ;
_ddef ._caadb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_ddef ._adeb =style ;_ddef ._cbec =width ;};};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_bgb *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_bgb ._gced .Left =left ;_bgb ._gced .Right =right ;_bgb ._gced .Top =top ;_bgb ._gced .Bottom =bottom ;};

// Width returns the current page width.
func (_bcfd *Creator )Width ()float64 {return _bcfd ._gdac };func _bedfd (_gfgfe ,_adgfbg ,_gecae string ,_dbegc uint ,_afebg TextStyle )*TOCLine {return _abcf (TextChunk {Text :_gfgfe ,Style :_afebg },TextChunk {Text :_adgfbg ,Style :_afebg },TextChunk {Text :_gecae ,Style :_afebg },_dbegc ,_afebg );
};

// GetMargins returns the left, right, top, bottom Margins.
func (_cadd *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cadd ._gbdab .Left ,_cadd ._gbdab .Right ,_cadd ._gbdab .Top ,_cadd ._gbdab .Bottom ;};

// AddColorStop add color stop information for rendering gradient.
func (_ggga *shading )AddColorStop (color Color ,point float64 ){_ggga ._gacbe =append (_ggga ._gacbe ,_efbgcd (color ,point ));};

// Height returns the height of the graphic svg.
func (_ggab *GraphicSVG )Height ()float64 {return _ggab ._dbgf .Height };

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_cabg *Chapter )Add (d Drawable )error {if Drawable (_cabg )==d {_dc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _ga .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _cfba :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_cabg ._aed =append (_cabg ._aed ,d );case containerDrawable :_gbb ,_bfa :=_cfba .ContainerComponent (_cabg );
if _bfa !=nil {return _bfa ;};_cabg ._aed =append (_cabg ._aed ,_gbb );default:_dc .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _ga .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};func _effdg (_ddbc *_b .Decoder )(int ,int ){return 0,0};

// SetOpacity sets opacity for border in range 0-1.
func (_gdfg *border )SetOpacity (opacity float64 ){_gdfg ._gbca =opacity };

// SetFontColor sets the font color for the paragraph.
func (_faffa *StyledParagraph )SetFontColor (color Color ){_faffa ._fdeab .Color =color ;for _ ,_dgce :=range _faffa ._gceca {_dgce .Style .Color =color ;};};func _ggec (_efcdd *Creator ,_gcggf string ,_acgbf []byte ,_bgfcg *TemplateOptions ,_bfgf componentRenderer )*templateProcessor {if _bgfcg ==nil {_bgfcg =&TemplateOptions {};
};_bgfcg .init ();if _bfgf ==nil {_bfgf =_efcdd ;};return &templateProcessor {creator :_efcdd ,_fdbfe :_acgbf ,_cebde :_bgfcg ,_fgbad :_bfgf ,_fefbg :_gcggf };};func _cccab (_cfee rune )bool {return _cfee =='('||_cfee ==','||_cfee ==')'};type border struct{_eea float64 ;
_gbcc float64 ;_bbg float64 ;_ebd float64 ;_bca Color ;_aad Color ;_bebc float64 ;_bgeg Color ;_cbc float64 ;_fbdc Color ;_egb float64 ;_aef Color ;_addc float64 ;LineStyle _fg .LineStyle ;_bbc CellBorderStyle ;_agc CellBorderStyle ;_dec CellBorderStyle ;
_fage CellBorderStyle ;_gbca float64 ;};

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_bfga *Ellipse )ScaleToHeight (h float64 ){_dcbbe :=_bfga ._gca /_bfga ._geeg ;_bfga ._geeg =h ;_bfga ._gca =h *_dcbbe ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_df *_ca .ContentStreamOperations ;_bcb *_cd .PdfPageResources ;_cdd Positioning ;_cfg ,_cab float64 ;_cef float64 ;_dff float64 ;_ecg float64 ;_dfc Margins ;_dfcc []*_cd .PdfAnnotation ;};func (_eefb *templateProcessor )parseFitModeAttr (_affe ,_acdba string )FitMode {_dc .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_affe ,_acdba );
_cfbef :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_acdba ];return _cfbef ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_deff *Table )SetMargins (left ,right ,top ,bottom float64 ){_deff ._gbdab .Left =left ;_deff ._gbdab .Right =right ;_deff ._gbdab .Top =top ;_deff ._gbdab .Bottom =bottom ;};func _gedc (_ceddg *Block ,_eafac *Paragraph ,_dcfa DrawContext )(DrawContext ,error ){_cefb :=1;
_gbaff :=_bc .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ge .Itoa (_cefb ));for _ceddg ._bcb .HasFontByName (_gbaff ){_cefb ++;_gbaff =_bc .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ge .Itoa (_cefb ));};_agda :=_ceddg ._bcb .SetFontByName (_gbaff ,_eafac ._fgef .ToPdfObject ());
if _agda !=nil {return _dcfa ,_agda ;};_eafac .wrapText ();_eefg :=_ca .NewContentCreator ();_eefg .Add_q ();_ddgg :=_aac .RoundDefault (_dcfa .PageHeight -_dcfa .Y -_eafac ._ebab *_eafac ._dbfac );_eefg .Translate (_dcfa .X ,_ddgg );if _eafac ._gdaec !=0{_eefg .RotateDeg (_eafac ._gdaec );
};_cebd :=_dfd (_eafac ._ecfga );_agda =_daeg (_ceddg ,_cebd ,_eafac ._ecfga ,func ()Rectangle {return Rectangle {_aaabb :_dcfa .X ,_adebb :_ddgg ,_dcdaf :_eafac .getMaxLineWidth ()/1000.0,_dbab :_eafac .Height ()};});if _agda !=nil {return _dcfa ,_agda ;
};_eefg .Add_BT ();_fdbf :=map[string ]_bc .PdfObject {};if _eafac ._ebcbf !=nil {_fdbf ["\u004d\u0043\u0049\u0044"]=_bc .MakeInteger (*_eafac ._ebcbf );};if _eafac ._dffff !=""{_fdbf ["\u004c\u0061\u006e\u0067"]=_bc .MakeString (_eafac ._dffff );};if len (_fdbf )> 0{_eefg .Add_BDC (*_bc .MakeName (_cd .StructureTypeParagraph ),_fdbf );
};_eefg .SetNonStrokingColor (_cebd ).Add_Tf (_gbaff ,_eafac ._ebab ).Add_TL (_eafac ._ebab *_eafac ._dbfac );for _gccae ,_fbgfg :=range _eafac ._aeeca {if _gccae !=0{_eefg .Add_Tstar ();};_acbeb :=[]rune (_fbgfg );_egdb :=0.0;_gfdcc :=0;for _afce ,_dgfef :=range _acbeb {if _dgfef ==' '{_gfdcc ++;
continue ;};if _dgfef =='\u000A'{continue ;};_cadf ,_ggaca :=_eafac ._fgef .GetRuneMetrics (_dgfef );if !_ggaca {_dc .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_afce ,_dgfef ,_dgfef ,_eafac ._fgef .BaseFont (),_eafac ._fgef .Subtype ());
return _dcfa ,_ga .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_egdb +=_eafac ._ebab *_cadf .Wx ;};var _cbbe []_bc .PdfObject ;_cbceb ,_cbffd :=_eafac ._fgef .GetRuneMetrics (' ');
if !_cbffd {return _dcfa ,_ga .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_ecega :=_cbceb .Wx ;switch _eafac ._aaagb {case TextAlignmentJustify :if _gfdcc > 0&&_gccae < len (_eafac ._aeeca )-1{_ecega =(_eafac ._deeb *1000.0-_egdb )/float64 (_gfdcc )/_eafac ._ebab ;
};case TextAlignmentCenter :_edbc :=_egdb +float64 (_gfdcc )*_ecega *_eafac ._ebab ;_fbeb :=_aac .RoundDefault ((_eafac ._deeb *1000.0-_edbc )/2/_eafac ._ebab );_cbbe =append (_cbbe ,_bc .MakeFloat (-_fbeb ));case TextAlignmentRight :_ecge :=_egdb +float64 (_gfdcc )*_ecega *_eafac ._ebab ;
_cfbb :=_aac .RoundDefault ((_eafac ._deeb *1000.0-_ecge )/_eafac ._ebab );_cbbe =append (_cbbe ,_bc .MakeFloat (-_cfbb ));};_gfdab :=_eafac ._fgef .Encoder ();var _dgda []byte ;for _ ,_aaca :=range _acbeb {if _aaca =='\u000A'{continue ;};if _aaca ==' '{if len (_dgda )> 0{_cbbe =append (_cbbe ,_bc .MakeStringFromBytes (_dgda ));
_dgda =nil ;};_cbbe =append (_cbbe ,_bc .MakeFloat (-_ecega ));}else {if _ ,_fdfa :=_gfdab .RuneToCharcode (_aaca );!_fdfa {_agda =UnsupportedRuneError {Message :_a .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_aaca ,_aaca ),Rune :_aaca };
_dcfa ._caab =append (_dcfa ._caab ,_agda );_dc .Log .Debug (_agda .Error ());if _dcfa ._affcb <=0{continue ;};_aaca =_dcfa ._affcb ;};_dgda =append (_dgda ,_gfdab .Encode (string (_aaca ))...);};};if len (_dgda )> 0{_cbbe =append (_cbbe ,_bc .MakeStringFromBytes (_dgda ));
};_eefg .Add_TJ (_cbbe ...);};if len (_fdbf )> 0{_eefg .Add_EMC ();};_eefg .Add_ET ();_eefg .Add_Q ();_bgae :=_eefg .Operations ();_bgae .WrapIfNeeded ();_ceddg .addContents (_bgae );if _eafac ._egaac .IsRelative (){_dgccb :=_eafac .Height ();_dcfa .Y =_aac .RoundDefault (_dcfa .Y +_dgccb );
_dcfa .Height =_aac .RoundDefault (_dcfa .Height -_dgccb );if _dcfa .Inline {_dcfa .X =_aac .RoundDefault (_dcfa .X +_eafac .Width ()+_eafac ._cafc .Right );};};return _dcfa ,nil ;};func (_feb *pageTransformations )applyFlip (_efbb *_cd .PdfPage )error {_acef ,_gage :=_feb ._cecd ,_feb ._ddad ;
if !_acef &&!_gage {return nil ;};if _efbb ==nil {return _ga .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_bea ,_bgcg :=_efbb .GetMediaBox ();if _bgcg !=nil {return _bgcg ;};_eebe ,_gagee :=_bea .Width (),_bea .Height ();
_gebf ,_bgcg :=_efbb .GetRotate ();if _bgcg !=nil {_dc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_bgcg .Error ());
};if _ebce :=_gebf %360!=0&&_gebf %90==0;_ebce {if _bfeg :=(360+_gebf %360)%360;_bfeg ==90||_bfeg ==270{_acef ,_gage =_gage ,_acef ;};};_dbfc ,_cbfd :=1.0,0.0;if _acef {_dbfc ,_cbfd =-1.0,-_eebe ;};_cff ,_agg :=1.0,0.0;if _gage {_cff ,_agg =-1.0,-_gagee ;
};_eacf :=_ca .NewContentCreator ().Scale (_dbfc ,_cff ).Translate (_cbfd ,_agg );_deaa ,_bgcg :=_bc .MakeStream (_eacf .Bytes (),_bc .NewFlateEncoder ());if _bgcg !=nil {return _bgcg ;};_facd :=_bc .MakeArray (_deaa );_facd .Append (_efbb .GetContentStreamObjs ()...);
_efbb .Contents =_facd ;return nil ;};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_aagb *Chart )Width ()float64 {return float64 (_aagb ._eegd .Width ())};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };
PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_abdca *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_abdca ._eebd =dashArray ;_abdca ._agcc =dashPhase ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_dabaa *StyledParagraph )Insert (index uint ,text string )*TextChunk {_fbad :=uint (len (_dabaa ._gceca ));if index > _fbad {index =_fbad ;};_fdbda :=NewTextChunk (text ,_dabaa ._fdeab );_dabaa ._gceca =append (_dabaa ._gceca [:index ],append ([]*TextChunk {_fdbda },_dabaa ._gceca [index :]...)...);
_dabaa .wrapText ();return _fdbda ;};

// Height returns the height of the list.
func (_cbecf *List )Height ()float64 {var _gcgb float64 ;for _ ,_eabda :=range _cbecf ._ebfe {_gcgb +=_eabda .ctxHeight (_cbecf .Width ());};return _gcgb ;};func _fdagg (_begcae *templateProcessor ,_bfbec *templateNode )(interface{},error ){return _begcae .parseImage (_bfbec );
};

// SetBorderColor sets the border color.
func (_cegbe *Polygon )SetBorderColor (color Color ){_cegbe ._bccge .BorderColor =_dfd (color )};

// SetSideBorderColor sets the cell's side border color.
func (_dabe *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_dabe ._bcfdc =col ;_dabe ._efffe =col ;_dabe ._cbea =col ;_dabe ._cefef =col ;case CellBorderSideTop :_dabe ._bcfdc =col ;case CellBorderSideBottom :_dabe ._efffe =col ;
case CellBorderSideLeft :_dabe ._cbea =col ;case CellBorderSideRight :_dabe ._cefef =col ;};};func (_fabf *Invoice )drawAddress (_fbbg *InvoiceAddress )[]*StyledParagraph {var _fdgb []*StyledParagraph ;if _fbbg .Heading !=""{_bfgc :=_eeff (_fabf ._cefda );
_bfgc .SetMargins (0,0,0,7);_bfgc .Append (_fbbg .Heading );_fdgb =append (_fdgb ,_bfgc );};_beea :=_eeff (_fabf ._daacd );_beea .SetLineHeight (1.2);_aeedf :=_fbbg .Separator ;if _aeedf ==""{_aeedf =_fabf ._bbgd ;};_afef :=_fbbg .City ;if _fbbg .State !=""{if _afef !=""{_afef +=_aeedf ;
};_afef +=_fbbg .State ;};if _fbbg .Zip !=""{if _afef !=""{_afef +=_aeedf ;};_afef +=_fbbg .Zip ;};if _fbbg .Name !=""{_beea .Append (_fbbg .Name +"\u000a");};if _fbbg .Street !=""{_beea .Append (_fbbg .Street +"\u000a");};if _fbbg .Street2 !=""{_beea .Append (_fbbg .Street2 +"\u000a");
};if _afef !=""{_beea .Append (_afef +"\u000a");};if _fbbg .Country !=""{_beea .Append (_fbbg .Country +"\u000a");};_ffcc :=_eeff (_fabf ._daacd );_ffcc .SetLineHeight (1.2);_ffcc .SetMargins (0,0,7,0);if _fbbg .Phone !=""{_ffcc .Append (_fbbg .fmtLine (_fbbg .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_fbbg .HidePhoneLabel ));
};if _fbbg .Email !=""{_ffcc .Append (_fbbg .fmtLine (_fbbg .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_fbbg .HideEmailLabel ));};_fdgb =append (_fdgb ,_beea ,_ffcc );return _fdgb ;};func (_efdbd *templateProcessor )parseListItem (_fdgde *templateNode )(interface{},error ){if _fdgde ._fafg ==nil {_efdbd .nodeLogError (_fdgde ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_bfcee ;};_cdegd ,_bgcba :=_fdgde ._fafg ._bedgb .(*List );if !_bgcba {_efdbd .nodeLogError (_fdgde ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_bfcee ;};_cecea :=_fgaae ();_cecea ._geed =_cdegd ._fbfg ;return _cecea ,nil ;};type pathParserError struct{_fdda string };func _cbfdf (_agbf []float64 )[]float64 {for _aeeg ,_efee :=0,len (_agbf )-1;_aeeg < _efee ;_aeeg ,_efee =_aeeg +1,_efee -1{_agbf [_aeeg ],_agbf [_efee ]=_agbf [_efee ],_agbf [_aeeg ];
};return _agbf ;};

// Logo returns the logo of the invoice.
func (_gcae *Invoice )Logo ()*Image {return _gcae ._deegg };

// SetFillColor sets the fill color for the path.
func (_gagf *FilledCurve )SetFillColor (color Color ){_gagf ._aade =color };

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_fdcca :_fb .Max (_fb .Min (c ,1.0),0.0),_aaac :_fb .Max (_fb .Min (m ,1.0),0.0),_fcda :_fb .Max (_fb .Min (y ,1.0),0.0),_cce :_fb .Max (_fb .Min (k ,1.0),0.0)};};

// SetMakedContentID sets the marked content id for the table.
func (_fagf *Table )SetMarkedContentID (mcid int64 )*_cd .KDict {return nil };func _dad (_decf string )(*GraphicSVG ,error ){_agdc ,_ecgc :=ParseFromSVGString (_decf );if _ecgc !=nil {return nil ,_ecgc ;};return _baag (_agdc );};func _abcf (_acfef ,_aggbc ,_fceba TextChunk ,_cgga uint ,_dcfca TextStyle )*TOCLine {_adbd :=_eeff (_dcfca );
_adbd .SetEnableWrap (true );_adbd .SetTextAlignment (TextAlignmentLeft );_adbd .SetMargins (0,0,2,2);_ebcfa :=&TOCLine {_bebag :_adbd ,Number :_acfef ,Title :_aggbc ,Page :_fceba ,Separator :TextChunk {Text :"\u002e",Style :_dcfca },_gecda :0,_bedfe :_cgga ,_fcegc :10,_gfeca :PositionRelative };
_adbd ._gebac .Left =_ebcfa ._gecda +float64 (_ebcfa ._bedfe -1)*_ebcfa ._fcegc ;_adbd ._gfeb =_ebcfa .prepareParagraph ;return _ebcfa ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_bdafe float64 ;_caff float64 ;_baeg float64 ;_ebaf float64 ;_beac float64 ;_bggc float64 ;_acge Color ;_dbdf float64 ;_accbg *int64 ;};

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _gagfc (path )};func (_eebbf *Table )resetColumnWidths (){_eebbf ._fbce =[]float64 {};_gfbcd :=float64 (1.0)/float64 (_eebbf ._gfgc );for _gbdeg :=0;_gbdeg < _eebbf ._gfgc ;_gbdeg ++{_eebbf ._fbce =append (_eebbf ._fbce ,_gfbcd );
};};

// GeneratePageBlocks generates a page break block.
func (_geebf *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eagcf :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_cbgbd :=ctx ;_cbgbd .Y =ctx .Margins .Top ;
_cbgbd .X =ctx .Margins .Left ;_cbgbd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_cbgbd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_cbgbd ;return _eagcf ,ctx ,nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_dbgg *Paragraph )SetLineHeight (lineheight float64 ){_dbgg ._dbfac =lineheight };

// SellerAddress returns the seller address used in the invoice template.
func (_bcag *Invoice )SellerAddress ()*InvoiceAddress {return _bcag ._egaec };

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_cdbf *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_cdbf .Text },nil ;};var _cffa []string ;var _dcedc []rune ;var _adgfb float64 ;var _fgcfa []float64 ;_afda :=_cdbf .Style ;_cbced :=_geab (_cdbf .Text );
for _ ,_aggac :=range _cdbf .Text {if _aggac =='\u000A'{_agdda :=_ccfb (string (_dcedc ),_cbced );_cffa =append (_cffa ,_gb .TrimRightFunc (_agdda ,_f .IsSpace )+string (_aggac ));_dcedc =nil ;_adgfb =0;_fgcfa =nil ;continue ;};_dacc :=_aggac ==' ';_ccbfeb ,_bbfb :=_afda .Font .GetRuneMetrics (_aggac );
if !_bbfb {_dc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_aggac ,_aggac ,_afda .Font .BaseFont (),_afda .Font .Subtype ());
_dc .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_afda .Font );_dc .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_afda .Font .Encoder ());return nil ,_ga .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_addccg :=_afda .FontSize *_ccbfeb .Wx ;_gddge :=_addccg ;if !_dacc {_gddge =_addccg +_afda .CharSpacing *1000.0;};if _adgfb +_addccg > width *1000.0{_deccb :=-1;if !_dacc {for _edgda :=len (_dcedc )-1;_edgda >=0;_edgda --{if _dcedc [_edgda ]==' '{_deccb =_edgda ;
break ;};};};_cgadg :=string (_dcedc );if _deccb > 0{_cgadg =string (_dcedc [0:_deccb +1]);_dcedc =append (_dcedc [_deccb +1:],_aggac );_fgcfa =append (_fgcfa [_deccb +1:],_gddge );_adgfb =0;for _ ,_cgcge :=range _fgcfa {_adgfb +=_cgcge ;};}else {if _dacc {_dcedc =[]rune {};
_fgcfa =[]float64 {};_adgfb =0;}else {_dcedc =[]rune {_aggac };_fgcfa =[]float64 {_gddge };_adgfb =_gddge ;};};_cgadg =_ccfb (_cgadg ,_cbced );_cffa =append (_cffa ,_gb .TrimRightFunc (_cgadg ,_f .IsSpace ));}else {_dcedc =append (_dcedc ,_aggac );_adgfb +=_gddge ;
_fgcfa =append (_fgcfa ,_gddge );};};if len (_dcedc )> 0{_bagf :=string (_dcedc );_bagf =_ccfb (_bagf ,_cbced );_cffa =append (_cffa ,_bagf );};return _cffa ,nil ;};func _gcg (_gdae _de .ChartRenderable )*Chart {return &Chart {_eegd :_gdae ,_edbd :PositionRelative ,_fdg :Margins {Top :10,Bottom :10}};
};func (_ceec *StyledParagraph )wrapWordChunks (){if !_ceec ._decb {return ;};var (_geag []*TextChunk ;_caege *_cd .PdfFont ;);for _ ,_deed :=range _ceec ._gceca {_dfbaa :=[]rune (_deed .Text );if _caege ==nil {_caege =_deed .Style .Font ;};_gbdb :=_deed ._ccbfe ;
_ageba :=_deed .VerticalAlignment ;if len (_geag )> 0{if len (_dfbaa )==1&&_f .IsPunct (_dfbaa [0])&&_deed .Style .Font ==_caege {_fbgaf :=[]rune (_geag [len (_geag )-1].Text );_geag [len (_geag )-1].Text =string (append (_fbgaf ,_dfbaa [0]));continue ;
}else {_ ,_ebcfb :=_ge .Atoi (_deed .Text );if _ebcfb ==nil {_cdeb :=[]rune (_geag [len (_geag )-1].Text );_bdfbd :=len (_cdeb );if _bdfbd >=2{_ ,_dbbd :=_ge .Atoi (string (_cdeb [_bdfbd -2]));if _dbbd ==nil &&_f .IsPunct (_cdeb [_bdfbd -1]){_geag [len (_geag )-1].Text =string (append (_cdeb ,_dfbaa ...));
continue ;};};};};};_bded ,_eafaa :=_cfcb (_deed .Text );if _eafaa !=nil {_dc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_eafaa );
_bded =[]string {_deed .Text };};for _ ,_dgdd :=range _bded {_bafaa :=NewTextChunk (_dgdd ,_deed .Style );_bafaa ._ccbfe =_gbbef (_gbdb );_bafaa .VerticalAlignment =_ageba ;_geag =append (_geag ,_bafaa );};_caege =_deed .Style .Font ;};if len (_geag )> 0{_ceec ._gceca =_geag ;
};};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_edfd *TOC )SetLineLevelOffset (levelOffset float64 ){_edfd ._gfdea =levelOffset };func (_geee *templateProcessor )parseCellBorderStyleAttr (_gcce ,_gdgdb string )CellBorderStyle {_dc .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_gcce ,_gdgdb );
_ebfeg :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_gdgdb ];return _ebfeg ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_gfbb *Invoice )SetNoteHeadingStyle (style TextStyle ){_gfbb ._cgbb =style };

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_beade *Ellipse )SetFitMode (fitMode FitMode ){_beade ._aeed =fitMode };func (_ddabf *templateProcessor )parseLineStyleAttr (_gcedf ,_gabd string )_fg .LineStyle {_dc .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gcedf ,_gabd );
_edfaf :=map[string ]_fg .LineStyle {"\u0073\u006f\u006ci\u0064":_fg .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_fg .LineStyleDashed }[_gabd ];return _edfaf ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// ColorGrayFromHex converts color hex code to gray color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ff -> white.
func ColorGrayFromHex (hexStr string )Color {_fbb :=grayColor {};if (len (hexStr )!=2&&len (hexStr )!=3)||hexStr [0]!='#'{_dc .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fbb ;
};var _fcg int ;if len (hexStr )==2{var _ecc int ;_egcfc ,_ecce :=_a .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078",&_ecc );if _ecce !=nil {_dc .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_ecce );
return _fbb ;};if _egcfc !=1{_dc .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fbb ;};_fcg =_ecc *16+_ecc ;}else {_bcf ,_ebda :=_a .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078",&_fcg );
if _ebda !=nil {_dc .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fbb ;};if _bcf !=1{_dc .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_bcf );
return _fbb ;};};_fbb ._bbe =float64 (_fcg )/255.0;return _fbb ;};

// GetRowHeight returns the height of the specified row.
func (_aabfc *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_aabfc ._cbaab ){return 0,_ga .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _aabfc ._cbaab [row -1],nil ;
};

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_ececb *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_ddcc []*Block ;_gadb =NewBlock (ctx .PageWidth ,ctx .PageHeight );_ddbdd =ctx ;);_egbca :=_ececb ._cddb .IsRelative ();if _egbca {_ececb .applyFitMode (ctx .Width );
ctx .X +=_ececb ._ebbed .Left ;ctx .Y +=_ececb ._ebbed .Top ;ctx .Width -=_ececb ._ebbed .Left +_ececb ._ebbed .Right ;ctx .Height -=_ececb ._ebbed .Top +_ececb ._ebbed .Bottom ;if _ececb ._geeg > ctx .Height {_ddcc =append (_ddcc ,_gadb );_gadb =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_gagge :=ctx ;_gagge .Y =ctx .Margins .Top +_ececb ._ebbed .Top ;_gagge .X =ctx .Margins .Left +_ececb ._ebbed .Left ;_gagge .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_ececb ._ebbed .Top -_ececb ._ebbed .Bottom ;_gagge .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ececb ._ebbed .Left -_ececb ._ebbed .Right ;
ctx =_gagge ;};}else {ctx .X =_ececb ._agdd -_ececb ._gca /2;ctx .Y =_ececb ._eebb -_ececb ._geeg /2;};_bffa :=_fg .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_ececb ._geeg ,Width :_ececb ._gca ,Height :_ececb ._geeg ,BorderWidth :_ececb ._bfd ,Opacity :1.0};
if _ececb ._dcdf !=nil {_bffa .FillEnabled =true ;_aagg :=_dfd (_ececb ._dcdf );_dgeg :=_daeg (_gadb ,_aagg ,_ececb ._dcdf ,func ()Rectangle {return Rectangle {_aaabb :_bffa .X ,_adebb :_bffa .Y ,_dcdaf :_bffa .Width ,_dbab :_bffa .Height };});if _dgeg !=nil {return nil ,ctx ,_dgeg ;
};_bffa .FillColor =_aagg ;};if _ececb ._bbeba !=nil {_bffa .BorderEnabled =false ;if _ececb ._bfd > 0{_bffa .BorderEnabled =true ;};_bffa .BorderColor =_dfd (_ececb ._bbeba );_bffa .BorderWidth =_ececb ._bfd ;};_ffgd ,_cfdd :=_gadb .setOpacity (_ececb ._cece ,_ececb ._daaca );
if _cfdd !=nil {return nil ,ctx ,_cfdd ;};_bfdg ,_ ,_cfdd :=_bffa .MarkedDraw (_ffgd ,_ececb ._cga );if _cfdd !=nil {return nil ,ctx ,_cfdd ;};_cfdd =_gadb .addContentsByString (string (_bfdg ));if _cfdd !=nil {return nil ,ctx ,_cfdd ;};if _egbca {ctx .X =_ddbdd .X ;
ctx .Width =_ddbdd .Width ;ctx .Y +=_ececb ._geeg +_ececb ._ebbed .Bottom ;ctx .Height -=_ececb ._geeg ;}else {ctx =_ddbdd ;};_ddcc =append (_ddcc ,_gadb );return _ddcc ,ctx ,nil ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_aec *Chapter )GetHeading ()*StyledParagraph {return _aec ._cgcg };func (_bdce *GraphicSVGElement )drawPolyline (_fagbg *_ca .ContentCreator ,_gaedg *_cd .PdfPageResources ){_fagbg .Add_q ();_bdce .Style .toContentStream (_fagbg ,_gaedg ,_bdce );
_gdede ,_dedba :=_cgbeg (_bdce .Attributes ["\u0070\u006f\u0069\u006e\u0074\u0073"]);if _dedba !=nil {_dc .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0025\u0076",_dedba );
return ;};if len (_gdede )%2> 0{_dc .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0069n\u0076\u0061l\u0069\u0064\u0020\u0070\u006f\u0069\u006e\u0074s\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006ce\u006e\u0067\u0074\u0068");return ;
};for _baega :=0;_baega < len (_gdede );{if _baega ==0{_fagbg .Add_m (_gdede [_baega ]*_bdce ._ddccg ,_gdede [_baega +1]*_bdce ._ddccg );}else {_fagbg .Add_l (_gdede [_baega ]*_bdce ._ddccg ,_gdede [_baega +1]*_bdce ._ddccg );};_baega +=2;};_bdce .Style .fillStroke (_fagbg );
_fagbg .Add_h ();_fagbg .Add_Q ();};func (_efbf *GraphicSVGElement )toContentStream (_bad *_ca .ContentCreator ,_cbfeg *_cd .PdfPageResources ){_dfcef ,_gbbg :=_fecbgg (_efbf .Attributes ,_efbf ._ddccg );if _gbbg !=nil {_dc .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_gbbg );
};_efbf .Style =_dfcef ;switch _efbf .Name {case "\u0070\u0061\u0074\u0068":_efbf .drawPath (_bad ,_cbfeg );for _ ,_caace :=range _efbf .Children {_caace .toContentStream (_bad ,_cbfeg );};case "\u0072\u0065\u0063\u0074":_efbf .drawRect (_bad ,_cbfeg );
for _ ,_bgcb :=range _efbf .Children {_bgcb .toContentStream (_bad ,_cbfeg );};case "\u0063\u0069\u0072\u0063\u006c\u0065":_efbf .drawCircle (_bad ,_cbfeg );for _ ,_gafbd :=range _efbf .Children {_gafbd .toContentStream (_bad ,_cbfeg );};case "\u0065l\u006c\u0069\u0070\u0073\u0065":_efbf .drawEllipse (_bad ,_cbfeg );
for _ ,_aafb :=range _efbf .Children {_aafb .toContentStream (_bad ,_cbfeg );};case "\u0070\u006f\u006c\u0079\u006c\u0069\u006e\u0065":_efbf .drawPolyline (_bad ,_cbfeg );for _ ,_ecag :=range _efbf .Children {_ecag .toContentStream (_bad ,_cbfeg );};case "\u0070o\u006c\u0079\u0067\u006f\u006e":_efbf .drawPolygon (_bad ,_cbfeg );
for _ ,_bcec :=range _efbf .Children {_bcec .toContentStream (_bad ,_cbfeg );};case "\u006c\u0069\u006e\u0065":_efbf .drawLine (_bad ,_cbfeg );for _ ,_fgebf :=range _efbf .Children {_fgebf .toContentStream (_bad ,_cbfeg );};case "\u0074\u0065\u0078\u0074":_efbf .drawText (_bad ,_cbfeg );
for _ ,_aggb :=range _efbf .Children {_aggb .toContentStream (_bad ,_cbfeg );};case "\u0067":_cede ,_bbaf :=_efbf .Attributes ["\u0066\u0069\u006c\u006c"];_addef ,_bgfc :=_efbf .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"];_dfccb ,_dfcg :=_efbf .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];
_fagbc ,_caad :=_efbf .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];for _ ,_fffa :=range _efbf .Children {if _ ,_ceb :=_fffa .Attributes ["\u0066\u0069\u006c\u006c"];!_ceb &&_bbaf {_fffa .Attributes ["\u0066\u0069\u006c\u006c"]=_cede ;};
if _ ,_faed :=_fffa .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"];!_faed &&_bgfc {_fffa .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"]=_addef ;};if _ ,_degf :=_fffa .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];
!_degf &&_dfcg {_fffa .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"]=_dfccb ;};if _ ,_agaef :=_fffa .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];!_agaef &&_caad {_fffa .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"]=_fagbc ;
};_fffa .toContentStream (_bad ,_cbfeg );};};};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_dbee *Table )EnablePageWrap (enable bool ){_dbee ._bdbea =enable };func (_ccgd *templateProcessor )addNodeText (_fafed *templateNode ,_effba string )error {_afdcd :=_fafed ._bedgb ;if _afdcd ==nil {return nil ;};switch _dbac :=_afdcd .(type ){case *TextChunk :_dbac .Text =_effba ;
case *StyledParagraph :switch _fafed ._egac .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _fafed ._fafg !=nil {if _cgcc ,_abgac :=_fafed ._fafg ._bedgb .(*Chapter );_abgac {_cgcc ._dfcf =_effba ;
_dbac .SetText (_cgcc .headingText ());};};};};return nil ;};func (_faf *Creator )wrapPageIfNeeded (_bdd *_cd .PdfPage )(*_cd .PdfPage ,error ){_fead ,_efbc :=_bdd .GetAllContentStreams ();if _efbc !=nil {return nil ,_efbc ;};_cdde :=_ca .NewContentStreamParser (_fead );
_geca ,_efbc :=_cdde .Parse ();if _efbc !=nil {return nil ,_efbc ;};if !_geca .HasUnclosedQ (){return nil ,nil ;};_geca .WrapIfNeeded ();_fcbd ,_efbc :=_bc .MakeStream (_geca .Bytes (),_bc .NewFlateEncoder ());if _efbc !=nil {return nil ,_efbc ;};_bdd .Contents =_bc .MakeArray (_fcbd );
return _bdd ,nil ;};

// SetBorderWidth sets the border width.
func (_gaaeba *Polygon )SetBorderWidth (borderWidth float64 ){_gaaeba ._bccge .BorderWidth =borderWidth };

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_begg *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_effee :=_begg ;if _begg ._ccgc {_effee =_begg .clone ();};return _cdbca (_effee ,ctx );};

// SetAngle sets Image rotation angle in degrees.
func (_egcg *Image )SetAngle (angle float64 ){_egcg ._adca =angle };

// NewImageFromFile creates an Image from a file.
func (_fbff *Creator )NewImageFromFile (path string )(*Image ,error ){return _bfad (path )};func (_ddada *Table )updateRowHeights (_bfced float64 ){for _ ,_aabbd :=range _ddada ._bbdb {_gbcae :=_aabbd .width (_ddada ._fbce ,_bfced );_acbcf :=_aabbd .height (_gbcae );
_abaef :=_ddada ._cbaab [_aabbd ._badcc +_aabbd ._gddee -2];if _aabbd ._gddee > 1{_ccacg :=0.0;_ceab :=_ddada ._cbaab [_aabbd ._badcc -1:(_aabbd ._badcc +_aabbd ._gddee -1)];for _ ,_fdgbe :=range _ceab {_ccacg +=_fdgbe ;};if _acbcf <=_ccacg {continue ;
};};if _acbcf > _abaef {_dbebf :=_acbcf /float64 (_aabbd ._gddee );if _dbebf > _abaef {for _eacga :=1;_eacga <=_aabbd ._gddee ;_eacga ++{if _dbebf > _ddada ._cbaab [_aabbd ._badcc +_eacga -2]{_ddada ._cbaab [_aabbd ._badcc +_eacga -2]=_dbebf ;};};};};};
};func (_agacb *TOCLine )prepareParagraph (_gdggf *StyledParagraph ,_dbggf DrawContext ){_acagg :=_agacb .Title .Text ;if _agacb .Number .Text !=""{_acagg ="\u0020"+_acagg ;};_acagg +="\u0020";_abcff :=_agacb .Page .Text ;if _abcff !=""{_abcff ="\u0020"+_abcff ;
};_begad :=[]*_cd .PdfAnnotation {};_aecc :=_agacb .getLineLink ();if _aecc !=nil {_begad =append (_begad ,_aecc );};_gdggf ._gceca =[]*TextChunk {{Text :_agacb .Number .Text ,Style :_agacb .Number .Style ,_ccbfe :_begad },{Text :_acagg ,Style :_agacb .Title .Style ,_ccbfe :_begad },{Text :_abcff ,Style :_agacb .Page .Style ,_ccbfe :_begad }};
_gdggf .wrapText ();_ecggee :=len (_gdggf ._aeca );if _ecggee ==0{return ;};_aede :=_dbggf .Width *1000-_gdggf .getTextLineWidth (_gdggf ._aeca [_ecggee -1]);_feebf :=_gdggf .getTextLineWidth ([]*TextChunk {&_agacb .Separator });_dcdgfa :=int (_aede /_feebf );
_gegf :=_gb .Repeat (_agacb .Separator .Text ,_dcdgfa );_gccc :=_agacb .Separator .Style ;_bbaac :=_gdggf .Insert (2,_gegf );_bbaac .Style =_gccc ;_bbaac .SetAnnotation (_agacb .getLineLink ());_aede =_aede -float64 (_dcdgfa )*_feebf ;if _aede > 500{_efcbd ,_aedbb :=_gccc .Font .GetRuneMetrics (' ');
if _aedbb &&_aede > _efcbd .Wx {_fbfff :=int (_aede /_efcbd .Wx );if _fbfff > 0{_bcdgfa :=_gccc ;_bcdgfa .FontSize =1;_bbaac =_gdggf .Insert (2,_gb .Repeat ("\u0020",_fbfff ));_bbaac .Style =_bcdgfa ;_bbaac .SetAnnotation (_agacb .getLineLink ());};};};
};func _ccggf (_abddc ,_adff ,_cfddg int )[]int {_bbbe :=[]int {};for _fdcde :=_abddc ;_fdcde <=_cfddg ;_fdcde +=_adff {_bbbe =append (_bbbe ,_fdcde );};return _bbbe ;};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_dbfa *Division )Height ()float64 {var _bbcd float64 ;for _ ,_fdaa :=range _dbfa ._bggcg {switch _dcag :=_fdaa .(type ){case marginDrawable :_ ,_ ,_bggf ,_eacd :=_dcag .GetMargins ();_bbcd +=_dcag .Height ()+_bggf +_eacd ;default:_bbcd +=_dcag .Height ();
};};return _bbcd ;};

// CreateFrontPage sets a function to generate a front Page.
func (_bede *Creator )CreateFrontPage (genFrontPageFunc func (_daac FrontpageFunctionArgs )){_bede ._gaed =genFrontPageFunc ;};

// DashPattern returns the dash pattern of the line.
func (_afcd *Line )DashPattern ()(_ebga []int64 ,_cfeg int64 ){return _afcd ._eebd ,_afcd ._agcc };func (_feafd *templateProcessor )parseTextVerticalAlignmentAttr (_ggdg ,_fgagb string )TextVerticalAlignment {_dc .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ggdg ,_fgagb );
_ddcae :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_fgagb ];return _ddcae ;};const (TextAlignmentLeft TextAlignment =iota ;
TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_deega *Image )ScaleToHeight (h float64 ){_acfg :=_deega ._gagbb /_deega ._cbgg ;_deega ._cbgg =h ;_deega ._gagbb =h *_acfg ;};func _cgde (_edfcc *templateProcessor ,_gdegbb *templateNode )(interface{},error ){return _edfcc .parseChart (_gdegbb );
};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_cfbd *Line )SetMargins (left ,right ,top ,bottom float64 ){_cfbd ._adbf .Left =left ;_cfbd ._adbf .Right =right ;_cfbd ._adbf .Top =top ;_cfbd ._adbf .Bottom =bottom ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_ed *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dae :=_aae .IdentityMatrix ();_ad ,_ba :=_ed .Width (),_ed .Height ();if _ed ._cdd .IsRelative (){_dae =_dae .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_ba );}else {_dae =_dae .Translate (_ed ._cfg ,ctx .PageHeight -_ed ._cab -_ba );
};_bed :=_ba ;if _ed ._ecg !=0{_dae =_dae .Translate (_ad /2,_ba /2).Rotate (_ed ._ecg *_fb .Pi /180.0).Translate (-_ad /2,-_ba /2);_ ,_bed =_ed .RotatedSize ();};if _ed ._cdd .IsRelative (){ctx .Y +=_bed ;};_ebf :=_ca .NewContentCreator ();_ebf .Add_cm (_dae [0],_dae [1],_dae [3],_dae [4],_dae [6],_dae [7]);
_gbg :=_ed .duplicate ();_cdf :=append (*_ebf .Operations (),*_gbg ._df ...);_cdf .WrapIfNeeded ();_gbg ._df =&_cdf ;for _ ,_ab :=range _ed ._dfcc {_cde ,_edb :=_bc .GetArray (_ab .Rect );if !_edb ||_cde .Len ()!=4{_dc .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_ab .Rect );
continue ;};_gdb ,_ffdg :=_cd .NewPdfRectangle (*_cde );if _ffdg !=nil {_dc .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_ffdg );
continue ;};_gdb .Transform (_dae );_ab .Rect =_gdb .ToPdfObject ();};return []*Block {_gbg },ctx ,nil ;};

// SetBorderColor sets the cell's border color.
func (_dafga *TableCell )SetBorderColor (col Color ){_dafga ._cbea =col ;_dafga ._efffe =col ;_dafga ._cefef =col ;_dafga ._bcfdc =col ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_bfbf *Invoice )Notes ()(string ,string ){return _bfbf ._efec [0],_bfbf ._efec [1]};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_egdc *Creator )AddPage (page *_cd .PdfPage )error {_faa ,_feaf :=_egdc .wrapPageIfNeeded (page );if _feaf !=nil {return _feaf ;};if _faa !=nil {page =_faa ;};_gfffb ,_feaf :=page .GetMediaBox ();if _feaf !=nil {_dc .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_feaf );
return _feaf ;};_gfffb .Normalize ();_fdebc ,_efdg :=_gfffb .Llx ,_gfffb .Lly ;_dfee :=_gfffb ;if _dcea :=page .CropBox ;_dcea !=nil &&*_dcea !=*_gfffb {_dcea .Normalize ();_fdebc ,_efdg =_dcea .Llx ,_dcea .Lly ;_dfee =_dcea ;};_fdfb :=_aae .IdentityMatrix ();
_eca ,_feaf :=page .GetRotate ();if _feaf !=nil {_dc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_feaf .Error ());
};_gcff :=_eca %360!=0&&_eca %90==0;if _gcff {_dfca :=float64 ((360+_eca %360)%360);if _dfca ==90{_fdfb =_fdfb .Translate (_dfee .Width (),0);}else if _dfca ==180{_fdfb =_fdfb .Translate (_dfee .Width (),_dfee .Height ());}else if _dfca ==270{_fdfb =_fdfb .Translate (0,_dfee .Height ());
};_fdfb =_fdfb .Mult (_aae .RotationMatrix (_dfca *_fb .Pi /180));_fdfb =_fdfb .Round (0.000001);_ggfd :=_fgfec (_dfee ,_fdfb );_dfee =_ggfd ;_dfee .Normalize ();};if _fdebc !=0||_efdg !=0{_fdfb =_aae .TranslationMatrix (_fdebc ,_efdg ).Mult (_fdfb );};
if !_fdfb .Identity (){_fdfb =_fdfb .Round (0.000001);_egdc ._dfge [page ]=&pageTransformations {_ace :&_fdfb };};_egdc ._gdac =_dfee .Width ();_egdc ._gdce =_dfee .Height ();_egdc .initContext ();_egdc ._cgb =append (_egdc ._cgb ,page );_egdc ._cfce .Page ++;
return nil ;};func (_acadc *GraphicSVGElement )drawEllipse (_gabbd *_ca .ContentCreator ,_bcab *_cd .PdfPageResources ){_gabbd .Add_q ();_acadc .Style .toContentStream (_gabbd ,_bcab ,_acadc );_bgcbg ,_badc :=_cagdb (_acadc .Attributes ["\u0063\u0078"],64);
if _badc !=nil {_dc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_badc .Error ());};_becgc ,_badc :=_cagdb (_acadc .Attributes ["\u0063\u0079"],64);
if _badc !=nil {_dc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_badc .Error ());};_edde ,_badc :=_cagdb (_acadc .Attributes ["\u0072\u0078"],64);
if _badc !=nil {_dc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_badc .Error ());};_dgbe ,_badc :=_cagdb (_acadc .Attributes ["\u0072\u0079"],64);
if _badc !=nil {_dc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_badc .Error ());};_edbe :=_edde *_acadc ._ddccg ;
_dccd :=_dgbe *_acadc ._ddccg ;_dcdac :=_bgcbg *_acadc ._ddccg ;_cgaf :=_becgc *_acadc ._ddccg ;_efab :=_edbe *_aebe ;_fbbfe :=_dccd *_aebe ;_acdeb :=_fg .NewCubicBezierPath ();_acdeb =_acdeb .AppendCurve (_fg .NewCubicBezierCurve (-_edbe ,0,-_edbe ,_fbbfe ,-_efab ,_dccd ,0,_dccd ));
_acdeb =_acdeb .AppendCurve (_fg .NewCubicBezierCurve (0,_dccd ,_efab ,_dccd ,_edbe ,_fbbfe ,_edbe ,0));_acdeb =_acdeb .AppendCurve (_fg .NewCubicBezierCurve (_edbe ,0,_edbe ,-_fbbfe ,_efab ,-_dccd ,0,-_dccd ));_acdeb =_acdeb .AppendCurve (_fg .NewCubicBezierCurve (0,-_dccd ,-_efab ,-_dccd ,-_edbe ,-_fbbfe ,-_edbe ,0));
_acdeb =_acdeb .Offset (_dcdac ,_cgaf );if _acadc .Style .StrokeWidth > 0{_acdeb =_acdeb .Offset (_acadc .Style .StrokeWidth /2,_acadc .Style .StrokeWidth /2);};_fg .DrawBezierPathWithCreator (_acdeb ,_gabbd );_acadc .Style .fillStroke (_gabbd );_gabbd .Add_h ();
_gabbd .Add_Q ();};func _dagc (_agf *Chapter ,_baac *TOC ,_dce *_cd .Outline ,_geda string ,_cdfg int ,_bcge TextStyle )*Chapter {var _cfca uint =1;if _agf !=nil {_cfca =_agf ._gfa +1;};_dda :=&Chapter {_fffd :_cdfg ,_dfcf :_geda ,_fbgf :true ,_eefa :true ,_bceb :_agf ,_cag :_baac ,_fad :_dce ,_aed :[]Drawable {},_gfa :_cfca };
_efba :=_eeff (_bcge );_geb :=_efba .SetText (_dda .headingText ());_geb .Style =_bcge ;_dda ._cgcg =_efba ;return _dda ;};

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_gcdf *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gcdf ._ddddf .Left ,_gcdf ._ddddf .Right ,_gcdf ._ddddf .Top ,_gcdf ._ddddf .Bottom ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_bg *Block )AddAnnotation (annotation *_cd .PdfAnnotation ){for _ ,_ebc :=range _bg ._dfcc {if _ebc ==annotation {return ;};};_bg ._dfcc =append (_bg ._dfcc ,annotation );};

// Columns returns all the columns in the invoice line items table.
func (_cbab *Invoice )Columns ()[]*InvoiceCell {return _cbab ._ebafb };func (_bddd *StyledParagraph )getTextHeight ()float64 {var _bbfdd float64 ;for _ ,_feadc :=range _bddd ._gceca {_cgbf :=_feadc .Style .FontSize *_bddd ._gdaeca ;if _cgbf > _bbfdd {_bbfdd =_cgbf ;
};};return _bbfdd ;};

// SetMarkedContentID sets the marked content ID for the image.
func (_aagcd *Image )SetMarkedContentID (mcid int64 )*_cd .KDict {_aagcd ._ffdce =&mcid ;_acdec :=_cd .NewKDictionary ();_acdec .S =_bc .MakeName (_cd .StructureTypeFigure );_acdec .K =_bc .MakeInteger (mcid );return _acdec ;};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_bcbaeb *RadialShading )AddPatternResource (block *Block )(_afcc _bc .PdfObjectName ,_fccd error ){_dggc :=1;_dcdb :=_bc .PdfObjectName ("\u0050"+_ge .Itoa (_dggc ));for block ._bcb .HasPatternByName (_dcdb ){_dggc ++;_dcdb =_bc .PdfObjectName ("\u0050"+_ge .Itoa (_dggc ));
};if _dfagg :=block ._bcb .SetPatternByName (_dcdb ,_bcbaeb .ToPdfShadingPattern ().ToPdfObject ());_dfagg !=nil {return "",_dfagg ;};return _dcdb ,nil ;};

// SkipOver skips over a specified number of rows and cols.
func (_gfefd *Table )SkipOver (rows ,cols int ){_gbafa :=rows *_gfefd ._gfgc +cols -1;if _gbafa < 0{_dc .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _eecec :=0;_eecec < _gbafa ;_eecec ++{_gfefd .NewCell ();};};

// SetLazy sets the lazy mode for the image.
func (_fcec *Image )SetLazy (lazy bool ){_fcec ._eecf =lazy };func (_dcae *List )split (_cfaaf DrawContext )(_dege ,_acgb *List ){var (_fabfd float64 ;_fcaa ,_fgbf []*listItem ;);_deggd :=_cfaaf .Width -_dcae ._afbf .Horizontal ()-_dcae ._acag -_dcae .markerWidth ();
_cagd :=_dcae .markerWidth ();for _gaee ,_edcge :=range _dcae ._ebfe {_cbdaf :=_edcge .ctxHeight (_deggd );_fabfd +=_cbdaf ;if _fabfd <=_cfaaf .Height {_fcaa =append (_fcaa ,_edcge );}else {switch _cbee :=_edcge ._adfbbg .(type ){case *List :_adfeb :=_cfaaf ;
_adfeb .Height =_fb .Floor (_cbdaf -(_fabfd -_cfaaf .Height ));_efbgd ,_gfbfb :=_cbee .split (_adfeb );if _efbgd !=nil {_fdebcg :=_fgaae ();_fdebcg ._geed =_edcge ._geed ;_fdebcg ._adfbbg =_efbgd ;_fcaa =append (_fcaa ,_fdebcg );};if _gfbfb !=nil {_caegg :=_cbee ._fbfg .Style .FontSize ;
_cfbc ,_afcae :=_cbee ._fbfg .Style .Font .GetRuneMetrics (' ');if _afcae {_caegg =_cbee ._fbfg .Style .FontSize *_cfbc .Wx *_cbee ._fbfg .Style .horizontalScale ()/1000.0;};_agcg :=_gb .Repeat ("\u0020",int (_cagd /_caegg ));_afff :=_fgaae ();_afff ._geed =*NewTextChunk (_agcg ,_cbee ._fbfg .Style );
_afff ._adfbbg =_gfbfb ;_fgbf =append (_fgbf ,_afff );_fgbf =append (_fgbf ,_dcae ._ebfe [_gaee +1:]...);};default:_fgbf =_dcae ._ebfe [_gaee :];};if len (_fgbf )> 0{break ;};};};if len (_fcaa )> 0{_dege =_bagc (_dcae ._adcc );*_dege =*_dcae ;_dege ._ebfe =_fcaa ;
};if len (_fgbf )> 0{_acgb =_bagc (_dcae ._adcc );*_acgb =*_dcae ;_acgb ._ebfe =_fgbf ;};return _dege ,_acgb ;};

// SetLanguage sets the language identifier that will be stored inside document catalog.
func (_dgdf *Creator )SetLanguage (language string ){_dgdf ._cbcg =language };func _caeg ()*GraphicSVGStyle {return &GraphicSVGStyle {FillColor :"\u00230\u0030\u0030\u0030\u0030\u0030",StrokeColor :"",StrokeWidth :0,FillOpacity :1.0};};

// SetWidthRight sets border width for right.
func (_eee *border )SetWidthRight (bw float64 ){_eee ._egb =bw };func (_agagca *templateProcessor )parseColorAttr (_ggfg ,_dbfcc string )Color {_dc .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_ggfg ,_dbfcc );
_dbfcc =_gb .TrimSpace (_dbfcc );if _gb .HasPrefix (_dbfcc ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_gb .HasSuffix (_dbfcc ,"\u0029")&&len (_dbfcc )> 17{return _agagca .parseLinearGradientAttr (_agagca .creator ,_dbfcc );
};if _gb .HasPrefix (_dbfcc ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_gb .HasSuffix (_dbfcc ,"\u0029")&&len (_dbfcc )> 17{return _agagca .parseRadialGradientAttr (_agagca .creator ,_dbfcc );};if _dcef :=_agagca .parseColor (_dbfcc );
_dcef !=nil {return _dcef ;};return ColorBlack ;};

// Length calculates and returns the length of the line.
func (_abaf *Line )Length ()float64 {return _fb .Sqrt (_fb .Pow (_abaf ._fgeg -_abaf ._cdfa ,2.0)+_fb .Pow (_abaf ._becde -_abaf ._eadda ,2.0));};

// SetSideBorderWidth sets the cell's side border width.
func (_acade *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_acade ._ebbgd =width ;_acade ._dabfb =width ;_acade ._bfgb =width ;_acade ._efdac =width ;case CellBorderSideTop :_acade ._ebbgd =width ;
case CellBorderSideBottom :_acade ._dabfb =width ;case CellBorderSideLeft :_acade ._bfgb =width ;case CellBorderSideRight :_acade ._efdac =width ;};};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_gfdae *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_fgdef :=&_gfdae ._afgga ;_fgdef .Left =left ;_fgdef .Right =right ;_fgdef .Top =top ;_fgdef .Bottom =bottom ;};

// SetBorderOpacity sets the border opacity.
func (_bacfg *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_bacfg ._efbdf =opacity };

// SetLineOpacity sets the line opacity.
func (_dbcdef *Polyline )SetLineOpacity (opacity float64 ){_dbcdef ._gbcb =opacity };

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_deee *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bffgd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ecbb ,_acfa :=_bffgd .setOpacity (_deee ._dfbd ,_deee ._ccb );if _acfa !=nil {return nil ,ctx ,_acfa ;
};_gcgg :=_deee ._fceg ;_gcgg .FillEnabled =_gcgg .FillColor !=nil ;_gcgg .BorderEnabled =_gcgg .BorderColor !=nil &&_gcgg .BorderWidth > 0;var (_gdag =ctx .PageHeight ;_abe =_gcgg .Rings ;_acgf =make ([][]_fg .CubicBezierCurve ,0,len (_gcgg .Rings ));
);_gefb :=_cd .PdfRectangle {};if len (_abe )> 0&&len (_abe [0])> 0{_dfce :=_abe [0][0];_dfce .P0 .Y =_gdag -_dfce .P0 .Y ;_dfce .P1 .Y =_gdag -_dfce .P1 .Y ;_dfce .P2 .Y =_gdag -_dfce .P2 .Y ;_dfce .P3 .Y =_gdag -_dfce .P3 .Y ;_gefb =_dfce .GetBounds ();
};for _ ,_ggeab :=range _abe {_gbaa :=make ([]_fg .CubicBezierCurve ,0,len (_ggeab ));for _ ,_fee :=range _ggeab {_ebg :=_fee ;_ebg .P0 .Y =_gdag -_ebg .P0 .Y ;_ebg .P1 .Y =_gdag -_ebg .P1 .Y ;_ebg .P2 .Y =_gdag -_ebg .P2 .Y ;_ebg .P3 .Y =_gdag -_ebg .P3 .Y ;
_gbaa =append (_gbaa ,_ebg );_gcgf :=_ebg .GetBounds ();_gefb .Llx =_fb .Min (_gefb .Llx ,_gcgf .Llx );_gefb .Lly =_fb .Min (_gefb .Lly ,_gcgf .Lly );_gefb .Urx =_fb .Max (_gefb .Urx ,_gcgf .Urx );_gefb .Ury =_fb .Max (_gefb .Ury ,_gcgf .Ury );};_acgf =append (_acgf ,_gbaa );
};_gcgg .Rings =_acgf ;defer func (){_gcgg .Rings =_abe }();if _gcgg .FillEnabled {_dbff :=_daeg (_bffgd ,_deee ._fceg .FillColor ,_deee ._cefd ,func ()Rectangle {return Rectangle {_aaabb :_gefb .Llx ,_adebb :_gefb .Lly ,_dcdaf :_gefb .Width (),_dbab :_gefb .Height ()};
});if _dbff !=nil {return nil ,ctx ,_dbff ;};};_aaag ,_ ,_acfa :=_gcgg .MarkedDraw (_ecbb ,_deee ._cgbe );if _acfa !=nil {return nil ,ctx ,_acfa ;};if _acfa =_bffgd .addContentsByString (string (_aaag ));_acfa !=nil {return nil ,ctx ,_acfa ;};return []*Block {_bffgd },ctx ,nil ;
};

// SetSubtotal sets the subtotal of the invoice.
func (_fgbgb *Invoice )SetSubtotal (value string ){_fgbgb ._adfbe [1].Value =value };

// SetTitleStyle sets the style properties of the invoice title.
func (_dccf *Invoice )SetTitleStyle (style TextStyle ){_dccf ._ggbef =style };

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_ffe *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _egefa (colorPoints );};func _cbdad (_edfe string )(float64 ,error ){_edfe =_gb .TrimSpace (_edfe );var _ddgf float64 ;if _gb .HasSuffix (_edfe ,"\u0025"){_fdadc ,_ffffg :=_ge .ParseFloat (_gb .TrimSuffix (_edfe ,"\u0025"),64);
if _ffffg !=nil {return 0,_ffffg ;};_ddgf =(_fdadc *255.0)/100.0;}else {_adga ,_afgd :=_ge .Atoi (_edfe );if _afgd !=nil {return 0,_afgd ;};_ddgf =float64 (_adga );};return _ddgf ,nil ;};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};func (_cccfaf *StyledParagraph )split (_ebeg DrawContext )(_dage ,_fcea *StyledParagraph ,_bdfffe error ){if _bdfffe =_cccfaf .wrapChunks (false );_bdfffe !=nil {return nil ,nil ,_bdfffe ;};if len (_cccfaf ._aeca )==1&&_cccfaf ._gdaeca > _ebeg .Height {return _cccfaf ,nil ,nil ;
};_cfdfb :=func (_bfba []*TextChunk ,_gadbd []*TextChunk )[]*TextChunk {if len (_gadbd )==0{return _bfba ;};_ggbgb :=len (_bfba );if _ggbgb ==0{return append (_bfba ,_gadbd ...);};if _bfba [_ggbgb -1].Style ==_gadbd [0].Style {_bfba [_ggbgb -1].Text +=_gadbd [0].Text ;
}else {_bfba =append (_bfba ,_gadbd [0]);};return append (_bfba ,_gadbd [1:]...);};_ccdd :=func (_ggde *StyledParagraph ,_ggbed []*TextChunk )*StyledParagraph {if len (_ggbed )==0{return nil ;};_daedd :=*_ggde ;_daedd ._gceca =_ggbed ;return &_daedd ;};
var (_cddbg float64 ;_gffa []*TextChunk ;_gfabc []*TextChunk ;);for _ ,_agef :=range _cccfaf ._aeca {var _cbdae float64 ;_eceac :=make ([]*TextChunk ,0,len (_agef ));for _ ,_ageeg :=range _agef {if _aacad :=_ageeg .Style .FontSize ;_aacad > _cbdae {_cbdae =_aacad ;
};_eceac =append (_eceac ,_ageeg .clone ());};_cbdae *=_cccfaf ._gdaeca ;if _cccfaf ._gaabe .IsRelative (){if _cddbg +_cbdae > _ebeg .Height {_gfabc =_cfdfb (_gfabc ,_eceac );}else {_gffa =_cfdfb (_gffa ,_eceac );};};_cddbg +=_cbdae ;};_cccfaf ._aeca =nil ;
if len (_gfabc )==0{return _cccfaf ,nil ,nil ;};return _ccdd (_cccfaf ,_gffa ),_ccdd (_cccfaf ,_gfabc ),nil ;};func (_ffbg *templateProcessor )parseDivision (_daff *templateNode )(interface{},error ){_cfbec :=_ffbg .creator .NewDivision ();for _ ,_begbg :=range _daff ._egac .Attr {_daege :=_begbg .Value ;
switch _fabbe :=_begbg .Name .Local ;_fabbe {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_cfbec .EnablePageWrap (_ffbg .parseBoolAttr (_fabbe ,_daege ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_aafae :=_ffbg .parseMarginAttr (_fabbe ,_daege );
_cfbec .SetMargins (_aafae .Left ,_aafae .Right ,_aafae .Top ,_aafae .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_dgdab :=_ffbg .parseMarginAttr (_fabbe ,_daege );_cfbec .SetPadding (_dgdab .Left ,_dgdab .Right ,_dgdab .Top ,_dgdab .Bottom );
default:_ffbg .nodeLogDebug (_daff ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_fabbe );
};};return _cfbec ,nil ;};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};func (_aafcg *Chapter )headingNumber ()string {var _affcf string ;
if _aafcg ._fbgf {if _aafcg ._fffd !=0{_affcf =_ge .Itoa (_aafcg ._fffd )+"\u002e";};if _aafcg ._bceb !=nil {_egcf :=_aafcg ._bceb .headingNumber ();if _egcf !=""{_affcf =_egcf +_affcf ;};};};return _affcf ;};

// SetCoords sets the center coordinates of the ellipse.
func (_acbc *Ellipse )SetCoords (xc ,yc float64 ){_acbc ._agdd =xc ;_acbc ._eebb =yc };

// Margins returns the margins of the list: left, right, top, bottom.
func (_bbfd *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _bbfd ._afbf .Left ,_bbfd ._afbf .Right ,_bbfd ._afbf .Top ,_bbfd ._afbf .Bottom ;};func (_acgd *templateProcessor )parseBorderRadiusAttr (_bdbggg ,_eadgb string )(_eeaea ,_dggdb ,_fefcg ,_gadgd float64 ){_dc .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_bdbggg ,_eadgb );
switch _febdg :=_gb .Fields (_eadgb );len (_febdg ){case 1:_eeaea ,_ =_ge .ParseFloat (_febdg [0],64);_dggdb =_eeaea ;_fefcg =_eeaea ;_gadgd =_eeaea ;case 2:_eeaea ,_ =_ge .ParseFloat (_febdg [0],64);_fefcg =_eeaea ;_dggdb ,_ =_ge .ParseFloat (_febdg [1],64);
_gadgd =_dggdb ;case 3:_eeaea ,_ =_ge .ParseFloat (_febdg [0],64);_dggdb ,_ =_ge .ParseFloat (_febdg [1],64);_gadgd =_dggdb ;_fefcg ,_ =_ge .ParseFloat (_febdg [2],64);case 4:_eeaea ,_ =_ge .ParseFloat (_febdg [0],64);_dggdb ,_ =_ge .ParseFloat (_febdg [1],64);
_fefcg ,_ =_ge .ParseFloat (_febdg [2],64);_gadgd ,_ =_ge .ParseFloat (_febdg [3],64);};return _eeaea ,_dggdb ,_fefcg ,_gadgd ;};

// SetTotal sets the total of the invoice.
func (_aegfb *Invoice )SetTotal (value string ){_aegfb ._ccaef [1].Value =value };

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_dgde *Rectangle )FillOpacity ()float64 {return _dgde ._ddeaec };

// CurRow returns the currently active cell's row number.
func (_acaca *Table )CurRow ()int {_bgfg :=(_acaca ._degcf -1)/_acaca ._gfgc +1;return _bgfg };

// SetStyleLeft sets border style for left side.
func (_dgee *border )SetStyleLeft (style CellBorderStyle ){_dgee ._bbc =style };

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_cgedg *Rectangle )SetPositioning (position Positioning ){_cgedg ._dgcaf =position };

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// MultiFont represents an encoder that accepts multiple fonts and selects the correct font for encoding.
MultiFont *_cd .MultipleFontEncoder ;

// Font represents the font the text will use.
Font *_cd .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_abggb *Image )SetWidth (w float64 ){_abggb ._gagbb =w };

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_gedgc *TOC )SetLinePageStyle (style TextStyle ){_gedgc ._abdfc =style };

// SetWidth sets the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_cged *Paragraph )SetWidth (width float64 ){_cged ._deeb =width ;_cged .wrapText ()};

// SetLineColor sets the line color.
func (_bafg *Polyline )SetLineColor (color Color ){_bafg ._bfde .LineColor =_dfd (color )};func (_dfad *TemplateOptions )init (){if _dfad .SubtemplateMap ==nil {_dfad .SubtemplateMap =map[string ]_ea .Reader {};};if _dfad .FontMap ==nil {_dfad .FontMap =map[string ]*_cd .PdfFont {};
};if _dfad .ImageMap ==nil {_dfad .ImageMap =map[string ]*_cd .Image {};};if _dfad .ColorMap ==nil {_dfad .ColorMap =map[string ]Color {};};if _dfad .ChartMap ==nil {_dfad .ChartMap =map[string ]_de .ChartRenderable {};};};

// SetBackground sets the background properties of the component.
func (_ccde *Division )SetBackground (background *Background ){_ccde ._geba =background };func _fecbgg (_cefc map[string ]string ,_bcaf float64 )(*GraphicSVGStyle ,error ){_cagg :=_caeg ();_gggb ,_bbfg :=_cefc ["\u0066\u0069\u006c\u006c"];if _bbfg {_cagg .FillColor =_gggb ;
if _gggb =="\u006e\u006f\u006e\u0065"{_cagg .FillColor ="";};};_gccaf ,_fdgf :=_cefc ["\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079"];if _fdgf {_egde ,_fdeba :=_eebbg (_gccaf );if _fdeba !=nil {return nil ,_fdeba ;};_cagg .FillOpacity =_egde ;
};_gfcg ,_cgaff :=_cefc ["\u0073\u0074\u0072\u006f\u006b\u0065"];if _cgaff {_cagg .StrokeColor =_gfcg ;if _gfcg =="\u006e\u006f\u006e\u0065"{_cagg .StrokeColor ="";};};_eebba ,_ffcdd :=_cefc ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];
if _ffcdd {_gaeg ,_dbda :=_cagdb (_eebba ,64);if _dbda !=nil {return nil ,_dbda ;};_cagg .StrokeWidth =_gaeg *_bcaf ;};return _cagg ,nil ;};

// AppendColumn appends a column to the line items table.
func (_edea *Invoice )AppendColumn (description string )*InvoiceCell {_gdgc :=_edea .NewColumn (description );_edea ._ebafb =append (_edea ._ebafb ,_gdgc );return _gdgc ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_gcggb *Rectangle )SetCoords (x ,y float64 ){_gcggb ._aaabb =x ;_gcggb ._adebb =y };

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;func _fgfed (_bbfda *templateProcessor ,_ffdfe *templateNode )(interface{},error ){return _bbfda .parseListMarker (_ffdfe );};

// Inline returns whether the inline mode of the division is active.
func (_deecd *Division )Inline ()bool {return _deecd ._ceda };

// GeneratePageBlocks draw graphic svg into block.
func (_fbfc *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aggda :=ctx ;_gbdd :=_fbfc ._bffac .IsRelative ();var _caac []*Block ;if _gbdd {_gcde :=1.0;_eff :=_fbfc ._ddddf .Top ;if _fbfc ._dbgf .Height > ctx .Height -_fbfc ._ddddf .Top {_caac =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _fdbc error ;if _ ,ctx ,_fdbc =_bdbb ().GeneratePageBlocks (ctx );_fdbc !=nil {return nil ,ctx ,_fdbc ;};_eff =0;};ctx .X +=_fbfc ._ddddf .Left +_gcde ;ctx .Y +=_eff ;ctx .Width -=_fbfc ._ddddf .Left +_fbfc ._ddddf .Right +2*_gcde ;ctx .Height -=_eff ;
}else {ctx .X =_fbfc ._gdbe ;ctx .Y =_fbfc ._abcd ;};_dcbfc :=_ca .NewContentCreator ();_dcbfc .Translate (0,ctx .PageHeight );_dcbfc .Scale (1,-1);_dcbfc .Translate (ctx .X ,ctx .Y );_fgfb :=_fbfc ._dbgf .Width /_fbfc ._dbgf .ViewBox .W ;_gdcab :=_fbfc ._dbgf .Height /_fbfc ._dbgf .ViewBox .H ;
_afcad :=0.0;_dfebb :=0.0;if _gbdd {_afcad =_fbfc ._gdbe -(_fbfc ._dbgf .ViewBox .X *_fb .Max (_fgfb ,_gdcab ));_dfebb =_fbfc ._abcd -(_fbfc ._dbgf .ViewBox .Y *_fb .Max (_fgfb ,_gdcab ));};_aecg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _fbfc ._dcceb !=nil {_dcbfc .Add_BDC (*_bc .MakeName (_cd .StructureTypeFigure ),map[string ]_bc .PdfObject {"\u004d\u0043\u0049\u0044":_bc .MakeInteger (*_fbfc ._dcceb )});
};_fbfc ._dbgf .SetPos (ctx .X ,ctx .Y );_fbfc ._dbgf .ToContentCreator (_dcbfc ,_aecg ._bcb ,_fgfb ,_gdcab ,_afcad ,_dfebb );if _fbfc ._dcceb !=nil {_dcbfc .Add_EMC ();};if _dcge :=_aecg .addContentsByString (_dcbfc .String ());_dcge !=nil {return nil ,ctx ,_dcge ;
};if _gbdd {_bbee :=_fbfc .Height ()+_fbfc ._ddddf .Bottom ;ctx .Y +=_bbee ;ctx .Height -=_bbee ;}else {ctx =_aggda ;};_caac =append (_caac ,_aecg );return _caac ,ctx ,nil ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// GetIndent get the cell's left indent.
func (_addgc *GridCell )GetIndent ()float64 {return _addgc ._cbfg };func _bgaac (_bebac string )(float64 ,float64 ,float64 ){_fbcg :=_gb .TrimPrefix (_bebac ,"\u0072\u0067\u0062\u0028");_fbcg =_gb .TrimSuffix (_fbcg ,"\u0029");_ceefb :=_gb .Split (_fbcg ,"\u002c");
if len (_ceefb )!=3{_dc .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_bebac );return 0,0,0;};var _gdgda ,_aegag ,_edcgeb float64 ;
_gdgda ,_dgbec :=_cbdad (_ceefb [0]);if _dgbec !=nil {_dc .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_bebac );
return 0,0,0;};_aegag ,_dgbec =_cbdad (_ceefb [1]);if _dgbec !=nil {_dc .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_bebac );
return 0,0,0;};_edcgeb ,_dgbec =_cbdad (_ceefb [2]);if _dgbec !=nil {_dc .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_bebac );
return 0,0,0;};_egggfg :=_gdgda /255.0;_bcbe :=_aegag /255.0;_aabe :=_edcgeb /255.0;return _egggfg ,_bcbe ,_aabe ;};func (_acab *Path )compare (_eeaad *Path )bool {if len (_acab .Subpaths )!=len (_eeaad .Subpaths ){return false ;};for _fggbe ,_cgagb :=range _acab .Subpaths {if !_cgagb .compare (_eeaad .Subpaths [_fggbe ]){return false ;
};};return true ;};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_acae *Division )Add (d VectorDrawable )error {switch _gagg :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_fdcg ,_ddba :=_gagg .ContainerComponent (_acae );
if _ddba !=nil {return _ddba ;};_cegc ,_gcdg :=_fdcg .(VectorDrawable );if !_gcdg {return _a .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_fdcg );
};d =_cegc ;default:return _ga .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_acae ._bggcg =append (_acae ._bggcg ,d );return nil ;};

// NewCell returns a new invoice table cell.
func (_gfed *Invoice )NewCell (value string )*InvoiceCell {return _gfed .newCell (value ,_gfed .NewCellProps ());};func _adag (_efcd [][]_fg .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_fceg :&_fg .CurvePolygon {Rings :_efcd },_dfbd :1.0,_ccb :1.0};
};

// Add adds a new line with the default style to the table of contents.
func (_cbgd *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_afgf :=_cbgd .AddLine (_abcf (TextChunk {Text :number ,Style :_cbgd ._agcfe },TextChunk {Text :title ,Style :_cbgd ._fbfe },TextChunk {Text :page ,Style :_cbgd ._abdfc },level ,_cbgd ._baeaa ));
if _afgf ==nil {return nil ;};_agbfg :=&_cbgd ._afgga ;_afgf .SetMargins (_agbfg .Left ,_agbfg .Right ,_agbfg .Top ,_agbfg .Bottom );_afgf .SetLevelOffset (_cbgd ._gfdea );_afgf .Separator .Text =_cbgd ._cbbcf ;_afgf .Separator .Style =_cbgd ._fbdd ;return _afgf ;
};

// SetFillOpacity sets the fill opacity.
func (_ebbeb *Polygon )SetFillOpacity (opacity float64 ){_ebbeb ._adgb =opacity };

// Context returns the current drawing context.
func (_aaae *Creator )Context ()DrawContext {return _aaae ._cfce };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_addbg *TOC )SetHeading (text string ,style TextStyle ){_cdaf :=_addbg .Heading ();_cdaf .Reset ();_deffb :=_cdaf .Append (text );_deffb .Style =style ;};func (_edada *StyledParagraph )getTextWidth ()float64 {var _fcgadf float64 ;_gaaa :=len (_edada ._gceca );
for _cgcd ,_cfgad :=range _edada ._gceca {_effe :=&_cfgad .Style ;_aeff :=len (_cfgad .Text );for _agfd ,_aaage :=range _cfgad .Text {if _aaage =='\u000A'{continue ;};_cfcc ,_abag :=_effe .Font .GetRuneMetrics (_aaage );if !_abag {_dc .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_aaage );
return -1;};_fcgadf +=_effe .FontSize *_cfcc .Wx *_effe .horizontalScale ();if _aaage !=' '&&(_cgcd !=_gaaa -1||_agfd !=_aeff -1){_fcgadf +=_effe .CharSpacing *1000.0;};};};return _fcgadf ;};const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;
AnchorTopLeft ;AnchorTopRight ;AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);

// SetFillOpacity sets the fill opacity.
func (_cabc *CurvePolygon )SetFillOpacity (opacity float64 ){_cabc ._dfbd =opacity };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_eada *RadialShading )SetBackgroundColor (backgroundColor Color ){_eada ._aaaed .SetBackgroundColor (backgroundColor );};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _bdca ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_bff :=&Creator {};_bff ._cgb =[]*_cd .PdfPage {};_bff ._bedd =map[*_cd .PdfPage ]*Block {};_bff ._dfge =map[*_cd .PdfPage ]*pageTransformations {};_bff .SetPageSize (PageSizeLetter );
_dbdd :=0.1*_bff ._gdac ;_bff ._gced .Left =_dbdd ;_bff ._gced .Right =_dbdd ;_bff ._gced .Top =_dbdd ;_bff ._gced .Bottom =_dbdd ;var _cggc error ;_bff ._becdg ,_cggc =_cd .NewStandard14Font (_cd .HelveticaName );if _cggc !=nil {_bff ._becdg =_cd .DefaultFont ();
};_bff ._aaeed ,_cggc =_cd .NewStandard14Font (_cd .HelveticaBoldName );if _cggc !=nil {_bff ._becdg =_cd .DefaultFont ();};_bff ._bga =_bff .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_bff .AddOutlines =true ;
_bff ._daba =_cd .NewOutline ();_cf .TrackUse (_bdca );return _bff ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;
TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// Indent returns the left offset of the list when nested into another list.
func (_egfgae *List )Indent ()float64 {return _egfgae ._acag };func _ccfb (_aaeef string ,_dcfef bool )string {_cbaag :=_aaeef ;if _cbaag ==""{return "";};_fbda :=_gag .Paragraph {};_ ,_dabda :=_fbda .SetString (_aaeef );if _dabda !=nil {return _cbaag ;
};_fbddf ,_dabda :=_fbda .Order ();if _dabda !=nil {return _cbaag ;};_egea :=_fbddf .NumRuns ();_cedfa :=make ([]string ,_egea );for _fdccd :=0;_fdccd < _fbddf .NumRuns ();_fdccd ++{_fggc :=_fbddf .Run (_fdccd );_fdbaa :=_fggc .String ();if _fggc .Direction ()==_gag .RightToLeft {_fdbaa =_gag .ReverseString (_fdbaa );
};if _dcfef {_cedfa [_fdccd ]=_fdbaa ;}else {_cedfa [_egea -1]=_fdbaa ;};_egea --;};if len (_cedfa )!=_fbddf .NumRuns (){return _aaeef ;};_cbaag =_gb .Join (_cedfa ,"");return _cbaag ;};func (_accc *templateProcessor )parseChapterHeading (_gcaa *templateNode )(interface{},error ){if _gcaa ._fafg ==nil {_accc .nodeLogError (_gcaa ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_bfcee ;};_caaad ,_facdd :=_gcaa ._fafg ._bedgb .(*Chapter );if !_facdd {_accc .nodeLogError (_gcaa ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_gcaa ._fafg ._bedgb );
return nil ,_bfcee ;};_adcga :=_caaad .GetHeading ();if _ ,_ecbc :=_accc .parseParagraph (_gcaa ,_adcga );_ecbc !=nil {return nil ,_ecbc ;};return _adcga ,nil ;};func (_aaaee *Command )compare (_bbebac *Command )bool {if _aaaee .Symbol !=_bbebac .Symbol {return false ;
};for _ddcbg ,_efgadb :=range _aaaee .Params {if _efgadb !=_bbebac .Params [_ddcbg ]{return false ;};};return true ;};func _fgeae (_babbg string ,_abeg TextStyle )*Paragraph {_gbdgd :=&Paragraph {_ceeaa :_babbg ,_fgef :_abeg .Font ,_ebab :_abeg .FontSize ,_dbfac :1.0,_aacba :true ,_bagg :true ,_aaagb :TextAlignmentLeft ,_gdaec :0,_affff :1,_accag :1,_egaac :PositionRelative ,_dffff :""};
_gbdgd .SetColor (_abeg .Color );return _gbdgd ;};func (_afeg *Table )sortCells (){_da .Slice (_afeg ._bbdb ,func (_becab ,_aabgc int )bool {_agfefa :=_afeg ._bbdb [_becab ]._badcc ;_dcaed :=_afeg ._bbdb [_aabgc ]._badcc ;if _agfefa < _dcaed {return true ;
};if _agfefa > _dcaed {return false ;};return _afeg ._bbdb [_becab ]._gdgcb < _afeg ._bbdb [_aabgc ]._gdgcb ;});};

// NewInvoice returns an instance of an empty invoice.
func (_gfbf *Creator )NewInvoice ()*Invoice {_eccc :=_gfbf .NewTextStyle ();_eccc .Font =_gfbf ._aaeed ;return _eeeg (_gfbf .NewTextStyle (),_eccc );};type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_ccef *Creator )Finalize ()error {if _ccef ._aca {return nil ;};_gfg :=len (_ccef ._cgb );_degc :=0;if _ccef ._gaed !=nil {_fbde :=*_ccef ;_ccef ._cgb =nil ;_ccef ._deg =nil ;_ccef .initContext ();_bceg :=FrontpageFunctionArgs {PageNum :1,TotalPages :_gfg };
_ccef ._gaed (_bceg );_degc +=len (_ccef ._cgb );_ccef ._cgb =_fbde ._cgb ;_ccef ._deg =_fbde ._deg ;};if _ccef .AddTOC {_ccef .initContext ();_ccef ._cfce .Page =_degc +1;if _ccef .CustomTOC &&_ccef ._efaa !=nil {_cdb :=*_ccef ;_ccef ._cgb =nil ;_ccef ._deg =nil ;
if _eged :=_ccef ._efaa (_ccef ._bga );_eged !=nil {return _eged ;};_degc +=len (_ccef ._cgb );_ccef ._cgb =_cdb ._cgb ;_ccef ._deg =_cdb ._deg ;}else {if _ccef ._efaa !=nil {if _ecegd :=_ccef ._efaa (_ccef ._bga );_ecegd !=nil {return _ecegd ;};};_aafa ,_ ,_ebac :=_ccef ._bga .GeneratePageBlocks (_ccef ._cfce );
if _ebac !=nil {_dc .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_ebac );return _ebac ;};_degc +=len (_aafa );};_afbc :=_ccef ._bga .Lines ();
for _ ,_bgec :=range _afbc {_gbccf ,_dcc :=_ge .Atoi (_bgec .Page .Text );if _dcc !=nil {continue ;};_bgec .Page .Text =_ge .Itoa (_gbccf +_degc );_bgec ._agcdg +=int64 (_degc );};};_dggb :=false ;var _efbg []*_cd .PdfPage ;if _ccef ._gaed !=nil {_egbe :=*_ccef ;
_ccef ._cgb =nil ;_ccef ._deg =nil ;_ebff :=FrontpageFunctionArgs {PageNum :1,TotalPages :_gfg };_ccef ._gaed (_ebff );_gfg +=len (_ccef ._cgb );_efbg =_ccef ._cgb ;_ccef ._cgb =append (_ccef ._cgb ,_egbe ._cgb ...);_ccef ._deg =_egbe ._deg ;_dggb =true ;
};var _bffg []*_cd .PdfPage ;if _ccef .AddTOC {_ccef .initContext ();if _ccef .CustomTOC &&_ccef ._efaa !=nil {_gfaf :=*_ccef ;_ccef ._cgb =nil ;_ccef ._deg =nil ;if _dfcb :=_ccef ._efaa (_ccef ._bga );_dfcb !=nil {_dc .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_dfcb );
return _dfcb ;};_bffg =_ccef ._cgb ;_gfg +=len (_bffg );_ccef ._cgb =_gfaf ._cgb ;_ccef ._deg =_gfaf ._deg ;}else {if _ccef ._efaa !=nil {if _bffe :=_ccef ._efaa (_ccef ._bga );_bffe !=nil {_dc .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_bffe );
return _bffe ;};};_efae ,_ ,_ :=_ccef ._bga .GeneratePageBlocks (_ccef ._cfce );for _ ,_fbga :=range _efae {_fbga .SetPos (0,0);_gfg ++;_fbf :=_ccef .newPage ();_bffg =append (_bffg ,_fbf );_ccef .setActivePage (_fbf );_ccef .Draw (_fbga );};};if _dggb {_ggfe :=_efbg ;
_adgc :=_ccef ._cgb [len (_efbg ):];_ccef ._cgb =append ([]*_cd .PdfPage {},_ggfe ...);_ccef ._cgb =append (_ccef ._cgb ,_bffg ...);_ccef ._cgb =append (_ccef ._cgb ,_adgc ...);}else {_ccef ._cgb =append (_bffg ,_ccef ._cgb ...);};};if _ccef ._daba !=nil &&_ccef .AddOutlines {var _gfab func (_bdcf *_cd .OutlineItem );
_gfab =func (_fdd *_cd .OutlineItem ){_fdd .Dest .Page +=int64 (_degc );if _bead :=int (_fdd .Dest .Page );_bead >=0&&_bead < len (_ccef ._cgb ){_fdd .Dest .PageObj =_ccef ._cgb [_bead ].GetPageAsIndirectObject ();}else {_dc .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_bead );
};_fdd .Dest .Y =_aac .RoundDefault (_ccef ._gdce -_fdd .Dest .Y );_degcg :=_fdd .Items ();for _ ,_cfag :=range _degcg {_gfab (_cfag );};};_fba :=_ccef ._daba .Items ();for _ ,_cbfee :=range _fba {_gfab (_cbfee );};if _ccef .AddTOC {var _efgd int ;if _dggb {_efgd =len (_efbg );
};_gbgf :=_cd .NewOutlineDest (int64 (_efgd ),0,_ccef ._gdce );if _efgd >=0&&_efgd < len (_ccef ._cgb ){_gbgf .PageObj =_ccef ._cgb [_efgd ].GetPageAsIndirectObject ();}else {_dc .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_efgd );
};_ccef ._daba .Insert (0,_cd .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_gbgf ));};};for _cge ,_bdfff :=range _ccef ._cgb {_ccef .setActivePage (_bdfff );if _ccef ._acd !=nil {_fecb ,_gde ,_dbc :=_bdfff .Size ();
if _dbc !=nil {return _dbc ;};_deb :=PageFinalizeFunctionArgs {PageNum :_cge +1,PageWidth :_fecb ,PageHeight :_gde ,TOCPages :len (_bffg ),TotalPages :_gfg };if _cege :=_ccef ._acd (_deb );_cege !=nil {_dc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_cege );
return _cege ;};};if _ccef ._aegb !=nil {_agfa :=NewBlock (_ccef ._gdac ,_ccef ._gced .Top );_cefgg :=HeaderFunctionArgs {PageNum :_cge +1,TotalPages :_gfg };_ccef ._aegb (_agfa ,_cefgg );_agfa .SetPos (0,0);if _ddg :=_ccef .Draw (_agfa );_ddg !=nil {_dc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_ddg );
return _ddg ;};};if _ccef ._bdfg !=nil {_gaae :=NewBlock (_ccef ._gdac ,_ccef ._gced .Bottom );_afd :=FooterFunctionArgs {PageNum :_cge +1,TotalPages :_gfg };_ccef ._bdfg (_gaae ,_afd );_gaae .SetPos (0,_ccef ._gdce -_gaae ._dff );if _acce :=_ccef .Draw (_gaae );
_acce !=nil {_dc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_acce );return _acce ;};};_dffg ,_ddc :=_ccef ._dfge [_bdfff ];if _dbgb ,_cfagf :=_ccef ._bedd [_bdfff ];
_cfagf {if _ddc {_dffg .transformBlock (_dbgb );};if _decc :=_dbgb .drawToPage (_bdfff );_decc !=nil {_dc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_cge +1,_decc );
return _decc ;};};if _ddc {if _fcbb :=_dffg .transformPage (_bdfff );_fcbb !=nil {_dc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_fcbb );
return _fcbb ;};};};_ccef ._aca =true ;return nil ;};

// Opacity returns the opacity of the line.
func (_dfbae *Line )Opacity ()float64 {return _dfbae ._gfde };

// SetMarkedContentID sets the marked content id for the list.
func (_bdde *List )SetMarkedContentID (id int64 )*_cd .KDict {return nil };func (_eegaf *templateProcessor )parseTextRenderingModeAttr (_dabcb ,_adfdb string )TextRenderingMode {_dc .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dabcb ,_adfdb );
_gbdbg :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_adfdb ];
return _gbdbg ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_fadad *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _dcaf (x1 ,y1 ,cx ,cy ,x2 ,y2 );};func (_ebced *templateProcessor )parseLinearGradientAttr (creator *Creator ,_bbeae string )Color {_caeag :=ColorBlack ;if _bbeae ==""{return _caeag ;
};_gaegc :=creator .NewLinearGradientColor ([]*ColorPoint {});_gaegc .SetExtends (true ,true );var (_ceef =_gb .Split (_bbeae [16:len (_bbeae )-1],"\u002c");_gdggc =_gb .TrimSpace (_ceef [0]););if _gb .HasSuffix (_gdggc ,"\u0064\u0065\u0067"){_egggf ,_eaaa :=_ge .ParseFloat (_gdggc [:len (_gdggc )-3],64);
if _eaaa !=nil {_dc .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_eaaa );}else {_gaegc .SetAngle (_egggf );
};_ceef =_ceef [1:];};_eedb ,_dceg :=_ebced .processGradientColorPair (_ceef );if _eedb ==nil ||_dceg ==nil {return _caeag ;};for _fecc :=0;_fecc < len (_eedb );_fecc ++{_gaegc .AddColorStop (_eedb [_fecc ],_dceg [_fecc ]);};return _gaegc ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_fcgb *Invoice )InfoLines ()[][2]*InvoiceCell {_acbef :=[][2]*InvoiceCell {_fcgb ._bedb ,_fcgb ._aecde ,_fcgb ._fgcd };return append (_acbef ,_fcgb ._abggd ...);};func (_cefdd *Image )makeXObject ()error {_deabf ,_eded :=_cd .NewXObjectImageFromImageLazy (_cefdd ._fbca ,nil ,_cefdd ._baed ,_cefdd ._eecf );
if _eded !=nil {_dc .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_eded );return _eded ;};_cefdd ._gcfb =_deabf ;
return nil ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_bfdbb *TOC )SetLineNumberStyle (style TextStyle ){_bfdbb ._agcfe =style };

// MoveY moves the drawing context to absolute position y.
func (_cdcd *Creator )MoveY (y float64 ){_cdcd ._cfce .Y =y };const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;);func _dfgf (_bfefd *_cd .PdfFont ,_eccfb float64 )*fontMetrics {_dffea :=&fontMetrics {};
if _bfefd ==nil {_dc .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");return _dffea ;};_bdfd ,_efgaf :=_bfefd .GetFontDescriptor ();if _efgaf !=nil {_dc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_efgaf );
return _dffea ;};if _dffea ._faafd ,_efgaf =_bdfd .GetCapHeight ();_efgaf !=nil {_dc .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_efgaf );
};if int (_dffea ._faafd )<=0{_dc .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_dffea ._faafd =1000;};_dffea ._faafd *=_eccfb /1000.0;if _dffea ._cgdcd ,_efgaf =_bdfd .GetXHeight ();_efgaf !=nil {_dc .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_efgaf );
};_dffea ._cgdcd *=_eccfb /1000.0;if _dffea ._bffeg ,_efgaf =_bdfd .GetAscent ();_efgaf !=nil {_dc .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_efgaf );
};_dffea ._bffeg *=_eccfb /1000.0;if _dffea ._fdfbeg ,_efgaf =_bdfd .GetDescent ();_efgaf !=nil {_dc .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_efgaf );
};_dffea ._fdfbeg *=_eccfb /1000.0;return _dffea ;};func (_agfg *GridCell )width (_fgag []float64 ,_efafc float64 )float64 {_gece :=float64 (0.0);for _gfdc :=0;_gfdc < _agfg ._fefb ;_gfdc ++{_gece +=_fgag [_agfg ._degg +_gfdc ];};return _gece *_efafc ;
};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_dfec *Invoice )Terms ()(string ,string ){return _dfec ._agagf [0],_dfec ._agagf [1]};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dbad *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _dbad ._fgcd [0],_dbad ._fgcd [1]};

// Width returns the width of the specified text chunk.
func (_gfbcg *TextChunk )Width ()float64 {var (_ggcab float64 ;_ecdcf =_gfbcg .Style ;);for _ ,_ebbb :=range _gfbcg .Text {_aacade ,_bdcde :=_ecdcf .Font .GetRuneMetrics (_ebbb );if !_bdcde {_dc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_ebbb ,_ebbb ,_ecdcf .Font .BaseFont (),_ecdcf .Font .Subtype ());
_dc .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_ecdcf .Font );_dc .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_ecdcf .Font .Encoder ());};_cdfaf :=_ecdcf .FontSize *_aacade .Wx ;_eecfe :=_cdfaf ;if _ebbb !=' '{_eecfe =_cdfaf +_ecdcf .CharSpacing *1000.0;
};_ggcab +=_eecfe ;};return _ggcab /1000.0;};func _eebbg (_gebfbb string )(float64 ,error ){_gebfbb =_gb .TrimSpace (_gebfbb );var _ddefb float64 ;if _gb .HasSuffix (_gebfbb ,"\u0025"){_dcbec ,_ggeag :=_ge .ParseFloat (_gb .TrimSuffix (_gebfbb ,"\u0025"),64);
if _ggeag !=nil {return 0,_ggeag ;};_ddefb =_dcbec /100.0;}else {_facad ,_bdcef :=_ge .ParseFloat (_gebfbb ,64);if _bdcef !=nil {return 0,_bdcef ;};_ddefb =_facad ;};return _ddefb ,nil ;};func _adfab (_fddaa *templateProcessor ,_dfccbf *templateNode )(interface{},error ){return _fddaa .parseTextChunk (_dfccbf ,nil );
};

// SetStyleTop sets border style for top side.
func (_eceg *border )SetStyleTop (style CellBorderStyle ){_eceg ._dec =style };

// Height returns the height of the chart.
func (_efd *Chart )Height ()float64 {return float64 (_efd ._eegd .Height ())};

// SetLogo sets the logo of the invoice.
func (_gggg *Invoice )SetLogo (logo *Image ){_gggg ._deegg =logo };

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_cabca *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_gdge :=_eeff (_cabca ._adcc );_gdge .Append (text );_ffac ,_ggggg :=_cabca .Add (_gdge );return _gdge ,_ffac ,_ggggg ;};func (_badgf *templateProcessor )parseAttrPropList (_acaeg string )map[string ]string {_abgad :=_gb .Fields (_acaeg );
if len (_abgad )==0{return nil ;};_efdc :=map[string ]string {};for _ ,_bfefg :=range _abgad {_aeafg :=_bfgg .FindStringSubmatch (_bfefg );if len (_aeafg )< 3{continue ;};_cdgad ,_ccccf :=_gb .TrimSpace (_aeafg [1]),_aeafg [2];if _cdgad ==""{continue ;
};_efdc [_cdgad ]=_ccccf ;};return _efdc ;};func _fbdbd ()commands {var _affcfc =map[string ]int {"\u006d":2,"\u007a":0,"\u006c":2,"\u0068":1,"\u0076":1,"\u0063":6,"\u0073":4,"\u0071":4,"\u0074":2,"\u0061":7};var _dafde []string ;for _fecdc :=range _affcfc {_dafde =append (_dafde ,_fecdc );
};return commands {_dafde ,_affcfc ,"\u006d","\u007a"};};

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_beda *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _efadb (xc ,yc ,width ,height );};

// GraphicSVGStyle represents style attributes for `GraphicSVG`.
type GraphicSVGStyle struct{FillColor string ;StrokeColor string ;StrokeWidth float64 ;FillOpacity float64 ;};

// SetMargins sets the Paragraph's margins.
func (_ffcd *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_ffcd ._gebac .Left =left ;_ffcd ._gebac .Right =right ;_ffcd ._gebac .Top =top ;_ffcd ._gebac .Bottom =bottom ;};func _fcgcf (_effag *templateProcessor ,_afdec *templateNode )(interface{},error ){return _effag .parseChapter (_afdec );
};

// NewPolyline creates a new polyline.
func (_gebe *Creator )NewPolyline (points []_fg .Point )*Polyline {return _feca (points )};

// SetMarkedContentID sets marked content ID.
func (_fgeb *border )SetMarkedContentID (id int64 )*_cd .KDict {return nil };func _gaeed (_adged ,_faggc ,_gacbef float64 )(_dgcd ,_edfbf ,_aeba ,_gfdad float64 ){if _gacbef ==0{return 0,0,_adged ,_faggc ;};_bbbda :=_fg .Path {Points :[]_fg .Point {_fg .NewPoint (0,0).Rotate (_gacbef ),_fg .NewPoint (_adged ,0).Rotate (_gacbef ),_fg .NewPoint (0,_faggc ).Rotate (_gacbef ),_fg .NewPoint (_adged ,_faggc ).Rotate (_gacbef )}}.GetBoundingBox ();
return _bbbda .X ,_bbbda .Y ,_bbbda .Width ,_bbbda .Height ;};

// Width returns Image's document width.
func (_feafg *Image )Width ()float64 {return _feafg ._gagbb };

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_ggdec *TOC )SetLineStyle (style TextStyle ){_ggdec .SetLineNumberStyle (style );_ggdec .SetLineTitleStyle (style );_ggdec .SetLineSeparatorStyle (style );_ggdec .SetLinePageStyle (style );};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_fcf *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_fcf ._dadf =align ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_cfbg *Creator )MoveDown (dy float64 ){_cfbg ._cfce .Y +=dy };

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_caa *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _cada (x ,y ,width ,height );};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_bggcg []VectorDrawable ;_ecec Positioning ;_bdbe Margins ;_egfg Margins ;_ceda bool ;_fcdc bool ;_geba *Background ;};

// SetMakeredContentID sets the marked content identifier for the ellipse.
func (_cfbaf *Ellipse )SetMarkedContentID (mcid int64 )*_cd .KDict {_cfbaf ._cga =&mcid ;_cfagfa :=_cd .NewKDictionary ();_cfagfa .S =_bc .MakeName (_cd .StructureTypeFigure );_cfagfa .K =_bc .MakeInteger (mcid );return _cfagfa ;};

// SetColPosition sets cell column position.
func (_ffga *TableCell )SetColPosition (col int ){_ffga ._gdgcb =col };

// SetNumber sets the number of the invoice.
func (_ecccf *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_ecccf ._bedb [1].Value =number ;return _ecccf ._bedb [0],_ecccf ._bedb [1];};

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_agfe *Rectangle )GetCoords ()(float64 ,float64 ){return _agfe ._aaabb ,_agfe ._adebb };func (_gbbc *StyledParagraph )wrapChunks (_fgfe bool )error {if !_gbbc ._ccbe ||int (_gbbc ._gabb )<=0{_gbbc ._aeca =[][]*TextChunk {_gbbc ._gceca };return nil ;
};if _gbbc ._decb {_gbbc .wrapWordChunks ();};_gbbc ._aeca =[][]*TextChunk {};var _gedg []*TextChunk ;var _cbdca float64 ;_ggce :=_f .IsSpace ;if !_fgfe {_ggce =func (rune )bool {return false };};_gdfgf :=_bgbbb (_gbbc ._gabb *1000.0,0.000001);for _ ,_dfaf :=range _gbbc ._gceca {_ecde :=_dfaf .Style ;
_baba :=_dfaf ._ccbfe ;_eadae :=_dfaf .VerticalAlignment ;var (_edca []rune ;_eagdg []float64 ;);_bgge :=_geab (_dfaf .Text );for _ ,_dcfb :=range _dfaf .Text {if _dcfb =='\u000A'{if !_fgfe {_edca =append (_edca ,_dcfb );};_gedg =append (_gedg ,&TextChunk {Text :_gb .TrimRightFunc (string (_edca ),_ggce ),Style :_ecde ,_ccbfe :_gbbef (_baba ),VerticalAlignment :_eadae ,_dfcgg :_dfaf ._dfcgg ,_fdaee :_dfaf ._fdaee ,_ccgfa :_dfaf ._ccgfa });
if _babbgb :=_gbbc .addLine (_gedg );!_babbgb {return nil ;};_gedg =nil ;_cbdca =0;_edca =nil ;_eagdg =nil ;continue ;};_acee :=_dcfb ==' ';_eagcd ,_geaf :=_ecde .Font .GetRuneMetrics (_dcfb );if _eagcd .Wx ==0&&_ecde .MultiFont !=nil ||_ecde .MultiFont !=nil &&!_geaf {_eagcd ,_geaf =_ecde .MultiFont .GetRuneMetrics (_dcfb );
};if !_geaf {_dc .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dcfb );return _ga .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_adfag :=_ecde .FontSize *_eagcd .Wx *_ecde .horizontalScale ();_fgfc :=_adfag ;if !_acee {_fgfc =_adfag +_ecde .CharSpacing *1000.0;};if _cbdca +_adfag > _gdfgf {_bgfbg :=-1;if !_acee {for _bgdgb :=len (_edca )-1;_bgdgb >=0;_bgdgb --{if _edca [_bgdgb ]==' '{_bgfbg =_bgdgb ;
break ;};};};if _gbbc ._decb {_ebfc :=len (_gedg );if _ebfc > 0{_gedg [_ebfc -1].Text =_gb .TrimRightFunc (_gedg [_ebfc -1].Text ,_ggce );_gbbc ._aeca =append (_gbbc ._aeca ,_gedg );_gedg =[]*TextChunk {};};_edca =append (_edca ,_dcfb );_eagdg =append (_eagdg ,_fgfc );
if _bgfbg >=0{_edca =_edca [_bgfbg +1:];_eagdg =_eagdg [_bgfbg +1:];};_cbdca =0;for _ ,_bfbda :=range _eagdg {_cbdca +=_bfbda ;};if _cbdca > _gdfgf {_dbgc :=string (_edca [:len (_edca )-1]);_dbgc =_ccfb (_dbgc ,_bgge );if !_fgfe &&_acee {_dbgc +="\u0020";
};_gedg =append (_gedg ,&TextChunk {Text :_gb .TrimRightFunc (_dbgc ,_ggce ),Style :_ecde ,_ccbfe :_gbbef (_baba ),VerticalAlignment :_eadae ,_dfcgg :_dfaf ._dfcgg ,_fdaee :_dfaf ._fdaee ,_ccgfa :_dfaf ._ccgfa });if _fffgb :=_gbbc .addLine (_gedg );!_fffgb {return nil ;
};_gedg =[]*TextChunk {};_edca =[]rune {_dcfb };_eagdg =[]float64 {_fgfc };_cbdca =_fgfc ;};continue ;};_bbbc :=string (_edca );if _bgfbg >=0{_bbbc =string (_edca [0:_bgfbg +1]);_edca =_edca [_bgfbg +1:];_edca =append (_edca ,_dcfb );_eagdg =_eagdg [_bgfbg +1:];
_eagdg =append (_eagdg ,_fgfc );_cbdca =0;for _ ,_cbbf :=range _eagdg {_cbdca +=_cbbf ;};}else {if _acee {_cbdca =0;_edca =[]rune {};_eagdg =[]float64 {};}else {_cbdca =_fgfc ;_edca =[]rune {_dcfb };_eagdg =[]float64 {_fgfc };};};_bbbc =_ccfb (_bbbc ,_bgge );
if !_fgfe &&_acee {_bbbc +="\u0020";};_gedg =append (_gedg ,&TextChunk {Text :_gb .TrimRightFunc (_bbbc ,_ggce ),Style :_ecde ,_ccbfe :_gbbef (_baba ),VerticalAlignment :_eadae ,_dfcgg :_dfaf ._dfcgg ,_fdaee :_dfaf ._fdaee ,_ccgfa :_dfaf ._ccgfa });if _egebf :=_gbbc .addLine (_gedg );
!_egebf {return nil ;};_gedg =[]*TextChunk {};}else {_cbdca +=_fgfc ;_edca =append (_edca ,_dcfb );_eagdg =append (_eagdg ,_fgfc );};};if len (_edca )> 0{_cfebg :=_ccfb (string (_edca ),_bgge );_gedg =append (_gedg ,&TextChunk {Text :_cfebg ,Style :_ecde ,_ccbfe :_gbbef (_baba ),VerticalAlignment :_eadae ,_dfcgg :_dfaf ._dfcgg ,_fdaee :_dfaf ._fdaee ,_ccgfa :_dfaf ._ccgfa });
};};if len (_gedg )> 0{if _aafgc :=_gbbc .addLine (_gedg );!_aafgc {return nil ;};};return nil ;};

// SetOpacity sets the cell's opacity in the range 0-1.
func (_cgcf *TableCell )SetOpacity (opacity float64 ){_cgcf ._cgfge =opacity };

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_ddd :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_dc .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ddd ;
};var _cccba ,_eagf ,_egae int ;if len (hexStr )==4{var _gaad ,_gef ,_aedd int ;_abdb ,_abgg :=_a .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_gaad ,&_gef ,&_aedd );if _abgg !=nil {_dc .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_abgg );
return _ddd ;};if _abdb !=3{_dc .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ddd ;};_cccba =_gaad *16+_gaad ;_eagf =_gef *16+_gef ;_egae =_aedd *16+_aedd ;}else {_cdfb ,_gdd :=_a .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_cccba ,&_eagf ,&_egae );
if _gdd !=nil {_dc .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ddd ;};if _cdfb !=3{_dc .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_cdfb );
return _ddd ;};};_beg :=float64 (_cccba )/255.0;_bebf :=float64 (_eagf )/255.0;_bdcc :=float64 (_egae )/255.0;_ddd ._dcf =_beg ;_ddd ._fagc =_bebf ;_ddd ._bac =_bdcc ;return _ddd ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_eeca *FilledCurve )AppendCurve (curve _fg .CubicBezierCurve )*FilledCurve {_eeca ._accf =append (_eeca ._accf ,curve );return _eeca ;};type shading struct{_bcagg Color ;_gecagb bool ;_ggefc []bool ;_gacbe []*ColorPoint ;};

// NewColumn returns a new column for the line items invoice table.
func (_gabcd *Invoice )NewColumn (description string )*InvoiceCell {return _gabcd .newColumn (description ,CellHorizontalAlignmentLeft );};func (_ggaa *Ellipse )applyFitMode (_daedb float64 ){_daedb -=_ggaa ._ebbed .Left +_ggaa ._ebbed .Right ;switch _ggaa ._aeed {case FitModeFillWidth :_ggaa .ScaleToWidth (_daedb );
};};func _fbeac (_ecfbf string )(*_cd .PdfFont ,error ){_dbcc ,_ddga :=map[string ]_cd .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_cd .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_cd .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_cd .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_cd .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_cd .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_cd .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_cd .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_cd .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_cd .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_cd .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_cd .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_cd .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_cd .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_cd .TimesBoldItalicName }[_ecfbf ];
if !_ddga {return nil ,_a .Errorf ("\u0066\u006f\u006e\u0074\u002df\u0061\u006d\u0069\u006c\u0079\u0020\u0025\u0073\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0020\u0066\u006f\u006e\u0074\u0073\u0020\u006c\u0069\u0073t",_ecfbf );
};_gfade ,_edgdf :=_cd .NewStandard14Font (_dbcc );if _edgdf !=nil {return nil ,_edgdf ;};return _gfade ,nil ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_edcd *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_edcd ._gfgc {_dc .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _ga .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_edcd ._fbce =widths ;return nil ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_efcdf *TOC )SetLineSeparator (separator string ){_efcdf ._cbbcf =separator };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_dbfcb *Image )ScaleToWidth (w float64 ){_feda :=_dbfcb ._cbgg /_dbfcb ._gagbb ;_dbfcb ._gagbb =w ;_dbfcb ._cbgg =w *_feda ;};

// SetHeight sets the custom height for the row.
func (_cbca *GridRow )SetHeight (h float64 ){_cbca ._facac =h };

// Horizontal returns total horizontal (left + right) margin.
func (_fbbc *Margins )Horizontal ()float64 {return _fbbc .Left +_fbbc .Right };

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_agde *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _agde ._ccaef [0],_agde ._ccaef [1]};func (_gbcd *Creator )initContext (){_gbcd ._cfce .X =_aac .RoundDefault (_gbcd ._gced .Left );_gbcd ._cfce .Y =_aac .RoundDefault (_gbcd ._gced .Top );
_gbcd ._cfce .Width =_aac .RoundDefault (_gbcd ._gdac -_gbcd ._gced .Right -_gbcd ._gced .Left );_gbcd ._cfce .Height =_aac .RoundDefault (_gbcd ._gdce -_gbcd ._gced .Bottom -_gbcd ._gced .Top );_gbcd ._cfce .PageHeight =_aac .RoundDefault (_gbcd ._gdce );
_gbcd ._cfce .PageWidth =_aac .RoundDefault (_gbcd ._gdac );_gbcd ._cfce .Margins =_gbcd ._gced ;_gbcd ._cfce ._affcb =_gbcd .UnsupportedCharacterReplacement ;};

// AddColorStop add color stop info for rendering gradient color.
func (_gaaff *RadialShading )AddColorStop (color Color ,point float64 ){_gaaff ._aaaed .AddColorStop (color ,point );};

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_aafg *Division )SetMargins (left ,right ,top ,bottom float64 ){_aafg ._bdbe .Left =left ;_aafg ._bdbe .Right =right ;_aafg ._bdbe .Top =top ;_aafg ._bdbe .Bottom =bottom ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_gcbed *StyledParagraph )SetText (text string )*TextChunk {_gcbed .Reset ();return _gcbed .Append (text );};

// GeneratePageBlocks draws the chart onto a block.
func (_fef *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfa :=ctx ;_ecdc :=_fef ._edbd .IsRelative ();var _eegf []*Block ;if _ecdc {_fbeg :=1.0;_fgcg :=_fef ._fdg .Top ;if float64 (_fef ._eegd .Height ())> ctx .Height -_fef ._fdg .Top {_eegf =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _egga error ;if _ ,ctx ,_egga =_bdbb ().GeneratePageBlocks (ctx );_egga !=nil {return nil ,ctx ,_egga ;};_fgcg =0;};ctx .X +=_fef ._fdg .Left +_fbeg ;ctx .Y +=_fgcg ;ctx .Width -=_fef ._fdg .Left +_fef ._fdg .Right +2*_fbeg ;ctx .Height -=_fgcg ;_fef ._eegd .SetWidth (int (ctx .Width ));
}else {ctx .X =_fef ._bbcf ;ctx .Y =_fef ._cfcg ;};_dgd :=_ca .NewContentCreator ();if _fef ._daa !=nil {_dgd .Add_BDC (*_bc .MakeName (_cd .StructureTypeFigure ),map[string ]_bc .PdfObject {"\u004d\u0043\u0049\u0044":_bc .MakeInteger (*_fef ._daa )});
};_dgd .Translate (0,ctx .PageHeight );_dgd .Scale (1,-1);_dgd .Translate (ctx .X ,ctx .Y );_dcg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fef ._eegd .Render (_ec .NewRenderer (_dgd ,_dcg ._bcb ),nil );if _fef ._daa !=nil {_dgd .Add_EMC ();};if _daf :=_dcg .addContentsByString (_dgd .String ());
_daf !=nil {return nil ,ctx ,_daf ;};if _ecdc {_dbg :=_fef .Height ()+_fef ._fdg .Bottom ;ctx .Y +=_dbg ;ctx .Height -=_dbg ;}else {ctx =_cfa ;};_eegf =append (_eegf ,_dcg );return _eegf ,ctx ,nil ;};

// Text sets the text content of the Paragraph.
func (_baec *Paragraph )Text ()string {return _baec ._ceeaa };

// GeneratePageBlocks generates the grid page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_cgbede *Grid )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _efgad []*Block ;_bdcbf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cgbede .updateRowHeights (ctx .Width -_cgbede ._ggbe .Left -_cgbede ._ggbe .Right );_gdfa :=_cgbede ._ggbe .Top ;
_ceba :=ctx ;if _cgbede ._eddd .IsAbsolute (){ctx .X =_cgbede ._aecd ;ctx .Y =_cgbede ._ccacd ;}else {ctx .X +=_cgbede ._ggbe .Left ;ctx .Y +=_gdfa ;ctx .Width -=_cgbede ._ggbe .Left +_cgbede ._ggbe .Right ;ctx .Height -=_gdfa ;};_gdcag :=ctx .Width ;_gaec :=ctx .X ;
_bcbdf :=ctx .Y ;_dgfea :=ctx .Height ;_cdee :=0;_cebg :=false ;for _gcfc :=0;_gcfc < len (_cgbede ._dgaa );_gcfc ++{_badg :=_cgbede ._dgaa [_gcfc ];_ggd :=float64 (0.0);for _faaf :=_cdee ;_faaf < _badg ._gaab ;_faaf ++{_ggd +=_cgbede ._dgaa [_faaf ]._aeec ;
};ctx .Height =_dgfea -_ggd ;if _cebg {_efgad =append (_efgad ,_bdcbf );_bdcbf =NewBlock (ctx .PageWidth ,ctx .PageHeight );_gaec =ctx .Margins .Left +_cgbede ._ggbe .Left ;_bcbdf =ctx .Margins .Top ;ctx .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;
ctx .Page ++;_dgfea =ctx .Height ;_cdee =_gcfc ;_ggd =0;_cebg =false ;};if _badg ._aeec > ctx .Height {_bfef :=_cgbede .cloneRow (_badg ._gaab );_fcgc :=false ;for _dfcbe ,_degff :=range _badg ._ebec {switch _fgbdd :=_degff ._feac .(type ){case *StyledParagraph :_fgad :=ctx ;
_fgad .Height =_fb .Floor (ctx .Height -_fgbdd ._gebac .Top -_fgbdd ._gebac .Bottom -0.5*_fgbdd .getTextHeight ());_dfgd ,_ccdbe ,_dbeb :=_fgbdd .split (_fgad );if _dbeb !=nil {_dc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dbeb );};if _dfgd !=nil &&_ccdbe !=nil &&_bfef !=nil {_degff .SetContent (_dfgd );
_bfef ._ebec [_dfcbe ].SetContent (_ccdbe );_fcgc =true ;};case *Division :_gfef :=ctx ;_gfef .Height =_fb .Floor (ctx .Height -_fgbdd ._bdbe .Top -_fgbdd ._bdbe .Bottom );_aeeba ,_abbc :=_fgbdd .split (_gfef );if _aeeba !=nil &&_abbc !=nil &&_bfef !=nil {_degff .SetContent (_aeeba );
_bfef ._ebec [_dfcbe ].SetContent (_abbc );_fcgc =true ;};case *List :_deecg :=ctx ;_deecg .Height =_fb .Floor (ctx .Height -_fgbdd ._afbf .Vertical ());_cbff ,_acfaf :=_fgbdd .split (_deecg );if _cbff !=nil &&_acfaf !=nil &&_bfef !=nil {_degff .SetContent (_cbff );
_bfef ._ebec [_dfcbe ].SetContent (_acfaf );_fcgc =true ;};};};_cebg =true ;if _fcgc {_cgbede .insertRowAfter (_badg ._gaab ,_bfef );_badg .updateRowHeight (_gdcag );_bfef .updateRowHeight (_gdcag );}else {_gcfc -=1;continue ;};};for _ ,_affa :=range _badg ._ebec {_aacb :=_affa .width (_cgbede ._aagd ,_gdcag );
_fcdb :=float64 (0.0);for _eabb :=0;_eabb < _affa ._degg ;_eabb ++{_fcdb +=_cgbede ._aagd [_eabb ]*_gdcag ;};_cadb :=float64 (0.0);for _dba :=0;_dba < _affa ._adggg ;_dba ++{_cadb +=_cgbede ._dgaa [_affa ._ccaa +_dba ]._aeec ;};ctx .Width =_aacb ;ctx .X =_gaec +_fcdb ;
ctx .Y =_bcbdf +_ggd ;_fafc :=_gacgb (ctx .X ,ctx .Y ,_aacb ,_cadb );if _affa ._gcgc !=nil {_fafc .SetFillColor (_affa ._gcgc );};_fafc .SetOpacity (_affa ._dede );_fafc .LineStyle =_affa ._aabb ;_fafc ._bbc =_affa ._ffbe ;_fafc ._agc =_affa ._agfbe ;_fafc ._dec =_affa ._adeb ;
_fafc ._fage =_affa ._dffc ;if _affa ._cbac !=nil {_fafc .SetColorLeft (_affa ._cbac );};if _affa ._faebf !=nil {_fafc .SetColorBottom (_affa ._faebf );};if _affa ._cdfcb !=nil {_fafc .SetColorRight (_affa ._cdfcb );};if _affa ._ddda !=nil {_fafc .SetColorTop (_affa ._ddda );
};_fafc .SetWidthBottom (_affa ._cgbed );_fafc .SetWidthLeft (_affa ._ccfg );_fafc .SetWidthRight (_affa ._caadb );_fafc .SetWidthTop (_affa ._cbec );_eabd :=_bdcbf .Draw (_fafc );if _eabd !=nil {_dc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_eabd );
};if _affa ._feac !=nil {_bfdc :=_affa ._feac .Width ();_cdbd :=_affa ._feac .Height ();_caea :=0.0;switch _eeed :=_affa ._feac .(type ){case *Paragraph :if _eeed ._aacba {_bfdc =_eeed .getMaxLineWidth ()/1000.0;};_eecac ,_dgca ,_ :=_eeed .getTextMetrics ();
_ebgb ,_aeedc :=_eecac *_eeed ._dbfac ,_dgca *_eeed ._dbfac ;_cdbd =_cdbd -_aeedc +_ebgb ;_caea +=_ebgb -_aeedc ;_ccbde :=0.5;switch _affa ._cfgf {case CellVerticalAlignmentTop :_caea +=_ebgb *_ccbde ;case CellVerticalAlignmentBottom :_caea -=_ebgb *_ccbde ;
};_bfdc +=_eeed ._cafc .Left +_eeed ._cafc .Right ;_cdbd +=_eeed ._cafc .Top +_eeed ._cafc .Bottom ;case *StyledParagraph :if _eeed ._ccbe {_bfdc =_eeed .getMaxLineWidth ()/1000.0;};_ecgb ,_efgbc ,_dcec :=_eeed .getLineMetrics (0);_cfab ,_gffcea :=_ecgb *_eeed ._gdaeca ,_efgbc *_eeed ._gdaeca ;
if _eeed ._dadf ==TextVerticalAlignmentCenter {_caea =_gffcea -(_efgbc +(_ecgb +_dcec -_efgbc )/2+(_gffcea -_efgbc )/2);};if len (_eeed ._aeca )==1{_cdbd =_cfab ;}else {_cdbd =_cdbd -_gffcea +_cfab ;};_caea +=_cfab -_gffcea ;switch _affa ._cfgf {case CellVerticalAlignmentTop :_caea +=_cfab *0.5;
case CellVerticalAlignmentBottom :_caea -=_cfab *0.5;};_bfdc +=_eeed ._gebac .Left +_eeed ._gebac .Right ;_cdbd +=_eeed ._gebac .Top +_eeed ._gebac .Bottom ;case *Table :_bfdc =_aacb ;case *List :_bfdc =_aacb ;case *Division :_bfdc =_aacb ;case *Chart :_bfdc =_aacb ;
case *Line :_cdbd +=_eeed ._adbf .Top +_eeed ._adbf .Bottom ;_caea -=_eeed .Height ()/2;case *Image :_bfdc +=_eeed ._fega .Left +_eeed ._fega .Right ;_cdbd +=_eeed ._fega .Top +_eeed ._fega .Bottom ;};switch _affa ._edbg {case CellHorizontalAlignmentLeft :ctx .X +=_affa ._cbfg ;
ctx .Width -=_affa ._cbfg ;case CellHorizontalAlignmentCenter :if _cccbe :=_aacb -_bfdc ;_cccbe > 0{ctx .X +=_cccbe /2;ctx .Width -=_cccbe /2;};case CellHorizontalAlignmentRight :if _aacb > _bfdc {ctx .X =ctx .X +_aacb -_bfdc -_affa ._cbfg ;ctx .Width -=_affa ._cbfg ;
};};_cabb :=ctx .Y ;_eegga :=ctx .Height ;ctx .Y +=_caea ;switch _affa ._cfgf {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _baage :=_cadb -_cdbd ;_baage > 0{ctx .Y +=_baage /2;ctx .Height -=_baage /2;};case CellVerticalAlignmentBottom :if _cadb > _cdbd {ctx .Y =ctx .Y +_cadb -_cdbd ;
ctx .Height =_cadb ;};};_feagf :=_bdcbf .DrawWithContext (_affa ._feac ,ctx );if _feagf !=nil {_dc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_feagf );};ctx .Y =_cabb ;ctx .Height =_eegga ;};};ctx .Y +=_badg ._aeec ;};_efgad =append (_efgad ,_bdcbf );
if _cgbede ._eddd .IsAbsolute (){return _efgad ,_ceba ,nil ;};ctx .X =_ceba .X ;ctx .Width =_ceba .Width ;ctx .Y +=_cgbede ._ggbe .Bottom ;ctx .Height -=_cgbede ._ggbe .Bottom ;return _efgad ,ctx ,nil ;};

// SetViewerPreferences sets the viewer preferences for the PDF document.
func (_fda *Creator )SetViewerPreferences (viewerPreferences *_cd .ViewerPreferences ){_fda ._cgg =viewerPreferences ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_fbac *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_eabec []*Block ;_cfgff =NewBlock (ctx .PageWidth ,ctx .PageHeight );_eaead =ctx ;_aeac =_fbac ._dedg /2;);_geceb :=_fbac ._dgcaf .IsRelative ();if _geceb {_fbac .applyFitMode (ctx .Width );
ctx .X +=_fbac ._egecg .Left +_aeac ;ctx .Y +=_fbac ._egecg .Top +_aeac ;ctx .Width -=_fbac ._egecg .Left +_fbac ._egecg .Right ;ctx .Height -=_fbac ._egecg .Top +_fbac ._egecg .Bottom ;if _fbac ._dbab > ctx .Height {_eabec =append (_eabec ,_cfgff );_cfgff =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_eefc :=ctx ;_eefc .Y =ctx .Margins .Top +_fbac ._egecg .Top +_aeac ;_eefc .X =ctx .Margins .Left +_fbac ._egecg .Left +_aeac ;_eefc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_fbac ._egecg .Top -_fbac ._egecg .Bottom ;
_eefc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_fbac ._egecg .Left -_fbac ._egecg .Right ;ctx =_eefc ;};}else {ctx .X =_fbac ._aaabb ;ctx .Y =_fbac ._adebb ;};_gbdce :=_fg .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_fbac ._dbab ,Width :_fbac ._dcdaf ,Height :_fbac ._dbab ,BorderRadiusTopLeft :_fbac ._fegba ,BorderRadiusTopRight :_fbac ._gaabc ,BorderRadiusBottomLeft :_fbac ._fdccg ,BorderRadiusBottomRight :_fbac ._ccgf ,Opacity :1.0};
if _fbac ._cgfc !=nil {_gbdce .FillEnabled =true ;_ddaaf :=_dfd (_fbac ._cgfc );_adgdg :=_daeg (_cfgff ,_ddaaf ,_fbac ._cgfc ,func ()Rectangle {return Rectangle {_aaabb :_gbdce .X ,_adebb :_gbdce .Y ,_dcdaf :_gbdce .Width ,_dbab :_gbdce .Height };});if _adgdg !=nil {return nil ,ctx ,_adgdg ;
};_gbdce .FillColor =_ddaaf ;};if _fbac ._gccag !=nil &&_fbac ._dedg > 0{_gbdce .BorderEnabled =true ;_gbdce .BorderColor =_dfd (_fbac ._gccag );_gbdce .BorderWidth =_fbac ._dedg ;};_caefb ,_affce :=_cfgff .setOpacity (_fbac ._ddeaec ,_fbac ._gafg );if _affce !=nil {return nil ,ctx ,_affce ;
};_edgg ,_ ,_affce :=_gbdce .MarkedDraw (_caefb ,_fbac ._gfdac );if _affce !=nil {return nil ,ctx ,_affce ;};if _affce =_cfgff .addContentsByString (string (_edgg ));_affce !=nil {return nil ,ctx ,_affce ;};if _geceb {ctx .X =_eaead .X ;ctx .Width =_eaead .Width ;
_cdbab :=_fbac ._dbab +_aeac ;ctx .Y +=_cdbab +_fbac ._egecg .Bottom ;ctx .Height -=_cdbab ;}else {ctx =_eaead ;};_eabec =append (_eabec ,_cfgff );return _eabec ,ctx ,nil ;};

// FitMode returns the fit mode of the rectangle.
func (_bdgf *Rectangle )FitMode ()FitMode {return _bdgf ._agabc };func _dedfb (_dbge map[string ]interface{},_edfg ...interface{})(map[string ]interface{},error ){_dggbff :=len (_edfg );if _dggbff %2!=0{return nil ,_bc .ErrRangeError ;};for _ebea :=0;_ebea < _dggbff ;
_ebea +=2{_ecegaf ,_faba :=_edfg [_ebea ].(string );if !_faba {return nil ,_bc .ErrTypeError ;};_dbge [_ecegaf ]=_edfg [_ebea +1];};return _dbge ,nil ;};

// SetLineWidth sets the line width.
func (_bgcae *Polyline )SetLineWidth (lineWidth float64 ){_bgcae ._bfde .LineWidth =lineWidth };func _dac ()*FilledCurve {_caaa :=FilledCurve {};_caaa ._accf =[]_fg .CubicBezierCurve {};return &_caaa ;};

// SetStructTreeRoot sets the structure tree root to be appended in the document that will be created.
func (_acde *Creator )SetStructTreeRoot (structTreeRoot *_cd .StructTreeRoot ){_acde ._fada =structTreeRoot ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_caca *TOCLine )LevelOffset ()float64 {return _caca ._fcegc };

// DrawWithContext draws the Block using the specified drawing context.
func (_gbf *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_cee ,_ ,_edbf :=d .GeneratePageBlocks (ctx );if _edbf !=nil {return _edbf ;};if len (_cee )!=1{return ErrContentNotFit ;};for _ ,_ef :=range _cee {if _dfg :=_gbf .mergeBlocks (_ef );
_dfg !=nil {return _dfg ;};};return nil ;};

// SetBorderColor sets the cell's border color.
func (_bgdd *GridCell )SetBorderColor (col Color ){_bgdd ._cbac =col ;_bgdd ._faebf =col ;_bgdd ._cdfcb =col ;_bgdd ._ddda =col ;};

// SetActualText sets the actual text for the text chunk.
func (_baacc *TextChunk )SetActualText (text string ){_baacc ._ccgfa =&text };

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_ccfa *Paragraph )SetMaxLines (maxLines int ){_ccfa ._bageg =maxLines ;_ccfa .wrapText ()};

// Lines returns all the lines the table of contents has.
func (_bcabgb *TOC )Lines ()[]*TOCLine {return _bcabgb ._fdad };

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//
//	red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_dcf :float64 (r )/255.0,_fagc :float64 (g )/255.0,_bac :float64 (b )/255.0};};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_bedf *Ellipse )SetPositioning (position Positioning ){_bedf ._cddb =position };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_gcbb *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_egfac :=range subtable ._bbdb {_cffgb :=&TableCell {};*_cffgb =*_egfac ;_cffgb ._dgfeac =_gcbb ;_cffgb ._gdgcb +=col -1;if _deeee :=_gcbb ._gfgc -(_cffgb ._gdgcb -1);_deeee < _cffgb ._abfbd {_gcbb ._gfgc +=_cffgb ._abfbd -_deeee ;
_gcbb .resetColumnWidths ();_dc .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_gcbb ._gfgc );
};_cffgb ._badcc +=row -1;_daagg :=subtable ._cbaab [_egfac ._badcc -1];if _cffgb ._badcc > _gcbb ._agga {for _cffgb ._badcc > _gcbb ._agga {_gcbb ._agga ++;_gcbb ._cbaab =append (_gcbb ._cbaab ,_gcbb ._cdgee );};_gcbb ._cbaab [_cffgb ._badcc -1]=_daagg ;
}else {_gcbb ._cbaab [_cffgb ._badcc -1]=_fb .Max (_gcbb ._cbaab [_cffgb ._badcc -1],_daagg );};_gcbb ._bbdb =append (_gcbb ._bbdb ,_cffgb );};_gcbb .sortCells ();};

// Padding returns the padding of the component.
func (_eaea *Division )Padding ()(_acdeg ,_bcdgf ,_ccf ,_abea float64 ){return _eaea ._egfg .Left ,_eaea ._egfg .Right ,_eaea ._egfg .Top ,_eaea ._egfg .Bottom ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_bgd *Block )DrawTemplate (c *Creator ,r _ea .Reader ,data interface{},options *TemplateOptions )error {return _acdb (c ,r ,data ,options ,_bgd );};func _cgbeg (_geede string )([]float64 ,error ){_afdbd :=-1;var _eebgg []float64 ;_daegd :=' ';for _eddeb ,_bccdb :=range _geede {if !_f .IsNumber (_bccdb )&&_bccdb !='.'&&!(_bccdb =='-'&&_daegd =='e')&&_bccdb !='e'{if _afdbd !=-1{_eggaa ,_abcdb :=_febae (_geede [_afdbd :_eddeb ]);
if _abcdb !=nil {return _eebgg ,_abcdb ;};_eebgg =append (_eebgg ,_eggaa ...);};if _bccdb =='-'{_afdbd =_eddeb ;}else {_afdbd =-1;};}else if _afdbd ==-1{_afdbd =_eddeb ;};_daegd =_bccdb ;};if _afdbd !=-1&&_afdbd !=len (_geede ){_fceee ,_gbfd :=_febae (_geede [_afdbd :]);
if _gbfd !=nil {return _eebgg ,_gbfd ;};_eebgg =append (_eebgg ,_fceee ...);};return _eebgg ,nil ;};var _ecbf commands ;func _caed (_dgccbd *templateProcessor ,_bfge *templateNode )(interface{},error ){return _dgccbd .parseChapterHeading (_bfge );};

// SetIndent sets the cell's left indent.
func (_gafbb *GridCell )SetIndent (indent float64 ){_gafbb ._cbfg =indent };func (_dbcdf *Line )computeCoords (_dccfc DrawContext )(_accg ,_ccfc ,_dbcdc ,_gdaea float64 ){_accg =_dccfc .X ;_dbcdc =_accg +_dbcdf ._fgeg -_dbcdf ._cdfa ;_dfdg :=_dbcdf ._beaa ;
if _dbcdf ._cdfa ==_dbcdf ._fgeg {_dfdg /=2;};if _dbcdf ._eadda < _dbcdf ._becde {_ccfc =_dccfc .PageHeight -_dccfc .Y -_dfdg ;_gdaea =_ccfc -_dbcdf ._becde +_dbcdf ._eadda ;}else {_gdaea =_dccfc .PageHeight -_dccfc .Y -_dfdg ;_ccfc =_gdaea -_dbcdf ._eadda +_dbcdf ._becde ;
};switch _dbcdf ._bffef {case FitModeFillWidth :_dbcdc =_accg +_dccfc .Width ;};return _accg ,_ccfc ,_dbcdc ,_gdaea ;};

// Height returns the Block's height.
func (_dag *Block )Height ()float64 {return _dag ._dff };

// NewDivision returns a new Division container component.
func (_aefb *Creator )NewDivision ()*Division {return _acdf ()};func (_beab *Invoice )generateLineBlocks (_aaad DrawContext )([]*Block ,DrawContext ,error ){_eacgf :=_bbab (len (_beab ._ebafb ));_eacgf .SetMargins (0,0,25,0);for _ ,_debcg :=range _beab ._ebafb {_gdgbf :=_eeff (_debcg .TextStyle );
_gdgbf .SetMargins (0,0,1,0);_gdgbf .Append (_debcg .Value );_gfce :=_eacgf .NewCell ();_gfce .SetHorizontalAlignment (_debcg .Alignment );_gfce .SetBackgroundColor (_debcg .BackgroundColor );_beab .setCellBorder (_gfce ,_debcg );_gfce .SetContent (_gdgbf );
};for _ ,_ebgbg :=range _beab ._adcac {for _ ,_dcfe :=range _ebgbg {_dfcfc :=_eeff (_dcfe .TextStyle );_dfcfc .SetMargins (0,0,3,2);_dfcfc .Append (_dcfe .Value );_eega :=_eacgf .NewCell ();_eega .SetHorizontalAlignment (_dcfe .Alignment );_eega .SetBackgroundColor (_dcfe .BackgroundColor );
_beab .setCellBorder (_eega ,_dcfe );_eega .SetContent (_dfcfc );};};return _eacgf .GeneratePageBlocks (_aaad );};

// SetBorderWidth sets the border width.
func (_edba *CurvePolygon )SetBorderWidth (borderWidth float64 ){_edba ._fceg .BorderWidth =borderWidth };

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_agga int ;_gfgc int ;_degcf int ;_fbce []float64 ;_cbaab []float64 ;_cdgee float64 ;_bbdb []*TableCell ;_degb []int ;_dgfgd Positioning ;_geacc ,_facedb float64 ;_gbdab Margins ;_aagga bool ;_bfbdae int ;_gedae int ;_ccgc bool ;_bdbea bool ;
_abddd bool ;};

// SkipRows skips over a specified number of rows in the table.
func (_cgaba *Table )SkipRows (num int ){_bfeffc :=num *_cgaba ._gfgc -1;if _bfeffc < 0{_dc .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _agfef :=0;_agfef < _bfeffc ;_agfef ++{_cgaba .NewCell ();};};func _cgee (_cgcgg ,_ebdg ,_abdg ,_fdead float64 )*Line {return &Line {_cdfa :_cgcgg ,_eadda :_ebdg ,_fgeg :_abdg ,_becde :_fdead ,_baad :ColorBlack ,_gfde :1.0,_beaa :1.0,_eebd :[]int64 {1,1},_dcac :PositionAbsolute };
};func (_fcbc *StyledParagraph )appendChunk (_ddbb *TextChunk )*TextChunk {_fcbc ._gceca =append (_fcbc ._gceca ,_ddbb );_fcbc .wrapText ();return _ddbb ;};

// SetCompactMode sets the compact mode flag for this table.
//
// By enabling compact mode, table cell that contains Paragraph/StyleParagraph
// would not add extra height when calculating it's height.
//
// The default value is false.
func (_aefc *Table )SetCompactMode (enable bool ){_aefc ._abddd =enable };type templateTag struct{_abbdg map[string ]struct{};_bedde func (*templateProcessor ,*templateNode )(interface{},error );};func (_gbbec *TableCell )cloneProps (_bfdb VectorDrawable )*TableCell {_cgafd :=*_gbbec ;
_cgafd ._fagd =_bfdb ;return &_cgafd ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_gdacf *StyledParagraph )SetWidth (width float64 ){_gdacf ._gabb =width ;_gdacf .wrapText ()};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_beb *Block )ScaleToWidth (w float64 ){_dca :=w /_beb ._cef ;_beb .Scale (_dca ,_dca )};

// CurCol returns the currently active cell's column number.
func (_dfbbd *Table )CurCol ()int {_bgff :=(_dfbbd ._degcf -1)%(_dfbbd ._gfgc )+1;return _bgff };

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_cdac Color ;_cdaac float64 ;};

// NewList creates a new list.
func (_fbee *Creator )NewList ()*List {return _bagc (_fbee .NewTextStyle ())};func (_ecgg *Invoice )generateNoteBlocks (_abab DrawContext )([]*Block ,DrawContext ,error ){_gegcc :=_acdf ();_agcd :=append ([][2]string {_ecgg ._efec ,_ecgg ._agagf },_ecgg ._edad ...);
for _ ,_gecf :=range _agcd {if _gecf [1]!=""{_cdcfa :=_ecgg .drawSection (_gecf [0],_gecf [1]);for _ ,_eeaec :=range _cdcfa {_gegcc .Add (_eeaec );};_begc :=_eeff (_ecgg ._fdeaf );_begc .SetMargins (0,0,10,0);_gegcc .Add (_begc );};};return _gegcc .GeneratePageBlocks (_abab );
};

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_addg *GraphicSVG )SetPos (x ,y float64 ){_addg ._bffac =PositionAbsolute ;_addg ._gdbe =x ;_addg ._abcd =y ;};func (_bedc *Paragraph )getTextLineWidth (_ccea string )float64 {var _adgf float64 ;for _ ,_egdd :=range _ccea {if _egdd =='\u000A'{continue ;
};_fddcg ,_eagba :=_bedc ._fgef .GetRuneMetrics (_egdd );if !_eagba {_dc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_egdd ,_egdd );
return -1;};_adgf +=_bedc ._ebab *_fddcg .Wx ;};return _adgf ;};func (_fdgc *Paragraph )getTextWidth ()float64 {_gffccg :=0.0;for _ ,_gacd :=range _fdgc ._ceeaa {if _gacd =='\u000A'{continue ;};_dbed ,_bbcfc :=_fdgc ._fgef .GetRuneMetrics (_gacd );if !_bbcfc {_dc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_gacd ,_gacd );
return -1;};_gffccg +=_fdgc ._ebab *_dbed .Wx ;};return _gffccg ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;func _afea (_fcge int64 ,_adcag ,_fffb ,_efed float64 )*_cd .PdfAnnotation {_dafb :=_cd .NewPdfAnnotationLink ();_bcgdf :=_cd .NewBorderStyle ();_bcgdf .SetBorderWidth (0);_dafb .BS =_bcgdf .ToPdfObject ();if _fcge < 0{_fcge =0;
};_dafb .Dest =_bc .MakeArray (_bc .MakeInteger (_fcge ),_bc .MakeName ("\u0058\u0059\u005a"),_bc .MakeFloat (_adcag ),_bc .MakeFloat (_fffb ),_bc .MakeFloat (_efed ));return _dafb .PdfAnnotation ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;
CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_cdef *Invoice )SetAddressHeadingStyle (style TextStyle ){_cdef ._cefda =style };func (_ffebf *templateProcessor )parseHorizontalAlignmentAttr (_dgdda ,_aebcc string )HorizontalAlignment {_dc .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_dgdda ,_aebcc );
_dabac :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_aebcc ];return _dabac ;};func (_aedde *shading )generatePdfFunctions ()[]_cd .PdfFunction {if len (_aedde ._gacbe )==0{return nil ;
}else if len (_aedde ._gacbe )<=2{_ffdbc ,_gafda ,_bggd :=_aedde ._gacbe [0]._cdac .ToRGB ();_gbcdd ,_aabdg ,_gcdbg :=_aedde ._gacbe [len (_aedde ._gacbe )-1]._cdac .ToRGB ();return []_cd .PdfFunction {&_cd .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_ffdbc ,_gafda ,_bggd },C1 :[]float64 {_gbcdd ,_aabdg ,_gcdbg }}};
}else {_ddfge :=[]_cd .PdfFunction {};_gecef :=[]float64 {};for _eaec :=0;_eaec < len (_aedde ._gacbe )-1;_eaec ++{_ebefa ,_fffgd ,_bbd :=_aedde ._gacbe [_eaec ]._cdac .ToRGB ();_gagef ,_bdfb ,_eggae :=_aedde ._gacbe [_eaec +1]._cdac .ToRGB ();_eced :=&_cd .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_ebefa ,_fffgd ,_bbd },C1 :[]float64 {_gagef ,_bdfb ,_eggae }};
_ddfge =append (_ddfge ,_eced );if _eaec > 0{_gecef =append (_gecef ,_aedde ._gacbe [_eaec ]._cdaac );};};_cedab :=[]float64 {};for range _ddfge {_cedab =append (_cedab ,[]float64 {0.0,1.0}...);};return []_cd .PdfFunction {&_cd .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_ddfge ,Bounds :_gecef ,Encode :_cedab }};
};};

// GetOptimizer returns current PDF optimizer.
func (_cabf *Creator )GetOptimizer ()_cd .Optimizer {return _cabf ._fecff };var PPMM =float64 (72*1.0/25.4);

// SetMarkedContentID sets the marked content id for the chart.
func (_bggb *Chart )SetMarkedContentID (mcid int64 )*_cd .KDict {_bggb ._daa =&mcid ;_fbdb :=_cd .NewKDictionary ();_fbdb .S =_bc .MakeName (_cd .StructureTypeFigure );_fbdb .K =_bc .MakeInteger (mcid );return _fbdb ;};func _acdb (_gbgaf *Creator ,_fbacbg _ea .Reader ,_dfdcb interface{},_gbccc *TemplateOptions ,_ccgac componentRenderer )error {if _gbgaf ==nil {_dc .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _egfcf ;};_eagge :="";if _cbabg ,_addcc :=_fbacbg .(*_be .File );_addcc {_eagge =_cbabg .Name ();};_abdga :=_gc .NewBuffer (nil );if _ ,_eebfbg :=_ea .Copy (_abdga ,_fbacbg );_eebfbg !=nil {return _eebfbg ;};_bgfdd :=_aa .FuncMap {"\u0064\u0069\u0063\u0074":_edaeca ,"\u0061\u0064\u0064":_afacf ,"\u0061\u0072\u0072a\u0079":_febc ,"\u0065\u0078\u0074\u0065\u006e\u0064\u0044\u0069\u0063\u0074":_dedfb ,"\u006da\u006b\u0065\u0053\u0065\u0071":_ccggf };
if _gbccc !=nil &&_gbccc .HelperFuncMap !=nil {for _egbec ,_eeecg :=range _gbccc .HelperFuncMap {if _ ,_aaefb :=_bgfdd [_egbec ];_aaefb {_dc .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_egbec );
continue ;};_bgfdd [_egbec ]=_eeecg ;};};_acabf ,_cbbcb :=_aa .New ("").Funcs (_bgfdd ).Parse (_abdga .String ());if _cbbcb !=nil {return _cbbcb ;};if _gbccc !=nil &&_gbccc .SubtemplateMap !=nil {for _fecg ,_bagcd :=range _gbccc .SubtemplateMap {if _fecg ==""{_dc .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _bagcd ==nil {_dc .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_adac :=_gc .NewBuffer (nil );if _ ,_gacdf :=_ea .Copy (_adac ,_bagcd );_gacdf !=nil {return _gacdf ;};if _ ,_aagbg :=_acabf .New (_fecg ).Parse (_adac .String ());_aagbg !=nil {return _aagbg ;};};};_abdga .Reset ();if _bbbdde :=_acabf .Execute (_abdga ,_dfdcb );
_bbbdde !=nil {return _bbbdde ;};return _ggec (_gbgaf ,_eagge ,_abdga .Bytes (),_gbccc ,_ccgac ).run ();};

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_cgeb *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_acgg []*Block ;_fdedb =NewBlock (ctx .PageWidth ,ctx .PageHeight );_bbgdf =ctx ;_aeag ,_bfdcd =_cgeb ._cdfa ,ctx .PageHeight -_cgeb ._eadda ;_cgbcc ,_fbgb =_cgeb ._fgeg ,ctx .PageHeight -_cgeb ._becde ;
);_faeg :=_cgeb ._dcac .IsRelative ();if _faeg {ctx .X +=_cgeb ._adbf .Left ;ctx .Y +=_cgeb ._adbf .Top ;ctx .Width -=_cgeb ._adbf .Left +_cgeb ._adbf .Right ;ctx .Height -=_cgeb ._adbf .Top +_cgeb ._adbf .Bottom ;_aeag ,_bfdcd ,_cgbcc ,_fbgb =_cgeb .computeCoords (ctx );
if _cgeb .Height ()> ctx .Height {_acgg =append (_acgg ,_fdedb );_fdedb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_bcba :=ctx ;_bcba .Y =ctx .Margins .Top +_cgeb ._adbf .Top ;_bcba .X =ctx .Margins .Left +_cgeb ._adbf .Left ;_bcba .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_cgeb ._adbf .Top -_cgeb ._adbf .Bottom ;
_bcba .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cgeb ._adbf .Left -_cgeb ._adbf .Right ;ctx =_bcba ;_aeag ,_bfdcd ,_cgbcc ,_fbgb =_cgeb .computeCoords (ctx );};};_gcfcc :=_fg .BasicLine {X1 :_aeag ,Y1 :_bfdcd ,X2 :_cgbcc ,Y2 :_fbgb ,LineColor :_dfd (_cgeb ._baad ),Opacity :_cgeb ._gfde ,LineWidth :_cgeb ._beaa ,LineStyle :_cgeb ._ggabf ,DashArray :_cgeb ._eebd ,DashPhase :_cgeb ._agcc };
_gacec ,_dadg :=_fdedb .setOpacity (1.0,_cgeb ._gfde );if _dadg !=nil {return nil ,ctx ,_dadg ;};_aace ,_ ,_dadg :=_gcfcc .MarkedDraw (_gacec ,_cgeb ._ecdga );if _dadg !=nil {return nil ,ctx ,_dadg ;};if _dadg =_fdedb .addContentsByString (string (_aace ));
_dadg !=nil {return nil ,ctx ,_dadg ;};if _faeg {ctx .X =_bbgdf .X ;ctx .Width =_bbgdf .Width ;_ebeca :=_cgeb .Height ();ctx .Y +=_ebeca +_cgeb ._adbf .Bottom ;ctx .Height -=_ebeca ;}else {ctx =_bbgdf ;};_acgg =append (_acgg ,_fdedb );return _acgg ,ctx ,nil ;
};

// TextAlignment options for paragraph.
type TextAlignment int ;func (_ceea *Image )applyFitMode (_eaa float64 ){_eaa -=_ceea ._fega .Left +_ceea ._fega .Right ;switch _ceea ._eeba {case FitModeFillWidth :_ceea .ScaleToWidth (_eaa );};};

// SetLevel sets the indentation level of the TOC line.
func (_bccfc *TOCLine )SetLevel (level uint ){_bccfc ._bedfe =level ;_bccfc ._bebag ._gebac .Left =_bccfc ._gecda +float64 (_bccfc ._bedfe -1)*_bccfc ._fcegc ;};func _bfcec (_aadc *_cd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_aadc ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_edfa *Creator )Draw (d Drawable )error {if _edfa .getActivePage ()==nil {_edfa .NewPage ();};_bdcb ,_ggac ,_dfebf :=d .GeneratePageBlocks (_edfa ._cfce );if _dfebf !=nil {return _dfebf ;};if len (_ggac ._caab )> 0{_edfa .Errors =append (_edfa .Errors ,_ggac ._caab ...);
};for _bdae ,_gecb :=range _bdcb {if _bdae > 0{_edfa .NewPage ();};_gfae :=_edfa .getActivePage ();if _cdg ,_bfcd :=_edfa ._bedd [_gfae ];_bfcd {if _cecg :=_cdg .mergeBlocks (_gecb );_cecg !=nil {return _cecg ;};if _dcab :=_fgb (_gecb ._bcb ,_cdg ._bcb );
_dcab !=nil {return _dcab ;};}else {_edfa ._bedd [_gfae ]=_gecb ;};};_edfa ._cfce .X =_ggac .X ;_edfa ._cfce .Y =_ggac .Y ;_edfa ._cfce .Height =_aac .RoundDefault (_ggac .PageHeight -_ggac .Y -_ggac .Margins .Bottom );return nil ;};