//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
package creator ;import (_cc "bytes";_cd "encoding/xml";_ff "errors";_d "fmt";_ab "github.com/gorilla/i18n/linebreak";_eb "github.com/unidoc/unichart/render";_gg "github.com/unidoc/unipdf/v4/common";_ae "github.com/unidoc/unipdf/v4/contentstream";_gga "github.com/unidoc/unipdf/v4/contentstream/draw";
_fac "github.com/unidoc/unipdf/v4/core";_cae "github.com/unidoc/unipdf/v4/internal/graphic2d";_cab "github.com/unidoc/unipdf/v4/internal/integrations/unichart";_af "github.com/unidoc/unipdf/v4/internal/license";_aa "github.com/unidoc/unipdf/v4/internal/precision";
_gb "github.com/unidoc/unipdf/v4/internal/transform";_cb "github.com/unidoc/unipdf/v4/model";_ba "golang.org/x/net/html/charset";_ca "golang.org/x/text/unicode/bidi";_g "image";_ad "io";_ee "log";_a "math";_b "os";_c "path/filepath";_gd "regexp";_ec "sort";
_fa "strconv";_bd "strings";_fb "text/template";_eef "unicode";_f "unicode/utf8";);

// SetTerms sets the terms and conditions section of the invoice.
func (_ebdd *Invoice )SetTerms (title ,content string ){_ebdd ._gefef =[2]string {title ,content }};func (_dddc *GraphicSVGElement )parseColorPoints ()[]*ColorPoint {var _ceff []*ColorPoint ;var _fgde error ;for _ ,_def :=range _dddc .Children {if _def .Name =="\u0073\u0074\u006f\u0070"{_bbfeaf :=ColorBlack ;
_agaa :=0.0;for _bdgd ,_cbfa :=range _def .Attributes {if _bdgd =="\u006f\u0066\u0066\u0073\u0065\u0074"{if _bd .HasSuffix (_cbfa ,"\u0025"){_daadf ,_bede :=_fa .ParseFloat (_bd .TrimSuffix (_cbfa ,"\u0025"),64);if _bede !=nil {continue ;};_agaa =_daadf /100;
}else {_agaa ,_fgde =_fa .ParseFloat (_cbfa ,64);if _fgde !=nil {continue ;};};}else if _bdgd =="\u0073\u0074\u006f\u0070\u002d\u0063\u006f\u006c\u006f\u0072"{if _cbfa [0]=='#'{_bbfeaf =ColorRGBFromHex (_cbfa );}else {_ddbc ,_eddd :=_cae .ColorMap [_cbfa ];
if _eddd {_bbfeaf =ColorRGBFrom8bit (_ddbc .R ,_ddbc .G ,_ddbc .B );};};};};_ceff =append (_ceff ,NewColorPoint (_bbfeaf ,_agaa ));};};return _ceff ;};func _bbbe ()*PageBreak {return &PageBreak {}};func _dacg (_dcfggf string )(float64 ,error ){_dcfggf =_bd .TrimSpace (_dcfggf );
var _egff float64 ;if _bd .HasSuffix (_dcfggf ,"\u0025"){_gfgce ,_dcga :=_fa .ParseFloat (_bd .TrimSuffix (_dcfggf ,"\u0025"),64);if _dcga !=nil {return 0,_dcga ;};_egff =_gfgce /100.0;}else {_adcbca ,_fcfge :=_fa .ParseFloat (_dcfggf ,64);if _fcfge !=nil {return 0,_fcfge ;
};_egff =_adcbca ;};return _egff ,nil ;};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_eadf *Invoice )SetAddressStyle (style TextStyle ){_eadf ._adeb =style };func _dbe (_bcf string ,_bab _fac .PdfObject ,_eagc *_cb .PdfPageResources )_fac .PdfObjectName {_geg :=_bd .TrimRightFunc (_bd .TrimSpace (_bcf ),func (_efa rune )bool {return _eef .IsNumber (_efa )});
if _geg ==""{_geg ="\u0046\u006f\u006e\u0074";};_adfd :=0;_bfb :=_fac .PdfObjectName (_bcf );for {_bcff ,_gff :=_eagc .GetFontByName (_bfb );if !_gff ||_bcff ==_bab {break ;};_adfd ++;_bfb =_fac .PdfObjectName (_d .Sprintf ("\u0025\u0073\u0025\u0064",_geg ,_adfd ));
};return _bfb ;};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// Width returns the width of the Paragraph.
func (_acac *StyledParagraph )Width ()float64 {if _acac ._cbcg &&int (_acac ._fgdfg )> 0{return _acac ._fgdfg ;};return _acac .getTextWidth ()/1000.0;};

// Width returns the width of the ellipse.
func (_afda *Ellipse )Width ()float64 {return _afda ._gdfc };func (_bdcca *templateProcessor )parseFloatArray (_abbcc ,_bcbdg string )[]float64 {_gg .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_abbcc ,_bcbdg );
_bcaad :=_bd .Fields (_bcbdg );_aabdd :=make ([]float64 ,0,len (_bcaad ));for _ ,_cdbdg :=range _bcaad {_ebgbd ,_ :=_fa .ParseFloat (_cdbdg ,64);_aabdd =append (_aabdd ,_ebgbd );};return _aabdd ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_cccg float64 ;_dgdb float64 ;_cfeb float64 ;_fbfg float64 ;_feec float64 ;_dgdbc float64 ;_agb Color ;_aff float64 ;_bafg *int64 ;};func (_fegee *TableCell )width (_acefcf []float64 ,_abbfb float64 )float64 {_gebgcc :=float64 (0.0);for _agad :=0;
_agad < _fegee ._gbbga ;_agad ++{_gebgcc +=_acefcf [_fegee ._bgage +_agad -1];};return _gebgcc *_abbfb ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_edbd *Creator )NewImage (img *_cb .Image )(*Image ,error ){return _bff (img )};func _acbbf (_degf *_cb .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_degf ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};func _bff (_fcg *_cb .Image )(*Image ,error ){_fffgc :=float64 (_fcg .Width );_acdg :=float64 (_fcg .Height );return &Image {_bgeac :_fcg ,_ddcae :_fffgc ,_decbc :_acdg ,_efca :_fffgc ,_efag :_acdg ,_gegeb :0,_gdefg :1.0,_cecd :PositionRelative },nil ;
};func _cdced ()*listItem {return &listItem {}};

// SetStyleLeft sets border style for left side.
func (_ecaa *border )SetStyleLeft (style CellBorderStyle ){_ecaa ._gdg =style };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_agabb *Creator )MoveRight (dx float64 ){_agabb ._fdec .X +=dx };func _ceg (_dgd ,_ebfa *_cb .PdfPageResources )error {_aeca ,_ :=_dgd .GetColorspaces ();if _aeca !=nil &&len (_aeca .Colorspaces )> 0{for _baf ,_cca :=range _aeca .Colorspaces {_cdd :=*_fac .MakeName (_baf );
if _ebfa .HasColorspaceByName (_cdd ){continue ;};_bcca :=_ebfa .SetColorspaceByName (_cdd ,_cca );if _bcca !=nil {return _bcca ;};};};return nil ;};func (_fagda *StyledParagraph )getTextLineWidth (_dgfgc []*TextChunk )float64 {var _gdgfe float64 ;_cegfd :=len (_dgfgc );
for _bcgdb ,_begdb :=range _dgfgc {_dffb :=&_begdb .Style ;_gcgac :=len (_begdb .Text );for _bcac ,_agfe :=range _begdb .Text {if _agfe =='\u000A'{continue ;};_bage ,_cdbd :=_dffb .Font .GetRuneMetrics (_agfe );if !_cdbd {_gg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_agfe );
return -1;};_gdgfe +=_dffb .FontSize *_bage .Wx *_dffb .horizontalScale ();if _agfe !=' '&&(_bcgdb !=_cegfd -1||_bcac !=_gcgac -1){_gdgfe +=_dffb .CharSpacing *1000.0;};};};return _gdgfe ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_afcca *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _ff .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _ff .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _ff .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_afcca ._gdeb =true ;_afcca ._dded =startRow ;_afcca ._ageggd =endRow ;return nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_egbf *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _fgdg float64 ;var _bcfb []*StyledParagraph ;for _ ,_fage :=range _egbf ._afab {_bbbfc :=_cedfb (_egbf ._aabgb );_bbbfc .SetEnableWrap (false );_bbbfc .SetTextAlignment (TextAlignmentRight );
_bbbfc .Append (_fage ._effcf .Text ).Style =_fage ._effcf .Style ;_cbfec :=_bbbfc .getTextWidth ()/1000.0/ctx .Width ;if _fgdg < _cbfec {_fgdg =_cbfec ;};_bcfb =append (_bcfb ,_bbbfc );};_fdfg :=_afddc (2);_fdfg .SetColumnWidths (_fgdg ,1-_fgdg );_fdfg .SetMargins (_egbf ._feba .Left +_egbf ._fdb ,_egbf ._feba .Right ,_egbf ._feba .Top ,_egbf ._feba .Bottom );
_fdfg .EnableRowWrap (true );for _gagdb ,_fgad :=range _egbf ._afab {_effbf :=_fdfg .NewCell ();_effbf .SetIndent (0);_effbf .SetContent (_bcfb [_gagdb ]);_effbf =_fdfg .NewCell ();_effbf .SetIndent (0);_effbf .SetContent (_fgad ._ggceb );};return _fdfg .GeneratePageBlocks (ctx );
};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_gdfa *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _cbabe (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_ddad *GraphicSVG )SetPos (x ,y float64 ){_ddad ._gcda =PositionAbsolute ;_ddad ._bbece =x ;_ddad ._cadd =y ;};func _bbgf (_ccgbc string )(*GraphicSVG ,error ){_gddg ,_ecbf :=ParseFromSVGString (_ccgbc );if _ecbf !=nil {return nil ,_ecbf ;};return _bec (_gddg );
};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_edefe *Paragraph )SetTextAlignment (align TextAlignment ){_edefe ._bfgaa =align };

// SetBuyerAddress sets the buyer address of the invoice.
func (_aagg *Invoice )SetBuyerAddress (address *InvoiceAddress ){_aagg ._fdaa =address };

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_agef *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _agef ._dede .Left ,_agef ._dede .Right ,_agef ._dede .Top ,_agef ._dede .Bottom ;};func (_cada *GraphicSVGStyle )fillStroke (_ffab *_ae .ContentCreator ){if _cada .FillColor !=""&&_cada .StrokeColor !=""{_ffab .Add_B ();
}else if _cada .FillColor !=""{_ffab .Add_f ();}else if _cada .StrokeColor !=""{_ffab .Add_S ();};};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_agceg *StyledParagraph )Insert (index uint ,text string )*TextChunk {_cbcgb :=uint (len (_agceg ._eaad ));if index > _cbcgb {index =_cbcgb ;};_fccfb :=NewTextChunk (text ,_agceg ._eeaba );_agceg ._eaad =append (_agceg ._eaad [:index ],append ([]*TextChunk {_fccfb },_agceg ._eaad [index :]...)...);
_agceg .wrapText ();return _fccfb ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_ffdd *Image )GetHorizontalAlignment ()HorizontalAlignment {return _ffdd ._fdabf };

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_eegd *Image )SetPos (x ,y float64 ){_eegd ._cecd =PositionAbsolute ;_eegd ._edbf =x ;_eegd ._ggcdc =y ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_fgda *Invoice )AddressHeadingStyle ()TextStyle {return _fgda ._fceb };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_bcfa *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_efded :=&_bcfa ._gbgfg ._dcbc ;return _bcfa ._bdfbfc ,_efded .Right ,_efded .Top ,_efded .Bottom ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_fbggf *Image )SetWidth (w float64 ){_fbggf ._efca =w };func (_cddf *GraphicSVGElement )drawPolyline (_febb *_ae .ContentCreator ,_fabba *_cb .PdfPageResources ){_febb .Add_q ();_cddf .Style .toContentStream (_febb ,_fabba ,_cddf );_afbf ,_cbgg :=_agbb (_cddf .Attributes ["\u0070\u006f\u0069\u006e\u0074\u0073"]);
if _cbgg !=nil {_gg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0025\u0076",_cbgg );
return ;};if len (_afbf )%2> 0{_gg .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0069n\u0076\u0061l\u0069\u0064\u0020\u0070\u006f\u0069\u006e\u0074s\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006ce\u006e\u0067\u0074\u0068");return ;
};for _dbdad :=0;_dbdad < len (_afbf );{if _dbdad ==0{_febb .Add_m (_afbf [_dbdad ]*_cddf ._dfgb ,_afbf [_dbdad +1]*_cddf ._dfgb );}else {_febb .Add_l (_afbf [_dbdad ]*_cddf ._dfgb ,_afbf [_dbdad +1]*_cddf ._dfgb );};_dbdad +=2;};_cddf .Style .fillStroke (_febb );
_febb .Add_h ();_febb .Add_Q ();};

// SetHeight sets the height of the ellipse.
func (_gdbdc *Ellipse )SetHeight (height float64 ){_gdbdc ._addb =height };

// Vertical returns total vertical (top + bottom) margin.
func (_edaf *Margins )Vertical ()float64 {return _edaf .Bottom +_edaf .Top };func _dbccd (_edcff *Creator ,_acega _ad .Reader ,_gaefb interface{},_gggg *TemplateOptions ,_aeffg componentRenderer )error {if _edcff ==nil {_gg .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _cffc ;};_agead :="";if _dgfd ,_dfedd :=_acega .(*_b .File );_dfedd {_agead =_dgfd .Name ();};_cgagb :=_cc .NewBuffer (nil );if _ ,_dffca :=_ad .Copy (_cgagb ,_acega );_dffca !=nil {return _dffca ;};_bbdda :=_fb .FuncMap {"\u0064\u0069\u0063\u0074":_bdfbf ,"\u0061\u0064\u0064":_beace ,"\u0061\u0072\u0072a\u0079":_fdcaa ,"\u0065\u0078\u0074\u0065\u006e\u0064\u0044\u0069\u0063\u0074":_efdb ,"\u006da\u006b\u0065\u0053\u0065\u0071":_cgebg };
if _gggg !=nil &&_gggg .HelperFuncMap !=nil {for _ggaae ,_egef :=range _gggg .HelperFuncMap {if _ ,_ceac :=_bbdda [_ggaae ];_ceac {_gg .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ggaae );
continue ;};_bbdda [_ggaae ]=_egef ;};};_bacfb ,_dfgfc :=_fb .New ("").Funcs (_bbdda ).Parse (_cgagb .String ());if _dfgfc !=nil {return _dfgfc ;};if _gggg !=nil &&_gggg .SubtemplateMap !=nil {for _cgbbb ,_bcegg :=range _gggg .SubtemplateMap {if _cgbbb ==""{_gg .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _bcegg ==nil {_gg .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_cbcbd :=_cc .NewBuffer (nil );if _ ,_fedgf :=_ad .Copy (_cbcbd ,_bcegg );_fedgf !=nil {return _fedgf ;};if _ ,_efgcf :=_bacfb .New (_cgbbb ).Parse (_cbcbd .String ());_efgcf !=nil {return _efgcf ;};};};_cgagb .Reset ();if _eeeb :=_bacfb .Execute (_cgagb ,_gaefb );
_eeeb !=nil {return _eeeb ;};return _bedgb (_edcff ,_agead ,_cgagb .Bytes (),_gggg ,_aeffg ).run ();};func _ceedc (_dggda *_cb .PdfAnnotation )*_cb .PdfAnnotation {if _dggda ==nil {return nil ;};var _bfcfa *_cb .PdfAnnotation ;switch _efdfc :=_dggda .GetContext ().(type ){case *_cb .PdfAnnotationLink :if _eegfc :=_beedbd (_efdfc );
_eegfc !=nil {_bfcfa =_eegfc .PdfAnnotation ;};case *_cb .PdfAnnotationHighlight :if _ageggc :=_ggac (_efdfc );_ageggc !=nil {_bfcfa =_ageggc .PdfAnnotation ;};};return _bfcfa ;};

// SetPositioning sets the positioning of the line (absolute or relative).
func (_eeba *Line )SetPositioning (positioning Positioning ){_eeba ._fcfa =positioning };

// NewDivision returns a new Division container component.
func (_adgad *Creator )NewDivision ()*Division {return _abfb ()};func (_dccd *List )split (_gceb DrawContext )(_gebb ,_agfa *List ){var (_fgbef float64 ;_efgg ,_gccab []*listItem ;);_agbe :=_gceb .Width -_dccd ._feba .Horizontal ()-_dccd ._fdb -_dccd .markerWidth ();
_abee :=_dccd .markerWidth ();for _dbdg ,_bbfgf :=range _dccd ._afab {_dacdd :=_bbfgf .ctxHeight (_agbe );_fgbef +=_dacdd ;if _fgbef <=_gceb .Height {_efgg =append (_efgg ,_bbfgf );}else {switch _dbeca :=_bbfgf ._ggceb .(type ){case *List :_bfbbf :=_gceb ;
_bfbbf .Height =_a .Floor (_dacdd -(_fgbef -_gceb .Height ));_afddd ,_dbde :=_dbeca .split (_bfbbf );if _afddd !=nil {_fgbab :=_cdced ();_fgbab ._effcf =_bbfgf ._effcf ;_fgbab ._ggceb =_afddd ;_efgg =append (_efgg ,_fgbab );};if _dbde !=nil {_fccc :=_dbeca ._gbaeb .Style .FontSize ;
_cegb ,_cedf :=_dbeca ._gbaeb .Style .Font .GetRuneMetrics (' ');if _cedf {_fccc =_dbeca ._gbaeb .Style .FontSize *_cegb .Wx *_dbeca ._gbaeb .Style .horizontalScale ()/1000.0;};_fdecgb :=_bd .Repeat ("\u0020",int (_abee /_fccc ));_aegd :=_cdced ();_aegd ._effcf =*NewTextChunk (_fdecgb ,_dbeca ._gbaeb .Style );
_aegd ._ggceb =_dbde ;_gccab =append (_gccab ,_aegd );_gccab =append (_gccab ,_dccd ._afab [_dbdg +1:]...);};default:_gccab =_dccd ._afab [_dbdg :];};if len (_gccab )> 0{break ;};};};if len (_efgg )> 0{_gebb =_gbcce (_dccd ._aabgb );*_gebb =*_dccd ;_gebb ._afab =_efgg ;
};if len (_gccab )> 0{_agfa =_gbcce (_dccd ._aabgb );*_agfa =*_dccd ;_agfa ._afab =_gccab ;};return _gebb ,_agfa ;};func (_bagcc *GridCell )width (_cbaca []float64 ,_deeb float64 )float64 {_gbeeg :=float64 (0.0);for _bgfc :=0;_bgfc < _bagcc ._cdfg ;_bgfc ++{_gbeeg +=_cbaca [_bagcc ._gfde +_bgfc ];
};return _gbeeg *_deeb ;};

// SetWidth sets line width.
func (_bdgaf *Curve )SetWidth (width float64 ){_bdgaf ._aff =width };

// SetFontSize sets the font size for the paragraph.
func (_fdefaa *StyledParagraph )SetFontSize (fontSize float64 ){_fdefaa ._eeaba .FontSize =fontSize ;for _ ,_efdd :=range _fdefaa ._eaad {_efdd .Style .FontSize =fontSize ;};};func _faeac (_dabaaa *templateProcessor ,_gbefe *templateNode )(interface{},error ){return _dabaaa .parseChart (_gbefe );
};func (_agfd *Command )isAbsolute ()bool {return _agfd .Symbol ==_bd .ToUpper (_agfd .Symbol )};const (_aedf =0.72;_fddc =28.3464;_fgdb =_fddc /10;_gabb =0.551784;_dgaa =96;_gfcc =16.0;);

// ColorGrayFromHex converts color hex code to gray color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ff -> white.
func ColorGrayFromHex (hexStr string )Color {_dacd :=grayColor {};if (len (hexStr )!=2&&len (hexStr )!=3)||hexStr [0]!='#'{_gg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dacd ;
};var _ceba int ;if len (hexStr )==2{var _egb int ;_daa ,_egg :=_d .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078",&_egb );if _egg !=nil {_gg .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_egg );
return _dacd ;};if _daa !=1{_gg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dacd ;};_ceba =_egb *16+_egb ;}else {_dfcg ,_edaa :=_d .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078",&_ceba );
if _edaa !=nil {_gg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dacd ;};if _dfcg !=1{_gg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_dfcg );
return _dacd ;};};_dacd ._gadc =float64 (_ceba )/255.0;return _dacd ;};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// Height returns the height of the chart.
func (_gcfd *Chart )Height ()float64 {return float64 (_gcfd ._degg .Height ())};

// SetFontColor sets the font color for the paragraph.
func (_egcgg *StyledParagraph )SetFontColor (color Color ){_egcgg ._eeaba .Color =color ;for _ ,_abfae :=range _egcgg ._eaad {_abfae .Style .Color =color ;};};func (_cebaa *Command )compare (_ccdfb *Command )bool {if _cebaa .Symbol !=_ccdfb .Symbol {return false ;
};for _cede ,_ddfc :=range _cebaa .Params {if _ddfc !=_ccdfb .Params [_cede ]{return false ;};};return true ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_gec *Creator )RotateDeg (angleDeg int64 )error {_bdgb :=_gec .getActivePage ();if _bdgb ==nil {_gg .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _ff .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_gg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _ff .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _fab int64 ;if _bdgb .Rotate !=nil {_fab =*(_bdgb .Rotate );};_fab +=angleDeg ;_bdgb .Rotate =&_fab ;return nil ;};

// SetLineOpacity sets the line opacity.
func (_eagdc *Polyline )SetLineOpacity (opacity float64 ){_eagdc ._bfbg =opacity };func _dgbc (_bgga []_gga .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_gaffeg :&_gga .PolyBezierCurve {Curves :_bgga ,BorderColor :_cb .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_gfgf :1.0,_cfage :1.0};
};func (_agaab *templateProcessor )parseColorAttr (_fcaec ,_dfgfd string )Color {_gg .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_fcaec ,_dfgfd );
_dfgfd =_bd .TrimSpace (_dfgfd );if _bd .HasPrefix (_dfgfd ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_bd .HasSuffix (_dfgfd ,"\u0029")&&len (_dfgfd )> 17{return _agaab .parseLinearGradientAttr (_agaab .creator ,_dfgfd );
};if _bd .HasPrefix (_dfgfd ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_bd .HasSuffix (_dfgfd ,"\u0029")&&len (_dfgfd )> 17{return _agaab .parseRadialGradientAttr (_agaab .creator ,_dfgfd );};if _ebgde :=_agaab .parseColor (_dfgfd );
_ebgde !=nil {return _ebgde ;};return ColorBlack ;};func _fggdc (_adbae *templateProcessor ,_bgdad *templateNode )(interface{},error ){return _adbae .parseImage (_bgdad );};

// Cols returns the total number of columns the table has.
func (_fbdcb *Table )Cols ()int {return _fbdcb ._cfgeg };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_gbab *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_cbfda :=range subtable ._gcbaa {_aecbg :=&TableCell {};*_aecbg =*_cbfda ;_aecbg ._cecgbe =_gbab ;_aecbg ._bgage +=col -1;if _gefc :=_gbab ._cfgeg -(_aecbg ._bgage -1);_gefc < _aecbg ._gbbga {_gbab ._cfgeg +=_aecbg ._gbbga -_gefc ;
_gbab .resetColumnWidths ();_gg .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_gbab ._cfgeg );
};_aecbg ._gbbed +=row -1;_gdce :=subtable ._begfg [_cbfda ._gbbed -1];if _aecbg ._gbbed > _gbab ._gagba {for _aecbg ._gbbed > _gbab ._gagba {_gbab ._gagba ++;_gbab ._begfg =append (_gbab ._begfg ,_gbab ._dgcc );};_gbab ._begfg [_aecbg ._gbbed -1]=_gdce ;
}else {_gbab ._begfg [_aecbg ._gbbed -1]=_a .Max (_gbab ._begfg [_aecbg ._gbbed -1],_gdce );};_gbab ._gcbaa =append (_gbab ._gcbaa ,_aecbg );};_gbab .sortCells ();};func (_bdda *Invoice )generateNoteBlocks (_cdbg DrawContext )([]*Block ,DrawContext ,error ){_fcfc :=_abfb ();
_cbcb :=append ([][2]string {_bdda ._ffce ,_bdda ._gefef },_bdda ._cbadd ...);for _ ,_dfgg :=range _cbcb {if _dfgg [1]!=""{_gbda :=_bdda .drawSection (_dfgg [0],_dfgg [1]);for _ ,_cbeb :=range _gbda {_fcfc .Add (_cbeb );};_befe :=_cedfb (_bdda ._dfae );
_befe .SetMargins (0,0,10,0);_fcfc .Add (_befe );};};return _fcfc .GeneratePageBlocks (_cdbg );};

// Horizontal returns total horizontal (left + right) margin.
func (_egfe *Margins )Horizontal ()float64 {return _egfe .Left +_egfe .Right };func (_agagd *Grid )cloneRow (_ebde int )*GridRow {_gcfba :=&GridRow {_cdbae :_agagd ._acdc ,_egag :_ebde +1,_accg :_agagd };for _ ,_gdefa :=range _agagd ._bded [_ebde ]._cabf {_gecg ,_ :=_gcfba .NewMultiCell (_gdefa ._cdfg ,1);
if _gecg !=nil {_gecg ._bbdf =_gdefa ._bbdf ;_gecg ._egfeg =_gdefa ._egfeg ;_gecg ._feac =_gdefa ._feac ;_gecg ._fbfe =_gdefa ._fbfe ;_gecg ._gbef =_gdefa ._gbef ;_gecg ._becd =_gdefa ._becd ;_gecg ._gbgf =_gdefa ._gbgf ;_gecg ._afbbd =_gdefa ._afbbd ;
_gecg ._aded =_gdefa ._aded ;_gecg ._adcea =_gdefa ._adcea ;_gecg ._bgge =_gdefa ._bgge ;_gecg ._dbaa =_gdefa ._dbaa ;_gecg ._aegc =_gdefa ._aegc ;_gecg ._adbe =_gdefa ._adbe ;_gecg ._gfde =_gdefa ._gfde ;_gecg ._eedc =_gdefa ._eedc ;_gecg ._bccb =_gdefa ._bccb ;
_gecg ._agefe =_gdefa ._agefe ;_gecg ._dbab =_ebde +1;_gecg ._cgcd =_gdefa ._cgcd ;};};return _gcfba ;};func _bccf (_bgeeb *Block ,_feb *Image ,_fdddf DrawContext )(DrawContext ,error ){_beaf :=_fdddf ;_ffgf :=1;_bdfg :=_fac .PdfObjectName (_d .Sprintf ("\u0049\u006d\u0067%\u0064",_ffgf ));
for _bgeeb ._bg .HasXObjectByName (_bdfg ){_ffgf ++;_bdfg =_fac .PdfObjectName (_d .Sprintf ("\u0049\u006d\u0067%\u0064",_ffgf ));};_ddddd :=_bgeeb ._bg .SetXObjectImageByNameLazy (_bdfg ,_feb ._bfad ,_feb ._ccefc );if _ddddd !=nil {return _fdddf ,_ddddd ;
};_eagb :=0;_gfeg :=_fac .PdfObjectName (_d .Sprintf ("\u0047\u0053\u0025\u0064",_eagb ));for _bgeeb ._bg .HasExtGState (_gfeg ){_eagb ++;_gfeg =_fac .PdfObjectName (_d .Sprintf ("\u0047\u0053\u0025\u0064",_eagb ));};_fecgf :=_fac .MakeDict ();_fecgf .Set ("\u0042\u004d",_fac .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));
if _feb ._gdefg < 1.0{_fecgf .Set ("\u0043\u0041",_fac .MakeFloat (_feb ._gdefg ));_fecgf .Set ("\u0063\u0061",_fac .MakeFloat (_feb ._gdefg ));};_ddddd =_bgeeb ._bg .AddExtGState (_gfeg ,_fac .MakeIndirectObject (_fecgf ));if _ddddd !=nil {return _fdddf ,_ddddd ;
};_defg :=_feb .Width ();_dfba :=_feb .Height ();_ ,_cbba :=_feb .rotatedSize ();_cbbg :=_fdddf .X ;_ecfef :=_fdddf .PageHeight -_fdddf .Y -_dfba ;if _feb ._cecd .IsRelative (){_ecfef -=(_cbba -_dfba )/2;switch _feb ._fdabf {case HorizontalAlignmentCenter :_cbbg +=(_fdddf .Width -_defg )/2;
case HorizontalAlignmentRight :_cbbg =_fdddf .PageWidth -_fdddf .Margins .Right -_feb ._bcgd .Right -_defg ;};};_agge :=_feb ._gegeb ;_fccgca :=_ae .NewContentCreator ();if _feb ._fbbe !=nil {_fccgca .Add_BDC (*_fac .MakeName (_cb .StructureTypeFigure ),map[string ]_fac .PdfObject {"\u004d\u0043\u0049\u0044":_fac .MakeInteger (*_feb ._fbbe )});
};_fccgca .Add_gs (_gfeg );_fccgca .Translate (_cbbg ,_ecfef );if _agge !=0{_fccgca .Translate (_defg /2,_dfba /2);_fccgca .RotateDeg (_agge );_fccgca .Translate (-_defg /2,-_dfba /2);};_fccgca .Scale (_defg ,_dfba ).Add_Do (_bdfg );if _feb ._fbbe !=nil {_fccgca .Add_EMC ();
};_deebd :=_fccgca .Operations ();_deebd .WrapIfNeeded ();_bgeeb .addContents (_deebd );if _feb ._cecd .IsRelative (){_fdddf .Y +=_cbba ;_fdddf .Height -=_cbba ;return _fdddf ,nil ;};return _beaf ,nil ;};func _aegaed (_dafde ,_dagcef ,_fcafe TextChunk ,_bfbeb uint ,_ffgge TextStyle )*TOCLine {_ggdff :=_cedfb (_ffgge );
_ggdff .SetEnableWrap (true );_ggdff .SetTextAlignment (TextAlignmentLeft );_ggdff .SetMargins (0,0,2,2);_cbbfd :=&TOCLine {_gbgfg :_ggdff ,Number :_dafde ,Title :_dagcef ,Page :_fcafe ,Separator :TextChunk {Text :"\u002e",Style :_ffgge },_bdfbfc :0,_gfga :_bfbeb ,_ceacd :10,_debaf :PositionRelative };
_ggdff ._dcbc .Left =_cbbfd ._bdfbfc +float64 (_cbbfd ._gfga -1)*_cbbfd ._ceacd ;_ggdff ._afea =_cbbfd .prepareParagraph ;return _cbbfd ;};func (_aabg *GraphicSVGStyle )toContentStream (_cfaf *_ae .ContentCreator ,_deaa *_cb .PdfPageResources ,_fbab *GraphicSVGElement ){if _aabg ==nil {return ;
};if _aabg .FillColor !=""{var _dcgec ,_ffga ,_dfebg float64 ;if _aece ,_fdcd :=_cae .ColorMap [_aabg .FillColor ];_fdcd {_fcea ,_cdff ,_deaef ,_ :=_aece .RGBA ();_dcgec ,_ffga ,_dfebg =float64 (_fcea ),float64 (_cdff ),float64 (_deaef );_cfaf .Add_rg (_dcgec ,_ffga ,_dfebg );
}else if _bd .HasPrefix (_aabg .FillColor ,"\u0072\u0067\u0062\u0028"){_dcgec ,_ffga ,_dfebg =_fgbgc (_aabg .FillColor );_cfaf .Add_rg (_dcgec ,_ffga ,_dfebg );}else if _bd .HasPrefix (_aabg .FillColor ,"\u0075\u0072\u006c\u0028"){_dfdc :=_bd .TrimPrefix (_aabg .FillColor ,"\u0075\u0072\u006c\u0028\u0027\u0023");
_dfdc =_bd .TrimPrefix (_dfdc ,"\u0075\u0072\u006c(\u0023");_dfdc =_bd .TrimSuffix (_dfdc ,"\u0027\u0029");_dfdc =_bd .TrimSuffix (_dfdc ,"\u0029");if _fbab ._decf [_dfdc ]!=nil {_deaa .SetPatternByName (*_fac .MakeName (_dfdc ),_fbab ._decf [_dfdc ].ToPdfShadingPattern ().ToPdfObject ());
_cfaf .Add_cs (*_fac .MakeName ("\u0050a\u0074\u0074\u0065\u0072\u006e"));_cfaf .Add_scn_pattern (*_fac .MakeName (_dfdc ));};}else {_dcgec ,_ffga ,_dfebg =ColorRGBFromHex (_aabg .FillColor ).ToRGB ();_cfaf .Add_rg (_dcgec ,_ffga ,_dfebg );};};if _aabg .FillOpacity < 1.0{_gbdb :=0;
_bgdd :=_fac .PdfObjectName (_d .Sprintf ("\u0047\u0053\u0025\u0064",_gbdb ));for {_ ,_efbcf :=_deaa .GetExtGState (_bgdd );if !_efbcf {break ;};_gbdb ++;_bgdd =_fac .PdfObjectName (_d .Sprintf ("\u0047\u0053\u0025\u0064",_gbdb ));};_efef :=_fac .MakeDict ();
_efef .Set ("\u0063\u0061",_fac .MakeFloat (_aabg .FillOpacity ));_gbba :=_deaa .AddExtGState (_bgdd ,_fac .MakeIndirectObject (_efef ));if _gbba !=nil {_gg .Log .Debug (_gbba .Error ());return ;};_cfaf .Add_gs (_bgdd );};if _aabg .StrokeColor !=""{var _ccbb ,_daggg ,_aafd float64 ;
if _afad ,_fffg :=_cae .ColorMap [_aabg .StrokeColor ];_fffg {_fecg ,_facc ,_dcff ,_ :=_afad .RGBA ();_ccbb ,_daggg ,_aafd =float64 (_fecg )/255.0,float64 (_facc )/255.0,float64 (_dcff )/255.0;}else if _bd .HasPrefix (_aabg .FillColor ,"\u0072\u0067\u0062\u0028"){_ccbb ,_daggg ,_aafd =_fgbgc (_aabg .FillColor );
}else {_ccbb ,_daggg ,_aafd =ColorRGBFromHex (_aabg .StrokeColor ).ToRGB ();};_cfaf .Add_RG (_ccbb ,_daggg ,_aafd );};if _aabg .StrokeWidth > 0{_cfaf .Add_w (_aabg .StrokeWidth );};};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_dgdcd *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_dgdcd ._fdabf =alignment };func (_caef *GraphicSVGElement )drawPath (_cdedd *_ae .ContentCreator ,_dbabb *_cb .PdfPageResources ){_cdedd .Add_q ();_caef .Style .toContentStream (_cdedd ,_dbabb ,_caef );
_daeage (_caef ,_cdedd );_gbbec ,_babce :=_cceed (_caef .Attributes ["\u0064"]);if _babce !=nil {_gg .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025s",_babce .Error ());};var (_ededb ,_fdbd =0.0,0.0;_ebcb ,_ebgcc =0.0,0.0;_acgd *Command ;);for _ ,_aceec :=range _gbbec .Subpaths {for _ ,_ddbbfa :=range _aceec .Commands {switch _bd .ToLower (_ddbbfa .Symbol ){case "\u006d":_ebcb ,_ebgcc =_ddbbfa .Params [0]*_caef ._dfgb ,_ddbbfa .Params [1]*_caef ._dfgb ;
if !_ddbbfa .isAbsolute (){_ebcb ,_ebgcc =_ededb +_ebcb -_caef .ViewBox .X ,_fdbd +_ebgcc -_caef .ViewBox .Y ;};_cdedd .Add_m (_aa .RoundFloat (_ebcb ,3),_aa .RoundFloat (_ebgcc ,3));_ededb ,_fdbd =_ebcb ,_ebgcc ;case "\u0063":_fffdd ,_cfdeb ,_ddgfa ,_bbcc ,_fbce ,_aefe :=_ddbbfa .Params [0]*_caef ._dfgb ,_ddbbfa .Params [1]*_caef ._dfgb ,_ddbbfa .Params [2]*_caef ._dfgb ,_ddbbfa .Params [3]*_caef ._dfgb ,_ddbbfa .Params [4]*_caef ._dfgb ,_ddbbfa .Params [5]*_caef ._dfgb ;
if !_ddbbfa .isAbsolute (){_fffdd ,_cfdeb ,_ddgfa ,_bbcc ,_fbce ,_aefe =_ededb +_fffdd ,_fdbd +_cfdeb ,_ededb +_ddgfa ,_fdbd +_bbcc ,_ededb +_fbce ,_fdbd +_aefe ;};_cdedd .Add_c (_aa .RoundFloat (_fffdd ,3),_aa .RoundFloat (_cfdeb ,3),_aa .RoundFloat (_ddgfa ,3),_aa .RoundFloat (_bbcc ,3),_aa .RoundFloat (_fbce ,3),_aa .RoundFloat (_aefe ,3));
_ededb ,_fdbd =_fbce ,_aefe ;case "\u0073":_gbgef ,_ddde ,_bceb ,_gfefc :=_ddbbfa .Params [0]*_caef ._dfgb ,_ddbbfa .Params [1]*_caef ._dfgb ,_ddbbfa .Params [2]*_caef ._dfgb ,_ddbbfa .Params [3]*_caef ._dfgb ;if !_ddbbfa .isAbsolute (){_gbgef ,_ddde ,_bceb ,_gfefc =_ededb +_gbgef ,_fdbd +_ddde ,_ededb +_bceb ,_fdbd +_gfefc ;
};_cdedd .Add_c (_aa .RoundFloat (_ededb ,3),_aa .RoundFloat (_fdbd ,3),_aa .RoundFloat (_gbgef ,3),_aa .RoundFloat (_ddde ,3),_aa .RoundFloat (_bceb ,3),_aa .RoundFloat (_gfefc ,3));_ededb ,_fdbd =_bceb ,_gfefc ;case "\u006c":_dddbd ,_dbea :=_ddbbfa .Params [0]*_caef ._dfgb ,_ddbbfa .Params [1]*_caef ._dfgb ;
if !_ddbbfa .isAbsolute (){_dddbd ,_dbea =_ededb +_dddbd ,_fdbd +_dbea ;};_cdedd .Add_l (_aa .RoundFloat (_dddbd ,3),_aa .RoundFloat (_dbea ,3));_ededb ,_fdbd =_dddbd ,_dbea ;case "\u0068":_aebc :=_ddbbfa .Params [0]*_caef ._dfgb ;if !_ddbbfa .isAbsolute (){_aebc =_ededb +_aebc ;
};_cdedd .Add_l (_aa .RoundFloat (_aebc ,3),_aa .RoundFloat (_fdbd ,3));_ededb =_aebc ;case "\u0076":_aeggaf :=_ddbbfa .Params [0]*_caef ._dfgb ;if !_ddbbfa .isAbsolute (){_aeggaf =_fdbd +_aeggaf ;};_cdedd .Add_l (_aa .RoundFloat (_ededb ,3),_aa .RoundFloat (_aeggaf ,3));
_fdbd =_aeggaf ;case "\u0071":_fdca ,_gfag ,_aggb ,_acbbc :=_ddbbfa .Params [0]*_caef ._dfgb ,_ddbbfa .Params [1]*_caef ._dfgb ,_ddbbfa .Params [2]*_caef ._dfgb ,_ddbbfa .Params [3]*_caef ._dfgb ;if !_ddbbfa .isAbsolute (){_fdca ,_gfag ,_aggb ,_acbbc =_ededb +_fdca ,_fdbd +_gfag ,_ededb +_aggb ,_fdbd +_acbbc ;
};_efbcff ,_dfde :=_cae .QuadraticToCubicBezier (_ededb ,_fdbd ,_fdca ,_gfag ,_aggb ,_acbbc );_cdedd .Add_c (_aa .RoundFloat (_efbcff .X ,3),_aa .RoundFloat (_efbcff .Y ,3),_aa .RoundFloat (_dfde .X ,3),_aa .RoundFloat (_dfde .Y ,3),_aa .RoundFloat (_aggb ,3),_aa .RoundFloat (_acbbc ,3));
_ededb ,_fdbd =_aggb ,_acbbc ;case "\u0074":var _cggbd ,_fbcec _cae .Point ;_bcdg ,_dbfa :=_ddbbfa .Params [0]*_caef ._dfgb ,_ddbbfa .Params [1]*_caef ._dfgb ;if !_ddbbfa .isAbsolute (){_bcdg ,_dbfa =_ededb +_bcdg ,_fdbd +_dbfa ;};if _acgd !=nil &&_bd .ToLower (_acgd .Symbol )=="\u0071"{_cggae :=_cae .Point {X :_acgd .Params [0]*_caef ._dfgb ,Y :_acgd .Params [1]*_caef ._dfgb };
_dcgea :=_cae .Point {X :_acgd .Params [2]*_caef ._dfgb ,Y :_acgd .Params [3]*_caef ._dfgb };_bgfca :=_dcgea .Mul (2.0).Sub (_cggae );_cggbd ,_fbcec =_cae .QuadraticToCubicBezier (_ededb ,_fdbd ,_bgfca .X ,_bgfca .Y ,_bcdg ,_dbfa );};_cdedd .Add_c (_aa .RoundFloat (_cggbd .X ,3),_aa .RoundFloat (_cggbd .Y ,3),_aa .RoundFloat (_fbcec .X ,3),_aa .RoundFloat (_fbcec .Y ,3),_aa .RoundFloat (_bcdg ,3),_aa .RoundFloat (_dbfa ,3));
_ededb ,_fdbd =_bcdg ,_dbfa ;case "\u0061":_ggdaa ,_agbcc :=_ddbbfa .Params [0]*_caef ._dfgb ,_ddbbfa .Params [1]*_caef ._dfgb ;_feacd :=_ddbbfa .Params [2];_gdfbd :=_ddbbfa .Params [3]> 0;_ebca :=_ddbbfa .Params [4]> 0;_bbda ,_cabb :=_ddbbfa .Params [5]*_caef ._dfgb ,_ddbbfa .Params [6]*_caef ._dfgb ;
if !_ddbbfa .isAbsolute (){_bbda ,_cabb =_ededb +_bbda ,_fdbd +_cabb ;};_daga :=_cae .EllipseToCubicBeziers (_ededb ,_fdbd ,_ggdaa ,_agbcc ,_feacd ,_gdfbd ,_ebca ,_bbda ,_cabb );for _ ,_aaddc :=range _daga {_cdedd .Add_c (_aa .RoundFloat (_aaddc [1].X ,3),_aa .RoundFloat ((_aaddc [1].Y ),3),_aa .RoundFloat ((_aaddc [2].X ),3),_aa .RoundFloat ((_aaddc [2].Y ),3),_aa .RoundFloat ((_aaddc [3].X ),3),_aa .RoundFloat ((_aaddc [3].Y ),3));
};_ededb ,_fdbd =_bbda ,_cabb ;case "\u007a":_cdedd .Add_h ();};_acgd =_ddbbfa ;};};_caef .Style .fillStroke (_cdedd );_cdedd .Add_h ();_cdedd .Add_Q ();};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_dcaac *TOC )SetLineStyle (style TextStyle ){_dcaac .SetLineNumberStyle (style );_dcaac .SetLineTitleStyle (style );_dcaac .SetLineSeparatorStyle (style );_dcaac .SetLinePageStyle (style );};const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;
AnchorTopLeft ;AnchorTopRight ;AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);func _gceeg (_fadgb []*Command )*Path {_ffbaa :=&Path {};var _cece []*Command ;for _bdba ,_bcdaa :=range _fadgb {switch _bd .ToLower (_bcdaa .Symbol ){case _dbdfb ._ecbde :if len (_cece )> 0{_ffbaa .Subpaths =append (_ffbaa .Subpaths ,&Subpath {_cece });
};_cece =[]*Command {_bcdaa };case _dbdfb ._dcdc :_cece =append (_cece ,_bcdaa );_ffbaa .Subpaths =append (_ffbaa .Subpaths ,&Subpath {_cece });_cece =[]*Command {};default:_cece =append (_cece ,_bcdaa );if len (_fadgb )==_bdba +1{_ffbaa .Subpaths =append (_ffbaa .Subpaths ,&Subpath {_cece });
};};};return _ffbaa ;};

// SetBorderOpacity sets the border opacity of the ellipse.
func (_cbgcc *Ellipse )SetBorderOpacity (opacity float64 ){_cbgcc ._fggg =opacity };func (_fga *Block )duplicate ()*Block {_dde :=&Block {};*_dde =*_fga ;_cg :=_ae .ContentStreamOperations {};_cg =append (_cg ,*_fga ._fd ...);_dde ._fd =&_cg ;return _dde ;
};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// FillColor returns the fill color of the rectangle.
func (_beae *Rectangle )FillColor ()Color {return _beae ._ecbc };const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_fbgfb *TOC )SetLineSeparator (separator string ){_fbgfb ._cbgfb =separator };

// SetColorLeft sets border color for left.
func (_ebe *border )SetColorLeft (col Color ){_ebe ._gfc =col };

// FitMode returns the fit mode of the image.
func (_geac *Image )FitMode ()FitMode {return _geac ._fbbd };

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};

// Rows returns the total number of rows the table has.
func (_dged *Table )Rows ()int {return _dged ._gagba };type templateTag struct{_bfaac map[string ]struct{};_fbedge func (*templateProcessor ,*templateNode )(interface{},error );};

// SetLanguage sets the language identifier that will be stored inside document catalog.
func (_cff *Creator )SetLanguage (language string ){_cff ._egfb =language };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_gabf *Chapter )SetIncludeInTOC (includeInTOC bool ){_gabf ._cdeb =includeInTOC };

// Height returns the total height of all rows.
func (_fbcef *Table )Height ()float64 {_ccfefc :=float64 (0.0);for _ ,_edba :=range _fbcef ._begfg {_ccfefc +=_edba ;};return _ccfefc ;};

// SetTotal sets the total of the invoice.
func (_eegf *Invoice )SetTotal (value string ){_eegf ._agdaf [1].Value =value };

// AddColorStop add color stop info for rendering gradient color.
func (_bggd *LinearShading )AddColorStop (color Color ,point float64 ){_bggd ._fafde .AddColorStop (color ,point );};

// SetFillColor sets the fill color of the ellipse.
func (_fcda *Ellipse )SetFillColor (col Color ){_fcda ._cfefb =col };

// Height returns the height of the ellipse.
func (_bgca *Ellipse )Height ()float64 {return _bgca ._addb };

// Path is a collection of all the subpaths in 'd' attribute.
type Path struct{Subpaths []*Subpath ;};

// SetBorderColor sets the border color of the ellipse.
func (_adfeg *Ellipse )SetBorderColor (col Color ){_adfeg ._eagg =col };

// SetColor sets the line color.
func (_aceg *Curve )SetColor (col Color ){_aceg ._agb =col };

// BorderWidth returns the border width of the rectangle.
func (_cbda *Rectangle )BorderWidth ()float64 {return _cbda ._afefe };

// FillColor returns the fill color of the ellipse.
func (_ggae *Ellipse )FillColor ()Color {return _ggae ._cfefb };type shading struct{_acggc Color ;_fbada bool ;_aadd []bool ;_bcbgf []*ColorPoint ;};

// SetMarkedContentID sets the marked content identifier.
func (_cfdea *Polygon )SetMarkedContentID (mcid int64 )*_cb .KDict {_cfdea ._agdcd =&mcid ;_acefc :=_cb .NewKDictionary ();_acefc .S =_fac .MakeName (_cb .StructureTypeFigure );_acefc .K =_fac .MakeInteger (mcid );return _acefc ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_dbcb *Invoice )InfoLines ()[][2]*InvoiceCell {_edfff :=[][2]*InvoiceCell {_dbcb ._dedbb ,_dbcb ._adceg ,_dbcb ._gcgd };return append (_edfff ,_dbcb ._gade ...);};func _ffffb (_gdfg *templateProcessor ,_bdcb *templateNode )(interface{},error ){return _gdfg .parseChapterHeading (_bdcb );
};

// NewColumn returns a new column for the line items invoice table.
func (_fceee *Invoice )NewColumn (description string )*InvoiceCell {return _fceee .newColumn (description ,CellHorizontalAlignmentLeft );};

// Height returns the height of the line.
func (_aecf *Line )Height ()float64 {_adcb :=_aecf ._fcfg ;if _aecf ._cdbgd ==_aecf ._abdb {_adcb /=2;};return _a .Abs (_aecf ._ecff -_aecf ._bggef )+_adcb ;};

// SetHeight sets the custom height for the row.
func (_cdfdc *GridRow )SetHeight (h float64 ){_cdfdc ._cdbae =h };

// BorderColor returns the border color of the ellipse.
func (_fgfb *Ellipse )BorderColor ()Color {return _fgfb ._eagg };func _beedbd (_gcdc *_cb .PdfAnnotationLink )*_cb .PdfAnnotationLink {if _gcdc ==nil {return nil ;};_ceaed :=_cb .NewPdfAnnotationLink ();_ceaed .BS =_gcdc .BS ;_ceaed .A =_gcdc .A ;if _geddf ,_cfdaa :=_gcdc .GetAction ();
_cfdaa ==nil &&_geddf !=nil {_ceaed .SetAction (_geddf );};if _deggb ,_eebg :=_gcdc .Dest .(*_fac .PdfObjectArray );_eebg {_ceaed .Dest =_fac .MakeArray (_deggb .Elements ()...);};return _ceaed ;};

// Padding returns the padding of the component.
func (_caaf *Division )Padding ()(_babe ,_geggf ,_ebga ,_acga float64 ){return _caaf ._cacg .Left ,_caaf ._cacg .Right ,_caaf ._cacg .Top ,_caaf ._cacg .Bottom ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_cfbd *Creator )EnableFontSubsetting (font *_cb .PdfFont ){_cfbd ._ecfg =append (_cfbd ._ecfg ,font );};

// SetMarkedContentID sets marked content ID.
func (_ddgff *GraphicSVG )SetMarkedContentID (mcid int64 )*_cb .KDict {_ddgff ._aabd =&mcid ;_fgba :=_cb .NewKDictionary ();_fgba .S =_fac .MakeName (_cb .StructureTypeFigure );_fgba .K =_fac .MakeInteger (mcid );return _fgba ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_fcdbg Color ;_fbbfg float64 ;_eceb _gga .LineStyle ;_ccecb CellBorderStyle ;_bfaa Color ;_acdbg float64 ;_dgfe CellBorderStyle ;_agac Color ;_aeefb float64 ;_bbgad CellBorderStyle ;_cbcac Color ;_eecfd float64 ;_edcda CellBorderStyle ;
_cgfdb Color ;_cdaeb float64 ;_gbbed ,_bgage int ;_dfgcc int ;_gbbga int ;_bgfcf VectorDrawable ;_fabd CellHorizontalAlignment ;_agcce CellVerticalAlignment ;_bbeab float64 ;_cecgbe *Table ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_fgbeb *StyledParagraph )SetText (text string )*TextChunk {_fgbeb .Reset ();return _fgbeb .Append (text );};func (_agdcg *Invoice )generateLineBlocks (_cdadg DrawContext )([]*Block ,DrawContext ,error ){_aegga :=_afddc (len (_agdcg ._cefb ));_aegga .SetMargins (0,0,25,0);
for _ ,_fegff :=range _agdcg ._cefb {_aaed :=_cedfb (_fegff .TextStyle );_aaed .SetMargins (0,0,1,0);_aaed .Append (_fegff .Value );_cgfac :=_aegga .NewCell ();_cgfac .SetHorizontalAlignment (_fegff .Alignment );_cgfac .SetBackgroundColor (_fegff .BackgroundColor );
_agdcg .setCellBorder (_cgfac ,_fegff );_cgfac .SetContent (_aaed );};for _ ,_aeff :=range _agdcg ._daeag {for _ ,_fabb :=range _aeff {_fbgb :=_cedfb (_fabb .TextStyle );_fbgb .SetMargins (0,0,3,2);_fbgb .Append (_fabb .Value );_beaa :=_aegga .NewCell ();
_beaa .SetHorizontalAlignment (_fabb .Alignment );_beaa .SetBackgroundColor (_fabb .BackgroundColor );_agdcg .setCellBorder (_beaa ,_fabb );_beaa .SetContent (_fbgb );};};return _aegga .GeneratePageBlocks (_cdadg );};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_dbdf []_gga .CubicBezierCurve ;FillEnabled bool ;_gfd Color ;BorderEnabled bool ;BorderWidth float64 ;_bga Color ;_eafb *int64 ;};

// SetWidth sets the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_caceg *Paragraph )SetWidth (width float64 ){_caceg ._egeg =width ;_caceg .wrapText ()};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_adfea *StyledParagraph )SetTextAlignment (align TextAlignment ){_adfea ._gffa =align };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_gdadc *RadialShading )SetBackgroundColor (backgroundColor Color ){_gdadc ._bbfaa .SetBackgroundColor (backgroundColor );};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_aaa *Ellipse )BorderOpacity ()float64 {return _aaa ._fggg };

// DrawFooter sets a function to draw a footer on created output pages.
func (_acb *Creator )DrawFooter (drawFooterFunc func (_bgc *Block ,_dafd FooterFunctionArgs )){_acb ._egf =drawFooterFunc ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_dgfg *LinearShading )SetExtends (start bool ,end bool ){_dgfg ._fafde .SetExtends (start ,end )};func (_gbaa *GridRow )updateRowHeight (_gaeba float64 ){_gbaa ._aeaaa =_gbaa ._cdbae ;for _ ,_fcdc :=range _gbaa ._cabf {_dffg :=_fcdc .width (_gbaa ._accg ._ggcd ,_gaeba );
_efbb :=_fcdc .height (_dffg );if _efbb > _gbaa ._aeaaa {_gbaa ._aeaaa =_efbb ;};};};

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_gcdf *Rectangle )SetFitMode (fitMode FitMode ){_gcdf ._bdde =fitMode };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_eecf *Image )ScaleToWidth (w float64 ){_fgfa :=_eecf ._efag /_eecf ._efca ;_eecf ._efca =w ;_eecf ._efag =w *_fgfa ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_gaeda *TOCLine )LevelOffset ()float64 {return _gaeda ._ceacd };

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_effe *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _effe ._gddc [0],_effe ._gddc [1]};

// DashPattern returns the dash pattern of the line.
func (_bdgad *Line )DashPattern ()(_bagb []int64 ,_febc int64 ){return _bdgad ._cfcb ,_bdgad ._affb };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_dbcf *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dbcf ._dcbc .Left ,_dbcf ._dcbc .Right ,_dbcf ._dcbc .Top ,_dbcf ._dcbc .Bottom ;};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };
PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);func _cfacb (_dbbbg ,_aedg ,_gcbgg string ,_cbcaf uint ,_abac TextStyle )*TOCLine {return _aegaed (TextChunk {Text :_dbbbg ,Style :_abac },TextChunk {Text :_aedg ,Style :_abac },TextChunk {Text :_gcbgg ,Style :_abac },_cbcaf ,_abac );
};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_abge *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_abge ._bcfdf =&_cb .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};func (_dfabb *GraphicSVGElement )toContentStream (_ggga *_ae .ContentCreator ,_eegb *_cb .PdfPageResources ){_gagd ,_eggde :=_dcgg (_dfabb .Attributes ,_dfabb ._dfgb );
if _eggde !=nil {_gg .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_eggde );};_dfabb .Style =_gagd ;
switch _dfabb .Name {case "\u0070\u0061\u0074\u0068":_dfabb .drawPath (_ggga ,_eegb );for _ ,_ddbgc :=range _dfabb .Children {_ddbgc .toContentStream (_ggga ,_eegb );};case "\u0072\u0065\u0063\u0074":_dfabb .drawRect (_ggga ,_eegb );for _ ,_aefd :=range _dfabb .Children {_aefd .toContentStream (_ggga ,_eegb );
};case "\u0063\u0069\u0072\u0063\u006c\u0065":_dfabb .drawCircle (_ggga ,_eegb );for _ ,_baad :=range _dfabb .Children {_baad .toContentStream (_ggga ,_eegb );};case "\u0065l\u006c\u0069\u0070\u0073\u0065":_dfabb .drawEllipse (_ggga ,_eegb );for _ ,_cacb :=range _dfabb .Children {_cacb .toContentStream (_ggga ,_eegb );
};case "\u0070\u006f\u006c\u0079\u006c\u0069\u006e\u0065":_dfabb .drawPolyline (_ggga ,_eegb );for _ ,_bddg :=range _dfabb .Children {_bddg .toContentStream (_ggga ,_eegb );};case "\u0070o\u006c\u0079\u0067\u006f\u006e":_dfabb .drawPolygon (_ggga ,_eegb );
for _ ,_gadcb :=range _dfabb .Children {_gadcb .toContentStream (_ggga ,_eegb );};case "\u006c\u0069\u006e\u0065":_dfabb .drawLine (_ggga ,_eegb );for _ ,_effa :=range _dfabb .Children {_effa .toContentStream (_ggga ,_eegb );};case "\u0074\u0065\u0078\u0074":_dfabb .drawText (_ggga ,_eegb );
for _ ,_ebfgg :=range _dfabb .Children {_ebfgg .toContentStream (_ggga ,_eegb );};case "\u0067":_gdff ,_fegf :=_dfabb .Attributes ["\u0066\u0069\u006c\u006c"];_bccc ,_dbb :=_dfabb .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"];_fbed ,_bggc :=_dfabb .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];
_bfdfe ,_cdba :=_dfabb .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];for _ ,_gfgg :=range _dfabb .Children {if _ ,_dggbe :=_gfgg .Attributes ["\u0066\u0069\u006c\u006c"];!_dggbe &&_fegf {_gfgg .Attributes ["\u0066\u0069\u006c\u006c"]=_gdff ;
};if _ ,_ccec :=_gfgg .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"];!_ccec &&_dbb {_gfgg .Attributes ["\u0073\u0074\u0072\u006f\u006b\u0065"]=_bccc ;};if _ ,_fdga :=_gfgg .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];
!_fdga &&_bggc {_gfgg .Attributes ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"]=_fbed ;};if _ ,_cffg :=_gfgg .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];!_cffg &&_cdba {_gfgg .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"]=_bfdfe ;
};_gfgg .toContentStream (_ggga ,_eegb );};};};func _efdgg (_badda interface{})(interface{},error ){switch _cgeag :=_badda .(type ){case uint8 :return int64 (_cgeag ),nil ;case int8 :return int64 (_cgeag ),nil ;case uint16 :return int64 (_cgeag ),nil ;
case int16 :return int64 (_cgeag ),nil ;case uint32 :return int64 (_cgeag ),nil ;case int32 :return int64 (_cgeag ),nil ;case uint64 :return int64 (_cgeag ),nil ;case int64 :return _cgeag ,nil ;case int :return int64 (_cgeag ),nil ;case float32 :return float64 (_cgeag ),nil ;
case float64 :return _cgeag ,nil ;};return nil ,_d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0076\u0061\u006c\u0075\u0065\u002c\u0020\u0025\u0076\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072",_badda );
};

// SetSellerAddress sets the seller address of the invoice.
func (_aeeba *Invoice )SetSellerAddress (address *InvoiceAddress ){_aeeba ._cefag =address };

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_acca *GridCell )SetVerticalAlignment (valign CellVerticalAlignment ){_acca ._cgcd =valign };func _abfd (_edfa [][]_gga .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_bgecf :&_gga .CurvePolygon {Rings :_edfa },_gaff :1.0,_efbg :1.0};};

// Decode decodes the child elements of element.
func (_bbbf *GraphicSVGElement )Decode (decoder *_cd .Decoder )error {for {_dcab ,_eebda :=decoder .Token ();if _dcab ==nil &&_eebda ==_ad .EOF {break ;};if _eebda !=nil {return _eebda ;};switch _eefg :=_dcab .(type ){case _cd .StartElement :_cgfd :=_aggd (_eefg );
_feed :=_cgfd .Decode (decoder );if _feed !=nil {return _feed ;};_bbbf .Children =append (_bbbf .Children ,_cgfd );case _cd .CharData :_gefg :=_bd .TrimSpace (string (_eefg ));if _gefg !=""{_bbbf .Content =string (_eefg );};case _cd .EndElement :if _eefg .Name .Local ==_bbbf .Name {return nil ;
};};};return nil ;};

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _bbgf (svgStr )};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_gaec :_a .Max (_a .Min (c ,1.0),0.0),_ceeb :_a .Max (_a .Min (m ,1.0),0.0),_adfa :_a .Max (_a .Min (y ,1.0),0.0),_deae :_a .Max (_a .Min (k ,1.0),0.0)};};

// SetMarkedContentID sets the marked content ID for the text chunk.
func (_ceaaf *TextChunk )SetMarkedContentID (mcid int64 )*_cb .KDict {_ceaaf ._deafg =&mcid ;_ffefc :=_cb .NewKDictionary ();_ffefc .S =_fac .MakeName ("\u0053\u0070\u0061\u006e");_ffefc .K =_fac .MakeInteger (mcid );return _ffefc ;};func (_dbfc *templateProcessor )parseTextChunk (_cabgc *templateNode ,_dcggd *TextChunk )(interface{},error ){if _cabgc ._bedad ==nil {_dbfc .nodeLogError (_cabgc ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_fbcba ;};var (_cfdaf =_dbfc .creator .NewTextStyle ();_aabcea bool ;);for _ ,_bcabg :=range _cabgc ._bcdgfa .Attr {if _bcabg .Name .Local =="\u006c\u0069\u006e\u006b"{_cdea ,_dggcb :=_cabgc ._bedad ._dadec .(*StyledParagraph );if !_dggcb {_dbfc .nodeLogError (_cabgc ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_aabcea =true ;}else {_cfdaf =_cdea ._bafbd ;};break ;};};if _dcggd ==nil {_dcggd =NewTextChunk ("",_cfdaf );};for _ ,_eecge :=range _cabgc ._bcdgfa .Attr {_gfebc :=_eecge .Value ;switch _gfbce :=_eecge .Name .Local ;_gfbce {case "\u0063\u006f\u006co\u0072":_dcggd .Style .Color =_dbfc .parseColorAttr (_gfbce ,_gfebc );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_dcggd .Style .OutlineColor =_dbfc .parseColorAttr (_gfbce ,_gfebc );case "\u0066\u006f\u006e\u0074":_dcggd .Style .Font =_dbfc .parseFontAttr (_gfbce ,_gfebc );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_dcggd .Style .FontSize =_dbfc .parseFloatAttr (_gfbce ,_gfebc );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_dcggd .Style .OutlineSize =_dbfc .parseFloatAttr (_gfbce ,_gfebc );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_dcggd .Style .CharSpacing =_dbfc .parseFloatAttr (_gfbce ,_gfebc );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_dcggd .Style .HorizontalScaling =_dbfc .parseFloatAttr (_gfbce ,_gfebc );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_dcggd .Style .RenderingMode =_dbfc .parseTextRenderingModeAttr (_gfbce ,_gfebc );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_dcggd .Style .Underline =_dbfc .parseBoolAttr (_gfbce ,_gfebc );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_dcggd .Style .UnderlineStyle .Color =_dbfc .parseColorAttr (_gfbce ,_gfebc );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_dcggd .Style .UnderlineStyle .Offset =_dbfc .parseFloatAttr (_gfbce ,_gfebc );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_dcggd .Style .UnderlineStyle .Thickness =_dbfc .parseFloatAttr (_gfbce ,_gfebc );
case "\u006c\u0069\u006e\u006b":if !_aabcea {_dcggd .AddAnnotation (_dbfc .parseLinkAttr (_gfbce ,_gfebc ));};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_dcggd .Style .TextRise =_dbfc .parseFloatAttr (_gfbce ,_gfebc );default:_dbfc .nodeLogDebug (_cabgc ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_gfbce );
};};return _dcggd ,nil ;};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_eaaa *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_eaaa ._bea .Left =left ;_eaaa ._bea .Right =right ;_eaaa ._bea .Top =top ;_eaaa ._bea .Bottom =bottom ;};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_fdaaf *Line )SetMargins (left ,right ,top ,bottom float64 ){_fdaaf ._bfgab .Left =left ;_fdaaf ._bfgab .Right =right ;_fdaaf ._bfgab .Top =top ;_fdaaf ._bfgab .Bottom =bottom ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_fbda *List )Width ()float64 {return 0};func _bbca (_dbdde string )*_cb .PdfAnnotation {_gedg :=_cb .NewPdfAnnotationLink ();_bbfged :=_cb .NewBorderStyle ();_bbfged .SetBorderWidth (0);_gedg .BS =_bbfged .ToPdfObject ();_fcece :=_cb .NewPdfActionURI ();
_fcece .URI =_fac .MakeString (_dbdde );_gedg .SetAction (_fcece .PdfAction );return _gedg .PdfAnnotation ;};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_gbed *TOCLine )SetLevelOffset (levelOffset float64 ){_gbed ._ceacd =levelOffset ;_gbed ._gbgfg ._dcbc .Left =_gbed ._bdfbfc +float64 (_gbed ._gfga -1)*_gbed ._ceacd ;};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_fbedg *LinearShading )AddPatternResource (block *Block )(_gcbdb _fac .PdfObjectName ,_begd error ){_efab :=1;_dagf :=_fac .PdfObjectName ("\u0050"+_fa .Itoa (_efab ));for block ._bg .HasPatternByName (_dagf ){_efab ++;_dagf =_fac .PdfObjectName ("\u0050"+_fa .Itoa (_efab ));
};if _febe :=block ._bg .SetPatternByName (_dagf ,_fbedg .ToPdfShadingPattern ().ToPdfObject ());_febe !=nil {return "",_febe ;};return _dagf ,nil ;};func (_acbdf *StyledParagraph )appendChunk (_babfb *TextChunk )*TextChunk {_acbdf ._eaad =append (_acbdf ._eaad ,_babfb );
_acbdf .wrapText ();return _babfb ;};

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_fbbgf *Table )MultiRowCell (rowspan int )*TableCell {return _fbbgf .MultiCell (rowspan ,1)};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_acf *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _aegaed (number ,title ,page ,level ,style );};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_geebd *Table )MultiColCell (colspan int )*TableCell {return _geebd .MultiCell (1,colspan )};func _egfbb (_gfcdc string )(_gggf []float64 ,_bcba error ){var _edgff float64 ;_cfacg :=0;_eecgc :=true ;for _gbbecb ,_fdcaaf :=range _gfcdc {if _fdcaaf =='.'{if _eecgc {_eecgc =false ;
continue ;};_edgff ,_bcba =_cdadb (_gfcdc [_cfacg :_gbbecb ],64);if _bcba !=nil {return ;};_gggf =append (_gggf ,_edgff );_cfacg =_gbbecb ;};};_edgff ,_bcba =_cdadb (_gfcdc [_cfacg :],64);if _bcba !=nil {return ;};_gggf =append (_gggf ,_edgff );return ;
};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// SetBorderColor sets the cell's border color.
func (_ddabb *GridCell )SetBorderColor (col Color ){_ddabb ._feac =col ;_ddabb ._egfeg =col ;_ddabb ._fbfe =col ;_ddabb ._gbef =col ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// Positioning returns the type of positioning the ellipse is set to use.
func (_cgfa *Ellipse )Positioning ()Positioning {return _cgfa ._gcfb };

// NewPolygon creates a new polygon.
func (_egc *Creator )NewPolygon (points [][]_gga .Point )*Polygon {return _ffabg (points )};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_gdae *Table )EnableRowWrap (enable bool ){_gdae ._cacgg =enable };

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_dgfbf *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_dgfbf ._beagc =align ;};

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_bgece *Rectangle )BorderOpacity ()float64 {return _bgece ._fbfee };

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_gdbfa *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_gbce :=[2]*InvoiceCell {_gdbfa .newCell (description ,_gdbfa ._dcebd ),_gdbfa .newCell (value ,_gdbfa ._dcebd )};_gdbfa ._gade =append (_gdbfa ._gade ,_gbce );return _gbce [0],_gbce [1];
};func _bfgcg (_fgag *templateProcessor ,_cdfee *templateNode )(interface{},error ){return _fgag .parseStyledParagraph (_cdfee );};

// SetMaxLines sets the maximum number of lines to be drawn.
func (_ggdc *StyledParagraph )SetMaxLines (maxLines int ){_ggdc ._ffef =maxLines };

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_bgb *Line )Width ()float64 {return _a .Abs (_bgb ._abdb -_bgb ._cdbgd )};func (_aegdgg *TextChunk )Highlight (color Color ,alpha float64 )*_cb .PdfAnnotation {_afegd ,_aefde ,_bggbb :=color .ToRGB ();_caefd :=_cb .NewPdfAnnotationHighlight ();_caefd .C =_fac .MakeArrayFromFloats ([]float64 {_afegd ,_aefde ,_bggbb });
_caefd .CA =_fac .MakeFloat (alpha );_aegdgg .AddAnnotation (_caefd .PdfAnnotation );return _caefd .PdfAnnotation ;};

// SetWidthTop sets border width for top.
func (_cac *border )SetWidthTop (bw float64 ){_cac ._ddb =bw };

// SetWidth sets the width of the ellipse.
func (_afdec *Ellipse )SetWidth (width float64 ){_afdec ._gdfc =width };func (_efbc *Creator )setActivePage (_fcef *_cb .PdfPage ){_efbc ._fccgc =_fcef };

// SetBorderColor sets border color of the rectangle.
func (_ffgfga *Rectangle )SetBorderColor (col Color ){_ffgfga ._edcc =col };func (_beagde *templateProcessor )parseImage (_aacf *templateNode )(interface{},error ){var _feafd string ;for _ ,_ccgab :=range _aacf ._bcdgfa .Attr {_fdffe :=_ccgab .Value ;switch _ffgfa :=_ccgab .Name .Local ;
_ffgfa {case "\u0073\u0072\u0063":_feafd =_fdffe ;};};_fbdab ,_dfabe :=_beagde .loadImageFromSrc (_feafd );if _dfabe !=nil {return nil ,_dfabe ;};var _bdce _fac .StreamEncoder ;_ggbe :=_bd .ToLower (_c .Ext (_feafd ));if _ggbe =="\u006a\u0070\u0067"||_ggbe =="\u006a\u0070\u0065\u0067"{_bdce =_fac .NewDCTEncoder ();
}else {_bdce =_fac .NewFlateEncoder ();};_fbdab .SetEncoder (_bdce );for _ ,_fggccb :=range _aacf ._bcdgfa .Attr {_dgcf :=_fggccb .Value ;switch _deeba :=_fggccb .Name .Local ;_deeba {case "\u0061\u006c\u0069g\u006e":_fbdab .SetHorizontalAlignment (_beagde .parseHorizontalAlignmentAttr (_deeba ,_dgcf ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_fbdab .SetOpacity (_beagde .parseFloatAttr (_deeba ,_dgcf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_acebg :=_beagde .parseMarginAttr (_deeba ,_dgcf );_fbdab .SetMargins (_acebg .Left ,_acebg .Right ,_acebg .Top ,_acebg .Bottom );
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_fbdab .SetFitMode (_beagde .parseFitModeAttr (_deeba ,_dgcf ));case "\u0078":_fbdab .SetPos (_beagde .parseFloatAttr (_deeba ,_dgcf ),_fbdab ._ggcdc );case "\u0079":_fbdab .SetPos (_fbdab ._edbf ,_beagde .parseFloatAttr (_deeba ,_dgcf ));
case "\u0077\u0069\u0064t\u0068":_fbdab .SetWidth (_beagde .parseFloatAttr (_deeba ,_dgcf ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_fbdab .SetHeight (_beagde .parseFloatAttr (_deeba ,_dgcf ));case "\u0061\u006e\u0067l\u0065":_fbdab .SetAngle (_beagde .parseFloatAttr (_deeba ,_dgcf ));
case "\u0065n\u0063\u006f\u0064\u0065\u0072":_bdce =_beagde .parseImageEncoder (_deeba ,_dgcf );if _bdce !=nil {_fbdab .SetEncoder (_bdce );};case "\u0073\u0072\u0063":break ;default:_beagde .nodeLogDebug (_aacf ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_deeba );
};};return _fbdab ,nil ;};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_cbab *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_ada *_cb .PdfWriter )error ){_cbab ._cacf =pdfWriterAccessFunc ;};

// SetSideBorderColor sets the cell's side border color.
func (_cgggg *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_cgggg ._cgfdb =col ;_cgggg ._agac =col ;_cgggg ._bfaa =col ;_cgggg ._cbcac =col ;case CellBorderSideTop :_cgggg ._cgfdb =col ;case CellBorderSideBottom :_cgggg ._agac =col ;
case CellBorderSideLeft :_cgggg ._bfaa =col ;case CellBorderSideRight :_cgggg ._cbcac =col ;};};

// SetLineHeight sets the line height (1.0 default).
func (_deba *Paragraph )SetLineHeight (lineheight float64 ){_deba ._ccfga =lineheight };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline ,_fegffe :[]*_cb .PdfAnnotation {},_gabgdd :[]bool {}};};func (_ebda *TableCell )height (_bebdb float64 )float64 {var _bbbef float64 ;
switch _dfafd :=_ebda ._bgfcf .(type ){case *Paragraph :if _dfafd ._cbca {_dfafd .SetWidth (_bebdb -_ebda ._bbeab -_dfafd ._gebd .Left -_dfafd ._gebd .Right );};_bbbef =_dfafd .Height ()+_dfafd ._gebd .Top +_dfafd ._gebd .Bottom ;if !_ebda ._cecgbe ._aaca {_bbbef +=(0.5*_dfafd ._dbcd *_dfafd ._ccfga );
};case *StyledParagraph :if _dfafd ._cbcg {_dfafd .SetWidth (_bebdb -_ebda ._bbeab -_dfafd ._dcbc .Left -_dfafd ._dcbc .Right );};_bbbef =_dfafd .Height ()+_dfafd ._dcbc .Top +_dfafd ._dcbc .Bottom ;if !_ebda ._cecgbe ._aaca {_bbbef +=(0.5*_dfafd .getTextHeight ());
};case *Image :_dfafd .applyFitMode (_bebdb -_ebda ._bbeab );_bbbef =_dfafd .Height ()+_dfafd ._bcgd .Top +_dfafd ._bcgd .Bottom ;case *Table :_dfafd .updateRowHeights (_bebdb -_ebda ._bbeab -_dfafd ._gdfeg .Left -_dfafd ._gdfeg .Right );_bbbef =_dfafd .Height ()+_dfafd ._gdfeg .Top +_dfafd ._gdfeg .Bottom ;
case *List :_bbbef =_dfafd .ctxHeight (_bebdb -_ebda ._bbeab )+_dfafd ._feba .Top +_dfafd ._feba .Bottom ;case *Division :_bbbef =_dfafd .ctxHeight (_bebdb -_ebda ._bbeab )+_dfafd ._ccega .Top +_dfafd ._ccega .Bottom +_dfafd ._cacg .Top +_dfafd ._cacg .Bottom ;
case *Chart :_bbbef =_dfafd .Height ()+_dfafd ._dege .Top +_dfafd ._dege .Bottom ;case *Rectangle :_dfafd .applyFitMode (_bebdb -_ebda ._bbeab );_bbbef =_dfafd .Height ()+_dfafd ._gdea .Top +_dfafd ._gdea .Bottom +_dfafd ._afefe ;case *Ellipse :_dfafd .applyFitMode (_bebdb -_ebda ._bbeab );
_bbbef =_dfafd .Height ()+_dfafd ._dede .Top +_dfafd ._dede .Bottom ;case *Line :_bbbef =_dfafd .Height ()+_dfafd ._bfgab .Top +_dfafd ._bfgab .Bottom ;};return _bbbef ;};

// SetMargins sets the margins TOC line.
func (_fcebb *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_fcebb ._bdfbfc =left ;_bbfcc :=&_fcebb ._gbgfg ._dcbc ;_bbfcc .Left =_fcebb ._bdfbfc +float64 (_fcebb ._gfga -1)*_fcebb ._ceacd ;_bbfcc .Right =right ;_bbfcc .Top =top ;_bbfcc .Bottom =bottom ;
};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_aeg *Block )AddAnnotation (annotation *_cb .PdfAnnotation ){for _ ,_acg :=range _aeg ._ed {if _acg ==annotation {return ;};};_aeg ._ed =append (_aeg ._ed ,annotation );};func _fggb (_bgbfg *templateProcessor ,_ddadd *templateNode )(interface{},error ){return _bgbfg .parseLine (_ddadd );
};

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_afff *Rectangle )ScaleToWidth (w float64 ){_daadc :=_afff ._baadd /_afff ._ggcb ;_afff ._ggcb =w ;_afff ._baadd =w *_daadc ;};

// SetLevel sets the indentation level of the TOC line.
func (_eegdg *TOCLine )SetLevel (level uint ){_eegdg ._gfga =level ;_eegdg ._gbgfg ._dcbc .Left =_eegdg ._bdfbfc +float64 (_eegdg ._gfga -1)*_eegdg ._ceacd ;};

// SetColorBottom sets border color for bottom.
func (_dad *border )SetColorBottom (col Color ){_dad ._ddc =col };type templateProcessor struct{creator *Creator ;_ddfcb []byte ;_debae *TemplateOptions ;_fceeg componentRenderer ;_eabee string ;};

// Title returns the title of the invoice.
func (_efbbd *Invoice )Title ()string {return _efbbd ._baggf };func (_eacb *StyledParagraph )getMaxLineWidth ()float64 {if _eacb ._ebbfe ==nil ||(_eacb ._ebbfe !=nil &&len (_eacb ._ebbfe )==0){_eacb .wrapText ();};var _gdcdd float64 ;for _ ,_beacb :=range _eacb ._ebbfe {_bdgfe :=_eacb .getTextLineWidth (_beacb );
if _bdgfe > _gdcdd {_gdcdd =_bdgfe ;};};return _gdcdd ;};

// Style returns the style of the line.
func (_bbdc *Line )Style ()_gga .LineStyle {return _bbdc ._gcege };func (_gaea *commands )isCommand (_afbgf string )bool {for _ ,_cbabea :=range _gaea ._dbdac {if _bd .ToLower (_afbgf )==_cbabea {return true ;};};return false ;};func (_decbde *templateProcessor )parseRadialGradientAttr (creator *Creator ,_ggbcb string )Color {_aacaa :=ColorBlack ;
if _ggbcb ==""{return _aacaa ;};var (_gcbae error ;_gbbbg =0.0;_cfdeae =0.0;_dbdfg =-1.0;_ecea =_bd .Split (_ggbcb [16:len (_ggbcb )-1],"\u002c"););_gaebd :=_bd .Fields (_ecea [0]);if len (_gaebd )==2&&_bd .TrimSpace (_gaebd [0])[0]!='#'{_gbbbg ,_gcbae =_fa .ParseFloat (_gaebd [0],64);
if _gcbae !=nil {_gg .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_gcbae );
};_cfdeae ,_gcbae =_fa .ParseFloat (_gaebd [1],64);if _gcbae !=nil {_gg .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_gcbae );
};_ecea =_ecea [1:];};_dabbe :=_bd .TrimSpace (_ecea [0]);if _dabbe [0]!='#'{_dbdfg ,_gcbae =_fa .ParseFloat (_dabbe ,64);if _gcbae !=nil {_gg .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_gcbae );
};_ecea =_ecea [1:];};_dadc ,_defeed :=_decbde .processGradientColorPair (_ecea );if _dadc ==nil ||_defeed ==nil {return _aacaa ;};_bbgfb :=creator .NewRadialGradientColor (_gbbbg ,_cfdeae ,0,_dbdfg ,[]*ColorPoint {});for _ccfag :=0;_ccfag < len (_dadc );
_ccfag ++{_bbgfb .AddColorStop (_dadc [_ccfag ],_defeed [_ccfag ]);};return _bbgfb ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _gdgg ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_fgg :=&Creator {};_fgg ._adce =[]*_cb .PdfPage {};_fgg ._cgaf =map[*_cb .PdfPage ]*Block {};_fgg ._ebgc =map[*_cb .PdfPage ]*pageTransformations {};_fgg .SetPageSize (PageSizeLetter );
_dbd :=0.1*_fgg ._eegg ;_fgg ._bea .Left =_dbd ;_fgg ._bea .Right =_dbd ;_fgg ._bea .Top =_dbd ;_fgg ._bea .Bottom =_dbd ;var _gdcd error ;_fgg ._ebd ,_gdcd =_cb .NewStandard14Font (_cb .HelveticaName );if _gdcd !=nil {_fgg ._ebd =_cb .DefaultFont ();};
_fgg ._fgcgd ,_gdcd =_cb .NewStandard14Font (_cb .HelveticaBoldName );if _gdcd !=nil {_fgg ._ebd =_cb .DefaultFont ();};_fgg ._fbc =_fgg .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_fgg .AddOutlines =true ;
_fgg ._gbcd =_cb .NewOutline ();_af .TrackUse (_gdgg );return _fgg ;};

// SetMargins sets the margins of the paragraph.
func (_gebag *List )SetMargins (left ,right ,top ,bottom float64 ){_gebag ._feba .Left =left ;_gebag ._feba .Right =right ;_gebag ._feba .Top =top ;_gebag ._feba .Bottom =bottom ;};var _dbdfb commands ;

// SetStyle sets paragraph style for all chunks.
func (_dfec *StyledParagraph )SetStyle (style TextStyle ){_dfec ._eeaba =style ;for _ ,_gaeff :=range _dfec ._eaad {_gaeff .Style =style ;};};

// NewChapter creates a new chapter with the specified title as the heading.
func (_dggc *Creator )NewChapter (title string )*Chapter {_dggc ._aedd ++;_bfdbb :=_dggc .NewTextStyle ();_bfdbb .FontSize =16;return _bbb (nil ,_dggc ._fbc ,_dggc ._gbcd ,title ,_dggc ._aedd ,_bfdbb );};func _bbb (_ggdg *Chapter ,_ece *TOC ,_edff *_cb .Outline ,_ffa string ,_bafd int ,_dcc TextStyle )*Chapter {var _bfbd uint =1;
if _ggdg !=nil {_bfbd =_ggdg ._fcf +1;};_adca :=&Chapter {_ffg :_bafd ,_cgbg :_ffa ,_cdce :true ,_cdeb :true ,_edc :_ggdg ,_fgaf :_ece ,_eeee :_edff ,_ebcc :[]Drawable {},_fcf :_bfbd };_bdga :=_cedfb (_dcc );_aebe :=_bdga .SetText (_adca .headingText ());
_aebe .Style =_dcc ;_adca ._egea =_bdga ;return _adca ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_faced *Table )SetPos (x ,y float64 ){_faced ._gccec =PositionAbsolute ;_faced ._cffd =x ;_faced ._ddagg =y ;};

// GeneratePageBlocks draws the chart onto a block.
func (_fgfd *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_faf :=ctx ;_acgg :=_fgfd ._cbbd .IsRelative ();var _dbfe []*Block ;if _acgg {_fdgg :=1.0;_dccb :=_fgfd ._dege .Top ;if float64 (_fgfd ._degg .Height ())> ctx .Height -_fgfd ._dege .Top {_dbfe =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _gege error ;if _ ,ctx ,_gege =_bbbe ().GeneratePageBlocks (ctx );_gege !=nil {return nil ,ctx ,_gege ;};_dccb =0;};ctx .X +=_fgfd ._dege .Left +_fdgg ;ctx .Y +=_dccb ;ctx .Width -=_fgfd ._dege .Left +_fgfd ._dege .Right +2*_fdgg ;ctx .Height -=_dccb ;
_fgfd ._degg .SetWidth (int (ctx .Width ));}else {ctx .X =_fgfd ._dfbd ;ctx .Y =_fgfd ._fae ;};_dagd :=_ae .NewContentCreator ();if _fgfd ._ebb !=nil {_dagd .Add_BDC (*_fac .MakeName (_cb .StructureTypeFigure ),map[string ]_fac .PdfObject {"\u004d\u0043\u0049\u0044":_fac .MakeInteger (*_fgfd ._ebb )});
};_dagd .Translate (0,ctx .PageHeight );_dagd .Scale (1,-1);_dagd .Translate (ctx .X ,ctx .Y );_eaga :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fgfd ._degg .Render (_cab .NewRenderer (_dagd ,_eaga ._bg ),nil );if _fgfd ._ebb !=nil {_dagd .Add_EMC ();
};if _deagc :=_eaga .addContentsByString (_dagd .String ());_deagc !=nil {return nil ,ctx ,_deagc ;};if _acgg {_begg :=_fgfd .Height ()+_fgfd ._dege .Bottom ;ctx .Y +=_begg ;ctx .Height -=_begg ;}else {ctx =_faf ;};_dbfe =append (_dbfe ,_eaga );return _dbfe ,ctx ,nil ;
};

// Width returns the width of the Paragraph.
func (_edcd *Paragraph )Width ()float64 {if _edcd ._cbca &&int (_edcd ._egeg )> 0{return _edcd ._egeg ;};return _edcd .getTextWidth ()/1000.0;};func _bdfbf (_aaece ...interface{})(map[string ]interface{},error ){_cegdd :=len (_aaece );if _cegdd %2!=0{_gg .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_cegdd );
return nil ,_fac .ErrRangeError ;};_aecc :=map[string ]interface{}{};for _fdad :=0;_fdad < _cegdd ;_fdad +=2{_dedbbd ,_ccafa :=_aaece [_fdad ].(string );if !_ccafa {_gg .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_aaece [_fdad ]);
return nil ,_fac .ErrTypeError ;};_aecc [_dedbbd ]=_aaece [_fdad +1];};return _aecc ,nil ;};func _aacd (_ccaeb []*_cb .PdfAnnotation )[]*_cb .PdfAnnotation {var _dfbcg []*_cb .PdfAnnotation ;for _ ,_cfgad :=range _ccaeb {_dfbcg =append (_dfbcg ,_ceedc (_cfgad ));
};return _dfbcg ;};

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_ceef *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _eeacf (colorPoints );};func _bfcfe (_acfbe *_cb .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_acfbe ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_gdcdf *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gdcdf ._bfgab .Left ,_gdcdf ._bfgab .Right ,_gdcdf ._bfgab .Top ,_gdcdf ._bfgab .Bottom ;};

// SetBorderColor sets the border color.
func (_eaaf *Polygon )SetBorderColor (color Color ){_eaaf ._bbbb .BorderColor =_cdfd (color )};func (_gdecd *TOCLine )getLineLink ()*_cb .PdfAnnotation {if _gdecd ._ecffff <=0{return nil ;};return _eebc (_gdecd ._ecffff -1,_gdecd ._dgag ,_gdecd ._beebg ,0);
};

// SetLogo sets the logo of the invoice.
func (_aacg *Invoice )SetLogo (logo *Image ){_aacg ._efad =logo };

// AddTotalLine adds a new line in the invoice totals table.
func (_fggec *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_bgeb :=&InvoiceCell {_fggec ._afca ,desc };_cege :=&InvoiceCell {_fggec ._afca ,value };_fggec ._cfgga =append (_fggec ._cfgga ,[2]*InvoiceCell {_bgeb ,_cege });return _bgeb ,_cege ;
};func (_egcge *templateProcessor )parseStyledParagraph (_dbdae *templateNode )(interface{},error ){_ddbda :=_egcge .creator .NewStyledParagraph ();for _ ,_aegdd :=range _dbdae ._bcdgfa .Attr {_ddcc :=_aegdd .Value ;switch _gdggg :=_aegdd .Name .Local ;
_gdggg {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_ddbda .SetTextAlignment (_egcge .parseTextAlignmentAttr (_gdggg ,_ddcc ));case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_ddbda .SetTextVerticalAlignment (_egcge .parseTextVerticalAlignmentAttr (_gdggg ,_ddcc ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_ddbda .SetLineHeight (_egcge .parseFloatAttr (_gdggg ,_ddcc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cfeaa :=_egcge .parseMarginAttr (_gdggg ,_ddcc );_ddbda .SetMargins (_cfeaa .Left ,_cfeaa .Right ,_cfeaa .Top ,_cfeaa .Bottom );
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_ddbda .SetEnableWrap (_egcge .parseBoolAttr (_gdggg ,_ddcc ));case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_ddbda .EnableWordWrap (_egcge .parseBoolAttr (_gdggg ,_ddcc ));
case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_ddbda .SetTextOverflow (_egcge .parseTextOverflowAttr (_gdggg ,_ddcc ));case "\u0078":_ddbda .SetPos (_egcge .parseFloatAttr (_gdggg ,_ddcc ),_ddbda ._ecdab );case "\u0079":_ddbda .SetPos (_ddbda ._bged ,_egcge .parseFloatAttr (_gdggg ,_ddcc ));
case "\u0061\u006e\u0067l\u0065":_ddbda .SetAngle (_egcge .parseFloatAttr (_gdggg ,_ddcc ));default:_egcge .nodeLogDebug (_dbdae ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gdggg );
};};return _ddbda ,nil ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_fdgeb *TOC )SetShowLinks (showLinks bool ){_fdgeb ._baeda =showLinks };

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_edfg *Invoice )SetAddressHeadingStyle (style TextStyle ){_edfg ._cfbde =style };

// NewImageFromFile creates an Image from a file.
func (_cbdb *Creator )NewImageFromFile (path string )(*Image ,error ){return _gbbc (path )};

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_gffb *LinearShading )SetAngle (angle float64 ){_gffb ._bgcff =angle };func _dagc (_dfggd []float64 )[]float64 {for _afce ,_ecgf :=0,len (_dfggd )-1;_afce < _ecgf ;_afce ,_ecgf =_afce +1,_ecgf -1{_dfggd [_afce ],_dfggd [_ecgf ]=_dfggd [_ecgf ],_dfggd [_afce ];
};return _dfggd ;};func _edbde (_beac []_gga .Point )*Polyline {return &Polyline {_daeaf :&_gga .Polyline {Points :_beac ,LineColor :_cb .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_bfbg :1.0};};func (_ebgaa *templateProcessor )processGradientColorPair (_dgeg []string )(_ceeab []Color ,_edeb []float64 ){for _ ,_efedg :=range _dgeg {var (_dedaa =_bd .Fields (_efedg );
_bceac =len (_dedaa ););if _bceac ==0{continue ;};_bacecc :="";if _bceac > 1{_bacecc =_bd .TrimSpace (_dedaa [1]);};_bcdac :=-1.0;if _bd .HasSuffix (_bacecc ,"\u0025"){_adeff ,_fcebee :=_fa .ParseFloat (_bacecc [:len (_bacecc )-1],64);if _fcebee !=nil {_gg .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_fcebee );
};_bcdac =_adeff /100.0;};_affbb :=_ebgaa .parseColor (_bd .TrimSpace (_dedaa [0]));if _affbb !=nil {_ceeab =append (_ceeab ,_affbb );_edeb =append (_edeb ,_bcdac );};};if len (_ceeab )!=len (_edeb ){_gg .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_dcfec :=-1;_gefge :=0.0;for _ccbbf ,_efega :=range _edeb {if _efega ==-1.0{if _ccbbf ==0{_efega =0.0;_edeb [_ccbbf ]=0.0;continue ;};_dcfec ++;if _ccbbf < len (_edeb )-1{continue ;}else {_efega =1.0;_edeb [_ccbbf ]=1.0;};};_bacfd :=_dcfec +1;
for _acgcf :=_ccbbf -_dcfec ;_acgcf < _ccbbf ;_acgcf ++{_edeb [_acgcf ]=_gefge +(float64 (_acgcf )*(_efega -_gefge )/float64 (_bacfd ));};_gefge =_efega ;_dcfec =-1;};return _ceeab ,_edeb ;};func (_bccd *templateProcessor )parseLineStyleAttr (_becbd ,_gfafa string )_gga .LineStyle {_gg .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_becbd ,_gfafa );
_geab :=map[string ]_gga .LineStyle {"\u0073\u006f\u006ci\u0064":_gga .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_gga .LineStyleDashed }[_gfafa ];return _geab ;};func (_gfggc *templateProcessor )parseCellBorderStyleAttr (_dgcb ,_cbcge string )CellBorderStyle {_gg .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_dgcb ,_cbcge );
_bafgff :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_cbcge ];return _bafgff ;};

// SetMakedContentID sets the marked content id for the table.
func (_cgeee *Table )SetMarkedContentID (mcid int64 )*_cb .KDict {return nil };

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_dca *Block )Draw (d Drawable )error {_ega :=DrawContext {};_ega .Width =_dca ._db ;_ega .Height =_dca ._ecf ;_ega .PageWidth =_dca ._db ;_ega .PageHeight =_dca ._ecf ;_ega .X =0;_ega .Y =0;_cag ,_ ,_ccc :=d .GeneratePageBlocks (_ega );if _ccc !=nil {return _ccc ;
};if len (_cag )!=1{return ErrContentNotFit ;};for _ ,_cfa :=range _cag {if _fed :=_dca .mergeBlocks (_cfa );_fed !=nil {return _fed ;};};return nil ;};func _bec (_cgac *GraphicSVGElement )(*GraphicSVG ,error ){return &GraphicSVG {_bggb :_cgac ,_gcda :PositionRelative ,_badf :Margins {Top :10,Bottom :10}},nil ;
};

// TOC returns the table of contents component of the creator.
func (_cgge *Creator )TOC ()*TOC {return _cgge ._fbc };

// Height returns Image's document height.
func (_ffgb *Image )Height ()float64 {return _ffgb ._efag };func (_ecdabb *templateProcessor )parseCellVerticalAlignmentAttr (_fadbc ,_ecfffd string )CellVerticalAlignment {_gg .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fadbc ,_ecfffd );
_ccgg :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_ecfffd ];return _ccgg ;};


// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// ColorGrayFromArithmetic creates a Color from a grayscale value (0-1).
// Example:
//
//	gray := ColorGrayFromArithmetic(0.7)
func ColorGrayFromArithmetic (g float64 )Color {return grayColor {g }};func (_febf *GraphicSVGElement )drawEllipse (_bbfdc *_ae .ContentCreator ,_adfc *_cb .PdfPageResources ){_bbfdc .Add_q ();_febf .Style .toContentStream (_bbfdc ,_adfc ,_febf );_gafg ,_efabb :=_cdadb (_febf .Attributes ["\u0063\u0078"],64);
if _efabb !=nil {_gg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_efabb .Error ());};_agegg ,_efabb :=_cdadb (_febf .Attributes ["\u0063\u0079"],64);
if _efabb !=nil {_gg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_efabb .Error ());};_gcffg ,_efabb :=_cdadb (_febf .Attributes ["\u0072\u0078"],64);
if _efabb !=nil {_gg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_efabb .Error ());};_gcaa ,_efabb :=_cdadb (_febf .Attributes ["\u0072\u0079"],64);
if _efabb !=nil {_gg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_efabb .Error ());};_eeeab :=_gcffg *_febf ._dfgb ;
_fgdef :=_gcaa *_febf ._dfgb ;_gdgd :=_gafg *_febf ._dfgb ;_deac :=_agegg *_febf ._dfgb ;_acea :=_eeeab *_gabb ;_adab :=_fgdef *_gabb ;_gbbea :=_gga .NewCubicBezierPath ();_gbbea =_gbbea .AppendCurve (_gga .NewCubicBezierCurve (-_eeeab ,0,-_eeeab ,_adab ,-_acea ,_fgdef ,0,_fgdef ));
_gbbea =_gbbea .AppendCurve (_gga .NewCubicBezierCurve (0,_fgdef ,_acea ,_fgdef ,_eeeab ,_adab ,_eeeab ,0));_gbbea =_gbbea .AppendCurve (_gga .NewCubicBezierCurve (_eeeab ,0,_eeeab ,-_adab ,_acea ,-_fgdef ,0,-_fgdef ));_gbbea =_gbbea .AppendCurve (_gga .NewCubicBezierCurve (0,-_fgdef ,-_acea ,-_fgdef ,-_eeeab ,-_adab ,-_eeeab ,0));
_gbbea =_gbbea .Offset (_gdgd ,_deac );if _febf .Style .StrokeWidth > 0{_gbbea =_gbbea .Offset (_febf .Style .StrokeWidth /2,_febf .Style .StrokeWidth /2);};_gga .DrawBezierPathWithCreator (_gbbea ,_bbfdc );_febf .Style .fillStroke (_bbfdc );_bbfdc .Add_h ();
_bbfdc .Add_Q ();};func (_cgfdbg *templateProcessor )parsePageBreak (_bafbb *templateNode )(interface{},error ){return _bbbe (),nil ;};func _eeacf (_ebcdg []*ColorPoint )*LinearShading {return &LinearShading {_fafde :&shading {_acggc :ColorWhite ,_fbada :false ,_aadd :[]bool {false ,false },_bcbgf :_ebcdg },_bcfdf :&_cb .PdfRectangle {}};
};

// Positioning returns the type of positioning the rectangle is set to use.
func (_bcbc *Rectangle )Positioning ()Positioning {return _bcbc ._fdfc };

// Text sets the text content of the Paragraph.
func (_acaf *Paragraph )Text ()string {return _acaf ._caec };

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_dacef *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_gcebc :=&_dacef ._ddbbfe ;_gcebc .Left =left ;_gcebc .Right =right ;_gcebc .Top =top ;_gcebc .Bottom =bottom ;};func _cgebg (_gdebg ,_ddea ,_cdec int )[]int {_dfda :=[]int {};for _aedafd :=_gdebg ;
_aedafd <=_cdec ;_aedafd +=_ddea {_dfda =append (_dfda ,_aedafd );};return _dfda ;};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_gcccc *Table )EnablePageWrap (enable bool ){_gcccc ._adfab =enable };

// SetMarkedContentID sets marked content ID.
func (_ggbc *Curve )SetMarkedContentID (mcid int64 )*_cb .KDict {_ggbc ._bafg =&mcid ;_fbdf :=_cb .NewKDictionary ();_fbdf .S =_fac .MakeName (_cb .StructureTypeFigure );_fbdf .K =_fac .MakeInteger (mcid );return _fbdf ;};func _cdadb (_dbcde string ,_acab int )(float64 ,error ){_fdbe ,_gfegg :=_ffcbd (_dbcde );
_fggfc ,_faac :=_fa .ParseFloat (_fdbe ,_acab );if _faac !=nil {return 0,_faac ;};if _adeac ,_aacgfb :=_gefe [_gfegg ];_aacgfb {_fggfc =_fggfc *_adeac ;}else {_fggfc =_fggfc *_aedf ;};return _fggfc ,nil ;};

// NewList creates a new list.
func (_cefae *Creator )NewList ()*List {return _gbcce (_cefae .NewTextStyle ())};

// SetAngle sets the rotation angle of the text.
func (_beggd *StyledParagraph )SetAngle (angle float64 ){_beggd ._dbcga =angle };

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_gbcfa *Creator )Flip (flipH ,flipV bool )error {_cbbc :=_gbcfa .getActivePage ();if _cbbc ==nil {return _ff .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_begea ,_cdad :=_gbcfa ._ebgc [_cbbc ];if !_cdad {_begea =&pageTransformations {};
_gbcfa ._ebgc [_cbbc ]=_begea ;};_begea ._bbgc =flipH ;_begea ._ccff =flipV ;return nil ;};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_dcefdg *Division )EnablePageWrap (enable bool ){_dcefdg ._gccg =enable };

// CurRow returns the currently active cell's row number.
func (_edcf *Table )CurRow ()int {_cdbf :=(_edcf ._ffec -1)/_edcf ._cfgeg +1;return _cdbf };func _eccd (_feag _g .Image )(*Image ,error ){_baffb ,_abbg :=_cb .ImageHandling .NewImageFromGoImage (_feag );if _abbg !=nil {return nil ,_abbg ;};return _bff (_baffb );
};func _faebe (_ccca *templateProcessor ,_gbebec *templateNode )(interface{},error ){return _ccca .parseListItem (_gbebec );};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_fdfda *RadialShading )AddShadingResource (block *Block )(_ecac _fac .PdfObjectName ,_aaeae error ){_adcaf :=1;_ecac =_fac .PdfObjectName ("\u0053\u0068"+_fa .Itoa (_adcaf ));for block ._bg .HasShadingByName (_ecac ){_adcaf ++;_ecac =_fac .PdfObjectName ("\u0053\u0068"+_fa .Itoa (_adcaf ));
};if _dggeg :=block ._bg .SetShadingByName (_ecac ,_fdfda .shadingModel ().ToPdfObject ());_dggeg !=nil {return "",_dggeg ;};return _ecac ,nil ;};func (_cge *Grid )resetColumnWidths (){_cge ._ggcd =[]float64 {};_eead :=float64 (1.0)/float64 (_cge ._eedbe );
for _agabbd :=0;_agabbd < _cge ._eedbe ;_agabbd ++{_cge ._ggcd =append (_cge ._ggcd ,_eead );};};func (_fcege *shading )generatePdfFunctions ()[]_cb .PdfFunction {if len (_fcege ._bcbgf )==0{return nil ;}else if len (_fcege ._bcbgf )<=2{_eagfb ,_ffbg ,_faega :=_fcege ._bcbgf [0]._cafb .ToRGB ();
_gegdd ,_cadba ,_deabb :=_fcege ._bcbgf [len (_fcege ._bcbgf )-1]._cafb .ToRGB ();return []_cb .PdfFunction {&_cb .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_eagfb ,_ffbg ,_faega },C1 :[]float64 {_gegdd ,_cadba ,_deabb }}};
}else {_aeggf :=[]_cb .PdfFunction {};_cabfa :=[]float64 {};for _efbfeb :=0;_efbfeb < len (_fcege ._bcbgf )-1;_efbfeb ++{_gaffa ,_babf ,_dcbfb :=_fcege ._bcbgf [_efbfeb ]._cafb .ToRGB ();_dbff ,_cebd ,_acbf :=_fcege ._bcbgf [_efbfeb +1]._cafb .ToRGB ();
_deddc :=&_cb .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_gaffa ,_babf ,_dcbfb },C1 :[]float64 {_dbff ,_cebd ,_acbf }};_aeggf =append (_aeggf ,_deddc );if _efbfeb > 0{_cabfa =append (_cabfa ,_fcege ._bcbgf [_efbfeb ]._fafb );
};};_dgad :=[]float64 {};for range _aeggf {_dgad =append (_dgad ,[]float64 {0.0,1.0}...);};return []_cb .PdfFunction {&_cb .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_aeggf ,Bounds :_cabfa ,Encode :_dgad }};
};};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_adbed *RadialShading )AddPatternResource (block *Block )(_faceg _fac .PdfObjectName ,_gacgc error ){_fdea :=1;_bgff :=_fac .PdfObjectName ("\u0050"+_fa .Itoa (_fdea ));for block ._bg .HasPatternByName (_bgff ){_fdea ++;_bgff =_fac .PdfObjectName ("\u0050"+_fa .Itoa (_fdea ));
};if _dfdd :=block ._bg .SetPatternByName (_bgff ,_adbed .ToPdfShadingPattern ().ToPdfObject ());_dfdd !=nil {return "",_dfdd ;};return _bgff ,nil ;};func (_fdaca *templateProcessor )parseChapterHeading (_eace *templateNode )(interface{},error ){if _eace ._bedad ==nil {_fdaca .nodeLogError (_eace ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_fbcba ;};_fdcdea ,_dgece :=_eace ._bedad ._dadec .(*Chapter );if !_dgece {_fdaca .nodeLogError (_eace ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_eace ._bedad ._dadec );
return nil ,_fbcba ;};_cagef :=_fdcdea .GetHeading ();if _ ,_cccdd :=_fdaca .parseParagraph (_eace ,_cagef );_cccdd !=nil {return nil ,_cccdd ;};return _cagef ,nil ;};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _eb .ChartRenderable )*Chart {return _bbdg (chart )};

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_ggcbe *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_ggcbe ._bfdd =textOverflow ;};

// SetLazy sets the lazy mode for the image.
func (_dcecb *Image )SetLazy (lazy bool ){_dcecb ._ccefc =lazy };

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_cdbgd float64 ;_bggef float64 ;_abdb float64 ;_ecff float64 ;_ccfeb Color ;_gcege _gga .LineStyle ;_gddge float64 ;_cfcb []int64 ;_affb int64 ;_fcfg float64 ;_fcfa Positioning ;_fdgd FitMode ;_bfgab Margins ;_gcfg *int64 ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_gace *Table )NewCell ()*TableCell {return _gace .MultiCell (1,1)};

// SetStructTreeRoot sets the structure tree root to be appended in the document that will be created.
func (_bfge *Creator )SetStructTreeRoot (structTreeRoot *_cb .StructTreeRoot ){_bfge ._daae =structTreeRoot ;};func _gbcce (_afafb TextStyle )*List {return &List {_gbaeb :TextChunk {Text :"\u2022\u0020",Style :_afafb },_fdb :0,_cedb :true ,_ffbad :PositionRelative ,_aabgb :_afafb };
};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default, it occupies the available width in the drawing context.
//
// Deprecated: This object is deprecated and will be removed in future versions.
//
// Use StyledParagraph instead as it provides more features and is more flexible.
type Paragraph struct{_caec string ;_effad *_cb .PdfFont ;_dbcd float64 ;_ccfga float64 ;_dcfc Color ;_bfgaa TextAlignment ;_cbca bool ;_egeg float64 ;_fgggce int ;_cdgge bool ;_gbagg float64 ;_gebd Margins ;_fefd Positioning ;_dbcg float64 ;_dgfba float64 ;
_afade ,_fcbd float64 ;_ffff []string ;_aaec *int64 ;_adae string ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_cdace *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _cdace ._cdbgd ,_cdace ._bggef ,_cdace ._abdb ,_cdace ._ecff ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_cb .PdfPage )(*Block ,error ){_be :=&Block {};_ea ,_gbc :=page .GetAllContentStreams ();if _gbc !=nil {return nil ,_gbc ;};_gda :=_ae .NewContentStreamParser (_ea );_fbb ,_gbc :=_gda .Parse ();if _gbc !=nil {return nil ,_gbc ;
};_fbb .WrapIfNeeded ();_be ._fd =_fbb ;if page .Resources !=nil {_be ._bg =page .Resources ;}else {_be ._bg =_cb .NewPdfPageResources ();};_bdd ,_gbc :=page .GetMediaBox ();if _gbc !=nil {return nil ,_gbc ;};if _bdd .Llx !=0||_bdd .Lly !=0{_be .translate (-_bdd .Llx ,_bdd .Lly );
};_be ._db =_bdd .Urx -_bdd .Llx ;_be ._ecf =_bdd .Ury -_bdd .Lly ;if page .Rotate !=nil {_be ._ccb =-float64 (*page .Rotate );};return _be ,nil ;};func (_eaed *Invoice )drawAddress (_cbfg *InvoiceAddress )[]*StyledParagraph {var _abea []*StyledParagraph ;
if _cbfg .Heading !=""{_dacb :=_cedfb (_eaed ._cfbde );_dacb .SetMargins (0,0,0,7);_dacb .Append (_cbfg .Heading );_abea =append (_abea ,_dacb );};_eaab :=_cedfb (_eaed ._adeb );_eaab .SetLineHeight (1.2);_ddgd :=_cbfg .Separator ;if _ddgd ==""{_ddgd =_eaed ._egbd ;
};_egeae :=_cbfg .City ;if _cbfg .State !=""{if _egeae !=""{_egeae +=_ddgd ;};_egeae +=_cbfg .State ;};if _cbfg .Zip !=""{if _egeae !=""{_egeae +=_ddgd ;};_egeae +=_cbfg .Zip ;};if _cbfg .Name !=""{_eaab .Append (_cbfg .Name +"\u000a");};if _cbfg .Street !=""{_eaab .Append (_cbfg .Street +"\u000a");
};if _cbfg .Street2 !=""{_eaab .Append (_cbfg .Street2 +"\u000a");};if _egeae !=""{_eaab .Append (_egeae +"\u000a");};if _cbfg .Country !=""{_eaab .Append (_cbfg .Country +"\u000a");};_afgc :=_cedfb (_eaed ._adeb );_afgc .SetLineHeight (1.2);_afgc .SetMargins (0,0,7,0);
if _cbfg .Phone !=""{_afgc .Append (_cbfg .fmtLine (_cbfg .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_cbfg .HidePhoneLabel ));};if _cbfg .Email !=""{_afgc .Append (_cbfg .fmtLine (_cbfg .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_cbfg .HideEmailLabel ));
};_abea =append (_abea ,_eaab ,_afgc );return _abea ;};

// SetCoords sets the center coordinates of the ellipse.
func (_bbec *Ellipse )SetCoords (xc ,yc float64 ){_bbec ._dada =xc ;_bbec ._dfdg =yc };

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_deg *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eefa :=ctx ;if _deg ._dfca .IsRelative (){ctx .X +=_deg ._afcg .Left ;ctx .Y +=_deg ._afcg .Top ;ctx .Width -=_deg ._afcg .Left +_deg ._afcg .Right ;ctx .Height -=_deg ._afcg .Top ;
};_bcd ,_gbeb ,_fdef :=_deg ._egea .GeneratePageBlocks (ctx );if _fdef !=nil {return _bcd ,ctx ,_fdef ;};ctx =_gbeb ;_egd :=ctx .X ;_fgec :=ctx .Y -_deg ._egea .Height ();_dgc :=int64 (ctx .Page );_ffb :=_deg .headingNumber ();_edg :=_deg .headingText ();
if _deg ._cdeb {_adb :=_deg ._fgaf .Add (_ffb ,_deg ._cgbg ,_fa .FormatInt (_dgc ,10),_deg ._fcf );if _deg ._fgaf ._baeda {_adb .SetLink (_dgc ,_egd ,_fgec );};};if _deg ._dda ==nil {_deg ._dda =_cb .NewOutlineItem (_edg ,_cb .NewOutlineDest (_dgc -1,_egd ,_fgec ));
if _deg ._edc !=nil {_deg ._edc ._dda .Add (_deg ._dda );}else {_deg ._eeee .Add (_deg ._dda );};}else {_acd :=&_deg ._dda .Dest ;_acd .Page =_dgc -1;_acd .X =_egd ;_acd .Y =_fgec ;};for _ ,_edfd :=range _deg ._ebcc {_fcee ,_agag ,_cfe :=_edfd .GeneratePageBlocks (ctx );
if _cfe !=nil {return _bcd ,ctx ,_cfe ;};if len (_fcee )< 1{continue ;};_bcd [len (_bcd )-1].mergeBlocks (_fcee [0]);_bcd =append (_bcd ,_fcee [1:]...);ctx =_agag ;};if _deg ._dfca .IsRelative (){ctx .X =_eefa .X ;};if _deg ._dfca .IsAbsolute (){return _bcd ,_eefa ,nil ;
};return _bcd ,ctx ,nil ;};

// FitMode returns the fit mode of the ellipse.
func (_dgfb *Ellipse )FitMode ()FitMode {return _dgfb ._dddb };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_gcfa *TOC )SetHeading (text string ,style TextStyle ){_efafa :=_gcfa .Heading ();_efafa .Reset ();_ccge :=_efafa .Append (text );_ccge .Style =style ;};

// NewGrid creates a new Grid with a specified number of columns.
func (_adef *Creator )NewGrid (cols int )*Grid {return _gcff (cols )};func (_ecda *Invoice )newCell (_cecg string ,_aefg InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_aefg ,_cecg };};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_gbfda *LinearShading )SetAntiAlias (enable bool ){_gbfda ._fafde .SetAntiAlias (enable )};

// SetFillOpacity sets the fill opacity of the ellipse.
func (_agf *Ellipse )SetFillOpacity (opacity float64 ){_agf ._abdd =opacity };func _cbabe (_gge ,_fefa ,_cefd ,_eece ,_gbga ,_cea float64 )*Curve {_cdfb :=&Curve {};_cdfb ._cccg =_gge ;_cdfb ._dgdb =_fefa ;_cdfb ._cfeb =_cefd ;_cdfb ._fbfg =_eece ;_cdfb ._feec =_gbga ;
_cdfb ._dgdbc =_cea ;_cdfb ._agb =ColorBlack ;_cdfb ._aff =1.0;return _cdfb ;};

// SetMarkedContentID sets the marked content ID.
func (_aecea *Rectangle )SetMarkedContentID (mcid int64 )*_cb .KDict {_aecea ._gfeca =&mcid ;_gead :=_cb .NewKDictionary ();_gead .S =_fac .MakeName (_cb .StructureTypeFigure );_gead .K =_fac .MakeInteger (mcid );return _gead ;};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_ebbg :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_gg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ebbg ;
};var _eaa ,_dcef ,_cfb int ;if len (hexStr )==4{var _gggd ,_cbfc ,_gfaf int ;_bdcd ,_dcg :=_d .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_gggd ,&_cbfc ,&_gfaf );if _dcg !=nil {_gg .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_dcg );
return _ebbg ;};if _bdcd !=3{_gg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ebbg ;};_eaa =_gggd *16+_gggd ;_dcef =_cbfc *16+_cbfc ;_cfb =_gfaf *16+_gfaf ;}else {_gbae ,_bgfg :=_d .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_eaa ,&_dcef ,&_cfb );
if _bgfg !=nil {_gg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _ebbg ;};if _gbae !=3{_gg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_gbae );
return _ebbg ;};};_cdca :=float64 (_eaa )/255.0;_dfgf :=float64 (_dcef )/255.0;_fdd :=float64 (_cfb )/255.0;_ebbg ._ccaf =_cdca ;_ebbg ._daefg =_dfgf ;_ebbg ._gafd =_fdd ;return _ebbg ;};

// Height returns the height of the graphic svg.
func (_ecdf *GraphicSVG )Height ()float64 {return _ecdf ._bggb .Height };func (_ecbdec *templateProcessor )parseAttrPropList (_ddgfb string )map[string ]string {_bdafd :=_bd .Fields (_ddgfb );if len (_bdafd )==0{return nil ;};_dbaec :=map[string ]string {};
for _ ,_fefdc :=range _bdafd {_cgaba :=_eadb .FindStringSubmatch (_fefdc );if len (_cgaba )< 3{continue ;};_gabfd ,_gccgf :=_bd .TrimSpace (_cgaba [1]),_cgaba [2];if _gabfd ==""{continue ;};_dbaec [_gabfd ]=_gccgf ;};return _dbaec ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_fee *Block )SetPos (x ,y float64 ){_fee ._fdg =PositionAbsolute ;_fee ._gbb =x ;_fee ._gbg =y };

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_bggb *GraphicSVGElement ;_gcda Positioning ;_bbece float64 ;_cadd float64 ;_badf Margins ;_aabd *int64 ;};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_gdbbc *Ellipse )SetPositioning (position Positioning ){_gdbbc ._gcfb =position };func _bdegd ()commands {var _feagg =map[string ]int {"\u006d":2,"\u007a":0,"\u006c":2,"\u0068":1,"\u0076":1,"\u0063":6,"\u0073":4,"\u0071":4,"\u0074":2,"\u0061":7};
var _cebf []string ;for _cfbg :=range _feagg {_cebf =append (_cebf ,_cfbg );};return commands {_cebf ,_feagg ,"\u006d","\u007a"};};func (_egfbf *Invoice )generateHeaderBlocks (_bdfb DrawContext )([]*Block ,DrawContext ,error ){_defb :=_cedfb (_egfbf ._fdaf );
_defb .SetEnableWrap (true );_defb .Append (_egfbf ._baggf );_fbede :=_afddc (2);if _egfbf ._efad !=nil {_fadda :=_fbede .NewCell ();_fadda .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_fadda .SetVerticalAlignment (CellVerticalAlignmentMiddle );
_fadda .SetIndent (0);_fadda .SetContent (_egfbf ._efad );_egfbf ._efad .ScaleToHeight (_defb .Height ()+20);}else {_fbede .SkipCells (1);};_faeg :=_fbede .NewCell ();_faeg .SetHorizontalAlignment (CellHorizontalAlignmentRight );_faeg .SetVerticalAlignment (CellVerticalAlignmentMiddle );
_faeg .SetContent (_defb );return _fbede .GeneratePageBlocks (_bdfb );};func _dfc (_dga string )string {_cbc :=_eeb .FindAllString (_dga ,-1);if len (_cbc )==0{_dga =_dga +"\u0030";}else {_cfg ,_aecdd :=_fa .Atoi (_cbc [len (_cbc )-1]);if _aecdd !=nil {_gg .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_aecdd );
_dga =_dga +"\u0030";}else {_cfg ++;_gbd :=_bd .LastIndex (_dga ,_cbc [len (_cbc )-1]);if _gbd ==-1{_dga =_d .Sprintf ("\u0025\u0073\u0025\u0064",_dga [:len (_dga )-1],_cfg );}else {_dga =_dga [:_gbd ]+_fa .Itoa (_cfg );};};};return _dga ;};

// GeneratePageBlocks draw graphic svg into block.
func (_cdegc *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fefg :=ctx ;_cggbb :=_cdegc ._gcda .IsRelative ();var _cddbf []*Block ;if _cggbb {_cbfd :=1.0;_agccg :=_cdegc ._badf .Top ;if _cdegc ._bggb .Height > ctx .Height -_cdegc ._badf .Top {_cddbf =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _eged error ;if _ ,ctx ,_eged =_bbbe ().GeneratePageBlocks (ctx );_eged !=nil {return nil ,ctx ,_eged ;};_agccg =0;};ctx .X +=_cdegc ._badf .Left +_cbfd ;ctx .Y +=_agccg ;ctx .Width -=_cdegc ._badf .Left +_cdegc ._badf .Right +2*_cbfd ;ctx .Height -=_agccg ;
}else {ctx .X =_cdegc ._bbece ;ctx .Y =_cdegc ._cadd ;};_ccd :=_ae .NewContentCreator ();_ccd .Translate (0,ctx .PageHeight );_ccd .Scale (1,-1);_ccd .Translate (ctx .X ,ctx .Y );_fbad :=_cdegc ._bggb .Width /_cdegc ._bggb .ViewBox .W ;_bdbge :=_cdegc ._bggb .Height /_cdegc ._bggb .ViewBox .H ;
_dgb :=0.0;_deadc :=0.0;if _cggbb {_dgb =_cdegc ._bbece -(_cdegc ._bggb .ViewBox .X *_a .Max (_fbad ,_bdbge ));_deadc =_cdegc ._cadd -(_cdegc ._bggb .ViewBox .Y *_a .Max (_fbad ,_bdbge ));};_fbgg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _cdegc ._aabd !=nil {_ccd .Add_BDC (*_fac .MakeName (_cb .StructureTypeFigure ),map[string ]_fac .PdfObject {"\u004d\u0043\u0049\u0044":_fac .MakeInteger (*_cdegc ._aabd )});
};_cdegc ._bggb .ToContentCreator (_ccd ,_fbgg ._bg ,_fbad ,_bdbge ,_dgb ,_deadc );if _cdegc ._aabd !=nil {_ccd .Add_EMC ();};if _ffae :=_fbgg .addContentsByString (_ccd .String ());_ffae !=nil {return nil ,ctx ,_ffae ;};if _cggbb {_bdcc :=_cdegc .Height ()+_cdegc ._badf .Bottom ;
ctx .Y +=_bdcc ;ctx .Height -=_bdcc ;}else {ctx =_fefg ;};_cddbf =append (_cddbf ,_fbgg );return _cddbf ,ctx ,nil ;};

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_beab *GraphicSVG )ScaleToHeight (h float64 ){_gacc :=_beab ._bggb .Width /_beab ._bggb .Height ;_beab ._bggb .Height =h ;_beab ._bggb .Width =h *_gacc ;_beab ._bggb .SetScaling (_gacc ,_gacc );};

// SetMarkedContentID sets the marked content id for the line.
func (_egca *Line )SetMarkedContentID (mcid int64 )*_cb .KDict {_egca ._gcfg =&mcid ;_bdeb :=_cb .NewKDictionary ();_bdeb .S =_fac .MakeName (_cb .StructureTypeFigure );_bdeb .K =_fac .MakeInteger (mcid );return _bdeb ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_baff *Creator )SetPageLabels (pageLabels _fac .PdfObject ){_baff ._eea =pageLabels };func (_bda *Chapter )headingText ()string {_ecd :=_bda ._cgbg ;if _dbc :=_bda .headingNumber ();_dbc !=""{_ecd =_d .Sprintf ("\u0025\u0073\u0020%\u0073",_dbc ,_ecd );
};return _ecd ;};

// List represents a list of items.
// The representation of a list item is as follows:
//
//	[marker] [content]
//
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_afab []*listItem ;_feba Margins ;_gbaeb TextChunk ;_fdb float64 ;_cedb bool ;_ffbad Positioning ;_aabgb TextStyle ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_befb *Table )SetMargins (left ,right ,top ,bottom float64 ){_befb ._gdfeg .Left =left ;_befb ._gdfeg .Right =right ;_befb ._gdfeg .Top =top ;_befb ._gdfeg .Bottom =bottom ;};func _fggcd (_gfafc *templateProcessor ,_cecb *templateNode )(interface{},error ){return _gfafc .parseChapter (_cecb );
};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_baed *TableCell )SetBorderLineStyle (style _gga .LineStyle ){_baed ._eceb =style };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_afcc *Invoice )TotalLines ()[][2]*InvoiceCell {_dgbe :=[][2]*InvoiceCell {_afcc ._gddc };_dgbe =append (_dgbe ,_afcc ._cfgga ...);return append (_dgbe ,_afcc ._agdaf );};

// MoveX moves the drawing context to absolute position x.
func (_edgf *Creator )MoveX (x float64 ){_edgf ._fdec .X =x };

// Length calculates and returns the length of the line.
func (_ddfe *Line )Length ()float64 {return _a .Sqrt (_a .Pow (_ddfe ._abdb -_ddfe ._cdbgd ,2.0)+_a .Pow (_ddfe ._ecff -_ddfe ._bggef ,2.0));};

// SetLineColor sets the line color.
func (_abgf *Polyline )SetLineColor (color Color ){_abgf ._daeaf .LineColor =_cdfd (color )};func _bbdg (_fgd _eb .ChartRenderable )*Chart {return &Chart {_degg :_fgd ,_cbbd :PositionRelative ,_dege :Margins {Top :10,Bottom :10}};};

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _dedec (path )};func _bbeba ()*FilledCurve {_fdabg :=FilledCurve {};_fdabg ._dbdf =[]_gga .CubicBezierCurve {};return &_fdabg ;};const (PositionRelative Positioning =iota ;PositionAbsolute ;
);

// SetWidth sets the width of the rectangle.
func (_egcg *Rectangle )SetWidth (width float64 ){_egcg ._ggcb =width };func _ededbe (_fgega *_cd .Decoder )(int ,int ){return 0,0};

// Height returns the height of the list.
func (_dffdb *List )Height ()float64 {var _eegba float64 ;for _ ,_afdd :=range _dffdb ._afab {_eegba +=_afdd .ctxHeight (_dffdb .Width ());};return _eegba ;};

// NewPolyline creates a new polyline.
func (_bgec *Creator )NewPolyline (points []_gga .Point )*Polyline {return _edbde (points )};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// Notes returns the notes section of the invoice as a title-content pair.
func (_gdbfac *Invoice )Notes ()(string ,string ){return _gdbfac ._ffce [0],_gdbfac ._ffce [1]};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_eecd *LinearShading )ToPdfShadingPattern ()*_cb .PdfShadingPatternType2 {_bbfaf ,_cbdf ,_fcgf :=_eecd ._fafde ._acggc .ToRGB ();_bbfeed :=_eecd .shadingModel ();_bbfeed .PdfShading .Background =_fac .MakeArrayFromFloats ([]float64 {_bbfaf ,_cbdf ,_fcgf });
_ffdc :=_cb .NewPdfShadingPatternType2 ();_ffdc .Shading =_bbfeed ;return _ffdc ;};

// SetMarkedContentID sets marked content ID.
func (_geb *border )SetMarkedContentID (id int64 )*_cb .KDict {return nil };

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_ffd *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _gbcg (x1 ,y1 ,x2 ,y2 )};

// GetIndent get the cell's left indent.
func (_dgde *TableCell )GetIndent ()float64 {return _dgde ._bbeab };

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_aeeb *Grid )SetColumnWidths (widths ...float64 )error {if len (widths )!=_aeeb ._eedbe {_gg .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _ff .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aeeb ._ggcd =widths ;return nil ;};

// DrawWithContext draws the Block using the specified drawing context.
func (_bfg *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_ecg ,_ ,_aab :=d .GeneratePageBlocks (ctx );if _aab !=nil {return _aab ;};if len (_ecg )!=1{return ErrContentNotFit ;};for _ ,_de :=range _ecg {if _cbb :=_bfg .mergeBlocks (_de );
_cbb !=nil {return _cbb ;};};return nil ;};

// SetMarkedContentID sets marked content ID.
func (_gecd *CurvePolygon )SetMarkedContentID (mcid int64 )*_cb .KDict {_gecd ._gbee =&mcid ;_fdff :=_cb .NewKDictionary ();_fdff .S =_fac .MakeName (_cb .StructureTypeFigure );_fdff .K =_fac .MakeInteger (mcid );return _fdff ;};func (_cdb *Division )split (_gegf DrawContext )(_beee ,_fgbd *Division ){var (_gbcbb float64 ;
_eccc ,_dafe []VectorDrawable ;);_gadd :=_gegf .Width -_cdb ._ccega .Left -_cdb ._ccega .Right -_cdb ._cacg .Left -_cdb ._cacg .Right ;for _ebac ,_cacdf :=range _cdb ._dbfd {_gbcbb +=_gfec (_cacdf ,_gadd );if _gbcbb < _gegf .Height {_eccc =append (_eccc ,_cacdf );
}else {_dafe =_cdb ._dbfd [_ebac :];break ;};};if len (_eccc )> 0{_beee =_abfb ();*_beee =*_cdb ;_beee ._dbfd =_eccc ;if _cdb ._babba !=nil {_beee ._babba =&Background {};*_beee ._babba =*_cdb ._babba ;};};if len (_dafe )> 0{_fgbd =_abfb ();*_fgbd =*_cdb ;
_fgbd ._dbfd =_dafe ;if _cdb ._babba !=nil {_fgbd ._babba =&Background {};*_fgbd ._babba =*_cdb ._babba ;};};return _beee ,_fgbd ;};

// Height returns the current page height.
func (_bbag *Creator )Height ()float64 {return _bbag ._bfbc };

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_egagf *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_egagf ._agcce =valign };func _affd (_cddfe string )[]token {var (_aebcc []token ;_fcad string ;);for _ ,_caae :=range _cddfe {_geeb :=string (_caae );switch {case _dbdfb .isCommand (_geeb ):_aebcc ,_fcad =_bbff (_aebcc ,_fcad );
_aebcc =append (_aebcc ,token {_geeb ,true });case _geeb =="\u002e":if _fcad ==""{_fcad ="\u0030";};if _bd .Contains (_fcad ,_geeb ){_aebcc =append (_aebcc ,token {_fcad ,false });_fcad ="\u0030";};fallthrough;case _geeb >="\u0030"&&_geeb <="\u0039"||_geeb =="\u0065":_fcad +=_geeb ;
case _geeb =="\u002d":if _bd .HasSuffix (_fcad ,"\u0065"){_fcad +=_geeb ;}else {_aebcc ,_ =_bbff (_aebcc ,_fcad );_fcad =_geeb ;};default:_aebcc ,_fcad =_bbff (_aebcc ,_fcad );};};_aebcc ,_ =_bbff (_aebcc ,_fcad );return _aebcc ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_bbbd *Creator )NewPage ()*_cb .PdfPage {_fbf :=_bbbd .newPage ();_bbbd ._adce =append (_bbbd ._adce ,_fbf );_bbbd ._fdec .Page ++;return _fbf ;};func (_gcab *templateProcessor )parseTextVerticalAlignmentAttr (_bbbgf ,_dafa string )TextVerticalAlignment {_gg .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bbbgf ,_dafa );
_bbbgb :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_dafa ];return _bbbgb ;};func _bbff (_cgde []token ,_agabe string )([]token ,string ){if _agabe !=""{_cgde =append (_cgde ,token {_agabe ,false });
_agabe ="";};return _cgde ,_agabe ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_baggf string ;_efad *Image ;_fdaa *InvoiceAddress ;_cefag *InvoiceAddress ;_egbd string ;_dedbb [2]*InvoiceCell ;_adceg [2]*InvoiceCell ;_gcgd [2]*InvoiceCell ;_gade [][2]*InvoiceCell ;_cefb []*InvoiceCell ;_daeag [][]*InvoiceCell ;
_gddc [2]*InvoiceCell ;_agdaf [2]*InvoiceCell ;_cfgga [][2]*InvoiceCell ;_ffce [2]string ;_gefef [2]string ;_cbadd [][2]string ;_dfae TextStyle ;_fceb TextStyle ;_fdaf TextStyle ;_adeb TextStyle ;_cfbde TextStyle ;_fefc TextStyle ;_agbc TextStyle ;_dcebd InvoiceCellProps ;
_gbdgc InvoiceCellProps ;_ggaea InvoiceCellProps ;_afca InvoiceCellProps ;_gdaf Positioning ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);func (_gfffa *templateProcessor )parseList (_bffd *templateNode )(interface{},error ){_eagbb :=_gfffa .creator .NewList ();
for _ ,_fgbg :=range _bffd ._bcdgfa .Attr {_faage :=_fgbg .Value ;switch _geeee :=_fgbg .Name .Local ;_geeee {case "\u0069\u006e\u0064\u0065\u006e\u0074":_eagbb .SetIndent (_gfffa .parseFloatAttr (_geeee ,_faage ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bbfag :=_gfffa .parseMarginAttr (_geeee ,_faage );
_eagbb .SetMargins (_bbfag .Left ,_bbfag .Right ,_bbfag .Top ,_bbfag .Bottom );default:_gfffa .nodeLogDebug (_bffd ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_geeee );
};};return _eagbb ,nil ;};

// SkipOver skips over a specified number of rows and cols.
func (_afaab *Table )SkipOver (rows ,cols int ){_dgfga :=rows *_afaab ._cfgeg +cols -1;if _dgfga < 0{_gg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _gdefad :=0;_gdefad < _dgfga ;_gdefad ++{_afaab .NewCell ();};};

// SetBorderWidth sets the border width.
func (_ebfe *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_ebfe ._gaffeg .BorderWidth =borderWidth ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_caa *Chapter )GetHeading ()*StyledParagraph {return _caa ._egea };func (_gggacd *Rectangle )applyFitMode (_caad float64 ){_caad -=_gggacd ._gdea .Left +_gggacd ._gdea .Right +_gggacd ._afefe ;switch _gggacd ._bdde {case FitModeFillWidth :_gggacd .ScaleToWidth (_caad );
};};func _dedec (_afbb string )(*GraphicSVG ,error ){_adfdaf ,_cgdb :=ParseFromSVGFile (_afbb );if _cgdb !=nil {return nil ,_cgdb ;};return _bec (_adfdaf );};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_ggaeg *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_ggaeg ._cfgeg {_gg .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _ff .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ggaeg ._bcbd =widths ;return nil ;};func _dcgg (_cfgec map[string ]string ,_ebeae float64 )(*GraphicSVGStyle ,error ){_bface :=_dafed ();
_dcfbd ,_aceee :=_cfgec ["\u0066\u0069\u006c\u006c"];if _aceee {_bface .FillColor =_dcfbd ;if _dcfbd =="\u006e\u006f\u006e\u0065"{_bface .FillColor ="";};};_agdga ,_dece :=_cfgec ["\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079"];if _dece {_dcgf ,_egbef :=_dacg (_agdga );
if _egbef !=nil {return nil ,_egbef ;};_bface .FillOpacity =_dcgf ;};_gfcb ,_dafea :=_cfgec ["\u0073\u0074\u0072\u006f\u006b\u0065"];if _dafea {_bface .StrokeColor =_gfcb ;if _gfcb =="\u006e\u006f\u006e\u0065"{_bface .StrokeColor ="";};};_dcbdb ,_feca :=_cfgec ["\u0073\u0074\u0072o\u006b\u0065\u002d\u0077\u0069\u0064\u0074\u0068"];
if _feca {_bfedf ,_cbbdg :=_cdadb (_dcbdb ,64);if _cbbdg !=nil {return nil ,_cbbdg ;};_bface .StrokeWidth =_bfedf *_ebeae ;};return _bface ,nil ;};

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_dbfde *Rectangle )ScaleToHeight (h float64 ){_gfcf :=_dbfde ._ggcb /_dbfde ._baadd ;_dbfde ._baadd =h ;_dbfde ._ggcb =h *_gfcf ;};func _faggc (_fbff *Block ,_gcgab *Paragraph ,_cded DrawContext )(DrawContext ,error ){_gbec :=1;_gded :=_fac .PdfObjectName ("\u0046\u006f\u006e\u0074"+_fa .Itoa (_gbec ));
for _fbff ._bg .HasFontByName (_gded ){_gbec ++;_gded =_fac .PdfObjectName ("\u0046\u006f\u006e\u0074"+_fa .Itoa (_gbec ));};_adda :=_fbff ._bg .SetFontByName (_gded ,_gcgab ._effad .ToPdfObject ());if _adda !=nil {return _cded ,_adda ;};_gcgab .wrapText ();
_dfbaf :=_ae .NewContentCreator ();_dfbaf .Add_q ();_acfea :=_aa .RoundDefault (_cded .PageHeight -_cded .Y -_gcgab ._dbcd *_gcgab ._ccfga );_dfbaf .Translate (_cded .X ,_acfea );if _gcgab ._gbagg !=0{_dfbaf .RotateDeg (_gcgab ._gbagg );};_bbeg :=_cdfd (_gcgab ._dcfc );
_adda =_bddf (_fbff ,_bbeg ,_gcgab ._dcfc ,func ()Rectangle {return Rectangle {_gbaf :_cded .X ,_gcfge :_acfea ,_ggcb :_gcgab .getMaxLineWidth ()/1000.0,_baadd :_gcgab .Height ()};});if _adda !=nil {return _cded ,_adda ;};_dfbaf .Add_BT ();_fdcde :=map[string ]_fac .PdfObject {};
if _gcgab ._aaec !=nil {_fdcde ["\u004d\u0043\u0049\u0044"]=_fac .MakeInteger (*_gcgab ._aaec );};if _gcgab ._adae !=""{_fdcde ["\u004c\u0061\u006e\u0067"]=_fac .MakeString (_gcgab ._adae );};if len (_fdcde )> 0{_dfbaf .Add_BDC (*_fac .MakeName (_cb .StructureTypeParagraph ),_fdcde );
};_dfbaf .SetNonStrokingColor (_bbeg ).Add_Tf (_gded ,_gcgab ._dbcd ).Add_TL (_gcgab ._dbcd *_gcgab ._ccfga );for _bbab ,_fgbbd :=range _gcgab ._ffff {if _bbab !=0{_dfbaf .Add_Tstar ();};_dfeba :=[]rune (_fgbbd );_cdcebb :=0.0;_ecdg :=0;for _defbc ,_gfeb :=range _dfeba {if _gfeb ==' '{_ecdg ++;
continue ;};if _gfeb =='\u000A'{continue ;};_fagd ,_fgea :=_gcgab ._effad .GetRuneMetrics (_gfeb );if !_fgea {_gg .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_defbc ,_gfeb ,_gfeb ,_gcgab ._effad .BaseFont (),_gcgab ._effad .Subtype ());
return _cded ,_ff .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_cdcebb +=_gcgab ._dbcd *_fagd .Wx ;};var _bcab []_fac .PdfObject ;_cbace ,_cgga :=_gcgab ._effad .GetRuneMetrics (' ');
if !_cgga {return _cded ,_ff .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_eddb :=_cbace .Wx ;switch _gcgab ._bfgaa {case TextAlignmentJustify :if _ecdg > 0&&_bbab < len (_gcgab ._ffff )-1{_eddb =(_gcgab ._egeg *1000.0-_cdcebb )/float64 (_ecdg )/_gcgab ._dbcd ;
};case TextAlignmentCenter :_agccf :=_cdcebb +float64 (_ecdg )*_eddb *_gcgab ._dbcd ;_ccfef :=_aa .RoundDefault ((_gcgab ._egeg *1000.0-_agccf )/2/_gcgab ._dbcd );_bcab =append (_bcab ,_fac .MakeFloat (-_ccfef ));case TextAlignmentRight :_bcgbd :=_cdcebb +float64 (_ecdg )*_eddb *_gcgab ._dbcd ;
_gdacc :=_aa .RoundDefault ((_gcgab ._egeg *1000.0-_bcgbd )/_gcgab ._dbcd );_bcab =append (_bcab ,_fac .MakeFloat (-_gdacc ));};_dfaedc :=_gcgab ._effad .Encoder ();var _fcbf []byte ;for _ ,_ggbd :=range _dfeba {if _ggbd =='\u000A'{continue ;};if _ggbd ==' '{if len (_fcbf )> 0{_bcab =append (_bcab ,_fac .MakeStringFromBytes (_fcbf ));
_fcbf =nil ;};_bcab =append (_bcab ,_fac .MakeFloat (-_eddb ));}else {if _ ,_bcee :=_dfaedc .RuneToCharcode (_ggbd );!_bcee {_adda =UnsupportedRuneError {Message :_d .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ggbd ,_ggbd ),Rune :_ggbd };
_cded ._eaba =append (_cded ._eaba ,_adda );_gg .Log .Debug (_adda .Error ());if _cded ._fdecg <=0{continue ;};_ggbd =_cded ._fdecg ;};_fcbf =append (_fcbf ,_dfaedc .Encode (string (_ggbd ))...);};};if len (_fcbf )> 0{_bcab =append (_bcab ,_fac .MakeStringFromBytes (_fcbf ));
};_dfbaf .Add_TJ (_bcab ...);};if len (_fdcde )> 0{_dfbaf .Add_EMC ();};_dfbaf .Add_ET ();_dfbaf .Add_Q ();_ffda :=_dfbaf .Operations ();_ffda .WrapIfNeeded ();_fbff .addContents (_ffda );if _gcgab ._fefd .IsRelative (){_beag :=_gcgab .Height ();_cded .Y =_aa .RoundDefault (_cded .Y +_beag );
_cded .Height =_aa .RoundDefault (_cded .Height -_beag );if _cded .Inline {_cded .X =_aa .RoundDefault (_cded .X +_gcgab .Width ()+_gcgab ._gebd .Right );};};return _cded ,nil ;};

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_fceg *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_fceg ._cfcb =dashArray ;_fceg ._affb =dashPhase ;};

// SetAngle sets Image rotation angle in degrees.
func (_bcaa *Image )SetAngle (angle float64 ){_bcaa ._gegeb =angle };

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_fcbca *Invoice )NoteHeadingStyle ()TextStyle {return _fcbca ._agbc };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_bcbgc *StyledParagraph )SetWidth (width float64 ){_bcbgc ._fgdfg =width ;_bcbgc .wrapText ()};

// ParseFromSVGStream creates a GraphicSVG instance from SVG stream input.
func ParseFromSVGStream (source _ad .Reader )(*GraphicSVGElement ,error ){_dcee :=_cd .NewDecoder (source );_dcee .CharsetReader =_ba .NewReaderLabel ;_gcedc ,_cbcfef :=_afefb (_dcee );if _cbcfef !=nil {return nil ,_cbcfef ;};if _ebcgb :=_gcedc .Decode (_dcee );
_ebcgb !=nil &&_ebcgb !=_ad .EOF {return nil ,_ebcgb ;};return _gcedc ,nil ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_cfdb *StyledParagraph )SetEnableWrap (enableWrap bool ){_cfdb ._cbcg =enableWrap ;_cfdb ._gfff =false ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_bfcg *Paragraph )SetEnableWrap (enableWrap bool ){_bfcg ._cbca =enableWrap ;_bfcg ._cdgge =false ;};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// Width returns Image's document width.
func (_bagg *Image )Width ()float64 {return _bagg ._efca };

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_daeaf *_gga .Polyline ;_bfbg float64 ;_fbabe *int64 ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_egfg *Invoice )SetNoteHeadingStyle (style TextStyle ){_egfg ._agbc =style };

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;func (_aed *Block )addContents (_eca *_ae .ContentStreamOperations ){_aed ._fd .WrapIfNeeded ();_eca .WrapIfNeeded ();*_aed ._fd =append (*_aed ._fd ,*_eca ...);};

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_dbg *Chapter )Add (d Drawable )error {if Drawable (_dbg )==d {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _ff .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _cdeg :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_dbg ._ebcc =append (_dbg ._ebcc ,d );case containerDrawable :_adcc ,_ebeb :=_cdeg .ContainerComponent (_dbg );
if _ebeb !=nil {return _ebeb ;};_dbg ._ebcc =append (_dbg ._ebcc ,_adcc );default:_gg .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _ff .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// SetColorTop sets border color for top.
func (_cef *border )SetColorTop (col Color ){_cef ._feeb =col };

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_gee *Creator )PageFinalize (pageFinalizeFunc func (_bbfa PageFinalizeFunctionArgs )error ){_gee ._cdg =pageFinalizeFunc ;};

// SetFillColor sets the fill color of the rectangle.
func (_abfab *Rectangle )SetFillColor (col Color ){_abfab ._ecbc =col };func _cbbcc (_gbfcb *Block ,_cggc *StyledParagraph ,_egcd [][]*TextChunk ,_dfbg DrawContext )(DrawContext ,[][]*TextChunk ,error ){_aeee :=1;_ceda :=_fac .PdfObjectName (_d .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aeee ));
for _gbfcb ._bg .HasFontByName (_ceda ){_aeee ++;_ceda =_fac .PdfObjectName (_d .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aeee ));};_fbdea :=_gbfcb ._bg .SetFontByName (_ceda ,_cggc ._eeaba .Font .ToPdfObject ());if _fbdea !=nil {return _dfbg ,nil ,_fbdea ;
};_aeee ++;_baadf :=_ceda ;_bcgda :=_cggc ._eeaba .FontSize ;_fgaff :=_cggc ._fafce .IsRelative ();var _cccfd [][]_fac .PdfObjectName ;var _afee [][]*TextChunk ;var _dacca float64 ;for _aedcc ,_eacga :=range _egcd {var _gebfa []_fac .PdfObjectName ;var _caca float64 ;
if len (_eacga )> 0{_caca =_eacga [0].Style .FontSize ;};for _ ,_cgbgd :=range _eacga {_abca :=_cgbgd .Style ;if _cgbgd .Text !=""&&_abca .FontSize > _caca {_caca =_abca .FontSize ;};if _caca > _dfbg .PageHeight {return _dfbg ,nil ,_ff .New ("\u0050\u0061\u0072\u0061\u0067\u0072a\u0070\u0068\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u006ca\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0070\u0061\u0067\u0065 \u0068e\u0069\u0067\u0068\u0074");
};_ceda =_fac .PdfObjectName (_d .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aeee ));_gbbb :=_gbfcb ._bg .SetFontByName (_ceda ,_abca .Font .ToPdfObject ());if _gbbb !=nil {return _dfbg ,nil ,_gbbb ;};_gebfa =append (_gebfa ,_ceda );_aeee ++;};_caca *=_cggc ._dcag ;
if _fgaff &&_dacca +_caca > _dfbg .Height {_afee =_egcd [_aedcc :];_egcd =_egcd [:_aedcc ];break ;};_dacca +=_caca ;_cccfd =append (_cccfd ,_gebfa );};_bdbba ,_cccb ,_cbbda :=_cggc .getLineMetrics (0);_gecf ,_dbbdf :=_bdbba *_cggc ._dcag ,_cccb *_cggc ._dcag ;
if len (_egcd )==0{return _dfbg ,_afee ,nil ;};_dcfed :=_ae .NewContentCreator ();_dcfed .Add_q ();_ddfb :=_dbbdf ;if _cggc ._beagc ==TextVerticalAlignmentCenter {_ddfb =_cccb +(_bdbba +_cbbda -_cccb )/2+(_dbbdf -_cccb )/2;};_daabf :=_dfbg .PageHeight -_dfbg .Y -_ddfb ;
_dcfed .Translate (_dfbg .X ,_daabf );_ccab :=_daabf ;if _cggc ._dbcga !=0{_dcfed .RotateDeg (_cggc ._dbcga );};if _cggc ._bfdd ==TextOverflowHidden {_dcfed .Add_re (0,-_dacca +_gecf +1,_cggc ._fgdfg ,_dacca ).Add_W ().Add_n ();};_dcfed .Add_BT ();_dfga :=map[string ]_fac .PdfObject {};
if _cggc ._eaef !=nil {_dfga ["\u004d\u0043\u0049\u0044"]=_fac .MakeInteger (*_cggc ._eaef );};if _cggc ._adcg !=""{_dfga ["\u004c\u0061\u006e\u0067"]=_fac .MakeString (_cggc ._adcg );};if len (_dfga )> 0{_dcfed .Add_BDC (*_fac .MakeName (_cb .StructureTypeParagraph ),_dfga );
};var _efdaf []*_gga .BasicLine ;for _dfbae ,_cegdb :=range _egcd {_egbe :=_dfbg .X ;var _edgbe float64 ;if len (_cegdb )> 0{_edgbe =_cegdb [0].Style .FontSize ;};_bdbba ,_ ,_cbbda =_cggc .getLineMetrics (_dfbae );_dbbdf =(_bdbba +_cbbda );for _ ,_aebf :=range _cegdb {_aagbf :=&_aebf .Style ;
if _aebf .Text !=""&&_aagbf .FontSize > _edgbe {_edgbe =_aagbf .FontSize ;};if _dbbdf > _edgbe {_edgbe =_dbbdf ;};};if _dfbae !=0{_dcfed .Add_TD (0,-_edgbe *_cggc ._dcag );_ccab -=_edgbe *_cggc ._dcag ;};_ffffa :=_dfbae ==len (_egcd )-1;var (_ebaf float64 ;
_bcbcb float64 ;_edcg *fontMetrics ;_aeea float64 ;_fdbb uint ;);var _fedd []float64 ;for _ ,_ebed :=range _cegdb {_ccabf :=&_ebed .Style ;if _ccabf .FontSize > _bcbcb {_bcbcb =_ccabf .FontSize ;_edcg =_gagfg (_ebed .Style .Font ,_ccabf .FontSize );};if _dbbdf > _bcbcb {_bcbcb =_dbbdf ;
};_dcbeb ,_egddf :=_ccabf .Font .GetRuneMetrics (' ');if _dcbeb .Wx ==0&&_ccabf .MultiFont !=nil {_dcbeb ,_egddf =_ccabf .MultiFont .GetRuneMetrics (' ');_ccabf .MultiFont .Reset ();};if !_egddf {return _dfbg ,nil ,_ff .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _gdcc uint ;var _ffcf float64 ;_gfaea :=len (_ebed .Text );for _bbfc ,_abcaa :=range _ebed .Text {if _abcaa ==' '{_gdcc ++;continue ;};if _abcaa =='\u000A'{continue ;};_aaeba ,_dfgcd :=_ccabf .Font .GetRuneMetrics (_abcaa );if _aaeba .Wx ==0&&_ccabf .MultiFont !=nil {_aaeba ,_dfgcd =_ccabf .MultiFont .GetRuneMetrics (' ');
_ccabf .MultiFont .Reset ();};if !_dfgcd {_gg .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_abcaa );return _dfbg ,nil ,_ff .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");
};_ffcf +=_ccabf .FontSize *_aaeba .Wx *_ccabf .horizontalScale ();if _bbfc !=_gfaea -1{_ffcf +=_ccabf .CharSpacing *1000.0;};};_fedd =append (_fedd ,_ffcf );_ebaf +=_ffcf ;_aeea +=float64 (_gdcc )*_dcbeb .Wx *_ccabf .FontSize *_ccabf .horizontalScale ();
_fdbb +=_gdcc ;};_bcbcb *=_cggc ._dcag ;var _daee []_fac .PdfObject ;_dade :=_cggc ._fgdfg *1000.0;if _cggc ._gffa ==TextAlignmentJustify {if _fdbb > 0&&!_ffffa {_aeea =(_dade -_ebaf )/float64 (_fdbb )/_bcgda ;};}else if _cggc ._gffa ==TextAlignmentCenter {_gbcda :=(_dade -_ebaf -_aeea )/2;
_dgabd :=_gbcda /_bcgda ;_daee =append (_daee ,_fac .MakeFloat (-_dgabd ));_egbe +=_gbcda /1000.0;}else if _cggc ._gffa ==TextAlignmentRight {_cgbge :=(_dade -_ebaf -_aeea );_aefa :=_cgbge /_bcgda ;_daee =append (_daee ,_fac .MakeFloat (-_aefa ));_egbe +=_cgbge /1000.0;
};if len (_daee )> 0{_dcfed .Add_Tf (_baadf ,_bcgda ).Add_TL (_bcgda *_cggc ._dcag ).Add_TJ (_daee ...);};_eedd :=0.0;for _bcded ,_bagee :=range _cegdb {_ddeb :=&_bagee .Style ;_afaaf :=_baadf ;_ggef :=_bcgda ;_cbgfe :=_ddeb .OutlineColor !=nil ;_gede :=_ddeb .HorizontalScaling !=DefaultHorizontalScaling ;
_fdba :=_ddeb .OutlineSize !=1;if _fdba {_dcfed .Add_w (_ddeb .OutlineSize );};_ecaff :=_ddeb .RenderingMode !=TextRenderingModeFill ;if _ecaff {_dcfed .Add_Tr (int64 (_ddeb .RenderingMode ));};_deefb :=_ddeb .CharSpacing !=0;if _deefb {_dcfed .Add_Tc (_ddeb .CharSpacing );
};_cgdg :=_ddeb .TextRise !=0;if _cgdg {_dcfed .Add_Ts (_ddeb .TextRise );};if _bagee .VerticalAlignment !=TextVerticalAlignmentBaseline {_aefgc :=_gagfg (_bagee .Style .Font ,_ddeb .FontSize );switch _bagee .VerticalAlignment {case TextVerticalAlignmentCenter :_eedd =_edcg ._bccfea /2-_aefgc ._bccfea /2;
case TextVerticalAlignmentBottom :_eedd =_edcg ._bcbe -_aefgc ._bcbe ;case TextVerticalAlignmentTop :_eedd =_cccb -_ddeb .FontSize ;};if _eedd !=0.0{_dcfed .Translate (0,_eedd );};};if _cggc ._gffa !=TextAlignmentJustify ||_ffffa {_affcg ,_fggdb :=_ddeb .Font .GetRuneMetrics (' ');
if !_fggdb {return _dfbg ,nil ,_ff .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_afaaf =_cccfd [_dfbae ][_bcded ];_ggef =_ddeb .FontSize ;
_aeea =_affcg .Wx *_ddeb .horizontalScale ();};_bdea :=_ddeb .Font .Encoder ();var _efefe []byte ;var _fege bool ;_becg :=_ddeb .Font ;_dfcgd :=map[string ]_fac .PdfObject {};if _bagee ._afae !=nil {_dfcgd ["\u0045"]=_fac .MakeString (*_bagee ._afae );
};if _bagee ._adbfb !=nil {_dfcgd ["\u0041\u0063\u0074\u0075\u0061\u006c\u0054\u0065\u0078\u0074"]=_fac .MakeString (*_bagee ._adbfb );};if _bagee ._deafg !=nil {_dfcgd ["\u004d\u0043\u0049\u0044"]=_fac .MakeInteger (*_bagee ._deafg );};if len (_dfcgd )> 0{_dcfed .Add_BDC (*_fac .MakeName (_cb .StructureTypeSpan ),_dfcgd );
};for _ ,_fbedc :=range _bagee .Text {if _fbedc =='\u000A'{continue ;};if _fbedc ==' '{if len (_efefe )> 0{if _cbgfe {_dcfed .SetStrokingColor (_cdfd (_ddeb .OutlineColor ));};if _gede {_dcfed .Add_Tz (_ddeb .HorizontalScaling );};_cebad :=_cccfd [_dfbae ][_bcded ];
if _fege {_cebad =_fac .PdfObjectName (_d .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aeee ));_egfa :=_gbfcb ._bg .SetFontByName (_cebad ,_becg .ToPdfObject ());if _egfa !=nil {return _dfbg ,nil ,_egfa ;};_aeee ++;_fege =false ;_bdea =_ddeb .Font .Encoder ();
};_dcfed .SetNonStrokingColor (_cdfd (_ddeb .Color )).Add_Tf (_cebad ,_ddeb .FontSize ).Add_TJ ([]_fac .PdfObject {_fac .MakeStringFromBytes (_efefe )}...);_efefe =nil ;};if _gede {_dcfed .Add_Tz (DefaultHorizontalScaling );};_dcfed .Add_Tf (_afaaf ,_ggef ).Add_TJ ([]_fac .PdfObject {_fac .MakeFloat (-_aeea )}...);
_fedd [_bcded ]+=_aeea *_ggef ;}else {if _ ,_gffad :=_bdea .RuneToCharcode (_fbedc );!_gffad {if _ddeb .MultiFont !=nil {_gcecd ,_bdca :=_ddeb .MultiFont .Encoder (_fbedc );if _bdca {if len (_efefe )!=0{_fecgb :=_fac .PdfObjectName (_d .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aeee ));
_cfdeg :=_gbfcb ._bg .SetFontByName (_afaaf ,_becg .ToPdfObject ());if _cfdeg !=nil {return _dfbg ,nil ,_cfdeg ;};_dcfed .SetNonStrokingColor (_cdfd (_ddeb .Color )).Add_Tf (_fecgb ,_ddeb .FontSize ).Add_TJ ([]_fac .PdfObject {_fac .MakeStringFromBytes (_efefe )}...);
_aeee ++;_efefe =nil ;};_bdea =_gcecd ;_fege =true ;_becg =_ddeb .MultiFont .CurrentFont ;};}else {_fbdea =UnsupportedRuneError {Message :_d .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_fbedc ,_fbedc ),Rune :_fbedc };
_dfbg ._eaba =append (_dfbg ._eaba ,_fbdea );_gg .Log .Debug (_fbdea .Error ());if _dfbg ._fdecg <=0{continue ;};_fbedc =_dfbg ._fdecg ;};};_gaebc :=_bdea .Encode (string (_fbedc ));_efefe =append (_efefe ,_gaebc ...);};if _ddeb .MultiFont !=nil {_ddeb .MultiFont .Reset ();
};};if len (_efefe )> 0{if _cbgfe {_dcfed .SetStrokingColor (_cdfd (_ddeb .OutlineColor ));};if _gede {_dcfed .Add_Tz (_ddeb .HorizontalScaling );};_gfggd :=_cccfd [_dfbae ][_bcded ];if _fege {_gfggd =_fac .PdfObjectName (_d .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_aeee ));
_cbdad :=_gbfcb ._bg .SetFontByName (_gfggd ,_becg .ToPdfObject ());if _cbdad !=nil {return _dfbg ,nil ,_cbdad ;};_aeee ++;_fege =false ;};_dcfed .SetNonStrokingColor (_cdfd (_ddeb .Color )).Add_Tf (_gfggd ,_ddeb .FontSize ).Add_TJ ([]_fac .PdfObject {_fac .MakeStringFromBytes (_efefe )}...);
};if len (_dfcgd )> 0{_dcfed .Add_EMC ();};_gggb :=_fedd [_bcded ]/1000.0;if _ddeb .Underline {_aefga :=_ddeb .UnderlineStyle .Color ;if _aefga ==nil {_aefga =_bagee .Style .Color ;};_dgdf ,_eafbg ,_ecabc :=_aefga .ToRGB ();_bfed :=_egbe -_dfbg .X ;_cggad :=_ccab -_daabf +_ddeb .TextRise -_ddeb .UnderlineStyle .Offset ;
_efdaf =append (_efdaf ,&_gga .BasicLine {X1 :_bfed ,Y1 :_cggad ,X2 :_bfed +_gggb ,Y2 :_cggad ,LineWidth :_bagee .Style .UnderlineStyle .Thickness ,LineColor :_cb .NewPdfColorDeviceRGB (_dgdf ,_eafbg ,_ecabc )});};for _bagac ,_dfbb :=range _bagee ._fegffe {var _bgcg *_fac .PdfObjectArray ;
if len (_bagee ._gabgdd )==_bagac {switch _aecbe :=_dfbb .GetContext ().(type ){case *_cb .PdfAnnotationLink :_bgcg =_fac .MakeArray ();_aecbe .Rect =_bgcg ;_feabb ,_gcaf :=_aecbe .Dest .(*_fac .PdfObjectArray );if _gcaf &&_feabb .Len ()==5{_gabdd ,_abbf :=_feabb .Get (1).(*_fac .PdfObjectName );
if _abbf &&_gabdd .String ()=="\u0058\u0059\u005a"{_fgbfd ,_fbcbb :=_fac .GetNumberAsFloat (_feabb .Get (3));if _fbcbb ==nil {_feabb .Set (3,_fac .MakeFloat (_dfbg .PageHeight -_fgbfd ));};};};case *_cb .PdfAnnotationHighlight :_bgcg =_fac .MakeArray ();
_aecbe .Rect =_bgcg ;_fbgf :=_egbe ;_faab :=_ccab +_ddeb .TextRise ;_fcdf :=_cdaaa (&_cb .PdfRectangle {Llx :_fbgf ,Lly :_faab ,Urx :_fbgf +_gggb ,Ury :_faab +_bcbcb },_cggc ._dbcga );_aecbe .QuadPoints =_fac .MakeArrayFromFloats ([]float64 {_fcdf [0].X ,_fcdf [0].Y ,_fcdf [1].X ,_fcdf [1].Y ,_fcdf [3].X ,_fcdf [3].Y ,_fcdf [2].X ,_fcdf [2].Y });
};_bagee ._gabgdd =append (_bagee ._gabgdd ,true );};if _bgcg !=nil {_fbbca :=_gga .NewPoint (_egbe -_dfbg .X ,_ccab +_ddeb .TextRise -_daabf ).Rotate (_cggc ._dbcga );_fbbca .X +=_dfbg .X ;_fbbca .Y +=_daabf ;_dgbcf ,_cfda ,_fcdfg ,_cfcee :=_ebebb (_gggb ,_bcbcb ,_cggc ._dbcga );
_fbbca .X +=_dgbcf ;_fbbca .Y +=_cfda ;_bgcg .Clear ();_bgcg .Append (_fac .MakeFloat (_fbbca .X ));_bgcg .Append (_fac .MakeFloat (_fbbca .Y ));_bgcg .Append (_fac .MakeFloat (_fbbca .X +_fcdfg ));_bgcg .Append (_fac .MakeFloat (_fbbca .Y +_cfcee ));};
_gbfcb .AddAnnotation (_dfbb );};_egbe +=_gggb ;if _fdba {_dcfed .Add_w (1.0);};if _cbgfe {_dcfed .Add_RG (0.0,0.0,0.0);};if _ecaff {_dcfed .Add_Tr (int64 (TextRenderingModeFill ));};if _deefb {_dcfed .Add_Tc (0);};if _cgdg {_dcfed .Add_Ts (0);};if _gede {_dcfed .Add_Tz (DefaultHorizontalScaling );
};if _eedd !=0.0{_dcfed .Translate (0,-_eedd );_eedd =0.0;};};};if len (_dfga )> 0{_dcfed .Add_EMC ();};_dcfed .Add_ET ();for _ ,_fcba :=range _efdaf {_dcfed .SetStrokingColor (_fcba .LineColor ).Add_w (_fcba .LineWidth ).Add_m (_fcba .X1 ,_fcba .Y1 ).Add_l (_fcba .X2 ,_fcba .Y2 ).Add_s ();
};_dcfed .Add_Q ();_defc :=_dcfed .Operations ();_defc .WrapIfNeeded ();_gbfcb .addContents (_defc );if _fgaff {_dgeb :=_dacca ;_dfbg .Y +=_dgeb ;_dfbg .Height -=_dgeb ;if _dfbg .Inline {_dfbg .X +=_cggc .Width ()+_cggc ._dcbc .Right ;};};return _dfbg ,_afee ,nil ;
};

// AddHighlightedText adds a new highlighted text to the paragraph.
func (_bedec *StyledParagraph )AddHighlightedText (text string ,color Color ,alpha float64 )*TextChunk {_gedc :=NewTextChunk (text ,_bedec ._eeaba );_gedc .Highlight (color ,alpha );return _bedec .appendChunk (_gedc );};

// NewCell makes a new single cell and inserts it into the row at the current position.
func (_ecdb *GridRow )NewCell ()(*GridCell ,error ){return _ecdb .NewMultiCell (1,1)};

// SetBorderWidth sets the border width.
func (_eeag *Polygon )SetBorderWidth (borderWidth float64 ){_eeag ._bbbb .BorderWidth =borderWidth };func (_fcccd *templateProcessor )parseChart (_aacaf *templateNode )(interface{},error ){var _egdcf string ;for _ ,_dbfcc :=range _aacaf ._bcdgfa .Attr {_dbefg :=_dbfcc .Value ;
switch _gddbf :=_dbfcc .Name .Local ;_gddbf {case "\u0073\u0072\u0063":_egdcf =_dbefg ;};};if _egdcf ==""{_fcccd .nodeLogError (_aacaf ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_efgag ;};_efbcdd ,_adad :=_fcccd ._debae .ChartMap [_egdcf ];if !_adad {_fcccd .nodeLogError (_aacaf ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_egdcf );
return nil ,_efgag ;};_adbbb :=NewChart (_efbcdd );for _ ,_fdecf :=range _aacaf ._bcdgfa .Attr {_gdca :=_fdecf .Value ;switch _egfgb :=_fdecf .Name .Local ;_egfgb {case "\u0078":_adbbb .SetPos (_fcccd .parseFloatAttr (_egfgb ,_gdca ),_adbbb ._fae );case "\u0079":_adbbb .SetPos (_adbbb ._dfbd ,_fcccd .parseFloatAttr (_egfgb ,_gdca ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_dfdb :=_fcccd .parseMarginAttr (_egfgb ,_gdca );_adbbb .SetMargins (_dfdb .Left ,_dfdb .Right ,_dfdb .Top ,_dfdb .Bottom );case "\u0077\u0069\u0064t\u0068":_adbbb ._degg .SetWidth (int (_fcccd .parseFloatAttr (_egfgb ,_gdca )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_adbbb ._degg .SetHeight (int (_fcccd .parseFloatAttr (_egfgb ,_gdca )));case "\u0073\u0072\u0063":break ;default:_fcccd .nodeLogDebug (_aacaf ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_egfgb );
};};return _adbbb ,nil ;};

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_gcec *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_gcec ._gdea .Left =left ;_gcec ._gdea .Right =right ;_gcec ._gdea .Top =top ;_gcec ._gdea .Bottom =bottom ;};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_ebfbb *TOCLine )SetStyle (style TextStyle ){_ebfbb .Number .Style =style ;_ebfbb .Title .Style =style ;_ebfbb .Separator .Style =style ;_ebfbb .Page .Style =style ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_gaffe *Invoice )TitleStyle ()TextStyle {return _gaffe ._fdaf };

// SetFillColor sets the fill color.
func (_deef *PolyBezierCurve )SetFillColor (color Color ){_deef ._abbc =color ;_deef ._gaffeg .FillColor =_cdfd (color );};

// NewTOC creates a new table of contents.
func (_fffb *Creator )NewTOC (title string )*TOC {_aecb :=_fffb .NewTextStyle ();_aecb .Font =_fffb ._fgcgd ;return _gedb (title ,_fffb .NewTextStyle (),_aecb );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gaee *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggaba :=ctx ;_cecdg ,ctx ,_cfdbb :=_gaee ._gdcbd .GeneratePageBlocks (ctx );if _cfdbb !=nil {return _cecdg ,ctx ,_cfdbb ;};for _ ,_fbcdf :=range _gaee ._afec {_gdegc :=_fbcdf ._ecffff ;
if !_gaee ._baeda {_fbcdf ._ecffff =0;};_fffedc ,_fdgc ,_gddcd :=_fbcdf .GeneratePageBlocks (ctx );_fbcdf ._ecffff =_gdegc ;if _gddcd !=nil {return _cecdg ,ctx ,_gddcd ;};if len (_fffedc )< 1{continue ;};_cecdg [len (_cecdg )-1].mergeBlocks (_fffedc [0]);
_cecdg =append (_cecdg ,_fffedc [1:]...);ctx =_fdgc ;};if _gaee ._dcaba .IsRelative (){ctx .X =_ggaba .X ;};if _gaee ._dcaba .IsAbsolute (){return _cecdg ,_ggaba ,nil ;};return _cecdg ,ctx ,nil ;};

// SetStyleRight sets border style for right side.
func (_edb *border )SetStyleRight (style CellBorderStyle ){_edb ._bgfd =style };

// ParseFromSVGString creates a GraphicSVG instance from string SVG.
func ParseFromSVGString (svgStr string )(*GraphicSVGElement ,error ){return ParseFromSVGStream (_bd .NewReader (svgStr ));};

// SetMargins sets the Paragraph's margins.
func (_gbde *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_gbde ._dcbc .Left =left ;_gbde ._dcbc .Right =right ;_gbde ._dcbc .Top =top ;_gbde ._dcbc .Bottom =bottom ;};

// SetFont sets the Paragraph's font.
func (_egfegg *Paragraph )SetFont (font *_cb .PdfFont ){_egfegg ._effad =font };func (_gfca *Invoice )newColumn (_cgfbg string ,_geed CellHorizontalAlignment )*InvoiceCell {_ddga :=&InvoiceCell {_gfca ._gbdgc ,_cgfbg };_ddga .Alignment =_geed ;return _ddga ;
};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_dabc *Creator )SetPageSize (size PageSize ){_dabc ._bbfg =size ;_dabc ._eegg =size [0];_dabc ._bfbc =size [1];_fef :=0.1*_dabc ._eegg ;_dabc ._bea .Left =_fef ;_dabc ._bea .Right =_fef ;_dabc ._bea .Top =_fef ;_dabc ._bea .Bottom =_fef ;};

// SetHeight sets the height of the rectangle.
func (_daca *Rectangle )SetHeight (height float64 ){_daca ._baadd =height };func _cgba (_efda ,_beaff TextStyle )*Invoice {_bagcd :=&Invoice {_baggf :"\u0049N\u0056\u004f\u0049\u0043\u0045",_egbd :"\u002c\u0020",_dfae :_efda ,_fceb :_beaff };_bagcd ._cefag =&InvoiceAddress {Separator :_bagcd ._egbd };
_bagcd ._fdaa =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_bagcd ._egbd };_ggee :=ColorRGBFrom8bit (245,245,245);_degc :=ColorRGBFrom8bit (155,155,155);_bagcd ._fdaf =_beaff ;_bagcd ._fdaf .Color =_degc ;_bagcd ._fdaf .FontSize =20;
_bagcd ._adeb =_efda ;_bagcd ._cfbde =_beaff ;_bagcd ._fefc =_efda ;_bagcd ._agbc =_beaff ;_bagcd ._dcebd =_bagcd .NewCellProps ();_bagcd ._dcebd .BackgroundColor =_ggee ;_bagcd ._dcebd .TextStyle =_beaff ;_bagcd ._gbdgc =_bagcd .NewCellProps ();_bagcd ._gbdgc .TextStyle =_beaff ;
_bagcd ._gbdgc .BackgroundColor =_ggee ;_bagcd ._gbdgc .BorderColor =_ggee ;_bagcd ._ggaea =_bagcd .NewCellProps ();_bagcd ._ggaea .BorderColor =_ggee ;_bagcd ._ggaea .BorderSides =[]CellBorderSide {CellBorderSideBottom };_bagcd ._ggaea .Alignment =CellHorizontalAlignmentRight ;
_bagcd ._afca =_bagcd .NewCellProps ();_bagcd ._afca .Alignment =CellHorizontalAlignmentRight ;_bagcd ._dedbb =[2]*InvoiceCell {_bagcd .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_bagcd ._dcebd ),_bagcd .newCell ("",_bagcd ._dcebd )};
_bagcd ._adceg =[2]*InvoiceCell {_bagcd .newCell ("\u0044\u0061\u0074\u0065",_bagcd ._dcebd ),_bagcd .newCell ("",_bagcd ._dcebd )};_bagcd ._gcgd =[2]*InvoiceCell {_bagcd .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_bagcd ._dcebd ),_bagcd .newCell ("",_bagcd ._dcebd )};
_bagcd ._gddc =[2]*InvoiceCell {_bagcd .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_bagcd ._afca ),_bagcd .newCell ("",_bagcd ._afca )};_eddc :=_bagcd ._afca ;_eddc .TextStyle =_beaff ;_eddc .BackgroundColor =_ggee ;_eddc .BorderColor =_ggee ;
_bagcd ._agdaf =[2]*InvoiceCell {_bagcd .newCell ("\u0054\u006f\u0074a\u006c",_eddc ),_bagcd .newCell ("",_eddc )};_bagcd ._ffce =[2]string {"\u004e\u006f\u0074e\u0073",""};_bagcd ._gefef =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_bagcd ._cefb =[]*InvoiceCell {_bagcd .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_bagcd .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_bagcd .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_bagcd .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _bagcd ;};

// SetAlternateText sets the alternate text for the image.
func (_fcec *Image )SetAlternateText (text string ){_fcec ._dccba =text };

// SetFillOpacity sets the fill opacity.
func (_fgbfa *Polygon )SetFillOpacity (opacity float64 ){_fgbfa ._bddc =opacity };func _fdcaa (_eafbga ...interface{})[]interface{}{return _eafbga };

// NewImageFromData creates an Image from image data.
func (_adceb *Creator )NewImageFromData (data []byte )(*Image ,error ){return _ecgc (data )};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_ead *Creator )Draw (d Drawable )error {if _ead .getActivePage ()==nil {_ead .NewPage ();};_gfac ,_dcge ,_ccgb :=d .GeneratePageBlocks (_ead ._fdec );if _ccgb !=nil {return _ccgb ;};if len (_dcge ._eaba )> 0{_ead .Errors =append (_ead .Errors ,_dcge ._eaba ...);
};for _bebg ,_agec :=range _gfac {if _bebg > 0{_ead .NewPage ();};_adfda :=_ead .getActivePage ();if _fggc ,_gdfb :=_ead ._cgaf [_adfda ];_gdfb {if _cceg :=_fggc .mergeBlocks (_agec );_cceg !=nil {return _cceg ;};if _aac :=_ceg (_agec ._bg ,_fggc ._bg );
_aac !=nil {return _aac ;};}else {_ead ._cgaf [_adfda ]=_agec ;};};_ead ._fdec .X =_dcge .X ;_ead ._fdec .Y =_dcge .Y ;_ead ._fdec .Height =_aa .RoundDefault (_dcge .PageHeight -_dcge .Y -_dcge .Margins .Bottom );return nil ;};func (_gfgc *templateProcessor )parseBoolAttr (_egab ,_fdafb string )bool {_gg .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_egab ,_fdafb );
_egaga ,_ :=_fa .ParseBool (_fdafb );return _fdafb ==""||_egaga ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_dada float64 ;_dfdg float64 ;_gdfc float64 ;_addb float64 ;_gcfb Positioning ;_cfefb Color ;_abdd float64 ;_eagg Color ;_gdad float64 ;_fggg float64 ;_dede Margins ;_dddb FitMode ;_aadc *int64 ;};func (_gbcc *Image )rotatedSize ()(float64 ,float64 ){_gafba :=_gbcc ._efca ;
_cafd :=_gbcc ._efag ;_face :=_gbcc ._gegeb ;if _face ==0{return _gafba ,_cafd ;};_aaee :=_gga .Path {Points :[]_gga .Point {_gga .NewPoint (0,0).Rotate (_face ),_gga .NewPoint (_gafba ,0).Rotate (_face ),_gga .NewPoint (0,_cafd ).Rotate (_face ),_gga .NewPoint (_gafba ,_cafd ).Rotate (_face )}}.GetBoundingBox ();
return _aaee .Width ,_aaee .Height ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ceefb *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _ceefb ._adceg [0],_ceefb ._adceg [1]};func (_faec *Paragraph )getTextLineWidth (_ccac string )float64 {var _fcbg float64 ;for _ ,_cgad :=range _ccac {if _cgad =='\u000A'{continue ;};_afdcb ,_bcgac :=_faec ._effad .GetRuneMetrics (_cgad );
if !_bcgac {_gg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_cgad ,_cgad );
return -1;};_fcbg +=_faec ._dbcd *_afdcb .Wx ;};return _fcbg ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_agdg *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _agdg ._gcgd [0],_agdg ._gcgd [1]};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_afegb *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbbg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dbaeg ,_dbbe :=_gbbg .setOpacity (_afegb ._gfgf ,_afegb ._cfage );if _dbbe !=nil {return nil ,ctx ,_dbbe ;
};_babca :=_afegb ._gaffeg ;_babca .FillEnabled =_babca .FillColor !=nil ;var (_bbcd =ctx .PageHeight ;_aecbd =_babca .Curves ;_eabf =make ([]_gga .CubicBezierCurve ,0,len (_babca .Curves )););_ggff :=_cb .PdfRectangle {};for _bbbgd :=range _babca .Curves {_fffed :=_aecbd [_bbbgd ];
_fffed .P0 .Y =_bbcd -_fffed .P0 .Y ;_fffed .P1 .Y =_bbcd -_fffed .P1 .Y ;_fffed .P2 .Y =_bbcd -_fffed .P2 .Y ;_fffed .P3 .Y =_bbcd -_fffed .P3 .Y ;_eabf =append (_eabf ,_fffed );_cacc :=_fffed .GetBounds ();if _bbbgd ==0{_ggff =_cacc ;}else {_ggff .Llx =_a .Min (_ggff .Llx ,_cacc .Llx );
_ggff .Lly =_a .Min (_ggff .Lly ,_cacc .Lly );_ggff .Urx =_a .Max (_ggff .Urx ,_cacc .Urx );_ggff .Ury =_a .Max (_ggff .Ury ,_cacc .Ury );};};_babca .Curves =_eabf ;defer func (){_babca .Curves =_aecbd }();if _babca .FillEnabled {_dfbfc :=_bddf (_gbbg ,_afegb ._gaffeg .FillColor ,_afegb ._abbc ,func ()Rectangle {return Rectangle {_gbaf :_ggff .Llx ,_gcfge :_ggff .Lly ,_ggcb :_ggff .Width (),_baadd :_ggff .Height ()};
});if _dfbfc !=nil {return nil ,ctx ,_dfbfc ;};};_bdgef ,_ ,_dbbe :=_babca .MarkedDraw (_dbaeg ,_afegb ._acbcg );if _dbbe !=nil {return nil ,ctx ,_dbbe ;};if _dbbe =_gbbg .addContentsByString (string (_bdgef ));_dbbe !=nil {return nil ,ctx ,_dbbe ;};return []*Block {_gbbg },ctx ,nil ;
};

// SetRowPosition sets cell row position.
func (_afdb *TableCell )SetRowPosition (row int ){_afdb ._gbbed =row };

// NewFilledCurve returns a instance of filled curve.
func (_acgc *Creator )NewFilledCurve ()*FilledCurve {return _bbeba ()};

// FitMode returns the fit mode of the rectangle.
func (_bfgg *Rectangle )FitMode ()FitMode {return _bfgg ._bdde };

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetBackgroundColor sets the cell's background color.
func (_adbg *GridCell )SetBackgroundColor (col Color ){_adbg ._bbdf =col };func _abfb ()*Division {return &Division {_gccg :true }};func (_aec *Block )mergeBlocks (_df *Block )error {_eda :=_da (_aec ._fd ,_aec ._bg ,_df ._fd ,_df ._bg );if _eda !=nil {return _eda ;
};for _ ,_agd :=range _df ._ed {_aec .AddAnnotation (_agd );};return nil ;};

// SetMarkedContentID sets marked content ID.
func (_afdfg *FilledCurve )SetMarkedContentID (mcid int64 )*_cb .KDict {_afdfg ._eafb =&mcid ;_fagg :=_cb .NewKDictionary ();_fagg .S =_fac .MakeName (_cb .StructureTypeFigure );_fagg .K =_fac .MakeInteger (mcid );return _fagg ;};

// Lines returns all the lines the table of contents has.
func (_fagfb *TOC )Lines ()[]*TOCLine {return _fagfb ._afec };func (_dgfa *templateProcessor )run ()error {_cfcbf :=_cd .NewDecoder (_cc .NewReader (_dgfa ._ddfcb ));var _ebgcdd *templateNode ;for {_ceebb ,_afga :=_cfcbf .Token ();if _afga !=nil {if _afga ==_ad .EOF {return nil ;
};return _afga ;};if _ceebb ==nil {break ;};_cdcga ,_bfdbe :=_ededbe (_cfcbf );_dadd :=_cfcbf .InputOffset ();switch _cefe :=_ceebb .(type ){case _cd .StartElement :_gg .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_cefe .Name .Local );
_egbg ,_fedgb :=_cacfgc [_cefe .Name .Local ];if !_fedgb {if _dgfa ._eabee ==""{if _cdcga !=0{_gg .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_cefe .Name .Local ,_cdcga ,_bfdbe );
}else {_gg .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_cefe .Name .Local ,_dadd );
};}else {if _cdcga !=0{_gg .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_cefe .Name .Local ,_dgfa ._eabee ,_cdcga ,_bfdbe );
}else {_gg .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_cefe .Name .Local ,_dgfa ._eabee ,_dadd );
};};continue ;};_ebgcdd =&templateNode {_bcdgfa :_cefe ,_bedad :_ebgcdd ,_acfbc :_cdcga ,_ecddb :_bfdbe ,_eecg :_dadd };if _fbfcb :=_egbg ._fbedge ;_fbfcb !=nil {_ebgcdd ._dadec ,_afga =_fbfcb (_dgfa ,_ebgcdd );if _afga !=nil {return _afga ;};};case _cd .EndElement :_gg .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_cefe .Name .Local );
if _ebgcdd !=nil {if _ebgcdd ._dadec !=nil {if _aagaf :=_dgfa .renderNode (_ebgcdd );_aagaf !=nil {return _aagaf ;};};_ebgcdd =_ebgcdd ._bedad ;};case _cd .CharData :if _ebgcdd !=nil &&_ebgcdd ._dadec !=nil {if _ddbfb :=_dgfa .addNodeText (_ebgcdd ,string (_cefe ));
_ddbfb !=nil {return _ddbfb ;};};case _cd .Comment :_gg .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_cefe ));
};};return nil ;};

// SetOpacity sets the opacity of the line (0-1).
func (_affc *Line )SetOpacity (opacity float64 ){_affc ._gddge =opacity };type grayColor struct{_gadc float64 };

// ToContentCreator convert SVG and add elements contentstream then returns `contentstream.ContentCreator`.
func (_dceb *GraphicSVGElement )ToContentCreator (cc *_ae .ContentCreator ,res *_cb .PdfPageResources ,scaleX ,scaleY ,translateX ,translateY float64 )*_ae .ContentCreator {if _dceb .Name =="\u0073\u0076\u0067"{_dceb .SetScaling (scaleX ,scaleY );cc .Add_cm (1,0,0,1,translateX ,translateY );
_dceb .setDefaultScaling (_dceb ._dfgb );cc .Add_q ();_bfgeg :=_a .Max (scaleX ,scaleY );cc .Add_re (_dceb .ViewBox .X *_bfgeg ,_dceb .ViewBox .Y *_bfgeg ,_dceb .ViewBox .W *_bfgeg ,_dceb .ViewBox .H *_bfgeg );cc .Add_W ();cc .Add_n ();_dceb .processDefs ();
for _ ,_cbgcg :=range _dceb .Children {_cbgcg .ViewBox =_dceb .ViewBox ;_cbgcg ._decf =_dceb ._decf ;_cbgcg .toContentStream (cc ,res );};cc .Add_Q ();return cc ;};return nil ;};var PPMM =float64 (72*1.0/25.4);

// AddColorStop add color stop info for rendering gradient color.
func (_ddaa *RadialShading )AddColorStop (color Color ,point float64 ){_ddaa ._bbfaa .AddColorStop (color ,point );};

// GeneratePageBlocks generates the grid page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_cbgbaa *Grid )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _beff []*Block ;_dega :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cbgbaa .updateRowHeights (ctx .Width -_cbgbaa ._cacfg .Left -_cbgbaa ._cacfg .Right );_ddca :=_cbgbaa ._cacfg .Top ;
_ggce :=ctx ;if _cbgbaa ._decb .IsAbsolute (){ctx .X =_cbgbaa ._cbgba ;ctx .Y =_cbgbaa ._dgffa ;}else {ctx .X +=_cbgbaa ._cacfg .Left ;ctx .Y +=_ddca ;ctx .Width -=_cbgbaa ._cacfg .Left +_cbgbaa ._cacfg .Right ;ctx .Height -=_ddca ;};_ecgd :=ctx .Width ;
_aefc :=ctx .X ;_cafc :=ctx .Y ;_afaf :=ctx .Height ;_dffd :=0;_gfab :=false ;for _dcfa :=0;_dcfa < len (_cbgbaa ._bded );_dcfa ++{_fafd :=_cbgbaa ._bded [_dcfa ];_fbagc :=float64 (0.0);for _dgfbe :=_dffd ;_dgfbe < _fafd ._egag ;_dgfbe ++{_fbagc +=_cbgbaa ._bded [_dgfbe ]._aeaaa ;
};ctx .Height =_afaf -_fbagc ;if _gfab {_beff =append (_beff ,_dega );_dega =NewBlock (ctx .PageWidth ,ctx .PageHeight );_aefc =ctx .Margins .Left +_cbgbaa ._cacfg .Left ;_cafc =ctx .Margins .Top ;ctx .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;
ctx .Page ++;_afaf =ctx .Height ;_dffd =_dcfa ;_fbagc =0;_gfab =false ;};if _fafd ._aeaaa > ctx .Height {_fcbc :=_cbgbaa .cloneRow (_fafd ._egag );_bbae :=false ;for _gegd ,_efgc :=range _fafd ._cabf {switch _cfgcf :=_efgc ._aafg .(type ){case *StyledParagraph :_bacc :=ctx ;
_bacc .Height =_a .Floor (ctx .Height -_cfgcf ._dcbc .Top -_cfgcf ._dcbc .Bottom -0.5*_cfgcf .getTextHeight ());_bbbc ,_bafda ,_bcfcg :=_cfgcf .split (_bacc );if _bcfcg !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bcfcg );};if _bbbc !=nil &&_bafda !=nil &&_fcbc !=nil {_efgc .SetContent (_bbbc );
_fcbc ._cabf [_gegd ].SetContent (_bafda );_bbae =true ;};case *Division :_agda :=ctx ;_agda .Height =_a .Floor (ctx .Height -_cfgcf ._ccega .Top -_cfgcf ._ccega .Bottom );_aba ,_gcga :=_cfgcf .split (_agda );if _aba !=nil &&_gcga !=nil &&_fcbc !=nil {_efgc .SetContent (_aba );
_fcbc ._cabf [_gegd ].SetContent (_gcga );_bbae =true ;};case *List :_eeefg :=ctx ;_eeefg .Height =_a .Floor (ctx .Height -_cfgcf ._feba .Vertical ());_dgcd ,_edgc :=_cfgcf .split (_eeefg );if _dgcd !=nil &&_edgc !=nil &&_fcbc !=nil {_efgc .SetContent (_dgcd );
_fcbc ._cabf [_gegd ].SetContent (_edgc );_bbae =true ;};};};_gfab =true ;if _bbae {_cbgbaa .insertRowAfter (_fafd ._egag ,_fcbc );_fafd .updateRowHeight (_ecgd );_fcbc .updateRowHeight (_ecgd );}else {_dcfa -=1;continue ;};};for _ ,_gaef :=range _fafd ._cabf {_bbad :=_gaef .width (_cbgbaa ._ggcd ,_ecgd );
_bcgb :=float64 (0.0);for _baec :=0;_baec < _gaef ._gfde ;_baec ++{_bcgb +=_cbgbaa ._ggcd [_baec ]*_ecgd ;};_fbcb :=float64 (0.0);for _bgdfd :=0;_bgdfd < _gaef ._gcca ;_bgdfd ++{_fbcb +=_cbgbaa ._bded [_gaef ._dbab +_bgdfd ]._aeaaa ;};ctx .Width =_bbad ;
ctx .X =_aefc +_bcgb ;ctx .Y =_cafc +_fbagc ;_eded :=_gedd (ctx .X ,ctx .Y ,_bbad ,_fbcb );if _gaef ._bbdf !=nil {_eded .SetFillColor (_gaef ._bbdf );};_eded .SetOpacity (_gaef ._agefe );_eded .LineStyle =_gaef ._becd ;_eded ._gdg =_gaef ._afbbd ;_eded ._bgfd =_gaef ._aded ;
_eded ._dcac =_gaef ._adcea ;_eded ._bee =_gaef ._gbgf ;if _gaef ._feac !=nil {_eded .SetColorLeft (_gaef ._feac );};if _gaef ._egfeg !=nil {_eded .SetColorBottom (_gaef ._egfeg );};if _gaef ._fbfe !=nil {_eded .SetColorRight (_gaef ._fbfe );};if _gaef ._gbef !=nil {_eded .SetColorTop (_gaef ._gbef );
};_eded .SetWidthBottom (_gaef ._bgge );_eded .SetWidthLeft (_gaef ._dbaa );_eded .SetWidthRight (_gaef ._aegc );_eded .SetWidthTop (_gaef ._adbe );_cegf :=_dega .Draw (_eded );if _cegf !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cegf );
};if _gaef ._aafg !=nil {_cfba :=_gaef ._aafg .Width ();_fbec :=_gaef ._aafg .Height ();_feeg :=0.0;switch _bafdg :=_gaef ._aafg .(type ){case *Paragraph :if _bafdg ._cbca {_cfba =_bafdg .getMaxLineWidth ()/1000.0;};_bggf ,_bdeg ,_ :=_bafdg .getTextMetrics ();
_cfca ,_aace :=_bggf *_bafdg ._ccfga ,_bdeg *_bafdg ._ccfga ;_fbec =_fbec -_aace +_cfca ;_feeg +=_cfca -_aace ;_agdd :=0.5;switch _gaef ._cgcd {case CellVerticalAlignmentTop :_feeg +=_cfca *_agdd ;case CellVerticalAlignmentBottom :_feeg -=_cfca *_agdd ;
};_cfba +=_bafdg ._gebd .Left +_bafdg ._gebd .Right ;_fbec +=_bafdg ._gebd .Top +_bafdg ._gebd .Bottom ;case *StyledParagraph :if _bafdg ._cbcg {_cfba =_bafdg .getMaxLineWidth ()/1000.0;};_dcae ,_gcedgc ,_aaag :=_bafdg .getLineMetrics (0);_dacce ,_cbfbd :=_dcae *_bafdg ._dcag ,_gcedgc *_bafdg ._dcag ;
if _bafdg ._beagc ==TextVerticalAlignmentCenter {_feeg =_cbfbd -(_gcedgc +(_dcae +_aaag -_gcedgc )/2+(_cbfbd -_gcedgc )/2);};if len (_bafdg ._ebbfe )==1{_fbec =_dacce ;}else {_fbec =_fbec -_cbfbd +_dacce ;};_feeg +=_dacce -_cbfbd ;switch _gaef ._cgcd {case CellVerticalAlignmentTop :_feeg +=_dacce *0.5;
case CellVerticalAlignmentBottom :_feeg -=_dacce *0.5;};_cfba +=_bafdg ._dcbc .Left +_bafdg ._dcbc .Right ;_fbec +=_bafdg ._dcbc .Top +_bafdg ._dcbc .Bottom ;case *Table :_cfba =_bbad ;case *List :_cfba =_bbad ;case *Division :_cfba =_bbad ;case *Chart :_cfba =_bbad ;
case *Line :_fbec +=_bafdg ._bfgab .Top +_bafdg ._bfgab .Bottom ;_feeg -=_bafdg .Height ()/2;case *Image :_cfba +=_bafdg ._bcgd .Left +_bafdg ._bcgd .Right ;_fbec +=_bafdg ._bcgd .Top +_bafdg ._bcgd .Bottom ;};switch _gaef ._eedc {case CellHorizontalAlignmentLeft :ctx .X +=_gaef ._bccb ;
ctx .Width -=_gaef ._bccb ;case CellHorizontalAlignmentCenter :if _gadb :=_bbad -_cfba ;_gadb > 0{ctx .X +=_gadb /2;ctx .Width -=_gadb /2;};case CellHorizontalAlignmentRight :if _bbad > _cfba {ctx .X =ctx .X +_bbad -_cfba -_gaef ._bccb ;ctx .Width -=_gaef ._bccb ;
};};_bdbd :=ctx .Y ;_efeg :=ctx .Height ;ctx .Y +=_feeg ;switch _gaef ._cgcd {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _fbbc :=_fbcb -_fbec ;_fbbc > 0{ctx .Y +=_fbbc /2;ctx .Height -=_fbbc /2;};case CellVerticalAlignmentBottom :if _fbcb > _fbec {ctx .Y =ctx .Y +_fbcb -_fbec ;
ctx .Height =_fbcb ;};};_bega :=_dega .DrawWithContext (_gaef ._aafg ,ctx );if _bega !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bega );};ctx .Y =_bdbd ;ctx .Height =_efeg ;};};ctx .Y +=_fafd ._aeaaa ;};_beff =append (_beff ,_dega );
if _cbgbaa ._decb .IsAbsolute (){return _beff ,_ggce ,nil ;};ctx .X =_ggce .X ;ctx .Width =_ggce .Width ;ctx .Y +=_cbgbaa ._cacfg .Bottom ;ctx .Height -=_cbgbaa ._cacfg .Bottom ;return _beff ,ctx ,nil ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_ggeaf *Invoice )Terms ()(string ,string ){return _ggeaf ._gefef [0],_ggeaf ._gefef [1]};

// SetRowHeight sets the height for a specified row.
func (_feegb *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_feegb ._begfg ){return _ff .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_feegb ._begfg [row -1]=h ;return nil ;
};

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_gggac *Image )SetFitMode (fitMode FitMode ){_gggac ._fbbd =fitMode };func (_debe *Paragraph )getMaxLineWidth ()float64 {if _debe ._ffff ==nil ||(_debe ._ffff !=nil &&len (_debe ._ffff )==0){_debe .wrapText ();};var _ggad float64 ;for _ ,_dffa :=range _debe ._ffff {_afbc :=_debe .getTextLineWidth (_dffa );
if _afbc > _ggad {_ggad =_afbc ;};};return _ggad ;};func _fabc (_cabd []token )([]*Command ,error ){var (_eefgf []*Command ;_fcaa []float64 ;);for _dbbf :=len (_cabd )-1;_dbbf >=0;_dbbf --{_bdcdg :=_cabd [_dbbf ];if _bdcdg ._fgada {_ccfc :=_dbdfb ._fcbbg [_bd .ToLower (_bdcdg ._gaaf )];
_daaf :=len (_fcaa );if _ccfc ==0&&_daaf ==0{_ceagf :=&Command {Symbol :_bdcdg ._gaaf };_eefgf =append ([]*Command {_ceagf },_eefgf ...);}else if _ccfc !=0&&_daaf %_ccfc ==0{_degeb :=_daaf /_ccfc ;for _bbdef :=0;_bbdef < _degeb ;_bbdef ++{_efffb :=_bdcdg ._gaaf ;
if _efffb =="\u006d"&&_bbdef < _degeb -1{_efffb ="\u006c";};if _efffb =="\u004d"&&_bbdef < _degeb -1{_efffb ="\u004c";};_cdab :=&Command {_efffb ,_dagc (_fcaa [:_ccfc ])};_eefgf =append ([]*Command {_cdab },_eefgf ...);_fcaa =_fcaa [_ccfc :];};}else {_daabb :=pathParserError {"I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0070\u0061r\u0061\u006d\u0065\u0074\u0065\u0072\u0073\u0020\u0066\u006fr\u0020"+_bdcdg ._gaaf };
return nil ,_daabb ;};}else {_dbcbg ,_dbgg :=_cdadb (_bdcdg ._gaaf ,64);if _dbgg !=nil {return nil ,_dbgg ;};_fcaa =append (_fcaa ,_dbcbg );};};return _eefgf ,nil ;};type rgbColor struct{_ccaf ,_daefg ,_gafd float64 };

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_bdge *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _agae (x ,y ,innerRadius ,outerRadius ,colorPoints );};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_gadg *Paragraph )Height ()float64 {_gadg .wrapText ();return _aa .RoundDefault (float64 (len (_gadg ._ffff ))*_gadg ._ccfga *_gadg ._dbcd );};func (_fbag cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_dff :=_fbag ._deae ;return 1-(_fbag ._gaec *(1-_dff )+_dff ),1-(_fbag ._ceeb *(1-_dff )+_dff ),1-(_fbag ._adfa *(1-_dff )+_dff );
};var (ErrContentNotFit =_ff .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
);

// CreateFrontPage sets a function to generate a front Page.
func (_ccfd *Creator )CreateFrontPage (genFrontPageFunc func (_gabfc FrontpageFunctionArgs )){_ccfd ._afdf =genFrontPageFunc ;};func _ecdcg (_fccgf *templateProcessor ,_bdadd *templateNode )(interface{},error ){return _fccgf .parseTable (_bdadd );};

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_gcba *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _ddbe (x ,y ,width ,height );};func (_bgeag *templateProcessor )parseTextAlignmentAttr (_faabd ,_abfbe string )TextAlignment {_gg .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_faabd ,_abfbe );
_fdeaf :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_abfbe ];
return _fdeaf ;};

// Subpath is a collection of Commands, beginning with moveto command and
// usually ending with closepath command.
type Subpath struct{Commands []*Command ;};

// SetBorderColor sets the border color.
func (_eegga *PolyBezierCurve )SetBorderColor (color Color ){_eegga ._gaffeg .BorderColor =_cdfd (color )};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_dced *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fadg :=ctx ;var _gbdd []*Block ;_cggaf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _dced ._fafce .IsRelative (){ctx .X +=_dced ._dcbc .Left ;ctx .Y +=_dced ._dcbc .Top ;
ctx .Width -=_dced ._dcbc .Left +_dced ._dcbc .Right ;ctx .Height -=_dced ._dcbc .Top ;_dced .SetWidth (ctx .Width );}else {if int (_dced ._fgdfg )<=0{_dced .SetWidth (_dced .getTextWidth ()/1000.0);};ctx .X =_dced ._bged ;ctx .Y =_dced ._ecdab ;};if _dced ._afea !=nil {_dced ._afea (_dced ,ctx );
};if _fdag :=_dced .wrapText ();_fdag !=nil {return nil ,ctx ,_fdag ;};_bbdcg :=_dced ._ebbfe ;_eeff :=0;for {_acfc ,_becdg ,_bgbf :=_cbbcc (_cggaf ,_dced ,_bbdcg ,ctx );if _bgbf !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bgbf );
return nil ,ctx ,_bgbf ;};ctx =_acfc ;_gbdd =append (_gbdd ,_cggaf );if _bbdcg =_becdg ;len (_becdg )==0{break ;};if len (_becdg )==_eeff {return nil ,ctx ,_ff .New ("\u006e\u006f\u0074\u0020\u0065\u006e\u006f\u0075\u0067\u0068 \u0073\u0070\u0061\u0063\u0065\u0020\u0066o\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068");
};_cggaf =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_acfc =ctx ;_acfc .Y =ctx .Margins .Top ;_acfc .X =ctx .Margins .Left +_dced ._dcbc .Left ;_acfc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_acfc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dced ._dcbc .Left -_dced ._dcbc .Right ;
ctx =_acfc ;_eeff =len (_becdg );};if _dced ._fafce .IsRelative (){ctx .Y +=_dced ._dcbc .Bottom ;ctx .Height -=_dced ._dcbc .Bottom ;if !ctx .Inline {ctx .X =_fadg .X ;ctx .Width =_fadg .Width ;};return _gbdd ,ctx ,nil ;};return _gbdd ,_fadg ,nil ;};func (_decfb *templateProcessor )parseTextRenderingModeAttr (_ggfc ,_caaef string )TextRenderingMode {_gg .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ggfc ,_caaef );
_fdaafe :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_caaef ];
return _fdaafe ;};func (_cabg *StyledParagraph )wrapText ()error {return _cabg .wrapChunks (true )};func _faeae (_fbaga *templateProcessor ,_geebbe *templateNode )(interface{},error ){return _fbaga .parseList (_geebbe );};

// SetBorderOpacity sets the border opacity.
func (_fdac *CurvePolygon )SetBorderOpacity (opacity float64 ){_fdac ._efbg =opacity };

// SetBackground sets the background properties of the component.
func (_bfe *Division )SetBackground (background *Background ){_bfe ._babba =background };

// SetMarkedContentID sets the marked content id for the grid.
func (_eedbf *Grid )SetMarkedContentID (mcid int64 )*_cb .KDict {return nil };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//
//	[number] [title]      [separator] [page]
//
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_gdcbd *StyledParagraph ;_afec []*TOCLine ;_ccgabc TextStyle ;_aaeac TextStyle ;_befec TextStyle ;_cebfa TextStyle ;_cbgfb string ;_fadf float64 ;_ddbbfe Margins ;_dcaba Positioning ;_bbgcdb TextStyle ;_baeda bool ;};

// NewCurvePolygon creates a new curve polygon.
func (_bdee *Creator )NewCurvePolygon (rings [][]_gga .CubicBezierCurve )*CurvePolygon {return _abfd (rings );};

// SetIndent sets the left offset of the list when nested into another list.
func (_efceb *List )SetIndent (indent float64 ){_efceb ._fdb =indent ;_efceb ._cedb =false };

// SetOpacity sets the cell's opacity in the range 0-1.
func (_egagd *TableCell )SetOpacity (opacity float64 ){_egagd ._fbbfg =opacity };func _ffabg (_cgee [][]_gga .Point )*Polygon {return &Polygon {_bbbb :&_gga .Polygon {Points :_cgee },_bddc :1.0,_fcccc :1.0};};

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_beeb *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _dedb (xc ,yc ,width ,height );};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_bdc *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aege :=_gb .IdentityMatrix ();_ga ,_fc :=_bdc .Width (),_bdc .Height ();if _bdc ._fdg .IsRelative (){_aege =_aege .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_fc );
}else {_aege =_aege .Translate (_bdc ._gbb ,ctx .PageHeight -_bdc ._gbg -_fc );};_cda :=_fc ;if _bdc ._ccb !=0{_aege =_aege .Translate (_ga /2,_fc /2).Rotate (_bdc ._ccb *_a .Pi /180.0).Translate (-_ga /2,-_fc /2);_ ,_cda =_bdc .RotatedSize ();};if _bdc ._fdg .IsRelative (){ctx .Y +=_cda ;
};_eag :=_ae .NewContentCreator ();_eag .Add_cm (_aege [0],_aege [1],_aege [3],_aege [4],_aege [6],_aege [7]);_fe :=_bdc .duplicate ();_gf :=append (*_eag .Operations (),*_fe ._fd ...);_gf .WrapIfNeeded ();_fe ._fd =&_gf ;for _ ,_ccf :=range _bdc ._ed {_dg ,_cad :=_fac .GetArray (_ccf .Rect );
if !_cad ||_dg .Len ()!=4{_gg .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_ccf .Rect );
continue ;};_gaf ,_afd :=_cb .NewPdfRectangle (*_dg );if _afd !=nil {_gg .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_afd );
continue ;};_gaf .Transform (_aege );_ccf .Rect =_gaf .ToPdfObject ();};return []*Block {_fe },ctx ,nil ;};

// Write output of creator to io.Writer interface.
func (_ccef *Creator )Write (ws _ad .Writer )error {if _effc :=_ccef .Finalize ();_effc !=nil {return _effc ;};_gbac :="";if _dfgfa ,_dgf :=ws .(*_b .File );_dgf {_gbac =_dfgfa .Name ();};_bfdf :=_cb .NewPdfWriter ();_bfdf .SetOptimizer (_ccef ._ggda );
_bfdf .SetFileName (_gbac );if _ccef ._daaa !=nil {_bcea :=_bfdf .SetForms (_ccef ._daaa );if _bcea !=nil {_gg .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bcea );return _bcea ;};};if _ccef ._ffba !=nil {_bfdf .AddOutlineTree (_ccef ._ffba );
}else if _ccef ._gbcd !=nil &&_ccef .AddOutlines {_bfdf .AddOutlineTree (&_ccef ._gbcd .ToPdfOutline ().PdfOutlineTreeNode );};if _ccef ._eea !=nil {if _egfd :=_bfdf .SetPageLabels (_ccef ._eea );_egfd !=nil {_gg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_egfd );
return _egfd ;};};if _ccef ._ecfg !=nil {for _ ,_efed :=range _ccef ._ecfg {_gdd :=_efed .SubsetRegistered ();if _gdd !=nil {_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_gdd );
return _gdd ;};};};if _ccef ._cacf !=nil {_fbcc :=_ccef ._cacf (&_bfdf );if _fbcc !=nil {_gg .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_fbcc );return _fbcc ;};};for _caea ,_egfde :=range _ccef ._adce {_fgaac :=_bfdf .AddPage (_egfde );
if _fgaac !=nil {_gg .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_fgaac );return _fgaac ;};if _ccef ._daae !=nil {_edab :=_ccef ._daae .K ;_cfef ,_acbc :=_bfdf .GetPageIndirectObject (_caea );
if _acbc !=nil {_gg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0043\u006fu\u006c\u0064\u0020n\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061ge\u0020\u0069\u006ed\u0069\u0072e\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074 \u0025\u0076",_acbc );
};var _faa func (_gbeg *_cb .KDict );_faa =func (_feab *_cb .KDict ){if _feab ==nil {return ;};if _feab .GetPageNumber ()-1==int64 (_caea ){_feab .SetPage (_cfef );};for _ ,_fgfc :=range _feab .GetChildren (){if _edec :=_fgfc .GetKDict ();_edec !=nil {_faa (_edec );
};};};for _ ,_ffaf :=range _edab {_faa (_ffaf );};};};if _ccef ._daae !=nil {if _gafb :=_bfdf .SetCatalogStructTreeRoot (_ccef ._daae .ToPdfObject ());_gafb !=nil {_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020n\u006f\u0074\u0020\u0073\u0065\u0074 \u0053\u0074\u0072\u0075\u0063\u0074\u0054\u0072\u0065\u0065\u0052\u006f\u006ft\u003a\u0020\u0025\u0076",_gafb );
return _gafb ;};};if _ccef ._dcefd !=nil {if _eagde :=_bfdf .SetCatalogViewerPreferences (_ccef ._dcefd .ToPdfObject ());_eagde !=nil {_gg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065\u0074\u0020\u0056\u0069\u0065\u0077\u0065\u0072\u0050\u0072\u0065\u0066\u0065\u0072e\u006e\u0063\u0065\u0073\u003a\u0020\u0025\u0076",_eagde );
return _eagde ;};};if _ccef ._egfb !=""{if _dacc :=_bfdf .SetCatalogLanguage (_fac .MakeString (_ccef ._egfb ));_dacc !=nil {_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0073\u0065t\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u006c\u0061\u006e\u0067\u0075\u0061\u0067\u0065\u003a\u0020\u0025\u0076",_dacc );
return _dacc ;};};_beec :=_bfdf .Write (ws );if _beec !=nil {return _beec ;};return nil ;};

// SetActualText sets the actual text for the text chunk.
func (_fdead *TextChunk )SetActualText (text string ){_fdead ._adbfb =&text };func _fggad (_cfgcg *_b .File )([]*_cb .PdfPage ,error ){_eabbb ,_eaebb :=_cb .NewPdfReader (_cfgcg );if _eaebb !=nil {return nil ,_eaebb ;};_cbfgd ,_eaebb :=_eabbb .GetNumPages ();
if _eaebb !=nil {return nil ,_eaebb ;};var _fdcbdd []*_cb .PdfPage ;for _gafga :=0;_gafga < _cbfgd ;_gafga ++{_cecgbc ,_gcfgd :=_eabbb .GetPage (_gafga +1);if _gcfgd !=nil {return nil ,_gcfgd ;};_fdcbdd =append (_fdcbdd ,_cecgbc );};return _fdcbdd ,nil ;
};

// Width returns the current page width.
func (_gfe *Creator )Width ()float64 {return _gfe ._eegg };

// SetFillOpacity sets the fill opacity.
func (_gcedg *CurvePolygon )SetFillOpacity (opacity float64 ){_gcedg ._gaff =opacity };func (_cfaff *Invoice )generateTotalBlocks (_fgbed DrawContext )([]*Block ,DrawContext ,error ){_edbc :=_afddc (4);_edbc .SetMargins (0,0,10,10);_eegdb :=[][2]*InvoiceCell {_cfaff ._gddc };
_eegdb =append (_eegdb ,_cfaff ._cfgga ...);_eegdb =append (_eegdb ,_cfaff ._agdaf );for _ ,_fdddd :=range _eegdb {_cgae ,_cgggd :=_fdddd [0],_fdddd [1];if _cgggd .Value ==""{continue ;};_edbc .SkipCells (2);_fcff :=_edbc .NewCell ();_fcff .SetBackgroundColor (_cgae .BackgroundColor );
_fcff .SetHorizontalAlignment (_cgggd .Alignment );_cfaff .setCellBorder (_fcff ,_cgae );_cfdf :=_cedfb (_cgae .TextStyle );_cfdf .SetMargins (0,0,2,1);_cfdf .Append (_cgae .Value );_fcff .SetContent (_cfdf );_fcff =_edbc .NewCell ();_fcff .SetBackgroundColor (_cgggd .BackgroundColor );
_fcff .SetHorizontalAlignment (_cgggd .Alignment );_cfaff .setCellBorder (_fcff ,_cgae );_cfdf =_cedfb (_cgggd .TextStyle );_cfdf .SetMargins (0,0,2,1);_cfdf .Append (_cgggd .Value );_fcff .SetContent (_cfdf );};return _edbc .GeneratePageBlocks (_fgbed );
};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;);

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_ffbe *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dace :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dgca ,_fgcc :=_dace .setOpacity (_ffbe ._gaff ,_ffbe ._efbg );if _fgcc !=nil {return nil ,ctx ,_fgcc ;};
_egafg :=_ffbe ._bgecf ;_egafg .FillEnabled =_egafg .FillColor !=nil ;_egafg .BorderEnabled =_egafg .BorderColor !=nil &&_egafg .BorderWidth > 0;var (_cdga =ctx .PageHeight ;_aee =_egafg .Rings ;_fbbg =make ([][]_gga .CubicBezierCurve ,0,len (_egafg .Rings ));
);_gddb :=_cb .PdfRectangle {};if len (_aee )> 0&&len (_aee [0])> 0{_ebfad :=_aee [0][0];_ebfad .P0 .Y =_cdga -_ebfad .P0 .Y ;_ebfad .P1 .Y =_cdga -_ebfad .P1 .Y ;_ebfad .P2 .Y =_cdga -_ebfad .P2 .Y ;_ebfad .P3 .Y =_cdga -_ebfad .P3 .Y ;_gddb =_ebfad .GetBounds ();
};for _ ,_eac :=range _aee {_bgea :=make ([]_gga .CubicBezierCurve ,0,len (_eac ));for _ ,_dgce :=range _eac {_aceba :=_dgce ;_aceba .P0 .Y =_cdga -_aceba .P0 .Y ;_aceba .P1 .Y =_cdga -_aceba .P1 .Y ;_aceba .P2 .Y =_cdga -_aceba .P2 .Y ;_aceba .P3 .Y =_cdga -_aceba .P3 .Y ;
_bgea =append (_bgea ,_aceba );_bafa :=_aceba .GetBounds ();_gddb .Llx =_a .Min (_gddb .Llx ,_bafa .Llx );_gddb .Lly =_a .Min (_gddb .Lly ,_bafa .Lly );_gddb .Urx =_a .Max (_gddb .Urx ,_bafa .Urx );_gddb .Ury =_a .Max (_gddb .Ury ,_bafa .Ury );};_fbbg =append (_fbbg ,_bgea );
};_egafg .Rings =_fbbg ;defer func (){_egafg .Rings =_aee }();if _egafg .FillEnabled {_cace :=_bddf (_dace ,_ffbe ._bgecf .FillColor ,_ffbe ._bcge ,func ()Rectangle {return Rectangle {_gbaf :_gddb .Llx ,_gcfge :_gddb .Lly ,_ggcb :_gddb .Width (),_baadd :_gddb .Height ()};
});if _cace !=nil {return nil ,ctx ,_cace ;};};_gbfb ,_ ,_fgcc :=_egafg .MarkedDraw (_dgca ,_ffbe ._gbee );if _fgcc !=nil {return nil ,ctx ,_fgcc ;};if _fgcc =_dace .addContentsByString (string (_gbfb ));_fgcc !=nil {return nil ,ctx ,_fgcc ;};return []*Block {_dace },ctx ,nil ;
};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_bagf *Creator )AddPage (page *_cb .PdfPage )error {_gcd ,_gcgef :=_bagf .wrapPageIfNeeded (page );if _gcgef !=nil {return _gcgef ;};if _gcd !=nil {page =_gcd ;};_bace ,_gcgef :=page .GetMediaBox ();if _gcgef !=nil {_gg .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_gcgef );
return _gcgef ;};_bace .Normalize ();_adgg ,_gbfc :=_bace .Llx ,_bace .Lly ;_afac :=_bace ;if _dge :=page .CropBox ;_dge !=nil &&*_dge !=*_bace {_dge .Normalize ();_adgg ,_gbfc =_dge .Llx ,_dge .Lly ;_afac =_dge ;};_aeda :=_gb .IdentityMatrix ();_agea ,_gcgef :=page .GetRotate ();
if _gcgef !=nil {_gg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_gcgef .Error ());
};_gced :=_agea %360!=0&&_agea %90==0;if _gced {_fbd :=float64 ((360+_agea %360)%360);if _fbd ==90{_aeda =_aeda .Translate (_afac .Width (),0);}else if _fbd ==180{_aeda =_aeda .Translate (_afac .Width (),_afac .Height ());}else if _fbd ==270{_aeda =_aeda .Translate (0,_afac .Height ());
};_aeda =_aeda .Mult (_gb .RotationMatrix (_fbd *_a .Pi /180));_aeda =_aeda .Round (0.000001);_gbcb :=_edgcde (_afac ,_aeda );_afac =_gbcb ;_afac .Normalize ();};if _adgg !=0||_gbfc !=0{_aeda =_gb .TranslationMatrix (_adgg ,_gbfc ).Mult (_aeda );};if !_aeda .Identity (){_aeda =_aeda .Round (0.000001);
_bagf ._ebgc [page ]=&pageTransformations {_eeec :&_aeda };};_bagf ._eegg =_afac .Width ();_bagf ._bfbc =_afac .Height ();_bagf .initContext ();_bagf ._adce =append (_bagf ._adce ,page );_bagf ._fdec .Page ++;return nil ;};

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_egac *GraphicSVG )Scale (xFactor ,yFactor float64 ){_egac ._bggb .Width =xFactor *_egac ._bggb .Width ;_egac ._bggb .Height =yFactor *_egac ._bggb .Height ;_egac ._bggb .SetScaling (xFactor ,yFactor );};

// SetText sets the text content of the Paragraph.
func (_cddg *Paragraph )SetText (text string ){_cddg ._caec =text };

// BorderColor returns the border color of the rectangle.
func (_ggbf *Rectangle )BorderColor ()Color {return _ggbf ._edcc };

// NewTable create a new Table with a specified number of columns.
func (_dcbf *Creator )NewTable (cols int )*Table {return _afddc (cols )};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;
TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// SetLineWidth sets the line width.
func (_ggeaff *Polyline )SetLineWidth (lineWidth float64 ){_ggeaff ._daeaf .LineWidth =lineWidth };func (_gcb *pageTransformations )transformPage (_ddg *_cb .PdfPage )error {if _dead :=_gcb .applyFlip (_ddg );_dead !=nil {return _dead ;};return nil ;};


// GetCoords returns coordinates of border.
func (_fdce *border )GetCoords ()(float64 ,float64 ){return _fdce ._bbe ,_fdce ._efgd };

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// NewCell returns a new invoice table cell.
func (_bagd *Invoice )NewCell (value string )*InvoiceCell {return _bagd .newCell (value ,_bagd .NewCellProps ());};

// SetMakeredContentID sets the marked content identifier for the ellipse.
func (_efff *Ellipse )SetMarkedContentID (mcid int64 )*_cb .KDict {_efff ._aadc =&mcid ;_daea :=_cb .NewKDictionary ();_daea .S =_fac .MakeName (_cb .StructureTypeFigure );_daea .K =_fac .MakeInteger (mcid );return _daea ;};

// GridRow defines a row which can contain cells.
type GridRow struct{_cabf []*GridCell ;_cdbae float64 ;_aeaaa float64 ;_egag int ;_accg *Grid ;};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_ddgf Drawable )(Drawable ,error );};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_fg :=&Block {};_fg ._fd =&_ae .ContentStreamOperations {};_fg ._bg =_cb .NewPdfPageResources ();_fg ._db =width ;_fg ._ecf =height ;return _fg ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_efead *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_efead ._egaff =&_cb .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_dcbd *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gegaa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gcfff ,_bceff :=_gegaa .setOpacity (_dcbd ._bfbg ,_dcbd ._bfbg );if _bceff !=nil {return nil ,ctx ,_bceff ;
};_fdeg :=_dcbd ._daeaf .Points ;for _aafa :=range _fdeg {_aefge :=&_fdeg [_aafa ];_aefge .Y =ctx .PageHeight -_aefge .Y ;};_gbcbc ,_ ,_bceff :=_dcbd ._daeaf .MarkedDraw (_gcfff ,_dcbd ._fbabe );if _bceff !=nil {return nil ,ctx ,_bceff ;};if _bceff =_gegaa .addContentsByString (string (_gbcbc ));
_bceff !=nil {return nil ,ctx ,_bceff ;};return []*Block {_gegaa },ctx ,nil ;};

// Scale scales the rectangle dimensions by the specified factors.
func (_fcebf *Rectangle )Scale (xFactor ,yFactor float64 ){_fcebf ._ggcb =xFactor *_fcebf ._ggcb ;_fcebf ._baadd =yFactor *_fcebf ._baadd ;};type pageTransformations struct{_eeec *_gb .Matrix ;_bbgc bool ;_ccff bool ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_abfcg *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_abfcg ._afec =append (_abfcg ._afec ,line );return line ;};

// GetOptimizer returns current PDF optimizer.
func (_gbbf *Creator )GetOptimizer ()_cb .Optimizer {return _gbbf ._ggda };func (_fgbf *Block )addContentsByString (_cbf string )error {_bag :=_ae .NewContentStreamParser (_cbf );_caf ,_age :=_bag .Parse ();if _age !=nil {return _age ;};_fgbf ._fd .WrapIfNeeded ();
_caf .WrapIfNeeded ();*_fgbf ._fd =append (*_fgbf ._fd ,*_caf ...);return nil ;};func _bddf (_dfcdb *Block ,_agce _cb .PdfColor ,_fgfde Color ,_aedae func ()Rectangle )error {switch _bfcb :=_agce .(type ){case *_cb .PdfColorPatternType2 :_eaaac ,_ddfea :=_fgfde .(*LinearShading );
if !_ddfea {return _d .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_gfae :=_aedae ();_eaaac .SetBoundingBox (_gfae ._gbaf ,_gfae ._gcfge ,_gfae ._ggcb ,_gfae ._baadd );
_bacad ,_acdcb :=_eaaac .AddPatternResource (_dfcdb );if _acdcb !=nil {return _d .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_acdcb );
};_bfcb .PatternName =_bacad ;case *_cb .PdfColorPatternType3 :_ebbf ,_ggdab :=_fgfde .(*RadialShading );if !_ggdab {return _d .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_abeab :=_aedae ();_ebbf .SetBoundingBox (_abeab ._gbaf ,_abeab ._gcfge ,_abeab ._ggcb ,_abeab ._baadd );_fffdf ,_ccbdd :=_ebbf .AddPatternResource (_dfcdb );if _ccbdd !=nil {return _d .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_ccbdd );
};_bfcb .PatternName =_fffdf ;};return nil ;};

// SetFillOpacity sets the fill opacity of the rectangle.
func (_ggfd *Rectangle )SetFillOpacity (opacity float64 ){_ggfd ._abeed =opacity };

// SetMarkedContentID sets the marked content ID for the chapter.
func (_efce *Chapter )SetMarkedContentID (id int64 )*_cb .KDict {return nil };func (_dadg *templateProcessor )parseListMarker (_gfcg *templateNode )(interface{},error ){if _gfcg ._bedad ==nil {_dadg .nodeLogError (_gfcg ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_fbcba ;};var _cgeb *TextChunk ;switch _agadf :=_gfcg ._bedad ._dadec .(type ){case *List :_cgeb =&_agadf ._gbaeb ;case *listItem :_cgeb =&_agadf ._effcf ;default:_dadg .nodeLogError (_gfcg ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_agadf );
return nil ,_fbcba ;};if _ ,_ddeef :=_dadg .parseTextChunk (_gfcg ,_cgeb );_ddeef !=nil {_dadg .nodeLogError (_gfcg ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_ddeef );
return nil ,nil ;};return _cgeb ,nil ;};

// SetMargins sets the margins of the chart component.
func (_dag *Chart )SetMargins (left ,right ,top ,bottom float64 ){_dag ._dege .Left =left ;_dag ._dege .Right =right ;_dag ._dege .Top =top ;_dag ._dege .Bottom =bottom ;};

// SetDate sets the date of the invoice.
func (_acbg *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_acbg ._adceg [1].Value =date ;return _acbg ._adceg [0],_acbg ._adceg [1];};func (_gadbf *GridCell )height (_cdaf float64 )float64 {var _abfa float64 ;switch _bgeae :=_gadbf ._aafg .(type ){case *Paragraph :if _bgeae ._cbca {_bgeae .SetWidth (_cdaf -_gadbf ._bccb -_bgeae ._gebd .Left -_bgeae ._gebd .Right );
};_abfa =_bgeae .Height ()+_bgeae ._gebd .Top +_bgeae ._gebd .Bottom ;case *StyledParagraph :if _bgeae ._cbcg {_bgeae .SetWidth (_cdaf -_gadbf ._bccb -_bgeae ._dcbc .Left -_bgeae ._dcbc .Right );};_abfa =_bgeae .Height ()+_bgeae ._dcbc .Top +_bgeae ._dcbc .Bottom ;
case *Image :_bgeae .applyFitMode (_cdaf -_gadbf ._bccb );_abfa =_bgeae .Height ()+_bgeae ._bcgd .Top +_bgeae ._bcgd .Bottom ;case *Table :_bgeae .updateRowHeights (_cdaf -_gadbf ._bccb -_bgeae ._gdfeg .Left -_bgeae ._gdfeg .Right );_abfa =_bgeae .Height ()+_bgeae ._gdfeg .Top +_bgeae ._gdfeg .Bottom ;
case *List :_abfa =_bgeae .ctxHeight (_cdaf -_gadbf ._bccb )+_bgeae ._feba .Top +_bgeae ._feba .Bottom ;case *Division :_abfa =_bgeae .ctxHeight (_cdaf -_gadbf ._bccb )+_bgeae ._ccega .Top +_bgeae ._ccega .Bottom +_bgeae ._cacg .Top +_bgeae ._cacg .Bottom ;
case *Chart :_abfa =_bgeae .Height ()+_bgeae ._dege .Top +_bgeae ._dege .Bottom ;case *Rectangle :_bgeae .applyFitMode (_cdaf -_gadbf ._bccb );_abfa =_bgeae .Height ()+_bgeae ._gdea .Top +_bgeae ._gdea .Bottom +_bgeae ._afefe ;case *Ellipse :_bgeae .applyFitMode (_cdaf -_gadbf ._bccb );
_abfa =_bgeae .Height ()+_bgeae ._dede .Top +_bgeae ._dede .Bottom ;case *Line :_abfa =_bgeae .Height ()+_bgeae ._bfgab .Top +_bgeae ._bfgab .Bottom ;};return _abfa ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_fgcg *Chapter )NewSubchapter (title string )*Chapter {_eeca :=_acbbf (_fgcg ._egea ._eaad [0].Style .Font );_eeca .FontSize =14;_fgcg ._bce ++;_bbac :=_bbb (_fgcg ,_fgcg ._fgaf ,_fgcg ._eeee ,title ,_fgcg ._bce ,_eeca );_fgcg .Add (_bbac );return _bbac ;
};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_dacab *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_aaac *GridCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_aaac ._eedc =halign };

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_cgc *Block )ScaleToHeight (h float64 ){_ged :=h /_cgc ._ecf ;_cgc .Scale (_ged ,_ged )};

// SetStyleTop sets border style for top side.
func (_edf *border )SetStyleTop (style CellBorderStyle ){_edf ._dcac =style };func (_dfaed *List )ctxHeight (_dbdcf float64 )float64 {_dbdcf -=_dfaed ._fdb ;var _aabef float64 ;for _ ,_bbgae :=range _dfaed ._afab {_aabef +=_bbgae .ctxHeight (_dbdcf );};
return _aabef ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_eaf *Chapter )SetShowNumbering (show bool ){_eaf ._cdce =show ;_eaf ._egea .SetText (_eaf .headingText ());};

// GridCell defines a cell which can contain a Drawable as content.
type GridCell struct{_bbdf Color ;_agefe float64 ;_becd _gga .LineStyle ;_afbbd CellBorderStyle ;_feac Color ;_dbaa float64 ;_gbgf CellBorderStyle ;_egfeg Color ;_bgge float64 ;_aded CellBorderStyle ;_fbfe Color ;_aegc float64 ;_adcea CellBorderStyle ;
_gbef Color ;_adbe float64 ;_aafg VectorDrawable ;_dbab ,_gfde int ;_gcca int ;_cdfg int ;_eedc CellHorizontalAlignment ;_cgcd CellVerticalAlignment ;_bccb float64 ;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};var PPI float64 =72;

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_efcaa *Invoice )SetNoteStyle (style TextStyle ){_efcaa ._fefc =style };

// SetMargins sets the Grid's left, right, top, bottom margins.
func (_abec *Grid )SetMargins (left ,right ,top ,bottom float64 ){_abec ._cacfg .Left =left ;_abec ._cacfg .Right =right ;_abec ._cacfg .Top =top ;_abec ._cacfg .Bottom =bottom ;};

// SkipRows skips over a specified number of rows in the table.
func (_fbcdc *Table )SkipRows (num int ){_afdgc :=num *_fbcdc ._cfgeg -1;if _afdgc < 0{_gg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _abbd :=0;_abbd < _afdgc ;_abbd ++{_fbcdc .NewCell ();};};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_ffgac *Invoice )NoteStyle ()TextStyle {return _ffgac ._fefc };

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;

// SetBorderRadius sets the radius of the rectangle corners.
func (_gabc *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_gabc ._ddce =topLeft ;_gabc ._fbbee =topRight ;_gabc ._cffgb =bottomLeft ;_gabc ._ggfa =bottomRight ;};func (_eabacf *TextStyle )horizontalScale ()float64 {return _eabacf .HorizontalScaling /100};
func _cedfb (_cbgf TextStyle )*StyledParagraph {return &StyledParagraph {_eaad :[]*TextChunk {},_eeaba :_cbgf ,_bafbd :_bfcfe (_cbgf .Font ),_dcag :1.0,_gffa :TextAlignmentLeft ,_cbcg :true ,_gfff :true ,_gbdf :false ,_dbcga :0,_edag :1,_cfge :1,_fafce :PositionRelative ,_adcg :""};
};

// SetFillColor sets background color for border.
func (_bfbb *border )SetFillColor (col Color ){_bfbb ._bgf =col };func _dacbe (_ecbca rune )bool {return _ecbca =='('||_ecbca ==','||_ecbca ==')'};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_eaaab *TableCell )SetContent (vd VectorDrawable )error {switch _dcfgg :=vd .(type ){case *Paragraph :if _dcfgg ._cdgge {_dcfgg ._cbca =true ;};_eaaab ._bgfcf =vd ;case *StyledParagraph :if _dcfgg ._gfff {_dcfgg ._cbcg =true ;};_eaaab ._bgfcf =vd ;
case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_eaaab ._bgfcf =vd ;default:_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _fac .ErrTypeError ;};return nil ;};

// SetStyleBottom sets border style for bottom side.
func (_dbec *border )SetStyleBottom (style CellBorderStyle ){_dbec ._bee =style };func (_agfc *StyledParagraph )wrapWordChunks (){if !_agfc ._gbdf {return ;};var (_fded []*TextChunk ;_edccd *_cb .PdfFont ;);for _ ,_gdcf :=range _agfc ._eaad {_fbfgcg :=[]rune (_gdcf .Text );
if _edccd ==nil {_edccd =_gdcf .Style .Font ;};_bgeaad :=_gdcf ._fegffe ;_ddgg :=_gdcf .VerticalAlignment ;if len (_fded )> 0{if len (_fbfgcg )==1&&_eef .IsPunct (_fbfgcg [0])&&_gdcf .Style .Font ==_edccd {_ffbcg :=[]rune (_fded [len (_fded )-1].Text );
_fded [len (_fded )-1].Text =string (append (_ffbcg ,_fbfgcg [0]));continue ;}else {_ ,_gggdc :=_fa .Atoi (_gdcf .Text );if _gggdc ==nil {_cfcad :=[]rune (_fded [len (_fded )-1].Text );_cedd :=len (_cfcad );if _cedd >=2{_ ,_ccaef :=_fa .Atoi (string (_cfcad [_cedd -2]));
if _ccaef ==nil &&_eef .IsPunct (_cfcad [_cedd -1]){_fded [len (_fded )-1].Text =string (append (_cfcad ,_fbfgcg ...));continue ;};};};};};_gebgc ,_accgd :=_bcdfgc (_gdcf .Text );if _accgd !=nil {_gg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_accgd );
_gebgc =[]string {_gdcf .Text };};for _ ,_dcbgd :=range _gebgc {_bgebb :=NewTextChunk (_dcbgd ,_gdcf .Style );_bgebb ._fegffe =_aacd (_bgeaad );_bgebb .VerticalAlignment =_ddgg ;_fded =append (_fded ,_bgebb );};_edccd =_gdcf .Style .Font ;};if len (_fded )> 0{_agfc ._eaad =_fded ;
};};

// SetBorderOpacity sets the border opacity.
func (_cgdbg *Polygon )SetBorderOpacity (opacity float64 ){_cgdbg ._fcccc =opacity };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_bbfed *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_dcca :=NewTextChunk (text ,_bbfed ._bafbd );_dcca .AddAnnotation (_eebc (page -1,x ,y ,zoom ));return _bbfed .appendChunk (_dcca );};func (_aaaae *templateProcessor )parseMarginAttr (_ffed ,_gagbg string )Margins {_gg .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_ffed ,_gagbg );
_dcbcf :=Margins {};switch _dabg :=_bd .Fields (_gagbg );len (_dabg ){case 1:_dcbcf .Top ,_ =_fa .ParseFloat (_dabg [0],64);_dcbcf .Bottom =_dcbcf .Top ;_dcbcf .Left =_dcbcf .Top ;_dcbcf .Right =_dcbcf .Top ;case 2:_dcbcf .Top ,_ =_fa .ParseFloat (_dabg [0],64);
_dcbcf .Bottom =_dcbcf .Top ;_dcbcf .Left ,_ =_fa .ParseFloat (_dabg [1],64);_dcbcf .Right =_dcbcf .Left ;case 3:_dcbcf .Top ,_ =_fa .ParseFloat (_dabg [0],64);_dcbcf .Left ,_ =_fa .ParseFloat (_dabg [1],64);_dcbcf .Right =_dcbcf .Left ;_dcbcf .Bottom ,_ =_fa .ParseFloat (_dabg [2],64);
case 4:_dcbcf .Top ,_ =_fa .ParseFloat (_dabg [0],64);_dcbcf .Right ,_ =_fa .ParseFloat (_dabg [1],64);_dcbcf .Bottom ,_ =_fa .ParseFloat (_dabg [2],64);_dcbcf .Left ,_ =_fa .ParseFloat (_dabg [3],64);};return _dcbcf ;};func (_eege *templateProcessor )parseBackground (_adbdg *templateNode )(interface{},error ){_dbefa :=&Background {};
for _ ,_fcecf :=range _adbdg ._bcdgfa .Attr {_geadf :=_fcecf .Value ;switch _acfcd :=_fcecf .Name .Local ;_acfcd {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_dbefa .FillColor =_eege .parseColorAttr (_acfcd ,_geadf );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_dbefa .BorderColor =_eege .parseColorAttr (_acfcd ,_geadf );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_dbefa .BorderSize =_eege .parseFloatAttr (_acfcd ,_geadf );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_gfbbf ,_baegg ,_bgce ,_fbfd :=_eege .parseBorderRadiusAttr (_acfcd ,_geadf );
_dbefa .SetBorderRadius (_gfbbf ,_baegg ,_fbfd ,_bgce );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_dbefa .BorderRadiusTopLeft =_eege .parseFloatAttr (_acfcd ,_geadf );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_dbefa .BorderRadiusTopRight =_eege .parseFloatAttr (_acfcd ,_geadf );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_dbefa .BorderRadiusBottomLeft =_eege .parseFloatAttr (_acfcd ,_geadf );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_dbefa .BorderRadiusBottomRight =_eege .parseFloatAttr (_acfcd ,_geadf );
default:_eege .nodeLogDebug (_adbdg ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_acfcd );
};};return _dbefa ,nil ;};

// String implements error interface.
func (_fdefa UnsupportedRuneError )Error ()string {return _fdefa .Message };type listItem struct{_ggceb VectorDrawable ;_effcf TextChunk ;};func _efdb (_gcbag map[string ]interface{},_bdbbd ...interface{})(map[string ]interface{},error ){_bcdec :=len (_bdbbd );
if _bcdec %2!=0{return nil ,_fac .ErrRangeError ;};for _gdeg :=0;_gdeg < _bcdec ;_gdeg +=2{_fbagd ,_efdbf :=_bdbbd [_gdeg ].(string );if !_efdbf {return nil ,_fac .ErrTypeError ;};_gcbag [_fbagd ]=_bdbbd [_gdeg +1];};return _gcbag ,nil ;};

// NewPageBreak create a new page break.
func (_bdbg *Creator )NewPageBreak ()*PageBreak {return _bbbe ()};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _fb .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_ad .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_cb .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_cb .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_eb .ChartRenderable ;};func _eebc (_egacd int64 ,_gcecg ,_dcbdc ,_abce float64 )*_cb .PdfAnnotation {_fbeb :=_cb .NewPdfAnnotationLink ();_adaf :=_cb .NewBorderStyle ();_adaf .SetBorderWidth (0);_fbeb .BS =_adaf .ToPdfObject ();if _egacd < 0{_egacd =0;
};_fbeb .Dest =_fac .MakeArray (_fac .MakeInteger (_egacd ),_fac .MakeName ("\u0058\u0059\u005a"),_fac .MakeFloat (_gcecg ),_fac .MakeFloat (_dcbdc ),_fac .MakeFloat (_abce ));return _fbeb .PdfAnnotation ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_ecccd *RadialShading )ToPdfShadingPattern ()*_cb .PdfShadingPatternType3 {_fgece ,_cbged ,_fbdd :=_ecccd ._bbfaa ._acggc .ToRGB ();_gcagg :=_ecccd .shadingModel ();_gcagg .PdfShading .Background =_fac .MakeArrayFromFloats ([]float64 {_fgece ,_cbged ,_fbdd });
_bcdf :=_cb .NewPdfShadingPatternType3 ();_bcdf .Shading =_gcagg ;return _bcdf ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_ffeb *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fbbf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fbg :=_ae .NewContentCreator ();if _ffeb ._bafg !=nil {_fbg .Add_BDC (*_fac .MakeName (_cb .StructureTypeFigure ),map[string ]_fac .PdfObject {"\u004d\u0043\u0049\u0044":_fac .MakeInteger (*_ffeb ._bafg )});
};_fbg .Add_q ().Add_w (_ffeb ._aff ).SetStrokingColor (_cdfd (_ffeb ._agb )).Add_m (_ffeb ._cccg ,ctx .PageHeight -_ffeb ._dgdb ).Add_v (_ffeb ._cfeb ,ctx .PageHeight -_ffeb ._fbfg ,_ffeb ._feec ,ctx .PageHeight -_ffeb ._dgdbc ).Add_S ().Add_Q ();if _ffeb ._bafg !=nil {_fbg .Add_EMC ();
};_bfgb :=_fbbf .addContentsByString (_fbg .String ());if _bfgb !=nil {return nil ,ctx ,_bfgb ;};return []*Block {_fbbf },ctx ,nil ;};

// Height returns the Block's height.
func (_gc *Block )Height ()float64 {return _gc ._ecf };

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_bbfaa *shading ;_egaff *_cb .PdfRectangle ;_fadc AnchorPoint ;_efbgb float64 ;_cged float64 ;_efde float64 ;_fgcga float64 ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_gafcc *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_dgbab :=uint (len (_gafcc ._cefb ));if index > _dgbab {index =_dgbab ;};_fdgb :=_gafcc .NewColumn (description );_gafcc ._cefb =append (_gafcc ._cefb [:index ],append ([]*InvoiceCell {_fdgb },_gafcc ._cefb [index :]...)...);
return _fdgb ;};

// Level returns the indentation level of the TOC line.
func (_aeccc *TOCLine )Level ()uint {return _aeccc ._gfga };func _aggd (_cbfe _cd .StartElement )*GraphicSVGElement {_ccfg :=&GraphicSVGElement {};_cadb :=make (map[string ]string );for _ ,_ddee :=range _cbfe .Attr {_cadb [_ddee .Name .Local ]=_ddee .Value ;
};_ccfg .Name =_cbfe .Name .Local ;_ccfg .Attributes =_cadb ;_ccfg ._dfgb =1;if _ccfg .Name =="\u0073\u0076\u0067"{_geba ,_afdag :=_agbb (_cadb ["\u0076i\u0065\u0077\u0042\u006f\u0078"]);if _afdag !=nil {_gg .Log .Debug ("\u0055\u006ea\u0062\u006c\u0065\u0020t\u006f\u0020p\u0061\u0072\u0073\u0065\u0020\u0076\u0069\u0065w\u0042\u006f\u0078\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074e\u003a\u0020\u0025\u0076",_afdag );
return nil ;};if len (_geba )>=4{_ccfg .ViewBox .X =_geba [0];_ccfg .ViewBox .Y =_geba [1];_ccfg .ViewBox .W =_geba [2];_ccfg .ViewBox .H =_geba [3];};_ccfg .Width =_ccfg .ViewBox .W ;_ccfg .Height =_ccfg .ViewBox .H ;if _bedg ,_fced :=_cadb ["\u0077\u0069\u0064t\u0068"];
_fced {if _bd .HasSuffix (_bedg ,"\u0025"){_fccb ,_bcbf :=_fa .ParseFloat (_bd .TrimSuffix (_bedg ,"\u0025"),64);if _bcbf !=nil {_gg .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0077\u0069\u0064\u0074\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_bcbf );
return nil ;};_ccfg .Width =_fccb *_ccfg .ViewBox .W ;}else {_bbc ,_ggea :=_cdadb (_bedg ,64);if _ggea !=nil {_gg .Log .Debug ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073e\u0020\u0077\u0069\u0064\u0074\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_ggea );
return nil ;};_ccfg .Width =_bbc ;if len (_geba )< 4{_ccfg .ViewBox .W =_bbc ;};};};if _deda ,_fgfce :=_cadb ["\u0068\u0065\u0069\u0067\u0068\u0074"];_fgfce {if _bd .HasSuffix (_deda ,"\u0025"){_ddag ,_ggcg :=_fa .ParseFloat (_bd .TrimSuffix (_deda ,"\u0025"),64);
if _ggcg !=nil {_gg .Log .Debug ("\u0055\u006eab\u006c\u0065\u0020t\u006f\u0020\u0070\u0061rse\u0020he\u0069\u0067\u0068\u0074\u0020\u0061\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_ggcg );return nil ;};_ccfg .Height =_ddag *_ccfg .ViewBox .H ;
}else {_gebe ,_cfcf :=_cdadb (_deda ,64);if _cfcf !=nil {_gg .Log .Debug ("\u0055\u006eab\u006c\u0065\u0020t\u006f\u0020\u0070\u0061rse\u0020he\u0069\u0067\u0068\u0074\u0020\u0061\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020%\u0076",_cfcf );return nil ;
};_ccfg .Height =_gebe ;if len (_geba )< 4{_ccfg .ViewBox .H =_gebe ;};};};if _ccfg .Width > 0&&_ccfg .Height > 0{_ccfg ._dfgb =_ccfg .Width /_ccfg .ViewBox .W ;};};return _ccfg ;};func (_faeb *templateProcessor )nodeLogDebug (_ecaea *templateNode ,_ceec string ,_cegbc ...interface{}){_gg .Log .Debug (_faeb .getNodeErrorLocation (_ecaea ,_ceec ,_cegbc ...));
};func (_bgeaa *GraphicSVGElement )setDefaultScaling (_agdc float64 ){_bgeaa ._dfgb =_agdc ;if _bgeaa .Style !=nil &&_bgeaa .Style .StrokeWidth > 0{_bgeaa .Style .StrokeWidth =_bgeaa .Style .StrokeWidth *_bgeaa ._dfgb ;};for _ ,_cbac :=range _bgeaa .Children {_cbac .setDefaultScaling (_agdc );
};};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);func (_cdaa *Creator )initContext (){_cdaa ._fdec .X =_aa .RoundDefault (_cdaa ._bea .Left );_cdaa ._fdec .Y =_aa .RoundDefault (_cdaa ._bea .Top );
_cdaa ._fdec .Width =_aa .RoundDefault (_cdaa ._eegg -_cdaa ._bea .Right -_cdaa ._bea .Left );_cdaa ._fdec .Height =_aa .RoundDefault (_cdaa ._bfbc -_cdaa ._bea .Bottom -_cdaa ._bea .Top );_cdaa ._fdec .PageHeight =_aa .RoundDefault (_cdaa ._bfbc );_cdaa ._fdec .PageWidth =_aa .RoundDefault (_cdaa ._eegg );
_cdaa ._fdec .Margins =_cdaa ._bea ;_cdaa ._fdec ._fdecg =_cdaa .UnsupportedCharacterReplacement ;};func (_fdcbd *templateProcessor )parseListItem (_gdcb *templateNode )(interface{},error ){if _gdcb ._bedad ==nil {_fdcbd .nodeLogError (_gdcb ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_fbcba ;};_cfbdea ,_fccfc :=_gdcb ._bedad ._dadec .(*List );if !_fccfc {_fdcbd .nodeLogError (_gdcb ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_fbcba ;};_fcaac :=_cdced ();_fcaac ._effcf =_cfbdea ._gbaeb ;return _fcaac ,nil ;};

// SetBorderWidth sets the border width of the ellipse.
func (_gdbb *Ellipse )SetBorderWidth (bw float64 ){_gdbb ._gdad =bw };

// Margins returns the margins of the component.
func (_dgge *Division )Margins ()(_dcce ,_bgg ,_fddf ,_bacec float64 ){return _dgge ._ccega .Left ,_dgge ._ccega .Right ,_dgge ._ccega .Top ,_dgge ._ccega .Bottom ;};

// SetFontSize sets the font size in document units (points).
func (_cbfeg *Paragraph )SetFontSize (fontSize float64 ){_cbfeg ._dbcd =fontSize };

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_fcb *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fcb ._badf .Left ,_fcb ._badf .Right ,_fcb ._badf .Top ,_fcb ._badf .Bottom ;};

// Scale scales the ellipse dimensions by the specified factors.
func (_eeeaf *Ellipse )Scale (xFactor ,yFactor float64 ){_eeeaf ._gdfc =xFactor *_eeeaf ._gdfc ;_eeeaf ._addb =yFactor *_eeeaf ._addb ;};

// SetMarkedContentID sets the marked content ID.
func (_acaa *PageBreak )SetMarkedContentID (id int64 )*_cb .KDict {return nil };

// SetMarkedContentID sets the marked content ID.
func (_gbgcc *PolyBezierCurve )SetMarkedContentID (mcid int64 )*_cb .KDict {_gbgcc ._acbcg =&mcid ;_gaagd :=_cb .NewKDictionary ();_gaagd .S =_fac .MakeName (_cb .StructureTypeFigure );_gaagd .K =_fac .MakeInteger (mcid );return _gaagd ;};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_ecab *Division )SetPadding (left ,right ,top ,bottom float64 ){_ecab ._cacg .Left =left ;_ecab ._cacg .Right =right ;_ecab ._cacg .Top =top ;_ecab ._cacg .Bottom =bottom ;};

// SetBorderWidth sets the border width.
func (_cbcf *CurvePolygon )SetBorderWidth (borderWidth float64 ){_cbcf ._bgecf .BorderWidth =borderWidth ;};

// The Image type is used to draw an image onto PDF.
type Image struct{_bfad *_cb .XObjectImage ;_bgeac *_cb .Image ;_dccba string ;_gegeb float64 ;_efca ,_efag float64 ;_ddcae ,_decbc float64 ;_cecd Positioning ;_fdabf HorizontalAlignment ;_edbf float64 ;_ggcdc float64 ;_gdefg float64 ;_bcgd Margins ;_afef ,_geec float64 ;
_eedcc _fac .StreamEncoder ;_fbbd FitMode ;_ccefc bool ;_fbbe *int64 ;};

// AddColorStop add color stop information for rendering gradient.
func (_eede *shading )AddColorStop (color Color ,point float64 ){_eede ._bcbgf =append (_eede ._bcbgf ,_egba (color ,point ));};

// SetNumber sets the number of the invoice.
func (_eacg *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_eacg ._dedbb [1].Value =number ;return _eacg ._dedbb [0],_eacg ._dedbb [1];};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_cccc *shading )SetBackgroundColor (backgroundColor Color ){_cccc ._acggc =backgroundColor };

// AppendColumn appends a column to the line items table.
func (_eeae *Invoice )AppendColumn (description string )*InvoiceCell {_gddd :=_eeae .NewColumn (description );_eeae ._cefb =append (_eeae ._cefb ,_gddd );return _gddd ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_bfgc *Invoice )SetColumns (cols []*InvoiceCell ){_bfgc ._cefb =cols };

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_deca *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _deca ._gdea .Left ,_deca ._gdea .Right ,_deca ._gdea .Top ,_deca ._gdea .Bottom ;};

// Angle returns the block rotation angle in degrees.
func (_cdc *Block )Angle ()float64 {return _cdc ._ccb };

// GraphicSVGStyle represents style attributes for `GraphicSVG`.
type GraphicSVGStyle struct{FillColor string ;StrokeColor string ;StrokeWidth float64 ;FillOpacity float64 ;};func (_gcfcb *templateProcessor )parseFitModeAttr (_ffbd ,_gdged string )FitMode {_gg .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_ffbd ,_gdged );
_edae :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_gdged ];return _edae ;};const (FitModeNone FitMode =iota ;FitModeFillWidth ;);func (_fdaad *Subpath )compare (_ccceg *Subpath )bool {if len (_fdaad .Commands )!=len (_ccceg .Commands ){return false ;
};for _afdac ,_ebade :=range _fdaad .Commands {if !_ebade .compare (_ccceg .Commands [_afdac ]){return false ;};};return true ;};

// SetBorderColor sets the cell's border color.
func (_aeddf *TableCell )SetBorderColor (col Color ){_aeddf ._bfaa =col ;_aeddf ._agac =col ;_aeddf ._cbcac =col ;_aeddf ._cgfdb =col ;};

// SetBackgroundColor sets the cell's background color.
func (_dafg *TableCell )SetBackgroundColor (col Color ){_dafg ._fcdbg =col };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_ege *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ege ._afg .Left ,_ege ._afg .Right ,_ege ._afg .Top ,_ege ._afg .Bottom ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_aaagg *Invoice )SetTitleStyle (style TextStyle ){_aaagg ._fdaf =style };

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_bebc *Division )Width ()float64 {return 0};

// SellerAddress returns the seller address used in the invoice template.
func (_eaaad *Invoice )SellerAddress ()*InvoiceAddress {return _eaaad ._cefag };func _bedgb (_bgdbg *Creator ,_agbd string ,_eaabd []byte ,_aecga *TemplateOptions ,_bcgdc componentRenderer )*templateProcessor {if _aecga ==nil {_aecga =&TemplateOptions {};
};_aecga .init ();if _bcgdc ==nil {_bcgdc =_bgdbg ;};return &templateProcessor {creator :_bgdbg ,_ddfcb :_eaabd ,_debae :_aecga ,_fceeg :_bcgdc ,_eabee :_agbd };};

// Context returns the current drawing context.
func (_aca *Creator )Context ()DrawContext {return _aca ._fdec };func _dafed ()*GraphicSVGStyle {return &GraphicSVGStyle {FillColor :"\u00230\u0030\u0030\u0030\u0030\u0030",StrokeColor :"",StrokeWidth :0,FillOpacity :1.0};};func (_dfg *Chapter )headingNumber ()string {var _cbd string ;
if _dfg ._cdce {if _dfg ._ffg !=0{_cbd =_fa .Itoa (_dfg ._ffg )+"\u002e";};if _dfg ._edc !=nil {_daba :=_dfg ._edc .headingNumber ();if _daba !=""{_cbd =_daba +_cbd ;};};};return _cbd ;};func (_dbbd *Invoice )drawInformation ()*Table {_cagf :=_afddc (2);
_bcdd :=append ([][2]*InvoiceCell {_dbbd ._dedbb ,_dbbd ._adceg ,_dbbd ._gcgd },_dbbd ._gade ...);for _ ,_eeab :=range _bcdd {_bbbdd ,_ecaf :=_eeab [0],_eeab [1];if _ecaf .Value ==""{continue ;};_cdccd :=_cagf .NewCell ();_cdccd .SetBackgroundColor (_bbbdd .BackgroundColor );
_dbbd .setCellBorder (_cdccd ,_bbbdd );_fgbe :=_cedfb (_bbbdd .TextStyle );_fgbe .Append (_bbbdd .Value );_fgbe .SetMargins (0,0,2,1);_cdccd .SetContent (_fgbe );_cdccd =_cagf .NewCell ();_cdccd .SetBackgroundColor (_ecaf .BackgroundColor );_dbbd .setCellBorder (_cdccd ,_ecaf );
_fgbe =_cedfb (_ecaf .TextStyle );_fgbe .Append (_ecaf .Value );_fgbe .SetMargins (0,0,2,1);_cdccd .SetContent (_fgbe );};return _cagf ;};

// SetFillColor sets the fill color.
func (_gcdd *Polygon )SetFillColor (color Color ){_gcdd ._fegd =color ;_gcdd ._bbbb .FillColor =_cdfd (color );};func (_cade *GraphicSVGElement )drawLine (_ebada *_ae .ContentCreator ,_caece *_cb .PdfPageResources ){_ebada .Add_q ();_cade .Style .toContentStream (_ebada ,_caece ,_cade );
_cgedg ,_gcaff :=_cdadb (_cade .Attributes ["\u0078\u0031"],64);if _gcaff !=nil {_gg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gcaff .Error ());
};_gagdf ,_gcaff :=_cdadb (_cade .Attributes ["\u0079\u0031"],64);if _gcaff !=nil {_gg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gcaff .Error ());
};_afbg ,_gcaff :=_cdadb (_cade .Attributes ["\u0078\u0032"],64);if _gcaff !=nil {_gg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gcaff .Error ());
};_dcbdg ,_gcaff :=_cdadb (_cade .Attributes ["\u0079\u0032"],64);if _gcaff !=nil {_gg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0072\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gcaff .Error ());
};_ebada .Add_m (_cgedg *_cade ._dfgb ,_gagdf *_cade ._dfgb );_ebada .Add_l (_afbg *_cade ._dfgb ,_dcbdg *_cade ._dfgb );_cade .Style .fillStroke (_ebada );_ebada .Add_h ();_ebada .Add_Q ();};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//
//	red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_ccaf :float64 (r )/255.0,_daefg :float64 (g )/255.0,_gafd :float64 (b )/255.0};};func (_febec *templateProcessor )parseCellAlignmentAttr (_ddfa ,_daefa string )CellHorizontalAlignment {_gg .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ddfa ,_daefa );
_adaa :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_daefa ];return _adaa ;
};func (_dfaec *templateProcessor )renderNode (_fece *templateNode )error {_bbgcg :=_fece ._dadec ;if _bbgcg ==nil {return nil ;};_fegg :=_fece ._bcdgfa .Name .Local ;_cbdaa ,_bcgde :=_cacfgc [_fegg ];if !_bcgde {_dfaec .nodeLogDebug (_fece ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_fegg );
return nil ;};var _cega interface{};if _fece ._bedad !=nil &&_fece ._bedad ._dadec !=nil {_gccadc :=_fece ._bedad ._bcdgfa .Name .Local ;if _ ,_bcgde =_cbdaa ._bfaac [_gccadc ];!_bcgde {_dfaec .nodeLogDebug (_fece ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_gccadc ,_fegg );
return _fbcba ;};_cega =_fece ._bedad ._dadec ;}else {_caab :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _dfaec ._fceeg .(type ){case *Block :_caab ="\u0062\u006c\u006fc\u006b";};if _ ,_bcgde =_cbdaa ._bfaac [_caab ];!_bcgde {_dfaec .nodeLogDebug (_fece ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_caab ,_fegg );
return _fbcba ;};_cega =_dfaec ._fceeg ;};switch _cbabeg :=_cega .(type ){case componentRenderer :_bbdge ,_bebda :=_bbgcg .(Drawable );if !_bebda {_dfaec .nodeLogError (_fece ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_fegg ,_bbgcg );
return _beedb ;};_fbggc :=_cbabeg .Draw (_bbdge );if _fbggc !=nil {return _dfaec .nodeError (_fece ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_fegg ,_bbgcg ,_fbggc );
};case *Division :switch _ffcbb :=_bbgcg .(type ){case *Background :_cbabeg .SetBackground (_ffcbb );case VectorDrawable :_aagc :=_cbabeg .Add (_ffcbb );if _aagc !=nil {return _dfaec .nodeError (_fece ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_fegg ,_bbgcg ,_aagc );
};};case *TableCell :_abdg ,_eefc :=_bbgcg .(VectorDrawable );if !_eefc {_dfaec .nodeLogError (_fece ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_fegg ,_bbgcg );
return _beedb ;};_gaad :=_cbabeg .SetContent (_abdg );if _gaad !=nil {return _dfaec .nodeError (_fece ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_fegg ,_bbgcg ,_gaad );
};case *StyledParagraph :_aadcb ,_egfag :=_bbgcg .(*TextChunk );if !_egfag {_dfaec .nodeLogError (_fece ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_fegg ,_bbgcg );
return _beedb ;};_cbabeg .appendChunk (_aadcb );case *Chapter :switch _deccdd :=_bbgcg .(type ){case *Chapter :return nil ;case *StyledParagraph :if _fece ._bcdgfa .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_cbbf :=_cbabeg .Add (_deccdd );if _cbbf !=nil {return _dfaec .nodeError (_fece ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_fegg ,_bbgcg ,_cbbf );
};case Drawable :_bgaf :=_cbabeg .Add (_deccdd );if _bgaf !=nil {return _dfaec .nodeError (_fece ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_fegg ,_bbgcg ,_bgaf );
};};case *List :switch _egcgd :=_bbgcg .(type ){case *TextChunk :case *listItem :_cbabeg ._afab =append (_cbabeg ._afab ,_egcgd );default:_dfaec .nodeLogError (_fece ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_fegg ,_bbgcg );
};case *listItem :switch _bagfg :=_bbgcg .(type ){case *TextChunk :case *StyledParagraph :_cbabeg ._ggceb =_bagfg ;case *List :if _bagfg ._cedb {_bagfg ._fdb =15;};_cbabeg ._ggceb =_bagfg ;case *Image :_cbabeg ._ggceb =_bagfg ;case *Division :_cbabeg ._ggceb =_bagfg ;
case *Table :_cbabeg ._ggceb =_bagfg ;default:_dfaec .nodeLogError (_fece ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_fegg ,_bbgcg );
return _beedb ;};};return nil ;};

// SetBorderWidth sets the border width of the rectangle.
func (_acbabg *Rectangle )SetBorderWidth (bw float64 ){_acbabg ._afefe =bw };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_ageac *Paragraph )SetMaxLines (maxLines int ){_ageac ._fgggce =maxLines ;_ageac .wrapText ()};func (_efec *List )markerWidth ()float64 {var _dbaf float64 ;for _ ,_abfbd :=range _efec ._afab {_fdcc :=_cedfb (_efec ._aabgb );_fdcc .SetEnableWrap (false );
_fdcc .SetTextAlignment (TextAlignmentRight );_fdcc .Append (_abfbd ._effcf .Text ).Style =_abfbd ._effcf .Style ;_ggde :=_fdcc .getTextWidth ()/1000.0;if _dbaf < _ggde {_dbaf =_ggde ;};};return _dbaf ;};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_dbfd []VectorDrawable ;_dadf Positioning ;_ccega Margins ;_cacg Margins ;_dba bool ;_gccg bool ;_babba *Background ;};

// SetWidthRight sets border width for right.
func (_dafc *border )SetWidthRight (bw float64 ){_dafc ._gaeb =bw };func (_acdd *StyledParagraph )getLineMetrics (_gdfaf int )(_ggdf ,_fccfg ,_dbcc float64 ){if _acdd ._ebbfe ==nil ||(_acdd ._ebbfe !=nil &&len (_acdd ._ebbfe )==0){_acdd .wrapText ();};
if _gdfaf < 0||_gdfaf > len (_acdd ._ebbfe )-1{_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_gdfaf );
return 0,0,0;};_edge :=_acdd ._ebbfe [_gdfaf ];for _ ,_cafce :=range _edge {_fbgbf :=_gagfg (_cafce .Style .Font ,_cafce .Style .FontSize );if _fbgbf ._cabc > _ggdf {_ggdf =_fbgbf ._cabc ;};if _fbgbf ._bcbe < _dbcc {_dbcc =_fbgbf ._bcbe ;};if _ffad :=_cafce .Style .FontSize ;
_ffad > _fccfg {_fccfg =_ffad ;};};return _ggdf ,_fccfg ,_dbcc ;};func (_ceeaa *GraphicSVGElement )drawRect (_ffade *_ae .ContentCreator ,_fefgg *_cb .PdfPageResources ){_ffade .Add_q ();_ceeaa .Style .toContentStream (_ffade ,_fefgg ,_ceeaa );_bcdgf ,_gfge :=_cdadb (_ceeaa .Attributes ["\u0078"],64);
if _gfge !=nil {_gg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0078\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_gfge .Error ());};_cecgf ,_gfge :=_cdadb (_ceeaa .Attributes ["\u0079"],64);
if _gfge !=nil {_gg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0079\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_gfge .Error ());};_dcbfdb ,_gfge :=_cdadb (_ceeaa .Attributes ["\u0077\u0069\u0064t\u0068"],64);
if _gfge !=nil {_gg .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0073\u0074\u0072\u006f\u006b\u0065\u0020\u0077\u0069\u0064\u0074\u0068\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gfge .Error ());
};_effcfc ,_gfge :=_cdadb (_ceeaa .Attributes ["\u0068\u0065\u0069\u0067\u0068\u0074"],64);if _gfge !=nil {_gg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0077h\u0069\u006c\u0065 \u0070\u0061\u0072\u0073i\u006e\u0067\u0020\u0073\u0074\u0072\u006f\u006b\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_gfge .Error ());
};_ffade .Add_re (_bcdgf *_ceeaa ._dfgb ,_cecgf *_ceeaa ._dfgb ,_dcbfdb *_ceeaa ._dfgb ,_effcfc *_ceeaa ._dfgb );_ceeaa .Style .fillStroke (_ffade );_ffade .Add_Q ();};func _aeacg (_ebagf string )bool {_cfabg :=func (_ecceb rune )bool {return _ecceb =='\u000A'};
_ddbcc :=_bd .TrimFunc (_ebagf ,_cfabg );_bgfgf :=_ca .Paragraph {};_ ,_dagca :=_bgfgf .SetString (_ddbcc );if _dagca !=nil {return true ;};_gacee ,_dagca :=_bgfgf .Order ();if _dagca !=nil {return true ;};if _gacee .NumRuns ()< 1{return true ;};return _bgfgf .IsLeftToRight ();
};func (_fgdbb *templateProcessor )parseChapter (_gbdgf *templateNode )(interface{},error ){_bfeb :=_fgdbb .creator .NewChapter ;if _gbdgf ._bedad !=nil {if _efbcd ,_fdda :=_gbdgf ._bedad ._dadec .(*Chapter );_fdda {_bfeb =_efbcd .NewSubchapter ;};};_agccb :=_bfeb ("");
for _ ,_bdaaf :=range _gbdgf ._bcdgfa .Attr {_abcc :=_bdaaf .Value ;switch _efagb :=_bdaaf .Name .Local ;_efagb {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_agccb .SetShowNumbering (_fgdbb .parseBoolAttr (_efagb ,_abcc ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_agccb .SetIncludeInTOC (_fgdbb .parseBoolAttr (_efagb ,_abcc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bccfe :=_fgdbb .parseMarginAttr (_efagb ,_abcc );_agccb .SetMargins (_bccfe .Left ,_bccfe .Right ,_bccfe .Top ,_bccfe .Bottom );
default:_fgdbb .nodeLogDebug (_gbdgf ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_efagb );
};};return _agccb ,nil ;};

// SetBorder sets the cell's border style.
func (_gacd *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_gacd ._ccecb =CellBorderStyleSingle ;_gacd ._acdbg =width ;_gacd ._dgfe =CellBorderStyleSingle ;
_gacd ._aeefb =width ;_gacd ._bbgad =CellBorderStyleSingle ;_gacd ._eecfd =width ;_gacd ._edcda =CellBorderStyleSingle ;_gacd ._cdaeb =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_gacd ._ccecb =CellBorderStyleDouble ;_gacd ._acdbg =width ;
_gacd ._dgfe =CellBorderStyleDouble ;_gacd ._aeefb =width ;_gacd ._bbgad =CellBorderStyleDouble ;_gacd ._eecfd =width ;_gacd ._edcda =CellBorderStyleDouble ;_gacd ._cdaeb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_gacd ._ccecb =style ;
_gacd ._acdbg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_gacd ._dgfe =style ;_gacd ._aeefb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_gacd ._bbgad =style ;
_gacd ._eecfd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_gacd ._edcda =style ;_gacd ._cdaeb =width ;};};

// SetMarkedContentID sets the marked content id for the chart.
func (_fea *Chart )SetMarkedContentID (mcid int64 )*_cb .KDict {_fea ._ebb =&mcid ;_bgd :=_cb .NewKDictionary ();_bgd .S =_fac .MakeName (_cb .StructureTypeFigure );_bgd .K =_fac .MakeInteger (mcid );return _bgd ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_bdbgb *Invoice )AddressStyle ()TextStyle {return _bdbgb ._adeb };func (_adcd *GraphicSVGElement )getGradientAngle ()float64 {_dfeb ,_gafcb :=_adcd .Attributes ["\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0054\u0072\u0061\u006es\u0066\u006f\u0072\u006d"];
if _gafcb {_ddcg :=_bd .Fields (_dfeb );for _ ,_fgggc :=range _ddcg {_gdde :=_bd .FieldsFunc (_fgggc ,_dacbe );if len (_gdde )< 2{continue ;};if _gdde [0]=="\u0072\u006f\u0074\u0061\u0074\u0065"{_abgb ,_cbef :=_feffb (_gdde [1]);if _cbef !=nil {_gg .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_dfeb );
return 0.0;};return _abgb ;};};};return 0.0;};

// BorderWidth returns the border width of the ellipse.
func (_ffbc *Ellipse )BorderWidth ()float64 {return _ffbc ._gdad };func (_addbf *templateProcessor )parseEllipse (_fabbd *templateNode )(interface{},error ){_ccda :=_addbf .creator .NewEllipse (0,0,0,0);for _ ,_ggabf :=range _fabbd ._bcdgfa .Attr {_cebdc :=_ggabf .Value ;
switch _ecfff :=_ggabf .Name .Local ;_ecfff {case "\u0063\u0078":_ccda ._dada =_addbf .parseFloatAttr (_ecfff ,_cebdc );case "\u0063\u0079":_ccda ._dfdg =_addbf .parseFloatAttr (_ecfff ,_cebdc );case "\u0077\u0069\u0064t\u0068":_ccda .SetWidth (_addbf .parseFloatAttr (_ecfff ,_cebdc ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_ccda .SetHeight (_addbf .parseFloatAttr (_ecfff ,_cebdc ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_ccda .SetFillColor (_addbf .parseColorAttr (_ecfff ,_cebdc ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_ccda .SetFillOpacity (_addbf .parseFloatAttr (_ecfff ,_cebdc ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_ccda .SetBorderColor (_addbf .parseColorAttr (_ecfff ,_cebdc ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_ccda .SetBorderOpacity (_addbf .parseFloatAttr (_ecfff ,_cebdc ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_ccda .SetBorderWidth (_addbf .parseFloatAttr (_ecfff ,_cebdc ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_ccda .SetPositioning (_addbf .parsePositioningAttr (_ecfff ,_cebdc ));
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_ccda .SetFitMode (_addbf .parseFitModeAttr (_ecfff ,_cebdc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_dfddc :=_addbf .parseMarginAttr (_ecfff ,_cebdc );_ccda .SetMargins (_dfddc .Left ,_dfddc .Right ,_dfddc .Top ,_dfddc .Bottom );
default:_addbf .nodeLogDebug (_fabbd ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ecfff );
};};return _ccda ,nil ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_bbbb *_gga .Polygon ;_bddc float64 ;_fcccc float64 ;_fegd Color ;_agdcd *int64 ;};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_gagf *Creator )NewPolyBezierCurve (curves []_gga .CubicBezierCurve )*PolyBezierCurve {return _dgbc (curves );};

// Add adds a new line with the default style to the table of contents.
func (_caed *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_bafdb :=_caed .AddLine (_aegaed (TextChunk {Text :number ,Style :_caed ._ccgabc },TextChunk {Text :title ,Style :_caed ._aaeac },TextChunk {Text :page ,Style :_caed ._cebfa },level ,_caed ._bbgcdb ));
if _bafdb ==nil {return nil ;};_cdceda :=&_caed ._ddbbfe ;_bafdb .SetMargins (_cdceda .Left ,_cdceda .Right ,_cdceda .Top ,_cdceda .Bottom );_bafdb .SetLevelOffset (_caed ._fadf );_bafdb .Separator .Text =_caed ._cbgfb ;_bafdb .Separator .Style =_caed ._befec ;
return _bafdb ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_gccga *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_bcda :=_cedfb (_gccga ._aabgb );_bcda .Append (text );_aaea ,_egbc :=_gccga .Add (_bcda );return _bcda ,_aaea ,_egbc ;};type marginDrawable interface{VectorDrawable ;
GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// Width returns the width of the specified text chunk.
func (_ceeg *TextChunk )Width ()float64 {var (_ecbec float64 ;_bdcba =_ceeg .Style ;);for _ ,_edgcd :=range _ceeg .Text {_ggebcc ,_ffdce :=_bdcba .Font .GetRuneMetrics (_edgcd );if !_ffdce {_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_edgcd ,_edgcd ,_bdcba .Font .BaseFont (),_bdcba .Font .Subtype ());
_gg .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_bdcba .Font );_gg .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_bdcba .Font .Encoder ());};_bbbec :=_bdcba .FontSize *_ggebcc .Wx ;_eecga :=_bbbec ;if _edgcd !=' '{_eecga =_bbbec +_bdcba .CharSpacing *1000.0;
};_ecbec +=_eecga ;};return _ecbec /1000.0;};

// SetMarkedContentID sets the marked content identifier.
func (_dfcaf *Division )SetMarkedContentID (id int64 )*_cb .KDict {return nil };

// Width returns the width of the graphic svg.
func (_bdcf *GraphicSVG )Width ()float64 {return _bdcf ._bggb .Width };

// SetPos sets absolute positioning with specified coordinates.
func (_fggd *StyledParagraph )SetPos (x ,y float64 ){_fggd ._fafce =PositionAbsolute ;_fggd ._bged =x ;_fggd ._ecdab =y ;};func (_ecgde *templateProcessor )parseLinearGradientAttr (creator *Creator ,_ccfge string )Color {_gdffa :=ColorBlack ;if _ccfge ==""{return _gdffa ;
};_dbgf :=creator .NewLinearGradientColor ([]*ColorPoint {});_dbgf .SetExtends (true ,true );var (_bccbb =_bd .Split (_ccfge [16:len (_ccfge )-1],"\u002c");_dcacf =_bd .TrimSpace (_bccbb [0]););if _bd .HasSuffix (_dcacf ,"\u0064\u0065\u0067"){_gfdc ,_eaca :=_fa .ParseFloat (_dcacf [:len (_dcacf )-3],64);
if _eaca !=nil {_gg .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_eaca );}else {_dbgf .SetAngle (_gfdc );
};_bccbb =_bccbb [1:];};_gbbcf ,_ccdd :=_ecgde .processGradientColorPair (_bccbb );if _gbbcf ==nil ||_ccdd ==nil {return _gdffa ;};for _dgcg :=0;_dgcg < len (_gbbcf );_dgcg ++{_dbgf .AddColorStop (_gbbcf [_dgcg ],_ccdd [_dgcg ]);};return _dbgf ;};func _beace (_cccdda ,_affa interface{})(interface{},error ){_gfed ,_agaec :=_efdgg (_cccdda );
if _agaec !=nil {return nil ,_agaec ;};switch _dfcgg :=_gfed .(type ){case int64 :_dbfbc ,_abcf :=_efdgg (_affa );if _abcf !=nil {return nil ,_abcf ;};switch _caafb :=_dbfbc .(type ){case int64 :return _dfcgg +_caafb ,nil ;case float64 :return float64 (_dfcgg )+_caafb ,nil ;
};case float64 :_egfc ,_ebec :=_efdgg (_affa );if _ebec !=nil {return nil ,_ebec ;};switch _fadcg :=_egfc .(type ){case int64 :return _dfcgg +float64 (_fadcg ),nil ;case float64 :return _dfcgg +_fadcg ,nil ;};};return nil ,_d .Errorf ("\u0066\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0025\u0076\u0020\u0061\u006e\u0064\u0020\u0025\u0076",_cccdda ,_affa );
};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;func _afefb (_aaaa *_cd .Decoder )(*GraphicSVGElement ,error ){for {_fcbe ,_fgef :=_aaaa .Token ();if _fcbe ==nil &&_fgef ==_ad .EOF {break ;};if _fgef !=nil {return nil ,_fgef ;};switch _gaae :=_fcbe .(type ){case _cd .StartElement :return _aggd (_gaae ),nil ;
};};return &GraphicSVGElement {},nil ;};type token struct{_gaaf string ;_fgada bool ;};func (_cfgb *Invoice )generateInformationBlocks (_gfbe DrawContext )([]*Block ,DrawContext ,error ){_cbfcc :=_cedfb (_cfgb ._dfae );_cbfcc .SetMargins (0,0,0,20);_feeba :=_cfgb .drawAddress (_cfgb ._cefag );
_feeba =append (_feeba ,_cbfcc );_feeba =append (_feeba ,_cfgb .drawAddress (_cfgb ._fdaa )...);_dcdg :=_abfb ();for _ ,_agabc :=range _feeba {_dcdg .Add (_agabc );};_geeca :=_cfgb .drawInformation ();_fefaf :=_afddc (2);_fefaf .SetMargins (0,0,25,0);_bcffc :=_fefaf .NewCell ();
_bcffc .SetIndent (0);_bcffc .SetContent (_dcdg );_bcffc =_fefaf .NewCell ();_bcffc .SetContent (_geeca );return _fefaf .GeneratePageBlocks (_gfbe );};

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};type cmykColor struct{_gaec ,_ceeb ,_adfa ,_deae float64 };

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_ebfggd *Rectangle )GetCoords ()(float64 ,float64 ){return _ebfggd ._gbaf ,_ebfggd ._gcfge };func (_edgb *Creator )wrapPageIfNeeded (_edfb *_cb .PdfPage )(*_cb .PdfPage ,error ){_aabe ,_dggg :=_edfb .GetAllContentStreams ();if _dggg !=nil {return nil ,_dggg ;
};_ced :=_ae .NewContentStreamParser (_aabe );_aegb ,_dggg :=_ced .Parse ();if _dggg !=nil {return nil ,_dggg ;};if !_aegb .HasUnclosedQ (){return nil ,nil ;};_aegb .WrapIfNeeded ();_adgc ,_dggg :=_fac .MakeStream (_aegb .Bytes (),_fac .NewFlateEncoder ());
if _dggg !=nil {return nil ,_dggg ;};_edfb .Contents =_fac .MakeArray (_adgc );return _edfb ,nil ;};func _gbcg (_ddeeg ,_efdg ,_gfea ,_geae float64 )*Line {return &Line {_cdbgd :_ddeeg ,_bggef :_efdg ,_abdb :_gfea ,_ecff :_geae ,_ccfeb :ColorBlack ,_gddge :1.0,_fcfg :1.0,_cfcb :[]int64 {1,1},_fcfa :PositionAbsolute };
};func (_adcda *templateProcessor )parseHorizontalAlignmentAttr (_babg ,_dcdcc string )HorizontalAlignment {_gg .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_babg ,_dcdcc );
_fefb :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_dcdcc ];return _fefb ;};func (_gbebe *templateProcessor )parseParagraph (_cbgeb *templateNode ,_cdgc *StyledParagraph )(interface{},error ){if _cdgc ==nil {_cdgc =_gbebe .creator .NewStyledParagraph ();
};for _ ,_fecaa :=range _cbgeb ._bcdgfa .Attr {_accbb :=_fecaa .Value ;switch _ddafg :=_fecaa .Name .Local ;_ddafg {case "\u0066\u006f\u006e\u0074":_cdgc .SetFont (_gbebe .parseFontAttr (_ddafg ,_accbb ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_cdgc .SetFontSize (_gbebe .parseFloatAttr (_ddafg ,_accbb ));
case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_cdgc .SetTextAlignment (_gbebe .parseTextAlignmentAttr (_ddafg ,_accbb ));case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_cdgc .SetLineHeight (_gbebe .parseFloatAttr (_ddafg ,_accbb ));
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_cdgc .SetEnableWrap (_gbebe .parseBoolAttr (_ddafg ,_accbb ));case "\u0063\u006f\u006co\u0072":_cdgc .SetFontColor (_gbebe .parseColorAttr (_ddafg ,_accbb ));case "\u0078":_cdgc .SetPos (_gbebe .parseFloatAttr (_ddafg ,_accbb ),_cdgc ._ecdab );
case "\u0079":_cdgc .SetPos (_cdgc ._bged ,_gbebe .parseFloatAttr (_ddafg ,_accbb ));case "\u0061\u006e\u0067l\u0065":_cdgc .SetAngle (_gbebe .parseFloatAttr (_ddafg ,_accbb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_aafaf :=_gbebe .parseMarginAttr (_ddafg ,_accbb );
_cdgc .SetMargins (_aafaf .Left ,_aafaf .Right ,_aafaf .Top ,_aafaf .Bottom );case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_cdgc .SetMaxLines (int (_gbebe .parseInt64Attr (_ddafg ,_accbb )));default:_gbebe .nodeLogDebug (_cbgeb ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_ddafg );
};};return _cdgc ,nil ;};

// Append adds a new text chunk to the paragraph.
func (_aeacf *StyledParagraph )Append (text string )*TextChunk {_efccd :=NewTextChunk (text ,_aeacf ._eeaba );return _aeacf .appendChunk (_efccd );};func (_edgd *StyledParagraph )wrapChunks (_facd bool )error {if !_edgd ._cbcg ||int (_edgd ._fgdfg )<=0{_edgd ._ebbfe =[][]*TextChunk {_edgd ._eaad };
return nil ;};if _edgd ._gbdf {_edgd .wrapWordChunks ();};_edgd ._ebbfe =[][]*TextChunk {};var _agfg []*TextChunk ;var _ebdg float64 ;_faea :=_eef .IsSpace ;if !_facd {_faea =func (rune )bool {return false };};_ddbd :=_abfce (_edgd ._fgdfg *1000.0,0.000001);
for _ ,_eedca :=range _edgd ._eaad {_dcaa :=_eedca .Style ;_eddbe :=_eedca ._fegffe ;_ddgb :=_eedca .VerticalAlignment ;var (_bfec []rune ;_fffda []float64 ;);_ffdb :=_aeacg (_eedca .Text );for _ ,_dcfe :=range _eedca .Text {if _dcfe =='\u000A'{if !_facd {_bfec =append (_bfec ,_dcfe );
};_agfg =append (_agfg ,&TextChunk {Text :_bd .TrimRightFunc (string (_bfec ),_faea ),Style :_dcaa ,_fegffe :_aacd (_eddbe ),VerticalAlignment :_ddgb ,_afae :_eedca ._afae ,_deafg :_eedca ._deafg ,_adbfb :_eedca ._adbfb });if _dabd :=_edgd .addLine (_agfg );
!_dabd {return nil ;};_agfg =nil ;_ebdg =0;_bfec =nil ;_fffda =nil ;continue ;};_aefcg :=_dcfe ==' ';_caeeb ,_gfad :=_dcaa .Font .GetRuneMetrics (_dcfe );if _caeeb .Wx ==0&&_dcaa .MultiFont !=nil ||_dcaa .MultiFont !=nil &&!_gfad {_caeeb ,_gfad =_dcaa .MultiFont .GetRuneMetrics (_dcfe );
};if !_gfad {_gg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dcfe );return _ff .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_ebacd :=_dcaa .FontSize *_caeeb .Wx *_dcaa .horizontalScale ();_faaeb :=_ebacd ;if !_aefcg {_faaeb =_ebacd +_dcaa .CharSpacing *1000.0;};if _ebdg +_ebacd > _ddbd {_cadfc :=-1;if !_aefcg {for _dcgc :=len (_bfec )-1;_dcgc >=0;_dcgc --{if _bfec [_dcgc ]==' '{_cadfc =_dcgc ;
break ;};};};if _edgd ._gbdf {_geaag :=len (_agfg );if _geaag > 0{_agfg [_geaag -1].Text =_bd .TrimRightFunc (_agfg [_geaag -1].Text ,_faea );_edgd ._ebbfe =append (_edgd ._ebbfe ,_agfg );_agfg =[]*TextChunk {};};_bfec =append (_bfec ,_dcfe );_fffda =append (_fffda ,_faaeb );
if _cadfc >=0{_bfec =_bfec [_cadfc +1:];_fffda =_fffda [_cadfc +1:];};_ebdg =0;for _ ,_gdcg :=range _fffda {_ebdg +=_gdcg ;};if _ebdg > _ddbd {_deccd :=string (_bfec [:len (_bfec )-1]);_deccd =_bbgbc (_deccd ,_ffdb );if !_facd &&_aefcg {_deccd +="\u0020";
};_agfg =append (_agfg ,&TextChunk {Text :_bd .TrimRightFunc (_deccd ,_faea ),Style :_dcaa ,_fegffe :_aacd (_eddbe ),VerticalAlignment :_ddgb ,_afae :_eedca ._afae ,_deafg :_eedca ._deafg ,_adbfb :_eedca ._adbfb });if _fcgc :=_edgd .addLine (_agfg );!_fcgc {return nil ;
};_agfg =[]*TextChunk {};_bfec =[]rune {_dcfe };_fffda =[]float64 {_faaeb };_ebdg =_faaeb ;};continue ;};_cgafa :=string (_bfec );if _cadfc >=0{_cgafa =string (_bfec [0:_cadfc +1]);_bfec =_bfec [_cadfc +1:];_bfec =append (_bfec ,_dcfe );_fffda =_fffda [_cadfc +1:];
_fffda =append (_fffda ,_faaeb );_ebdg =0;for _ ,_cfbdg :=range _fffda {_ebdg +=_cfbdg ;};}else {if _aefcg {_ebdg =0;_bfec =[]rune {};_fffda =[]float64 {};}else {_ebdg =_faaeb ;_bfec =[]rune {_dcfe };_fffda =[]float64 {_faaeb };};};_cgafa =_bbgbc (_cgafa ,_ffdb );
if !_facd &&_aefcg {_cgafa +="\u0020";};_agfg =append (_agfg ,&TextChunk {Text :_bd .TrimRightFunc (_cgafa ,_faea ),Style :_dcaa ,_fegffe :_aacd (_eddbe ),VerticalAlignment :_ddgb ,_afae :_eedca ._afae ,_deafg :_eedca ._deafg ,_adbfb :_eedca ._adbfb });
if _deddg :=_edgd .addLine (_agfg );!_deddg {return nil ;};_agfg =[]*TextChunk {};}else {_ebdg +=_faaeb ;_bfec =append (_bfec ,_dcfe );_fffda =append (_fffda ,_faaeb );};};if len (_bfec )> 0{_cgdfb :=_bbgbc (string (_bfec ),_ffdb );_agfg =append (_agfg ,&TextChunk {Text :_cgdfb ,Style :_dcaa ,_fegffe :_aacd (_eddbe ),VerticalAlignment :_ddgb ,_afae :_eedca ._afae ,_deafg :_eedca ._deafg ,_adbfb :_eedca ._adbfb });
};};if len (_agfg )> 0{if _baaddg :=_edgd .addLine (_agfg );!_baaddg {return nil ;};};return nil ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_afb *Creator )MoveTo (x ,y float64 ){_afb ._fdec .X =x ;_afb ._fdec .Y =y };

// SetAnchor set gradient position anchor.
// Default to center.
func (_ebgf *RadialShading )SetAnchor (anchor AnchorPoint ){_ebgf ._fadc =anchor };func (_eadfd *templateProcessor )parseLinkAttr (_gbacd ,_agdgb string )*_cb .PdfAnnotation {_agdgb =_bd .TrimSpace (_agdgb );if _bd .HasPrefix (_agdgb ,"\u0075\u0072\u006c(\u0027")&&_bd .HasSuffix (_agdgb ,"\u0027\u0029")&&len (_agdgb )> 7{return _bbca (_agdgb [5:len (_agdgb )-2]);
};if _bd .HasPrefix (_agdgb ,"\u0070\u0061\u0067e\u0028")&&_bd .HasSuffix (_agdgb ,"\u0029")&&len (_agdgb )> 6{var (_ebdf error ;_gcffgf int64 ;_facaa float64 ;_gbdea float64 ;_bcegf =1.0;_eabaf =_bd .Split (_agdgb [5:len (_agdgb )-1],"\u002c"););_gcffgf ,_ebdf =_fa .ParseInt (_bd .TrimSpace (_eabaf [0]),10,64);
if _ebdf !=nil {_gg .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ebdf );return nil ;};if len (_eabaf )>=2{_facaa ,_ebdf =_fa .ParseFloat (_bd .TrimSpace (_eabaf [1]),64);
if _ebdf !=nil {_gg .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ebdf );
return nil ;};};if len (_eabaf )>=3{_gbdea ,_ebdf =_fa .ParseFloat (_bd .TrimSpace (_eabaf [2]),64);if _ebdf !=nil {_gg .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ebdf );
return nil ;};};if len (_eabaf )>=4{_bcegf ,_ebdf =_fa .ParseFloat (_bd .TrimSpace (_eabaf [3]),64);if _ebdf !=nil {_gg .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ebdf );
return nil ;};};return _eebc (_gcffgf -1,_facaa ,_gbdea ,_bcegf );};return nil ;};func (_ecaag *Table )resetColumnWidths (){_ecaag ._bcbd =[]float64 {};_adcba :=float64 (1.0)/float64 (_ecaag ._cfgeg );for _gbace :=0;_gbace < _ecaag ._cfgeg ;_gbace ++{_ecaag ._bcbd =append (_ecaag ._bcbd ,_adcba );
};};func _bcgbdc (_cdfae *templateProcessor ,_aaef *templateNode )(interface{},error ){return _cdfae .parseDivision (_aaef );};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_deabbf *LinearShading )AddShadingResource (block *Block )(_eccdf _fac .PdfObjectName ,_bfcf error ){_cbbdd :=1;_eccdf =_fac .PdfObjectName ("\u0053\u0068"+_fa .Itoa (_cbbdd ));for block ._bg .HasShadingByName (_eccdf ){_cbbdd ++;_eccdf =_fac .PdfObjectName ("\u0053\u0068"+_fa .Itoa (_cbbdd ));
};if _efcc :=block ._bg .SetShadingByName (_eccdf ,_deabbf .shadingModel ().ToPdfObject ());_efcc !=nil {return "",_efcc ;};return _eccdf ,nil ;};

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_eaegb *shading )SetExtends (start bool ,end bool ){_eaegb ._aadd =[]bool {start ,end }};

// SetNotes sets the notes section of the invoice.
func (_fgedf *Invoice )SetNotes (title ,content string ){_fgedf ._ffce =[2]string {title ,content }};func (_adfaa *templateProcessor )parseColor (_baaf string )Color {if _baaf ==""{return nil ;};_aebce ,_bdgab :=_adfaa ._debae .ColorMap [_baaf ];if _bdgab {return _aebce ;
};if _baaf [0]=='#'{return ColorRGBFromHex (_baaf );};return nil ;};func _gedb (_adabg string ,_gedfg ,_ddafd TextStyle )*TOC {_bgdee :=_ddafd ;_bgdee .FontSize =14;_bgbad :=_cedfb (_bgdee );_bgbad .SetEnableWrap (true );_bgbad .SetTextAlignment (TextAlignmentLeft );
_bgbad .SetMargins (0,0,0,5);_bgae :=_bgbad .Append (_adabg );_bgae .Style =_bgdee ;return &TOC {_gdcbd :_bgbad ,_afec :[]*TOCLine {},_ccgabc :_gedfg ,_aaeac :_gedfg ,_befec :_gedfg ,_cebfa :_gedfg ,_cbgfb :"\u002e",_fadf :10,_ddbbfe :Margins {0,0,2,2},_dcaba :PositionRelative ,_bbgcdb :_gedfg ,_baeda :true };
};

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_gdgc *Rectangle )SetCoords (x ,y float64 ){_gdgc ._gbaf =x ;_gdgc ._gcfge =y };func (_fdeae *Table )wrapRow (_afddg int ,_cgcaa DrawContext ,_gffed float64 )(bool ,error ){if !_fdeae ._cacgg {return false ,nil ;};var (_efadb =_fdeae ._gcbaa [_afddg ];
_fdffa =-1;_bcbda []*TableCell ;_adcae float64 ;_eccda bool ;_dgedc =make ([]float64 ,0,len (_fdeae ._bcbd )););_cceedc :=func (_acdb *TableCell ,_bgagd VectorDrawable ,_ebedd bool )*TableCell {_accbc :=*_acdb ;_accbc ._bgfcf =_bgagd ;if _ebedd {_accbc ._gbbed ++;
};return &_accbc ;};_cdbfd :=func (_faba int ,_aebfd VectorDrawable ){var _gebaf float64 =-1;if _aebfd ==nil {if _agaac :=_dgedc [_faba -_afddg ];_agaac > _cgcaa .Height {_aebfd =_fdeae ._gcbaa [_faba ]._bgfcf ;_fdeae ._gcbaa [_faba ]._bgfcf =nil ;_dgedc [_faba -_afddg ]=0;
_gebaf =_agaac ;};};_ecbdef :=_cceedc (_fdeae ._gcbaa [_faba ],_aebfd ,true );_bcbda =append (_bcbda ,_ecbdef );if _gebaf < 0{_gebaf =_ecbdef .height (_cgcaa .Width );};if _gebaf > _adcae {_adcae =_gebaf ;};};for _daffbg :=_afddg ;_daffbg < len (_fdeae ._gcbaa );
_daffbg ++{_gcfga :=_fdeae ._gcbaa [_daffbg ];if _efadb ._gbbed !=_gcfga ._gbbed {_fdffa =_daffbg ;break ;};_cgcaa .Width =_gcfga .width (_fdeae ._bcbd ,_gffed );_afdeca :=_gcfga .height (_cgcaa .Width );var _ccag VectorDrawable ;switch _fcbbga :=_gcfga ._bgfcf .(type ){case *StyledParagraph :if _afdeca > _cgcaa .Height {_deggd :=_cgcaa ;
_deggd .Height =_a .Floor (_cgcaa .Height -_fcbbga ._dcbc .Top -_fcbbga ._dcbc .Bottom -0.5*_fcbbga .getTextHeight ());_eebb ,_daed ,_cgdgg :=_fcbbga .split (_deggd );if _cgdgg !=nil {return false ,_cgdgg ;};if _eebb !=nil &&_daed !=nil {_fcbbga =_eebb ;
_gcfga =_cceedc (_gcfga ,_eebb ,false );_fdeae ._gcbaa [_daffbg ]=_gcfga ;_ccag =_daed ;_eccda =true ;};_afdeca =_gcfga .height (_cgcaa .Width );};case *Division :if _afdeca > _cgcaa .Height {_bfced :=_cgcaa ;_bfced .Height =_a .Floor (_cgcaa .Height -_fcbbga ._ccega .Top -_fcbbga ._ccega .Bottom );
_daefb ,_bdeae :=_fcbbga .split (_bfced );if _daefb !=nil &&_bdeae !=nil {_fcbbga =_daefb ;_gcfga =_cceedc (_gcfga ,_daefb ,false );_fdeae ._gcbaa [_daffbg ]=_gcfga ;_ccag =_bdeae ;_eccda =true ;if _daefb ._babba !=nil {_daefb ._babba .BorderRadiusBottomLeft =0;
_daefb ._babba .BorderRadiusBottomRight =0;};if _bdeae ._babba !=nil {_bdeae ._babba .BorderRadiusTopLeft =0;_bdeae ._babba .BorderRadiusTopRight =0;};_afdeca =_gcfga .height (_cgcaa .Width );};};case *List :if _afdeca > _cgcaa .Height {_dcad :=_cgcaa ;
_dcad .Height =_a .Floor (_cgcaa .Height -_fcbbga ._feba .Vertical ());_cbfeb ,_afefeb :=_fcbbga .split (_dcad );if _cbfeb !=nil {_fcbbga =_cbfeb ;_gcfga =_cceedc (_gcfga ,_cbfeb ,false );_fdeae ._gcbaa [_daffbg ]=_gcfga ;};if _afefeb !=nil {_ccag =_afefeb ;
_eccda =true ;};_afdeca =_gcfga .height (_cgcaa .Width );};};_dgedc =append (_dgedc ,_afdeca );if _eccda {if _bcbda ==nil {_bcbda =make ([]*TableCell ,0,len (_fdeae ._bcbd ));for _fddfd :=_afddg ;_fddfd < _daffbg ;_fddfd ++{_cdbfd (_fddfd ,nil );};};_cdbfd (_daffbg ,_ccag );
};};var _bbfgg float64 ;for _ ,_aacgf :=range _dgedc {if _aacgf > _bbfgg {_bbfgg =_aacgf ;};};if _eccda &&_bbfgg < _cgcaa .Height {if _fdffa < 0{_fdffa =len (_fdeae ._gcbaa );};_deea :=_fdeae ._gcbaa [_fdffa -1]._gbbed +_fdeae ._gcbaa [_fdffa -1]._dfgcc -1;
for _fegdg :=_fdffa ;_fegdg < len (_fdeae ._gcbaa );_fegdg ++{_fdeae ._gcbaa [_fegdg ]._gbbed ++;};_fdeae ._gcbaa =append (_fdeae ._gcbaa [:_fdffa ],append (_bcbda ,_fdeae ._gcbaa [_fdffa :]...)...);_fdeae ._begfg =append (_fdeae ._begfg [:_deea ],append ([]float64 {_adcae },_fdeae ._begfg [_deea :]...)...);
_fdeae ._begfg [_efadb ._gbbed +_efadb ._dfgcc -2]=_bbfgg ;};return _eccda ,nil ;};

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_cafb Color ;_fafb float64 ;};func _daeage (_bfce *GraphicSVGElement ,_caccg *_ae .ContentCreator ){_bggff ,_ggefc :=_bfce .Attributes ["\u0074r\u0061\u006e\u0073\u0066\u006f\u0072m"];if _ggefc {_cgcdf :=_bd .Fields (_bggff );for _ ,_fgdbf :=range _cgcdf {_dgggb :=_bd .FieldsFunc (_fgdbf ,_dacbe );
if len (_dgggb )< 3{_gg .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_bggff );return ;};_abfad ,_fdcad :=_cdadb (_dgggb [1],64);
if _fdcad !=nil {_gg .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_bggff );return ;};_cgefe ,_fdcad :=_cdadb (_dgggb [2],64);
if _fdcad !=nil {_gg .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_bggff );return ;};if _dgggb [0]=="\u0074r\u0061\u006e\u0073\u006c\u0061\u0074e"{_caccg .Translate (_abfad ,_cgefe );
}else if _dgggb [0]=="\u0073\u0063\u0061l\u0065"{_caccg .Scale (_abfad ,_cgefe );}else {_gg .Log .Debug ("\u0063\u0061\u006e't\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0074\u0072a\u006es\u0066o\u0072m\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0025\u0076",_bggff );
return ;};};};};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_egdb *Creator )NewTextStyle ()TextStyle {return _acbbf (_egdb ._ebd )};func (_eaeb *templateProcessor )parseTableCell (_ccbbd *templateNode )(interface{},error ){if _ccbbd ._bedad ==nil {_eaeb .nodeLogError (_ccbbd ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_fbcba ;};_bfdee ,_fagdc :=_ccbbd ._bedad ._dadec .(*Table );if !_fagdc {_eaeb .nodeLogError (_ccbbd ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_ccbbd ._bedad ._dadec );
return nil ,_fbcba ;};var _dbbfd ,_caegd int64 ;for _ ,_dgdff :=range _ccbbd ._bcdgfa .Attr {_fadb :=_dgdff .Value ;switch _eagdd :=_dgdff .Name .Local ;_eagdd {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_dbbfd =_eaeb .parseInt64Attr (_eagdd ,_fadb );
case "\u0072o\u0077\u0073\u0070\u0061\u006e":_caegd =_eaeb .parseInt64Attr (_eagdd ,_fadb );};};if _dbbfd <=0{_dbbfd =1;};if _caegd <=0{_caegd =1;};_gaggg :=_bfdee .MultiCell (int (_caegd ),int (_dbbfd ));for _ ,_adbd :=range _ccbbd ._bcdgfa .Attr {_bcdde :=_adbd .Value ;
switch _agbda :=_adbd .Name .Local ;_agbda {case "\u0069\u006e\u0064\u0065\u006e\u0074":_gaggg .SetIndent (_eaeb .parseFloatAttr (_agbda ,_bcdde ));case "\u0061\u006c\u0069g\u006e":_gaggg .SetHorizontalAlignment (_eaeb .parseCellAlignmentAttr (_agbda ,_bcdde ));
case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_gaggg .SetVerticalAlignment (_eaeb .parseCellVerticalAlignmentAttr (_agbda ,_bcdde ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_gaggg .SetSideBorderStyle (CellBorderSideAll ,_eaeb .parseCellBorderStyleAttr (_agbda ,_bcdde ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_gaggg .SetSideBorderStyle (CellBorderSideTop ,_eaeb .parseCellBorderStyleAttr (_agbda ,_bcdde ));case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_gaggg .SetSideBorderStyle (CellBorderSideBottom ,_eaeb .parseCellBorderStyleAttr (_agbda ,_bcdde ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_gaggg .SetSideBorderStyle (CellBorderSideLeft ,_eaeb .parseCellBorderStyleAttr (_agbda ,_bcdde ));case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_gaggg .SetSideBorderStyle (CellBorderSideRight ,_eaeb .parseCellBorderStyleAttr (_agbda ,_bcdde ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_gaggg .SetSideBorderWidth (CellBorderSideAll ,_eaeb .parseFloatAttr (_agbda ,_bcdde ));case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_gaggg .SetSideBorderWidth (CellBorderSideTop ,_eaeb .parseFloatAttr (_agbda ,_bcdde ));
case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_gaggg .SetSideBorderWidth (CellBorderSideBottom ,_eaeb .parseFloatAttr (_agbda ,_bcdde ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_gaggg .SetSideBorderWidth (CellBorderSideLeft ,_eaeb .parseFloatAttr (_agbda ,_bcdde ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_gaggg .SetSideBorderWidth (CellBorderSideRight ,_eaeb .parseFloatAttr (_agbda ,_bcdde ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_gaggg .SetSideBorderColor (CellBorderSideAll ,_eaeb .parseColorAttr (_agbda ,_bcdde ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_gaggg .SetSideBorderColor (CellBorderSideTop ,_eaeb .parseColorAttr (_agbda ,_bcdde ));case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_gaggg .SetSideBorderColor (CellBorderSideBottom ,_eaeb .parseColorAttr (_agbda ,_bcdde ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_gaggg .SetSideBorderColor (CellBorderSideLeft ,_eaeb .parseColorAttr (_agbda ,_bcdde ));case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_gaggg .SetSideBorderColor (CellBorderSideRight ,_eaeb .parseColorAttr (_agbda ,_bcdde ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_gaggg .SetBorderLineStyle (_eaeb .parseLineStyleAttr (_agbda ,_bcdde ));case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_gaggg .SetBackgroundColor (_eaeb .parseColorAttr (_agbda ,_bcdde ));
case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;default:_eaeb .nodeLogDebug (_ccbbd ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_agbda );
};};return _gaggg ,nil ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_acggb *RadialShading )SetExtends (start bool ,end bool ){_acggb ._bbfaa .SetExtends (start ,end )};

// NewTOCLine creates a new table of contents line with the default style.
func (_gada *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _cfacb (number ,title ,page ,level ,_gada .NewTextStyle ());};

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_bcdcg *Ellipse )ScaleToWidth (w float64 ){_ggaa :=_bcdcg ._addb /_bcdcg ._gdfc ;_bcdcg ._gdfc =w ;_bcdcg ._addb =w *_ggaa ;};func _cgabd (_caegg *templateProcessor ,_beded *templateNode )(interface{},error ){return _caegg .parsePageBreak (_beded );
};func _dedb (_dbfb ,_egdc ,_daff ,_agdb float64 )*Ellipse {return &Ellipse {_dada :_dbfb ,_dfdg :_egdc ,_gdfc :_daff ,_addb :_agdb ,_gcfb :PositionAbsolute ,_abdd :1.0,_eagg :ColorBlack ,_gdad :1.0,_fggg :1.0};};func (_cdcc *GraphicSVGElement )processDefs (){_cdcc ._decf =make (map[string ]*LinearShading );
for _ ,_ddab :=range _cdcc .Children {if _ddab .Name =="\u0064\u0065\u0066\u0073"{for _ ,_baef :=range _ddab .Children {if _baef .Name =="\u006c\u0069\u006e\u0065\u0061\u0072\u0047\u0072\u0061d\u0069\u0065\u006e\u0074"{_deab :=_baef .Attributes ["\u0069\u0064"];
_afdgf :=_baef .parseColorPoints ();_fbca :=_eeacf (_afdgf );_edd :=_baef .getGradientAngle ();_fbca .SetAngle (-_edd );_fbca .SetExtends (true ,true );_fbca .SetBoundingBox (0,0,_cdcc .Width ,_cdcc .Height );_cdcc ._decf [_deab ]=_fbca ;};};};};};

// SetAnnotation sets an annotation on a TextChunk,
// this will replace any existing annotation that has been set.
// Supplying a nil value as parameter would clear all the annotations.
func (_ggec *TextChunk )SetAnnotation (annotation *_cb .PdfAnnotation ){if annotation ==nil {_ggec .ClearAnnotations ();}else {_ggec ._fegffe =[]*_cb .PdfAnnotation {annotation };};};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_eab *Block )SetMargins (left ,right ,top ,bottom float64 ){_eab ._afg .Left =left ;_eab ._afg .Right =right ;_eab ._afg .Top =top ;_eab ._afg .Bottom =bottom ;};

// Width returns the Block's width.
func (_ag *Block )Width ()float64 {return _ag ._db };

// SetDueDate sets the due date of the invoice.
func (_bcfd *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_bcfd ._gcgd [1].Value =dueDate ;return _bcfd ._gcgd [0],_bcfd ._gcgd [1];};

// SetColPosition sets cell column position.
func (_ecbe *TableCell )SetColPosition (col int ){_ecbe ._bgage =col };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_eada *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcbfd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_geeeg ,_ddbb :=_dcbfd .setOpacity (_eada ._bddc ,_eada ._fcccc );if _ddbb !=nil {return nil ,ctx ,_ddbb ;};
_eeabf :=_eada ._bbbb ;_eeabf .FillEnabled =_eeabf .FillColor !=nil ;_eeabf .BorderEnabled =_eeabf .BorderColor !=nil &&_eeabf .BorderWidth > 0;_fegffa :=_eeabf .Points ;_afgg :=_cb .PdfRectangle {};_dgec :=false ;for _fbbcf :=range _fegffa {for _fcfac :=range _fegffa [_fbbcf ]{_cdddg :=&_fegffa [_fbbcf ][_fcfac ];
_cdddg .Y =ctx .PageHeight -_cdddg .Y ;if !_dgec {_afgg .Llx =_cdddg .X ;_afgg .Lly =_cdddg .Y ;_afgg .Urx =_cdddg .X ;_afgg .Ury =_cdddg .Y ;_dgec =true ;}else {_afgg .Llx =_a .Min (_afgg .Llx ,_cdddg .X );_afgg .Lly =_a .Min (_afgg .Lly ,_cdddg .Y );
_afgg .Urx =_a .Max (_afgg .Urx ,_cdddg .X );_afgg .Ury =_a .Max (_afgg .Ury ,_cdddg .Y );};};};if _eeabf .FillEnabled {_cdffe :=_bddf (_dcbfd ,_eada ._bbbb .FillColor ,_eada ._fegd ,func ()Rectangle {return Rectangle {_gbaf :_afgg .Llx ,_gcfge :_afgg .Lly ,_ggcb :_afgg .Width (),_baadd :_afgg .Height ()};
});if _cdffe !=nil {return nil ,ctx ,_cdffe ;};};_aaga ,_ ,_ddbb :=_eeabf .MarkedDraw (_geeeg ,_eada ._agdcd );if _ddbb !=nil {return nil ,ctx ,_ddbb ;};if _ddbb =_dcbfd .addContentsByString (string (_aaga ));_ddbb !=nil {return nil ,ctx ,_ddbb ;};return []*Block {_dcbfd },ctx ,nil ;
};func (_fgaaa *GraphicSVGElement )drawPolygon (_dbad *_ae .ContentCreator ,_daeeg *_cb .PdfPageResources ){_dbad .Add_q ();_fgaaa .Style .toContentStream (_dbad ,_daeeg ,_fgaaa );_cdaac ,_aedfb :=_agbb (_fgaaa .Attributes ["\u0070\u006f\u0069\u006e\u0074\u0073"]);
if _aedfb !=nil {_gg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0025\u0076",_aedfb );
return ;};if len (_cdaac )%2> 0{_gg .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0069n\u0076\u0061l\u0069\u0064\u0020\u0070\u006f\u0069\u006e\u0074s\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006ce\u006e\u0067\u0074\u0068");return ;
};for _bcdgg :=0;_bcdgg < len (_cdaac );{if _bcdgg ==0{_dbad .Add_m (_cdaac [_bcdgg ]*_fgaaa ._dfgb ,_cdaac [_bcdgg +1]*_fgaaa ._dfgb );}else {_dbad .Add_l (_cdaac [_bcdgg ]*_fgaaa ._dfgb ,_cdaac [_bcdgg +1]*_fgaaa ._dfgb );};_bcdgg +=2;};_dbad .Add_l (_cdaac [0]*_fgaaa ._dfgb ,_cdaac [1]*_fgaaa ._dfgb );
_fgaaa .Style .fillStroke (_dbad );_dbad .Add_h ();_dbad .Add_Q ();};func (_cf *Block )translate (_aaeb ,_eee float64 ){_ebg :=_ae .NewContentCreator ().Translate (_aaeb ,-_eee ).Operations ();*_cf ._fd =append (*_ebg ,*_cf ._fd ...);_cf ._fd .WrapIfNeeded ();
};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// Columns returns all the columns in the invoice line items table.
func (_dbdb *Invoice )Columns ()[]*InvoiceCell {return _dbdb ._cefb };

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_dggcg *Ellipse )ScaleToHeight (h float64 ){_cfefa :=_dggcg ._gdfc /_dggcg ._addb ;_dggcg ._addb =h ;_dggcg ._gdfc =h *_cfefa ;};func (_cgb *Block )SetMarkedContentID (id int64 )*_cb .KDict {return nil };

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_cagcb *TOC )SetLineLevelOffset (levelOffset float64 ){_cagcb ._fadf =levelOffset };func _bbdfa (_cacda string )(*_cb .PdfFont ,error ){_ecec ,_eeffd :=map[string ]_cb .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_cb .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_cb .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_cb .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_cb .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_cb .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_cb .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_cb .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_cb .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_cb .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_cb .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_cb .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_cb .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_cb .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_cb .TimesBoldItalicName }[_cacda ];
if !_eeffd {return nil ,_d .Errorf ("\u0066\u006f\u006e\u0074\u002df\u0061\u006d\u0069\u006c\u0079\u0020\u0025\u0073\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0020\u0066\u006f\u006e\u0074\u0073\u0020\u006c\u0069\u0073t",_cacda );
};_ebdga ,_cbabc :=_cb .NewStandard14Font (_ecec );if _cbabc !=nil {return nil ,_cbabc ;};return _ebdga ,nil ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_gagba int ;_cfgeg int ;_ffec int ;_bcbd []float64 ;_begfg []float64 ;_dgcc float64 ;_gcbaa []*TableCell ;_bgddf []int ;_gccec Positioning ;_cffd ,_ddagg float64 ;_gdfeg Margins ;_gdeb bool ;_dded int ;_ageggd int ;_cacgg bool ;_adfab bool ;
_aaca bool ;};

// SetLineWidth sets the line width.
func (_acge *Line )SetLineWidth (width float64 ){_acge ._fcfg =width };

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_dedd *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_fafdg []*Block ;_dccbag =NewBlock (ctx .PageWidth ,ctx .PageHeight );_bebf =ctx ;_cdcea ,_cdae =_dedd ._cdbgd ,ctx .PageHeight -_dedd ._bggef ;_aadf ,_aecg =_dedd ._abdb ,ctx .PageHeight -_dedd ._ecff ;
);_dbefc :=_dedd ._fcfa .IsRelative ();if _dbefc {ctx .X +=_dedd ._bfgab .Left ;ctx .Y +=_dedd ._bfgab .Top ;ctx .Width -=_dedd ._bfgab .Left +_dedd ._bfgab .Right ;ctx .Height -=_dedd ._bfgab .Top +_dedd ._bfgab .Bottom ;_cdcea ,_cdae ,_aadf ,_aecg =_dedd .computeCoords (ctx );
if _dedd .Height ()> ctx .Height {_fafdg =append (_fafdg ,_dccbag );_dccbag =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_faee :=ctx ;_faee .Y =ctx .Margins .Top +_dedd ._bfgab .Top ;_faee .X =ctx .Margins .Left +_dedd ._bfgab .Left ;_faee .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_dedd ._bfgab .Top -_dedd ._bfgab .Bottom ;
_faee .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dedd ._bfgab .Left -_dedd ._bfgab .Right ;ctx =_faee ;_cdcea ,_cdae ,_aadf ,_aecg =_dedd .computeCoords (ctx );};};_cgbe :=_gga .BasicLine {X1 :_cdcea ,Y1 :_cdae ,X2 :_aadf ,Y2 :_aecg ,LineColor :_cdfd (_dedd ._ccfeb ),Opacity :_dedd ._gddge ,LineWidth :_dedd ._fcfg ,LineStyle :_dedd ._gcege ,DashArray :_dedd ._cfcb ,DashPhase :_dedd ._affb };
_dbefd ,_gaecc :=_dccbag .setOpacity (1.0,_dedd ._gddge );if _gaecc !=nil {return nil ,ctx ,_gaecc ;};_ebad ,_ ,_gaecc :=_cgbe .MarkedDraw (_dbefd ,_dedd ._gcfg );if _gaecc !=nil {return nil ,ctx ,_gaecc ;};if _gaecc =_dccbag .addContentsByString (string (_ebad ));
_gaecc !=nil {return nil ,ctx ,_gaecc ;};if _dbefc {ctx .X =_bebf .X ;ctx .Width =_bebf .Width ;_bbea :=_dedd .Height ();ctx .Y +=_bbea +_dedd ._bfgab .Bottom ;ctx .Height -=_bbea ;}else {ctx =_bebf ;};_fafdg =append (_fafdg ,_dccbag );return _fafdg ,ctx ,nil ;
};func (_bcfff *Table )updateRowHeights (_cgbb float64 ){for _ ,_afeae :=range _bcfff ._gcbaa {_cbed :=_afeae .width (_bcfff ._bcbd ,_cgbb );_fcca :=_afeae .height (_cbed );_gdeeb :=_bcfff ._begfg [_afeae ._gbbed +_afeae ._dfgcc -2];if _afeae ._dfgcc > 1{_cfga :=0.0;
_dcgbc :=_bcfff ._begfg [_afeae ._gbbed -1:(_afeae ._gbbed +_afeae ._dfgcc -1)];for _ ,_gddfg :=range _dcgbc {_cfga +=_gddfg ;};if _fcca <=_cfga {continue ;};};if _fcca > _gdeeb {_fgbdb :=_fcca /float64 (_afeae ._dfgcc );if _fgbdb > _gdeeb {for _abgfg :=1;
_abgfg <=_afeae ._dfgcc ;_abgfg ++{if _fgbdb > _bcfff ._begfg [_afeae ._gbbed +_abgfg -2]{_bcfff ._begfg [_afeae ._gbbed +_abgfg -2]=_fgbdb ;};};};};};};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_bac *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_bac ._afcg .Left =left ;_bac ._afcg .Right =right ;_bac ._afcg .Top =top ;_bac ._afcg .Bottom =bottom ;};func (_fddfe *templateProcessor )parseInt64Attr (_ggfad ,_gfeag string )int64 {_gg .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_ggfad ,_gfeag );
_bcad ,_ :=_fa .ParseInt (_gfeag ,10,64);return _bcad ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_ceaa *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_bcabb []*Block ;_eedbef =NewBlock (ctx .PageWidth ,ctx .PageHeight );_defac =ctx ;_beda =_ceaa ._afefe /2;);_afdfe :=_ceaa ._fdfc .IsRelative ();if _afdfe {_ceaa .applyFitMode (ctx .Width );
ctx .X +=_ceaa ._gdea .Left +_beda ;ctx .Y +=_ceaa ._gdea .Top +_beda ;ctx .Width -=_ceaa ._gdea .Left +_ceaa ._gdea .Right ;ctx .Height -=_ceaa ._gdea .Top +_ceaa ._gdea .Bottom ;if _ceaa ._baadd > ctx .Height {_bcabb =append (_bcabb ,_eedbef );_eedbef =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_ddafc :=ctx ;_ddafc .Y =ctx .Margins .Top +_ceaa ._gdea .Top +_beda ;_ddafc .X =ctx .Margins .Left +_ceaa ._gdea .Left +_beda ;_ddafc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_ceaa ._gdea .Top -_ceaa ._gdea .Bottom ;
_ddafc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ceaa ._gdea .Left -_ceaa ._gdea .Right ;ctx =_ddafc ;};}else {ctx .X =_ceaa ._gbaf ;ctx .Y =_ceaa ._gcfge ;};_decba :=_gga .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_ceaa ._baadd ,Width :_ceaa ._ggcb ,Height :_ceaa ._baadd ,BorderRadiusTopLeft :_ceaa ._ddce ,BorderRadiusTopRight :_ceaa ._fbbee ,BorderRadiusBottomLeft :_ceaa ._cffgb ,BorderRadiusBottomRight :_ceaa ._ggfa ,Opacity :1.0};
if _ceaa ._ecbc !=nil {_decba .FillEnabled =true ;_gagg :=_cdfd (_ceaa ._ecbc );_dcbg :=_bddf (_eedbef ,_gagg ,_ceaa ._ecbc ,func ()Rectangle {return Rectangle {_gbaf :_decba .X ,_gcfge :_decba .Y ,_ggcb :_decba .Width ,_baadd :_decba .Height };});if _dcbg !=nil {return nil ,ctx ,_dcbg ;
};_decba .FillColor =_gagg ;};if _ceaa ._edcc !=nil &&_ceaa ._afefe > 0{_decba .BorderEnabled =true ;_decba .BorderColor =_cdfd (_ceaa ._edcc );_decba .BorderWidth =_ceaa ._afefe ;};_fbee ,_bbgcc :=_eedbef .setOpacity (_ceaa ._abeed ,_ceaa ._fbfee );if _bbgcc !=nil {return nil ,ctx ,_bbgcc ;
};_bgdb ,_ ,_bbgcc :=_decba .MarkedDraw (_fbee ,_ceaa ._gfeca );if _bbgcc !=nil {return nil ,ctx ,_bbgcc ;};if _bbgcc =_eedbef .addContentsByString (string (_bgdb ));_bbgcc !=nil {return nil ,ctx ,_bbgcc ;};if _afdfe {ctx .X =_defac .X ;ctx .Width =_defac .Width ;
_bgaa :=_ceaa ._baadd +_beda ;ctx .Y +=_bgaa +_ceaa ._gdea .Bottom ;ctx .Height -=_bgaa ;}else {ctx =_defac ;};_bcabb =append (_bcabb ,_eedbef );return _bcabb ,ctx ,nil ;};

// SetSideBorderStyle sets the cell's side border style.
func (_ceaag *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_ceaag ._edcda =style ;_ceaag ._dgfe =style ;_ceaag ._ccecb =style ;_ceaag ._bbgad =style ;case CellBorderSideTop :_ceaag ._edcda =style ;
case CellBorderSideBottom :_ceaag ._dgfe =style ;case CellBorderSideLeft :_ceaag ._ccecb =style ;case CellBorderSideRight :_ceaag ._bbgad =style ;};};

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_ggdb *Ellipse )GetCoords ()(float64 ,float64 ){return _ggdb ._dada ,_ggdb ._dfdg };var (_eadb =_gd .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");_cffc =_ff .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");
_fbcba =_ff .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");_beedb =_ff .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");
_efgag =_ff .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e"););func _da (_ade *_ae .ContentStreamOperations ,_gbcf *_cb .PdfPageResources ,_agg *_ae .ContentStreamOperations ,_gcg *_cb .PdfPageResources )error {_fcd :=map[_fac .PdfObjectName ]_fac .PdfObjectName {};
_ecb :=map[_fac .PdfObjectName ]_fac .PdfObjectName {};_fad :=map[_fac .PdfObjectName ]_fac .PdfObjectName {};_bfd :=map[_fac .PdfObjectName ]_fac .PdfObjectName {};_aef :=map[_fac .PdfObjectName ]_fac .PdfObjectName {};_efb :=map[_fac .PdfObjectName ]_fac .PdfObjectName {};
for _ ,_bbf :=range *_agg {switch _bbf .Operand {case "\u0044\u006f":if len (_bbf .Params )==1{if _ggb ,_dcd :=_bbf .Params [0].(*_fac .PdfObjectName );_dcd {if _ ,_aga :=_fcd [*_ggb ];!_aga {var _afa _fac .PdfObjectName ;_cage ,_ :=_gcg .GetXObjectByName (*_ggb );
if _cage !=nil {_afa =*_ggb ;for {_dgg ,_ :=_gbcf .GetXObjectByName (_afa );if _dgg ==nil ||_dgg ==_cage {break ;};_afa =*_fac .MakeName (_dfc (_afa .String ()));};};_gbcf .SetXObjectByName (_afa ,_cage );_fcd [*_ggb ]=_afa ;};_efg :=_fcd [*_ggb ];_bbf .Params [0]=&_efg ;
};};case "\u0054\u0066":if len (_bbf .Params )==2{if _aea ,_daf :=_bbf .Params [0].(*_fac .PdfObjectName );_daf {if _ ,_gcgb :=_ecb [*_aea ];!_gcgb {_ebc ,_gcc :=_gcg .GetFontByName (*_aea );_agc :=*_aea ;if _gcc &&_ebc !=nil {_agc =_dbe (_aea .String (),_ebc ,_gbcf );
};_gbcf .SetFontByName (_agc ,_ebc );_ecb [*_aea ]=_agc ;};_beg :=_ecb [*_aea ];_bbf .Params [0]=&_beg ;};};case "\u0043\u0053","\u0063\u0073":if len (_bbf .Params )==1{if _cba ,_gdc :=_bbf .Params [0].(*_fac .PdfObjectName );_gdc {if _ ,_bba :=_fad [*_cba ];
!_bba {var _bbgg _fac .PdfObjectName ;_fgc ,_dae :=_gcg .GetColorspaceByName (*_cba );if _dae {_bbgg =*_cba ;for {_fdc ,_fec :=_gbcf .GetColorspaceByName (_bbgg );if !_fec ||_fgc ==_fdc {break ;};_bbgg =*_fac .MakeName (_dfc (_bbgg .String ()));};_gbcf .SetColorspaceByName (_bbgg ,_fgc );
_fad [*_cba ]=_bbgg ;}else {_gg .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _bbgd ,_dfd :=_fad [*_cba ];_dfd {_bbf .Params [0]=&_bbgd ;}else {_gg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_cba );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_bbf .Params )==1{if _dac ,_cee :=_bbf .Params [0].(*_fac .PdfObjectName );_cee {if _ ,_fgac :=_bfd [*_dac ];!_fgac {var _ebf _fac .PdfObjectName ;_bcc ,_adg :=_gcg .GetPatternByName (*_dac );
if _adg {_ebf =*_dac ;for {_fcc ,_cccf :=_gbcf .GetPatternByName (_ebf );if !_cccf ||_fcc ==_bcc {break ;};_ebf =*_fac .MakeName (_dfc (_ebf .String ()));};_ggg :=_gbcf .SetPatternByName (_ebf ,_bcc .ToPdfObject ());if _ggg !=nil {return _ggg ;};_bfd [*_dac ]=_ebf ;
};};if _adc ,_bcg :=_bfd [*_dac ];_bcg {_bbf .Params [0]=&_adc ;};};};case "\u0073\u0068":if len (_bbf .Params )==1{if _fde ,_cbfb :=_bbf .Params [0].(*_fac .PdfObjectName );_cbfb {if _ ,_dcdb :=_aef [*_fde ];!_dcdb {var _eagf _fac .PdfObjectName ;_eagd ,_fedb :=_gcg .GetShadingByName (*_fde );
if _fedb {_eagf =*_fde ;for {_cdf ,_ebfb :=_gbcf .GetShadingByName (_eagf );if !_ebfb ||_eagd ==_cdf {break ;};_eagf =*_fac .MakeName (_dfc (_eagf .String ()));};_abd :=_gbcf .SetShadingByName (_eagf ,_eagd .ToPdfObject ());if _abd !=nil {_gg .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_abd );
return _abd ;};_aef [*_fde ]=_eagf ;}else {_gg .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _cgg ,_dcb :=_aef [*_fde ];_dcb {_bbf .Params [0]=&_cgg ;}else {_gg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_fde );
};};};case "\u0067\u0073":if len (_bbf .Params )==1{if _dec ,_cgf :=_bbf .Params [0].(*_fac .PdfObjectName );_cgf {if _ ,_gbgc :=_efb [*_dec ];!_gbgc {var _dce _fac .PdfObjectName ;_ecad ,_gae :=_gcg .GetExtGState (*_dec );if _gae {_dce =*_dec ;for {_agcb ,_gcef :=_gbcf .GetExtGState (_dce );
if !_gcef ||_ecad ==_agcb {break ;};_dce =*_fac .MakeName (_dfc (_dce .String ()));};};_gbcf .AddExtGState (_dce ,_ecad );_efb [*_dec ]=_dce ;};_bef :=_efb [*_dec ];_bbf .Params [0]=&_bef ;};};};*_ade =append (*_ade ,_bbf );};return nil ;};func _cdfd (_bdad Color )_cb .PdfColor {if _bdad ==nil {_bdad =ColorBlack ;
};switch _eaff :=_bdad .(type ){case grayColor :return _cb .NewPdfColorDeviceGray (_eaff ._gadc );case cmykColor :return _cb .NewPdfColorDeviceCMYK (_eaff ._gaec ,_eaff ._ceeb ,_eaff ._adfa ,_eaff ._deae );case *LinearShading :return _cb .NewPdfColorPatternType2 ();
case *RadialShading :return _cb .NewPdfColorPatternType3 ();};return _cb .NewPdfColorDeviceRGB (_bdad .ToRGB ());};func (_ddfd *templateProcessor )parseLine (_ffeg *templateNode )(interface{},error ){_dacee :=_ddfd .creator .NewLine (0,0,0,0);for _ ,_caade :=range _ffeg ._bcdgfa .Attr {_geff :=_caade .Value ;
switch _bfgabd :=_caade .Name .Local ;_bfgabd {case "\u0078\u0031":_dacee ._cdbgd =_ddfd .parseFloatAttr (_bfgabd ,_geff );case "\u0079\u0031":_dacee ._bggef =_ddfd .parseFloatAttr (_bfgabd ,_geff );case "\u0078\u0032":_dacee ._abdb =_ddfd .parseFloatAttr (_bfgabd ,_geff );
case "\u0079\u0032":_dacee ._ecff =_ddfd .parseFloatAttr (_bfgabd ,_geff );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_dacee .SetLineWidth (_ddfd .parseFloatAttr (_bfgabd ,_geff ));case "\u0063\u006f\u006co\u0072":_dacee .SetColor (_ddfd .parseColorAttr (_bfgabd ,_geff ));
case "\u0073\u0074\u0079l\u0065":_dacee .SetStyle (_ddfd .parseLineStyleAttr (_bfgabd ,_geff ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_dacee .SetDashPattern (_ddfd .parseInt64Array (_bfgabd ,_geff ),_dacee ._affb );case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_dacee .SetDashPattern (_dacee ._cfcb ,_ddfd .parseInt64Attr (_bfgabd ,_geff ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_dacee .SetOpacity (_ddfd .parseFloatAttr (_bfgabd ,_geff ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_dacee .SetPositioning (_ddfd .parsePositioningAttr (_bfgabd ,_geff ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_dacee .SetFitMode (_ddfd .parseFitModeAttr (_bfgabd ,_geff ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_edgg :=_ddfd .parseMarginAttr (_bfgabd ,_geff );_dacee .SetMargins (_edgg .Left ,_edgg .Right ,_edgg .Top ,_edgg .Bottom );default:_ddfd .nodeLogDebug (_ffeg ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_bfgabd );
};};return _dacee ,nil ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_aabcf *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aabcf ._bcgd .Left ,_aabcf ._bcgd .Right ,_aabcf ._bcgd .Top ,_aabcf ._bcgd .Bottom ;};func _gagfg (_afcge *_cb .PdfFont ,_dcbff float64 )*fontMetrics {_geabb :=&fontMetrics {};
if _afcge ==nil {_gg .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");return _geabb ;};_ceegb ,_cbeea :=_afcge .GetFontDescriptor ();if _cbeea !=nil {_gg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_cbeea );
return _geabb ;};if _geabb ._cabc ,_cbeea =_ceegb .GetCapHeight ();_cbeea !=nil {_gg .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_cbeea );
};if int (_geabb ._cabc )<=0{_gg .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_geabb ._cabc =1000;};_geabb ._cabc *=_dcbff /1000.0;if _geabb ._bccfea ,_cbeea =_ceegb .GetXHeight ();_cbeea !=nil {_gg .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_cbeea );
};_geabb ._bccfea *=_dcbff /1000.0;if _geabb ._eeagg ,_cbeea =_ceegb .GetAscent ();_cbeea !=nil {_gg .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_cbeea );
};_geabb ._eeagg *=_dcbff /1000.0;if _geabb ._bcbe ,_cbeea =_ceegb .GetDescent ();_cbeea !=nil {_gg .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_cbeea );
};_geabb ._bcbe *=_dcbff /1000.0;return _geabb ;};

// SetHeight sets the Image's document height to specified h.
func (_fbcd *Image )SetHeight (h float64 ){_fbcd ._efag =h };func (_bacf *Image )applyFitMode (_cddd float64 ){_cddd -=_bacf ._bcgd .Left +_bacf ._bcgd .Right ;switch _bacf ._fbbd {case FitModeFillWidth :_bacf .ScaleToWidth (_cddd );};};func (_dcgcb *templateProcessor )addNodeText (_fbbff *templateNode ,_gbfbf string )error {_gbfbg :=_fbbff ._dadec ;
if _gbfbg ==nil {return nil ;};switch _cgce :=_gbfbg .(type ){case *TextChunk :_cgce .Text =_gbfbf ;case *StyledParagraph :switch _fbbff ._bcdgfa .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _fbbff ._bedad !=nil {if _ddfg ,_ceee :=_fbbff ._bedad ._dadec .(*Chapter );
_ceee {_ddfg ._cgbg =_gbfbf ;_cgce .SetText (_ddfg .headingText ());};};};};return nil ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_cdfgdb *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cdfgdb ._gdfeg .Left ,_cdfgdb ._gdfeg .Right ,_cdfgdb ._gdfeg .Top ,_cdfgdb ._gdfeg .Bottom ;};

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _egba (color ,point )};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_faecg *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_beed :=ctx ;var _cgfbf []*Block ;_addeb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _faecg ._fefd .IsRelative (){ctx .X +=_aa .RoundDefault (_faecg ._gebd .Left );
ctx .Y +=_aa .RoundDefault (_faecg ._gebd .Top );ctx .Width -=_aa .RoundDefault (_faecg ._gebd .Left +_faecg ._gebd .Right );ctx .Height -=_aa .RoundDefault (_faecg ._gebd .Top );_faecg .SetWidth (ctx .Width );if _faecg .Height ()> ctx .Height {_cgfbf =append (_cgfbf ,_addeb );
_addeb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cgfad :=ctx ;_cgfad .Y =_aa .RoundDefault (ctx .Margins .Top );_cgfad .X =_aa .RoundDefault (ctx .Margins .Left +_faecg ._gebd .Left );_cgfad .Height =_aa .RoundDefault (ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom );
_cgfad .Width =_aa .RoundDefault (ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_faecg ._gebd .Left -_faecg ._gebd .Right );ctx =_cgfad ;};}else {if int (_faecg ._egeg )<=0{_faecg .SetWidth (_faecg .getTextWidth ());};ctx .X =_faecg ._dbcg ;
ctx .Y =_faecg ._dgfba ;};ctx ,_cddbg :=_faggc (_addeb ,_faecg ,ctx );if _cddbg !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cddbg );return nil ,ctx ,_cddbg ;};_cgfbf =append (_cgfbf ,_addeb );if _faecg ._fefd .IsRelative (){ctx .Y +=_aa .RoundDefault (_faecg ._gebd .Bottom );
ctx .Height -=_aa .RoundDefault (_faecg ._gebd .Bottom );if !ctx .Inline {ctx .X =_beed .X ;ctx .Width =_beed .Width ;};return _cgfbf ,ctx ,nil ;};return _cgfbf ,_beed ,nil ;};func _ffcbd (_gaeea string )(_bddd ,_eaag string ){if _gaeea ==""||(_gaeea [len (_gaeea )-1]>='0'&&_gaeea [len (_gaeea )-1]<='9'){return _gaeea ,"";
};_bddd =_gaeea ;for _ ,_dfdcg :=range _ecadc {if _bd .Contains (_bddd ,_dfdcg ){_eaag =_dfdcg ;};_bddd =_bd .TrimSuffix (_bddd ,_dfdcg );};return ;};func (_baac *StyledParagraph )addLine (_fcbb []*TextChunk )bool {if _baac ._ffef > 0&&len (_baac ._ebbfe )+1>=_baac ._ffef {if len (_fcbb )> 0{_baac ._ebbfe =append (_baac ._ebbfe ,_fcbb );
};return false ;};_baac ._ebbfe =append (_baac ._ebbfe ,_fcbb );return true ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_cdceb *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cdceb ._gebd .Left ,_cdceb ._gebd .Right ,_cdceb ._gebd .Top ,_cdceb ._gebd .Bottom ;};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// MultiFont represents an encoder that accepts multiple fonts and selects the correct font for encoding.
MultiFont *_cb .MultipleFontEncoder ;

// Font represents the font the text will use.
Font *_cb .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_gac *Chart )Width ()float64 {return float64 (_gac ._degg .Width ())};func _gfec (_bfac VectorDrawable ,_bdgf float64 )float64 {switch _ddf :=_bfac .(type ){case *Paragraph :if _ddf ._cbca {_ddf .SetWidth (_bdgf -_ddf ._gebd .Left -_ddf ._gebd .Right );
};return _ddf .Height ()+_ddf ._gebd .Top +_ddf ._gebd .Bottom +(0.5*_ddf ._dbcd *_ddf ._ccfga );case *StyledParagraph :if _ddf ._cbcg {_ddf .SetWidth (_bdgf -_ddf ._dcbc .Left -_ddf ._dcbc .Right );};return _ddf .Height ()+_ddf ._dcbc .Top +_ddf ._dcbc .Bottom +(0.5*_ddf .getTextHeight ());
case *Image :_ddf .applyFitMode (_bdgf );return _ddf .Height ()+_ddf ._bcgd .Top +_ddf ._bcgd .Bottom ;case *Rectangle :_ddf .applyFitMode (_bdgf );return _ddf .Height ()+_ddf ._gdea .Top +_ddf ._gdea .Bottom +_ddf ._afefe ;case *Ellipse :_ddf .applyFitMode (_bdgf );
return _ddf .Height ()+_ddf ._dede .Top +_ddf ._dede .Bottom ;case *Division :return _ddf .ctxHeight (_bdgf )+_ddf ._ccega .Top +_ddf ._ccega .Bottom +_ddf ._cacg .Top +_ddf ._cacg .Bottom ;case *Table :_ddf .updateRowHeights (_bdgf -_ddf ._gdfeg .Left -_ddf ._gdfeg .Right );
return _ddf .Height ()+_ddf ._gdfeg .Top +_ddf ._gdfeg .Bottom ;case *List :return _ddf .ctxHeight (_bdgf )+_ddf ._feba .Top +_ddf ._feba .Bottom ;case marginDrawable :_ ,_ ,_cbee ,_gaga :=_ddf .GetMargins ();return _ddf .Height ()+_cbee +_gaga ;default:return _ddf .Height ();
};};

// Scale block by specified factors in the x and y directions.
func (_ceb *Block )Scale (sx ,sy float64 ){_ggd :=_ae .NewContentCreator ().Scale (sx ,sy ).Operations ();*_ceb ._fd =append (*_ggd ,*_ceb ._fd ...);_ceb ._fd .WrapIfNeeded ();_ceb ._db *=sx ;_ceb ._ecf *=sy ;};

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_fcfab *Paragraph )SetColor (col Color ){_fcfab ._dcfc =col };func (_dageb *Division )ctxHeight (_acgab float64 )float64 {_acgab -=_dageb ._ccega .Left +_dageb ._ccega .Right +_dageb ._cacg .Left +_dageb ._cacg .Right ;var _cacd float64 ;for _ ,_gfef :=range _dageb ._dbfd {_cacd +=_gfec (_gfef ,_acgab );
};return _cacd ;};

// SetLineHeight sets the line height (1.0 default).
func (_gegaae *StyledParagraph )SetLineHeight (lineheight float64 ){_gegaae ._dcag =lineheight };

// Scale scales Image by a constant factor, both width and height.
func (_ebgcd *Image )Scale (xFactor ,yFactor float64 ){_ebgcd ._efca =xFactor *_ebgcd ._efca ;_ebgcd ._efag =yFactor *_ebgcd ._efag ;};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_gdef *Ellipse )SetFitMode (fitMode FitMode ){_gdef ._dddb =fitMode };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_eafc *Image )SetEncoder (encoder _fac .StreamEncoder ){_eafc ._eedcc =encoder };

// NewMultiCell makes a new cell with given colspan and rowspan and inserts it into the row at the current position.
func (_ddbf *GridRow )NewMultiCell (colspan ,rowspan int )(*GridCell ,error ){_bagc :=&GridCell {_gfde :len (_ddbf ._cabf ),_dbab :_ddbf ._egag ,_cdfg :colspan ,_gcca :rowspan };_bagc ._dbab =_ddbf ._egag ;_bagc ._gfde =0;for _ ,_babeb :=range _ddbf ._cabf {_bagc ._gfde +=_babeb ._cdfg ;
};for _ccdf ,_ecfe :=range _ddbf ._accg ._bded {if _ccdf ==_ddbf ._egag +1{break ;};for _ ,_ebea :=range _ecfe ._cabf {if _ebea ._dbab +_ebea ._gcca > _bagc ._dbab {if _ebea ._gfde +_ebea ._cdfg > _bagc ._gfde {_bagc ._gfde =_ebea ._gfde +_ebea ._cdfg ;
};};};};if _bagc ._gfde >=_ddbf ._accg ._eedbe {return nil ,_ff .New ("\u0063\u0061n'\u0074\u0020\u0061d\u0064\u0020\u0061\u006ey m\u006fre\u0020\u0063\u0065\u006c\u006c\u0073\u0020to\u0020\u0074\u0068\u0069\u0073\u0020\u0072o\u0077");};_bagc ._bccb =5;
_bagc ._afbbd =CellBorderStyleNone ;_bagc ._becd =_gga .LineStyleSolid ;_bagc ._eedc =CellHorizontalAlignmentLeft ;_bagc ._cgcd =CellVerticalAlignmentTop ;_bagc ._dbaa =0;_bagc ._bgge =0;_bagc ._aegc =0;_bagc ._adbe =0;_abegg :=ColorBlack ;_bagc ._feac =_abegg ;
_bagc ._egfeg =_abegg ;_bagc ._fbfe =_abegg ;_bagc ._gbef =_abegg ;_bagc ._agefe =1.0;_ddbf ._cabf =append (_ddbf ._cabf ,_bagc );return _bagc ,nil ;};

// Opacity returns the opacity of the line.
func (_gggad *Line )Opacity ()float64 {return _gggad ._gddge };

// Command is a representation of an SVG path command and its parameters.
type Command struct{Symbol string ;Params []float64 ;};func _beedc (_ccbg *templateProcessor ,_ceddg *templateNode )(interface{},error ){return _ccbg .parseTextChunk (_ceddg ,nil );};

// Width returns the cell's width based on the input draw context.
func (_fgcf *TableCell )Width (ctx DrawContext )float64 {_aegbe :=float64 (0.0);for _ffgab :=0;_ffgab < _fgcf ._gbbga ;_ffgab ++{_aegbe +=_fgcf ._cecgbe ._bcbd [_fgcf ._bgage +_ffgab -1];};_egec :=ctx .Width *_aegbe ;return _egec ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_gaffeg *_gga .PolyBezierCurve ;_gfgf float64 ;_cfage float64 ;_abbc Color ;_acbcg *int64 ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_dabce *Creator )CreateTableOfContents (genTOCFunc func (_bbge *TOC )error ){_dabce ._gegg =genTOCFunc ;};

// SetBorderColor sets the border color.
func (_bfa *CurvePolygon )SetBorderColor (color Color ){_bfa ._bgecf .BorderColor =_cdfd (color )};func (_edcad *templateProcessor )nodeError (_cgcbd *templateNode ,_edgdg string ,_gbecf ...interface{})error {return _d .Errorf ("\u0025\u0073",_edcad .getNodeErrorLocation (_cgcbd ,_edgdg ,_gbecf ...));
};func (_adgaa *templateProcessor )parseFontAttr (_dbbed ,_dggd string )*_cb .PdfFont {_gg .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_dbbed ,_dggd );
_gfeea :=_adgaa .creator ._ebd ;if _dggd ==""{return _gfeea ;};_daggd :=_bd .Split (_dggd ,"\u002c");for _ ,_gagag :=range _daggd {_gagag =_bd .TrimSpace (_gagag );if _gagag ==""{continue ;};_babcb ,_agbdb :=_adgaa ._debae .FontMap [_dggd ];if _agbdb {return _babcb ;
};_geebb ,_agbdb :=map[string ]_cb .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_cb .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_cb .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_cb .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_cb .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_cb .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_cb .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_cb .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_cb .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_cb .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_cb .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_cb .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_cb .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_cb .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_cb .TimesBoldItalicName }[_dggd ];
if _agbdb {if _ffceg ,_gedaa :=_cb .NewStandard14Font (_geebb );_gedaa ==nil {return _ffceg ;};};if _bggefc :=_adgaa .parseAttrPropList (_gagag );len (_bggefc )> 0{if _cfgd ,_ddbba :=_bggefc ["\u0070\u0061\u0074\u0068"];_ddbba {_dcggb :=_cb .NewPdfFontFromTTFFile ;
if _gaadb ,_gefgaf :=_bggefc ["\u0074\u0079\u0070\u0065"];_gefgaf &&_gaadb =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_dcggb =_cb .NewCompositePdfFontFromTTFFile ;};if _baae ,_dfecg :=_dcggb (_cfgd );_dfecg !=nil {_gg .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_cfgd ,_dfecg );
}else {return _baae ;};};};};return _gfeea ;};func (_efaa *Path )compare (_cfdc *Path )bool {if len (_efaa .Subpaths )!=len (_cfdc .Subpaths ){return false ;};for _acgb ,_bggca :=range _efaa .Subpaths {if !_bggca .compare (_cfdc .Subpaths [_acgb ]){return false ;
};};return true ;};func _fcecfg (_dbgb *templateProcessor ,_ggebc *templateNode )(interface{},error ){return _dbgb .parseEllipse (_ggebc );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fafe *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_geaeg :=ctx ;_dadcb ,ctx ,_dgbb :=_fafe ._gbgfg .GeneratePageBlocks (ctx );if _dgbb !=nil {return _dadcb ,ctx ,_dgbb ;};if _fafe ._debaf .IsRelative (){ctx .X =_geaeg .X ;
};if _fafe ._debaf .IsAbsolute (){return _dadcb ,_geaeg ,nil ;};return _dadcb ,ctx ,nil ;};func (_aafc *StyledParagraph )getTextWidth ()float64 {var _bebca float64 ;_bebff :=len (_aafc ._eaad );for _fade ,_fgfdf :=range _aafc ._eaad {_dfafc :=&_fgfdf .Style ;
_cagfe :=len (_fgfdf .Text );for _eefad ,_bgfgc :=range _fgfdf .Text {if _bgfgc =='\u000A'{continue ;};_bbcb ,_fdeac :=_dfafc .Font .GetRuneMetrics (_bgfgc );if !_fdeac {_gg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bgfgc );
return -1;};_bebca +=_dfafc .FontSize *_bbcb .Wx *_dfafc .horizontalScale ();if _bgfgc !=' '&&(_fade !=_bebff -1||_eefad !=_cagfe -1){_bebca +=_dfafc .CharSpacing *1000.0;};};};return _bebca ;};

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_bcceb *Paragraph )SetLanguageIdentifier (id string ){_bcceb ._adae =id };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_gcag *Creator )SetOptimizer (optimizer _cb .Optimizer ){_gcag ._ggda =optimizer };

// SetOpacity sets opacity for border in range 0-1.
func (_dafcg *border )SetOpacity (opacity float64 ){_dafcg ._gcgf =opacity };func _bbgbc (_eadbd string ,_fefaa bool )string {_dafdb :=_eadbd ;if _dafdb ==""{return "";};_ebafc :=_ca .Paragraph {};_ ,_cbgccg :=_ebafc .SetString (_eadbd );if _cbgccg !=nil {return _dafdb ;
};_badd ,_cbgccg :=_ebafc .Order ();if _cbgccg !=nil {return _dafdb ;};_dedee :=_badd .NumRuns ();_fbbbg :=make ([]string ,_dedee );for _efdac :=0;_efdac < _badd .NumRuns ();_efdac ++{_efbebf :=_badd .Run (_efdac );_bcbed :=_efbebf .String ();if _efbebf .Direction ()==_ca .RightToLeft {_bcbed =_ca .ReverseString (_bcbed );
};if _fefaa {_fbbbg [_efdac ]=_bcbed ;}else {_fbbbg [_dedee -1]=_bcbed ;};_dedee --;};if len (_fbbbg )!=_badd .NumRuns (){return _eadbd ;};_dafdb =_bd .Join (_fbbbg ,"");return _dafdb ;};

// Heading returns the heading component of the table of contents.
func (_afafg *TOC )Heading ()*StyledParagraph {return _afafg ._gdcbd };

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// GeneratePageBlocks draws the filled curve on page blocks.
func (_dfbde *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aeaa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eaffe ,_ ,_acbe :=_dfbde .draw (_aeaa ,"");if _acbe !=nil {return nil ,ctx ,_acbe ;};_acbe =_aeaa .addContentsByString (string (_eaffe ));
if _acbe !=nil {return nil ,ctx ,_acbe ;};return []*Block {_aeaa },ctx ,nil ;};

// Indent returns the left offset of the list when nested into another list.
func (_eade *List )Indent ()float64 {return _eade ._fdb };func (_bdbdg *templateProcessor )parseDivision (_fggag *templateNode )(interface{},error ){_bcdea :=_bdbdg .creator .NewDivision ();for _ ,_gbad :=range _fggag ._bcdgfa .Attr {_aggc :=_gbad .Value ;
switch _bdebc :=_gbad .Name .Local ;_bdebc {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_bcdea .EnablePageWrap (_bdbdg .parseBoolAttr (_bdebc ,_aggc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_fbbcfe :=_bdbdg .parseMarginAttr (_bdebc ,_aggc );
_bcdea .SetMargins (_fbbcfe .Left ,_fbbcfe .Right ,_fbbcfe .Top ,_fbbcfe .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_ededbb :=_bdbdg .parseMarginAttr (_bdebc ,_aggc );_bcdea .SetPadding (_ededbb .Left ,_ededbb .Right ,_ededbb .Top ,_ededbb .Bottom );
default:_bdbdg .nodeLogDebug (_fggag ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_bdebc );
};};return _bcdea ,nil ;};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_fegffe []*_cb .PdfAnnotation ;_gabgdd []bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;_deafg *int64 ;_afae *string ;_adbfb *string ;};

// SkipCells skips over a specified number of cells in the table.
func (_eddcg *Table )SkipCells (num int ){if num < 0{_gg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _egga :=0;_egga < num ;_egga ++{_eddcg .NewCell ();};};

// SetBorderRadius sets the radius of the background corners.
func (_eeg *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_eeg .BorderRadiusTopLeft =topLeft ;_eeg .BorderRadiusTopRight =topRight ;_eeg .BorderRadiusBottomLeft =bottomLeft ;_eeg .BorderRadiusBottomRight =bottomRight ;
};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
//
// Deprecated: Use NewStyledParagraph instead for better styling options.
func (_dbef *Creator )NewParagraph (text string )*Paragraph {return _abad (text ,_dbef .NewTextStyle ())};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_cdfa *Image )SetMargins (left ,right ,top ,bottom float64 ){_cdfa ._bcgd .Left =left ;_cdfa ._bcgd .Right =right ;_cdfa ._bcgd .Top =top ;_cdfa ._bcgd .Bottom =bottom ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_cgcba *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_ggeb *LinearShading )SetBackgroundColor (backgroundColor Color ){_ggeb ._fafde .SetBackgroundColor (backgroundColor );};func _afddc (_cbde int )*Table {_dfag :=&Table {_cfgeg :_cbde ,_dgcc :10.0,_bcbd :[]float64 {},_begfg :[]float64 {},_gcbaa :[]*TableCell {},_bgddf :make ([]int ,_cbde ),_adfab :true };
_dfag .resetColumnWidths ();return _dfag ;};func (_aedb *pageTransformations )applyFlip (_ecfc *_cb .PdfPage )error {_afcf ,_cbgb :=_aedb ._bbgc ,_aedb ._ccff ;if !_afcf &&!_cbgb {return nil ;};if _ecfc ==nil {return _ff .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");
};_ddd ,_dcf :=_ecfc .GetMediaBox ();if _dcf !=nil {return _dcf ;};_dfbe ,_cdgg :=_ddd .Width (),_ddd .Height ();_fffd ,_dcf :=_ecfc .GetRotate ();if _dcf !=nil {_gg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_dcf .Error ());
};if _ecc :=_fffd %360!=0&&_fffd %90==0;_ecc {if _bbef :=(360+_fffd %360)%360;_bbef ==90||_bbef ==270{_afcf ,_cbgb =_cbgb ,_afcf ;};};_cefa ,_feaa :=1.0,0.0;if _afcf {_cefa ,_feaa =-1.0,-_dfbe ;};_gfafe ,_fcaf :=1.0,0.0;if _cbgb {_gfafe ,_fcaf =-1.0,-_cdgg ;
};_cdgd :=_ae .NewContentCreator ().Scale (_cefa ,_gfafe ).Translate (_feaa ,_fcaf );_gea ,_dcf :=_fac .MakeStream (_cdgd .Bytes (),_fac .NewFlateEncoder ());if _dcf !=nil {return _dcf ;};_accb :=_fac .MakeArray (_gea );_accb .Append (_ecfc .GetContentStreamObjs ()...);
_ecfc .Contents =_accb ;return nil ;};func _agbb (_gfdg string )([]float64 ,error ){_bfcee :=-1;var _bbfbf []float64 ;_baeb :=' ';for _ggge ,_gbece :=range _gfdg {if !_eef .IsNumber (_gbece )&&_gbece !='.'&&!(_gbece =='-'&&_baeb =='e')&&_gbece !='e'{if _bfcee !=-1{_ddafcf ,_fcbdf :=_egfbb (_gfdg [_bfcee :_ggge ]);
if _fcbdf !=nil {return _bbfbf ,_fcbdf ;};_bbfbf =append (_bbfbf ,_ddafcf ...);};if _gbece =='-'{_bfcee =_ggge ;}else {_bfcee =-1;};}else if _bfcee ==-1{_bfcee =_ggge ;};_baeb =_gbece ;};if _bfcee !=-1&&_bfcee !=len (_gfdg ){_fgggd ,_ababe :=_egfbb (_gfdg [_bfcee :]);
if _ababe !=nil {return _bbfbf ,_ababe ;};_bbfbf =append (_bbfbf ,_fgggd ...);};return _bbfbf ,nil ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func (_aedc *Invoice )drawSection (_adge ,_edece string )[]*StyledParagraph {var _badfe []*StyledParagraph ;if _adge !=""{_ecgdc :=_cedfb (_aedc ._agbc );_ecgdc .SetMargins (0,0,0,5);_ecgdc .Append (_adge );_badfe =append (_badfe ,_ecgdc );
};if _edece !=""{_bdgea :=_cedfb (_aedc ._fefc );_bdgea .Append (_edece );_badfe =append (_badfe ,_bdgea );};return _badfe ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// GetRowHeight returns the height of the specified row.
func (_bagca *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_bagca ._begfg ){return 0,_ff .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _bagca ._begfg [row -1],nil ;
};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_acee *StyledParagraph )Height ()float64 {_acee .wrapText ();var _gabg float64 ;for _ ,_fbbdc :=range _acee ._ebbfe {var _aafge float64 ;for _ ,_fbbb :=range _fbbdc {_bafgf :=_acee ._dcag *_fbbb .Style .FontSize ;if _bafgf > _aafge {_aafge =_bafgf ;
};};_gabg +=_aafge ;};return _gabg ;};

// Link returns link information for this line.
func (_gdfec *TOCLine )Link ()(_cbbdf int64 ,_bfadf ,_acag float64 ){return _gdfec ._ecffff ,_gdfec ._dgag ,_gdfec ._beebg ;};

// SetIndent sets the cell's left indent.
func (_egeb *TableCell )SetIndent (indent float64 ){_egeb ._bbeab =indent };func (_ebff *Paragraph )getTextWidth ()float64 {_cfea :=0.0;for _ ,_dcbe :=range _ebff ._caec {if _dcbe =='\u000A'{continue ;};_caag ,_fdggd :=_ebff ._effad .GetRuneMetrics (_dcbe );
if !_fdggd {_gg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_dcbe ,_dcbe );
return -1;};_cfea +=_ebff ._dbcd *_caag .Wx ;};return _cfea ;};type commands struct{_dbdac []string ;_fcbbg map[string ]int ;_ecbde string ;_dcdc string ;};

// WriteToFile writes the Creator output to file specified by path.
func (_acba *Creator )WriteToFile (outputPath string )error {_gag ,_bbfea :=_b .Create (outputPath );if _bbfea !=nil {return _bbfea ;};defer _gag .Close ();return _acba .Write (_gag );};func _ebebb (_fcfae ,_ecfgf ,_cgacc float64 )(_abcba ,_gdgcc ,_cfaga ,_bgcba float64 ){if _cgacc ==0{return 0,0,_fcfae ,_ecfgf ;
};_gdag :=_gga .Path {Points :[]_gga .Point {_gga .NewPoint (0,0).Rotate (_cgacc ),_gga .NewPoint (_fcfae ,0).Rotate (_cgacc ),_gga .NewPoint (0,_ecfgf ).Rotate (_cgacc ),_gga .NewPoint (_fcfae ,_ecfgf ).Rotate (_cgacc )}}.GetBoundingBox ();return _gdag .X ,_gdag .Y ,_gdag .Width ,_gdag .Height ;
};

// GeneratePageBlocks implements drawable interface.
func (_cegd *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_beeg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_daec :=_cegd ._bbe ;_ggab :=ctx .PageHeight -_cegd ._efgd ;if _cegd ._bgf !=nil {_fagf :=_gga .Rectangle {Opacity :1.0,X :_cegd ._bbe ,Y :ctx .PageHeight -_cegd ._efgd -_cegd ._cagd ,Height :_cegd ._cagd ,Width :_cegd ._dfa };
_fagf .FillEnabled =true ;_dabf :=_cdfd (_cegd ._bgf );_ffe :=_bddf (_beeg ,_dabf ,_cegd ._bgf ,func ()Rectangle {return Rectangle {_gbaf :_fagf .X ,_gcfge :_fagf .Y ,_ggcb :_fagf .Width ,_baadd :_fagf .Height };});if _ffe !=nil {return nil ,ctx ,_ffe ;
};_fagf .FillColor =_dabf ;_fagf .BorderEnabled =false ;_gedf :="";if _cegd ._gcgf < 1{_gcgc :=_fac .MakeDict ();_gcgc .Set ("\u0063\u0061",_fac .MakeFloat (_cegd ._gcgf ));_gcgc .Set ("\u0043\u0041",_fac .MakeFloat (_cegd ._gcgf ));_dea :=_beeg ._bg .AddExtGState ("\u0067\u0073\u0031",_gcgc );
if _dea ==nil {_gedf ="\u0067\u0073\u0031";};};_dcec ,_ ,_ffe :=_fagf .Draw (_gedf );if _ffe !=nil {return nil ,ctx ,_ffe ;};_ffe =_beeg .addContentsByString (string (_dcec ));if _ffe !=nil {return nil ,ctx ,_ffe ;};};_deag :=_cegd ._ddb ;_bfga :=_cegd ._dab ;
_gba :=_cegd ._bfdb ;_dbf :=_cegd ._gaeb ;_bge :=_cegd ._ddb ;if _cegd ._dcac ==CellBorderStyleDouble {_bge +=2*_deag ;};_adga :=_cegd ._dab ;if _cegd ._bee ==CellBorderStyleDouble {_adga +=2*_bfga ;};_caeg :=_cegd ._bfdb ;if _cegd ._gdg ==CellBorderStyleDouble {_caeg +=2*_gba ;
};_aeb :=_cegd ._gaeb ;if _cegd ._bgfd ==CellBorderStyleDouble {_aeb +=2*_dbf ;};_ffc :=(_bge -_caeg )/2;_ebce :=(_bge -_aeb )/2;_bcfc :=(_adga -_caeg )/2;_ccfa :=(_adga -_aeb )/2;if _cegd ._ddb !=0{_aad :=_daec ;_fff :=_ggab ;if _cegd ._dcac ==CellBorderStyleDouble {_fff -=_deag ;
_eeed :=_gga .BasicLine {LineColor :_cdfd (_cegd ._feeb ),Opacity :1.0,LineWidth :_cegd ._ddb ,LineStyle :_cegd .LineStyle ,X1 :_aad -_bge /2+_ffc ,Y1 :_fff +2*_deag ,X2 :_aad +_bge /2-_ebce +_cegd ._dfa ,Y2 :_fff +2*_deag };_ebfg ,_ ,_dfe :=_eeed .Draw ("");
if _dfe !=nil {return nil ,ctx ,_dfe ;};_dfe =_beeg .addContentsByString (string (_ebfg ));if _dfe !=nil {return nil ,ctx ,_dfe ;};};_eff :=_gga .BasicLine {LineWidth :_cegd ._ddb ,Opacity :1.0,LineColor :_cdfd (_cegd ._feeb ),LineStyle :_cegd .LineStyle ,X1 :_aad -_bge /2+_ffc +(_caeg -_cegd ._bfdb ),Y1 :_fff ,X2 :_aad +_bge /2-_ebce +_cegd ._dfa -(_aeb -_cegd ._gaeb ),Y2 :_fff };
_eba ,_ ,_fccg :=_eff .Draw ("");if _fccg !=nil {return nil ,ctx ,_fccg ;};_fccg =_beeg .addContentsByString (string (_eba ));if _fccg !=nil {return nil ,ctx ,_fccg ;};};if _cegd ._dab !=0{_cgcc :=_daec ;_gcgbb :=_ggab -_cegd ._cagd ;if _cegd ._bee ==CellBorderStyleDouble {_gcgbb +=_bfga ;
_cegc :=_gga .BasicLine {LineWidth :_cegd ._dab ,Opacity :1.0,LineColor :_cdfd (_cegd ._ddc ),LineStyle :_cegd .LineStyle ,X1 :_cgcc -_adga /2+_bcfc ,Y1 :_gcgbb -2*_bfga ,X2 :_cgcc +_adga /2-_ccfa +_cegd ._dfa ,Y2 :_gcgbb -2*_bfga };_fdf ,_ ,_cga :=_cegc .Draw ("");
if _cga !=nil {return nil ,ctx ,_cga ;};_cga =_beeg .addContentsByString (string (_fdf ));if _cga !=nil {return nil ,ctx ,_cga ;};};_gcf :=_gga .BasicLine {LineWidth :_cegd ._dab ,Opacity :1.0,LineColor :_cdfd (_cegd ._ddc ),LineStyle :_cegd .LineStyle ,X1 :_cgcc -_adga /2+_bcfc +(_caeg -_cegd ._bfdb ),Y1 :_gcgbb ,X2 :_cgcc +_adga /2-_ccfa +_cegd ._dfa -(_aeb -_cegd ._gaeb ),Y2 :_gcgbb };
_afc ,_ ,_bdg :=_gcf .Draw ("");if _bdg !=nil {return nil ,ctx ,_bdg ;};_bdg =_beeg .addContentsByString (string (_afc ));if _bdg !=nil {return nil ,ctx ,_bdg ;};};if _cegd ._bfdb !=0{_dgdg :=_daec ;_bbaa :=_ggab ;if _cegd ._gdg ==CellBorderStyleDouble {_dgdg +=_gba ;
_fbaa :=_gga .BasicLine {LineWidth :_cegd ._bfdb ,Opacity :1.0,LineColor :_cdfd (_cegd ._gfc ),LineStyle :_cegd .LineStyle ,X1 :_dgdg -2*_gba ,Y1 :_bbaa +_caeg /2+_ffc ,X2 :_dgdg -2*_gba ,Y2 :_bbaa -_caeg /2-_bcfc -_cegd ._cagd };_aaf ,_ ,_fdcf :=_fbaa .Draw ("");
if _fdcf !=nil {return nil ,ctx ,_fdcf ;};_fdcf =_beeg .addContentsByString (string (_aaf ));if _fdcf !=nil {return nil ,ctx ,_fdcf ;};};_eec :=_gga .BasicLine {LineWidth :_cegd ._bfdb ,Opacity :1.0,LineColor :_cdfd (_cegd ._gfc ),LineStyle :_cegd .LineStyle ,X1 :_dgdg ,Y1 :_bbaa +_caeg /2+_ffc -(_bge -_cegd ._ddb ),X2 :_dgdg ,Y2 :_bbaa -_caeg /2-_bcfc -_cegd ._cagd +(_adga -_cegd ._dab )};
_gad ,_ ,_deb :=_eec .Draw ("");if _deb !=nil {return nil ,ctx ,_deb ;};_deb =_beeg .addContentsByString (string (_gad ));if _deb !=nil {return nil ,ctx ,_deb ;};};if _cegd ._gaeb !=0{_fda :=_daec +_cegd ._dfa ;_bafb :=_ggab ;if _cegd ._bgfd ==CellBorderStyleDouble {_fda -=_dbf ;
_fccf :=_gga .BasicLine {LineWidth :_cegd ._gaeb ,Opacity :1.0,LineColor :_cdfd (_cegd ._ccce ),LineStyle :_cegd .LineStyle ,X1 :_fda +2*_dbf ,Y1 :_bafb +_aeb /2+_ebce ,X2 :_fda +2*_dbf ,Y2 :_bafb -_aeb /2-_ccfa -_cegd ._cagd };_fge ,_ ,_gfa :=_fccf .Draw ("");
if _gfa !=nil {return nil ,ctx ,_gfa ;};_gfa =_beeg .addContentsByString (string (_fge ));if _gfa !=nil {return nil ,ctx ,_gfa ;};};_gaa :=_gga .BasicLine {LineWidth :_cegd ._gaeb ,Opacity :1.0,LineColor :_cdfd (_cegd ._ccce ),LineStyle :_cegd .LineStyle ,X1 :_fda ,Y1 :_bafb +_aeb /2+_ebce -(_bge -_cegd ._ddb ),X2 :_fda ,Y2 :_bafb -_aeb /2-_ccfa -_cegd ._cagd +(_adga -_cegd ._dab )};
_bad ,_ ,_bedb :=_gaa .Draw ("");if _bedb !=nil {return nil ,ctx ,_bedb ;};_bedb =_beeg .addContentsByString (string (_bad ));if _bedb !=nil {return nil ,ctx ,_bedb ;};};return []*Block {_beeg },ctx ,nil ;};func (_dadb grayColor )ToRGB ()(float64 ,float64 ,float64 ){return _dadb ._gadc ,_dadb ._gadc ,_dadb ._gadc ;
};

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_fecbc *Rectangle )SetPositioning (position Positioning ){_fecbc ._fdfc =position };func _ggac (_eacbc *_cb .PdfAnnotationHighlight )*_cb .PdfAnnotationHighlight {if _eacbc ==nil {return nil ;};_adfadf :=_cb .NewPdfAnnotationHighlight ();_adfadf .C =_eacbc .C ;
_adfadf .CA =_eacbc .CA ;_adfadf .Rect =_eacbc .Rect ;_adfadf .QuadPoints =_eacbc .QuadPoints ;return _adfadf ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};func _edgcde (_ffagb *_cb .PdfRectangle ,_ccecg _gb .Matrix )*_cb .PdfRectangle {var _bggeff _cb .PdfRectangle ;_bggeff .Llx ,_bggeff .Lly =_ccecg .Transform (_ffagb .Llx ,_ffagb .Lly );_bggeff .Urx ,_bggeff .Ury =_ccecg .Transform (_ffagb .Urx ,_ffagb .Ury );
_bggeff .Normalize ();return &_bggeff ;};func (_gccf *TOCLine )prepareParagraph (_bdcbb *StyledParagraph ,_eegec DrawContext ){_cdfc :=_gccf .Title .Text ;if _gccf .Number .Text !=""{_cdfc ="\u0020"+_cdfc ;};_cdfc +="\u0020";_cbgfd :=_gccf .Page .Text ;
if _cbgfd !=""{_cbgfd ="\u0020"+_cbgfd ;};_eggaf :=[]*_cb .PdfAnnotation {};_gbffb :=_gccf .getLineLink ();if _gbffb !=nil {_eggaf =append (_eggaf ,_gbffb );};_bdcbb ._eaad =[]*TextChunk {{Text :_gccf .Number .Text ,Style :_gccf .Number .Style ,_fegffe :_eggaf },{Text :_cdfc ,Style :_gccf .Title .Style ,_fegffe :_eggaf },{Text :_cbgfd ,Style :_gccf .Page .Style ,_fegffe :_eggaf }};
_bdcbb .wrapText ();_eabbc :=len (_bdcbb ._ebbfe );if _eabbc ==0{return ;};_adfec :=_eegec .Width *1000-_bdcbb .getTextLineWidth (_bdcbb ._ebbfe [_eabbc -1]);_fcac :=_bdcbb .getTextLineWidth ([]*TextChunk {&_gccf .Separator });_ddcbfc :=int (_adfec /_fcac );
_agagdf :=_bd .Repeat (_gccf .Separator .Text ,_ddcbfc );_dcbca :=_gccf .Separator .Style ;_cdcgf :=_bdcbb .Insert (2,_agagdf );_cdcgf .Style =_dcbca ;_cdcgf .SetAnnotation (_gccf .getLineLink ());_adfec =_adfec -float64 (_ddcbfc )*_fcac ;if _adfec > 500{_bccebf ,_dcabf :=_dcbca .Font .GetRuneMetrics (' ');
if _dcabf &&_adfec > _bccebf .Wx {_cgaec :=int (_adfec /_bccebf .Wx );if _cgaec > 0{_fdecfg :=_dcbca ;_fdecfg .FontSize =1;_cdcgf =_bdcbb .Insert (2,_bd .Repeat ("\u0020",_cgaec ));_cdcgf .Style =_fdecfg ;_cdcgf .SetAnnotation (_gccf .getLineLink ());};
};};};

// AppendCurve appends a Bezier curve to the filled curve.
func (_adbb *FilledCurve )AppendCurve (curve _gga .CubicBezierCurve )*FilledCurve {_adbb ._dbdf =append (_adbb ._dbdf ,curve );return _adbb ;};

// TextAlignment options for paragraph.
type TextAlignment int ;func (_eafa *Grid )updateRowHeights (_baccb float64 ){for _ ,_dfad :=range _eafa ._bded {_dfad .updateRowHeight (_baccb );};};

// SetTextExpansion sets the text expansion for the text chunk.
func (_ffcgg *TextChunk )SetTextExpansion (text string ){_ffcgg ._afae =&text };

// SetFillColor sets the fill color.
func (_bgef *CurvePolygon )SetFillColor (color Color ){_bgef ._bcge =color ;_bgef ._bgecf .FillColor =_cdfd (color );};

// SetBorderOpacity sets the border opacity.
func (_dcgeg *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_dcgeg ._cfage =opacity };func (_aegdf *templateProcessor )parseInt64Array (_bgecg ,_efee string )[]int64 {_gg .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bgecg ,_efee );
_fdceec :=_bd .Fields (_efee );_eebdab :=make ([]int64 ,0,len (_fdceec ));for _ ,_gfbdd :=range _fdceec {_egabd ,_ :=_fa .ParseInt (_gfbdd ,10,64);_eebdab =append (_eebdab ,_egabd );};return _eebdab ;};

// SetMarkedContentID sets the marked content ID for the image.
func (_ccee *Image )SetMarkedContentID (mcid int64 )*_cb .KDict {_ccee ._fbbe =&mcid ;_gbea :=_cb .NewKDictionary ();_gbea .S =_fac .MakeName (_cb .StructureTypeFigure );_gbea .K =_fac .MakeInteger (mcid );return _gbea ;};

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_gedac *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_edce []*Block ;_cgfb =NewBlock (ctx .PageWidth ,ctx .PageHeight );_bcce =ctx ;);_bfbf :=_gedac ._gcfb .IsRelative ();if _bfbf {_gedac .applyFitMode (ctx .Width );
ctx .X +=_gedac ._dede .Left ;ctx .Y +=_gedac ._dede .Top ;ctx .Width -=_gedac ._dede .Left +_gedac ._dede .Right ;ctx .Height -=_gedac ._dede .Top +_gedac ._dede .Bottom ;if _gedac ._addb > ctx .Height {_edce =append (_edce ,_cgfb );_cgfb =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_dgff :=ctx ;_dgff .Y =ctx .Margins .Top +_gedac ._dede .Top ;_dgff .X =ctx .Margins .Left +_gedac ._dede .Left ;_dgff .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_gedac ._dede .Top -_gedac ._dede .Bottom ;_dgff .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gedac ._dede .Left -_gedac ._dede .Right ;
ctx =_dgff ;};}else {ctx .X =_gedac ._dada -_gedac ._gdfc /2;ctx .Y =_gedac ._dfdg -_gedac ._addb /2;};_fdgfa :=_gga .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_gedac ._addb ,Width :_gedac ._gdfc ,Height :_gedac ._addb ,BorderWidth :_gedac ._gdad ,Opacity :1.0};
if _gedac ._cfefb !=nil {_fdgfa .FillEnabled =true ;_ebae :=_cdfd (_gedac ._cfefb );_cccee :=_bddf (_cgfb ,_ebae ,_gedac ._cfefb ,func ()Rectangle {return Rectangle {_gbaf :_fdgfa .X ,_gcfge :_fdgfa .Y ,_ggcb :_fdgfa .Width ,_baadd :_fdgfa .Height };});
if _cccee !=nil {return nil ,ctx ,_cccee ;};_fdgfa .FillColor =_ebae ;};if _gedac ._eagg !=nil {_fdgfa .BorderEnabled =false ;if _gedac ._gdad > 0{_fdgfa .BorderEnabled =true ;};_fdgfa .BorderColor =_cdfd (_gedac ._eagg );_fdgfa .BorderWidth =_gedac ._gdad ;
};_ddaf ,_fbfgc :=_cgfb .setOpacity (_gedac ._abdd ,_gedac ._fggg );if _fbfgc !=nil {return nil ,ctx ,_fbfgc ;};_fbfc ,_ ,_fbfgc :=_fdgfa .MarkedDraw (_ddaf ,_gedac ._aadc );if _fbfgc !=nil {return nil ,ctx ,_fbfgc ;};_fbfgc =_cgfb .addContentsByString (string (_fbfc ));
if _fbfgc !=nil {return nil ,ctx ,_fbfgc ;};if _bfbf {ctx .X =_bcce .X ;ctx .Width =_bcce .Width ;ctx .Y +=_gedac ._addb +_gedac ._dede .Bottom ;ctx .Height -=_gedac ._addb ;}else {ctx =_bcce ;};_edce =append (_edce ,_cgfb );return _edce ,ctx ,nil ;};

// AddAnnotation adds an annotation on a TextChunk.
func (_aecff *TextChunk )AddAnnotation (annotation *_cb .PdfAnnotation ){if annotation ==nil {return ;};_aecff ._fegffe =append (_aecff ._fegffe ,annotation );};

// Logo returns the logo of the invoice.
func (_cacfc *Invoice )Logo ()*Image {return _cacfc ._efad };func (_gfee *StyledParagraph )getTextHeight ()float64 {var _edeae float64 ;for _ ,_caadd :=range _gfee ._eaad {_dfbca :=_caadd .Style .FontSize *_gfee ._dcag ;if _dfbca > _edeae {_edeae =_dfbca ;
};};return _edeae ;};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_aega *Line )SetFitMode (fitMode FitMode ){_aega ._fdgd =fitMode };

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_aae *Block )ScaleToWidth (w float64 ){_adf :=w /_aae ._db ;_aae .Scale (_adf ,_adf )};func _ddbe (_ebbd ,_ddgc ,_dgaac ,_bgcf float64 )*Rectangle {return &Rectangle {_gbaf :_ebbd ,_gcfge :_ddgc ,_ggcb :_dgaac ,_baadd :_bgcf ,_fdfc :PositionAbsolute ,_abeed :1.0,_edcc :ColorBlack ,_afefe :1.0,_fbfee :1.0};
};

// SetMarkedContentID sets the marked content id for the paragraph.
func (_afeg *Paragraph )SetMarkedContentID (mcid int64 )*_cb .KDict {_afeg ._aaec =&mcid ;_fedg :=_cb .NewKDictionary ();_fedg .S =_fac .MakeName ("\u0050");_fedg .K =_fac .MakeInteger (mcid );return _fedg ;};func (_cgbab *TableCell )cloneProps (_gcbbb VectorDrawable )*TableCell {_gabgd :=*_cgbab ;
_gabgd ._bgfcf =_gcbbb ;return &_gabgd ;};

// SetTitle sets the title of the invoice.
func (_cadc *Invoice )SetTitle (title string ){_cadc ._baggf =title };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_babb *Creator )Finalize ()error {if _babb ._ecae {return nil ;};_afcgf :=len (_babb ._adce );_bdec :=0;if _babb ._afdf !=nil {_eeac :=*_babb ;_babb ._adce =nil ;_babb ._fccgc =nil ;_babb .initContext ();_ede :=FrontpageFunctionArgs {PageNum :1,TotalPages :_afcgf };
_babb ._afdf (_ede );_bdec +=len (_babb ._adce );_babb ._adce =_eeac ._adce ;_babb ._fccgc =_eeac ._fccgc ;};if _babb .AddTOC {_babb .initContext ();_babb ._fdec .Page =_bdec +1;if _babb .CustomTOC &&_babb ._gegg !=nil {_cgd :=*_babb ;_babb ._adce =nil ;
_babb ._fccgc =nil ;if _beea :=_babb ._gegg (_babb ._fbc );_beea !=nil {return _beea ;};_bdec +=len (_babb ._adce );_babb ._adce =_cgd ._adce ;_babb ._fccgc =_cgd ._fccgc ;}else {if _babb ._gegg !=nil {if _babd :=_babb ._gegg (_babb ._fbc );_babd !=nil {return _babd ;
};};_ebcd ,_ ,_ebgb :=_babb ._fbc .GeneratePageBlocks (_babb ._fdec );if _ebgb !=nil {_gg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_ebgb );
return _ebgb ;};_bdec +=len (_ebcd );};_ddbg :=_babb ._fbc .Lines ();for _ ,_aafe :=range _ddbg {_ggabg ,_fbde :=_fa .Atoi (_aafe .Page .Text );if _fbde !=nil {continue ;};_aafe .Page .Text =_fa .Itoa (_ggabg +_bdec );_aafe ._ecffff +=int64 (_bdec );};
};_cbge :=false ;var _dgdc []*_cb .PdfPage ;if _babb ._afdf !=nil {_befc :=*_babb ;_babb ._adce =nil ;_babb ._fccgc =nil ;_eecb :=FrontpageFunctionArgs {PageNum :1,TotalPages :_afcgf };_babb ._afdf (_eecb );_afcgf +=len (_babb ._adce );_dgdc =_babb ._adce ;
_babb ._adce =append (_babb ._adce ,_befc ._adce ...);_babb ._fccgc =_befc ._fccgc ;_cbge =true ;};var _ggf []*_cb .PdfPage ;if _babb .AddTOC {_babb .initContext ();if _babb .CustomTOC &&_babb ._gegg !=nil {_feff :=*_babb ;_babb ._adce =nil ;_babb ._fccgc =nil ;
if _bcb :=_babb ._gegg (_babb ._fbc );_bcb !=nil {_gg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_bcb );return _bcb ;};_ggf =_babb ._adce ;_afcgf +=len (_ggf );
_babb ._adce =_feff ._adce ;_babb ._fccgc =_feff ._fccgc ;}else {if _babb ._gegg !=nil {if _eed :=_babb ._gegg (_babb ._fbc );_eed !=nil {_gg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_eed );
return _eed ;};};_eabd ,_ ,_ :=_babb ._fbc .GeneratePageBlocks (_babb ._fdec );for _ ,_bbfe :=range _eabd {_bbfe .SetPos (0,0);_afcgf ++;_cbce :=_babb .newPage ();_ggf =append (_ggf ,_cbce );_babb .setActivePage (_cbce );_babb .Draw (_bbfe );};};if _cbge {_gacf :=_dgdc ;
_gacg :=_babb ._adce [len (_dgdc ):];_babb ._adce =append ([]*_cb .PdfPage {},_gacf ...);_babb ._adce =append (_babb ._adce ,_ggf ...);_babb ._adce =append (_babb ._adce ,_gacg ...);}else {_babb ._adce =append (_ggf ,_babb ._adce ...);};};if _babb ._gbcd !=nil &&_babb .AddOutlines {var _acbd func (_bgee *_cb .OutlineItem );
_acbd =func (_ddcf *_cb .OutlineItem ){_ddcf .Dest .Page +=int64 (_bdec );if _ace :=int (_ddcf .Dest .Page );_ace >=0&&_ace < len (_babb ._adce ){_ddcf .Dest .PageObj =_babb ._adce [_ace ].GetPageAsIndirectObject ();}else {_gg .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_ace );
};_ddcf .Dest .Y =_aa .RoundDefault (_babb ._bfbc -_ddcf .Dest .Y );_abf :=_ddcf .Items ();for _ ,_efea :=range _abf {_acbd (_efea );};};_cddb :=_babb ._gbcd .Items ();for _ ,_daad :=range _cddb {_acbd (_daad );};if _babb .AddTOC {var _dcgb int ;if _cbge {_dcgb =len (_dgdc );
};_eage :=_cb .NewOutlineDest (int64 (_dcgb ),0,_babb ._bfbc );if _dcgb >=0&&_dcgb < len (_babb ._adce ){_eage .PageObj =_babb ._adce [_dcgb ].GetPageAsIndirectObject ();}else {_gg .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_dcgb );
};_babb ._gbcd .Insert (0,_cb .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_eage ));};};for _bfdc ,_bfgaf :=range _babb ._adce {_babb .setActivePage (_bfgaf );if _babb ._cdg !=nil {_fdeb ,_ageg ,_gega :=_bfgaf .Size ();
if _gega !=nil {return _gega ;};_cdac :=PageFinalizeFunctionArgs {PageNum :_bfdc +1,PageWidth :_fdeb ,PageHeight :_ageg ,TOCPages :len (_ggf ),TotalPages :_afcgf };if _gbbe :=_babb ._cdg (_cdac );_gbbe !=nil {_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_gbbe );
return _gbbe ;};};if _babb ._gcge !=nil {_bbbg :=NewBlock (_babb ._eegg ,_babb ._bea .Top );_bdaf :=HeaderFunctionArgs {PageNum :_bfdc +1,TotalPages :_afcgf };_babb ._gcge (_bbbg ,_bdaf );_bbbg .SetPos (0,0);if _cce :=_babb .Draw (_bbbg );_cce !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_cce );
return _cce ;};};if _babb ._egf !=nil {_gfg :=NewBlock (_babb ._eegg ,_babb ._bea .Bottom );_ddda :=FooterFunctionArgs {PageNum :_bfdc +1,TotalPages :_afcgf };_babb ._egf (_gfg ,_ddda );_gfg .SetPos (0,_babb ._bfbc -_gfg ._ecf );if _aaff :=_babb .Draw (_gfg );
_aaff !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_aaff );return _aaff ;};};_egee ,_bgcd :=_babb ._ebgc [_bfgaf ];if _cfbe ,_cbe :=_babb ._cgaf [_bfgaf ];
_cbe {if _bgcd {_egee .transformBlock (_cfbe );};if _gcbe :=_cfbe .drawToPage (_bfgaf );_gcbe !=nil {_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_bfdc +1,_gcbe );
return _gcbe ;};};if _bgcd {if _afdc :=_egee .transformPage (_bfgaf );_afdc !=nil {_gg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_afdc );
return _afdc ;};};};_babb ._ecae =true ;return nil ;};type border struct{_bbe float64 ;_efgd float64 ;_dfa float64 ;_cagd float64 ;_bgf Color ;_gfc Color ;_bfdb float64 ;_ddc Color ;_dab float64 ;_ccce Color ;_gaeb float64 ;_feeb Color ;_ddb float64 ;LineStyle _gga .LineStyle ;
_gdg CellBorderStyle ;_bgfd CellBorderStyle ;_dcac CellBorderStyle ;_bee CellBorderStyle ;_gcgf float64 ;};func (_ceead *templateProcessor )getNodeErrorLocation (_cdge *templateNode ,_adcbc string ,_egbde ...interface{})string {_eggb :=_d .Sprintf (_adcbc ,_egbde ...);
_afbga :=_d .Sprintf ("\u0025\u0064",_cdge ._eecg );if _cdge ._acfbc !=0{_afbga =_d .Sprintf ("\u0025\u0064\u003a%\u0064",_cdge ._acfbc ,_cdge ._ecddb );};if _ceead ._eabee !=""{return _d .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_eggb ,_ceead ._eabee ,_afbga );
};return _d .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_eggb ,_afbga );};func (_cdgac *Image )makeXObject ()error {_egdf ,_dgba :=_cb .NewXObjectImageFromImageLazy (_cdgac ._bgeac ,nil ,_cdgac ._eedcc ,_cdgac ._ccefc );if _dgba !=nil {_gg .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dgba );
return _dgba ;};_cdgac ._bfad =_egdf ;return nil ;};func (_ceebf *Paragraph )getTextMetrics ()(_agcd ,_edad ,_efbfe float64 ){_gcce :=_gagfg (_ceebf ._effad ,_ceebf ._dbcd );if _gcce ._cabc > _agcd {_agcd =_gcce ._cabc ;};if _gcce ._bcbe < _efbfe {_efbfe =_gcce ._bcbe ;
};if _edfga :=_ceebf ._dbcd ;_edfga > _edad {_edad =_edfga ;};return _agcd ,_edad ,_efbfe ;};

// MoveY moves the drawing context to absolute position y.
func (_gdfe *Creator )MoveY (y float64 ){_gdfe ._fdec .Y =y };

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_adfad *Creator )NewStyledParagraph ()*StyledParagraph {return _cedfb (_adfad .NewTextStyle ())};func (_cdgfc pathParserError )Error ()string {return _cdgfc ._faaeg };

// SetFillOpacity sets the fill opacity.
func (_dcdf *PolyBezierCurve )SetFillOpacity (opacity float64 ){_dcdf ._gfgf =opacity };

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_efc *Block )DrawTemplate (c *Creator ,r _ad .Reader ,data interface{},options *TemplateOptions )error {return _dbccd (c ,r ,data ,options ,_efc );};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_cdag *Image )ScaleToHeight (h float64 ){_adedd :=_cdag ._efca /_cdag ._efag ;_cdag ._efag =h ;_cdag ._efca =h *_adedd ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_fbef *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_dccgd ,_fdggf :=_fbef .Wrap (width );if _fdggf !=nil {return nil ,_fdggf ;};_fgcge :=int (height /_fbef .Style .FontSize );if _fgcge >=len (_dccgd ){return nil ,nil ;};_befca :="\u000a";
_fbef .Text =_bd .Replace (_bd .Join (_dccgd [:_fgcge ],"\u0020"),_befca +"\u0020",_befca ,-1);_cfged :=_bd .Replace (_bd .Join (_dccgd [_fgcge :],"\u0020"),_befca +"\u0020",_befca ,-1);return NewTextChunk (_cfged ,_fbef .Style ),nil ;};func _abfce (_eaac float64 ,_gdfab float64 )float64 {return _a .Round (_eaac /_gdfab )*_gdfab };
func (_bb *Block )setOpacity (_abg float64 ,_ccg float64 )(string ,error ){if (_abg < 0||_abg >=1.0)&&(_ccg < 0||_ccg >=1.0){return "",nil ;};_dd :=0;_gbgb :=_d .Sprintf ("\u0047\u0053\u0025\u0064",_dd );for _bb ._bg .HasExtGState (_fac .PdfObjectName (_gbgb )){_dd ++;
_gbgb =_d .Sprintf ("\u0047\u0053\u0025\u0064",_dd );};_ac :=_fac .MakeDict ();if _abg >=0&&_abg < 1.0{_ac .Set ("\u0063\u0061",_fac .MakeFloat (_abg ));};if _ccg >=0&&_ccg < 1.0{_ac .Set ("\u0043\u0041",_fac .MakeFloat (_ccg ));};_abe :=_bb ._bg .AddExtGState (_fac .PdfObjectName (_gbgb ),_ac );
if _abe !=nil {return "",_abe ;};return _gbgb ,nil ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_ffg int ;_cgbg string ;_egea *StyledParagraph ;_ebcc []Drawable ;_bce int ;_cdce bool ;_cdeb bool ;_dfca Positioning ;_dbfg ,_cafg float64 ;_afcg Margins ;_edc *Chapter ;_fgaf *TOC ;_eeee *_cb .Outline ;_dda *_cb .OutlineItem ;_fcf uint ;
};

// GeneratePageBlocks generates a page break block.
func (_fddde *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_daaac :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_egdbf :=ctx ;_egdbf .Y =ctx .Margins .Top ;
_egdbf .X =ctx .Margins .Left ;_egdbf .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_egdbf .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_egdbf ;return _daaac ,ctx ,nil ;};

// ParseFromSVGFile creates a GraphicSVG instance from file.
func ParseFromSVGFile (path string )(*GraphicSVGElement ,error ){_ecdad ,_agfag :=_b .Open (path );if _agfag !=nil {return nil ,_agfag ;};defer _ecdad .Close ();return ParseFromSVGStream (_ecdad );};

// SetMargins sets the Paragraph's margins.
func (_gbfg *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_gbfg ._gebd .Left =left ;_gbfg ._gebd .Right =right ;_gbfg ._gebd .Top =top ;_gbfg ._gebd .Bottom =bottom ;};func (_gebba *templateProcessor )parsePositioningAttr (_eeebc ,_bcdfg string )Positioning {_gg .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_eeebc ,_bcdfg );
_efbeb :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_bcdfg ];return _efbeb ;};

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_edeg *Ellipse )FillOpacity ()float64 {return _edeg ._abdd };

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_bgecf *_gga .CurvePolygon ;_gaff float64 ;_efbg float64 ;_bcge Color ;_gbee *int64 ;};

// LineWidth returns the width of the line.
func (_fadde *Line )LineWidth ()float64 {return _fadde ._fcfg };func (_daab *Paragraph )wrapText ()error {if !_daab ._cbca ||int (_daab ._egeg )<=0{_daab ._ffff =[]string {_daab ._caec };return nil ;};_bgde :=NewTextChunk (_daab ._caec ,TextStyle {Font :_daab ._effad ,FontSize :_daab ._dbcd });
_fffe ,_cfag :=_bgde .Wrap (_daab ._egeg );if _cfag !=nil {return _cfag ;};if _daab ._fgggce > 0&&len (_fffe )> _daab ._fgggce {_fffe =_fffe [:_daab ._fgggce ];};_daab ._ffff =_fffe ;return nil ;};func (_bfc *Invoice )setCellBorder (_fbabb *TableCell ,_bdaag *InvoiceCell ){for _ ,_effcd :=range _bdaag .BorderSides {_fbabb .SetBorder (_effcd ,CellBorderStyleSingle ,_bdaag .BorderWidth );
};_fbabb .SetBorderColor (_bdaag .BorderColor );};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_abc DrawContext )([]*Block ,DrawContext ,error );

// SetMarkedContentID sets the marked content id for the drawable.
SetMarkedContentID (_bcga int64 )*_cb .KDict ;};func (_ffcaf *Table )getLastCellFromCol (_faagga int )(int ,*TableCell ){for _afbfd :=len (_ffcaf ._gcbaa )-1;_afbfd >=0;_afbfd --{if _ffcaf ._gcbaa [_afbfd ]._bgage ==_faagga {return _afbfd ,_ffcaf ._gcbaa [_afbfd ];
};};return 0,nil ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_cggg *Creator )NewImageFromGoImage (goimg _g .Image )(*Image ,error ){return _eccd (goimg )};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_ffag *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_bbgcd :=NewTextChunk (text ,_ffag ._bafbd );_bbgcd .AddAnnotation (_bbca (url ));return _ffag .appendChunk (_bbgcd );};

// Lazy gets the lazy mode for the image.
func (_addbe *Image )Lazy ()bool {return _addbe ._ccefc };

// SetPos sets absolute positioning with specified coordinates.
func (_acef *Paragraph )SetPos (x ,y float64 ){_acef ._fefd =PositionAbsolute ;_acef ._dbcg =x ;_acef ._dgfba =y ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_ccaf :_a .Max (_a .Min (r ,1.0),0.0),_daefg :_a .Max (_a .Min (g ,1.0),0.0),_gafd :_a .Max (_a .Min (b ,1.0),0.0)};};func (_acec *StyledParagraph )split (_gagb DrawContext )(_bfecg ,_defee *StyledParagraph ,_cgfe error ){if _cgfe =_acec .wrapChunks (false );
_cgfe !=nil {return nil ,nil ,_cgfe ;};if len (_acec ._ebbfe )==1&&_acec ._dcag > _gagb .Height {return _acec ,nil ,nil ;};_facdc :=func (_aeag []*TextChunk ,_ggcc []*TextChunk )[]*TextChunk {if len (_ggcc )==0{return _aeag ;};_geecaa :=len (_aeag );if _geecaa ==0{return append (_aeag ,_ggcc ...);
};if _aeag [_geecaa -1].Style ==_ggcc [0].Style {_aeag [_geecaa -1].Text +=_ggcc [0].Text ;}else {_aeag =append (_aeag ,_ggcc [0]);};return append (_aeag ,_ggcc [1:]...);};_ggba :=func (_acfee *StyledParagraph ,_efcg []*TextChunk )*StyledParagraph {if len (_efcg )==0{return nil ;
};_bdbb :=*_acfee ;_bdbb ._eaad =_efcg ;return &_bdbb ;};var (_bdbbf float64 ;_dbed []*TextChunk ;_ggegf []*TextChunk ;);for _ ,_bdcce :=range _acec ._ebbfe {var _cgag float64 ;_bgdda :=make ([]*TextChunk ,0,len (_bdcce ));for _ ,_aecba :=range _bdcce {if _ccfda :=_aecba .Style .FontSize ;
_ccfda > _cgag {_cgag =_ccfda ;};_bgdda =append (_bgdda ,_aecba .clone ());};_cgag *=_acec ._dcag ;if _acec ._fafce .IsRelative (){if _bdbbf +_cgag > _gagb .Height {_ggegf =_facdc (_ggegf ,_bgdda );}else {_dbed =_facdc (_dbed ,_bgdda );};};_bdbbf +=_cgag ;
};_acec ._ebbfe =nil ;if len (_ggegf )==0{return _acec ,nil ,nil ;};return _ggba (_acec ,_dbed ),_ggba (_acec ,_ggegf ),nil ;};func (_ffgg *Table )clone ()*Table {_ccde :=*_ffgg ;_ccde ._begfg =make ([]float64 ,len (_ffgg ._begfg ));copy (_ccde ._begfg ,_ffgg ._begfg );
_ccde ._bcbd =make ([]float64 ,len (_ffgg ._bcbd ));copy (_ccde ._bcbd ,_ffgg ._bcbd );_ccde ._gcbaa =make ([]*TableCell ,0,len (_ffgg ._gcbaa ));for _ ,_fgbae :=range _ffgg ._gcbaa {_bebgc :=*_fgbae ;_bebgc ._cecgbe =&_ccde ;_ccde ._gcbaa =append (_ccde ._gcbaa ,&_bebgc );
};return &_ccde ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dbbg *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _dbbg ._dedbb [0],_dbbg ._dedbb [1]};func (_abaf *TemplateOptions )init (){if _abaf .SubtemplateMap ==nil {_abaf .SubtemplateMap =map[string ]_ad .Reader {};};if _abaf .FontMap ==nil {_abaf .FontMap =map[string ]*_cb .PdfFont {};
};if _abaf .ImageMap ==nil {_abaf .ImageMap =map[string ]*_cb .Image {};};if _abaf .ColorMap ==nil {_abaf .ColorMap =map[string ]Color {};};if _abaf .ChartMap ==nil {_abaf .ChartMap =map[string ]_eb .ChartRenderable {};};};func (_becf *templateProcessor )nodeLogError (_ccfec *templateNode ,_fbfcg string ,_gcgbbf ...interface{}){_gg .Log .Error (_becf .getNodeErrorLocation (_ccfec ,_fbfcg ,_gcgbbf ...));
};func _abad (_eafe string ,_gdee TextStyle )*Paragraph {_eefgg :=&Paragraph {_caec :_eafe ,_effad :_gdee .Font ,_dbcd :_gdee .FontSize ,_ccfga :1.0,_cbca :true ,_cdgge :true ,_bfgaa :TextAlignmentLeft ,_gbagg :0,_afade :1,_fcbd :1,_fefd :PositionRelative ,_adae :""};
_eefgg .SetColor (_gdee .Color );return _eefgg ;};

// SetColorRight sets border color for right.
func (_gef *border )SetColorRight (col Color ){_gef ._ccce =col };

// SetMarkedContentID sets the marked content ID for the paragraph.
func (_becb *StyledParagraph )SetMarkedContentID (mcid int64 )*_cb .KDict {_becb ._eaef =&mcid ;_abcb :=_cb .NewKDictionary ();_abcb .S =_fac .MakeName ("\u0050");_abcb .K =_fac .MakeInteger (mcid );return _abcb ;};func (_daag *Table )moveToNextAvailableCell ()int {_ccdea :=(_daag ._ffec -1)%(_daag ._cfgeg )+1;
for {if _ccdea -1>=len (_daag ._bgddf ){if _daag ._bgddf [0]==0{return _ccdea ;};_ccdea =1;}else if _daag ._bgddf [_ccdea -1]==0{return _ccdea ;};_daag ._ffec ++;_daag ._bgddf [_ccdea -1]--;_ccdea ++;};};

// Reset removes all the text chunks the paragraph contains.
func (_becdc *StyledParagraph )Reset (){_becdc ._eaad =[]*TextChunk {}};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_cfab *TOCLine )SetLink (page int64 ,x ,y float64 ){_cfab ._dgag =x ;_cfab ._beebg =y ;_cfab ._ecffff =page ;_cfae :=_cfab ._gbgfg ._bafbd .Color ;_cfab .Number .Style .Color =_cfae ;_cfab .Title .Style .Color =_cfae ;_cfab .Separator .Style .Color =_cfae ;
_cfab .Page .Style .Color =_cfae ;};func (_gdcea *TextChunk )clone ()*TextChunk {_gaaea :=*_gdcea ;_gaaea ._fegffe =_aacd (_gdcea ._fegffe );return &_gaaea ;};

// SetInline sets the inline mode of the division.
func (_gebf *Division )SetInline (inline bool ){_gebf ._dba =inline };

// CurCol returns the currently active cell's column number.
func (_bccag *Table )CurCol ()int {_gcgaa :=(_bccag ._ffec -1)%(_bccag ._cfgeg )+1;return _gcgaa };

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_gfcd *Division )SetMargins (left ,right ,top ,bottom float64 ){_gfcd ._ccega .Left =left ;_gfcd ._ccega .Right =right ;_gfcd ._ccega .Top =top ;_gfcd ._ccega .Bottom =bottom ;};

// SetMarkedContentID sets the marked content id for the list.
func (_egfbfe *List )SetMarkedContentID (id int64 )*_cb .KDict {return nil };func (_fbge *Ellipse )applyFitMode (_fbaf float64 ){_fbaf -=_fbge ._dede .Left +_fbge ._dede .Right ;switch _fbge ._dddb {case FitModeFillWidth :_fbge .ScaleToWidth (_fbaf );};
};

// SetOpacity sets opacity for Image.
func (_becc *Image )SetOpacity (opacity float64 ){_becc ._gdefg =opacity };func (_cfce *RadialShading )shadingModel ()*_cb .PdfShadingType3 {_aebb ,_gaed ,_ecaad :=_cfce ._bbfaa ._acggc .ToRGB ();var _ddbbf _gga .Point ;switch _cfce ._fadc {case AnchorBottomLeft :_ddbbf =_gga .Point {X :_cfce ._egaff .Llx ,Y :_cfce ._egaff .Lly };
case AnchorBottomRight :_ddbbf =_gga .Point {X :_cfce ._egaff .Urx ,Y :_cfce ._egaff .Ury -_cfce ._egaff .Height ()};case AnchorTopLeft :_ddbbf =_gga .Point {X :_cfce ._egaff .Llx ,Y :_cfce ._egaff .Lly +_cfce ._egaff .Height ()};case AnchorTopRight :_ddbbf =_gga .Point {X :_cfce ._egaff .Urx ,Y :_cfce ._egaff .Ury };
case AnchorLeft :_ddbbf =_gga .Point {X :_cfce ._egaff .Llx ,Y :_cfce ._egaff .Lly +_cfce ._egaff .Height ()/2};case AnchorTop :_ddbbf =_gga .Point {X :_cfce ._egaff .Llx +_cfce ._egaff .Width ()/2,Y :_cfce ._egaff .Ury };case AnchorRight :_ddbbf =_gga .Point {X :_cfce ._egaff .Urx ,Y :_cfce ._egaff .Lly +_cfce ._egaff .Height ()/2};
case AnchorBottom :_ddbbf =_gga .Point {X :_cfce ._egaff .Urx +_cfce ._egaff .Width ()/2,Y :_cfce ._egaff .Lly };default:_ddbbf =_gga .NewPoint (_cfce ._egaff .Llx +_cfce ._egaff .Width ()/2,_cfce ._egaff .Lly +_cfce ._egaff .Height ()/2);};_cbfbg :=_cfce ._efde ;
_ceed :=_cfce ._fgcga ;_ddef :=_ddbbf .X +_cfce ._efbgb ;_edea :=_ddbbf .Y +_cfce ._cged ;if _cbfbg ==-1.0{_cbfbg =0.0;};if _ceed ==-1.0{var _egaa []float64 ;_ffcb :=_a .Pow (_ddef -_cfce ._egaff .Llx ,2)+_a .Pow (_edea -_cfce ._egaff .Lly ,2);_egaa =append (_egaa ,_a .Abs (_ffcb ));
_gbcbd :=_a .Pow (_ddef -_cfce ._egaff .Llx ,2)+_a .Pow (_cfce ._egaff .Lly +_cfce ._egaff .Height ()-_edea ,2);_egaa =append (_egaa ,_a .Abs (_gbcbd ));_gdfdd :=_a .Pow (_cfce ._egaff .Urx -_ddef ,2)+_a .Pow (_edea -_cfce ._egaff .Ury -_cfce ._egaff .Height (),2);
_egaa =append (_egaa ,_a .Abs (_gdfdd ));_bgba :=_a .Pow (_cfce ._egaff .Urx -_ddef ,2)+_a .Pow (_cfce ._egaff .Ury -_edea ,2);_egaa =append (_egaa ,_a .Abs (_bgba ));_ec .Slice (_egaa ,func (_fgeg ,_bgcdg int )bool {return _fgeg > _bgcdg });_ceed =_a .Sqrt (_egaa [0]);
};_eefd :=&_cb .PdfRectangle {Llx :_ddef -_ceed ,Lly :_edea -_ceed ,Urx :_ddef +_ceed ,Ury :_edea +_ceed };_gbge :=_cb .NewPdfShadingType3 ();_gbge .PdfShading .ShadingType =_fac .MakeInteger (3);_gbge .PdfShading .ColorSpace =_cb .NewPdfColorspaceDeviceRGB ();
_gbge .PdfShading .Background =_fac .MakeArrayFromFloats ([]float64 {_aebb ,_gaed ,_ecaad });_gbge .PdfShading .BBox =_eefd ;_gbge .PdfShading .AntiAlias =_fac .MakeBool (_cfce ._bbfaa ._fbada );_gbge .Coords =_fac .MakeArrayFromFloats ([]float64 {_ddef ,_edea ,_cbfbg ,_ddef ,_edea ,_ceed });
_gbge .Domain =_fac .MakeArrayFromFloats ([]float64 {0.0,1.0});_gbge .Extend =_fac .MakeArray (_fac .MakeBool (_cfce ._bbfaa ._aadd [0]),_fac .MakeBool (_cfce ._bbfaa ._aadd [1]));_gbge .Function =_cfce ._bbfaa .generatePdfFunctions ();return _gbge ;};


// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_cdafg *Table )Width ()float64 {return 0};

// AddSection adds a new content section at the end of the invoice.
func (_cgbgb *Invoice )AddSection (title ,content string ){_cgbgb ._cbadd =append (_cgbgb ._cbadd ,[2]string {title ,content });};func (_efe *Creator )getActivePage ()*_cb .PdfPage {if _efe ._fccgc ==nil {if len (_efe ._adce )==0{return nil ;};return _efe ._adce [len (_efe ._adce )-1];
};return _efe ._fccgc ;};

// Color returns the color of the line.
func (_bdbfd *Line )Color ()Color {return _bdbfd ._ccfeb };

// ColorGrayFrom8bit creates a Color from 8-bit (0-255) gray values.
// Example:
//
//	gray := ColorGrayFrom8bit(255, 0, 0)
func ColorGrayFrom8bit (g byte )Color {return grayColor {float64 (g )/255.0}};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};func (_aabf *Division )drawBackground (_dbda []*Block ,_bae ,_gfbc DrawContext ,_fgae bool )([]*Block ,error ){_fecb :=len (_dbda );if _fecb ==0||_aabf ._babba ==nil {return _dbda ,nil ;};_cbgc :=make ([]*Block ,0,len (_dbda ));for _bca ,_dfce :=range _dbda {var (_cacfb =_aabf ._babba .BorderRadiusTopLeft ;
_bbdd =_aabf ._babba .BorderRadiusTopRight ;_dbdc =_aabf ._babba .BorderRadiusBottomLeft ;_aead =_aabf ._babba .BorderRadiusBottomRight ;);_dgcea :=_bae ;_dgcea .Page +=_bca ;if _bca ==0{if _fgae {_cbgc =append (_cbgc ,_dfce );continue ;};if _fecb ==1{_dgcea .Height =_gfbc .Y -_bae .Y ;
};}else {_dgcea .X =_dgcea .Margins .Left +_aabf ._ccega .Left ;_dgcea .Y =_dgcea .Margins .Top ;_dgcea .Width =_dgcea .PageWidth -_dgcea .Margins .Left -_dgcea .Margins .Right -_aabf ._ccega .Left -_aabf ._ccega .Right ;if _bca ==_fecb -1{_dgcea .Height =_gfbc .Y -_dgcea .Margins .Top -_aabf ._ccega .Top ;
}else {_dgcea .Height =_dgcea .PageHeight -_dgcea .Margins .Top -_dgcea .Margins .Bottom ;};if !_fgae {_cacfb =0;_bbdd =0;};};if _fecb > 1&&_bca !=_fecb -1{_dbdc =0;_aead =0;};_ddcd :=_ddbe (_dgcea .X ,_dgcea .Y ,_dgcea .Width ,_dgcea .Height );_ddcd .SetFillColor (_aabf ._babba .FillColor );
_ddcd .SetBorderColor (_aabf ._babba .BorderColor );_ddcd .SetBorderWidth (_aabf ._babba .BorderSize );_ddcd .SetBorderRadius (_cacfb ,_bbdd ,_dbdc ,_aead );_effb ,_ ,_ceae :=_ddcd .GeneratePageBlocks (_dgcea );if _ceae !=nil {return nil ,_ceae ;};if len (_effb )==0{continue ;
};_dagg :=_effb [0];if _ceae =_dagg .mergeBlocks (_dfce );_ceae !=nil {return nil ,_ceae ;};_cbgc =append (_cbgc ,_dagg );};return _cbgc ,nil ;};func (_aedafb *Table )wrapContent (_acddc DrawContext )error {if _aedafb ._cacgg {return nil ;};_aedafb .sortCells ();
_babfd :=func (_dcadg *TableCell ,_ebadc int ,_agee int ,_gdbfc int )(_dffc int ){if _gdbfc < 1{return -1;};_fgbee :=0;for _dgea :=_agee +1;_dgea < len (_aedafb ._gcbaa )-1;_dgea ++{_gccad :=_aedafb ._gcbaa [_dgea ];if _gccad ._gbbed ==_gdbfc &&_fgbee !=_agee {_fgbee =_dgea ;
if (_gccad ._bgage < _dcadg ._bgage &&_aedafb ._cfgeg > _gccad ._bgage )||_dcadg ._bgage < _aedafb ._cfgeg {continue ;};break ;};};_aebfc :=float64 (0.0);for _cgdd :=0;_cgdd < _dcadg ._dfgcc ;_cgdd ++{_aebfc +=_aedafb ._begfg [_dcadg ._gbbed +_cgdd -1];
};_bbdec :=_dcadg .width (_aedafb ._bcbd ,_acddc .Width );var (_ffde VectorDrawable ;_feagd =false ;);switch _gcebb :=_dcadg ._bgfcf .(type ){case *StyledParagraph :_ebeg :=_acddc ;_ebeg .Height =_a .Floor (_aebfc -_gcebb ._dcbc .Top -_gcebb ._dcbc .Bottom -0.5*_gcebb .getTextHeight ());
_ebeg .Width =_bbdec ;_dfedb ,_afdgb ,_ebbdd :=_gcebb .split (_ebeg );if _ebbdd !=nil {_gg .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_ebbdd .Error ());
};if _dfedb !=nil &&_afdgb !=nil {_aedafb ._gcbaa [_agee ]._bgfcf =_dfedb ;_ffde =_afdgb ;_feagd =true ;};};_aedafb ._gcbaa [_agee ]._dfgcc =_dcadg ._dfgcc ;_acddc .Height =_acddc .PageHeight -_acddc .Margins .Top -_acddc .Margins .Bottom ;_efbee :=_dcadg .cloneProps (nil );
if _feagd {_efbee ._bgfcf =_ffde ;};_efbee ._dfgcc =_ebadc ;_efbee ._gbbed =_gdbfc +1;_efbee ._bgage =_dcadg ._bgage ;if _efbee ._gbbed +_efbee ._dfgcc -1> _aedafb ._gagba {for _bcgae :=_aedafb ._gagba ;_bcgae < _efbee ._gbbed +_efbee ._dfgcc -1;_bcgae ++{_aedafb ._gagba ++;
_aedafb ._begfg =append (_aedafb ._begfg ,_aedafb ._dgcc );};};_aedafb ._gcbaa =append (_aedafb ._gcbaa [:_fgbee +1],append ([]*TableCell {_efbee },_aedafb ._gcbaa [_fgbee +1:]...)...);return _fgbee +1;};_deaac :=func (_gcgba *TableCell ,_cbfbdd int ,_ggdee int ,_efbed float64 )(_begc int ){_baada :=_gcgba .width (_aedafb ._bcbd ,_acddc .Width );
_adbf :=_efbed ;_bagge :=1;_ffaa :=_acddc .Height ;if _ffaa > 0{for _adbf > _ffaa {_adbf -=_acddc .Height ;_ffaa =_acddc .PageHeight -_acddc .Margins .Top -_acddc .Margins .Bottom ;_bagge ++;};};var (_bdgbe VectorDrawable ;_ffbeg =false ;);switch _cdgaa :=_gcgba ._bgfcf .(type ){case *StyledParagraph :_aeeff :=_acddc ;
_aeeff .Height =_a .Floor (_acddc .Height -_cdgaa ._dcbc .Top -_cdgaa ._dcbc .Bottom -0.5*_cdgaa .getTextHeight ());_aeeff .Width =_baada ;_cecf ,_degbd ,_gddeca :=_cdgaa .split (_aeeff );if _gddeca !=nil {_gg .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_gddeca .Error ());
};if _cecf !=nil &&_degbd !=nil {_aedafb ._gcbaa [_cbfbdd ]._bgfcf =_cecf ;_bdgbe =_degbd ;_ffbeg =true ;};};if _bagge < 2{return -1;};if _aedafb ._gcbaa [_cbfbdd ]._gbbed +_bagge -1> _aedafb ._gagba {for _ecbcaa :=0;_ecbcaa < _bagge ;_ecbcaa ++{_aedafb ._gagba ++;
_aedafb ._begfg =append (_aedafb ._begfg ,_aedafb ._dgcc );};};_fdgaa :=_efbed /float64 (_bagge );for _dcbde :=0;_dcbde < _bagge ;_dcbde ++{_aedafb ._begfg [_ggdee +_dcbde -1]=_fdgaa ;};_acddc .Height =_acddc .PageHeight -_acddc .Margins .Top -_acddc .Margins .Bottom ;
_cgcg :=_gcgba .cloneProps (nil );if _ffbeg {_cgcg ._bgfcf =_bdgbe ;};_cgcg ._dfgcc =1;_cgcg ._gbbed =_ggdee +_bagge -1;_cgcg ._bgage =_gcgba ._bgage ;_aedafb ._gcbaa =append (_aedafb ._gcbaa ,_cgcg );return len (_aedafb ._gcbaa );};_edccc :=1;_cedg :=-1;
for _acfb :=0;_acfb < len (_aedafb ._gcbaa );_acfb ++{_dffea :=_aedafb ._gcbaa [_acfb ];if _cedg ==_acfb {_edccc =_dffea ._gbbed ;};if _dffea ._dfgcc < 2{if _ffafg :=_aedafb ._begfg [_dffea ._gbbed -1];_ffafg > _acddc .Height {_cedg =_deaac (_dffea ,_acfb ,_dffea ._gbbed ,_ffafg );
continue ;};continue ;};_bgebd :=float64 (0);for _bfba :=0;_bfba < _dffea ._dfgcc ;_bfba ++{_bgebd +=_aedafb ._begfg [_dffea ._gbbed +_bfba -1];};_daebg :=float64 (0);for _dgbec :=_edccc -1;_dgbec < _dffea ._gbbed -1;_dgbec ++{_daebg +=_aedafb ._begfg [_dgbec ];
};if _bgebd <=(_acddc .Height -_daebg ){continue ;};_cbfgf :=float64 (0.0);_dbfge :=_dffea ._dfgcc ;_dbdd :=-1;_acfd :=1;for _fggge :=1;_fggge <=_dffea ._dfgcc ;_fggge ++{if (_cbfgf +_aedafb ._begfg [_dffea ._gbbed +_fggge -2])> (_acddc .Height -_daebg ){_acfd --;
break ;};_dbdd =_dffea ._gbbed +_fggge -1;_dbfge =_dffea ._dfgcc -_fggge ;_cbfgf +=_aedafb ._begfg [_dffea ._gbbed +_fggge -2];_acfd ++;};if _dffea ._dfgcc ==_dbfge {_acddc .Height =_acddc .PageHeight -_acddc .Margins .Top -_acddc .Margins .Bottom ;_edccc =_dffea ._gbbed ;
_acfb --;continue ;};if _dbfge > 0&&_dffea ._dfgcc > _acfd {_dffea ._dfgcc =_acfd ;_cedg =_babfd (_dffea ,_dbfge ,_acfb ,_dbdd );if _acfb +1==_cedg {_acfb --;};};_edccc =_dffea ._gbbed ;};_aedafb .sortCells ();return nil ;};func _gedd (_fag ,_dfab ,_acc ,_dfb float64 )*border {_baa :=&border {};
_baa ._bbe =_fag ;_baa ._efgd =_dfab ;_baa ._dfa =_acc ;_baa ._cagd =_dfb ;_baa ._feeb =ColorBlack ;_baa ._ddc =ColorBlack ;_baa ._gfc =ColorBlack ;_baa ._ccce =ColorBlack ;_baa ._ddb =0;_baa ._dab =0;_baa ._bfdb =0;_baa ._gaeb =0;_baa ._gcgf =1.0;_baa .LineStyle =_gga .LineStyleSolid ;
return _baa ;};func (_gcee rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _gcee ._ccaf ,_gcee ._daefg ,_gcee ._gafd ;};

// SetMarkedContentID sets marked content ID.
func (_debd *Invoice )SetMarkedContentID (id int64 )*_cb .KDict {return nil };

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_adce []*_cb .PdfPage ;_cgaf map[*_cb .PdfPage ]*Block ;_ebgc map[*_cb .PdfPage ]*pageTransformations ;_fccgc *_cb .PdfPage ;_bbfg PageSize ;_fdec DrawContext ;_bea Margins ;_eegg ,_bfbc float64 ;_aedd int ;_afdf func (_gdb FrontpageFunctionArgs );
_gegg func (_gccc *TOC )error ;_gcge func (_cgbgf *Block ,_cbg HeaderFunctionArgs );_egf func (_agab *Block ,_dbce FooterFunctionArgs );_cdg func (_gceg PageFinalizeFunctionArgs )error ;_cacf func (_gdbd *_cb .PdfWriter )error ;_ecae bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_fbc *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gbcd *_cb .Outline ;_ffba *_cb .PdfOutlineTreeNode ;_daaa *_cb .PdfAcroForm ;_eea _fac .PdfObject ;_ggda _cb .Optimizer ;_ecfg []*_cb .PdfFont ;_ebd *_cb .PdfFont ;_fgcgd *_cb .PdfFont ;_daae *_cb .StructTreeRoot ;_dcefd *_cb .ViewerPreferences ;
_egfb string ;};type Grid struct{_eedbe int ;_ggcd []float64 ;_acdc float64 ;_decb Positioning ;_cbgba ,_dgffa float64 ;_cacfg Margins ;_bded []*GridRow ;};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_add *Creator )SetOutlineTree (outlineTree *_cb .PdfOutlineTreeNode ){_add ._ffba =outlineTree };

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_cbag *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cbag ._dege .Left ,_cbag ._dege .Right ,_cbag ._dege .Top ,_cbag ._dege .Bottom ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//
//	red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_gaec :_a .Min (float64 (c ),100)/100.0,_ceeb :_a .Min (float64 (m ),100)/100.0,_adfa :_a .Min (float64 (y ),100)/100.0,_deae :_a .Min (float64 (k ),100)/100.0};};

// IsAbsolute checks if the positioning is absolute.
func (_dagb Positioning )IsAbsolute ()bool {return _dagb ==PositionAbsolute };func _gcff (_bdgaff int )*Grid {_cec :=&Grid {_eedbe :_bdgaff ,_acdc :10.0,_ggcd :[]float64 {}};_cec .resetColumnWidths ();return _cec ;};

// RotatedSize returns the width and height of the rotated block.
func (_ef *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_ge ,_eg :=_ebebb (_ef ._db ,_ef ._ecf ,_ef ._ccb );return _ge ,_eg ;};

// SetFont sets the font for the paragraph.
func (_egdba *StyledParagraph )SetFont (font *_cb .PdfFont ){_egdba ._eeaba .Font =font ;for _ ,_ccacc :=range _egdba ._eaad {_ccacc .Style .Font =font ;};};func (_cccd *InvoiceAddress )fmtLine (_fccfd ,_faddb string ,_begeaf bool )string {if _begeaf {_faddb ="";
};return _d .Sprintf ("\u0025\u0073\u0025s\u000a",_faddb ,_fccfd );};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);
ColorYellow =ColorRGBFromArithmetic (1,1,0););

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_eabe *Creator )MoveDown (dy float64 ){_eabe ._fdec .Y +=dy };func _gbbc (_abfg string )(*Image ,error ){_decbd ,_gdgb :=_b .Open (_abfg );if _gdgb !=nil {return nil ,_gdgb ;};defer _decbd .Close ();_dcfb ,_gdgb :=_cb .ImageHandling .Read (_decbd );
if _gdgb !=nil {_gg .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gdgb );return nil ,_gdgb ;};return _bff (_dcfb );};func (_afggg *templateProcessor )parseRectangle (_dbcfd *templateNode )(interface{},error ){_fegc :=_afggg .creator .NewRectangle (0,0,0,0);
for _ ,_aabcc :=range _dbcfd ._bcdgfa .Attr {_dafeb :=_aabcc .Value ;switch _ggfdf :=_aabcc .Name .Local ;_ggfdf {case "\u0078":_fegc ._gbaf =_afggg .parseFloatAttr (_ggfdf ,_dafeb );case "\u0079":_fegc ._gcfge =_afggg .parseFloatAttr (_ggfdf ,_dafeb );
case "\u0077\u0069\u0064t\u0068":_fegc .SetWidth (_afggg .parseFloatAttr (_ggfdf ,_dafeb ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_fegc .SetHeight (_afggg .parseFloatAttr (_ggfdf ,_dafeb ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_fegc .SetFillColor (_afggg .parseColorAttr (_ggfdf ,_dafeb ));
case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_fegc .SetFillOpacity (_afggg .parseFloatAttr (_ggfdf ,_dafeb ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_fegc .SetBorderColor (_afggg .parseColorAttr (_ggfdf ,_dafeb ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_fegc .SetBorderOpacity (_afggg .parseFloatAttr (_ggfdf ,_dafeb ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_fegc .SetBorderWidth (_afggg .parseFloatAttr (_ggfdf ,_dafeb ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_gfbf ,_bbbce ,_adfdaa ,_bfdbee :=_afggg .parseBorderRadiusAttr (_ggfdf ,_dafeb );_fegc .SetBorderRadius (_gfbf ,_bbbce ,_bfdbee ,_adfdaa );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_fegc ._ddce =_afggg .parseFloatAttr (_ggfdf ,_dafeb );
case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_fegc ._fbbee =_afggg .parseFloatAttr (_ggfdf ,_dafeb );case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_fegc ._cffgb =_afggg .parseFloatAttr (_ggfdf ,_dafeb );
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_fegc ._ggfa =_afggg .parseFloatAttr (_ggfdf ,_dafeb );case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_fegc .SetPositioning (_afggg .parsePositioningAttr (_ggfdf ,_dafeb ));
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_fegc .SetFitMode (_afggg .parseFitModeAttr (_ggfdf ,_dafeb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_bbgcb :=_afggg .parseMarginAttr (_ggfdf ,_dafeb );_fegc .SetMargins (_bbgcb .Left ,_bbgcb .Right ,_bbgcb .Top ,_bbgcb .Bottom );
default:_afggg .nodeLogDebug (_dbcfd ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_ggfdf );
};};return _fegc ,nil ;};

// SetMarkedContentID sets marked content ID.
func (_efba *Polyline )SetMarkedContentID (mcid int64 )*_cb .KDict {_efba ._fbabe =&mcid ;_agcdg :=_cb .NewKDictionary ();_agcdg .S =_fac .MakeName (_cb .StructureTypeFigure );_agcdg .K =_fac .MakeInteger (mcid );return _agcdg ;};

// SetViewerPreferences sets the viewer preferences for the PDF document.
func (_bdf *Creator )SetViewerPreferences (viewerPreferences *_cb .ViewerPreferences ){_bdf ._dcefd =viewerPreferences ;};

// NewCellProps returns the default properties of an invoice cell.
func (_gcfc *Invoice )NewCellProps ()InvoiceCellProps {_ddadg :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_gcfc ._dfae ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_ddadg ,BorderColor :_ddadg ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_fbea *RadialShading )SetAntiAlias (enable bool ){_fbea ._bbfaa .SetAntiAlias (enable )};func _cceed (_egae string )(*Path ,error ){_dbdfb =_bdegd ();_affdb ,_cgeae :=_fabc (_affd (_egae ));if _cgeae !=nil {return nil ,_cgeae ;};return _gceeg (_affdb ),nil ;
};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_bdb *Creator )SetForms (form *_cb .PdfAcroForm )error {_bdb ._daaa =form ;return nil };

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_gcbc *Division )Height ()float64 {var _afde float64 ;for _ ,_abeg :=range _gcbc ._dbfd {switch _fdab :=_abeg .(type ){case marginDrawable :_ ,_ ,_aeef ,_fdae :=_fdab .GetMargins ();_afde +=_fdab .Height ()+_aeef +_fdae ;default:_afde +=_fdab .Height ();
};};return _afde ;};func (_adba *templateProcessor )loadImageFromSrc (_dcfd string )(*Image ,error ){if _dcfd ==""{_gg .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_efgag ;};_ddeg :=_bd .Split (_dcfd ,"\u002c");for _ ,_eaade :=range _ddeg {_eaade =_bd .TrimSpace (_eaade );if _eaade ==""{continue ;};_cccba ,_degcg :=_adba ._debae .ImageMap [_eaade ];if _degcg {return _bff (_cccba );};if _ffbge :=_adba .parseAttrPropList (_eaade );
len (_ffbge )> 0{if _adeef ,_dgggd :=_ffbge ["\u0070\u0061\u0074\u0068"];_dgggd {if _egdg ,_ebgdf :=_gbbc (_adeef );_ebgdf !=nil {_gg .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_adeef ,_ebgdf );
}else {return _egdg ,nil ;};};};};_gg .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_dcfd );return nil ,_efgag ;};func _gbcbe (_aeeec *templateProcessor ,_gfece *templateNode )(interface{},error ){return _aeeec .parseBackground (_gfece );
};

// Positioning returns the type of positioning the line is set to use.
func (_ccga *Line )Positioning ()Positioning {return _ccga ._fcfa };func (_gbf *Block )transform (_beb _gb .Matrix ){_gde :=_ae .NewContentCreator ().Add_cm (_beb [0],_beb [1],_beb [3],_beb [4],_beb [6],_beb [7]).Operations ();*_gbf ._fd =append (*_gde ,*_gbf ._fd ...);
_gbf ._fd .WrapIfNeeded ();};

// GraphicSVGElement represents SVG instances.
type GraphicSVGElement struct{

// ViewBox represents viewBox value of element.
ViewBox struct{X ,Y ,W ,H float64 ;};

// Name of element.
Name string ;

// Attributes of element.
Attributes map[string ]string ;

// Children elements.
Children []*GraphicSVGElement ;

// Content contains text value of element.
Content string ;

// Style element style attribute.
Style *GraphicSVGStyle ;

// Width of element.
Width float64 ;

// Height of element.
Height float64 ;_dfgb float64 ;_decf map[string ]*LinearShading ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_fadd *Creator )DrawTemplate (r _ad .Reader ,data interface{},options *TemplateOptions )error {return _dbccd (_fadd ,r ,data ,options ,_fadd );};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;
);

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_gbaf float64 ;_gcfge float64 ;_ggcb float64 ;_baadd float64 ;_fdfc Positioning ;_ecbc Color ;_abeed float64 ;_edcc Color ;_afefe float64 ;_fbfee float64 ;_ddce float64 ;_fbbee float64 ;_cffgb float64 ;_ggfa float64 ;_gdea Margins ;
_bdde FitMode ;_gfeca *int64 ;};

// SetBorder sets the cell's border style.
func (_fbbae *GridCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_fbbae ._afbbd =CellBorderStyleSingle ;_fbbae ._dbaa =width ;_fbbae ._gbgf =CellBorderStyleSingle ;
_fbbae ._bgge =width ;_fbbae ._aded =CellBorderStyleSingle ;_fbbae ._aegc =width ;_fbbae ._adcea =CellBorderStyleSingle ;_fbbae ._adbe =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_fbbae ._afbbd =CellBorderStyleDouble ;_fbbae ._dbaa =width ;
_fbbae ._gbgf =CellBorderStyleDouble ;_fbbae ._bgge =width ;_fbbae ._aded =CellBorderStyleDouble ;_fbbae ._aegc =width ;_fbbae ._adcea =CellBorderStyleDouble ;_fbbae ._adbe =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_fbbae ._afbbd =style ;
_fbbae ._dbaa =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_fbbae ._gbgf =style ;_fbbae ._bgge =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_fbbae ._aded =style ;
_fbbae ._aegc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_fbbae ._adcea =style ;_fbbae ._adbe =width ;};};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_ffcc *Invoice )Sections ()[][2]string {return _ffcc ._cbadd };

// SetMarkedContentID sets marked content ID.
func (_ggggg *TOC )SetMarkedContentID (mcid int64 )*_cb .KDict {return nil };

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dabcd *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _dabcd ._agdaf [0],_dabcd ._agdaf [1];};

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_agde *GraphicSVG )ScaleToWidth (w float64 ){_egdd :=_agde ._bggb .Height /_agde ._bggb .Width ;_agde ._bggb .Width =w ;_agde ._bggb .Height =w *_egdd ;_agde ._bggb .SetScaling (_egdd ,_egdd );};func (_gfccb *pageTransformations )transformBlock (_dfgc *Block ){if _gfccb ._eeec !=nil {_dfgc .transform (*_gfccb ._eeec );
};};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_fbgge *List )Marker ()*TextChunk {return &_fbgge ._gbaeb };const (DefaultHorizontalScaling =100;);

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_bcabbd *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_bcabbd .Text },nil ;};var _cgcfb []string ;var _dcdbd []rune ;var _abbgf float64 ;var _fgccc []float64 ;_ddggb :=_bcabbd .Style ;_ddcbf :=_aeacg (_bcabbd .Text );
for _ ,_abfdb :=range _bcabbd .Text {if _abfdb =='\u000A'{_dgbee :=_bbgbc (string (_dcdbd ),_ddcbf );_cgcfb =append (_cgcfb ,_bd .TrimRightFunc (_dgbee ,_eef .IsSpace )+string (_abfdb ));_dcdbd =nil ;_abbgf =0;_fgccc =nil ;continue ;};_cbeeb :=_abfdb ==' ';
_addcc ,_ggead :=_ddggb .Font .GetRuneMetrics (_abfdb );if !_ggead {_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_abfdb ,_abfdb ,_ddggb .Font .BaseFont (),_ddggb .Font .Subtype ());
_gg .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_ddggb .Font );_gg .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_ddggb .Font .Encoder ());return nil ,_ff .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_degbgb :=_ddggb .FontSize *_addcc .Wx ;_defgg :=_degbgb ;if !_cbeeb {_defgg =_degbgb +_ddggb .CharSpacing *1000.0;};if _abbgf +_degbgb > width *1000.0{_bfag :=-1;if !_cbeeb {for _edbab :=len (_dcdbd )-1;_edbab >=0;_edbab --{if _dcdbd [_edbab ]==' '{_bfag =_edbab ;
break ;};};};_bdeca :=string (_dcdbd );if _bfag > 0{_bdeca =string (_dcdbd [0:_bfag +1]);_dcdbd =append (_dcdbd [_bfag +1:],_abfdb );_fgccc =append (_fgccc [_bfag +1:],_defgg );_abbgf =0;for _ ,_aaega :=range _fgccc {_abbgf +=_aaega ;};}else {if _cbeeb {_dcdbd =[]rune {};
_fgccc =[]float64 {};_abbgf =0;}else {_dcdbd =[]rune {_abfdb };_fgccc =[]float64 {_defgg };_abbgf =_defgg ;};};_bdeca =_bbgbc (_bdeca ,_ddcbf );_cgcfb =append (_cgcfb ,_bd .TrimRightFunc (_bdeca ,_eef .IsSpace ));}else {_dcdbd =append (_dcdbd ,_abfdb );
_abbgf +=_defgg ;_fgccc =append (_fgccc ,_defgg );};};if len (_dcdbd )> 0{_bddee :=string (_dcdbd );_bddee =_bbgbc (_bddee ,_ddcbf );_cgcfb =append (_cgcfb ,_bddee );};return _cgcfb ,nil ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_egce *TOC )SetLineNumberStyle (style TextStyle ){_egce ._ccgabc =style };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_bffdd *TOC )SetLineSeparatorStyle (style TextStyle ){_bffdd ._befec =style };func _agae (_fdcb float64 ,_cdfgd float64 ,_afabe float64 ,_eegc float64 ,_aaeg []*ColorPoint )*RadialShading {return &RadialShading {_bbfaa :&shading {_acggc :ColorWhite ,_fbada :false ,_aadd :[]bool {false ,false },_bcbgf :_aaeg },_efbgb :_fdcb ,_cged :_cdfgd ,_efde :_afabe ,_fgcga :_eegc ,_fadc :AnchorCenter };
};type componentRenderer interface{Draw (_gfbd Drawable )error ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_aeec *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _aeec ._feba .Left ,_aeec ._feba .Right ,_aeec ._feba .Top ,_aeec ._feba .Bottom ;};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_degg _eb .ChartRenderable ;_cbbd Positioning ;_dfbd float64 ;_fae float64 ;_dege Margins ;_ebb *int64 ;};

// SetOpacity sets the cell's opacity in the range 0-1.
func (_abab *GridCell )SetOpacity (opacity float64 ){_abab ._agefe =opacity };

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_gfb *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_gfb ._fbc =toc ;};func (_cfdcc *Table )sortCells (){_ec .Slice (_cfdcc ._gcbaa ,func (_dffee ,_bcdb int )bool {_dfebe :=_cfdcc ._gcbaa [_dffee ]._gbbed ;_bfff :=_cfdcc ._gcbaa [_bcdb ]._gbbed ;
if _dfebe < _bfff {return true ;};if _dfebe > _bfff {return false ;};return _cfdcc ._gcbaa [_dffee ]._bgage < _cfdcc ._gcbaa [_bcdb ]._bgage ;});};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_dagce *TOC )SetLinePageStyle (style TextStyle ){_dagce ._cebfa =style };

// SetAngle sets the rotation angle of the text.
func (_fbece *Paragraph )SetAngle (angle float64 ){_fbece ._gbagg =angle };

// SetWidthBottom sets border width for bottom.
func (_gbe *border )SetWidthBottom (bw float64 ){_gbe ._dab =bw };func (_beegd *templateProcessor )parseFloatAttr (_abaa ,_cbdfd string )float64 {_gg .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_abaa ,_cbdfd );
_bfddc ,_ :=_fa .ParseFloat (_cbdfd ,64);return _bfddc ;};

// NewInvoice returns an instance of an empty invoice.
func (_aceb *Creator )NewInvoice ()*Invoice {_bcdc :=_aceb .NewTextStyle ();_bcdc .Font =_aceb ._fgcgd ;return _cgba (_aceb .NewTextStyle (),_bcdc );};type templateNode struct{_dadec interface{};_bcdgfa _cd .StartElement ;_bedad *templateNode ;_acfbc int ;
_ecddb int ;_eecg int64 ;};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_eagaa *Line )SetColor (color Color ){_eagaa ._ccfeb =color };

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_gbgfg *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_bdfbfc float64 ;_gfga uint ;_ceacd float64 ;_debaf Positioning ;_dgag float64 ;_beebg float64 ;_ecffff int64 ;};func _feffb (_bfdcc string )(float64 ,error ){_bfdcc =_bd .TrimSpace (_bfdcc );var _bece float64 ;if _bd .HasSuffix (_bfdcc ,"\u0025"){_daaaa ,_ebagc :=_fa .ParseFloat (_bd .TrimSuffix (_bfdcc ,"\u0025"),64);
if _ebagc !=nil {return 0,_ebagc ;};_bece =(_daaaa *255.0)/100.0;}else {_bfeg ,_afag :=_fa .Atoi (_bfdcc );if _afag !=nil {return 0,_afag ;};_bece =float64 (_bfeg );};return _bece ,nil ;};

// SetAngle sets the rotation angle in degrees.
func (_eae *Block )SetAngle (angleDeg float64 ){_eae ._ccb =angleDeg };

// SetScaling sets scaling value for graphic SVG and maintain the aspect ratio.
func (_bgfa *GraphicSVGElement )SetScaling (xFactor ,yFactor float64 ){_fdfd :=_bgfa .Width /_bgfa .ViewBox .W ;_ecdc :=_bgfa .Height /_bgfa .ViewBox .H ;_bgfa .setDefaultScaling (_a .Max (_fdfd ,_ecdc ));for _ ,_aede :=range _bgfa .Children {_aede .SetScaling (xFactor ,yFactor );
};};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_dage *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_acegb []*Block ;_dggb bool ;_fgge error ;_cbceg =_dage ._dadf .IsRelative ();_acfe =_dage ._ccega .Top ;);if _cbceg &&!_dage ._gccg &&!_dage ._dba {_bcec :=_dage .ctxHeight (ctx .Width );
if _bcec > ctx .Height -_dage ._ccega .Top &&_bcec <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _acegb ,ctx ,_fgge =_bbbe ().GeneratePageBlocks (ctx );_fgge !=nil {return nil ,ctx ,_fgge ;};_dggb =true ;_acfe =0;};};_efaf :=ctx ;_cfd :=ctx ;
if _cbceg {ctx .X +=_dage ._ccega .Left ;ctx .Y +=_acfe ;ctx .Width -=_dage ._ccega .Left +_dage ._ccega .Right ;ctx .Height -=_acfe ;_cfd =ctx ;ctx .X +=_dage ._cacg .Left ;ctx .Y +=_dage ._cacg .Top ;ctx .Width -=_dage ._cacg .Left +_dage ._cacg .Right ;
ctx .Height -=_dage ._cacg .Top ;ctx .Margins .Top +=_dage ._cacg .Top ;ctx .Margins .Bottom +=_dage ._cacg .Bottom ;ctx .Margins .Left +=_dage ._ccega .Left +_dage ._cacg .Left ;ctx .Margins .Right +=_dage ._ccega .Right +_dage ._cacg .Right ;};ctx .Inline =_dage ._dba ;
_gfbb :=ctx ;_ccaa :=ctx ;var _fcce float64 ;for _ ,_gece :=range _dage ._dbfd {if ctx .Inline {if (ctx .X -_gfbb .X )+_gece .Width ()<=ctx .Width {ctx .Y =_ccaa .Y ;ctx .Height =_ccaa .Height ;}else {ctx .X =_gfbb .X ;ctx .Width =_gfbb .Width ;_ccaa .Y +=_fcce ;
_ccaa .Height -=_fcce ;_fcce =0;};};_cebc ,_gffe ,_eeea :=_gece .GeneratePageBlocks (ctx );if _eeea !=nil {_gg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_eeea );
return nil ,ctx ,_eeea ;};if len (_cebc )< 1{continue ;};if len (_acegb )> 0{_acegb [len (_acegb )-1].mergeBlocks (_cebc [0]);_acegb =append (_acegb ,_cebc [1:]...);}else {if _cagc :=_cebc [0]._fd ;_cagc ==nil ||len (*_cagc )==0{_dggb =true ;};_acegb =append (_acegb ,_cebc [0:]...);
};_eeef :=0.0;switch _acce :=_gece .(type ){case *Paragraph :_eeef =(0.5*_acce ._dbcd *_acce ._ccfga );case *StyledParagraph :_eeef =(0.5*_acce .getTextHeight ());};_gffe .Y +=_eeef ;_gffe .Height -=_eeef ;if ctx .Inline {if ctx .Page !=_gffe .Page {_gfbb .Y =ctx .Margins .Top ;
_gfbb .Height =ctx .PageHeight -ctx .Margins .Top ;_ccaa .Y =_gfbb .Y ;_ccaa .Height =_gfbb .Height ;_fcce =_gffe .Height -_gfbb .Height ;}else {if _bgda :=ctx .Height -_gffe .Height ;_bgda > _fcce {_fcce =_bgda ;};};}else {_gffe .X =ctx .X ;};ctx =_gffe ;
};if len (_dage ._dbfd )==0{_gbfd :=NewBlock (ctx .Width ,0);_acegb =append (_acegb ,_gbfd );};ctx .Inline =_efaf .Inline ;ctx .Margins =_efaf .Margins ;if _cbceg {ctx .X =_efaf .X ;ctx .Width =_efaf .Width ;ctx .Y +=_dage ._cacg .Bottom ;ctx .Height -=_dage ._cacg .Bottom ;
};if _dage ._babba !=nil {_acegb ,_fgge =_dage .drawBackground (_acegb ,_cfd ,ctx ,_dggb );if _fgge !=nil {return nil ,ctx ,_fgge ;};};if _dage ._dadf .IsAbsolute (){return _acegb ,_efaf ,nil ;};ctx .Y +=_dage ._ccega .Bottom ;ctx .Height -=_dage ._ccega .Bottom ;
return _acegb ,ctx ,nil ;};

// SetSideBorderWidth sets the cell's side border width.
func (_bggba *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_bggba ._cdaeb =width ;_bggba ._aeefb =width ;_bggba ._acdbg =width ;_bggba ._eecfd =width ;case CellBorderSideTop :_bggba ._cdaeb =width ;
case CellBorderSideBottom :_bggba ._aeefb =width ;case CellBorderSideLeft :_bggba ._acdbg =width ;case CellBorderSideRight :_bggba ._eecfd =width ;};};func (_cbae *templateProcessor )parseImageEncoder (_egcc ,_dgdeg string )_fac .StreamEncoder {_gg .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074e\u003a\u0020\u0028\u0060\u0025s\u0060\u002c \u0025\u0073\u0029\u002e",_egcc ,_dgdeg );
if _dgdeg =="\u0066\u006c\u0061t\u0065"{return _fac .NewFlateEncoder ();}else if _dgdeg =="\u0064\u0063\u0074"{return _fac .NewDCTEncoder ();};_gg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0076\u0061\u006cu\u0065\u0020\u006f\u0066 \u0065\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u0020\u0066\u006f\u0075\u006e\u0064\u002e",_egcc ,_dgdeg );
return nil ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_fd *_ae .ContentStreamOperations ;_bg *_cb .PdfPageResources ;_fdg Positioning ;_gbb ,_gbg float64 ;_db float64 ;_ecf float64 ;_ccb float64 ;_afg Margins ;_ed []*_cb .PdfAnnotation ;};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_bebd *Chart )SetPos (x ,y float64 ){_bebd ._cbbd =PositionAbsolute ;_bebd ._dfbd =x ;_bebd ._fae =y ;};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_dedg *Rectangle )Height ()float64 {return _dedg ._baadd };

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_fcag *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_fcag ._dede .Left =left ;_fcag ._dede .Right =right ;_fcag ._dede .Top =top ;_fcag ._dede .Bottom =bottom ;};func (_degbg *LinearShading )shadingModel ()*_cb .PdfShadingType2 {_cbfcb :=_gga .NewPoint (_degbg ._bcfdf .Llx +_degbg ._bcfdf .Width ()/2,_degbg ._bcfdf .Lly +_degbg ._bcfdf .Height ()/2);
_abdbb :=_gga .NewPoint (_degbg ._bcfdf .Llx ,_degbg ._bcfdf .Lly +_degbg ._bcfdf .Height ()/2).Add (-_cbfcb .X ,-_cbfcb .Y ).Rotate (_degbg ._bgcff ).Add (_cbfcb .X ,_cbfcb .Y );_abdbb =_gga .NewPoint (_a .Max (_a .Min (_abdbb .X ,_degbg ._bcfdf .Urx ),_degbg ._bcfdf .Llx ),_a .Max (_a .Min (_abdbb .Y ,_degbg ._bcfdf .Ury ),_degbg ._bcfdf .Lly ));
_cfggd :=_gga .NewPoint (_degbg ._bcfdf .Urx ,_degbg ._bcfdf .Lly +_degbg ._bcfdf .Height ()/2).Add (-_cbfcb .X ,-_cbfcb .Y ).Rotate (_degbg ._bgcff ).Add (_cbfcb .X ,_cbfcb .Y );_cfggd =_gga .NewPoint (_a .Min (_a .Max (_cfggd .X ,_degbg ._bcfdf .Llx ),_degbg ._bcfdf .Urx ),_a .Min (_a .Max (_cfggd .Y ,_degbg ._bcfdf .Lly ),_degbg ._bcfdf .Ury ));
_aeae :=_cb .NewPdfShadingType2 ();_aeae .PdfShading .ShadingType =_fac .MakeInteger (2);_aeae .PdfShading .ColorSpace =_cb .NewPdfColorspaceDeviceRGB ();_aeae .PdfShading .AntiAlias =_fac .MakeBool (_degbg ._fafde ._fbada );_aeae .Coords =_fac .MakeArrayFromFloats ([]float64 {_abdbb .X ,_abdbb .Y ,_cfggd .X ,_cfggd .Y });
_aeae .Extend =_fac .MakeArray (_fac .MakeBool (_degbg ._fafde ._aadd [0]),_fac .MakeBool (_degbg ._fafde ._aadd [1]));_aeae .Function =_degbg ._fafde .generatePdfFunctions ();return _aeae ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_eeggg *Creator )DrawHeader (drawHeaderFunc func (_cgab *Block ,_efbf HeaderFunctionArgs )){_eeggg ._gcge =drawHeaderFunc ;};func _fgace (_dagggg *templateProcessor ,_acbcb *templateNode )(interface{},error ){return _dagggg .parseListMarker (_acbcb );
};func _efcad (_edggg *templateProcessor ,_fagdg *templateNode )(interface{},error ){return _edggg .parseTableCell (_fagdg );};func _bcdfgc (_gdgdd string )([]string ,error ){if !_f .ValidString (_gdgdd ){return []string {_gdgdd },_ff .New ("\u0069n\u0070\u0075\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020v\u0061\u006c\u0069\u0064\u0020\u0055\u0054\u0046\u002d\u0038");
};var (_bdcaa []string ;_becdb []rune ;);for _ ,_afbe :=range _gdgdd {if _afbe =='\u000A'{if len (_becdb )> 0{_bdcaa =append (_bdcaa ,string (_becdb ));};_bdcaa =append (_bdcaa ,string (_afbe ));_becdb =nil ;continue ;};_becdb =append (_becdb ,_afbe );
};if len (_becdb )> 0{_bdcaa =append (_bdcaa ,string (_becdb ));};var _dagbc []string ;for _ ,_fggf :=range _bdcaa {_effg :=[]rune (_fggf );_acfbg :=_ab .NewScanner (_effg );var _ececc []rune ;for _aedba :=0;_aedba < len (_effg );_aedba ++{_ ,_ddagf ,_aecfd :=_acfbg .Next ();
if _aecfd !=nil {return nil ,_aecfd ;};if _ddagf ==_ab .BreakProhibited ||_eef .IsSpace (_effg [_aedba ]){_ececc =append (_ececc ,_effg [_aedba ]);if _eef .IsSpace (_effg [_aedba ]){_dagbc =append (_dagbc ,string (_ececc ));_ececc =[]rune {};};continue ;
}else {if len (_ececc )> 0{_dagbc =append (_dagbc ,string (_ececc ));};_ececc =[]rune {_effg [_aedba ]};};};if len (_ececc )> 0{_dagbc =append (_dagbc ,string (_ececc ));};};return _dagbc ,nil ;};

// ClearAnnotations clears any existing annotations.
func (_gbgd *TextChunk )ClearAnnotations (){_gbgd ._fegffe =[]*_cb .PdfAnnotation {}};

// AddLine appends a new line to the invoice line items table.
func (_baca *Invoice )AddLine (values ...string )[]*InvoiceCell {_ecdd :=len (_baca ._cefb );var _bgfcd []*InvoiceCell ;for _efgf ,_ccdbb :=range values {_ggeg :=_baca .newCell (_ccdbb ,_baca ._ggaea );if _efgf < _ecdd {_ggeg .Alignment =_baca ._cefb [_efgf ].Alignment ;
};_bgfcd =append (_bgfcd ,_ggeg );};_baca ._daeag =append (_baca ._daeag ,_bgfcd );return _bgfcd ;};var _eeb =_gd .MustCompile ("\u005c\u0064\u002b");

// SetStyle sets the style of the line (solid or dashed).
func (_accc *Line )SetStyle (style _gga .LineStyle ){_accc ._gcege =style };

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_cbgd *Image )ConvertToBinary ()error {return _cbgd ._bgeac .ConvertToBinary ()};

// Crop crops the Image to the specified bounds.
func (_dggec *Image )Crop (x0 ,y0 ,x1 ,y1 int ){_fddd ,_bfde :=_dggec ._bgeac .ToGoImage ();if _bfde !=nil {_ee .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0074o\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_bfde );
};var _ebgd _g .Image ;_ffgag :=_g .Rect (x0 ,y0 ,x1 ,y1 );if _dfbf :=_ffgag .Intersect (_fddd .Bounds ());!_ffgag .Empty (){_bffc :=_g .NewRGBA (_g .Rect (0,0,_ffgag .Dx (),_ffgag .Dy ()));for _fafc :=_dfbf .Min .Y ;_fafc < _dfbf .Max .Y ;_fafc ++{for _dgfcb :=_dfbf .Min .X ;
_dgfcb < _dfbf .Max .X ;_dgfcb ++{_bffc .Set (_dgfcb -_dfbf .Min .X ,_fafc -_dfbf .Min .Y ,_fddd .At (_dgfcb ,_fafc ));};};_ebgd =_bffc ;}else {_ebgd =&_g .RGBA {};};_gdgf ,_bfde :=_cb .ImageHandling .NewImageFromGoImage (_ebgd );if _bfde !=nil {_ee .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0066\u0072\u006fm\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_bfde );
};_efbe :=float64 (_gdgf .Width );_deaf :=float64 (_gdgf .Height );_dggec ._bgeac =_gdgf ;_dggec ._ddcae =_efbe ;_dggec ._decbc =_deaf ;_dggec ._efca =_efbe ;_dggec ._efag =_deaf ;};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_egcb *TOC )SetLineTitleStyle (style TextStyle ){_egcb ._aaeac =style };func (_dddcg *GraphicSVGElement )drawText (_gbecg *_ae .ContentCreator ,_cacdd *_cb .PdfPageResources ){_gbecg .Add_BT ();_bbde ,_effff :=_cdadb (_dddcg .Attributes ["\u0078"],64);
if _effff !=nil {_gg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0078\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_effff .Error ());};_gfeee ,_effff :=_cdadb (_dddcg .Attributes ["\u0079"],64);
if _effff !=nil {_gg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0079\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_effff .Error ());};_eadeg :=_dddcg .Attributes ["\u0066\u0069\u006c\u006c"];
var _cccdb ,_fbecec ,_ecccc float64 ;if _cdde ,_deaeg :=_cae .ColorMap [_eadeg ];_deaeg {_cgef ,_agabf ,_efga ,_ :=_cdde .RGBA ();_cccdb ,_fbecec ,_ecccc =float64 (_cgef ),float64 (_agabf ),float64 (_efga );}else if _bd .HasPrefix (_eadeg ,"\u0072\u0067\u0062\u0028"){_cccdb ,_fbecec ,_ecccc =_fgbgc (_eadeg );
}else {_cccdb ,_fbecec ,_ecccc =ColorRGBFromHex (_eadeg ).ToRGB ();};_gbecg .Add_rg (_cccdb ,_fbecec ,_ecccc );_cgea :=_gfcc ;if _bcefe ,_gcgbbc :=_dddcg .Attributes ["\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae"];_gcgbbc {_cgea ,_effff =_fa .ParseFloat (_bcefe ,64);
if _effff !=nil {_gg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067 \u0060\u0066\u006f\u006e\u0074\u002d\u0073\u0069\u007a\u0065\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_effff .Error ());
_cgea =_gfcc ;};};_deadd :=_dddcg ._dfgb *_cgea *PPI /_dgaa ;_eeddb :=_fac .PdfObjectName ("\u0053\u0046\u006fn\u0074");_fbfba :=_cb .DefaultFont ();_baacd ,_dgadf :=_dddcg .Attributes ["f\u006f\u006e\u0074\u002d\u0066\u0061\u006d\u0069\u006c\u0079"];if _dgadf {if _fega ,_gceab :=_bbdfa (_baacd );
_gceab ==nil {_fbfba =_fega ;_gdgdb :=1;for _cacdd .HasFontByName (_eeddb ){_eeddb =_fac .PdfObjectName ("\u0053\u0046\u006fn\u0074"+_fa .Itoa (_gdgdb ));_gdgdb ++;};};};_ddcb :=0.0;_dagdf ,_dgadf :=_dddcg .Attributes ["t\u0065\u0078\u0074\u002d\u0061\u006e\u0063\u0068\u006f\u0072"];
if _dgadf &&_dagdf !="\u0073\u0074\u0061r\u0074"{var _gbfcd float64 ;for _ ,_bbdbc :=range _dddcg .Content {_dabaa ,_gedea :=_fbfba .GetRuneMetrics (_bbdbc );if !_gedea {_gg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074e\u0064 \u0072u\u006e\u0065\u0020\u0025\u0076\u0020\u0069\u006e\u0020\u0066\u006f\u006e\u0074",_bbdbc );
};_gbfcd +=_dabaa .Wx ;};_gbfcd =_gbfcd *_deadd /1000.0;if _dagdf =="\u006d\u0069\u0064\u0064\u006c\u0065"{_ddcb =-_gbfcd /2;}else if _dagdf =="\u0065\u006e\u0064"{_ddcb =-_gbfcd ;};};_gbecg .Add_Tm (1,0,0,-1,_bbde *_dddcg ._dfgb +_ddcb ,_gfeee *_dddcg ._dfgb );
_cacdd .SetFontByName (_eeddb ,_fbfba .ToPdfObject ());_gbecg .Add_Tf (_eeddb ,_deadd );_fgff :=_dddcg .Content ;_cbdc :=_fac .MakeString (_fgff );_gbecg .Add_Tj (*_cbdc );_gbecg .Add_ET ();};

// SetBorderOpacity sets the border opacity of the rectangle.
func (_aagb *Rectangle )SetBorderOpacity (opacity float64 ){_aagb ._fbfee =opacity };func (_cbgbab *Grid )insertRowAfter (_gbdg int ,_gcbd *GridRow ){_cbgbab ._bded =append (_cbgbab ._bded ,&GridRow {});copy (_cbgbab ._bded [_gbdg +2:],_cbgbab ._bded [_gbdg +1:]);
_cbgbab ._bded [_gbdg +1]=_gcbd ;for _agfb ,_adag :=range _cbgbab ._bded {if _agfb > _gbdg +1{_adag ._egag +=1;for _ ,_fbdc :=range _adag ._cabf {_fbdc ._dbab +=1;};};};};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_bgag *shading )SetAntiAlias (enable bool ){_bgag ._fbada =enable };

// SetBorderColor sets the border color for the path.
func (_cbfca *FilledCurve )SetBorderColor (color Color ){_cbfca ._bga =color };

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_fbccf *GridCell )SetContent (vd VectorDrawable )error {switch _cefc :=vd .(type ){case *Paragraph :if _cefc ._cdgge {_cefc ._cbca =true ;};_fbccf ._aafg =vd ;case *StyledParagraph :if _cefc ._gfff {_cefc ._cbcg =true ;};_fbccf ._aafg =vd ;case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_fbccf ._aafg =vd ;
default:_gg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _fac .ErrTypeError ;};return nil ;};type fontMetrics struct{_cabc float64 ;_bccfea float64 ;_eeagg float64 ;_bcbe float64 ;};

// SetMargins sets the margins of the graphic svg component.
func (_faag *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_faag ._badf .Left =left ;_faag ._badf .Right =right ;_faag ._badf .Top =top ;_faag ._badf .Bottom =bottom ;};type pathParserError struct{_faaeg string };func _dgebe (_fegbf *Table ,_ffcfd DrawContext )([]*Block ,DrawContext ,error ){var _gffc []*Block ;
_fdcfb :=NewBlock (_ffcfd .PageWidth ,_ffcfd .PageHeight );_fegbf .updateRowHeights (_ffcfd .Width -_fegbf ._gdfeg .Left -_fegbf ._gdfeg .Right );_gccge :=_fegbf ._gdfeg .Top ;if _fegbf ._gccec .IsRelative ()&&!_fegbf ._adfab {_eafee :=_fegbf .Height ();
if _eafee > _ffcfd .Height -_fegbf ._gdfeg .Top &&_eafee <=_ffcfd .PageHeight -_ffcfd .Margins .Top -_ffcfd .Margins .Bottom {_gffc =[]*Block {NewBlock (_ffcfd .PageWidth ,_ffcfd .PageHeight -_ffcfd .Y )};var _caafa error ;if _ ,_ffcfd ,_caafa =_bbbe ().GeneratePageBlocks (_ffcfd );
_caafa !=nil {return nil ,_ffcfd ,_caafa ;};_gccge =0;};};_acdde :=_ffcfd ;if _fegbf ._gccec .IsAbsolute (){_ffcfd .X =_fegbf ._cffd ;_ffcfd .Y =_fegbf ._ddagg ;}else {_ffcfd .X +=_fegbf ._gdfeg .Left ;_ffcfd .Y +=_gccge ;_ffcfd .Width -=_fegbf ._gdfeg .Left +_fegbf ._gdfeg .Right ;
_ffcfd .Height -=_gccge ;};_bgcb :=_ffcfd .Width ;_cdfag :=_ffcfd .X ;_gfcee :=_ffcfd .Y ;_geedd :=_ffcfd .Height ;_ecabe :=0;_fcffg ,_bcag :=-1,-1;if _fegbf ._gdeb {for _edced ,_dcffg :=range _fegbf ._gcbaa {if _dcffg ._gbbed < _fegbf ._dded {continue ;
};if _dcffg ._gbbed > _fegbf ._ageggd {break ;};if _fcffg < 0{_fcffg =_edced ;};_bcag =_edced ;};};if _aecee :=_fegbf .wrapContent (_ffcfd );_aecee !=nil {return nil ,_ffcfd ,_aecee ;};_fegbf .updateRowHeights (_ffcfd .Width -_fegbf ._gdfeg .Left -_fegbf ._gdfeg .Right );
var (_bead bool ;_beafe int ;_gbaga int ;_cdfe bool ;_cbagd int ;_dfabd error ;);for _bdab :=0;_bdab < len (_fegbf ._gcbaa );_bdab ++{_efac :=_fegbf ._gcbaa [_bdab ];if _adcgg ,_baee :=_fegbf .getLastCellFromCol (_efac ._bgage );_adcgg ==_bdab {if (_baee ._gbbed +_baee ._dfgcc -1)< _fegbf ._gagba {for _faaegd :=_efac ._gbbed ;
_faaegd < _fegbf ._gagba ;_faaegd ++{_gfada :=&TableCell {};_gfada ._gbbed =_faaegd +1;_gfada ._dfgcc =1;_gfada ._bgage =_efac ._bgage ;_fegbf ._gcbaa =append (_fegbf ._gcbaa ,_gfada );};};};_cgafb :=_efac .width (_fegbf ._bcbd ,_bgcb );_aabce :=float64 (0.0);
for _cgcca :=0;_cgcca < _efac ._bgage -1;_cgcca ++{_aabce +=_fegbf ._bcbd [_cgcca ]*_bgcb ;};_acgbf :=float64 (0.0);for _aegdg :=_ecabe ;_aegdg < _efac ._gbbed -1;_aegdg ++{_acgbf +=_fegbf ._begfg [_aegdg ];};_ffcfd .Height =_geedd -_acgbf ;_ffcg :=float64 (0.0);
for _ebgg :=0;_ebgg < _efac ._dfgcc ;_ebgg ++{_ffcg +=_fegbf ._begfg [_efac ._gbbed +_ebgg -1];};_fgdfc :=_cdfe &&_efac ._gbbed !=_cbagd ;_cbagd =_efac ._gbbed ;if _fgdfc ||_ffcg > _ffcfd .Height {if _fegbf ._cacgg &&!_cdfe {_cdfe ,_dfabd =_fegbf .wrapRow (_bdab ,_ffcfd ,_bgcb );
if _dfabd !=nil {return nil ,_ffcfd ,_dfabd ;};if _cdfe {_bdab --;continue ;};};_gffc =append (_gffc ,_fdcfb );_fdcfb =NewBlock (_ffcfd .PageWidth ,_ffcfd .PageHeight );_cdfag =_ffcfd .Margins .Left +_fegbf ._gdfeg .Left ;_gfcee =_ffcfd .Margins .Top ;
_ffcfd .Height =_ffcfd .PageHeight -_ffcfd .Margins .Top -_ffcfd .Margins .Bottom ;_ffcfd .Page ++;_geedd =_ffcfd .Height ;_ecabe =_efac ._gbbed -1;_acgbf =0;_cdfe =false ;if _fegbf ._gdeb &&_fcffg >=0{_beafe =_bdab ;_bdab =_fcffg -1;_gbaga =_ecabe ;_ecabe =_fegbf ._dded -1;
_bead =true ;if _efac ._dfgcc > (_fegbf ._gagba -_cbagd )||(_efac ._dfgcc > 1&&_bdab < 0){_gg .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_bead =false ;_fcffg ,_bcag =-1,-1;};continue ;};if _fgdfc {_bdab --;continue ;};};_ffcfd .Width =_cgafb ;_ffcfd .X =_cdfag +_aabce ;_ffcfd .Y =_gfcee +_acgbf ;if _ffcg > _ffcfd .PageHeight -_ffcfd .Margins .Top -_ffcfd .Margins .Bottom {_ffcg =_ffcfd .PageHeight -_ffcfd .Margins .Top -_ffcfd .Margins .Bottom ;
};_fgga :=_gedd (_ffcfd .X ,_ffcfd .Y ,_cgafb ,_ffcg );if _efac ._fcdbg !=nil {_fgga .SetFillColor (_efac ._fcdbg );};_fgga .SetOpacity (_efac ._fbbfg );_fgga .LineStyle =_efac ._eceb ;_fgga ._gdg =_efac ._ccecb ;_fgga ._bgfd =_efac ._bbgad ;_fgga ._dcac =_efac ._edcda ;
_fgga ._bee =_efac ._dgfe ;if _efac ._bfaa !=nil {_fgga .SetColorLeft (_efac ._bfaa );};if _efac ._agac !=nil {_fgga .SetColorBottom (_efac ._agac );};if _efac ._cbcac !=nil {_fgga .SetColorRight (_efac ._cbcac );};if _efac ._cgfdb !=nil {_fgga .SetColorTop (_efac ._cgfdb );
};_fgga .SetWidthBottom (_efac ._aeefb );_fgga .SetWidthLeft (_efac ._acdbg );_fgga .SetWidthRight (_efac ._eecfd );_fgga .SetWidthTop (_efac ._cdaeb );_efdc :=NewBlock (_fdcfb ._db ,_fdcfb ._ecf );_ebaca :=_fdcfb .Draw (_fgga );if _ebaca !=nil {_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ebaca );
};if _efac ._bgfcf !=nil {_eabc :=_efac ._bgfcf .Width ();_dbabbg :=_efac ._bgfcf .Height ();_bdgdg :=0.0;switch _adac :=_efac ._bgfcf .(type ){case *Paragraph :if _adac ._cbca {_eabc =_adac .getMaxLineWidth ()/1000.0;};_dagfc ,_beagd ,_ :=_adac .getTextMetrics ();
_facg ,_dggbc :=_dagfc *_adac ._ccfga ,_beagd *_adac ._ccfga ;_dbabbg =_dbabbg -_dggbc +_facg ;_bdgdg +=_facg -_dggbc ;_cgccf :=0.5;if _fegbf ._aaca {_cgccf =0.3;};switch _efac ._agcce {case CellVerticalAlignmentTop :_bdgdg +=_facg *_cgccf ;case CellVerticalAlignmentBottom :_bdgdg -=_facg *_cgccf ;
};_eabc +=_adac ._gebd .Left +_adac ._gebd .Right ;_dbabbg +=_adac ._gebd .Top +_adac ._gebd .Bottom ;case *StyledParagraph :if _adac ._cbcg {_eabc =_adac .getMaxLineWidth ()/1000.0;};_eefe ,_eeffc ,_bdgfa :=_adac .getLineMetrics (0);_fcae ,_beca :=_eefe *_adac ._dcag ,_eeffc *_adac ._dcag ;
if _adac ._beagc ==TextVerticalAlignmentCenter {_bdgdg =_beca -(_eeffc +(_eefe +_bdgfa -_eeffc )/2+(_beca -_eeffc )/2);};if len (_adac ._ebbfe )==1{_dbabbg =_fcae ;}else {_dbabbg =_dbabbg -_beca +_fcae ;};_bdgdg +=_fcae -_beca ;switch _efac ._agcce {case CellVerticalAlignmentTop :_bdgdg +=_fcae *0.5;
case CellVerticalAlignmentBottom :_bdgdg -=_fcae *0.5;};_eabc +=_adac ._dcbc .Left +_adac ._dcbc .Right ;_dbabbg +=_adac ._dcbc .Top +_adac ._dcbc .Bottom ;case *Table :_eabc =_cgafb ;case *List :_eabc =_cgafb ;case *Division :_eabc =_cgafb ;case *Chart :_eabc =_cgafb ;
case *Line :_dbabbg +=_adac ._bfgab .Top +_adac ._bfgab .Bottom ;_bdgdg -=_adac .Height ()/2;case *Image :_eabc +=_adac ._bcgd .Left +_adac ._bcgd .Right ;_dbabbg +=_adac ._bcgd .Top +_adac ._bcgd .Bottom ;};switch _efac ._fabd {case CellHorizontalAlignmentLeft :_ffcfd .X +=_efac ._bbeab ;
_ffcfd .Width -=_efac ._bbeab ;case CellHorizontalAlignmentCenter :if _bbfb :=_cgafb -_eabc ;_bbfb > 0{_ffcfd .X +=_bbfb /2;_ffcfd .Width -=_bbfb /2;};case CellHorizontalAlignmentRight :if _cgafb > _eabc {_ffcfd .X =_ffcfd .X +_cgafb -_eabc -_efac ._bbeab ;
_ffcfd .Width -=_efac ._bbeab ;};};_cedee :=_ffcfd .Y ;_daffb :=_ffcfd .Height ;_ffcfd .Y +=_bdgdg ;switch _efac ._agcce {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _ebbb :=_ffcg -_dbabbg ;_ebbb > 0{_ffcfd .Y +=_ebbb /2;_ffcfd .Height -=_ebbb /2;
};case CellVerticalAlignmentBottom :if _ffcg > _dbabbg {_ffcfd .Y =_ffcfd .Y +_ffcg -_dbabbg ;_ffcfd .Height =_ffcg ;};};_dafcd :=_fdcfb .DrawWithContext (_efac ._bgfcf ,_ffcfd );if _dafcd !=nil {if _ff .Is (_dafcd ,ErrContentNotFit )&&!_fgdfc {_fdcfb =_efdc ;
_fgdfc =true ;_bdab --;continue ;};_gg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dafcd );};_ffcfd .Y =_cedee ;_ffcfd .Height =_daffb ;};_ffcfd .Y +=_ffcg ;_ffcfd .Height -=_ffcg ;if _bead &&_bdab +1> _bcag {_gfcee +=_acgbf +_ffcg ;_geedd -=_ffcg +_acgbf ;
_ecabe =_gbaga ;_bdab =_beafe -1;_bead =false ;};};_gffc =append (_gffc ,_fdcfb );if _fegbf ._gccec .IsAbsolute (){return _gffc ,_acdde ,nil ;};_ffcfd .X =_acdde .X ;_ffcfd .Width =_acdde .Width ;_ffcfd .Y +=_fegbf ._gdfeg .Bottom ;_ffcfd .Height -=_fegbf ._gdfeg .Bottom ;
return _gffc ,_ffcfd ,nil ;};

// SetFillColor sets the fill color for the path.
func (_dddd *FilledCurve )SetFillColor (color Color ){_dddd ._gfd =color };

// SetCompactMode sets the compact mode flag for this table.
//
// By enabling compact mode, table cell that contains Paragraph/StyleParagraph
// would not add extra height when calculating it's height.
//
// The default value is false.
func (_abfc *Table )SetCompactMode (enable bool ){_abfc ._aaca =enable };func _ecgc (_faae []byte )(*Image ,error ){_gddf :=_cc .NewReader (_faae );_efd ,_dggf :=_cb .ImageHandling .Read (_gddf );if _dggf !=nil {_gg .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dggf );
return nil ,_dggf ;};return _bff (_efd );};func (_eeabb *templateProcessor )parseBorderRadiusAttr (_bbeca ,_abbbd string )(_dedfe ,_febff ,_bgeg ,_ecce float64 ){_gg .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_bbeca ,_abbbd );
switch _eafg :=_bd .Fields (_abbbd );len (_eafg ){case 1:_dedfe ,_ =_fa .ParseFloat (_eafg [0],64);_febff =_dedfe ;_bgeg =_dedfe ;_ecce =_dedfe ;case 2:_dedfe ,_ =_fa .ParseFloat (_eafg [0],64);_bgeg =_dedfe ;_febff ,_ =_fa .ParseFloat (_eafg [1],64);_ecce =_febff ;
case 3:_dedfe ,_ =_fa .ParseFloat (_eafg [0],64);_febff ,_ =_fa .ParseFloat (_eafg [1],64);_ecce =_febff ;_bgeg ,_ =_fa .ParseFloat (_eafg [2],64);case 4:_dedfe ,_ =_fa .ParseFloat (_eafg [0],64);_febff ,_ =_fa .ParseFloat (_eafg [1],64);_bgeg ,_ =_fa .ParseFloat (_eafg [2],64);
_ecce ,_ =_fa .ParseFloat (_eafg [3],64);};return _dedfe ,_febff ,_bgeg ,_ecce ;};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_cfggc *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_cfggc ._fabd =halign ;};

// NewRow makes a new row and inserts it into the table at the current position.
func (_bdbf *Grid )NewRow ()*GridRow {_ddff :=&GridRow {_cdbae :_bdbf ._acdc ,_egag :len (_bdbf ._bded ),_accg :_bdbf };_bdbf ._bded =append (_bdbf ._bded ,_ddff );return _ddff ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_dgab *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _dgab ._bfad ==nil {if _ffbb :=_dgab .makeXObject ();_ffbb !=nil {return nil ,ctx ,_ffbb ;};};var _bcbg []*Block ;_cfefad :=ctx ;_bcbfe :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _dgab ._cecd .IsRelative (){_dgab .applyFitMode (ctx .Width );ctx .X +=_dgab ._bcgd .Left ;ctx .Y +=_dgab ._bcgd .Top ;ctx .Width -=_dgab ._bcgd .Left +_dgab ._bcgd .Right ;ctx .Height -=_dgab ._bcgd .Top +_dgab ._bcgd .Bottom ;if _dgab ._efag > ctx .Height {_bcbg =append (_bcbg ,_bcbfe );
_bcbfe =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dgfc :=ctx ;_dgfc .Y =ctx .Margins .Top +_dgab ._bcgd .Top ;_dgfc .X =ctx .Margins .Left +_dgab ._bcgd .Left ;_dgfc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_dgab ._bcgd .Top -_dgab ._bcgd .Bottom ;
_dgfc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dgab ._bcgd .Left -_dgab ._bcgd .Right ;ctx =_dgfc ;};}else {ctx .X =_dgab ._edbf ;ctx .Y =_dgab ._ggcdc ;};ctx ,_gbag :=_bccf (_bcbfe ,_dgab ,ctx );if _gbag !=nil {return nil ,ctx ,_gbag ;
};_bcbg =append (_bcbg ,_bcbfe );if _dgab ._cecd .IsAbsolute (){ctx =_cfefad ;}else {ctx .X =_cfefad .X ;ctx .Width =_cfefad .Width ;ctx .Y +=_dgab ._bcgd .Bottom ;};return _bcbg ,ctx ,nil ;};func (_abbb *listItem )ctxHeight (_gdec float64 )float64 {var _daaec float64 ;
switch _ccbd :=_abbb ._ggceb .(type ){case *Paragraph :if _ccbd ._cbca {_ccbd .SetWidth (_gdec -_ccbd ._gebd .Horizontal ());};_daaec =_ccbd .Height ()+_ccbd ._gebd .Vertical ();_daaec +=0.5*_ccbd ._dbcd *_ccbd ._ccfga ;case *StyledParagraph :if _ccbd ._cbcg {_ccbd .SetWidth (_gdec -_ccbd ._dcbc .Horizontal ());
};_daaec =_ccbd .Height ()+_ccbd ._dcbc .Vertical ();_daaec +=0.5*_ccbd .getTextHeight ();case *List :_edfbc :=_gdec -_abbb ._effcf .Width ()-_ccbd ._feba .Horizontal ()-_ccbd ._fdb ;_daaec =_ccbd .ctxHeight (_edfbc )+_ccbd ._feba .Vertical ();case *Image :_daaec =_ccbd .Height ()+_ccbd ._bcgd .Vertical ();
case *Division :_dcbb :=_gdec -_abbb ._effcf .Width ()-_ccbd ._ccega .Horizontal ();_daaec =_ccbd .ctxHeight (_dcbb )+_ccbd ._ccega .Vertical ();case *Table :_eefga :=_gdec -_abbb ._effcf .Width ()-_ccbd ._gdfeg .Horizontal ();_ccbd .updateRowHeights (_eefga );
_daaec =_ccbd .Height ()+_ccbd ._gdfeg .Vertical ();default:_daaec =_abbb ._ggceb .Height ();};return _daaec ;};func (_gdf *Block )drawToPage (_aag *_cb .PdfPage )error {_bbd :=&_ae .ContentStreamOperations {};if _aag .Resources ==nil {_aag .Resources =_cb .NewPdfPageResources ();
};_gab :=_da (_bbd ,_aag .Resources ,_gdf ._fd ,_gdf ._bg );if _gab !=nil {return _gab ;};if _gab =_ceg (_gdf ._bg ,_aag .Resources );_gab !=nil {return _gab ;};if _gab =_aag .AppendContentBytes (_bbd .Bytes (),true );_gab !=nil {return _gab ;};for _ ,_gce :=range _gdf ._ed {_aag .AddAnnotation (_gce );
};return nil ;};func (_agdf *Creator )newPage ()*_cb .PdfPage {_geaa :=_cb .NewPdfPage ();_beege :=_agdf ._bbfg [0];_cggb :=_agdf ._bbfg [1];_bege :=_cb .PdfRectangle {Llx :0,Lly :0,Urx :_beege ,Ury :_cggb };_geaa .MediaBox =&_bege ;_agdf ._eegg =_beege ;
_agdf ._bfbc =_cggb ;_agdf .initContext ();return _geaa ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_gdac *List )Add (item VectorDrawable )(*TextChunk ,error ){_dfaf :=&listItem {_ggceb :item ,_effcf :_gdac ._gbaeb };switch _bceg :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _bceg ._cedb {_bceg ._fdb =15;};case *Division :case *Image :case *Table :default:return nil ,_ff .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_gdac ._afab =append (_gdac ._afab ,_dfaf );return &_dfaf ._effcf ,nil ;};

// IsRelative checks if the positioning is relative.
func (_eggd Positioning )IsRelative ()bool {return _eggd ==PositionRelative };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_fgaa *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fgaa ._afcg .Left ,_fgaa ._afcg .Right ,_fgaa ._afcg .Top ,_fgaa ._afcg .Bottom ;};

// SetLanguageIdentifier sets the language identifier for the paragraph.
func (_gcbce *StyledParagraph )SetLanguageIdentifier (id string ){_gcbce ._adcg =id };func _cdaaa (_efefa *_cb .PdfRectangle ,_baced float64 )[4]_gga .Point {_babfbb :=_baced *_a .Pi /180.0;_eeaf :=_efefa .Width ();_cbedg :=_efefa .Height ();_fefe :=_a .Sin (_babfbb );
_caga :=_a .Cos (_babfbb );_ggfe :=[4]_gga .Point {{X :_aa .RoundFloat (_efefa .Llx ,3),Y :_aa .RoundFloat (_efefa .Lly ,3)},{X :_aa .RoundFloat (_efefa .Llx +_eeaf *_caga ,3),Y :_aa .RoundFloat (_efefa .Lly +_eeaf *_fefe ,3)},{X :_aa .RoundFloat (_efefa .Llx +_eeaf *_caga -_cbedg *_fefe ,3),Y :_aa .RoundFloat (_efefa .Lly +_eeaf *_fefe +_cbedg *_caga ,3)},{X :_aa .RoundFloat (_efefa .Llx -_cbedg *_fefe ,3),Y :_aa .RoundFloat (_efefa .Lly +_cbedg *_caga ,3)}};
return _ggfe ;};var (_ecadc =[]string {"\u0063\u006d","\u006d\u006d","\u0070\u0078","\u0070\u0074"};_gefe =map[string ]float64 {"\u0063\u006d":_fddc ,"\u006d\u006d":_fgdb ,"\u0070\u0078":_aedf ,"\u0070\u0074":1};);

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// Inline returns whether the inline mode of the division is active.
func (_cbad *Division )Inline ()bool {return _cbad ._dba };func _fgbgc (_ebddg string )(float64 ,float64 ,float64 ){_begde :=_bd .TrimPrefix (_ebddg ,"\u0072\u0067\u0062\u0028");_begde =_bd .TrimSuffix (_begde ,"\u0029");_bbadb :=_bd .Split (_begde ,"\u002c");
if len (_bbadb )!=3{_gg .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_ebddg );return 0,0,0;};var _bgbg ,_ecfca ,_ebdgaf float64 ;
_bgbg ,_fabe :=_feffb (_bbadb [0]);if _fabe !=nil {_gg .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_ebddg );
return 0,0,0;};_ecfca ,_fabe =_feffb (_bbadb [1]);if _fabe !=nil {_gg .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_ebddg );
return 0,0,0;};_ebdgaf ,_fabe =_feffb (_bbadb [2]);if _fabe !=nil {_gg .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0067\u0062\u0020\u0063\u006fl\u006f\u0072\u0020\u0073\u0070\u0065\u0063i\u0066\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020%\u0073",_ebddg );
return 0,0,0;};_cbdadf :=_bgbg /255.0;_fggde :=_ecfca /255.0;_dfcafc :=_ebdgaf /255.0;return _cbdadf ,_fggde ,_dfcafc ;};

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_cdcf *Rectangle )Width ()float64 {return _cdcf ._ggcb };const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_fafde *shading ;_bcfdf *_cb .PdfRectangle ;_bgcff float64 ;};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_cgcf *Table )MultiCell (rowspan ,colspan int )*TableCell {_cgcf ._ffec ++;_acace :=(_cgcf .moveToNextAvailableCell ()-1)%(_cgcf ._cfgeg )+1;_baffc :=(_cgcf ._ffec -1)/_cgcf ._cfgeg +1;for _baffc > _cgcf ._gagba {_cgcf ._gagba ++;_cgcf ._begfg =append (_cgcf ._begfg ,_cgcf ._dgcc );
};_aafee :=&TableCell {};_aafee ._gbbed =_baffc ;_aafee ._bgage =_acace ;_aafee ._bbeab =5;_aafee ._ccecb =CellBorderStyleNone ;_aafee ._eceb =_gga .LineStyleSolid ;_aafee ._fabd =CellHorizontalAlignmentLeft ;_aafee ._agcce =CellVerticalAlignmentTop ;_aafee ._acdbg =0;
_aafee ._aeefb =0;_aafee ._eecfd =0;_aafee ._cdaeb =0;_caadg :=ColorBlack ;_aafee ._bfaa =_caadg ;_aafee ._agac =_caadg ;_aafee ._cbcac =_caadg ;_aafee ._cgfdb =_caadg ;_aafee ._fbbfg =1.0;if rowspan < 1{_gg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_gadge :=_cgcf ._gagba -(_aafee ._gbbed -1);if rowspan > _gadge {_gg .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_gadge );
_cgcf ._gagba +=rowspan -1;for _ageaf :=0;_ageaf <=rowspan -_gadge ;_ageaf ++{_cgcf ._begfg =append (_cgcf ._begfg ,_cgcf ._dgcc );};};for _bbgb :=0;_bbgb < colspan &&_acace +_bbgb -1< len (_cgcf ._bgddf );_bbgb ++{_cgcf ._bgddf [_acace +_bbgb -1]=rowspan -1;
};_aafee ._dfgcc =rowspan ;if colspan < 1{_gg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_faabg :=_cgcf ._cfgeg -(_aafee ._bgage -1);if colspan > _faabg {_gg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_faabg );
colspan =_faabg ;};_aafee ._gbbga =colspan ;_cgcf ._ffec +=colspan -1;_cgcf ._gcbaa =append (_cgcf ._gcbaa ,_aafee );_aafee ._cecgbe =_cgcf ;return _aafee ;};func _cfcg (_fdbg *templateProcessor ,_adff *templateNode )(interface{},error ){return _fdbg .parseRectangle (_adff );
};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_afdg *Division )Add (d VectorDrawable )error {switch _gbege :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_cgcb ,_eecee :=_gbege .ContainerComponent (_afdg );
if _eecee !=nil {return _eecee ;};_fbba ,_dfed :=_cgcb .(VectorDrawable );if !_dfed {return _d .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_cgcb );
};d =_fbba ;default:return _ff .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_afdg ._dbfd =append (_afdg ._dbfd ,d );return nil ;};

// FitMode returns the fit mode of the line.
func (_adgb *Line )FitMode ()FitMode {return _adgb ._fdgd };

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_eefgd *Rectangle )FillOpacity ()float64 {return _eefgd ._abeed };

// Lines returns all the rows of the invoice line items table.
func (_fdcee *Invoice )Lines ()[][]*InvoiceCell {return _fdcee ._daeag };

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_eaad []*TextChunk ;_eeaba TextStyle ;_bafbd TextStyle ;_gffa TextAlignment ;_beagc TextVerticalAlignment ;_dcag float64 ;_cbcg bool ;_fgdfg float64 ;_gbdf bool ;_ffef int ;_gfff bool ;_bfdd TextOverflow ;_dbcga float64 ;_dcbc Margins ;
_fafce Positioning ;_bged float64 ;_ecdab float64 ;_edag float64 ;_cfge float64 ;_ebbfe [][]*TextChunk ;_afea func (_accd *StyledParagraph ,_bebce DrawContext );_eaef *int64 ;_adcg string ;};

// SetSubtotal sets the subtotal of the invoice.
func (_bdaa *Invoice )SetSubtotal (value string ){_bdaa ._gddc [1].Value =value };

// BuyerAddress returns the buyer address used in the invoice template.
func (_bbecc *Invoice )BuyerAddress ()*InvoiceAddress {return _bbecc ._fdaa };func (_ceeac *templateProcessor )parseTable (_adcdf *templateNode )(interface{},error ){var _ffadef int64 ;for _ ,_eaecc :=range _adcdf ._bcdgfa .Attr {_afed :=_eaecc .Value ;
switch _fgdd :=_eaecc .Name .Local ;_fgdd {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_ffadef =_ceeac .parseInt64Attr (_fgdd ,_afed );};};if _ffadef <=0{_ceeac .nodeLogDebug (_adcdf ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_ffadef );
_ffadef =1;};_eafeea :=_ceeac .creator .NewTable (int (_ffadef ));for _ ,_fdbac :=range _adcdf ._bcdgfa .Attr {_gfgb :=_fdbac .Value ;switch _aegdc :=_fdbac .Name .Local ;_aegdc {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_eafeea .SetColumnWidths (_ceeac .parseFloatArray (_aegdc ,_gfgb )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_fbdgb :=_ceeac .parseMarginAttr (_aegdc ,_gfgb );_eafeea .SetMargins (_fbdgb .Left ,_fbdgb .Right ,_fbdgb .Top ,_fbdgb .Bottom );case "\u0078":_eafeea .SetPos (_ceeac .parseFloatAttr (_aegdc ,_gfgb ),_eafeea ._ddagg );
case "\u0079":_eafeea .SetPos (_eafeea ._cffd ,_ceeac .parseFloatAttr (_aegdc ,_gfgb ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_eafeea ._dded =int (_ceeac .parseInt64Attr (_aegdc ,_gfgb ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_eafeea ._ageggd =int (_ceeac .parseInt64Attr (_aegdc ,_gfgb ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_eafeea .EnableRowWrap (_ceeac .parseBoolAttr (_aegdc ,_gfgb ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_eafeea .EnablePageWrap (_ceeac .parseBoolAttr (_aegdc ,_gfgb ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_ceeac .nodeLogDebug (_adcdf ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_aegdc );
};};if _eafeea ._dded !=0&&_eafeea ._ageggd !=0{_aage :=_eafeea .SetHeaderRows (_eafeea ._dded ,_eafeea ._ageggd );if _aage !=nil {_ceeac .nodeLogDebug (_adcdf ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_aage );
};}else {_eafeea ._dded =0;_eafeea ._ageggd =0;};return _eafeea ,nil ;};

// SetWidthLeft sets border width for left.
func (_egaf *border )SetWidthLeft (bw float64 ){_egaf ._bfdb =bw };

// EnableWordWrap sets the paragraph word wrap flag.
func (_ecdaf *StyledParagraph )EnableWordWrap (val bool ){_ecdaf ._gbdf =val };

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_fdecg rune ;_eaba []error ;};func (_effbe *Line )computeCoords (_caba DrawContext )(_bdac ,_defa ,_cgcdd ,_gcbb float64 ){_bdac =_caba .X ;_cgcdd =_bdac +_effbe ._abdb -_effbe ._cdbgd ;_dffgd :=_effbe ._fcfg ;if _effbe ._cdbgd ==_effbe ._abdb {_dffgd /=2;
};if _effbe ._bggef < _effbe ._ecff {_defa =_caba .PageHeight -_caba .Y -_dffgd ;_gcbb =_defa -_effbe ._ecff +_effbe ._bggef ;}else {_gcbb =_caba .PageHeight -_caba .Y -_dffgd ;_defa =_gcbb -_effbe ._bggef +_effbe ._ecff ;};switch _effbe ._fdgd {case FitModeFillWidth :_cgcdd =_bdac +_caba .Width ;
};return _bdac ,_defa ,_cgcdd ,_gcbb ;};func _egba (_bfcc Color ,_gaaa float64 )*ColorPoint {return &ColorPoint {_cafb :_bfcc ,_fafb :_gaaa }};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_cbdd *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_caada :=_cbdd ;if _cbdd ._cacgg {_caada =_cbdd .clone ();};return _dgebe (_caada ,ctx );};func (_baefb *GraphicSVGElement )drawCircle (_eecab *_ae .ContentCreator ,_gfce *_cb .PdfPageResources ){_eecab .Add_q ();
_baefb .Style .toContentStream (_eecab ,_gfce ,_baefb );_fbcf ,_aegae :=_cdadb (_baefb .Attributes ["\u0063\u0078"],64);if _aegae !=nil {_gg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0078\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_aegae .Error ());
};_bbed ,_aegae :=_cdadb (_baefb .Attributes ["\u0063\u0079"],64);if _aegae !=nil {_gg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0070\u0061r\u0073i\u006eg\u0020`\u0063\u0079\u0060\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_aegae .Error ());
};_gfdf ,_aegae :=_cdadb (_baefb .Attributes ["\u0072"],64);if _aegae !=nil {_gg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020w\u0068\u0069\u006c\u0065\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020`\u0072\u0060\u0020\u0076\u0061\u006c\u0075e\u003a\u0020\u0025\u0076",_aegae .Error ());
};_becga :=_gfdf *_baefb ._dfgb ;_fegb :=_gfdf *_baefb ._dfgb ;_bfcbc :=_becga *_gabb ;_cdgf :=_fegb *_gabb ;_gbged :=_gga .NewCubicBezierPath ();_gbged =_gbged .AppendCurve (_gga .NewCubicBezierCurve (-_becga ,0,-_becga ,_cdgf ,-_bfcbc ,_fegb ,0,_fegb ));
_gbged =_gbged .AppendCurve (_gga .NewCubicBezierCurve (0,_fegb ,_bfcbc ,_fegb ,_becga ,_cdgf ,_becga ,0));_gbged =_gbged .AppendCurve (_gga .NewCubicBezierCurve (_becga ,0,_becga ,-_cdgf ,_bfcbc ,-_fegb ,0,-_fegb ));_gbged =_gbged .AppendCurve (_gga .NewCubicBezierCurve (0,-_fegb ,-_bfcbc ,-_fegb ,-_becga ,-_cdgf ,-_becga ,0));
_gbged =_gbged .Offset (_fbcf *_baefb ._dfgb ,_bbed *_baefb ._dfgb );if _baefb .Style .StrokeWidth > 0{_gbged =_gbged .Offset (_baefb .Style .StrokeWidth /2,_baefb .Style .StrokeWidth /2);};_gga .DrawBezierPathWithCreator (_gbged ,_eecab );_baefb .Style .fillStroke (_eecab );
_eecab .Add_h ();_eecab .Add_Q ();};func (_fged *FilledCurve )draw (_dcfg *Block ,_eedb string )([]byte ,*_cb .PdfRectangle ,error ){_aedaf :=_gga .NewCubicBezierPath ();for _ ,_fcdb :=range _fged ._dbdf {_aedaf =_aedaf .AppendCurve (_fcdb );};creator :=_ae .NewContentCreator ();
if _fged ._eafb !=nil {creator .Add_BDC (*_fac .MakeName (_cb .StructureTypeFigure ),map[string ]_fac .PdfObject {"\u004d\u0043\u0049\u0044":_fac .MakeInteger (*_fged ._eafb )});};creator .Add_q ();if _fged .FillEnabled &&_fged ._gfd !=nil {_afe :=_cdfd (_fged ._gfd );
_edcb :=_bddf (_dcfg ,_afe ,_fged ._gfd ,func ()Rectangle {_bcbb :=_gga .NewCubicBezierPath ();for _ ,_aabc :=range _fged ._dbdf {_bcbb =_bcbb .AppendCurve (_aabc );};_cgdf :=_bcbb .GetBoundingBox ();if _fged .BorderEnabled {_cgdf .Height +=_fged .BorderWidth ;
_cgdf .Width +=_fged .BorderWidth ;_cgdf .X -=_fged .BorderWidth /2;_cgdf .Y -=_fged .BorderWidth /2;};return Rectangle {_gbaf :_cgdf .X ,_gcfge :_cgdf .Y ,_ggcb :_cgdf .Width ,_baadd :_cgdf .Height };});if _edcb !=nil {return nil ,nil ,_edcb ;};creator .SetNonStrokingColor (_afe );
};if _fged .BorderEnabled {if _fged ._bga !=nil {creator .SetStrokingColor (_cdfd (_fged ._bga ));};creator .Add_w (_fged .BorderWidth );};if len (_eedb )> 1{creator .Add_gs (_fac .PdfObjectName (_eedb ));};_gga .DrawBezierPathWithCreator (_aedaf ,creator );
creator .Add_h ();if _fged .FillEnabled &&_fged .BorderEnabled {creator .Add_B ();}else if _fged .FillEnabled {creator .Add_f ();}else if _fged .BorderEnabled {creator .Add_S ();};creator .Add_Q ();if _fged ._eafb !=nil {creator .Add_EMC ();};_bcef :=_aedaf .GetBoundingBox ();
if _fged .BorderEnabled {_bcef .Height +=_fged .BorderWidth ;_bcef .Width +=_fged .BorderWidth ;_bcef .X -=_fged .BorderWidth /2;_bcef .Y -=_fged .BorderWidth /2;};_fbe :=&_cb .PdfRectangle {};_fbe .Llx =_bcef .X ;_fbe .Lly =_bcef .Y ;_fbe .Urx =_bcef .X +_bcef .Width ;
_fbe .Ury =_bcef .Y +_bcef .Height ;return creator .Bytes (),_fbe ,nil ;};func (_ggaff *templateProcessor )parseTextOverflowAttr (_adea ,_agdba string )TextOverflow {_gg .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_adea ,_agdba );
_afgd :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_agdba ];return _afgd ;};var _cacfgc =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_bfaac :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_fbedge :_bfgcg },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_bfaac :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_fbedge :_beedc },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_bfaac :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_fbedge :_bcgbdc },"\u0074\u0061\u0062l\u0065":&templateTag {_bfaac :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_fbedge :_ecdcg },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_bfaac :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_fbedge :_efcad },"\u006c\u0069\u006e\u0065":&templateTag {_bfaac :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_fbedge :_fggb },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_bfaac :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_fbedge :_cfcg },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_bfaac :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_fbedge :_fcecfg },"\u0069\u006d\u0061g\u0065":&templateTag {_bfaac :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_fbedge :_fggdc },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_bfaac :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_fbedge :_fggcd },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_bfaac :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_fbedge :_ffffb },"\u0063\u0068\u0061r\u0074":&templateTag {_bfaac :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_fbedge :_faeac },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_bfaac :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_fbedge :_cgabd },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_bfaac :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_fbedge :_gbcbe },"\u006c\u0069\u0073\u0074":&templateTag {_bfaac :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_fbedge :_faeae },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_bfaac :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_fbedge :_faebe },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_bfaac :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_fbedge :_fgace }};


// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_daeb *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbcfe :=ctx ;_bcffg :=[]func (_daecb DrawContext )([]*Block ,DrawContext ,error ){_daeb .generateHeaderBlocks ,_daeb .generateInformationBlocks ,_daeb .generateLineBlocks ,_daeb .generateTotalBlocks ,_daeb .generateNoteBlocks };
var _dabb []*Block ;for _ ,_ggbb :=range _bcffg {_fggcc ,_cbcc ,_badfg :=_ggbb (ctx );if _badfg !=nil {return _dabb ,ctx ,_badfg ;};if len (_dabb )==0{_dabb =_fggcc ;}else if len (_fggcc )> 0{_dabb [len (_dabb )-1].mergeBlocks (_fggcc [0]);_dabb =append (_dabb ,_fggcc [1:]...);
};ctx =_cbcc ;};if _daeb ._gdaf .IsRelative (){ctx .X =_cbcfe .X ;};if _daeb ._gdaf .IsAbsolute (){return _dabb ,_cbcfe ,nil ;};return _dabb ,ctx ,nil ;};