//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_dd "bufio";_gf "bytes";_gd "compress/lzw";_ege "compress/zlib";_de "crypto/md5";_ba "crypto/rand";_beg "encoding/hex";_d "errors";_fc "fmt";_fef "github.com/unidoc/unipdf/v3/common";_bba "github.com/unidoc/unipdf/v3/core/security";
_bf "github.com/unidoc/unipdf/v3/core/security/crypt";_af "github.com/unidoc/unipdf/v3/internal/ccittfax";_bc "github.com/unidoc/unipdf/v3/internal/imageutil";_ee "github.com/unidoc/unipdf/v3/internal/jbig2";_ea "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";
_afg "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_ce "github.com/unidoc/unipdf/v3/internal/jbig2/document";_dg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_bab "github.com/unidoc/unipdf/v3/internal/strutils";_dcb "golang.org/x/image/tiff/lzw";
_dc "golang.org/x/xerrors";_fd "image";_db "image/color";_f "image/jpeg";_gdb "io";_bg "io/ioutil";_g "os";_eg "reflect";_aa "regexp";_be "sort";_b "strconv";_fe "strings";_c "sync";_bb "time";_a "unicode";);

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_bccb :=MakeArray ();for _ ,_eacb :=range vals {_bccb .Append (MakeInteger (int64 (_eacb )));};return _bccb ;};func (_cecdc *PdfParser )inspect ()(map[string ]int ,error ){_fef .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_fef .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_faef :=map[string ]int {};_edggc :=0;_gggfg :=0;var _ccdbb []int ;for _fged :=range _cecdc ._aaea .ObjectMap {_ccdbb =append (_ccdbb ,_fged );};_be .Ints (_ccdbb );_bfae :=0;
for _ ,_bfbcd :=range _ccdbb {_ccbg :=_cecdc ._aaea .ObjectMap [_bfbcd ];if _ccbg .ObjectNumber ==0{continue ;};_edggc ++;_fef .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_fef .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_ccbg .ObjectNumber );
_cdgb ,_cgcce :=_cecdc .LookupByNumber (_ccbg .ObjectNumber );if _cgcce !=nil {_fef .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_ccbg .ObjectNumber ,_cgcce );
_gggfg ++;continue ;};_fef .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_cdgb );_bggb ,_fdbb :=_cdgb .(*PdfIndirectObject );if _fdbb {_fef .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_ccbg .ObjectNumber ,_bggb );
_aeaee ,_ffgc :=_bggb .PdfObject .(*PdfObjectDictionary );if _ffgc {if _eddgg ,_agdbc :=_aeaee .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_agdbc {_cgcgec :=string (*_eddgg );_fef .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_cgcgec );
_ ,_ecaff :=_faef [_cgcgec ];if _ecaff {_faef [_cgcgec ]++;}else {_faef [_cgcgec ]=1;};}else if _adbb ,_cgff :=_aeaee .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_cgff {_ddabe :=string (*_adbb );_fef .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_ddabe );
_ ,_gafae :=_faef [_ddabe ];if _gafae {_faef [_ddabe ]++;}else {_faef [_ddabe ]=1;};};if _dceee ,_bagc :=_aeaee .Get ("\u0053").(*PdfObjectName );_bagc &&*_dceee =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_dbab :=_faef ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _dbab {_faef ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_faef ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _bebb ,_adef :=_cdgb .(*PdfObjectStream );_adef {if _dgfb ,_bfef :=_bebb .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_bfef {_fef .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_dgfb );_ecagc :=string (*_dgfb );_faef [_ecagc ]++;};}else {_ffge ,_fcce :=_cdgb .(*PdfObjectDictionary );
if _fcce {_aegb ,_bdcbf :=_ffge .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _bdcbf {_fgac :=string (*_aegb );_fef .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_fgac );_faef [_fgac ]++;};};_fef .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_ccbg .ObjectNumber ,_cdgb );
};_bfae ++;};_fef .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_fef .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");
_fef .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_edggc );_fef .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_gggfg );for _ddabc ,_ccfcf :=range _faef {_fef .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_ddabc ,_ccfcf );
};_fef .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_cecdc ._aaea .ObjectMap )< 1{_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_fc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_aafa ,_acbc :=_faef ["\u0046\u006f\u006e\u0074"];
if !_acbc ||_aafa < 2{_fef .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_fef .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _faef ,nil ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_bebdac :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _bebdac ==nil {return NewRawEncoder (),nil ;};if _ ,_ffdce :=_bebdac .(*PdfObjectNull );
_ffdce {return NewRawEncoder (),nil ;};_bgeb ,_bbcfb :=_bebdac .(*PdfObjectName );if !_bbcfb {_eeg ,_eeadb :=_bebdac .(*PdfObjectArray );if !_eeadb {return nil ,_fc .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _eeg .Len ()==0{return NewRawEncoder (),nil ;};if _eeg .Len ()!=1{_bcaa ,_gafg :=_bddg (streamObj );if _gafg !=nil {_fef .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_gafg );
return nil ,_gafg ;};_fef .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_bcaa );return _bcaa ,nil ;};_bebdac =_eeg .Get (0);_bgeb ,_eeadb =_bebdac .(*PdfObjectName );if !_eeadb {return nil ,_fc .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _ccbcd ,_ceff :=_egdd .Load (_bgeb .String ());_ceff {return _ccbcd .(StreamEncoder ),nil ;};switch *_bgeb {case StreamEncodingFilterNameFlate :return _gege (streamObj ,nil );case StreamEncodingFilterNameLZW :return _aagb (streamObj ,nil );case StreamEncodingFilterNameDCT :return _dfg (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _eddg (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _ddagb (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _cddd (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_fef .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_fc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_bgeb );};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_fabc *FlateEncoder )SetPredictor (columns int ){_fabc .Predictor =11;_fabc .Columns =columns };

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_cfbb *PdfObjectReference )Resolve ()PdfObject {if _cfbb ._begga ==nil {return MakeNull ();};_dccg ,_ ,_dfde :=_cfbb ._begga .resolveReference (_cfbb );if _dfde !=nil {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_dfde );
return MakeNull ();};if _dccg ==nil {_fef .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _dccg ;};func (_fac *PdfCrypt )securityHandler ()_bba .StdHandler {if _fac ._fab .R >=5{return _bba .NewHandlerR6 ();};return _bba .NewHandlerR4 (_fac ._eeb ,_fac ._bde .Length );};const JB2ImageAutoThreshold =-1.0;

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dcff *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// DecodeStream implements ASCII85 stream decoding.
func (_dbec *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dbec .DecodeBytes (streamObj .Stream );};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_gce *_bc .ImageBase ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ggbb *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fef .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cbgc ,_fagdd :=NewEncoderFromStream (streamObj );if _fagdd !=nil {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_fagdd );
return nil ,_fagdd ;};_fef .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_cbgc );_dgeb ,_fagdd :=_cbgc .DecodeStream (streamObj );if _fagdd !=nil {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_fagdd );
return nil ,_fagdd ;};return _dgeb ,nil ;};func (_gcf *PdfCrypt )loadCryptFilters (_dge *PdfObjectDictionary )error {_gcf ._deb =cryptFilters {};_ecb :=_dge .Get ("\u0043\u0046");_ecb =TraceToDirectObject (_ecb );if _dea ,_dfe :=_ecb .(*PdfObjectReference );
_dfe {_eba ,_ggc :=_gcf ._cfg .LookupByReference (*_dea );if _ggc !=nil {_fef .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _ggc ;};_ecb =TraceToDirectObject (_eba );};_cbb ,_ggb :=_ecb .(*PdfObjectDictionary );if !_ggb {_fef .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_ecb );return _d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_cafg :=range _cbb .Keys (){_bac :=_cbb .Get (_cafg );if _ebag ,_babc :=_bac .(*PdfObjectReference );_babc {_edc ,_fad :=_gcf ._cfg .LookupByReference (*_ebag );if _fad !=nil {_fef .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _fad ;};_bac =TraceToDirectObject (_edc );};_ddbe ,_ace :=_bac .(*PdfObjectDictionary );if !_ace {return _fc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_cafg ,_bac );
};if _cafg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _dde _bf .FilterDict ;if _efbb :=_dfa (&_dde ,_ddbe );_efbb !=nil {return _efbb ;};_deec ,_bfcc :=_bf .NewFilter (_dde );if _bfcc !=nil {return _bfcc ;};_gcf ._deb [string (_cafg )]=_deec ;};_gcf ._deb ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_bf .NewIdentity ();
_gcf ._fge ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _acea ,_ccd :=_dge .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ccd {if _ ,_faf :=_gcf ._deb [string (*_acea )];!_faf {return _fc .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_acea );
};_gcf ._fge =string (*_acea );};_gcf ._caf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cdab ,_ffe :=_dge .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_ffe {if _ ,_edgf :=_gcf ._deb [string (*_cdab )];!_edgf {return _fc .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_cdab );
};_gcf ._caf =string (*_cdab );};return nil ;};func _daf (_dfd _bf .Filter ,_gffa _bba .AuthEvent )*PdfObjectDictionary {if _gffa ==""{_gffa =_bba .EventDocOpen ;};_eaf :=MakeDict ();_eaf .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));
_eaf .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_gffa )));_eaf .Set ("\u0043\u0046\u004d",MakeName (_dfd .Name ()));_eaf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_dfd .KeyLength ())));return _eaf ;};

// WriteString outputs the object as it is to be written to file.
func (_cdfb *PdfObjectString )WriteString ()string {var _bcga _gf .Buffer ;if _cdfb ._gdggc {_caaeb :=_beg .EncodeToString (_cdfb .Bytes ());_bcga .WriteString ("\u003c");_bcga .WriteString (_caaeb );_bcga .WriteString ("\u003e");return _bcga .String ();
};_ccfcb :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_bcga .WriteString ("\u0028");for _adcc :=0;_adcc < len (_cdfb ._deef );
_adcc ++{_cbde :=_cdfb ._deef [_adcc ];if _bgdb ,_gafb :=_ccfcb [_cbde ];_gafb {_bcga .WriteString (_bgdb );}else {_bcga .WriteByte (_cbde );};};_bcga .WriteString ("\u0029");return _bcga .String ();};func (_dbf *PdfParser )readComment ()(string ,error ){var _ceged _gf .Buffer ;
_ ,_dcgc :=_dbf .skipSpaces ();if _dcgc !=nil {return _ceged .String (),_dcgc ;};_dega :=true ;for {_cfce ,_faeb :=_dbf ._cedf .Peek (1);if _faeb !=nil {_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_faeb .Error ());return _ceged .String (),_faeb ;
};if _dega &&_cfce [0]!='%'{return _ceged .String (),_d .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_dega =false ;if (_cfce [0]!='\r')&&(_cfce [0]!='\n'){_caga ,_ :=_dbf ._cedf .ReadByte ();
_ceged .WriteByte (_caga );}else {break ;};};return _ceged .String (),nil ;};func (_bddea *PdfParser )parseXrefStream (_eafec *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _eafec !=nil {_fef .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_eafec );
_bddea ._ccfe .Seek (int64 (*_eafec ),_gdb .SeekStart );_bddea ._cedf =_dd .NewReader (_bddea ._ccfe );};_gcfe :=_bddea .GetFileOffset ();_dcda ,_cffc :=_bddea .ParseIndirectObject ();if _cffc !=nil {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_fef .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_dcda );
_baeaed ,_ffefa :=_dcda .(*PdfObjectStream );if !_ffefa {_fef .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_dacc :=_baeaed .PdfObjectDictionary ;
_ccdc ,_ffefa :=_baeaed .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_ffefa {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_d .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_ccdc )> 8388607{_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_ccdc );
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cfgg :=_baeaed .PdfObjectDictionary .Get ("\u0057");_dadf ,_ffefa :=_cfgg .(*PdfObjectArray );if !_ffefa {return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_abfb :=_dadf .Len ();if _abfb !=3{_fef .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_abfb );
return nil ,_d .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _abbce []int64 ;for _cbfd :=0;_cbfd < 3;
_cbfd ++{_gdgc ,_bfbff :=GetInt (_dadf .Get (_cbfd ));if !_bfbff {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_abbce =append (_abbce ,int64 (*_gdgc ));};_egeae ,_cffc :=DecodeStream (_baeaed );
if _cffc !=nil {_fef .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_cffc );return nil ,_cffc ;};_bdage :=int (_abbce [0]);
_eccd :=int (_abbce [0]+_abbce [1]);_bdbcf :=int (_abbce [0]+_abbce [1]+_abbce [2]);_gdbc :=int (_abbce [0]+_abbce [1]+_abbce [2]);if _bdage < 0||_eccd < 0||_bdbcf < 0{_fef .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_bdage ,_eccd ,_bdbcf );
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _gdbc ==0{_fef .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _dacc ,nil ;};_bacb :=len (_egeae )/_gdbc ;_aggg :=0;_degad :=_baeaed .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _fdec []int ;if _degad !=nil {_fef .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_degad );_bbbe ,_ecde :=_degad .(*PdfObjectArray );
if !_ecde {_fef .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_d .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _bbbe .Len ()%2!=0{_fef .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aggg =0;_fgba ,_fbdcb :=_bbbe .ToIntegerArray ();if _fbdcb !=nil {_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_fbdcb );
return nil ,_fbdcb ;};for _bfbce :=0;_bfbce < len (_fgba );_bfbce +=2{_gbbad :=_fgba [_bfbce ];_cfde :=_fgba [_bfbce +1];for _dgcgc :=0;_dgcgc < _cfde ;_dgcgc ++{_fdec =append (_fdec ,_gbbad +_dgcgc );};_aggg +=_cfde ;};}else {for _egdg :=0;_egdg < int (*_ccdc );
_egdg ++{_fdec =append (_fdec ,_egdg );};_aggg =int (*_ccdc );};if _bacb ==_aggg +1{_fef .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_bffgg :=_aggg -1;for _ ,_dcee :=range _fdec {if _dcee > _bffgg {_bffgg =_dcee ;};};_fdec =append (_fdec ,_bffgg +1);_aggg ++;};if _bacb !=len (_fdec ){_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_bacb ,len (_fdec ));
return nil ,_d .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_fef .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_aggg );
_fef .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_fdec );_fffga :=func (_gdee []byte )int64 {var _baaf int64 ;for _beaf :=0;_beaf < len (_gdee );_beaf ++{_baaf +=int64 (_gdee [_beaf ])*(1<<uint (8*(len (_gdee )-_beaf -1)));
};return _baaf ;};_fef .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_egeae ));_adda :=0;for _cafa :=0;_cafa < len (_egeae );_cafa +=_gdbc {_ccfee :=_egead (len (_egeae ),_cafa ,_cafa +_bdage );
if _ccfee !=nil {_fef .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ccfee );return nil ,_ccfee ;};_efggc :=_egeae [_cafa :_cafa +_bdage ];_ccfee =_egead (len (_egeae ),_cafa +_bdage ,_cafa +_eccd );
if _ccfee !=nil {_fef .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ccfee );return nil ,_ccfee ;};_cefcg :=_egeae [_cafa +_bdage :_cafa +_eccd ];_ccfee =_egead (len (_egeae ),_cafa +_eccd ,_cafa +_bdbcf );
if _ccfee !=nil {_fef .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ccfee );return nil ,_ccfee ;};_gbdad :=_egeae [_cafa +_eccd :_cafa +_bdbcf ];_bdba :=_fffga (_efggc );
_eef :=_fffga (_cefcg );_debba :=_fffga (_gbdad );if _abbce [0]==0{_bdba =1;};if _adda >=len (_fdec ){_fef .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_eabbg :=_fdec [_adda ];_adda ++;_fef .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_eabbg ,_efggc );_fef .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_eabbg ,_cefcg );_fef .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_eabbg ,_gbdad );
_fef .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_eabbg ,_bdba ,_eef ,_debba );if _bdba ==0{_fef .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _bdba ==1{_fef .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_cefcg );if _eef ==_gcfe {_fef .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_eabbg ,_baeaed .ObjectNumber );
_eabbg =int (_baeaed .ObjectNumber );};if _gbdac ,_ddade :=_bddea ._aaea .ObjectMap [_eabbg ];!_ddade ||int (_debba )> _gbdac .Generation {_eaga :=XrefObject {ObjectNumber :_eabbg ,XType :XrefTypeTableEntry ,Offset :_eef ,Generation :int (_debba )};_bddea ._aaea .ObjectMap [_eabbg ]=_eaga ;
};}else if _bdba ==2{_fef .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_acdbe :=_bddea ._aaea .ObjectMap [_eabbg ];!_acdbe {_abfbb :=XrefObject {ObjectNumber :_eabbg ,XType :XrefTypeObjectStream ,OsObjNumber :int (_eef ),OsObjIndex :int (_debba )};
_bddea ._aaea .ObjectMap [_eabbg ]=_abfbb ;_fef .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_abfbb );};}else {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _bddea ._debe ==nil {_daa :=XrefTypeObjectStream ;_bddea ._debe =&_daa ;};return _dacc ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_bfcf *PdfObjectInteger )WriteString ()string {return _b .FormatInt (int64 (*_bfcf ),10)};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};func (_geee *PdfObjectInteger )String ()string {return _fc .Sprintf ("\u0025\u0064",*_geee )};

// HeaderPosition gets the file header position.
func (_cabf ParserMetadata )HeaderPosition ()int {return _cabf ._ggg };

// UpdateParams updates the parameter values of the encoder.
func (_aga *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _fead ,_fdfe :=GetNumberAsInt64 (params .Get ("\u004b"));_fdfe ==nil {_aga .K =int (_fead );};if _aeed ,_aafe :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_aafe ==nil {_aga .Columns =int (_aeed );}else if _aeed ,_aafe =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_aafe ==nil {_aga .Columns =int (_aeed );};if _cbbb ,_aeeb :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_aeeb ==nil {_aga .BlackIs1 =_cbbb > 0;}else {if _def ,_adbde :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_adbde {_aga .BlackIs1 =_def ;}else {if _cfec ,_bgegd :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_bgegd {_gggg ,_bgbb :=_cfec .ToIntegerArray ();if _bgbb ==nil {_aga .BlackIs1 =_gggg [0]==1&&_gggg [1]==0;};};};};if _dfaf ,_eagc :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_eagc ==nil {_aga .EncodedByteAlign =_dfaf > 0;}else {if _cfaa ,_bcde :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bcde {_aga .EncodedByteAlign =_cfaa ;};};if _gcea ,_ddff :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_ddff ==nil {_aga .EndOfLine =_gcea > 0;}else {if _afac ,_dgdab :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_dgdab {_aga .EndOfLine =_afac ;};};if _fddbe ,_cccdg :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_cccdg ==nil {_aga .Rows =int (_fddbe );}else if _fddbe ,_cccdg =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_cccdg ==nil {_aga .Rows =int (_fddbe );};if _dfee ,_deab :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_deab ==nil {_aga .EndOfBlock =_dfee > 0;}else {if _gdeb ,_edac :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_edac {_aga .EndOfBlock =_gdeb ;};};if _aabc ,_fdae :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_fdae !=nil {_aga .DamagedRowsBeforeError =int (_aabc );};};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_bfdb :=_gf .NewReader ([]byte (txt ));_egdgc :=&PdfParser {ObjCache :objectCache {},_ccfe :_bfdb ,_cedf :_dd .NewReader (_bfdb ),_agde :int64 (len (txt )),_bccc :map[int64 ]bool {},_aade :make (map[*PdfParser ]*PdfParser )};
_egdgc ._aaea .ObjectMap =make (map[int ]XrefObject );return _egdgc ;};func _bfbf (_gagaa string )(PdfObjectReference ,error ){_ccef :=PdfObjectReference {};_fedf :=_afcc .FindStringSubmatch (_gagaa );if len (_fedf )< 3{_fef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
return _ccef ,_d .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_defc ,_ :=_b .Atoi (_fedf [1]);_dced ,_ :=_b .Atoi (_fedf [2]);_ccef .ObjectNumber =int64 (_defc );_ccef .GenerationNumber =int64 (_dced );
return _ccef ,nil ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_fdab :=PdfObjectString {_deef :s ,_gdggc :true };return &_fdab ;};var _egdd _c .Map ;

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_fgca *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_gcaa :=PdfIndirectObject {};_gcaa ._begga =_fgca ;_fef .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_aadb ,_gdeeag :=_fgca ._cedf .Peek (20);
if _gdeeag !=nil {if _gdeeag !=_gdb .EOF {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_gcaa ,_gdeeag ;
};};_fef .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_aadb ));_ebfa :=_aaff .FindStringSubmatchIndex (string (_aadb ));if len (_ebfa )< 6{if _gdeeag ==_gdb .EOF {return nil ,_gdeeag ;
};_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_aadb ));
return &_gcaa ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_fgca ._cedf .Discard (_ebfa [0]);_fef .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_ebfa );_ffbe :=_ebfa [1]-_ebfa [0];_fdaga :=make ([]byte ,_ffbe );_ ,_gdeeag =_fgca .ReadAtLeast (_fdaga ,_ffbe );if _gdeeag !=nil {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_gdeeag );
return nil ,_gdeeag ;};_fef .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fdaga );_bffge :=_aaff .FindStringSubmatch (string (_fdaga ));if len (_bffge )< 3{_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_fdaga ));
return &_gcaa ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_dacbg ,_ :=_b .Atoi (_bffge [1]);_cdbb ,_ :=_b .Atoi (_bffge [2]);_gcaa .ObjectNumber =int64 (_dacbg );_gcaa .GenerationNumber =int64 (_cdbb );for {_addg ,_fegd :=_fgca ._cedf .Peek (2);if _fegd !=nil {return &_gcaa ,_fegd ;};_fef .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_addg ),string (_addg ));
if IsWhiteSpace (_addg [0]){_fgca .skipSpaces ();}else if _addg [0]=='%'{_fgca .skipComments ();}else if (_addg [0]=='<')&&(_addg [1]=='<'){_fef .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_gcaa .PdfObject ,_fegd =_fgca .ParseDict ();
_fef .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_fegd );if _fegd !=nil {return &_gcaa ,_fegd ;};_fef .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_addg [0]=='/')||(_addg [0]=='(')||(_addg [0]=='[')||(_addg [0]=='<'){_gcaa .PdfObject ,_fegd =_fgca .parseObject ();if _fegd !=nil {return &_gcaa ,_fegd ;};_fef .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _addg [0]==']'{_fef .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_fgca ._cedf .Discard (1);}else {if _addg [0]=='e'{_eddfe ,_bdbd :=_fgca .readTextLine ();if _bdbd !=nil {return nil ,_bdbd ;};if len (_eddfe )>=6&&_eddfe [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _addg [0]=='s'{_addg ,_ =_fgca ._cedf .Peek (10);
if string (_addg [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_aage :=6;if len (_addg )> 6{if IsWhiteSpace (_addg [_aage ])&&_addg [_aage ]!='\r'&&_addg [_aage ]!='\n'{_fef .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_fgca ._bffd ._bedc =true ;_aage ++;};if _addg [_aage ]=='\r'{_aage ++;if _addg [_aage ]=='\n'{_aage ++;};}else if _addg [_aage ]=='\n'{_aage ++;}else {_fgca ._bffd ._bedc =true ;};};_fgca ._cedf .Discard (_aage );_ccbf ,_cdfg :=_gcaa .PdfObject .(*PdfObjectDictionary );
if !_cdfg {return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fef .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_ccbf );
_cbcege ,_gebaa :=_fgca .traceStreamLength (_ccbf .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _gebaa !=nil {_fef .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_gebaa );
return nil ,_gebaa ;};_fef .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_cbcege );_eebg ,_ccgeb :=_cbcege .(*PdfObjectInteger );if !_ccgeb {return nil ,_d .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_ccab :=*_eebg ;if _ccab < 0{return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_dfeb :=_fgca .GetFileOffset ();
_edbce :=_fgca .xrefNextObjectOffset (_dfeb );if _dfeb +int64 (_ccab )> _edbce &&_edbce > _dfeb {_fef .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_dfeb +int64 (_ccab ));_fef .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_edbce );
_gcafg :=_edbce -_dfeb -17;if _gcafg < 0{return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_fef .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_gcafg );_ccab =PdfObjectInteger (_gcafg );
_ccbf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_gcafg ));};if int64 (_ccab )> _fgca ._agde {_fef .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_bbdb :=make ([]byte ,_ccab );
_ ,_gebaa =_fgca .ReadAtLeast (_bbdb ,int (_ccab ));if _gebaa !=nil {_fef .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_bbdb ),_bbdb );_fef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gebaa );
return nil ,_gebaa ;};_agca :=PdfObjectStream {};_agca .Stream =_bbdb ;_agca .PdfObjectDictionary =_gcaa .PdfObject .(*PdfObjectDictionary );_agca .ObjectNumber =_gcaa .ObjectNumber ;_agca .GenerationNumber =_gcaa .GenerationNumber ;_agca .PdfObjectReference ._begga =_fgca ;
_fgca .skipSpaces ();_fgca ._cedf .Discard (9);_fgca .skipSpaces ();return &_agca ,nil ;};};_gcaa .PdfObject ,_fegd =_fgca .parseObject ();if _gcaa .PdfObject ==nil {_fef .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_gcaa .PdfObject =MakeNull ();};return &_gcaa ,_fegd ;};};if _gcaa .PdfObject ==nil {_fef .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_gcaa .PdfObject =MakeNull ();};_fef .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_gcaa ,nil ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_bcgc *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ccba _bc .Gray ;switch len (data ){case _bcgc .Rows *_bcgc .Columns :_ebba ,_defa :=_bc .NewImage (_bcgc .Columns ,_bcgc .Rows ,8,1,data ,nil ,nil );if _defa !=nil {return nil ,_defa ;
};_ccba =_ebba .(_bc .Gray );case (_bcgc .Columns *_bcgc .Rows )+7>>3:_bdcfg ,_gdgg :=_bc .NewImage (_bcgc .Columns ,_bcgc .Rows ,1,1,data ,nil ,nil );if _gdgg !=nil {return nil ,_gdgg ;};_bdcb :=_bdcfg .(*_bc .Monochrome );if _gdgg =_bdcb .AddPadding ();
_gdgg !=nil {return nil ,_gdgg ;};_ccba =_bdcb ;default:if len (data )< _bc .BytesPerLine (_bcgc .Columns ,1,1)*_bcgc .Rows {return nil ,_d .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_ddae ,_egf :=_bc .NewImage (_bcgc .Columns ,_bcgc .Rows ,1,1,data ,nil ,nil );if _egf !=nil {return nil ,_egf ;};_egac :=_ddae .(*_bc .Monochrome );_ccba =_egac ;};_agba :=make ([][]byte ,_bcgc .Rows );for _agda :=0;_agda < _bcgc .Rows ;_agda ++{_abc :=make ([]byte ,_bcgc .Columns );
for _fcee :=0;_fcee < _bcgc .Columns ;_fcee ++{_ccfd :=_ccba .GrayAt (_fcee ,_agda );_abc [_fcee ]=_ccfd .Y >>7;};_agba [_agda ]=_abc ;};_beeg :=&_af .Encoder {K :_bcgc .K ,Columns :_bcgc .Columns ,EndOfLine :_bcgc .EndOfLine ,EndOfBlock :_bcgc .EndOfBlock ,BlackIs1 :_bcgc .BlackIs1 ,DamagedRowsBeforeError :_bcgc .DamagedRowsBeforeError ,Rows :_bcgc .Rows ,EncodedByteAlign :_bcgc .EncodedByteAlign };
return _beeg .Encode (_agba ),nil ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_dgd :=&FlateEncoder {};_dgd .Predictor =1;_dgd .BitsPerComponent =8;_dgd .Colors =1;_dgd .Columns =1;return _dgd ;};func _ddagb (_fefa *PdfObjectStream ,_edgff *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_bgge :=NewCCITTFaxEncoder ();
_gagd :=_fefa .PdfObjectDictionary ;if _gagd ==nil {return _bgge ,nil ;};if _edgff ==nil {_bbed :=TraceToDirectObject (_gagd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _bbed !=nil {switch _beff :=_bbed .(type ){case *PdfObjectDictionary :_edgff =_beff ;
case *PdfObjectArray :if _beff .Len ()==1{if _bgcc ,_gaab :=GetDict (_beff .Get (0));_gaab {_edgff =_bgcc ;};};default:_fef .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_bbed );
return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _edgff ==nil {_fef .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_bbed );
return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cdbe ,_bgae :=GetNumberAsInt64 (_edgff .Get ("\u004b"));_bgae ==nil {_bgge .K =int (_cdbe );};if _cbbf ,_efc :=GetNumberAsInt64 (_edgff .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_efc ==nil {_bgge .Columns =int (_cbbf );}else {_bgge .Columns =1728;};if _fdc ,_ccaac :=GetNumberAsInt64 (_edgff .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_ccaac ==nil {_bgge .BlackIs1 =_fdc > 0;}else {if _bggc ,_egc :=GetBoolVal (_edgff .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_egc {_bgge .BlackIs1 =_bggc ;}else {if _ggga ,_cebc :=GetArray (_edgff .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_cebc {_dafg ,_fbce :=_ggga .ToIntegerArray ();if _fbce ==nil {_bgge .BlackIs1 =_dafg [0]==1&&_dafg [1]==0;};};};};if _dgdb ,_dfbg :=GetNumberAsInt64 (_edgff .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_dfbg ==nil {_bgge .EncodedByteAlign =_dgdb > 0;}else {if _aaa ,_fcef :=GetBoolVal (_edgff .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_fcef {_bgge .EncodedByteAlign =_aaa ;};};if _gbde ,_febf :=GetNumberAsInt64 (_edgff .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_febf ==nil {_bgge .EndOfLine =_gbde > 0;}else {if _ddea ,_fbab :=GetBoolVal (_edgff .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_fbab {_bgge .EndOfLine =_ddea ;};};if _feee ,_ffgf :=GetNumberAsInt64 (_edgff .Get ("\u0052\u006f\u0077\u0073"));
_ffgf ==nil {_bgge .Rows =int (_feee );};_bgge .EndOfBlock =true ;if _cccb ,_gbfe :=GetNumberAsInt64 (_edgff .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gbfe ==nil {_bgge .EndOfBlock =_cccb > 0;}else {if _adba ,_ffcb :=GetBoolVal (_edgff .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_ffcb {_bgge .EndOfBlock =_adba ;};};if _ebb ,_cgaeg :=GetNumberAsInt64 (_edgff .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_cgaeg !=nil {_bgge .DamagedRowsBeforeError =int (_ebb );
};_fef .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_edgff .String ());return _bgge ,nil ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_ec *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_ddad ,_efb :=obj .(*PdfObjectReference );if !_efb {return obj ,nil ;};_fae :=_ec .GetFileOffset ();defer func (){_ec .SetFileOffset (_fae )}();_abe ,_bgf :=_ec .LookupByReference (*_ddad );
if _bgf !=nil {return nil ,_bgf ;};_abed ,_ccb :=_abe .(*PdfIndirectObject );if !_ccb {return _abe ,nil ;};_abe =_abed .PdfObject ;_ ,_efb =_abe .(*PdfObjectReference );if _efb {return _abed ,_d .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _abe ,nil ;};func _dfg (_cee *PdfObjectStream ,_ffdc *MultiEncoder )(*DCTEncoder ,error ){_adgg :=NewDCTEncoder ();_cagd :=_cee .PdfObjectDictionary ;if _cagd ==nil {return _adgg ,nil ;};_ffa :=_cee .Stream ;if _ffdc !=nil {_gbag ,_afff :=_ffdc .DecodeBytes (_ffa );
if _afff !=nil {return nil ,_afff ;};_ffa =_gbag ;};_bdge :=_gf .NewReader (_ffa );_ebf ,_aecg :=_f .DecodeConfig (_bdge );if _aecg !=nil {_fef .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_aecg );
return nil ,_aecg ;};switch _ebf .ColorModel {case _db .RGBAModel :_adgg .BitsPerComponent =8;_adgg .ColorComponents =3;_adgg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _db .RGBA64Model :_adgg .BitsPerComponent =16;_adgg .ColorComponents =3;_adgg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};
case _db .GrayModel :_adgg .BitsPerComponent =8;_adgg .ColorComponents =1;_adgg .Decode =[]float64 {0.0,1.0};case _db .Gray16Model :_adgg .BitsPerComponent =16;_adgg .ColorComponents =1;_adgg .Decode =[]float64 {0.0,1.0};case _db .CMYKModel :_adgg .BitsPerComponent =8;
_adgg .ColorComponents =4;_adgg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0};case _db .YCbCrModel :_adgg .BitsPerComponent =8;_adgg .ColorComponents =3;_adgg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};default:return nil ,_d .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_adgg .Width =_ebf .Width ;_adgg .Height =_ebf .Height ;_fef .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_adgg );_adgg .Quality =DefaultJPEGQuality ;_adee ,_fded :=GetArray (_cagd .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
if _fded {_abec ,_dcdd :=_adee .ToFloat64Array ();if _dcdd !=nil {return _adgg ,_dcdd ;};_adgg .Decode =_abec ;};return _adgg ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_caeb *PdfObjectDictionary )WriteString ()string {var _eedg _fe .Builder ;_eedg .WriteString ("\u003c\u003c");for _ ,_edace :=range _caeb ._bbdc {_aaga :=_caeb ._efca [_edace ];_eedg .WriteString (_edace .WriteString ());_eedg .WriteString ("\u0020");
_eedg .WriteString (_aaga .WriteString ());};_eedg .WriteString ("\u003e\u003e");return _eedg .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_dafc *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};func (_cdde *PdfParser )parseHexString ()(*PdfObjectString ,error ){_cdde ._cedf .ReadByte ();var _gebe _gf .Buffer ;for {_aacg ,_gfdg :=_cdde ._cedf .Peek (1);if _gfdg !=nil {return MakeString (""),_gfdg ;
};if _aacg [0]=='>'{_cdde ._cedf .ReadByte ();break ;};_bbg ,_ :=_cdde ._cedf .ReadByte ();if _cdde ._fece {if _gf .IndexByte (_bffdb ,_bbg )==-1{_cdde ._bffd ._gdda =true ;};};if !IsWhiteSpace (_bbg ){_gebe .WriteByte (_bbg );};};if _gebe .Len ()%2==1{_cdde ._bffd ._dcbc =true ;
_gebe .WriteRune ('0');};_bgcg ,_ :=_beg .DecodeString (_gebe .String ());return MakeHexString (string (_bgcg )),nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_dbbg *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _dbbg .Predictor !=1&&_dbbg .Predictor !=11{_fef .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _dbbg .Predictor ==11{_ccf :=_dbbg .Columns ;_agdf :=len (data )/_ccf ;if len (data )%_ccf !=0{_fef .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_bge :=_gf .NewBuffer (nil );_baea :=make ([]byte ,_ccf );for _aff :=0;_aff < _agdf ;_aff ++{_dggd :=data [_ccf *_aff :_ccf *(_aff +1)];_baea [0]=_dggd [0];
for _daebd :=1;_daebd < _ccf ;_daebd ++{_baea [_daebd ]=byte (int (_dggd [_daebd ]-_dggd [_daebd -1])%256);};_bge .WriteByte (1);_bge .Write (_baea );};data =_bge .Bytes ();};var _cabc _gf .Buffer ;_fde :=_ege .NewWriter (&_cabc );_fde .Write (data );_fde .Close ();
return _cabc .Bytes (),nil ;};func _ceb (_ab PdfObject )(int64 ,int64 ,error ){if _gcb ,_dga :=_ab .(*PdfIndirectObject );_dga {return _gcb .ObjectNumber ,_gcb .GenerationNumber ,nil ;};if _fb ,_abb :=_ab .(*PdfObjectStream );_abb {return _fb .ObjectNumber ,_fb .GenerationNumber ,nil ;
};return 0,0,_d .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eadg *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func _fcccf (_agcc ,_edeeg ,_faad uint8 )uint8 {_bdecd :=int (_faad );_gaec :=int (_edeeg )-_bdecd ;_cgg :=int (_agcc )-_bdecd ;_bdecd =_addc (_gaec +_cgg );_gaec =_addc (_gaec );
_cgg =_addc (_cgg );if _gaec <=_cgg &&_gaec <=_bdecd {return _agcc ;}else if _cgg <=_bdecd {return _edeeg ;};return _faad ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_afab *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_cgc ParserMetadata )HasEOLAfterHeader ()bool {return _cgc ._fbb };

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_fca :=MakeArray ();for _ ,_cada :=range vals {_fca .Append (MakeFloat (_cada ));};return _fca ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cccf *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };func (_ffcbb *PdfParser )traceStreamLength (_bcgg PdfObject )(PdfObject ,error ){_bfdc ,_bege :=_bcgg .(*PdfObjectReference );if _bege {_bbbb ,_baec :=_ffcbb ._bccc [_bfdc .ObjectNumber ];
if _baec &&_bbbb {_fef .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_d .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_ffcbb ._bccc [_bfdc .ObjectNumber ]=true ;};_gdeea ,_gacg :=_ffcbb .Resolve (_bcgg );if _gacg !=nil {return nil ,_gacg ;
};_fef .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_gdeea );if _bege {_ffcbb ._bccc [_bfdc .ObjectNumber ]=false ;};return _gdeea ,nil ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_aded *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_cdfc :=MakeDict ();_cdfc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aded .GetFilterName ()));return _cdfc ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_addb *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _addb .Predictor !=1{return nil ,_fc .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _addb .EarlyChange ==1{return nil ,_fc .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _aegg _gf .Buffer ;_bbd :=_gd .NewWriter (&_aegg ,_gd .MSB ,8);_bbd .Write (data );_bbd .Close ();return _aegg .Bytes (),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_efec *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_aefad *PdfParser )Inspect ()(map[string ]int ,error ){return _aefad .inspect ()};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_gcgd *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gcgd .DecodeBytes (streamObj .Stream );};var _gddf =_aa .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_ecfg :=PdfObjectString {_deef :s };return &_ecfg };

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_ddbb *PdfParser )GetObjectNums ()[]int {var _acbf []int ;for _ ,_eebcb :=range _ddbb ._aaea .ObjectMap {_acbf =append (_acbf ,_eebcb .ObjectNumber );};_be .Ints (_acbf );return _acbf ;};func (_cba *PdfParser )lookupByNumberWrapper (_aeg int ,_aecf bool )(PdfObject ,bool ,error ){_cae ,_gg ,_ccgd :=_cba .lookupByNumber (_aeg ,_aecf );
if _ccgd !=nil {return nil ,_gg ,_ccgd ;};if !_gg &&_cba ._fffgf !=nil &&_cba ._fffgf ._gbc &&!_cba ._fffgf .isDecrypted (_cae ){_fa :=_cba ._fffgf .Decrypt (_cae ,0,0);if _fa !=nil {return nil ,_gg ,_fa ;};};return _cae ,_gg ,nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// GetXrefTable returns the PDFs xref table.
func (_gaca *PdfParser )GetXrefTable ()XrefTable {return _gaca ._aaea };

// String returns a string describing `d`.
func (_bcda *PdfObjectDictionary )String ()string {var _befd _fe .Builder ;_befd .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_fgdcg :=range _bcda ._bbdc {_ffag :=_bcda ._efca [_fgdcg ];_befd .WriteString ("\u0022"+_fgdcg .String ()+"\u0022\u003a\u0020");
_befd .WriteString (_ffag .String ());_befd .WriteString ("\u002c\u0020");};_befd .WriteString ("\u0029");return _befd .String ();};func (_afda *limitedReadSeeker )getError (_ebc int64 )error {switch {case _ebc < 0:return _fc .Errorf ("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064",_ebc );
case _ebc > _afda ._adedd :return _fc .Errorf ("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064",_ebc );};return nil ;};const _baeb =6;

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_gafa string ,_ccbc bool ){_ccdff ,_ccbc :=TraceToDirectObject (obj ).(*PdfObjectName );if _ccbc {return string (*_ccdff ),true ;};return ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// WriteString outputs the object as it is to be written to file.
func (_ddfac *PdfObjectReference )WriteString ()string {var _dafff _fe .Builder ;_dafff .WriteString (_b .FormatInt (_ddfac .ObjectNumber ,10));_dafff .WriteString ("\u0020");_dafff .WriteString (_b .FormatInt (_ddfac .GenerationNumber ,10));_dafff .WriteString ("\u0020\u0052");
return _dafff .String ();};func (_gada *PdfParser )checkLinearizedInformation (_feafe *PdfObjectDictionary )(bool ,error ){var _ebaa error ;_gada ._ebbad ,_ebaa =GetNumberAsInt64 (_feafe .Get ("\u004c"));if _ebaa !=nil {return false ,_ebaa ;};_ebaa =_gada .seekToEOFMarker (_gada ._ebbad );
switch _ebaa {case nil :return true ,nil ;case _debg :return false ,nil ;default:return false ,_ebaa ;};};

// String returns a string describing `streams`.
func (_daaa *PdfObjectStreams )String ()string {return _fc .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_daaa .ObjectNumber );};

// WriteString outputs the object as it is to be written to file.
func (_eebd *PdfObjectStreams )WriteString ()string {var _cddc _fe .Builder ;_cddc .WriteString (_b .FormatInt (_eebd .ObjectNumber ,10));_cddc .WriteString ("\u0020\u0030\u0020\u0052");return _cddc .String ();};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_feaf *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _dafeb ,_afffg :=obj .(*PdfObjectReference );_afffg {obj =_dafeb .Resolve ();};_efaa ,_fbgeb :=obj .(*PdfIndirectObject );_cbbgf :=0;for _fbgeb {obj =_efaa .PdfObject ;_efaa ,_fbgeb =GetIndirect (obj );
_cbbgf ++;if _cbbgf > _fcea {_fef .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_fcea );
return nil ;};};return obj ;};func _addc (_dcfc int )int {_gfcg :=_dcfc >>(_cdge -1);return (_dcfc ^_gfcg )-_gfcg };var _fgdb =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_adad *PdfParser )GetTrailer ()*PdfObjectDictionary {return _adad ._fdef };func _eabg (_fddd ,_dfbe PdfObject ,_eggag int )bool {if _eggag > _fcea {_fef .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_fcea );
return false ;};if _fddd ==nil &&_dfbe ==nil {return true ;}else if _fddd ==nil ||_dfbe ==nil {return false ;};if _eg .TypeOf (_fddd )!=_eg .TypeOf (_dfbe ){return false ;};switch _cefb :=_fddd .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_cefb ==*(_dfbe .(*PdfObjectName ));case *PdfObjectString :return *_cefb ==*(_dfbe .(*PdfObjectString ));case *PdfObjectInteger :return *_cefb ==*(_dfbe .(*PdfObjectInteger ));case *PdfObjectBool :return *_cefb ==*(_dfbe .(*PdfObjectBool ));
case *PdfObjectFloat :return *_cefb ==*(_dfbe .(*PdfObjectFloat ));case *PdfIndirectObject :return _eabg (TraceToDirectObject (_fddd ),TraceToDirectObject (_dfbe ),_eggag +1);case *PdfObjectArray :_aeag :=_dfbe .(*PdfObjectArray );if len ((*_cefb )._bdfag )!=len ((*_aeag )._bdfag ){return false ;
};for _dcedc ,_fbbb :=range (*_cefb )._bdfag {if !_eabg (_fbbb ,(*_aeag )._bdfag [_dcedc ],_eggag +1){return false ;};};return true ;case *PdfObjectDictionary :_ecgd :=_dfbe .(*PdfObjectDictionary );_bgebb ,_gcdb :=(*_cefb )._efca ,(*_ecgd )._efca ;if len (_bgebb )!=len (_gcdb ){return false ;
};for _bbcb ,_cccfg :=range _bgebb {_dgegb ,_fceeg :=_gcdb [_bbcb ];if !_fceeg ||!_eabg (_cccfg ,_dgegb ,_eggag +1){return false ;};};return true ;case *PdfObjectStream :_gffcd :=_dfbe .(*PdfObjectStream );return _eabg ((*_cefb ).PdfObjectDictionary ,(*_gffcd ).PdfObjectDictionary ,_eggag +1);
default:_fef .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_fddd );
};return false ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cffd *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_edf :=MakeDict ();_edf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_cffd .GetFilterArray ());for _ ,_afgg :=range _cffd ._gebb {_eggc :=_afgg .MakeStreamDict ();for _ ,_bddb :=range _eggc .Keys (){_cbab :=_eggc .Get (_bddb );
if _bddb !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_bddb !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_edf .Set (_bddb ,_cbab );};};};_agbb :=_cffd .MakeDecodeParams ();if _agbb !=nil {_edf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_agbb );
};return _edf ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_ddfc Version ;_ccfe _gdb .ReadSeeker ;_cedf *_dd .Reader ;_agde int64 ;_aaea XrefTable ;_fgfaf int64 ;_debe *xrefType ;_edaba objectStreams ;_fdef *PdfObjectDictionary ;_fffgf *PdfCrypt ;_abbc *PdfIndirectObject ;_dcac bool ;ObjCache objectCache ;
_edebg map[int ]bool ;_bccc map[int64 ]bool ;_bffd ParserMetadata ;_fece bool ;_defdg []int64 ;_bcaef int ;_fdbf bool ;_ebbad int64 ;_aade map[*PdfParser ]*PdfParser ;_ecaf []*PdfParser ;};func _dafa (_gagdc PdfObject )(*float64 ,error ){switch _caedg :=_gagdc .(type ){case *PdfObjectFloat :_ebfc :=float64 (*_caedg );
return &_ebfc ,nil ;case *PdfObjectInteger :_abbef :=float64 (*_caedg );return &_abbef ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_gfg *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fef .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_fef .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gfg .Predictor );
if _gfg .BitsPerComponent !=8{return nil ,_fc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_gfg .BitsPerComponent );
};_cec ,_ccde :=_gfg .DecodeBytes (streamObj .Stream );if _ccde !=nil {return nil ,_ccde ;};_cec ,_ccde =_gfg .postDecodePredict (_cec );if _ccde !=nil {return nil ,_ccde ;};return _cec ,nil ;};func (_gfde *PdfParser )parsePdfVersion ()(int ,int ,error ){var _ffcbg int64 =20;
_decb :=make ([]byte ,_ffcbg );_gfde ._ccfe .Seek (0,_gdb .SeekStart );_gfde ._ccfe .Read (_decb );var _cbbfc error ;var _aafgb ,_dbge int ;if _ccdf :=_gead .FindStringSubmatch (string (_decb ));len (_ccdf )< 3{if _aafgb ,_dbge ,_cbbfc =_gfde .seekPdfVersionTopDown ();
_cbbfc !=nil {_fef .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_cbbfc ;
};_gfde ._ccfe ,_cbbfc =_fgf (_gfde ._ccfe ,_gfde .GetFileOffset ()-8);if _cbbfc !=nil {return 0,0,_cbbfc ;};}else {if _aafgb ,_cbbfc =_b .Atoi (_ccdf [1]);_cbbfc !=nil {return 0,0,_cbbfc ;};if _dbge ,_cbbfc =_b .Atoi (_ccdf [2]);_cbbfc !=nil {return 0,0,_cbbfc ;
};_gfde .SetFileOffset (0);};_gfde ._cedf =_dd .NewReader (_gfde ._ccfe );_fef .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_aafgb ,_dbge );return _aafgb ,_dbge ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfec *FlateEncoder )MakeDecodeParams ()PdfObject {if _bfec .Predictor > 1{_eccg :=MakeDict ();_eccg .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_bfec .Predictor )));if _bfec .BitsPerComponent !=8{_eccg .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_bfec .BitsPerComponent )));
};if _bfec .Columns !=1{_eccg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bfec .Columns )));};if _bfec .Colors !=1{_eccg .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_bfec .Colors )));};return _eccg ;};return nil ;
};func _gca (_fgg *_bba .StdEncryptDict ,_dgb *PdfObjectDictionary ){_dgb .Set ("\u0052",MakeInteger (int64 (_fgg .R )));_dgb .Set ("\u0050",MakeInteger (int64 (_fgg .P )));_dgb .Set ("\u004f",MakeStringFromBytes (_fgg .O ));_dgb .Set ("\u0055",MakeStringFromBytes (_fgg .U ));
if _fgg .R >=5{_dgb .Set ("\u004f\u0045",MakeStringFromBytes (_fgg .OE ));_dgb .Set ("\u0055\u0045",MakeStringFromBytes (_fgg .UE ));_dgb .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_fgg .EncryptMetadata ));
if _fgg .R > 5{_dgb .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_fgg .Perms ));};};};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// String returns a string representation of `name`.
func (_bgcgb *PdfObjectName )String ()string {return string (*_bgcgb )};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_gdeg *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ee .Globals ,error ){return _ee .DecodeGlobals (encoded );};

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_ggg int ;_fbb bool ;_efg [4]byte ;_fgga bool ;_dcbc bool ;_gdda bool ;_bedc bool ;_fadd bool ;_fga bool ;};

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_cde ParserMetadata )HasInvalidSubsectionHeader ()bool {return _cde ._fadd };

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_aca :_ce .InitEncodeDocument (false )}};var _afcc =_aa .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");


// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_fbge :=PdfObjectName (s );return &_fbge };type objectStreams map[int ]objectStream ;

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_edfb *JBIG2Encoder )EncodeImage (img _fd .Image )([]byte ,error ){return _edfb .encodeImage (img )};func _efdb (_efdg _gdb .ReadSeeker ,_fbdc int64 )(*limitedReadSeeker ,error ){_ ,_eeee :=_efdg .Seek (0,_gdb .SeekStart );if _eeee !=nil {return nil ,_eeee ;
};return &limitedReadSeeker {_dgae :_efdg ,_adedd :_fbdc },nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};func _dfa (_dba *_bf .FilterDict ,_fgd *PdfObjectDictionary )error {if _aega ,_faec :=_fgd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_faec {if _dbag :=string (*_aega );_dbag !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_fef .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_dbag );
};};_cfgc ,_agb :=_fgd .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_agb {return _fc .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_dba .CFM =string (*_cfgc );if _bgbe ,_bbac :=_fgd .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_bbac {_dba .AuthEvent =_bba .AuthEvent (*_bgbe );}else {_dba .AuthEvent =_bba .EventDocOpen ;};if _cab ,_gedg :=_fgd .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_gedg {_dba .Length =int (*_cab );};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cge *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };func (_fabb *PdfObjectDictionary )setWithLock (_fcac PdfObjectName ,_bcbd PdfObject ,_fdaa bool ){if _fdaa {_fabb ._aecea .Lock ();defer _fabb ._aecea .Unlock ();};
_ ,_cfgab :=_fabb ._efca [_fcac ];if !_cfgab {_fabb ._bbdc =append (_fabb ._bbdc ,_fcac );};_fabb ._efca [_fcac ]=_bcbd ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_gagg *PdfObjectArray )Get (i int )PdfObject {if _gagg ==nil ||i >=len (_gagg ._bdfag )||i < 0{return nil ;};return _gagg ._bdfag [i ];};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_deef string ;_gdggc bool ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_bcacd *PdfObjectArray )Elements ()[]PdfObject {if _bcacd ==nil {return nil ;};return _bcacd ._bdfag ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_adbg *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };var _gbffa =_aa .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// UpdateParams updates the parameter values of the encoder.
func (_cbcc *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_dgee ,_ccge :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _ccge ==nil {_cbcc .Predictor =int (_dgee );};_gfbae ,_ccge :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _ccge ==nil {_cbcc .BitsPerComponent =int (_gfbae );};_cccd ,_ccge :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ccge ==nil {_cbcc .Columns =int (_cccd );};_fgdf ,_ccge :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _ccge ==nil {_cbcc .Colors =int (_fgdf );};};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_eebc :=&ASCIIHexEncoder {};return _eebc };

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_geaf :objects };};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_daeg *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bgg *PdfCrypt )GetAccessPermissions ()_bba .Permissions {return _bgg ._fab .P };var _aeedc =_aa .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");


// EncodeBytes DCT encodes the passed in slice of bytes.
func (_ffca *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _aab _fd .Image ;if _ffca .ColorComponents ==1&&_ffca .BitsPerComponent ==8{_aab =&_fd .Gray {Rect :_fd .Rect (0,0,_ffca .Width ,_ffca .Height ),Pix :data ,Stride :_bc .BytesPerLine (_ffca .Width ,_ffca .BitsPerComponent ,_ffca .ColorComponents )};
}else {var _aef error ;_aab ,_aef =_bc .NewImage (_ffca .Width ,_ffca .Height ,_ffca .BitsPerComponent ,_ffca .ColorComponents ,data ,nil ,nil );if _aef !=nil {return nil ,_aef ;};};_cced :=_f .Options {};_cced .Quality =_ffca .Quality ;var _baaa _gf .Buffer ;
if _bcdg :=_f .Encode (&_baaa ,_aab ,&_cced );_bcdg !=nil {return nil ,_bcdg ;};return _baaa .Bytes (),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gbaea *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_bbeg :=MakeDict ();_bbeg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gbaea .GetFilterName ()));_bbeg .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gbaea .MakeDecodeParams ());
return _bbeg ;};type xrefType int ;

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_dgf *JBIG2Encoder )DecodeImages (encoded []byte )([]_fd .Image ,error ){const _caecb ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_acg ,_gacc :=_afg .Decode (encoded ,_afg .Parameters {},_dgf .Globals .ToDocumentGlobals ());
if _gacc !=nil {return nil ,_dg .Wrap (_gacc ,_caecb ,"");};_cbeb ,_gacc :=_acg .PageNumber ();if _gacc !=nil {return nil ,_dg .Wrap (_gacc ,_caecb ,"");};_dcg :=[]_fd .Image {};var _bdcc _fd .Image ;for _aeca :=1;_aeca <=_cbeb ;_aeca ++{_bdcc ,_gacc =_acg .DecodePageImage (_aeca );
if _gacc !=nil {return nil ,_dg .Wrapf (_gacc ,_caecb ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_aeca );};_dcg =append (_dcg ,_bdcc );};return _dcg ,nil ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_gbdaf :=&PdfObjectDictionary {};_gbdaf ._efca =map[PdfObjectName ]PdfObject {};_gbdaf ._bbdc =[]PdfObjectName {};_gbdaf ._aecea =&_c .Mutex {};return _gbdaf ;};

// LookupByReference looks up a PdfObject by a reference.
func (_begc *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_fef .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());
return _begc .LookupByNumber (int (ref .ObjectNumber ));};

// GetFilterName returns the name of the encoding filter.
func (_ecdb *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_eagb bool ,_gddfe bool ){_facee ,_gddfe :=TraceToDirectObject (obj ).(*PdfObjectBool );if _gddfe {return bool (*_facee ),true ;};return false ,false ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_gdbed *PdfParser )CheckAccessRights (password []byte )(bool ,_bba .Permissions ,error ){if _gdbed ._fffgf ==nil {return true ,_bba .PermOwner ,nil ;};return _gdbed ._fffgf .checkAccessRights (password );};func _aagb (_gda *PdfObjectStream ,_aeb *PdfObjectDictionary )(*LZWEncoder ,error ){_aac :=NewLZWEncoder ();
_babb :=_gda .PdfObjectDictionary ;if _babb ==nil {return _aac ,nil ;};if _aeb ==nil {_cgb :=TraceToDirectObject (_babb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _cgb !=nil {if _aeceb ,_ddbcb :=_cgb .(*PdfObjectDictionary );
_ddbcb {_aeb =_aeceb ;}else if _bcb ,_bce :=_cgb .(*PdfObjectArray );_bce {if _bcb .Len ()==1{if _bddc ,_gcba :=GetDict (_bcb .Get (0));_gcba {_aeb =_bddc ;};};};if _aeb ==nil {_fef .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_cgb );
return nil ,_fc .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_cfgcg :=_babb .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _cfgcg !=nil {_eedb ,_eede :=_cfgcg .(*PdfObjectInteger );
if !_eede {_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_cfgcg );
return nil ,_fc .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_eedb !=0&&*_eedb !=1{return nil ,_fc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_aac .EarlyChange =int (*_eedb );}else {_aac .EarlyChange =1;};if _aeb ==nil {return _aac ,nil ;};if _bgaa ,_bbea :=GetIntVal (_aeb .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_bbea {if _bgaa ==0||_bgaa ==1{_aac .EarlyChange =_bgaa ;
}else {_fef .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_bgaa );};};_cfgcg =_aeb .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _cfgcg !=nil {_dgda ,_acdb :=_cfgcg .(*PdfObjectInteger );if !_acdb {_fef .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_cfgcg );
return nil ,_fc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_aac .Predictor =int (*_dgda );};_cfgcg =_aeb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _cfgcg !=nil {_gdbd ,_fcg :=_cfgcg .(*PdfObjectInteger );if !_fcg {_fef .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_fc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_aac .BitsPerComponent =int (*_gdbd );};if _aac .Predictor > 1{_aac .Columns =1;_cfgcg =_aeb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _cfgcg !=nil {_caea ,_dcfd :=_cfgcg .(*PdfObjectInteger );if !_dcfd {return nil ,_fc .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_aac .Columns =int (*_caea );
};_aac .Colors =1;_cfgcg =_aeb .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _cfgcg !=nil {_efee ,_daebdc :=_cfgcg .(*PdfObjectInteger );if !_daebdc {return nil ,_fc .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_aac .Colors =int (*_efee );};};_fef .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_aeb .String ());return _aac ,nil ;};func (_fffaa *PdfParser )readTextLine ()(string ,error ){var _effe _gf .Buffer ;
for {_cfdf ,_abfe :=_fffaa ._cedf .Peek (1);if _abfe !=nil {_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_abfe .Error ());return _effe .String (),_abfe ;};if (_cfdf [0]!='\r')&&(_cfdf [0]!='\n'){_ddca ,_ :=_fffaa ._cedf .ReadByte ();
_effe .WriteByte (_ddca );}else {break ;};};return _effe .String (),nil ;};func (_gagdd *PdfParser )parseArray ()(*PdfObjectArray ,error ){_egae :=MakeArray ();_gagdd ._cedf .ReadByte ();for {_gagdd .skipSpaces ();_dbfd ,_ffaa :=_gagdd ._cedf .Peek (1);
if _ffaa !=nil {return _egae ,_ffaa ;};if _dbfd [0]==']'{_gagdd ._cedf .ReadByte ();break ;};_gbded ,_ffaa :=_gagdd .parseObject ();if _ffaa !=nil {return _egae ,_ffaa ;};_egae .Append (_gbded );};return _egae ,nil ;};func (_dce *PdfParser )checkPostEOFData ()error {const _gcaf ="\u0025\u0025\u0045O\u0046";
_ ,_gab :=_dce ._ccfe .Seek (-int64 (len ([]byte (_gcaf )))-1,_gdb .SeekEnd );if _gab !=nil {return _gab ;};_dbbc :=make ([]byte ,len ([]byte (_gcaf ))+1);_ ,_gab =_dce ._ccfe .Read (_dbbc );if _gab !=nil {if _gab !=_gdb .EOF {return _gab ;};};if string (_dbbc )==_gcaf ||string (_dbbc )==_gcaf +"\u000a"{_dce ._bffd ._fgga =true ;
};return nil ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_caaa *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fef .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_gcce :=_gf .NewReader (encoded );_ced ,_gfce :=_ege .NewReader (_gcce );if _gfce !=nil {_fef .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_gfce );_fef .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_gfce ;};defer _ced .Close ();var _aegcc _gf .Buffer ;_aegcc .ReadFrom (_ced );return _aegcc .Bytes (),nil ;};func (_gbe *PdfCrypt )isEncrypted (_dcd PdfObject )bool {_ ,_cgdf :=_gbe ._dee [_dcd ];if _cgdf {_fef .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};_fef .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_begga *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};var _eead =_aa .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");func _ffde (_abf int )cryptFilters {return cryptFilters {_fba :_bf .NewFilterV2 (_abf )}};


// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cegf *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_fcdg :=MakeDict ();_fcdg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cegf .GetFilterName ()));return _fcdg ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ecba *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };func (_cbeg *PdfParser )seekToEOFMarker (_cbdc int64 )error {var _ddba int64 ;var _gagc int64 =2048;for _ddba < _cbdc -4{if _cbdc <=(_gagc +_ddba ){_gagc =_cbdc -_ddba ;};_ ,_egfe :=_cbeg ._ccfe .Seek (_cbdc -_ddba -_gagc ,_gdb .SeekStart );
if _egfe !=nil {return _egfe ;};_bebd :=make ([]byte ,_gagc );_cbeg ._ccfe .Read (_bebd );_fef .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_bebd ));
_cgeb :=_gddf .FindAllStringIndex (string (_bebd ),-1);if _cgeb !=nil {_ddace :=_cgeb [len (_cgeb )-1];_fef .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cgeb );_efgcg :=_cbdc -_ddba -_gagc +int64 (_ddace [0]);_cbeg ._ccfe .Seek (_efgcg ,_gdb .SeekStart );
return nil ;};_fef .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_ddba +=_gagc -4;};_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _debg ;};func (_fdce *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_fdce ._aaea .ObjectMap =make (map[int ]XrefObject );
_fdce ._edaba =make (objectStreams );_bafe ,_bcedc :=_fdce ._ccfe .Seek (0,_gdb .SeekEnd );if _bcedc !=nil {return nil ,_bcedc ;};_fef .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_bafe );_fdce ._agde =_bafe ;_bcedc =_fdce .seekToEOFMarker (_bafe );
if _bcedc !=nil {_fef .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_bcedc );return nil ,_bcedc ;};_efcf ,_bcedc :=_fdce ._ccfe .Seek (0,_gdb .SeekCurrent );
if _bcedc !=nil {return nil ,_bcedc ;};var _abcg int64 =64;_cgce :=_efcf -_abcg ;if _cgce < 0{_cgce =0;};_ ,_bcedc =_fdce ._ccfe .Seek (_cgce ,_gdb .SeekStart );if _bcedc !=nil {return nil ,_bcedc ;};_cbebc :=make ([]byte ,_abcg );_ ,_bcedc =_fdce ._ccfe .Read (_cbebc );
if _bcedc !=nil {_fef .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_bcedc );
return nil ,_bcedc ;};_fdda :=_bdcdf .FindStringSubmatch (string (_cbebc ));if len (_fdda )< 2{_fef .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");
return nil ,_d .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_fdda )> 2{_fef .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_cbebc );
return nil ,_d .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_ffeb ,_ :=_b .ParseInt (_fdda [1],10,64);_fef .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_ffeb );
if _ffeb > _bafe {_fef .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_fef .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");
_ffeb ,_bcedc =_fdce .repairLocateXref ();if _bcedc !=nil {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_bcedc ;};};_fdce ._ccfe .Seek (_ffeb ,_gdb .SeekStart );_fdce ._cedf =_dd .NewReader (_fdce ._ccfe );_adab ,_bcedc :=_fdce .parseXref ();if _bcedc !=nil {return nil ,_bcedc ;};_cffag :=_adab .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _cffag !=nil {_gffeg ,_gecg :=_cffag .(*PdfObjectInteger );
if !_gecg {return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_bcedc =_fdce .parseXrefStream (_gffeg );if _bcedc !=nil {return nil ,_bcedc ;};};var _ggaf []int64 ;_gdea :=func (_bagf int64 ,_gecgd []int64 )bool {for _ ,_cbebd :=range _gecgd {if _cbebd ==_bagf {return true ;
};};return false ;};_cffag =_adab .Get ("\u0050\u0072\u0065\u0076");for _cffag !=nil {_cgga ,_gafce :=_cffag .(*PdfObjectInteger );if !_gafce {_fef .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_cffag );
return _adab ,nil ;};_fadf :=*_cgga ;_fef .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_fadf );_fdce ._ccfe .Seek (int64 (_fadf ),_gdb .SeekStart );
_fdce ._cedf =_dd .NewReader (_fdce ._ccfe );_afca ,_fdg :=_fdce .parseXref ();if _fdg !=nil {_fef .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_fef .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_fdce ._defdg =append (_fdce ._defdg ,int64 (_fadf ));
_cffag =_afca .Get ("\u0050\u0072\u0065\u0076");if _cffag !=nil {_bfgggd :=*(_cffag .(*PdfObjectInteger ));if _gdea (int64 (_bfgggd ),_ggaf ){_fef .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_ggaf =append (_ggaf ,int64 (_bfgggd ));};};return _adab ,nil ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_daee []float64 ,_cdbbb error ){for _ ,_afgf :=range objects {_bbabf ,_gdagf :=GetNumberAsFloat (_afgf );if _gdagf !=nil {return nil ,_gdagf ;};_daee =append (_daee ,_bbabf );};return _daee ,nil ;};func _bddg (_bgccg *PdfObjectStream )(*MultiEncoder ,error ){_efa :=NewMultiEncoder ();
_afad :=_bgccg .PdfObjectDictionary ;if _afad ==nil {return _efa ,nil ;};var _bddee *PdfObjectDictionary ;var _cbca []PdfObject ;_edcc :=_afad .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _edcc !=nil {_ecee ,_dff :=_edcc .(*PdfObjectDictionary );
if _dff {_bddee =_ecee ;};_dade ,_bddd :=_edcc .(*PdfObjectArray );if _bddd {for _ ,_eggd :=range _dade .Elements (){_eggd =TraceToDirectObject (_eggd );if _bced ,_dadb :=_eggd .(*PdfObjectDictionary );_dadb {_cbca =append (_cbca ,_bced );}else {_cbca =append (_cbca ,MakeDict ());
};};};};_edcc =_afad .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _edcc ==nil {return nil ,_fc .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_edcf ,_ffec :=_edcc .(*PdfObjectArray );if !_ffec {return nil ,_fc .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _fdcf ,_deag :=range _edcf .Elements (){_bfag ,_gcff :=_deag .(*PdfObjectName );if !_gcff {return nil ,_fc .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _deecb PdfObject ;if _bddee !=nil {_deecb =_bddee ;}else {if len (_cbca )> 0{if _fdcf >=len (_cbca ){return nil ,_fc .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_deecb =_cbca [_fdcf ];};};var _gbaf *PdfObjectDictionary ;if _age ,_cceg :=_deecb .(*PdfObjectDictionary );_cceg {_gbaf =_age ;};_fef .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_bfag ,_deecb ,_gbaf );
if *_bfag ==StreamEncodingFilterNameFlate {_ccfa ,_bddf :=_gege (_bgccg ,_gbaf );if _bddf !=nil {return nil ,_bddf ;};_efa .AddEncoder (_ccfa );}else if *_bfag ==StreamEncodingFilterNameLZW {_bafd ,_gdcc :=_aagb (_bgccg ,_gbaf );if _gdcc !=nil {return nil ,_gdcc ;
};_efa .AddEncoder (_bafd );}else if *_bfag ==StreamEncodingFilterNameASCIIHex {_dabg :=NewASCIIHexEncoder ();_efa .AddEncoder (_dabg );}else if *_bfag ==StreamEncodingFilterNameASCII85 {_fgbd :=NewASCII85Encoder ();_efa .AddEncoder (_fgbd );}else if *_bfag ==StreamEncodingFilterNameDCT {_edee ,_gdec :=_dfg (_bgccg ,_efa );
if _gdec !=nil {return nil ,_gdec ;};_efa .AddEncoder (_edee );_fef .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_fef .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_efa );
}else if *_bfag ==StreamEncodingFilterNameCCITTFax {_ffaf ,_egfa :=_ddagb (_bgccg ,_gbaf );if _egfa !=nil {return nil ,_egfa ;};_efa .AddEncoder (_ffaf );}else {_fef .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_bfag );
return nil ,_fc .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _efa ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fccc *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_eadca :=range _fccc ._gebb {_eadca .UpdateParams (params );};};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_gbdc *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_gbdc ._aecea .Lock ();defer _gbdc ._aecea .Unlock ();for _cfcbg ,_dcec :=range objmap {_gbdc .setWithLock (PdfObjectName (_cfcbg ),_dcec ,false );};return _gbdc ;
};func (_feed *PdfParser )parseString ()(*PdfObjectString ,error ){_feed ._cedf .ReadByte ();var _eacfd _gf .Buffer ;_bbc :=1;for {_caba ,_dbfb :=_feed ._cedf .Peek (1);if _dbfb !=nil {return MakeString (_eacfd .String ()),_dbfb ;};if _caba [0]=='\\'{_feed ._cedf .ReadByte ();
_eeba ,_baeg :=_feed ._cedf .ReadByte ();if _baeg !=nil {return MakeString (_eacfd .String ()),_baeg ;};if IsOctalDigit (_eeba ){_edcfc ,_dgcb :=_feed ._cedf .Peek (2);if _dgcb !=nil {return MakeString (_eacfd .String ()),_dgcb ;};var _fbfg []byte ;_fbfg =append (_fbfg ,_eeba );
for _ ,_ceba :=range _edcfc {if IsOctalDigit (_ceba ){_fbfg =append (_fbfg ,_ceba );}else {break ;};};_feed ._cedf .Discard (len (_fbfg )-1);_fef .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_fbfg );
_gegg ,_dgcb :=_b .ParseUint (string (_fbfg ),8,32);if _dgcb !=nil {return MakeString (_eacfd .String ()),_dgcb ;};_eacfd .WriteByte (byte (_gegg ));continue ;};switch _eeba {case 'n':_eacfd .WriteRune ('\n');case 'r':_eacfd .WriteRune ('\r');case 't':_eacfd .WriteRune ('\t');
case 'b':_eacfd .WriteRune ('\b');case 'f':_eacfd .WriteRune ('\f');case '(':_eacfd .WriteRune ('(');case ')':_eacfd .WriteRune (')');case '\\':_eacfd .WriteRune ('\\');};continue ;}else if _caba [0]=='('{_bbc ++;}else if _caba [0]==')'{_bbc --;if _bbc ==0{_feed ._cedf .ReadByte ();
break ;};};_babe ,_ :=_feed ._cedf .ReadByte ();_eacfd .WriteByte (_babe );};return MakeString (_eacfd .String ()),nil ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_ecab *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ecab .GetFilterName ());
return data ,ErrNoJPXDecode ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_bbdg *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ecfd ,_eeae :=_af .NewDecoder (encoded ,_af .DecodeOptions {Columns :_bbdg .Columns ,Rows :_bbdg .Rows ,K :_bbdg .K ,EncodedByteAligned :_bbdg .EncodedByteAlign ,BlackIsOne :_bbdg .BlackIs1 ,EndOfBlock :_bbdg .EndOfBlock ,EndOfLine :_bbdg .EndOfLine ,DamagedRowsBeforeError :_bbdg .DamagedRowsBeforeError });
if _eeae !=nil {return nil ,_eeae ;};_afdd ,_eeae :=_bg .ReadAll (_ecfd );if _eeae !=nil {return nil ,_eeae ;};return _afdd ,nil ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_ddcf *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ddcf .DecodeBytes (streamObj .Stream );};

// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_dbbcg *PdfParser )GetPreviousRevisionReadSeeker ()(_gdb .ReadSeeker ,error ){if _eabf :=_dbbcg .seekToEOFMarker (_dbbcg ._agde -_baeb );_eabf !=nil {return nil ,_eabf ;};_abgfg ,_beea :=_dbbcg ._ccfe .Seek (0,_gdb .SeekCurrent );if _beea !=nil {return nil ,_beea ;
};_abgfg +=_baeb ;return _efdb (_dbbcg ._ccfe ,_abgfg );};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _bf .Filter ,userPass ,ownerPass []byte ,perm _bba .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_bdg :=&PdfCrypt {_dee :make (map[PdfObject ]bool ),_deb :make (cryptFilters ),_fab :_bba .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _ga Version ;if cf !=nil {_fbg :=cf .PDFVersion ();_ga .Major ,_ga .Minor =_fbg [0],_fbg [1];V ,R :=cf .HandlerVersion ();_bdg ._bde .V =V ;_bdg ._fab .R =R ;_bdg ._bde .Length =cf .KeyLength ()*8;};const (_edg =_fba ;);_bdg ._deb [_edg ]=cf ;if _bdg ._bde .V >=4{_bdg ._caf =_edg ;
_bdg ._fge =_edg ;};_fcd :=_bdg .newEncryptDict ();_aad :=_de .Sum ([]byte (_bb .Now ().Format (_bb .RFC850 )));_gee :=string (_aad [:]);_fdb :=make ([]byte ,100);_ba .Read (_fdb );_aad =_de .Sum (_fdb );_bcg :=string (_aad [:]);_fef .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_fdb );
_fef .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_gee );_bdg ._eeb =_gee ;_abbb :=_bdg .generateParams (userPass ,ownerPass );if _abbb !=nil {return nil ,nil ,_abbb ;};_gca (&_bdg ._fab ,_fcd );if _bdg ._bde .V >=4{if _fcdb :=_bdg .saveCryptFilters (_fcd );
_fcdb !=nil {return nil ,nil ,_fcdb ;};};return _bdg ,&EncryptInfo {Version :_ga ,Encrypt :_fcd ,ID0 :_gee ,ID1 :_bcg },nil ;};func (_eabbgg *PdfParser )xrefNextObjectOffset (_egfc int64 )int64 {_aeeg :=int64 (0);if len (_eabbgg ._aaea .ObjectMap )==0{return 0;
};if len (_eabbgg ._aaea ._ff )==0{_ebcg :=0;for _ ,_fagad :=range _eabbgg ._aaea .ObjectMap {if _fagad .Offset > 0{_ebcg ++;};};if _ebcg ==0{return 0;};_eabbgg ._aaea ._ff =make ([]XrefObject ,_ebcg );_fdbgd :=0;for _ ,_daae :=range _eabbgg ._aaea .ObjectMap {if _daae .Offset > 0{_eabbgg ._aaea ._ff [_fdbgd ]=_daae ;
_fdbgd ++;};};_be .Slice (_eabbgg ._aaea ._ff ,func (_dacg ,_debcd int )bool {return _eabbgg ._aaea ._ff [_dacg ].Offset < _eabbgg ._aaea ._ff [_debcd ].Offset ;});};_aegcg :=_be .Search (len (_eabbgg ._aaea ._ff ),func (_eaed int )bool {return _eabbgg ._aaea ._ff [_eaed ].Offset >=_egfc });
if _aegcg < len (_eabbgg ._aaea ._ff ){_aeeg =_eabbgg ._aaea ._ff [_aegcg ].Offset ;};return _aeeg ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_adbd *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _cefc _gf .Buffer ;for _afc :=0;_afc < len (data );_afc +=4{_cfga :=data [_afc ];_deeda :=1;_cbcg :=byte (0);if _afc +1< len (data ){_cbcg =data [_afc +1];_deeda ++;};_ccaa :=byte (0);
if _afc +2< len (data ){_ccaa =data [_afc +2];_deeda ++;};_ggba :=byte (0);if _afc +3< len (data ){_ggba =data [_afc +3];_deeda ++;};_abaa :=(uint32 (_cfga )<<24)|(uint32 (_cbcg )<<16)|(uint32 (_ccaa )<<8)|uint32 (_ggba );if _abaa ==0{_cefc .WriteByte ('z');
}else {_bdcf :=_adbd .base256Tobase85 (_abaa );for _ ,_efbbf :=range _bdcf [:_deeda +1]{_cefc .WriteByte (_efbbf +'!');};};};_cefc .WriteString ("\u007e\u003e");return _cefc .Bytes (),nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_fafd JBIG2EncoderSettings )Validate ()error {const _gadb ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _fafd .Threshold < 0||_fafd .Threshold > 1.0{return _dg .Errorf (_gadb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_fafd .Threshold );
};if _fafd .ResolutionX < 0{return _dg .Errorf (_gadb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_fafd .ResolutionX );
};if _fafd .ResolutionY < 0{return _dg .Errorf (_gadb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_fafd .ResolutionY );
};if _fafd .DefaultPixelValue !=0&&_fafd .DefaultPixelValue !=1{return _dg .Errorf (_gadb ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_fafd .DefaultPixelValue );
};if _fafd .Compression !=JB2Generic {return _dg .Errorf (_gadb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_gef :=&PdfCrypt {_gbc :false ,_ecd :make (map[PdfObject ]bool ),_dee :make (map[PdfObject ]bool ),_begb :make (map[int ]struct{}),_cfg :parser };_gfc ,_eda :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_eda {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _gef ,_d .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_gfc !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_fef .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_gfc );
return _gef ,_d .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_gef ._bde .Filter =string (*_gfc );if _eged ,_eae :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_eae {_gef ._bde .SubFilter =_eged .Str ();
_fef .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_eged );};if L ,_gffe :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_gffe {if (*L %8)!=0{_fef .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _gef ,_d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_gef ._bde .Length =int (*L );}else {_gef ._bde .Length =40;};_gef ._bde .V =0;if _agbf ,_baca :=ed .Get ("\u0056").(*PdfObjectInteger );
_baca {V :=int (*_agbf );_gef ._bde .V =V ;if V >=1&&V <=2{_gef ._deb =_ffde (_gef ._bde .Length );}else if V >=4&&V <=5{if _abga :=_gef .loadCryptFilters (ed );_abga !=nil {return _gef ,_abga ;};}else {_fef .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _gef ,_d .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _ebe :=_afe (&_gef ._fab ,ed );_ebe !=nil {return _gef ,_ebe ;};_ceg :="";if _cfd ,_geb :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_geb &&_cfd .Len ()>=1{_aba ,_fee :=GetString (_cfd .Get (0));if !_fee {return _gef ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_ceg =_aba .Str ();}else {_fef .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_gef ._eeb =_ceg ;return _gef ,nil ;};func _fgf (_gfgb _gdb .ReadSeeker ,_cfecg int64 )(*offsetReader ,error ){_fcbc :=&offsetReader {_faag :_gfgb ,_ecfe :_cfecg };_ ,_abda :=_fcbc .Seek (0,_gdb .SeekStart );return _fcbc ,_abda ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_agd *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _agd .isDecrypted (obj ){return nil ;};switch _cce :=obj .(type ){case *PdfIndirectObject :_agd ._ecd [_cce ]=true ;_fef .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_cce .ObjectNumber ,_cce .GenerationNumber );
_gcd :=_cce .ObjectNumber ;_dgec :=_cce .GenerationNumber ;_deed :=_agd .Decrypt (_cce .PdfObject ,_gcd ,_dgec );if _deed !=nil {return _deed ;};return nil ;case *PdfObjectStream :_agd ._ecd [_cce ]=true ;_eafe :=_cce .PdfObjectDictionary ;if _agd ._fab .R !=5{if _cbf ,_dbc :=_eafe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_dbc &&*_cbf =="\u0058\u0052\u0065\u0066"{return nil ;};};_fdbc :=_cce .ObjectNumber ;_fbgc :=_cce .GenerationNumber ;_fef .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_fdbc ,_fbgc );
_cfa :=_fba ;if _agd ._bde .V >=4{_cfa =_agd ._caf ;_fef .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_agd ._caf );if _cfgcf ,_ggd :=_eafe .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_ggd {if _aeae ,_badc :=GetName (_cfgcf .Get (0));_badc {if *_aeae =="\u0043\u0072\u0079p\u0074"{_cfa ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _deae ,_dbaf :=_eafe .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_dbaf {if _afgad ,_cbc :=_deae .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_cbc {if _ ,_dfc :=_agd ._deb [string (*_afgad )];_dfc {_fef .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_afgad );
_cfa =string (*_afgad );};};};};};};_fef .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_cfa );if _cfa =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bcad :=_agd .Decrypt (_eafe ,_fdbc ,_fbgc );
if _bcad !=nil {return _bcad ;};_cgd ,_bcad :=_agd .makeKey (_cfa ,uint32 (_fdbc ),uint32 (_fbgc ),_agd ._ac );if _bcad !=nil {return _bcad ;};_cce .Stream ,_bcad =_agd .decryptBytes (_cce .Stream ,_cfa ,_cgd );if _bcad !=nil {return _bcad ;};_eafe .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cce .Stream ))));
return nil ;case *PdfObjectString :_fef .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_fdf :=_fba ;if _agd ._bde .V >=4{_fef .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_agd ._fge );
if _agd ._fge =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_fdf =_agd ._fge ;};_dbaa ,_ada :=_agd .makeKey (_fdf ,uint32 (parentObjNum ),uint32 (parentGenNum ),_agd ._ac );if _ada !=nil {return _ada ;};_fggc :=_cce .Str ();_gfbb :=make ([]byte ,len (_fggc ));
for _daea :=0;_daea < len (_fggc );_daea ++{_gfbb [_daea ]=_fggc [_daea ];};if len (_gfbb )> 0{_fef .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_gfbb ,_gfbb );
_gfbb ,_ada =_agd .decryptBytes (_gfbb ,_fdf ,_dbaa );if _ada !=nil {return _ada ;};};_cce ._deef =string (_gfbb );return nil ;case *PdfObjectArray :for _ ,_bdga :=range _cce .Elements (){_efbg :=_agd .Decrypt (_bdga ,parentObjNum ,parentGenNum );if _efbg !=nil {return _efbg ;
};};return nil ;case *PdfObjectDictionary :_bga :=false ;if _fcf :=_cce .Get ("\u0054\u0079\u0070\u0065");_fcf !=nil {_dbb ,_cdbc :=_fcf .(*PdfObjectName );if _cdbc &&*_dbb =="\u0053\u0069\u0067"{_bga =true ;};};for _ ,_bdgb :=range _cce .Keys (){_geff :=_cce .Get (_bdgb );
if _bga &&string (_bdgb )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_bdgb )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_bdgb )!="\u0050\u0072\u0065\u0076"&&string (_bdgb )!="\u004c\u0061\u0073\u0074"{_bec :=_agd .Decrypt (_geff ,parentObjNum ,parentGenNum );
if _bec !=nil {return _bec ;};};};return nil ;};return nil ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_edeg *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_fef .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_dfgc :=MakeDict ();_dfgc ._bebda =_edeg ;_aefg ,_ :=_edeg ._cedf .ReadByte ();
if _aefg !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_aefg ,_ =_edeg ._cedf .ReadByte ();if _aefg !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");
};for {_edeg .skipSpaces ();_edeg .skipComments ();_fgeb ,_gadbe :=_edeg ._cedf .Peek (2);if _gadbe !=nil {return nil ,_gadbe ;};_fef .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_fgeb ),string (_fgeb ));
if (_fgeb [0]=='>')&&(_fgeb [1]=='>'){_fef .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_edeg ._cedf .ReadByte ();_edeg ._cedf .ReadByte ();break ;};_fef .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");
_debc ,_gadbe :=_edeg .parseName ();_fef .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_debc );if _gadbe !=nil {_fef .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_gadbe );
return nil ,_gadbe ;};if len (_debc )> 4&&_debc [len (_debc )-4:]=="\u006e\u0075\u006c\u006c"{_ccaad :=_debc [0:len (_debc )-4];_fef .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_debc );
_fef .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_ccaad );_edeg .skipSpaces ();_abdf ,_ :=_edeg ._cedf .Peek (1);if _abdf [0]=='/'{_dfgc .Set (_ccaad ,MakeNull ());continue ;};
};_edeg .skipSpaces ();_fcde ,_gadbe :=_edeg .parseObject ();if _gadbe !=nil {return nil ,_gadbe ;};_dfgc .Set (_debc ,_fcde );if _fef .Log .IsLogLevel (_fef .LogLevelTrace ){_fef .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_debc ,_fcde .String ());
};};_fef .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _dfgc ,nil ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_baeaf *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _gaad ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _fggd :=_baeaf .AddPageImage (img ,&_baeaf .DefaultPageSettings );
_fggd !=nil {return nil ,_dg .Wrap (_fggd ,_gaad ,"");};return _baeaf .Encode ();};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_ebda *MultiEncoder )GetFilterArray ()*PdfObjectArray {_agab :=make ([]PdfObject ,len (_ebda ._gebb ));for _aada ,_gage :=range _ebda ._gebb {_agab [_aada ]=MakeName (_gage .GetFilterName ());};return MakeArray (_agab ...);};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fbdd *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_fbdd ._gebb )==0{return nil ;};if len (_fbdd ._gebb )==1{return _fbdd ._gebb [0].MakeDecodeParams ();};_eabba :=MakeArray ();_edab :=true ;for _ ,_dacf :=range _fbdd ._gebb {_fdbg :=_dacf .MakeDecodeParams ();
if _fdbg ==nil {_eabba .Append (MakeNull ());}else {_edab =false ;_eabba .Append (_fdbg );};};if _edab {return nil ;};return _eabba ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_gccd *PdfParser )GetCrypter ()*PdfCrypt {return _gccd ._fffgf };func (_bgb *PdfParser )lookupByNumber (_cea int ,_bd bool )(PdfObject ,bool ,error ){_caa ,_aegc :=_bgb .ObjCache [_cea ];if _aegc {_fef .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_cea );
return _caa ,false ,nil ;};if _bgb ._edebg ==nil {_bgb ._edebg =map[int ]bool {};};if _bgb ._edebg [_cea ]{_fef .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_cea );
return nil ,false ,_d .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_bgb ._edebg [_cea ]=true ;defer delete (_bgb ._edebg ,_cea );
_dab ,_aegc :=_bgb ._aaea .ObjectMap [_cea ];if !_aegc {_fef .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _faa PdfObjectNull ;return &_faa ,false ,nil ;};_fef .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_cea );if _dab .XType ==XrefTypeTableEntry {_fef .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_dab .ObjectNumber );
_fef .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_dab .Generation );_fef .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_dab .Offset );
_bgb ._ccfe .Seek (_dab .Offset ,_gdb .SeekStart );_bgb ._cedf =_dd .NewReader (_bgb ._ccfe );_cd ,_fcc :=_bgb .ParseIndirectObject ();if _fcc !=nil {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_fcc );
if _bd {_fef .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_eab ,_cda :=_bgb .repairRebuildXrefsTopDown ();
if _cda !=nil {_fef .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_cda );return nil ,false ,_cda ;};_bgb ._aaea =*_eab ;return _bgb .lookupByNumber (_cea ,false );
};return nil ,false ,_fcc ;};if _bd {_egg ,_ ,_ :=_ceb (_cd );if int (_egg )!=_cea {_fef .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_ged :=_bgb .rebuildXrefTable ();
if _ged !=nil {return nil ,false ,_ged ;};_bgb .ObjCache =objectCache {};return _bgb .lookupByNumberWrapper (_cea ,false );};};_fef .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_bgb .ObjCache [_cea ]=_cd ;
return _cd ,false ,nil ;}else if _dab .XType ==XrefTypeObjectStream {_fef .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_fef .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_fef .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_dab .OsObjNumber ,_dab .OsObjIndex );
if _dab .OsObjNumber ==_cea {_fef .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_d .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_dcf :=_bgb ._aaea .ObjectMap [_dab .OsObjNumber ];_dcf {_ddac ,_dbd :=_bgb .lookupObjectViaOS (_dab .OsObjNumber ,_cea );if _dbd !=nil {_fef .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_dbd );
return nil ,true ,_dbd ;};_fef .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_bgb .ObjCache [_cea ]=_ddac ;if _bgb ._fffgf !=nil {_bgb ._fffgf ._ecd [_ddac ]=true ;};return _ddac ,true ,nil ;};_fef .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_d .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_d .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//
//	renamed to String() as a pretty string to use in debugging etc.
func (_fcfab *MultiEncoder )GetFilterName ()string {_bbdf :="";for _ceec ,_fbcc :=range _fcfab ._gebb {_bbdf +=_fbcc .GetFilterName ();if _ceec < len (_fcfab ._gebb )-1{_bbdf +="\u0020";};};return _bbdf ;};

// String returns the state of the bool as "true" or "false".
func (_cegc *PdfObjectBool )String ()string {if *_cegc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_ddgb *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ddgb .setWithLock (key ,val ,true );};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_cdbd *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_cdbd ._aecea .Lock ();defer _cdbd ._aecea .Unlock ();_debga ,_dbbe :=_cdbd ._efca [key ];if !_dbbe {return nil ;};return _debga ;};type objectCache map[int ]PdfObject ;

// Len returns the number of elements in the array.
func (_fcaf *PdfObjectArray )Len ()int {if _fcaf ==nil {return 0;};return len (_fcaf ._bdfag );};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_caead *PdfObjectBool ,_eagd bool ){_caead ,_eagd =TraceToDirectObject (obj ).(*PdfObjectBool );return _caead ,_eagd ;};

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_efd ParserMetadata )HasOddLengthHexStrings ()bool {return _efd ._dcbc };const (_bfgg =0;_aeaed =1;_dcag =2;_eacf =3;_cga =4;);

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eabb *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_dfef :=MakeDict ();_dfef .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_eabb .GetFilterName ()));return _dfef ;};func (_ddacb *PdfParser )getNumbersOfUpdatedObjects (_edbfd *PdfParser )([]int ,error ){if _edbfd ==nil {return nil ,_d .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_ecabf :=_edbfd ._agde ;_bfcb :=make ([]int ,0);_bdea :=make (map[int ]interface{});_cdgc :=make (map[int ]int64 );for _gceac ,_cagga :=range _ddacb ._aaea .ObjectMap {if _cagga .Offset ==0{if _cagga .OsObjNumber !=0{if _geef ,_ggca :=_ddacb ._aaea .ObjectMap [_cagga .OsObjNumber ];
_ggca {_bdea [_cagga .OsObjNumber ]=struct{}{};_cdgc [_gceac ]=_geef .Offset ;}else {return nil ,_d .New ("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065");};};}else {_cdgc [_gceac ]=_cagga .Offset ;};};
for _ebdg ,_dgaf :=range _cdgc {if _ ,_gedb :=_bdea [_ebdg ];_gedb {continue ;};if _dgaf > _ecabf {_bfcb =append (_bfcb ,_ebdg );};};return _bfcb ,nil ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_beb *JBIG2Encoder )Encode ()(_gffb []byte ,_cbce error ){const _gbcgc ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _beb ._aca ==nil {return nil ,_dg .Errorf (_gbcgc ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_beb ._aca .FullHeaders =_beb .DefaultPageSettings .FileMode ;_gffb ,_cbce =_beb ._aca .Encode ();if _cbce !=nil {return nil ,_dg .Wrap (_cbce ,_gbcgc ,"");};return _gffb ,nil ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_gadd *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_ddde error ){const _baeae ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _gadd ==nil {return _dg .Error (_baeae ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_gadd .DefaultPageSettings ;};if _gadd ._aca ==nil {_gadd ._aca =_ce .InitEncodeDocument (settings .FileMode );
};if _ddde =settings .Validate ();_ddde !=nil {return _dg .Wrap (_ddde ,_baeae ,"");};_agdb ,_ddde :=img .toBitmap ();if _ddde !=nil {return _dg .Wrap (_ddde ,_baeae ,"");};switch settings .Compression {case JB2Generic :if _ddde =_gadd ._aca .AddGenericPage (_agdb ,settings .DuplicatedLinesRemoval );
_ddde !=nil {return _dg .Wrap (_ddde ,_baeae ,"");};case JB2SymbolCorrelation :return _dg .Error (_baeae ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _dg .Error (_baeae ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _dg .Error (_baeae ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// UpdateParams updates the parameter values of the encoder.
func (_cgaa *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_fcfe ,_cgae :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _cgae ==nil {_cgaa .ColorComponents =int (_fcfe );
};_gbae ,_cgae :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _cgae ==nil {_cgaa .BitsPerComponent =int (_gbae );};_gbge ,_cgae :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _cgae ==nil {_cgaa .Width =int (_gbge );};_fccd ,_cgae :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _cgae ==nil {_cgaa .Height =int (_fccd );};_agg ,_cgae :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _cgae ==nil {_cgaa .Quality =int (_agg );};_gfbcf ,_dceg :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));if _dceg {_cgaa .Decode ,_cgae =_gfbcf .ToFloat64Array ();if _cgae !=nil {_fef .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020de\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006eto\u0020\u0061r\u0072\u0061\u0079\u0073\u003a\u0020\u0025\u0076",_cgae );
};};};

// UpdateParams updates the parameter values of the encoder.
func (_badd *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _gdb .ReadSeeker )(_daeb *PdfParser ,_dfeg error ){_daeb =&PdfParser {_ccfe :rs ,ObjCache :make (objectCache ),_bccc :map[int64 ]bool {},_fece :true ,_aade :make (map[*PdfParser ]*PdfParser )};if _dfeg =_daeb .parseDetailedHeader ();
_dfeg !=nil {return nil ,_dfeg ;};if _daeb ._fdef ,_dfeg =_daeb .loadXrefs ();_dfeg !=nil {_fef .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_dfeg );
return nil ,_dfeg ;};_fef .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_daeb ._fdef );if len (_daeb ._aaea .ObjectMap )==0{return nil ,_fc .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _daeb ,nil ;};type cryptFilters map[string ]_bf .Filter ;

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_aeee float64 ,_cgebd bool ){_faca ,_cgebd :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _cgebd {return float64 (*_faca ),true ;};return 0,false ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;
);

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_bdecb *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _bdecb ._abbc };

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_gdbca *PdfParser )GetPreviousRevisionParser ()(*PdfParser ,error ){if _gdbca ._bcaef ==0{return nil ,_d .New ("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e");};if _aafge ,_ccea :=_gdbca ._aade [_gdbca ];
_ccea {return _aafge ,nil ;};_cdafg ,_gedgf :=_gdbca .GetPreviousRevisionReadSeeker ();if _gedgf !=nil {return nil ,_gedgf ;};_gdeeg ,_gedgf :=NewParser (_cdafg );_gdeeg ._aade =_gdbca ._aade ;if _gedgf !=nil {return nil ,_gedgf ;};_gdbca ._aade [_gdbca ]=_gdeeg ;
return _gdeeg ,nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_fddc *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_fddc ._ccfe .Seek (offset ,_gdb .SeekStart );_fddc ._cedf =_dd .NewReader (_fddc ._ccfe );};func (_efe *PdfCrypt )saveCryptFilters (_gfba *PdfObjectDictionary )error {if _efe ._bde .V < 4{return _d .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_cbe :=MakeDict ();_gfba .Set ("\u0043\u0046",_cbe );for _aea ,_cdb :=range _efe ._deb {if _aea =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_agf :=_daf (_cdb ,"");_cbe .Set (PdfObjectName (_aea ),_agf );};_gfba .Set ("\u0053\u0074\u0072\u0046",MakeName (_efe ._fge ));
_gfba .Set ("\u0053\u0074\u006d\u0046",MakeName (_efe ._caf ));return nil ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _bbacg :=obj .(type ){case *PdfObjectFloat :_fef .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_bbacg ),nil ;case *PdfObjectInteger :return int64 (*_bbacg ),nil ;case *PdfObjectReference :_ggge :=TraceToDirectObject (obj );return GetNumberAsInt64 (_ggge );case *PdfIndirectObject :return GetNumberAsInt64 (_bbacg .PdfObject );};return 0,ErrNotANumber ;
};func (_gggb *FlateEncoder )postDecodePredict (_ecbd []byte )([]byte ,error ){if _gggb .Predictor > 1{if _gggb .Predictor ==2{_fef .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_fef .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_gggb .Colors );
_fagd :=_gggb .Columns *_gggb .Colors ;if _fagd < 1{return []byte {},nil ;};_ccgbg :=len (_ecbd )/_fagd ;if len (_ecbd )%_fagd !=0{_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_fc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ecbd ),_fagd );};if _fagd %_gggb .Colors !=0{return nil ,_fc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_fagd ,_gggb .Colors );
};if _fagd > len (_ecbd ){_fef .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fagd ,len (_ecbd ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fef .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_ecbd ),_ecbd );
_gbff :=_gf .NewBuffer (nil );for _fea :=0;_fea < _ccgbg ;_fea ++{_fec :=_ecbd [_fagd *_fea :_fagd *(_fea +1)];for _gfa :=_gggb .Colors ;_gfa < _fagd ;_gfa ++{_fec [_gfa ]+=_fec [_gfa -_gggb .Colors ];};_gbff .Write (_fec );};_gdf :=_gbff .Bytes ();_fef .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_gdf ),_gdf );
return _gdf ,nil ;}else if _gggb .Predictor >=10&&_gggb .Predictor <=15{_fef .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ddgc :=_gggb .Columns *_gggb .Colors +1;_adf :=len (_ecbd )/_ddgc ;if len (_ecbd )%_ddgc !=0{return nil ,_fc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ecbd ),_ddgc );
};if _ddgc > len (_ecbd ){_fef .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ddgc ,len (_ecbd ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_geec :=_gf .NewBuffer (nil );_fef .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_gggb .Columns );
_fef .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_ecbd ),_ddgc ,_adf );_gedf :=make ([]byte ,_ddgc );for _acdd :=0;_acdd < _ddgc ;_acdd ++{_gedf [_acdd ]=0;
};_fcdc :=_gggb .Colors ;for _bgdf :=0;_bgdf < _adf ;_bgdf ++{_faga :=_ecbd [_ddgc *_bgdf :_ddgc *(_bgdf +1)];_fbbc :=_faga [0];switch _fbbc {case _bfgg :case _aeaed :for _eedag :=1+_fcdc ;_eedag < _ddgc ;_eedag ++{_faga [_eedag ]+=_faga [_eedag -_fcdc ];
};case _dcag :for _bfb :=1;_bfb < _ddgc ;_bfb ++{_faga [_bfb ]+=_gedf [_bfb ];};case _eacf :for _bef :=1;_bef < _fcdc +1;_bef ++{_faga [_bef ]+=_gedf [_bef ]/2;};for _daff :=_fcdc +1;_daff < _ddgc ;_daff ++{_faga [_daff ]+=byte ((int (_faga [_daff -_fcdc ])+int (_gedf [_daff ]))/2);
};case _cga :for _fgc :=1;_fgc < _ddgc ;_fgc ++{var _ffef ,_becc ,_abbe byte ;_becc =_gedf [_fgc ];if _fgc >=_fcdc +1{_ffef =_faga [_fgc -_fcdc ];_abbe =_gedf [_fgc -_fcdc ];};_faga [_fgc ]+=_fcccf (_ffef ,_becc ,_abbe );};default:_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_fbbc ,_bgdf );
return nil ,_fc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fbbc );};copy (_gedf ,_faga );_geec .Write (_faga [1:]);};_bee :=_geec .Bytes ();return _bee ,nil ;
}else {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_gggb .Predictor );return nil ,_fc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_gggb .Predictor );
};};return _ecbd ,nil ;};var _fgfa =_aa .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_cfc *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _cfc .isEncrypted (obj ){return nil ;};switch _bda :=obj .(type ){case *PdfIndirectObject :_cfc ._dee [_bda ]=true ;_fef .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_bda .ObjectNumber ,_bda .GenerationNumber );
_dgeg :=_bda .ObjectNumber ;_cfe :=_bda .GenerationNumber ;_ead :=_cfc .Encrypt (_bda .PdfObject ,_dgeg ,_cfe );if _ead !=nil {return _ead ;};return nil ;case *PdfObjectStream :_cfc ._dee [_bda ]=true ;_aceac :=_bda .PdfObjectDictionary ;if _ebee ,_gdbb :=_aceac .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_gdbb &&*_ebee =="\u0058\u0052\u0065\u0066"{return nil ;};_gdd :=_bda .ObjectNumber ;_cgdg :=_bda .GenerationNumber ;_fef .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gdd ,_cgdg );
_gaa :=_fba ;if _cfc ._bde .V >=4{_gaa =_cfc ._caf ;_fef .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_cfc ._caf );if _cdd ,_ede :=_aceac .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_ede {if _bfee ,_eeda :=GetName (_cdd .Get (0));_eeda {if *_bfee =="\u0043\u0072\u0079p\u0074"{_gaa ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bcf ,_gcc :=_aceac .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_gcc {if _dbdg ,_eadc :=_bcf .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_eadc {if _ ,_ecg :=_cfc ._deb [string (*_dbdg )];_ecg {_fef .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_dbdg );
_gaa =string (*_dbdg );};};};};};};_fef .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gaa );if _gaa =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bed :=_cfc .Encrypt (_bda .PdfObjectDictionary ,_gdd ,_cgdg );
if _bed !=nil {return _bed ;};_dgc ,_bed :=_cfc .makeKey (_gaa ,uint32 (_gdd ),uint32 (_cgdg ),_cfc ._ac );if _bed !=nil {return _bed ;};_bda .Stream ,_bed =_cfc .encryptBytes (_bda .Stream ,_gaa ,_dgc );if _bed !=nil {return _bed ;};_aceac .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bda .Stream ))));
return nil ;case *PdfObjectString :_fef .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_ccgbc :=_fba ;if _cfc ._bde .V >=4{_fef .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_cfc ._fge );
if _cfc ._fge =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_ccgbc =_cfc ._fge ;};_gfbc ,_ecdc :=_cfc .makeKey (_ccgbc ,uint32 (parentObjNum ),uint32 (parentGenNum ),_cfc ._ac );if _ecdc !=nil {return _ecdc ;};_gdbe :=_bda .Str ();
_bcfb :=make ([]byte ,len (_gdbe ));for _add :=0;_add < len (_gdbe );_add ++{_bcfb [_add ]=_gdbe [_add ];};_fef .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bcfb ,_bcfb );
_bcfb ,_ecdc =_cfc .encryptBytes (_bcfb ,_ccgbc ,_gfbc );if _ecdc !=nil {return _ecdc ;};_bda ._deef =string (_bcfb );return nil ;case *PdfObjectArray :for _ ,_bff :=range _bda .Elements (){_gdc :=_cfc .Encrypt (_bff ,parentObjNum ,parentGenNum );if _gdc !=nil {return _gdc ;
};};return nil ;case *PdfObjectDictionary :_bgga :=false ;if _gbb :=_bda .Get ("\u0054\u0079\u0070\u0065");_gbb !=nil {_acd ,_cbg :=_gbb .(*PdfObjectName );if _cbg &&*_acd =="\u0053\u0069\u0067"{_bgga =true ;};};for _ ,_ccc :=range _bda .Keys (){_effg :=_bda .Get (_ccc );
if _bgga &&string (_ccc )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_ccc )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_ccc )!="\u0050\u0072\u0065\u0076"&&string (_ccc )!="\u004c\u0061\u0073\u0074"{_bcff :=_cfc .Encrypt (_effg ,parentObjNum ,parentGenNum );
if _bcff !=nil {return _bcff ;};};};return nil ;};return nil ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_bdfag []PdfObject };

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _acbg _gf .Buffer ;_acbg .Write ([]byte {0xFE,0xFF});_acbg .WriteString (_bab .StringToUTF16 (s ));return &PdfObjectString {_deef :_acbg .String (),_gdggc :true };};return &PdfObjectString {_deef :string (_bab .StringToPDFDocEncoding (s )),_gdggc :false };
};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_ebbg *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_fecfg :=PdfObjectFloat (val );return &_fecfg };

// Bytes returns the PdfObjectString content as a []byte array.
func (_fgeab *PdfObjectString )Bytes ()[]byte {return []byte (_fgeab ._deef )};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_bf .FilterDict ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_efca map[PdfObjectName ]PdfObject ;_bbdc []PdfObjectName ;_aecea *_c .Mutex ;_bebda *PdfParser ;};

// SetImage sets the image base for given flate encoder.
func (_caff *FlateEncoder )SetImage (img *_bc .ImageBase ){_caff ._gce =img };func (_bebc *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_bebc ._cedf )};const _fcea =10;var (ErrUnsupportedEncodingParameters =_d .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");
ErrNoCCITTFaxDecode =_d .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_d .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_d .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_dc .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_d .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);

// GetXrefType returns the type of the first xref object (table or stream).
func (_defb *PdfParser )GetXrefType ()*xrefType {return _defb ._debe };

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _cfgb ,_bbbef :=obj .(*PdfObjectReference );_bbbef {return _cfgb .Resolve ();};return obj ;};func (_ddaga *ASCII85Encoder )base256Tobase85 (_cadf uint32 )[5]byte {_fbgd :=[5]byte {0,0,0,0,0};_dbbgae :=_cadf ;
for _dgag :=0;_dgag < 5;_dgag ++{_fcca :=uint32 (1);for _bgbg :=0;_bgbg < 4-_dgag ;_bgbg ++{_fcca *=85;};_bead :=_dbbgae /_fcca ;_dbbgae =_dbbgae %_fcca ;_fbgd [_dgag ]=byte (_bead );};return _fbgd ;};

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_egfgg *PdfParser )GetRevision (revisionNumber int )(*PdfParser ,error ){_adcb :=_egfgg ._bcaef ;if _adcb ==revisionNumber {return _egfgg ,nil ;};if _adcb < revisionNumber {return nil ,_d .New ("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e");
};if _egfgg ._ecaf [revisionNumber ]!=nil {return _egfgg ._ecaf [revisionNumber ],nil ;};_dfga :=_egfgg ;for ;_adcb > revisionNumber ;_adcb --{_cbgg ,_edcac :=_dfga .GetPreviousRevisionParser ();if _edcac !=nil {return nil ,_edcac ;};_egfgg ._ecaf [_adcb -1]=_cbgg ;
_egfgg ._aade [_dfga ]=_cbgg ;_dfga =_cbgg ;};return _dfga ,nil ;};func (_fecf *PdfParser )skipSpaces ()(int ,error ){_edfc :=0;for {_cgaf ,_gaga :=_fecf ._cedf .ReadByte ();if _gaga !=nil {return 0,_gaga ;};if IsWhiteSpace (_cgaf ){_edfc ++;}else {_fecf ._cedf .UnreadByte ();
break ;};};return _edfc ,nil ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_afge *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _dccd :=val .(type ){case *PdfObjectName :if _dccd !=nil {_afge .Set (key ,val );};case *PdfObjectDictionary :if _dccd !=nil {_afge .Set (key ,val );
};case *PdfObjectStream :if _dccd !=nil {_afge .Set (key ,val );};case *PdfObjectString :if _dccd !=nil {_afge .Set (key ,val );};case *PdfObjectNull :if _dccd !=nil {_afge .Set (key ,val );};case *PdfObjectInteger :if _dccd !=nil {_afge .Set (key ,val );
};case *PdfObjectArray :if _dccd !=nil {_afge .Set (key ,val );};case *PdfObjectBool :if _dccd !=nil {_afge .Set (key ,val );};case *PdfObjectFloat :if _dccd !=nil {_afge .Set (key ,val );};case *PdfObjectReference :if _dccd !=nil {_afge .Set (key ,val );
};case *PdfIndirectObject :if _dccd !=nil {_afge .Set (key ,val );};default:_fef .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// GetFilterName returns the name of the encoding filter.
func (_egd *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_gebbf *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _fbffd []float64 ;for _ ,_acfb :=range _gebbf .Elements (){_adadb ,_dgeca :=GetNumberAsFloat (TraceToDirectObject (_acfb ));if _dgeca !=nil {return nil ,_fc .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_fbffd =append (_fbffd ,_adadb );};return _fbffd ,nil ;};func _dcegg (_gfgab int )int {if _gfgab < 0{return -_gfgab ;};return _gfgab ;};

// WriteString outputs the object as it is to be written to file.
func (_efbd *PdfObjectArray )WriteString ()string {var _fegfe _fe .Builder ;_fegfe .WriteString ("\u005b");for _abbcc ,_fbccb :=range _efbd .Elements (){_fegfe .WriteString (_fbccb .WriteString ());if _abbcc < (_efbd .Len ()-1){_fegfe .WriteString ("\u0020");
};};_fegfe .WriteString ("\u005d");return _fegfe .String ();};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_fege *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _bcge _gf .Buffer ;for _ ,_gaee :=range data {_bcge .WriteString (_fc .Sprintf ("\u0025\u002e\u0032X\u0020",_gaee ));};_bcge .WriteByte ('>');return _bcge .Bytes (),nil ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_fbac *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };func (_cad *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_cbad :=MakeDict ();_cbad .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));
_cbad .Set ("\u0056",MakeInteger (int64 (_cad ._bde .V )));_cbad .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_cad ._bde .Length )));return _cbad ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cdda *LZWEncoder )MakeDecodeParams ()PdfObject {if _cdda .Predictor > 1{_dbafa :=MakeDict ();_dbafa .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_cdda .Predictor )));if _cdda .BitsPerComponent !=8{_dbafa .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_cdda .BitsPerComponent )));
};if _cdda .Columns !=1{_dbafa .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_cdda .Columns )));};if _cdda .Colors !=1{_dbafa .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_cdda .Colors )));};return _dbafa ;};return nil ;
};func (_ggbd *PdfParser )parseObject ()(PdfObject ,error ){_fef .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_ggbd .skipSpaces ();for {_ecgb ,_agdg :=_ggbd ._cedf .Peek (2);if _agdg !=nil {if _agdg !=_gdb .EOF ||len (_ecgb )==0{return nil ,_agdg ;
};if len (_ecgb )==1{_ecgb =append (_ecgb ,' ');};};_fef .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_ecgb ));if _ecgb [0]=='/'{_accd ,_bdfb :=_ggbd .parseName ();_fef .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_accd );
return &_accd ,_bdfb ;}else if _ecgb [0]=='('{_fef .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_ddacf ,_edbc :=_ggbd .parseString ();return _ddacf ,_edbc ;}else if _ecgb [0]=='['{_fef .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");
_baee ,_gcad :=_ggbd .parseArray ();return _baee ,_gcad ;}else if (_ecgb [0]=='<')&&(_ecgb [1]=='<'){_fef .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_gefef ,_cagg :=_ggbd .ParseDict ();return _gefef ,_cagg ;}else if _ecgb [0]=='<'{_fef .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");
_gfbcfb ,_cdaf :=_ggbd .parseHexString ();return _gfbcfb ,_cdaf ;}else if _ecgb [0]=='%'{_ggbd .readComment ();_ggbd .skipSpaces ();}else {_fef .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_ecgb ,_ =_ggbd ._cedf .Peek (15);
_fddg :=string (_ecgb );_fef .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_fddg );if (len (_fddg )> 3)&&(_fddg [:4]=="\u006e\u0075\u006c\u006c"){_ffgag ,_ddfb :=_ggbd .parseNull ();return &_ffgag ,_ddfb ;}else if (len (_fddg )> 4)&&(_fddg [:5]=="\u0066\u0061\u006cs\u0065"){_bceg ,_dfafb :=_ggbd .parseBool ();
return &_bceg ,_dfafb ;}else if (len (_fddg )> 3)&&(_fddg [:4]=="\u0074\u0072\u0075\u0065"){_afeb ,_dffc :=_ggbd .parseBool ();return &_afeb ,_dffc ;};_cccg :=_afcc .FindStringSubmatch (_fddg );if len (_cccg )> 1{_ecgb ,_ =_ggbd ._cedf .ReadBytes ('R');
_fef .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_ecgb [:]));_gacb ,_cggd :=_bfbf (string (_ecgb ));_gacb ._begga =_ggbd ;return &_gacb ,_cggd ;};_faba :=_gbffa .FindStringSubmatch (_fddg );if len (_faba )> 1{_fef .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");
_ddaa ,_efea :=_ggbd .parseNumber ();return _ddaa ,_efea ;};_faba =_egfg .FindStringSubmatch (_fddg );if len (_faba )> 1{_fef .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");
_fef .Log .Trace ("\u0025\u0020\u0073",_faba );_adedf ,_aeabe :=_ggbd .parseNumber ();return _adedf ,_aeabe ;};_fef .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_fddg );
return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_abba *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _ddag _gf .Buffer ;_ebeg :=_gf .NewReader (encoded );var _geea _gdb .ReadCloser ;if _abba .EarlyChange ==1{_geea =_dcb .NewReader (_ebeg ,_dcb .MSB ,8);}else {_geea =_gd .NewReader (_ebeg ,_gd .MSB ,8);
};defer _geea .Close ();if _ ,_eaaa :=_ddag .ReadFrom (_geea );_eaaa !=nil {if _eaaa !=_gdb .ErrUnexpectedEOF ||_ddag .Len ()==0{return nil ,_eaaa ;};_fef .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_eaaa );
};return _ddag .Bytes (),nil ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_dd .Reader )(PdfObject ,error ){_eacdd :=false ;_abff :=true ;var _dgde _gf .Buffer ;for {if _fef .Log .IsLogLevel (_fef .LogLevelTrace ){_fef .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_dgde .String ());
};_dcba ,_bgdg :=buf .Peek (1);if _bgdg ==_gdb .EOF {break ;};if _bgdg !=nil {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_bgdg );return nil ,_bgdg ;};if _abff &&(_dcba [0]=='-'||_dcba [0]=='+'){_adeag ,_ :=buf .ReadByte ();_dgde .WriteByte (_adeag );
_abff =false ;}else if IsDecimalDigit (_dcba [0]){_gccdc ,_ :=buf .ReadByte ();_dgde .WriteByte (_gccdc );}else if _dcba [0]=='.'{_gbfc ,_ :=buf .ReadByte ();_dgde .WriteByte (_gbfc );_eacdd =true ;}else if _dcba [0]=='e'||_dcba [0]=='E'{_dacfg ,_ :=buf .ReadByte ();
_dgde .WriteByte (_dacfg );_eacdd =true ;_abff =true ;}else {break ;};};var _gcdg PdfObject ;if _eacdd {_fcbcd ,_aebg :=_b .ParseFloat (_dgde .String (),64);if _aebg !=nil {_fef .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_dgde .String (),_aebg );
_fcbcd =0.0;};_beed :=PdfObjectFloat (_fcbcd );_gcdg =&_beed ;}else {_cadca ,_gdbcc :=_b .ParseInt (_dgde .String (),10,64);if _gdbcc !=nil {_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_dgde .String (),_gdbcc );
_cadca =0;};_dcgac :=PdfObjectInteger (_cadca );_gcdg =&_dcgac ;};return _gcdg ,nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// String returns a descriptive information string about the encryption method used.
func (_eff *PdfCrypt )String ()string {if _eff ==nil {return "";};_ecf :=_eff ._bde .Filter +"\u0020\u002d\u0020";if _eff ._bde .V ==0{_ecf +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _eff ._bde .V ==1{_ecf +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _eff ._bde .V ==2{_ecf +=_fc .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_eff ._bde .Length );}else if _eff ._bde .V ==3{_ecf +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _eff ._bde .V >=4{_ecf +=_fc .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_eff ._caf ,_eff ._fge );
_ecf +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _bdec ,_fff :=range _eff ._deb {_ecf +=_fc .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_bdec ,_fff .Name (),_fff .KeyLength ());
};};_ded :=_eff .GetAccessPermissions ();_ecf +=_fc .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_ded );return _ecf ;};func _adgf ()string {return _fef .Version };

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_accf *MultiEncoder )AddEncoder (encoder StreamEncoder ){_accf ._gebb =append (_accf ._gebb ,encoder );};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};func (_addaf *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){_addaf .skipSpaces ();const _beffg =20;_gaada ,_ :=_addaf ._cedf .Peek (_beffg );for _gcgf :=0;_gcgf < 2;_gcgf ++{if _addaf ._fgfaf ==0{_addaf ._fgfaf =_addaf .GetFileOffset ();
};if _aaff .Match (_gaada ){_fef .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_fef .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_gaada ));return _addaf .parseXrefStream (nil );};if _bcgba .Match (_gaada ){_fef .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _addaf .parseXrefTable ();};_bag :=_addaf .GetFileOffset ();if _addaf ._fgfaf ==0{_addaf ._fgfaf =_bag ;};_addaf .SetFileOffset (_bag -_beffg );defer _addaf .SetFileOffset (_bag );_bdfa ,_ :=_addaf ._cedf .Peek (_beffg );_gaada =append (_bdfa ,_gaada ...);
};_fef .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _gddd :=_addaf .repairSeekXrefMarker ();_gddd !=nil {_fef .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_gddd );return nil ,_gddd ;};return _addaf .parseXrefTable ();};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};func (_fbff *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_ggfe :=_fbff ._cedf .Discard (4);return PdfObjectNull {},_ggfe ;};func (_adggg *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_adggg ._ccfe .Seek (0,_gdb .SeekStart );
_adggg ._cedf =_dd .NewReader (_adggg ._ccfe );_becd :=20;_dag :=make ([]byte ,_becd );for {_acgf ,_dgdf :=_adggg ._cedf .ReadByte ();if _dgdf !=nil {if _dgdf ==_gdb .EOF {break ;}else {return 0,0,_dgdf ;};};if IsDecimalDigit (_acgf )&&_dag [_becd -1]=='.'&&IsDecimalDigit (_dag [_becd -2])&&_dag [_becd -3]=='-'&&_dag [_becd -4]=='F'&&_dag [_becd -5]=='D'&&_dag [_becd -6]=='P'{_adge :=int (_dag [_becd -2]-'0');
_badcd :=int (_acgf -'0');return _adge ,_badcd ,nil ;};_dag =append (_dag [1:_becd ],_acgf );};return 0,0,_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_efgb ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _efgb ._fga };

// String returns a string describing `ind`.
func (_fedg *PdfIndirectObject )String ()string {return _fc .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_fedg ).ObjectNumber );};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_befgf *PdfParser )IsEncrypted ()(bool ,error ){if _befgf ._fffgf !=nil {return true ,nil ;}else if _befgf ._fdef ==nil {return false ,nil ;};_fef .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_abecb :=_befgf ._fdef .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _abecb ==nil {return false ,nil ;};_fef .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_dceea *PdfObjectDictionary ;);switch _egbb :=_abecb .(type ){case *PdfObjectDictionary :_dceea =_egbb ;
case *PdfObjectReference :_fef .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_egbb );_ebac ,_aceg :=_befgf .LookupByReference (*_egbb );_fef .Log .Trace ("\u0031\u003a\u0020%\u0071",_ebac );
if _aceg !=nil {return false ,_aceg ;};_cadc ,_fccac :=_ebac .(*PdfIndirectObject );if !_fccac {_fef .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_bgac ,_fccac :=_cadc .PdfObject .(*PdfObjectDictionary );_befgf ._abbc =_cadc ;_fef .Log .Trace ("\u0032\u003a\u0020%\u0071",_bgac );if !_fccac {return false ,_d .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
};_dceea =_bgac ;case *PdfObjectNull :_fef .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_fc .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_egbb );};_ecae ,_gdae :=PdfCryptNewDecrypt (_befgf ,_dceea ,_befgf ._fdef );if _gdae !=nil {return false ,_gdae ;
};for _ ,_afce :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_baebf :=_befgf ._fdef .Get (PdfObjectName (_afce ));if _baebf ==nil {continue ;};switch _cdfa :=_baebf .(type ){case *PdfObjectReference :_ecae ._begb [int (_cdfa .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_ecae ._ecd [_cdfa ]=true ;_ecae ._begb [int (_cdfa .ObjectNumber )]=struct{}{};};};_befgf ._fffgf =_ecae ;_fef .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_ecae );
return true ,nil ;};

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_dbbf *PdfParser )GetUpdatedObjects (prevParser *PdfParser )(map[int64 ]PdfObject ,error ){if prevParser ==nil {return nil ,_d .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_fgad ,_agcg :=_dbbf .getNumbersOfUpdatedObjects (prevParser );if _agcg !=nil {return nil ,_agcg ;};_bcac :=make (map[int64 ]PdfObject );for _ ,_cadg :=range _fgad {if _eagcf ,_caed :=_dbbf .LookupByNumber (_cadg );_caed ==nil {_bcac [int64 (_cadg )]=_eagcf ;
}else {return nil ,_caed ;};};return _bcac ,nil ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _bcgde :=obj .(type ){case *PdfObjectFloat :return float64 (*_bcgde ),nil ;case *PdfObjectInteger :return float64 (*_bcgde ),nil ;case *PdfObjectReference :_dfgb :=TraceToDirectObject (obj );
return GetNumberAsFloat (_dfgb );case *PdfIndirectObject :return GetNumberAsFloat (_bcgde .PdfObject );};return 0,ErrNotANumber ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_daeag :=PdfObjectInteger (val );return &_daeag };var _debg =_d .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");func (_dgbd *PdfCrypt )encryptBytes (_ffga []byte ,_cff string ,_ffgd []byte )([]byte ,error ){_fef .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_bae ,_dfce :=_dgbd ._deb [_cff ];if !_dfce {return nil ,_fc .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cff );};return _bae .EncryptBytes (_ffga ,_ffgd );};

// GetFilterName returns the name of the encoding filter.
func (_cbcf *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };func _ggfaf (_adea PdfObject ,_gfag int )PdfObject {if _gfag > _fcea {_fef .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_fcea );
return MakeNull ();};switch _gcada :=_adea .(type ){case *PdfIndirectObject :_adea =_ggfaf ((*_gcada ).PdfObject ,_gfag +1);case *PdfObjectArray :for _fffb ,_bcccf :=range (*_gcada )._bdfag {(*_gcada )._bdfag [_fffb ]=_ggfaf (_bcccf ,_gfag +1);};case *PdfObjectDictionary :for _bgbfg ,_edgb :=range (*_gcada )._efca {(*_gcada )._efca [_bgbfg ]=_ggfaf (_edgb ,_gfag +1);
};_be .Slice ((*_gcada )._bbdc ,func (_bgcee ,_gfage int )bool {return (*_gcada )._bbdc [_bgcee ]< (*_gcada )._bbdc [_gfage ]});};return _adea ;};func (_caef *PdfCrypt )checkAccessRights (_ffed []byte )(bool ,_bba .Permissions ,error ){_caae :=_caef .securityHandler ();
_caac ,_eaaf ,_bgd :=_caae .Authenticate (&_caef ._fab ,_ffed );if _bgd !=nil {return false ,0,_bgd ;}else if _eaaf ==0||len (_caac )==0{return false ,0,nil ;};return true ,_eaaf ,nil ;};

// Clear resets the dictionary to an empty state.
func (_aced *PdfObjectDictionary )Clear (){_aced ._bbdc =[]PdfObjectName {};_aced ._efca =map[PdfObjectName ]PdfObject {};_aced ._aecea =&_c .Mutex {};};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_aefb *PdfIndirectObject ,_cgca bool ){obj =ResolveReference (obj );_aefb ,_cgca =obj .(*PdfIndirectObject );return _aefb ,_cgca ;};

// UpdateParams updates the parameter values of the encoder.
func (_begcc *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};func (_dbecc *PdfParser )parseBool ()(PdfObjectBool ,error ){_edcfg ,_aagdb :=_dbecc ._cedf .Peek (4);if _aagdb !=nil {return PdfObjectBool (false ),_aagdb ;};if (len (_edcfg )>=4)&&(string (_edcfg [:4])=="\u0074\u0072\u0075\u0065"){_dbecc ._cedf .Discard (4);
return PdfObjectBool (true ),nil ;};_edcfg ,_aagdb =_dbecc ._cedf .Peek (5);if _aagdb !=nil {return PdfObjectBool (false ),_aagdb ;};if (len (_edcfg )>=5)&&(string (_edcfg [:5])=="\u0066\u0061\u006cs\u0065"){_dbecc ._cedf .Discard (5);return PdfObjectBool (false ),nil ;
};return PdfObjectBool (false ),_d .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_afabd *PdfParser )Decrypt (password []byte )(bool ,error ){if _afabd ._fffgf ==nil {return false ,_d .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_gedge ,_fdfc :=_afabd ._fffgf .authenticate (password );
if _fdfc !=nil {return false ,_fdfc ;};if !_gedge {_gedge ,_fdfc =_afabd ._fffgf .authenticate ([]byte (""));};return _gedge ,_fdfc ;};

// MakeLazy create temporary file for stream to reduce memory usage.
// It can be used for creating PDF with many images.
// Temporary files are removed automatically when Write/WriteToFile is called for creator object.
func (_addef *PdfObjectStream )MakeLazy ()error {if _addef .Lazy {return nil ;};_bcgcd ,_fbeg :=_g .CreateTemp ("","\u0078o\u0062\u006a\u0065\u0063\u0074");if _fbeg !=nil {return _fbeg ;};defer _bcgcd .Close ();_ ,_fbeg =_bcgcd .Write (_addef .Stream );
if _fbeg !=nil {return _fbeg ;};_addef .Lazy =true ;_addef .Stream =nil ;_addef .TempFile =_bcgcd .Name ();return nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_aacdg *PdfObjectString )Decoded ()string {if _aacdg ==nil {return "";};_cgaee :=[]byte (_aacdg ._deef );if len (_cgaee )>=2&&_cgaee [0]==0xFE&&_cgaee [1]==0xFF{return _bab .UTF16ToString (_cgaee [2:]);};return _bab .PDFDocEncodingToString (_cgaee );
};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_bfggg *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dbbga :=_gf .NewReader (encoded );var _fddb []byte ;for {_baed ,_ccfc :=_dbbga .ReadByte ();if _ccfc !=nil {return nil ,_ccfc ;};if _baed > 128{_gbgbb ,_egga :=_dbbga .ReadByte ();
if _egga !=nil {return nil ,_egga ;};for _eccf :=0;_eccf < 257-int (_baed );_eccf ++{_fddb =append (_fddb ,_gbgbb );};}else if _baed < 128{for _caecc :=0;_caecc < int (_baed )+1;_caecc ++{_bdc ,_face :=_dbbga .ReadByte ();if _face !=nil {return nil ,_face ;
};_fddb =append (_fddb ,_bdc );};}else {break ;};};return _fddb ,nil ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};func (_ddf *PdfCrypt )makeKey (_ade string ,_fbde ,_cg uint32 ,_bea []byte )([]byte ,error ){_acb ,_afdg :=_ddf ._deb [_ade ];if !_afdg {return nil ,_fc .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ade );
};return _acb .MakeKey (_fbde ,_cg ,_bea );};func _dcc (_ggff uint ,_cac ,_befg float64 )float64 {return (_cac +(float64 (_ggff )*(_befg -_cac )/255))*255;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_fda *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_ag ,_ ,_gdg :=_fda .lookupByNumberWrapper (objNumber ,true );return _ag ,_gdg ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_bde encryptDict ;_fab _bba .StdEncryptDict ;_eeb string ;_ac []byte ;_ecd map[PdfObject ]bool ;_dee map[PdfObject ]bool ;_gbc bool ;_deb cryptFilters ;_caf string ;_fge string ;_cfg *PdfParser ;_begb map[int ]struct{};};

// GetParser returns the parser for lazy-loading or compare references.
func (_fedfg *PdfObjectReference )GetParser ()*PdfParser {return _fedfg ._begga };

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_geaf []PdfObject ;};func _fbdcd (_agbaa string )(int ,int ,error ){_gdegc :=_aaff .FindStringSubmatch (_agbaa );if len (_gdegc )< 3{return 0,0,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_eaac ,_ :=_b .Atoi (_gdegc [1]);_fbcff ,_ :=_b .Atoi (_gdegc [2]);return _eaac ,_fbcff ,nil ;};func _fbcf (_eddb *PdfObjectDictionary )(_ebae *_bc .ImageBase ){var (_cgad *PdfObjectInteger ;_bgba bool ;);if _cgad ,_bgba =_eddb .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );
_bgba {_ebae =&_bc .ImageBase {Width :int (*_cgad )};}else {return nil ;};if _cgad ,_bgba =_eddb .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_bgba {_ebae .Height =int (*_cgad );};if _cgad ,_bgba =_eddb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_bgba {_ebae .BitsPerComponent =int (*_cgad );};if _cgad ,_bgba =_eddb .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_bgba {_ebae .ColorComponents =int (*_cgad );};return _ebae ;};func (_edb *PdfCrypt )decryptBytes (_ebge []byte ,_geg string ,_ega []byte )([]byte ,error ){_fef .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_ffc ,_bdf :=_edb ._deb [_geg ];if !_bdf {return nil ,_fc .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_geg );};return _ffc .DecryptBytes (_ebge ,_ega );};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_aabgg []byte ,_gcdd bool ){_cebe ,_gcdd :=TraceToDirectObject (obj ).(*PdfObjectString );if _gcdd {return _cebe .Bytes (),true ;};return ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// UpdateParams updates the parameter values of the encoder.
func (_bdeb *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_fgbb *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_caefa :=n ;_efeg :=0;_ffdg :=0;for _caefa > 0{_deee ,_aeaa :=_fgbb ._cedf .Read (p [_efeg :]);if _aeaa !=nil {_fef .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_deee ,_ffdg ,_aeaa .Error ());
return _efeg ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_ffdg ++;_efeg +=_deee ;_caefa -=_deee ;};return _efeg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_fcdba *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };var _bdcdf =_aa .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// HasNonConformantStream implements core.ParserMetadata.
func (_cafd ParserMetadata )HasNonConformantStream ()bool {return _cafd ._bedc };

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _eabg (obj1 ,obj2 ,0)};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_bede *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_bede ._bdfag ){return _d .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_bede ._bdfag [i ]=obj ;return nil ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_gebb []StreamEncoder };func _gff (_aee XrefTable ){_fef .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_fef .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_bgc :=0;for _ ,_fag :=range _aee .ObjectMap {_fef .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_bgc +1,_fag .ObjectNumber ,_fag .Generation ,_fag .Offset );
_bgc ++;};};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
//
//	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _fd .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _ggcb ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_dg .Error (_ggcb ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_efgbg uint8 ;_feade _bc .Image ;_cbd error ;);if bwThreshold ==JB2ImageAutoThreshold {_feade ,_cbd =_bc .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_dg .Error (_ggcb ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_efgbg =uint8 (255*bwThreshold );_feade ,_cbd =_bc .MonochromeThresholdConverter (_efgbg ).Convert (i );};if _cbd !=nil {return nil ,_cbd ;};return _cdeff (_feade ),nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_bdfag :objects }};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_eaeg *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _fgge []float64 ;for _ ,_cdbef :=range _eaeg .Elements (){switch _baff :=_cdbef .(type ){case *PdfObjectInteger :_fgge =append (_fgge ,float64 (*_baff ));case *PdfObjectFloat :_fgge =append (_fgge ,float64 (*_baff ));
default:return nil ,ErrTypeError ;};};return _fgge ,nil ;};

// ParserMetadata gets the pdf parser metadata.
func (_dca *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_dca ._fece {return ParserMetadata {},_fc .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _dca ._bffd ,nil ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_cfge *PdfObjectName ,_bcfa bool ){_cfge ,_bcfa =TraceToDirectObject (obj ).(*PdfObjectName );return _cfge ,_bcfa ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_afccc *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_cbef :=range another .Keys (){_gcfb :=another .Get (_cbef );_afccc .Set (_cbef ,_gcfb );};};return _afccc ;};func (_baeag *PdfParser )repairLocateXref ()(int64 ,error ){_bffgef :=int64 (1000);
_baeag ._ccfe .Seek (-_bffgef ,_gdb .SeekCurrent );_adfd ,_dcdde :=_baeag ._ccfe .Seek (0,_gdb .SeekCurrent );if _dcdde !=nil {return 0,_dcdde ;};_bddba :=make ([]byte ,_bffgef );_baeag ._ccfe .Read (_bddba );_fcbg :=_aeedc .FindAllStringIndex (string (_bddba ),-1);
if len (_fcbg )< 1{_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_d .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");
};_ecge :=int64 (_fcbg [len (_fcbg )-1][0]);_afgda :=_adfd +_ecge ;return _afgda ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_baa *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_cdea :=MakeDict ();_cdea .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_baa .GetFilterName ()));return _cdea ;};const (DefaultJPEGQuality =75;);

// WriteString outputs the object as it is to be written to file.
func (_adeg *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_bcab *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_bdd :=MakeDict ();_bdd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bcab .GetFilterName ()));_ccga :=_bcab .MakeDecodeParams ();if _ccga !=nil {_bdd .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ccga );
};_bdd .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_bcab .EarlyChange )));return _bdd ;};type offsetReader struct{_faag _gdb .ReadSeeker ;_ecfe int64 ;};var _bcgba =_aa .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");
func (_cb *PdfParser )lookupObjectViaOS (_ae int ,_eb int )(PdfObject ,error ){var _ge *_gf .Reader ;var _gb objectStream ;var _ed bool ;_gb ,_ed =_cb ._edaba [_ae ];if !_ed {_ca ,_gc :=_cb .LookupByNumber (_ae );if _gc !=nil {_fef .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_ae );
return nil ,_gc ;};_ddbc ,_dgg :=_ca .(*PdfObjectStream );if !_dgg {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _cb ._fffgf !=nil &&!_cb ._fffgf .isDecrypted (_ddbc ){return nil ,_d .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_eea :=_ddbc .PdfObjectDictionary ;_fef .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_eea .String ());_ddbcf ,_dgg :=_eea .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_dgg {_fef .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _fe .ToLower (string (*_ddbcf ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_d .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_dgg :=_eea .Get ("\u004e").(*PdfObjectInteger );if !_dgg {return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_df ,_dgg :=_eea .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_dgg {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_fef .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ddbcf ,*N );_dda ,_gc :=DecodeStream (_ddbc );if _gc !=nil {return nil ,_gc ;
};_fef .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_dda );_da :=_cb .GetFileOffset ();defer func (){_cb .SetFileOffset (_da )}();_ge =_gf .NewReader (_dda );_cb ._cedf =_dd .NewReader (_ge );_fef .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_bfd :=map[int ]int64 {};for _ffd :=0;_ffd < int (*N );_ffd ++{_cb .skipSpaces ();_cc ,_gfb :=_cb .parseNumber ();if _gfb !=nil {return nil ,_gfb ;};_fed ,_bad :=_cc .(*PdfObjectInteger );if !_bad {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_cb .skipSpaces ();_cc ,_gfb =_cb .parseNumber ();if _gfb !=nil {return nil ,_gfb ;};_afd ,_bad :=_cc .(*PdfObjectInteger );if !_bad {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_fef .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_fed ,*_afd );_bfd [int (*_fed )]=int64 (*_df +*_afd );};_gb =objectStream {N :int (*N ),_ddb :_dda ,_ad :_bfd };_cb ._edaba [_ae ]=_gb ;}else {_gbf :=_cb .GetFileOffset ();
defer func (){_cb .SetFileOffset (_gbf )}();_ge =_gf .NewReader (_gb ._ddb );_cb ._cedf =_dd .NewReader (_ge );};_aec :=_gb ._ad [_eb ];_fef .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_eb ,_aec );
_ge .Seek (_aec ,_gdb .SeekStart );_cb ._cedf =_dd .NewReader (_ge );_eaa ,_ :=_cb ._cedf .Peek (100);_fef .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_eaa ));_ccg ,_cf :=_cb .parseObject ();if _cf !=nil {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_cf );
return nil ,_cf ;};if _ccg ==nil {return nil ,_d .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_baf :=PdfIndirectObject {};_baf .ObjectNumber =int64 (_eb );_baf .PdfObject =_ccg ;_baf ._begga =_cb ;
return &_baf ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_beaa *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_egab ,_cgf :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _cgf ==nil {_beaa .Predictor =int (_egab );};_bbb ,_cgf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _cgf ==nil {_beaa .BitsPerComponent =int (_bbb );};_ccfb ,_cgf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cgf ==nil {_beaa .Columns =int (_ccfb );};_fdfg ,_cgf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _cgf ==nil {_beaa .Colors =int (_fdfg );};_fffa ,_cgf :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _cgf ==nil {_beaa .EarlyChange =int (_fffa );};};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_fbec *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fef .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_fef .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_fbec .Predictor );
_ece ,_dfec :=_fbec .DecodeBytes (streamObj .Stream );if _dfec !=nil {return nil ,_dfec ;};_fef .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_fef .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_ece ),_ece );
if _fbec .Predictor > 1{if _fbec .Predictor ==2{_fef .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_gcbb :=_fbec .Columns *_fbec .Colors ;if _gcbb < 1{return []byte {},nil ;};_cdef :=len (_ece )/_gcbb ;if len (_ece )%_gcbb !=0{_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_fc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ece ),_gcbb );};if _gcbb %_fbec .Colors !=0{return nil ,_fc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_gcbb ,_fbec .Colors );
};if _gcbb > len (_ece ){_fef .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_gcbb ,len (_ece ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fef .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_ece ),_ece );
_bbaa :=_gf .NewBuffer (nil );for _abfg :=0;_abfg < _cdef ;_abfg ++{_edeb :=_ece [_gcbb *_abfg :_gcbb *(_abfg +1)];for _bcgb :=_fbec .Colors ;_bcgb < _gcbb ;_bcgb ++{_edeb [_bcgb ]=byte (int (_edeb [_bcgb ]+_edeb [_bcgb -_fbec .Colors ])%256);};_bbaa .Write (_edeb );
};_ffcd :=_bbaa .Bytes ();_fef .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_ffcd ),_ffcd );return _ffcd ,nil ;}else if _fbec .Predictor >=10&&_fbec .Predictor <=15{_fef .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_cgcc :=_fbec .Columns *_fbec .Colors +1;if _cgcc < 1{return []byte {},nil ;};_eaff :=len (_ece )/_cgcc ;if len (_ece )%_cgcc !=0{return nil ,_fc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ece ),_cgcc );
};if _cgcc > len (_ece ){_fef .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cgcc ,len (_ece ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_adac :=_gf .NewBuffer (nil );_fef .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_fbec .Columns );
_fef .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_ece ),_cgcc ,_eaff );_ddgd :=make ([]byte ,_cgcc );for _eedbb :=0;_eedbb < _cgcc ;_eedbb ++{_ddgd [_eedbb ]=0;
};for _bcbe :=0;_bcbe < _eaff ;_bcbe ++{_bgff :=_ece [_cgcc *_bcbe :_cgcc *(_bcbe +1)];_ffb :=_bgff [0];switch _ffb {case 0:case 1:for _efgc :=2;_efgc < _cgcc ;_efgc ++{_bgff [_efgc ]=byte (int (_bgff [_efgc ]+_bgff [_efgc -1])%256);};case 2:for _decg :=1;
_decg < _cgcc ;_decg ++{_bgff [_decg ]=byte (int (_bgff [_decg ]+_ddgd [_decg ])%256);};default:_fef .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_ffb );
return nil ,_fc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_ffb );};for _abbg :=0;_abbg < _cgcc ;_abbg ++{_ddgd [_abbg ]=_bgff [_abbg ];};_adac .Write (_bgff [1:]);
};_cdac :=_adac .Bytes ();return _cdac ,nil ;}else {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_fbec .Predictor );
return nil ,_fc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_fbec .Predictor );};};return _ece ,nil ;};func (_gffc *PdfParser )repairSeekXrefMarker ()error {_dafb ,_ddcfb :=_gffc ._ccfe .Seek (0,_gdb .SeekEnd );
if _ddcfb !=nil {return _ddcfb ;};_aabd :=_aa .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _dfdf int64 ;var _ebad int64 =1000;for _dfdf < _dafb {if _dafb <=(_ebad +_dfdf ){_ebad =_dafb -_dfdf ;};_ ,_beba :=_gffc ._ccfe .Seek (-_dfdf -_ebad ,_gdb .SeekEnd );
if _beba !=nil {return _beba ;};_fecd :=make ([]byte ,_ebad );_gffc ._ccfe .Read (_fecd );_fef .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_fecd ));
_cdddf :=_aabd .FindAllStringIndex (string (_fecd ),-1);if _cdddf !=nil {_daef :=_cdddf [len (_cdddf )-1];_fef .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cdddf );_gffc ._ccfe .Seek (-_dfdf -_ebad +int64 (_daef [0]),_gdb .SeekEnd );
_gffc ._cedf =_dd .NewReader (_gffc ._ccfe );for {_effda ,_cggdb :=_gffc ._cedf .Peek (1);if _cggdb !=nil {return _cggdb ;};_fef .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_effda [0],_effda [0]);if !IsWhiteSpace (_effda [0]){break ;
};_gffc ._cedf .Discard (1);};return nil ;};_fef .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_dfdf +=_ebad ;};_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _d .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_dafe *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_fgdc :=data ;var _fdag error ;for _gccaa :=len (_dafe ._gebb )-1;_gccaa >=0;_gccaa --{_gac :=_dafe ._gebb [_gccaa ];_fgdc ,_fdag =_gac .EncodeBytes (_fgdc );if _fdag !=nil {return nil ,_fdag ;
};};return _fgdc ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fcgf *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_dbcg :=MakeDict ();_dbcg .Set ("\u004b",MakeInteger (int64 (_fcgf .K )));_dbcg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fcgf .Columns )));if _fcgf .BlackIs1 {_dbcg .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_fcgf .BlackIs1 ));
};if _fcgf .EncodedByteAlign {_dbcg .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_fcgf .EncodedByteAlign ));};if _fcgf .EndOfLine &&_fcgf .K >=0{_dbcg .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_fcgf .EndOfLine ));
};if _fcgf .Rows !=0&&!_fcgf .EndOfBlock {_dbcg .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_fcgf .Rows )));};if !_fcgf .EndOfBlock {_dbcg .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_fcgf .EndOfBlock ));};if _fcgf .DamagedRowsBeforeError !=0{_dbcg .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_fcgf .DamagedRowsBeforeError )));
};return _dbcg ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_faaaa string ,_bffdc bool ){_fbcbg ,_bffdc :=TraceToDirectObject (obj ).(*PdfObjectString );if _bffdc {return _fbcbg .Str (),true ;};return ;};func (_bcgd *PdfParser )resolveReference (_gccb *PdfObjectReference )(PdfObject ,bool ,error ){_bdbf ,_cbdb :=_bcgd .ObjCache [int (_gccb .ObjectNumber )];
if _cbdb {return _bdbf ,true ,nil ;};_ebcc ,_adce :=_bcgd .LookupByReference (*_gccb );if _adce !=nil {return nil ,false ,_adce ;};_bcgd .ObjCache [int (_gccb .ObjectNumber )]=_ebcc ;return _ebcc ,false ,nil ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_fbca *PdfParser )IsAuthenticated ()bool {return _fbca ._fffgf ._gbc };func _cddd (_effdg *PdfObjectStream ,_bfce *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _gaf ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";
_fcbb :=NewJBIG2Encoder ();_efce :=_effdg .PdfObjectDictionary ;if _efce ==nil {return _fcbb ,nil ;};if _bfce ==nil {_aagd :=_efce .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _aagd !=nil {switch _bcdd :=_aagd .(type ){case *PdfObjectDictionary :_bfce =_bcdd ;
case *PdfObjectArray :if _bcdd .Len ()==1{if _dbac ,_cgcge :=GetDict (_bcdd .Get (0));_cgcge {_bfce =_dbac ;};};default:_fef .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_aagd );
return nil ,_dg .Errorf (_gaf ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_bcdd );};};};if _bfce ==nil {return _fcbb ,nil ;};_fcbb .UpdateParams (_bfce );
_bgab ,_fbf :=GetStream (_bfce .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_fbf {return _fcbb ,nil ;};var _abgae error ;_fcbb .Globals ,_abgae =_ee .DecodeGlobals (_bgab .Stream );if _abgae !=nil {_abgae =_dg .Wrap (_abgae ,_gaf ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_fef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_abgae );return nil ,_abgae ;};return _fcbb ,nil ;};

// Len returns the number of elements in the streams.
func (_baadf *PdfObjectStreams )Len ()int {if _baadf ==nil {return 0;};return len (_baadf ._geaf );};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_dggbg *PdfParser )GetFileOffset ()int64 {_faagf ,_ :=_dggbg ._ccfe .Seek (0,_gdb .SeekCurrent );_faagf -=int64 (_dggbg ._cedf .Buffered ());return _faagf ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_cdgef :=TraceToDirectObject (obj ).(*PdfObjectNull );return _cdgef ;};

// GetRevisionNumber returns the current version of the Pdf document.
func (_faade *PdfParser )GetRevisionNumber ()int {return _faade ._bcaef };

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_egfaf :=PdfObjectNull {};return &_egfaf };var _gead =_aa .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// Remove removes an element specified by key.
func (_fbfc *PdfObjectDictionary )Remove (key PdfObjectName ){_egbbc :=-1;for _dfegg ,_aeabc :=range _fbfc ._bbdc {if _aeabc ==key {_egbbc =_dfegg ;break ;};};if _egbbc >=0{_fbfc ._bbdc =append (_fbfc ._bbdc [:_egbbc ],_fbfc ._bbdc [_egbbc +1:]...);delete (_fbfc ._efca ,key );
};};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_efga *PdfObjectDictionary ,_fcag bool ){_efga ,_fcag =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _efga ,_fcag ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_bggg :=MultiEncoder {};_bggg ._gebb =[]StreamEncoder {};return &_bggg ;};var _bffdb =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");


// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_bfgc *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ee .DecodeBytes (encoded ,_afg .Parameters {},_bfgc .Globals );};func (_bcgeg *PdfParser )skipComments ()error {if _ ,_edbf :=_bcgeg .skipSpaces ();_edbf !=nil {return _edbf ;
};_ecdg :=true ;for {_dbead ,_fdea :=_bcgeg ._cedf .Peek (1);if _fdea !=nil {_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_fdea .Error ());return _fdea ;};if _ecdg &&_dbead [0]!='%'{return nil ;};_ecdg =false ;if (_dbead [0]!='\r')&&(_dbead [0]!='\n'){_bcgeg ._cedf .ReadByte ();
}else {break ;};};return _bcgeg .skipComments ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bgad *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_gfcee :=MakeDict ();_gfcee .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bgad .GetFilterName ()));return _gfcee ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};func _egead (_eecc ,_bgdbb ,_aabe int )error {if _bgdbb < 0||_bgdbb > _eecc {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _aabe < _bgdbb {return _d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _aabe > _eecc {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_efeef *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_bcec :=_gf .NewReader (data );var _feae []byte ;var _fcfb []byte ;_gfdc ,_effa :=_bcec .ReadByte ();if _effa ==_gdb .EOF {return []byte {},nil ;}else if _effa !=nil {return nil ,_effa ;
};_adb :=1;for {_gfcf ,_acf :=_bcec .ReadByte ();if _acf ==_gdb .EOF {break ;}else if _acf !=nil {return nil ,_acf ;};if _gfcf ==_gfdc {if len (_fcfb )> 0{_fcfb =_fcfb [:len (_fcfb )-1];if len (_fcfb )> 0{_feae =append (_feae ,byte (len (_fcfb )-1));_feae =append (_feae ,_fcfb ...);
};_adb =1;_fcfb =[]byte {};};_adb ++;if _adb >=127{_feae =append (_feae ,byte (257-_adb ),_gfdc );_adb =0;};}else {if _adb > 0{if _adb ==1{_fcfb =[]byte {_gfdc };}else {_feae =append (_feae ,byte (257-_adb ),_gfdc );};_adb =0;};_fcfb =append (_fcfb ,_gfcf );
if len (_fcfb )>=127{_feae =append (_feae ,byte (len (_fcfb )-1));_feae =append (_feae ,_fcfb ...);_fcfb =[]byte {};};};_gfdc =_gfcf ;};if len (_fcfb )> 0{_feae =append (_feae ,byte (len (_fcfb )-1));_feae =append (_feae ,_fcfb ...);}else if _adb > 0{_feae =append (_feae ,byte (257-_adb ),_gfdc );
};_feae =append (_feae ,128);return _feae ,nil ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_aca *_ce .Document ;

// Globals are the JBIG2 global segments.
Globals _ee .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_acbb :=PdfObjectBool (val );return &_acbb };

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// Append appends PdfObject(s) to the streams.
func (_dfgcc *PdfObjectStreams )Append (objects ...PdfObject ){if _dfgcc ==nil {_fef .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_dfgcc ._geaf =append (_dfgcc ._geaf ,objects ...);};func (_beab *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_gdb .SeekStart {offset +=_beab ._ecfe ;};_acfc ,_fafg :=_beab ._faag .Seek (offset ,whence );if _fafg !=nil {return _acfc ,_fafg ;
};if whence ==_gdb .SeekCurrent {_acfc -=_beab ._ecfe ;};if _acfc < 0{return 0,_d .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _acfc ,nil ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};func (_affc *offsetReader )Read (p []byte )(_fggg int ,_bgbc error ){return _affc ._faag .Read (p )};func _eddg (_bcbg *PdfObjectStream ,_abag *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;
};func (_ddcb *JBIG2Image )toBitmap ()(_eaeb *_ea .Bitmap ,_ccfbg error ){const _fddf ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _ddcb .Data ==nil {return nil ,_dg .Error (_fddf ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _ddcb .Width ==0||_ddcb .Height ==0{return nil ,_dg .Error (_fddf ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _ddcb .HasPadding {_eaeb ,_ccfbg =_ea .NewWithData (_ddcb .Width ,_ddcb .Height ,_ddcb .Data );}else {_eaeb ,_ccfbg =_ea .NewWithUnpaddedData (_ddcb .Width ,_ddcb .Height ,_ddcb .Data );};if _ccfbg !=nil {return nil ,_dg .Wrap (_ccfbg ,_fddf ,"");
};return _eaeb ,nil ;};

// GetXrefOffset returns the offset of the xref table.
func (_bccf *PdfParser )GetXrefOffset ()int64 {return _bccf ._fgfaf };

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// Append appends PdfObject(s) to the array.
func (_fefgg *PdfObjectArray )Append (objects ...PdfObject ){if _fefgg ==nil {_fef .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_fefgg ._bdfag =append (_fefgg ._bdfag ,objects ...);};func (_faaa *PdfParser )parseLinearizedDictionary ()(*PdfObjectDictionary ,error ){_ddfaf ,_ggef :=_faaa ._ccfe .Seek (0,_gdb .SeekEnd );if _ggef !=nil {return nil ,_ggef ;};var _agcgb int64 ;
var _fefg int64 =2048;for _agcgb < _ddfaf -4{if _ddfaf <=(_fefg +_agcgb ){_fefg =_ddfaf -_agcgb ;};_ ,_bgdd :=_faaa ._ccfe .Seek (_agcgb ,_gdb .SeekStart );if _bgdd !=nil {return nil ,_bgdd ;};_fdcc :=make ([]byte ,_fefg );_ ,_bgdd =_faaa ._ccfe .Read (_fdcc );
if _bgdd !=nil {return nil ,_bgdd ;};_fef .Log .Trace ("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022",string (_fdcc ));
_aacf :=_aaff .FindAllStringIndex (string (_fdcc ),-1);if _aacf !=nil {_fgef :=_aacf [0];_fef .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_aacf );_ ,_bcddc :=_faaa ._ccfe .Seek (int64 (_fgef [0]),_gdb .SeekStart );if _bcddc !=nil {return nil ,_bcddc ;
};_faaa ._cedf =_dd .NewReader (_faaa ._ccfe );_ecag ,_bcddc :=_faaa .ParseIndirectObject ();if _bcddc !=nil {return nil ,nil ;};if _acad ,_fagga :=GetIndirect (_ecag );_fagga {if _abbgg ,_babeb :=GetDict (_acad .PdfObject );_babeb {if _gdcac :=_abbgg .Get ("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064");
_gdcac !=nil {return _abbgg ,nil ;};return nil ,nil ;};};return nil ,nil ;};_agcgb +=_fefg -4;};return nil ,_d .New ("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064");
};func (_acee *PdfCrypt )generateParams (_cfag ,_dbdbb []byte )error {_eddf :=_acee .securityHandler ();_gbda ,_bgce :=_eddf .GenerateParams (&_acee ._fab ,_dbdbb ,_cfag );if _bgce !=nil {return _bgce ;};_acee ._ac =_gbda ;return nil ;};

// Seek implementation of Seek interface.
func (_cecd *limitedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){var _aecd int64 ;switch whence {case _gdb .SeekStart :_aecd =offset ;case _gdb .SeekCurrent :_cfdd ,_dfda :=_cecd ._dgae .Seek (0,_gdb .SeekCurrent );if _dfda !=nil {return 0,_dfda ;
};_aecd =_cfdd +offset ;case _gdb .SeekEnd :_aecd =_cecd ._adedd +offset ;};if _gefee :=_cecd .getError (_aecd );_gefee !=nil {return 0,_gefee ;};if _ ,_acab :=_cecd ._dgae .Seek (_aecd ,_gdb .SeekStart );_acab !=nil {return 0,_acab ;};return _aecd ,nil ;
};

// DecodeStream implements ASCII hex decoding.
func (_ggfa *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ggfa .DecodeBytes (streamObj .Stream );};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_aagg *PdfObjectString ,_facb bool ){_aagg ,_facb =TraceToDirectObject (obj ).(*PdfObjectString );return _aagg ,_facb ;};

// GetFilterName returns the name of the encoding filter.
func (_cecb *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// String returns a string describing `ref`.
func (_ccgbf *PdfObjectReference )String ()string {return _fc .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_ccgbf .ObjectNumber ,_ccgbf .GenerationNumber );};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_egdd .Store (filterName ,customStreamEncoder );};

// WriteString outputs the object as it is to be written to file.
func (_dfcd *PdfObjectStream )WriteString ()string {var _cgba _fe .Builder ;_cgba .WriteString (_b .FormatInt (_dfcd .ObjectNumber ,10));_cgba .WriteString ("\u0020\u0030\u0020\u0052");return _cgba .String ();};

// String returns a string describing `null`.
func (_eagf *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_ddaae :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_ddaae .PdfObjectDictionary =encoder .MakeStreamDict ();_bgfff ,_feaa :=encoder .EncodeBytes (contents );
if _feaa !=nil {return nil ,_feaa ;};_ddaae .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bgfff ))));_ddaae .Stream =_bgfff ;return _ddaae ,nil ;};func _afe (_fbd *_bba .StdEncryptDict ,_bdb *PdfObjectDictionary )error {R ,_abg :=_bdb .Get ("\u0052").(*PdfObjectInteger );
if !_abg {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _fc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );
};_fbd .R =int (*R );O ,_abg :=_bdb .GetString ("\u004f");if !_abg {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _fbd .R ==5||_fbd .R ==6{if len (O )< 48{return _fc .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));
};}else if len (O )!=32{return _fc .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_fbd .O =[]byte (O );U ,_abg :=_bdb .GetString ("\u0055");if !_abg {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");
};if _fbd .R ==5||_fbd .R ==6{if len (U )< 48{return _fc .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_fef .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));
};_fbd .U =[]byte (U );if _fbd .R >=5{OE ,_ffdb :=_bdb .GetString ("\u004f\u0045");if !_ffdb {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");
}else if len (OE )!=32{return _fc .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_fbd .OE =[]byte (OE );UE ,_ffdb :=_bdb .GetString ("\u0055\u0045");if !_ffdb {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _fc .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_fbd .UE =[]byte (UE );};P ,_abg :=_bdb .Get ("\u0050").(*PdfObjectInteger );if !_abg {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_fbd .P =_bba .Permissions (*P );if _fbd .R ==6{Perms ,_bca :=_bdb .GetString ("\u0050\u0065\u0072m\u0073");if !_bca {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _fc .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_fbd .Perms =[]byte (Perms );};if _ffg ,_gae :=_bdb .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_gae {_fbd .EncryptMetadata =bool (*_ffg );}else {_fbd .EncryptMetadata =true ;};return nil ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;Decode []float64 ;};

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_cfad ParserMetadata )HasInvalidHexRunes ()bool {return _cfad ._gdda };

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;func (_adca *PdfParser )parseName ()(PdfObjectName ,error ){var _dgbdb _gf .Buffer ;_cdc :=false ;for {_ffgb ,_ddga :=_adca ._cedf .Peek (1);if _ddga ==_gdb .EOF {break ;};if _ddga !=nil {return PdfObjectName (_dgbdb .String ()),_ddga ;
};if !_cdc {if _ffgb [0]=='/'{_cdc =true ;_adca ._cedf .ReadByte ();}else if _ffgb [0]=='%'{_adca .readComment ();_adca .skipSpaces ();}else {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_ffgb ,_ffgb );
return PdfObjectName (_dgbdb .String ()),_fc .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_ffgb [0]);};}else {if IsWhiteSpace (_ffgb [0]){break ;}else if (_ffgb [0]=='/')||(_ffgb [0]=='[')||(_ffgb [0]=='(')||(_ffgb [0]==']')||(_ffgb [0]=='<')||(_ffgb [0]=='>'){break ;
}else if _ffgb [0]=='#'{_cadfb ,_cged :=_adca ._cedf .Peek (3);if _cged !=nil {return PdfObjectName (_dgbdb .String ()),_cged ;};_gbce ,_cged :=_beg .DecodeString (string (_cadfb [1:3]));if _cged !=nil {_fef .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_dgbdb .WriteByte ('#');_adca ._cedf .Discard (1);continue ;};_adca ._cedf .Discard (3);_dgbdb .Write (_gbce );}else {_eafeg ,_ :=_adca ._cedf .ReadByte ();_dgbdb .WriteByte (_eafeg );};};};return PdfObjectName (_dgbdb .String ()),nil ;};func (_ecdd *PdfParser )rebuildXrefTable ()error {_dddf :=XrefTable {};
_dddf .ObjectMap =map[int ]XrefObject {};_gbbb :=make ([]int ,0,len (_ecdd ._aaea .ObjectMap ));for _cdbcc :=range _ecdd ._aaea .ObjectMap {_gbbb =append (_gbbb ,_cdbcc );};_be .Ints (_gbbb );for _ ,_dbba :=range _gbbb {_accdd :=_ecdd ._aaea .ObjectMap [_dbba ];
_ggcd ,_ ,_cgbd :=_ecdd .lookupByNumberWrapper (_dbba ,false );if _cgbd !=nil {_fef .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_cgbd );
_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_adegg ,_fbfe :=_ecdd .repairRebuildXrefsTopDown ();if _fbfe !=nil {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_fbfe );
return _fbfe ;};_ecdd ._aaea =*_adegg ;_fef .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_acaf ,_fgbf ,_cgbd :=_ceb (_ggcd );if _cgbd !=nil {return _cgbd ;
};_accdd .ObjectNumber =int (_acaf );_accdd .Generation =int (_fgbf );_dddf .ObjectMap [int (_acaf )]=_accdd ;};_ecdd ._aaea =_dddf ;_fef .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_gff (_ecdd ._aaea );
return nil ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _gdb .ReadSeeker )(*PdfParser ,error ){_effc :=&PdfParser {_ccfe :rs ,ObjCache :make (objectCache ),_bccc :map[int64 ]bool {},_defdg :make ([]int64 ,0),_aade :make (map[*PdfParser ]*PdfParser )};_cggb ,_acag ,_cagc :=_effc .parsePdfVersion ();
if _cagc !=nil {_fef .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_cagc );return nil ,_cagc ;};_effc ._ddfc .Major =_cggb ;_effc ._ddfc .Minor =_acag ;
if _effc ._fdef ,_cagc =_effc .loadXrefs ();_cagc !=nil {_fef .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_cagc );return nil ,_cagc ;
};_fef .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_effc ._fdef );_fgebe ,_cagc :=_effc .parseLinearizedDictionary ();if _cagc !=nil {return nil ,_cagc ;};if _fgebe !=nil {_effc ._fdbf ,_cagc =_effc .checkLinearizedInformation (_fgebe );
if _cagc !=nil {return nil ,_cagc ;};};if len (_effc ._aaea .ObjectMap )==0{return nil ,_fc .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};
_effc ._bcaef =len (_effc ._defdg );if _effc ._fdbf &&_effc ._bcaef !=0{_effc ._bcaef --;};_effc ._ecaf =make ([]*PdfParser ,_effc ._bcaef );return _effc ,nil ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _ggfaf (obj ,0)};const _fba ="\u0053\u0074\u0064C\u0046";

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_aadf *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _edbcc []int64 ;for _ ,_ddab :=range _aadf .Elements (){if _ggeb ,_gfga :=_ddab .(*PdfObjectInteger );_gfga {_edbcc =append (_edbcc ,int64 (*_ggeb ));}else {return nil ,ErrTypeError ;};};
return _edbcc ,nil ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_debd :=&PdfIndirectObject {};_debd .PdfObject =obj ;return _debd ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_cdbefd int ,_bgef bool ){_bgaga ,_bgef :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _bgef &&_bgaga !=nil {return int (*_bgaga ),true ;};return 0,false ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_bcfbf *PdfObjectDictionary );EncodeBytes (_cabg []byte )([]byte ,error );DecodeBytes (_ecc []byte )([]byte ,error );
DecodeStream (_bcade *PdfObjectStream )([]byte ,error );};const _cdge =32<<(^uint (0)>>63);

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_fffad *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fcga :=_gf .NewReader (encoded );var _efbbc []byte ;for {_cbbg ,_gbbe :=_fcga .ReadByte ();if _gbbe !=nil {return nil ,_gbbe ;};if _cbbg =='>'{break ;};if IsWhiteSpace (_cbbg ){continue ;
};if (_cbbg >='a'&&_cbbg <='f')||(_cbbg >='A'&&_cbbg <='F')||(_cbbg >='0'&&_cbbg <='9'){_efbbc =append (_efbbc ,_cbbg );}else {_fef .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_cbbg );
return nil ,_fc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_cbbg );};};if len (_efbbc )%2==1{_efbbc =append (_efbbc ,'0');
};_fef .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_efbbc );_cdba :=make ([]byte ,_beg .DecodedLen (len (_efbbc )));_ ,_ddfa :=_beg .Decode (_cdba ,_efbbc );if _ddfa !=nil {return nil ,_ddfa ;};return _cdba ,nil ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_eabc *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eabc .DecodeBytes (streamObj .Stream );};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_gcbd *PdfObjectFloat ,_daead bool ){_gcbd ,_daead =TraceToDirectObject (obj ).(*PdfObjectFloat );return _gcbd ,_daead ;};

// Read implementation of Read interface.
func (_bdcd *limitedReadSeeker )Read (p []byte )(_ebgf int ,_badb error ){_bdac ,_badb :=_bdcd ._dgae .Seek (0,_gdb .SeekCurrent );if _badb !=nil {return 0,_badb ;};_gfdcf :=_bdcd ._adedd -_bdac ;if _gfdcf ==0{return 0,_gdb .EOF ;};if _fccf :=int64 (len (p ));
_fccf < _gfdcf {_gfdcf =_fccf ;};_edecg :=make ([]byte ,_gfdcf );_ebgf ,_badb =_bdcd ._dgae .Read (_edecg );copy (p ,_edecg );return _ebgf ,_badb ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_edec *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_edec .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};func _gege (_abd *PdfObjectStream ,_cfab *PdfObjectDictionary )(*FlateEncoder ,error ){_feg :=NewFlateEncoder ();_gad :=_abd .PdfObjectDictionary ;if _gad ==nil {return _feg ,nil ;};_feg ._gce =_fbcf (_gad );
if _cfab ==nil {_aece :=TraceToDirectObject (_gad .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _afgc :=_aece .(type ){case *PdfObjectArray :if _afgc .Len ()!=1{_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_afgc .Len ());
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _aag ,_addd :=GetDict (_afgc .Get (0));_addd {_cfab =_aag ;};case *PdfObjectDictionary :_cfab =_afgc ;case *PdfObjectNull ,nil :default:_fef .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_aece );
return nil ,_fc .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cfab ==nil {return _feg ,nil ;};_fef .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cfab .String ());
_aafg :=_cfab .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _aafg ==nil {_fef .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_dad ,_cef :=_aafg .(*PdfObjectInteger );if !_cef {_fef .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_aafg );
return nil ,_fc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_feg .Predictor =int (*_dad );};_aafg =_cfab .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _aafg !=nil {_feff ,_fdfb :=_aafg .(*PdfObjectInteger );if !_fdfb {_fef .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_fc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_feg .BitsPerComponent =int (*_feff );};if _feg .Predictor > 1{_feg .Columns =1;_aafg =_cfab .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _aafg !=nil {_eaad ,_ddc :=_aafg .(*PdfObjectInteger );if !_ddc {return nil ,_fc .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_feg .Columns =int (*_eaad );
};_feg .Colors =1;_aafg =_cfab .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _aafg !=nil {_eaae ,_bcc :=_aafg .(*PdfObjectInteger );if !_bcc {return nil ,_fc .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_feg .Colors =int (*_eaae );};};return _feg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dggb *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_eaee *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_begcf :=_eaee .GetFileOffset ();_ ,_gafc :=_eaee ._ccfe .Seek (offset ,_gdb .SeekStart );if _gafc !=nil {return nil ,_gafc ;};_ggde :=make ([]byte ,len );_ ,_gafc =_gdb .ReadAtLeast (_eaee ._ccfe ,_ggde ,int (len ));
if _gafc !=nil {return nil ,_gafc ;};_eaee .SetFileOffset (_begcf );return _ggde ,nil ;};func _fbgf (_ffbg PdfObject ,_faadf int ,_cgfe map[PdfObject ]struct{})error {_fef .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_faadf );
if _ ,_aedc :=_cgfe [_ffbg ];_aedc {_fef .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_cgfe [_ffbg ]=struct{}{};switch _degf :=_ffbg .(type ){case *PdfIndirectObject :_cfee :=_degf ;
_fef .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_cfee );_fef .Log .Trace ("\u002d\u0020\u0025\u0073",_cfee .PdfObject );return _fbgf (_cfee .PdfObject ,_faadf +1,_cgfe );case *PdfObjectStream :_cfed :=_degf ;return _fbgf (_cfed .PdfObjectDictionary ,_faadf +1,_cgfe );
case *PdfObjectDictionary :_efae :=_degf ;_fef .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_efae );for _ ,_ecda :=range _efae .Keys (){_edgg :=_efae .Get (_ecda );if _gfbcd ,_bece :=_edgg .(*PdfObjectReference );_bece {_bfage :=_gfbcd .Resolve ();
_efae .Set (_ecda ,_bfage );_eeade :=_fbgf (_bfage ,_faadf +1,_cgfe );if _eeade !=nil {return _eeade ;};}else {_fgfb :=_fbgf (_edgg ,_faadf +1,_cgfe );if _fgfb !=nil {return _fgfb ;};};};return nil ;case *PdfObjectArray :_ggcag :=_degf ;_fef .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_ggcag );
for _edfbg ,_ccdb :=range _ggcag .Elements (){if _ddbg ,_cdbf :=_ccdb .(*PdfObjectReference );_cdbf {_bafb :=_ddbg .Resolve ();_ggcag .Set (_edfbg ,_bafb );_ccaaa :=_fbgf (_bafb ,_faadf +1,_cgfe );if _ccaaa !=nil {return _ccaaa ;};}else {_ebce :=_fbgf (_ccdb ,_faadf +1,_cgfe );
if _ebce !=nil {return _ebce ;};};};return nil ;case *PdfObjectReference :_fef .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _d .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};type limitedReadSeeker struct{_dgae _gdb .ReadSeeker ;_adedd int64 ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_agabe *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_fgea ,_gcae :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _gcae ==nil {_agabe .BitsPerComponent =int (_fgea );
};_cfcb ,_gcae :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _gcae ==nil {_agabe .Width =int (_cfcb );};_edca ,_gcae :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _gcae ==nil {_agabe .Height =int (_edca );
};_bfecc ,_gcae :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _gcae ==nil {_agabe .ColorComponents =int (_bfecc );};};func (_gbdab *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _gbdab ._dcac {return nil ,_fc .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_gbdab ._dcac =true ;_gbdab ._ccfe .Seek (0,_gdb .SeekStart );_gbdab ._cedf =_dd .NewReader (_gbdab ._ccfe );_eedcd :=20;_cbffc :=make ([]byte ,_eedcd );_ccdg :=XrefTable {};_ccdg .ObjectMap =make (map[int ]XrefObject );for {_bagd ,_bbf :=_gbdab ._cedf .ReadByte ();
if _bbf !=nil {if _bbf ==_gdb .EOF {break ;}else {return nil ,_bbf ;};};if _bagd =='j'&&_cbffc [_eedcd -1]=='b'&&_cbffc [_eedcd -2]=='o'&&IsWhiteSpace (_cbffc [_eedcd -3]){_cbbd :=_eedcd -4;for IsWhiteSpace (_cbffc [_cbbd ])&&_cbbd > 0{_cbbd --;};if _cbbd ==0||!IsDecimalDigit (_cbffc [_cbbd ]){continue ;
};for IsDecimalDigit (_cbffc [_cbbd ])&&_cbbd > 0{_cbbd --;};if _cbbd ==0||!IsWhiteSpace (_cbffc [_cbbd ]){continue ;};for IsWhiteSpace (_cbffc [_cbbd ])&&_cbbd > 0{_cbbd --;};if _cbbd ==0||!IsDecimalDigit (_cbffc [_cbbd ]){continue ;};for IsDecimalDigit (_cbffc [_cbbd ])&&_cbbd > 0{_cbbd --;
};if _cbbd ==0{continue ;};_gcggd :=_gbdab .GetFileOffset ()-int64 (_eedcd -_cbbd );_ffcf :=append (_cbffc [_cbbd +1:],_bagd );_dggg ,_dgafd ,_cfgee :=_fbdcd (string (_ffcf ));if _cfgee !=nil {_fef .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_cfgee );
return nil ,_cfgee ;};if _aebe ,_caebg :=_ccdg .ObjectMap [_dggg ];!_caebg ||_aebe .Generation < _dgafd {_ebea :=XrefObject {};_ebea .XType =XrefTypeTableEntry ;_ebea .ObjectNumber =_dggg ;_ebea .Generation =_dgafd ;_ebea .Offset =_gcggd ;_ccdg .ObjectMap [_dggg ]=_ebea ;
};};_cbffc =append (_cbffc [1:_eedcd ],_bagd );};_gbdab ._edebg =nil ;return &_ccdg ,nil ;};

// String returns a string describing `array`.
func (_faedc *PdfObjectArray )String ()string {_gdaeb :="\u005b";for _ddec ,_cabed :=range _faedc .Elements (){_gdaeb +=_cabed .String ();if _ddec < (_faedc .Len ()-1){_gdaeb +="\u002c\u0020";};};_gdaeb +="\u005d";return _gdaeb ;};func _cdeff (_defd _bc .Image )*JBIG2Image {_gdcg :=_defd .Base ();
return &JBIG2Image {Data :_gdcg .Data ,Width :_gdcg .Width ,Height :_gdcg .Height ,HasPadding :true };};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_fbaf *PdfObjectArray ,_ebdd bool ){_fbaf ,_ebdd =TraceToDirectObject (obj ).(*PdfObjectArray );return _fbaf ,_ebdd ;};

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_fbc ParserMetadata )HasDataAfterEOF ()bool {return _fbc ._fgga };type objectStream struct{N int ;_ddb []byte ;_ad map[int ]int64 ;};

// Clear resets the array to an empty state.
func (_aaec *PdfObjectArray )Clear (){_aaec ._bdfag =[]PdfObject {}};var _aaff =_aa .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_fffe *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _cgcgb []byte ;_fef .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_cabe :=0;_eag :=false ;for _cabe < len (encoded )&&!_eag {_gbcg :=[5]byte {0,0,0,0,0};
_ecgg :=0;_aeab :=0;_gbfb :=4;for _aeab < 5+_ecgg {if _cabe +_aeab ==len (encoded ){break ;};_eceg :=encoded [_cabe +_aeab ];if IsWhiteSpace (_eceg ){_ecgg ++;_aeab ++;continue ;}else if _eceg =='~'&&_cabe +_aeab +1< len (encoded )&&encoded [_cabe +_aeab +1]=='>'{_gbfb =(_aeab -_ecgg )-1;
if _gbfb < 0{_gbfb =0;};_eag =true ;break ;}else if _eceg >='!'&&_eceg <='u'{_eceg -='!';}else if _eceg =='z'&&_aeab -_ecgg ==0{_gbfb =4;_aeab ++;break ;}else {_fef .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_gbcg [_aeab -_ecgg ]=_eceg ;_aeab ++;};_cabe +=_aeab ;for _agbd :=_gbfb +1;_agbd < 5;_agbd ++{_gbcg [_agbd ]=84;
};_dcbd :=uint32 (_gbcg [0])*85*85*85*85+uint32 (_gbcg [1])*85*85*85+uint32 (_gbcg [2])*85*85+uint32 (_gbcg [3])*85+uint32 (_gbcg [4]);_bgbf :=[]byte {byte ((_dcbd >>24)&0xff),byte ((_dcbd >>16)&0xff),byte ((_dcbd >>8)&0xff),byte (_dcbd &0xff)};_cgcgb =append (_cgcgb ,_bgbf [:_gbfb ]...);
};_fef .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_fef .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_cgcgb );
return _cgcgb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_defdd *PdfObjectFloat )WriteString ()string {return _b .FormatFloat (float64 (*_defdd ),'f',-1,64);};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_acce *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _bfece ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _acce .ColorComponents !=1||_acce .BitsPerComponent !=1{return nil ,_dg .Errorf (_bfece ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_fabg *_ea .Bitmap ;_edaf error ;);_cfaf :=(_acce .Width *_acce .Height )==len (data );if _cfaf {_fabg ,_edaf =_ea .NewWithUnpaddedData (_acce .Width ,_acce .Height ,data );}else {_fabg ,_edaf =_ea .NewWithData (_acce .Width ,_acce .Height ,data );
};if _edaf !=nil {return nil ,_edaf ;};_gcgg :=_acce .DefaultPageSettings ;if _edaf =_gcgg .Validate ();_edaf !=nil {return nil ,_dg .Wrap (_edaf ,_bfece ,"");};if _acce ._aca ==nil {_acce ._aca =_ce .InitEncodeDocument (_gcgg .FileMode );};switch _gcgg .Compression {case JB2Generic :if _edaf =_acce ._aca .AddGenericPage (_fabg ,_gcgg .DuplicatedLinesRemoval );
_edaf !=nil {return nil ,_dg .Wrap (_edaf ,_bfece ,"");};case JB2SymbolCorrelation :return nil ,_dg .Error (_bfece ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_dg .Error (_bfece ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_dg .Error (_bfece ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _acce .Encode ();};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _fbgf (o ,0,traversed );};

// String returns a string describing `stream`.
func (_ecfc *PdfObjectStream )String ()string {return _fc .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_ecfc .ObjectNumber ,_ecfc .PdfObjectDictionary );};

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_dbef :=MakeDict ();return _dbef .Update (objmap );};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_gbgg *JBIG2Image )ToGoImage ()(_fd .Image ,error ){const _dcbb ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _gbgg .Data ==nil {return nil ,_dg .Error (_dcbb ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _gbgg .Width ==0||_gbgg .Height ==0{return nil ,_dg .Error (_dcbb ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_begg ,_gfdb :=_bc .NewImage (_gbgg .Width ,_gbgg .Height ,1,1,_gbgg .Data ,nil ,nil );if _gfdb !=nil {return nil ,_gfdb ;};return _begg ,nil ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_agfg :=&LZWEncoder {};_agfg .Predictor =1;_agfg .BitsPerComponent =8;_agfg .Colors =1;_agfg .Columns =1;_agfg .EarlyChange =1;return _agfg ;};func (_bcgdc *PdfObjectFloat )String ()string {return _fc .Sprintf ("\u0025\u0066",*_bcgdc )};


// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_afgd *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_afgd ._geaf ){return _d .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_afgd ._geaf [i ]=obj ;return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_gbfa *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_fceg :=MakeDict ();_fceg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gbfa .GetFilterName ()));_fcfa :=_gbfa .MakeDecodeParams ();if _fcfa !=nil {_fceg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_fcfa );
};return _fceg ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_fef .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cbea ,_efbbg :=NewEncoderFromStream (streamObj );if _efbbg !=nil {_fef .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_efbbg );
return _efbbg ;};if _defg ,_aebb :=_cbea .(*LZWEncoder );_aebb {_defg .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_fef .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_cbea );
_decgb ,_efbbg :=_cbea .EncodeBytes (streamObj .Stream );if _efbbg !=nil {_fef .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_efbbg );return _efbbg ;
};streamObj .Stream =_decgb ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_decgb ))));return nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_cbga *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bdbc :=_gf .NewReader (encoded );_gcg ,_agge :=_f .Decode (_bdbc );if _agge !=nil {_fef .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_agge );
return nil ,_agge ;};_bcca :=_gcg .Bounds ();var _agc =make ([]byte ,_bcca .Dx ()*_bcca .Dy ()*_cbga .ColorComponents *_cbga .BitsPerComponent /8);_cfef :=0;switch _cbga .ColorComponents {case 1:_egea :=[]float64 {_cbga .Decode [0],_cbga .Decode [1]};for _afa :=_bcca .Min .Y ;
_afa < _bcca .Max .Y ;_afa ++{for _dgdc :=_bcca .Min .X ;_dgdc < _bcca .Max .X ;_dgdc ++{_afb :=_gcg .At (_dgdc ,_afa );if _cbga .BitsPerComponent ==16{_fbda ,_adc :=_afb .(_db .Gray16 );if !_adc {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_bcae :=_dcc (uint (_fbda .Y >>8),_egea [0],_egea [1]);_gag :=_dcc (uint (_fbda .Y ),_egea [0],_egea [1]);_agc [_cfef ]=byte (_bcae );_cfef ++;_agc [_cfef ]=byte (_gag );_cfef ++;}else {_gcca ,_cgcb :=_afb .(_db .Gray );if !_cgcb {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_agc [_cfef ]=byte (_dcc (uint (_gcca .Y ),_egea [0],_egea [1]));_cfef ++;};};};case 3:_ddd :=[]float64 {_cbga .Decode [0],_cbga .Decode [1]};_bcd :=[]float64 {_cbga .Decode [2],_cbga .Decode [3]};_faab :=[]float64 {_cbga .Decode [4],_cbga .Decode [5]};
for _gbcd :=_bcca .Min .Y ;_gbcd < _bcca .Max .Y ;_gbcd ++{for _bfbb :=_bcca .Min .X ;_bfbb < _bcca .Max .X ;_bfbb ++{_gdga :=_gcg .At (_bfbb ,_gbcd );if _cbga .BitsPerComponent ==16{_cbba ,_deg :=_gdga .(_db .RGBA64 );if !_deg {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_fgb :=_dcc (uint (_cbba .R >>8),_ddd [0],_ddd [1]);_agdd :=_dcc (uint (_cbba .R ),_ddd [0],_ddd [1]);_dbea :=_dcc (uint (_cbba .G >>8),_bcd [0],_bcd [1]);_cgcg :=_dcc (uint (_cbba .G ),_bcd [0],_bcd [1]);_efgg :=_dcc (uint (_cbba .B >>8),_faab [0],_faab [1]);
_gdca :=_dcc (uint (_cbba .B ),_faab [0],_faab [1]);_agc [_cfef ]=byte (_fgb );_cfef ++;_agc [_cfef ]=byte (_agdd );_cfef ++;_agc [_cfef ]=byte (_dbea );_cfef ++;_agc [_cfef ]=byte (_cgcg );_cfef ++;_agc [_cfef ]=byte (_efgg );_cfef ++;_agc [_cfef ]=byte (_gdca );
_cfef ++;}else {_faddf ,_bbdd :=_gdga .(_db .RGBA );if _bbdd {_cfb :=_dcc (uint (_faddf .R ),_ddd [0],_ddd [1]);_dgcg :=_dcc (uint (_faddf .G ),_bcd [0],_bcd [1]);_daec :=_dcc (uint (_faddf .B ),_faab [0],_faab [1]);_agc [_cfef ]=byte (_cfb );_cfef ++;
_agc [_cfef ]=byte (_dgcg );_cfef ++;_agc [_cfef ]=byte (_daec );_cfef ++;}else {_bdde ,_bffg :=_gdga .(_db .YCbCr );if !_bffg {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_debb ,_aafc ,_feac ,_ :=_bdde .RGBA ();
_ggf :=_dcc (uint (_debb >>8),_ddd [0],_ddd [1]);_adfg :=_dcc (uint (_aafc >>8),_bcd [0],_bcd [1]);_gde :=_dcc (uint (_feac >>8),_faab [0],_faab [1]);_agc [_cfef ]=byte (_ggf );_cfef ++;_agc [_cfef ]=byte (_adfg );_cfef ++;_agc [_cfef ]=byte (_gde );_cfef ++;
};};};};case 4:_bdag :=[]float64 {_cbga .Decode [0],_cbga .Decode [1]};_bfa :=[]float64 {_cbga .Decode [2],_cbga .Decode [3]};_dac :=[]float64 {_cbga .Decode [4],_cbga .Decode [5]};_bfbd :=[]float64 {_cbga .Decode [6],_cbga .Decode [7]};for _aed :=_bcca .Min .Y ;
_aed < _bcca .Max .Y ;_aed ++{for _fbcg :=_bcca .Min .X ;_fbcg < _bcca .Max .X ;_fbcg ++{_cege :=_gcg .At (_fbcg ,_aed );_baad ,_ddeg :=_cege .(_db .CMYK );if !_ddeg {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gbgb :=255-_dcc (uint (_baad .C ),_bdag [0],_bdag [1]);_cffa :=255-_dcc (uint (_baad .M ),_bfa [0],_bfa [1]);_bgfe :=255-_dcc (uint (_baad .Y ),_dac [0],_dac [1]);_adcg :=255-_dcc (uint (_baad .K ),_bfbd [0],_bfbd [1]);_agc [_cfef ]=byte (_gbgb );_cfef ++;
_agc [_cfef ]=byte (_cffa );_cfef ++;_agc [_cfef ]=byte (_bgfe );_cfef ++;_agc [_cfef ]=byte (_adcg );_cfef ++;};};};return _agc ,nil ;};func (_aaed *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _decf *PdfObjectDictionary ;_dcga ,_cecg :=_aaed .readTextLine ();
if _cecg !=nil {return nil ,_cecg ;};if _aaed ._fece &&_fe .Count (_fe .TrimPrefix (_dcga ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_aaed ._bffd ._fga =true ;};_fef .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_dcga );
_cfage :=-1;_ddaf :=0;_dgfg :=false ;_dcdf :="";for {_aaed .skipSpaces ();_ ,_fggf :=_aaed ._cedf .Peek (1);if _fggf !=nil {return nil ,_fggf ;};_dcga ,_fggf =_aaed .readTextLine ();if _fggf !=nil {return nil ,_fggf ;};_dbfg :=_eead .FindStringSubmatch (_dcga );
if len (_dbfg )==0{_egeb :=len (_dcdf )> 0;_dcdf +=_dcga +"\u000a";if _egeb {_dbfg =_eead .FindStringSubmatch (_dcdf );};};if len (_dbfg )==3{if _aaed ._fece &&!_aaed ._bffd ._fadd {var (_bfgf bool ;_fabab int ;);for _ ,_dbdee :=range _dcga {if _a .IsDigit (_dbdee ){if _bfgf {break ;
};continue ;};if !_bfgf {_bfgf =true ;};_fabab ++;};if _fabab > 1{_aaed ._bffd ._fadd =true ;};};_cgafd ,_ :=_b .Atoi (_dbfg [1]);_cdgf ,_ :=_b .Atoi (_dbfg [2]);_cfage =_cgafd ;_ddaf =_cdgf ;_dgfg =true ;_dcdf ="";_fef .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_cfage ,_ddaf );
continue ;};_dgbf :=_fgfa .FindStringSubmatch (_dcga );if len (_dgbf )==4{if !_dgfg {_fef .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_d .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_cddaf ,_ :=_b .ParseInt (_dgbf [1],10,64);_eedc ,_ :=_b .Atoi (_dgbf [2]);_gaff :=_dgbf [3];_dcdf ="";if _fe .ToLower (_gaff )=="\u006e"&&_cddaf > 1{_bdccd ,_fbcb :=_aaed ._aaea .ObjectMap [_cfage ];if !_fbcb ||_eedc > _bdccd .Generation {_eebaf :=XrefObject {ObjectNumber :_cfage ,XType :XrefTypeTableEntry ,Offset :_cddaf ,Generation :_eedc };
_aaed ._aaea .ObjectMap [_cfage ]=_eebaf ;};};_cfage ++;continue ;};if (len (_dcga )> 6)&&(_dcga [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_fef .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_dcga );
if len (_dcga )> 9{_fbddb :=_aaed .GetFileOffset ();_aaed .SetFileOffset (_fbddb -int64 (len (_dcga ))+7);};_aaed .skipSpaces ();_aaed .skipComments ();_fef .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_fef .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_dcga );_decf ,_fggf =_aaed .ParseDict ();_fef .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _fggf !=nil {_fef .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_fggf );return nil ,_fggf ;};break ;};if _dcga =="\u0025\u0025\u0045O\u0046"{_fef .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_d .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_fef .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_dcga );
};_fef .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _aaed ._debe ==nil {_edba :=XrefTypeTableEntry ;_aaed ._debe =&_edba ;};return _decf ,nil ;};

// PdfVersion returns version of the PDF file.
func (_aacd *PdfParser )PdfVersion ()Version {return _aacd ._ddfc };

// WriteString outputs the object as it is to be written to file.
func (_faed *PdfObjectName )WriteString ()string {var _aabg _gf .Buffer ;if len (*_faed )> 127{_fef .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_faed );};_aabg .WriteString ("\u002f");
for _acfa :=0;_acfa < len (*_faed );_acfa ++{_ggda :=(*_faed )[_acfa ];if !IsPrintable (_ggda )||_ggda =='#'||IsDelimiter (_ggda ){_aabg .WriteString (_fc .Sprintf ("\u0023\u0025\u002e2\u0078",_ggda ));}else {_aabg .WriteByte (_ggda );};};return _aabg .String ();
};func (_dbe *PdfParser )parseDetailedHeader ()(_gccf error ){_dbe ._ccfe .Seek (0,_gdb .SeekStart );_dbe ._cedf =_dd .NewReader (_dbe ._ccfe );_abgf :=20;_bbe :=make ([]byte ,_abgf );var (_dcbcc bool ;_ebeeb int ;);for {_dec ,_gba :=_dbe ._cedf .ReadByte ();
if _gba !=nil {if _gba ==_gdb .EOF {break ;}else {return _gba ;};};if IsDecimalDigit (_dec )&&_bbe [_abgf -1]=='.'&&IsDecimalDigit (_bbe [_abgf -2])&&_bbe [_abgf -3]=='-'&&_bbe [_abgf -4]=='F'&&_bbe [_abgf -5]=='D'&&_bbe [_abgf -6]=='P'&&_bbe [_abgf -7]=='%'{_dbe ._ddfc =Version {Major :int (_bbe [_abgf -2]-'0'),Minor :int (_dec -'0')};
_dbe ._bffd ._ggg =_ebeeb -7;_dcbcc =true ;break ;};_ebeeb ++;_bbe =append (_bbe [1:_abgf ],_dec );};if !_dcbcc {return _fc .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_gbg ,_gccf :=_dbe ._cedf .ReadByte ();
if _gccf ==_gdb .EOF {return _fc .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _gccf !=nil {return _gccf ;};_dbe ._bffd ._fbb =_gbg =='\n';_gbg ,_gccf =_dbe ._cedf .ReadByte ();
if _gccf !=nil {return _fc .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_gccf );};if _gbg !='%'{return nil ;};_bgag :=make ([]byte ,4);_ ,_gccf =_dbe ._cedf .Read (_bgag );
if _gccf !=nil {return _fc .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_gccf );};_dbe ._bffd ._efg =[4]byte {_bgag [0],_bgag [1],_bgag [2],_bgag [3]};
return nil ;};var _egfg =_aa .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");func (_eed *PdfCrypt )isDecrypted (_dbde PdfObject )bool {_ ,_fbe :=_eed ._ecd [_dbde ];
if _fbe {_fef .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _dae :=_dbde .(type ){case *PdfObjectStream :if _eed ._fab .R !=5{if _dgbe ,_feb :=_dae .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_feb &&*_dgbe =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_fbe =_eed ._begb [int (_dae .ObjectNumber )];_fbe {return true ;};switch _gefe :=_dae .PdfObject .(type ){case *PdfObjectDictionary :_fdd :=true ;for _ ,_dbdb :=range _fgdb {if _gefe .Get (_dbdb )==nil {_fdd =false ;
break ;};};if _fdd {return true ;};};};_fef .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_eca *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eca .DecodeBytes (streamObj .Stream );};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_cdg *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fef .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cdg .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bcdgbb *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _dbeg []int ;for _ ,_bbbf :=range _bcdgbb .Elements (){if _cbdef ,_dfgd :=_bbbf .(*PdfObjectInteger );_dfgd {_dbeg =append (_dbeg ,int (*_cbdef ));}else {return nil ,ErrTypeError ;};};
return _dbeg ,nil ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bdgbe Version )String ()string {return _fc .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_bdgbe .Major ,_bdgbe .Minor );};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_geaa *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _geaa .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_cbceg *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// String returns a string representation of the *PdfObjectString.
func (_afba *PdfObjectString )String ()string {return _afba ._deef };

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_ff []XrefObject ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};func (_abef *JBIG2Encoder )encodeImage (_dgagc _fd .Image )([]byte ,error ){const _bcdb ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_gggf ,_effd :=GoImageToJBIG2 (_dgagc ,JB2ImageAutoThreshold );
if _effd !=nil {return nil ,_dg .Wrap (_effd ,_bcdb ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _effd =_abef .AddPageImage (_gggf ,&_abef .DefaultPageSettings );
_effd !=nil {return nil ,_dg .Wrap (_effd ,_bcdb ,"");};return _abef .Encode ();};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_dgeec :=&ASCII85Encoder {};return _dgeec };

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_ffdef *PdfObjectInteger ,_cbgb bool ){_ffdef ,_cbgb =TraceToDirectObject (obj ).(*PdfObjectInteger );return _ffdef ,_cbgb ;};

// HeaderCommentBytes gets the header comment bytes.
func (_acc ParserMetadata )HeaderCommentBytes ()[4]byte {return _acc ._efg };

// UpdateParams updates the parameter values of the encoder.
func (_eec *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_db .Model ;Bounds ()_fd .Rectangle ;At (_acbe ,_cedb int )_db .Color ;Set (_bbbd ,_bccg int ,_bfgb _db .Color );};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;Lazy bool ;TempFile string ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// WriteString outputs the object as it is to be written to file.
func (_dcge *PdfIndirectObject )WriteString ()string {var _ecgf _fe .Builder ;_ecgf .WriteString (_b .FormatInt (_dcge .ObjectNumber ,10));_ecgf .WriteString ("\u0020\u0030\u0020\u0052");return _ecgf .String ();};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_fbbg *PdfObjectStreams )Elements ()[]PdfObject {if _fbbg ==nil {return nil ;};return _fbbg ._geaf ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_febd *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_fcfc :=_febd .Get (key );if _fcfc ==nil {return "",false ;};_fbfd ,_gfcd :=_fcfc .(*PdfObjectString );if !_gfcd {return "",false ;};return _fbfd .Str (),true ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_cbff *PdfObjectDictionary )Keys ()[]PdfObjectName {if _cbff ==nil {return nil ;};return _cbff ._bbdc ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_dcaga :=MakeArray ();for _ ,_fadc :=range vals {_dcaga .Append (MakeInteger (_fadc ));};return _dcaga ;};func (_bfe *PdfCrypt )authenticate (_adg []byte )(bool ,error ){_bfe ._gbc =false ;_gfd :=_bfe .securityHandler ();
_ebg ,_eac ,_ccgb :=_gfd .Authenticate (&_bfe ._fab ,_adg );if _ccgb !=nil {return false ,_ccgb ;}else if _eac ==0||len (_ebg )==0{return false ,nil ;};_bfe ._gbc =true ;_bfe ._ac =_ebg ;return true ,nil ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_fffg *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fagg :=encoded ;var _ccee error ;for _ ,_abae :=range _fffg ._gebb {_fef .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_abae ,_abae );
_fagg ,_ccee =_abae .DecodeBytes (_fagg );if _ccee !=nil {return nil ,_ccee ;};};return _fagg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_bgcd *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// GetFilterName returns the name of the encoding filter.
func (_fcb *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_abeb *PdfObjectStreams ,_fagdg bool ){_abeb ,_fagdg =obj .(*PdfObjectStreams );return _abeb ,_fagdg ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_begbf *PdfObjectStream ,_eefg bool ){obj =ResolveReference (obj );_begbf ,_eefg =obj .(*PdfObjectStream );return _begbf ,_eefg ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_fgcg :=&DCTEncoder {};_fgcg .ColorComponents =3;_fgcg .BitsPerComponent =8;_fgcg .Quality =DefaultJPEGQuality ;_fgcg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};return _fgcg ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// WriteString outputs the object as it is to be written to file.
func (_afde *PdfObjectBool )WriteString ()string {if *_afde {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_fcec *PdfObjectString )Str ()string {return _fcec ._deef };

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_gdaec *PdfObjectString )IsHexadecimal ()bool {return _gdaec ._gdggc };