//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_gc "bufio";_gbg "bytes";_ae "compress/lzw";_daa "compress/zlib";_e "crypto/md5";_eb "crypto/rand";_cg "encoding/hex";_d "errors";_af "fmt";_gf "github.com/unidoc/unipdf/v3/common";_fg "github.com/unidoc/unipdf/v3/core/security";_ee "github.com/unidoc/unipdf/v3/core/security/crypt";
_dag "github.com/unidoc/unipdf/v3/internal/ccittfax";_bb "github.com/unidoc/unipdf/v3/internal/imageutil";_ef "github.com/unidoc/unipdf/v3/internal/jbig2";_ca "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_fb "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";
_ccb "github.com/unidoc/unipdf/v3/internal/jbig2/document";_ag "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_gfg "github.com/unidoc/unipdf/v3/internal/strutils";_fa "golang.org/x/image/tiff/lzw";_gg "golang.org/x/xerrors";_cc "image";_gb "image/color";
_c "image/jpeg";_cb "io";_a "os";_da "reflect";_ga "regexp";_ff "sort";_db "strconv";_cf "strings";_g "sync";_b "time";_fd "unicode";);

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_fggf *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _gage []float64 ;for _ ,_aacgc :=range _fggf .Elements (){switch _fcagb :=_aacgc .(type ){case *PdfObjectInteger :_gage =append (_gage ,float64 (*_fcagb ));case *PdfObjectFloat :_gage =append (_gage ,float64 (*_fcagb ));
default:return nil ,ErrTypeError ;};};return _gage ,nil ;};func (_fgaf *PdfParser )parseLinearizedDictionary ()(*PdfObjectDictionary ,error ){_decc ,_feed :=_fgaf ._bcdda .Seek (0,_cb .SeekEnd );if _feed !=nil {return nil ,_feed ;};var _gdae int64 ;var _cabc int64 =2048;
for _gdae < _decc -4{if _decc <=(_cabc +_gdae ){_cabc =_decc -_gdae ;};_ ,_fggc :=_fgaf ._bcdda .Seek (_gdae ,_cb .SeekStart );if _fggc !=nil {return nil ,_fggc ;};_eefdg :=make ([]byte ,_cabc );_ ,_fggc =_fgaf ._bcdda .Read (_eefdg );if _fggc !=nil {return nil ,_fggc ;
};_gf .Log .Trace ("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022",string (_eefdg ));
_dffcg :=_cdegb .FindAllStringIndex (string (_eefdg ),-1);if _dffcg !=nil {_bdde :=_dffcg [0];_gf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_dffcg );_ ,_abfee :=_fgaf ._bcdda .Seek (int64 (_bdde [0]),_cb .SeekStart );if _abfee !=nil {return nil ,_abfee ;
};_fgaf ._fdc =_gc .NewReader (_fgaf ._bcdda );_edebc ,_abfee :=_fgaf .ParseIndirectObject ();if _abfee !=nil {return nil ,nil ;};if _cccdf ,_ecgc :=GetIndirect (_edebc );_ecgc {if _eebda ,_cdgfb :=GetDict (_cccdf .PdfObject );_cdgfb {if _febb :=_eebda .Get ("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064");
_febb !=nil {return _eebda ,nil ;};return nil ,nil ;};};return nil ,nil ;};_gdae +=_cabc -4;};return nil ,_d .New ("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064");
};

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_fea ParserMetadata )HasInvalidSubsectionHeader ()bool {return _fea ._daf };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_dgcb *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_gdde :=MakeDict ();_gdde .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dgcb .GetFilterName ()));return _gdde ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gdff *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_cacbf :=_gbg .NewReader ([]byte (txt ));_daff :=&PdfParser {ObjCache :objectCache {},_bcdda :_cacbf ,_fdc :_gc .NewReader (_cacbf ),_fbbge :int64 (len (txt )),_fbge :map[int64 ]bool {},_fefb :make (map[*PdfParser ]*PdfParser )};
_daff ._gfdb .ObjectMap =make (map[int ]XrefObject );return _daff ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_dgddc *PdfParser )GetCrypter ()*PdfCrypt {return _dgddc ._bcgfc };

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_bgcc *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ef .DecodeBytes (encoded ,_fb .Parameters {},_bgcc .Globals );};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_cbeg *PdfObjectString )Decoded ()string {if _cbeg ==nil {return "";};_dgef :=[]byte (_cbeg ._addg );if len (_dgef )>=2&&_dgef [0]==0xFE&&_dgef [1]==0xFF{return _gfg .UTF16ToString (_dgef [2:]);};return _gfg .PDFDocEncodingToString (_dgef );};const _adgbd =6;
func (_gaba *PdfParser )getNumbersOfUpdatedObjects (_fgeg *PdfParser )([]int ,error ){if _fgeg ==nil {return nil ,_d .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_gccae :=_fgeg ._fbbge ;_cgce :=make ([]int ,0);_fccf :=make (map[int ]interface{});_dfca :=make (map[int ]int64 );for _bdaf ,_fccaf :=range _gaba ._gfdb .ObjectMap {if _fccaf .Offset ==0{if _fccaf .OsObjNumber !=0{if _cfdgf ,_gfgeb :=_gaba ._gfdb .ObjectMap [_fccaf .OsObjNumber ];
_gfgeb {_fccf [_fccaf .OsObjNumber ]=struct{}{};_dfca [_bdaf ]=_cfdgf .Offset ;}else {return nil ,_d .New ("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065");};};}else {_dfca [_bdaf ]=_fccaf .Offset ;};};
for _bfdb ,_bgfdd :=range _dfca {if _ ,_abdcb :=_fccf [_bfdb ];_abdcb {continue ;};if _bgfdd > _gccae {_cgce =append (_cgce ,_bfdb );};};return _cgce ,nil ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_eeca *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bebf ,_edfd :=_dag .NewDecoder (encoded ,_dag .DecodeOptions {Columns :_eeca .Columns ,Rows :_eeca .Rows ,K :_eeca .K ,EncodedByteAligned :_eeca .EncodedByteAlign ,BlackIsOne :_eeca .BlackIs1 ,EndOfBlock :_eeca .EndOfBlock ,EndOfLine :_eeca .EndOfLine ,DamagedRowsBeforeError :_eeca .DamagedRowsBeforeError });
if _edfd !=nil {return nil ,_edfd ;};_aeca ,_edfd :=_cb .ReadAll (_bebf );if _edfd !=nil {return nil ,_edfd ;};return _aeca ,nil ;};

// Clear resets the array to an empty state.
func (_aedb *PdfObjectArray )Clear (){_aedb ._dcgec =[]PdfObject {}};func (_afcd *PdfParser )repairLocateXref ()(int64 ,error ){_gbaef :=int64 (1000);_afcd ._bcdda .Seek (-_gbaef ,_cb .SeekCurrent );_dcff ,_daedc :=_afcd ._bcdda .Seek (0,_cb .SeekCurrent );
if _daedc !=nil {return 0,_daedc ;};_eaccg :=make ([]byte ,_gbaef );_afcd ._bcdda .Read (_eaccg );_ebcgc :=_ccbcf .FindAllStringIndex (string (_eaccg ),-1);if len (_ebcgc )< 1{_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");
return 0,_d .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_afbae :=int64 (_ebcgc [len (_ebcgc )-1][0]);_gabe :=_dcff +_afbae ;return _gabe ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_eefg *PdfObjectReference )WriteString ()string {var _gddc _cf .Builder ;_gddc .WriteString (_db .FormatInt (_eefg .ObjectNumber ,10));_gddc .WriteString ("\u0020");_gddc .WriteString (_db .FormatInt (_eefg .GenerationNumber ,10));_gddc .WriteString ("\u0020\u0052");
return _gddc .String ();};

// GetFilterName returns the name of the encoding filter.
func (_dgdf *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_geda *MultiEncoder )AddEncoder (encoder StreamEncoder ){_geda ._fcge =append (_geda ._fcge ,encoder );};

// GetRevisionNumber returns the current version of the Pdf document.
func (_abea *PdfParser )GetRevisionNumber ()int {return _abea ._decec };

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_ddfd *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_bdf :=MakeDict ();_bdf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ddfd .GetFilterName ()));_ebcg :=_ddfd .MakeDecodeParams ();if _ebcg !=nil {_bdf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ebcg );
};return _bdf ;};func (_gdfe *PdfParser )resolveReference (_dbfgg *PdfObjectReference )(PdfObject ,bool ,error ){_fceec ,_befge :=_gdfe .ObjCache [int (_dbfgg .ObjectNumber )];if _befge {return _fceec ,true ,nil ;};_ceab ,_befa :=_gdfe .LookupByReference (*_dbfgg );
if _befa !=nil {return nil ,false ,_befa ;};_gdfe .ObjCache [int (_dbfgg .ObjectNumber )]=_ceab ;return _ceab ,false ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cbca *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// GetParser returns the parser for lazy-loading or compare references.
func (_fbca *PdfObjectReference )GetParser ()*PdfParser {return _fbca ._gcdb };

// String returns a string representation of the *PdfObjectString.
func (_dgec *PdfObjectString )String ()string {return _dgec ._addg };var _cagf =_d .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_beea *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _fbfe _bb .Gray ;switch len (data ){case _beea .Rows *_beea .Columns :_dcdb ,_fbad :=_bb .NewImage (_beea .Columns ,_beea .Rows ,8,1,data ,nil ,nil );if _fbad !=nil {return nil ,_fbad ;
};_fbfe =_dcdb .(_bb .Gray );case (_beea .Columns *_beea .Rows )+7>>3:_gaadb ,_bfee :=_bb .NewImage (_beea .Columns ,_beea .Rows ,1,1,data ,nil ,nil );if _bfee !=nil {return nil ,_bfee ;};_cceab :=_gaadb .(*_bb .Monochrome );if _bfee =_cceab .AddPadding ();
_bfee !=nil {return nil ,_bfee ;};_fbfe =_cceab ;default:if len (data )< _bb .BytesPerLine (_beea .Columns ,1,1)*_beea .Rows {return nil ,_d .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_ccgf ,_gfb :=_bb .NewImage (_beea .Columns ,_beea .Rows ,1,1,data ,nil ,nil );if _gfb !=nil {return nil ,_gfb ;};_ceee :=_ccgf .(*_bb .Monochrome );_fbfe =_ceee ;};_fbbg :=make ([][]byte ,_beea .Rows );for _bffd :=0;_bffd < _beea .Rows ;_bffd ++{_agaf :=make ([]byte ,_beea .Columns );
for _cfdg :=0;_cfdg < _beea .Columns ;_cfdg ++{_egec :=_fbfe .GrayAt (_cfdg ,_bffd );_agaf [_cfdg ]=_egec .Y >>7;};_fbbg [_bffd ]=_agaf ;};_faab :=&_dag .Encoder {K :_beea .K ,Columns :_beea .Columns ,EndOfLine :_beea .EndOfLine ,EndOfBlock :_beea .EndOfBlock ,BlackIs1 :_beea .BlackIs1 ,DamagedRowsBeforeError :_beea .DamagedRowsBeforeError ,Rows :_beea .Rows ,EncodedByteAlign :_beea .EncodedByteAlign };
return _faab .Encode (_fbbg ),nil ;};func (_bde *PdfCrypt )encryptBytes (_gdeg []byte ,_cfeb string ,_eeef []byte )([]byte ,error ){_gf .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_cgcd ,_fbb :=_bde ._fcag [_cfeb ];
if !_fbb {return nil ,_af .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cfeb );};return _cgcd .EncryptBytes (_gdeg ,_eeef );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cbcf *FlateEncoder )MakeDecodeParams ()PdfObject {if _cbcf .Predictor > 1{_bda :=MakeDict ();_bda .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_cbcf .Predictor )));if _cbcf .BitsPerComponent !=8{_bda .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_cbcf .BitsPerComponent )));
};if _cbcf .Columns !=1{_bda .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_cbcf .Columns )));};if _cbcf .Colors !=1{_bda .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_cbcf .Colors )));};return _bda ;};return nil ;
};

// UpdateParams updates the parameter values of the encoder.
func (_bbge *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// Read implementation of Read interface.
func (_baac *limitedReadSeeker )Read (p []byte )(_fcbf int ,_cdgf error ){_bdbee ,_cdgf :=_baac ._dcb .Seek (0,_cb .SeekCurrent );if _cdgf !=nil {return 0,_cdgf ;};_adbc :=_baac ._adad -_bdbee ;if _adbc ==0{return 0,_cb .EOF ;};if _bfege :=int64 (len (p ));
_bfege < _adbc {_adbc =_bfege ;};_bbcc :=make ([]byte ,_adbc );_fcbf ,_cdgf =_baac ._dcb .Read (_bbcc );copy (p ,_bbcc );return _fcbf ,_cdgf ;};

// UpdateParams updates the parameter values of the encoder.
func (_baeea *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_fbeg *PdfObjectDictionary );EncodeBytes (_fgdc []byte )([]byte ,error );DecodeBytes (_dabc []byte )([]byte ,error );
DecodeStream (_eaa *PdfObjectStream )([]byte ,error );};func (_dfbga *PdfParser )traceStreamLength (_gfbe PdfObject )(PdfObject ,error ){_eefd ,_ggce :=_gfbe .(*PdfObjectReference );if _ggce {_daac ,_cfcg :=_dfbga ._fbge [_eefd .ObjectNumber ];if _cfcg &&_daac {_gf .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_d .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_dfbga ._fbge [_eefd .ObjectNumber ]=true ;};_bffc ,_bfddd :=_dfbga .Resolve (_gfbe );if _bfddd !=nil {return nil ,_bfddd ;
};_gf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_bffc );if _ggce {_dfbga ._fbge [_eefd .ObjectNumber ]=false ;};return _bffc ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_babga *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };func (_bfadd *PdfParser )parsePdfVersion ()(int ,int ,error ){var _dcce int64 =20;_dbgf :=make ([]byte ,_dcce );_bfadd ._bcdda .Seek (0,_cb .SeekStart );_bfadd ._bcdda .Read (_dbgf );
var _cceac error ;var _aeeac ,_fedd int ;if _cacf :=_fbbf .FindStringSubmatch (string (_dbgf ));len (_cacf )< 3{if _aeeac ,_fedd ,_cceac =_bfadd .seekPdfVersionTopDown ();_cceac !=nil {_gf .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_cceac ;};_bfadd ._bcdda ,_cceac =_cbgdc (_bfadd ._bcdda ,_bfadd .GetFileOffset ()-8);if _cceac !=nil {return 0,0,_cceac ;};}else {if _aeeac ,_cceac =_db .Atoi (_cacf [1]);_cceac !=nil {return 0,0,_cceac ;};if _fedd ,_cceac =_db .Atoi (_cacf [2]);
_cceac !=nil {return 0,0,_cceac ;};_bfadd .SetFileOffset (0);};_bfadd ._fdc =_gc .NewReader (_bfadd ._bcdda );_gf .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_aeeac ,_fedd );return _aeeac ,_fedd ,nil ;
};func (_edf *PdfParser )parseDetailedHeader ()(_gded error ){_edf ._bcdda .Seek (0,_cb .SeekStart );_edf ._fdc =_gc .NewReader (_edf ._bcdda );_abfg :=20;_egfeg :=make ([]byte ,_abfg );var (_ffbd bool ;_acbg int ;);for {_gcbc ,_ceg :=_edf ._fdc .ReadByte ();
if _ceg !=nil {if _ceg ==_cb .EOF {break ;}else {return _ceg ;};};if IsDecimalDigit (_gcbc )&&_egfeg [_abfg -1]=='.'&&IsDecimalDigit (_egfeg [_abfg -2])&&_egfeg [_abfg -3]=='-'&&_egfeg [_abfg -4]=='F'&&_egfeg [_abfg -5]=='D'&&_egfeg [_abfg -6]=='P'&&_egfeg [_abfg -7]=='%'{_edf ._dbdd =Version {Major :int (_egfeg [_abfg -2]-'0'),Minor :int (_gcbc -'0')};
_edf ._ebaa ._fbe =_acbg -7;_ffbd =true ;break ;};_acbg ++;_egfeg =append (_egfeg [1:_abfg ],_gcbc );};if !_ffbd {return _af .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_fgab ,_gded :=_edf ._fdc .ReadByte ();
if _gded ==_cb .EOF {return _af .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _gded !=nil {return _gded ;};_edf ._ebaa ._gaad =_fgab =='\n';_fgab ,_gded =_edf ._fdc .ReadByte ();
if _gded !=nil {return _af .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_gded );};if _fgab !='%'{return nil ;};_gfef :=make ([]byte ,4);_ ,_gded =_edf ._fdc .Read (_gfef );
if _gded !=nil {return _af .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_gded );};_edf ._ebaa ._fccg =[4]byte {_gfef [0],_gfef [1],_gfef [2],_gfef [3]};
return nil ;};var _bbga =_ga .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");func (_aacg *PdfCrypt )makeKey (_cgb string ,_aaf ,_fbd uint32 ,_bba []byte )([]byte ,error ){_cfg ,_bbb :=_aacg ._fcag [_cgb ];
if !_bbb {return nil ,_af .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cgb );};return _cfg .MakeKey (_aaf ,_fbd ,_bba );};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_gcbb *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_gf .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_geca :=MakeDict ();_geca ._cbdf =_gcbb ;_fcf ,_ :=_gcbb ._fdc .ReadByte ();
if _fcf !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_fcf ,_ =_gcbb ._fdc .ReadByte ();if _fcf !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_gcbb .skipSpaces ();
_gcbb .skipComments ();_ebbg ,_baaf :=_gcbb ._fdc .Peek (2);if _baaf !=nil {return nil ,_baaf ;};_gf .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_ebbg ),string (_ebbg ));if (_ebbg [0]=='>')&&(_ebbg [1]=='>'){_gf .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
_gcbb ._fdc .ReadByte ();_gcbb ._fdc .ReadByte ();break ;};_gf .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_cdba ,_baaf :=_gcbb .parseName ();_gf .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_cdba );
if _baaf !=nil {_gf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_baaf );return nil ,_baaf ;};if len (_cdba )> 4&&_cdba [len (_cdba )-4:]=="\u006e\u0075\u006c\u006c"{_dcga :=_cdba [0:len (_cdba )-4];
_gf .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_cdba );_gf .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_dcga );
_gcbb .skipSpaces ();_bdbac ,_ :=_gcbb ._fdc .Peek (1);if _bdbac [0]=='/'{_geca .Set (_dcga ,MakeNull ());continue ;};};_gcbb .skipSpaces ();_dgce ,_baaf :=_gcbb .parseObject ();if _baaf !=nil {return nil ,_baaf ;};_geca .Set (_cdba ,_dgce );if _gf .Log .IsLogLevel (_gf .LogLevelTrace ){_gf .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_cdba ,_dgce .String ());
};};_gf .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _geca ,nil ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_bacd :_ccb .InitEncodeDocument (false )}};func (_bfdf *PdfCrypt )generateParams (_afa ,_aefc []byte )error {_cdee :=_bfdf .securityHandler ();_feda ,_bged :=_cdee .GenerateParams (&_bfdf ._acc ,_aefc ,_afa );
if _bged !=nil {return _bged ;};_bfdf ._dbbe =_feda ;return nil ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_ebdbd *PdfObjectArray ,_adaa bool ){_ebdbd ,_adaa =TraceToDirectObject (obj ).(*PdfObjectArray );return _ebdbd ,_adaa ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _cb .ReadSeeker )(*PdfParser ,error ){_gcec :=&PdfParser {_bcdda :rs ,ObjCache :make (objectCache ),_fbge :map[int64 ]bool {},_fcca :make ([]int64 ,0),_fefb :make (map[*PdfParser ]*PdfParser )};_fddg ,_bddf ,_bbbd :=_gcec .parsePdfVersion ();
if _bbbd !=nil {_gf .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_bbbd );return nil ,_bbbd ;};_gcec ._dbdd .Major =_fddg ;_gcec ._dbdd .Minor =_bddf ;
if _gcec ._ffe ,_bbbd =_gcec .loadXrefs ();_bbbd !=nil {_gf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_bbbd );return nil ,_bbbd ;
};_gf .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_gcec ._ffe );_affe ,_bbbd :=_gcec .parseLinearizedDictionary ();if _bbbd !=nil {return nil ,_bbbd ;};if _affe !=nil {_gcec ._ecbbe ,_bbbd =_gcec .checkLinearizedInformation (_affe );
if _bbbd !=nil {return nil ,_bbbd ;};};if len (_gcec ._gfdb .ObjectMap )==0{return nil ,_af .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};
_gcec ._decec =len (_gcec ._fcca );if _gcec ._ecbbe &&_gcec ._decec !=0{_gcec ._decec --;};_gcec ._acaa =make ([]*PdfParser ,_gcec ._decec );return _gcec ,nil ;};var _fbbf =_ga .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");


// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fdagf *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_gacc :=MakeDict ();_gacc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_fdagf .GetFilterArray ());for _ ,_eagd :=range _fdagf ._fcge {_cbgd :=_eagd .MakeStreamDict ();for _ ,_abee :=range _cbgd .Keys (){_cegc :=_cbgd .Get (_abee );
if _abee !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_abee !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_gacc .Set (_abee ,_cegc );};};};_gce :=_fdagf .MakeDecodeParams ();if _gce !=nil {_gacc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gce );
};return _gacc ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_bfef *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_badcc :=_bfef .Get (key );if _badcc ==nil {return "",false ;};_gbdcf ,_bdbbg :=_badcc .(*PdfObjectString );if !_bdbbg {return "",false ;};return _gbdcf .Str (),true ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_bddea :=PdfObjectInteger (val );return &_bddea };

// WriteString outputs the object as it is to be written to file.
func (_agcg *PdfObjectStream )WriteString ()string {var _gcfad _cf .Builder ;_gcfad .WriteString (_db .FormatInt (_agcg .ObjectNumber ,10));_gcfad .WriteString ("\u0020\u0030\u0020\u0052");return _gcfad .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_adcb *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_dbdgf :=range _adcb ._fcge {_dbdgf .UpdateParams (params );};};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;
CF map[string ]_ee .FilterDict ;};func _adge (_bagc *PdfObjectStream ,_afeb *PdfObjectDictionary )(*LZWEncoder ,error ){_adgg :=NewLZWEncoder ();_geee :=_bagc .PdfObjectDictionary ;if _geee ==nil {return _adgg ,nil ;};if _afeb ==nil {_bccg :=TraceToDirectObject (_geee .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));
if _bccg !=nil {if _dea ,_aaab :=_bccg .(*PdfObjectDictionary );_aaab {_afeb =_dea ;}else if _baa ,_gdd :=_bccg .(*PdfObjectArray );_gdd {if _baa .Len ()==1{if _efgg ,_cbed :=GetDict (_baa .Get (0));_cbed {_afeb =_efgg ;};};};if _afeb ==nil {_gf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_bccg );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_dce :=_geee .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _dce !=nil {_ddaeg ,_bfb :=_dce .(*PdfObjectInteger );
if !_bfb {_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_dce );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_ddaeg !=0&&*_ddaeg !=1{return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_adgg .EarlyChange =int (*_ddaeg );}else {_adgg .EarlyChange =1;};if _afeb ==nil {return _adgg ,nil ;};if _cddd ,_ggef :=GetIntVal (_afeb .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_ggef {if _cddd ==0||_cddd ==1{_adgg .EarlyChange =_cddd ;
}else {_gf .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_cddd );};};_dce =_afeb .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _dce !=nil {_aed ,_adea :=_dce .(*PdfObjectInteger );if !_adea {_gf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_dce );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_adgg .Predictor =int (*_aed );};_dce =_afeb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _dce !=nil {_accg ,_egae :=_dce .(*PdfObjectInteger );if !_egae {_gf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_af .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_adgg .BitsPerComponent =int (*_accg );};if _adgg .Predictor > 1{_adgg .Columns =1;_dce =_afeb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _dce !=nil {_fba ,_bgcd :=_dce .(*PdfObjectInteger );if !_bgcd {return nil ,_af .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_adgg .Columns =int (*_fba );
};_adgg .Colors =1;_dce =_afeb .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _dce !=nil {_cfgg ,_egfg :=_dce .(*PdfObjectInteger );if !_egfg {return nil ,_af .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_adgg .Colors =int (*_cfgg );};};_gf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_afeb .String ());return _adgg ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_bgga *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};func _edba (_eaf _bb .Image )*JBIG2Image {_dbde :=_eaf .Base ();return &JBIG2Image {Data :_dbde .Data ,Width :_dbde .Width ,Height :_dbde .Height ,HasPadding :true };};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};type xrefType int ;

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};func (_agdf *ASCII85Encoder )base256Tobase85 (_acd uint32 )[5]byte {_ebda :=[5]byte {0,0,0,0,0};_ecaf :=_acd ;for _aecf :=0;_aecf < 5;_aecf ++{_cfed :=uint32 (1);for _bedf :=0;_bedf < 4-_aecf ;_bedf ++{_cfed *=85;};_dcd :=_ecaf /_cfed ;
_ecaf =_ecaf %_cfed ;_ebda [_aecf ]=byte (_dcd );};return _ebda ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_edcb *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_edcb ._fcge )==0{return nil ;};if len (_edcb ._fcge )==1{return _edcb ._fcge [0].MakeDecodeParams ();};_egfb :=MakeArray ();_begc :=true ;for _ ,_cbaab :=range _edcb ._fcge {_fcee :=_cbaab .MakeDecodeParams ();
if _fcee ==nil {_egfb .Append (MakeNull ());}else {_begc =false ;_egfb .Append (_fcee );};};if _begc {return nil ;};return _egfb ;};func (_daeb *PdfCrypt )isDecrypted (_fbf PdfObject )bool {_ ,_gfd :=_daeb ._dbe [_fbf ];if _gfd {_gf .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};switch _fgc :=_fbf .(type ){case *PdfObjectStream :if _daeb ._acc .R !=5{if _aff ,_fga :=_fgc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fga &&*_aff =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_gfd =_daeb ._dbdb [int (_fgc .ObjectNumber )];
_gfd {return true ;};switch _gfa :=_fgc .PdfObject .(type ){case *PdfObjectDictionary :_ggdc :=true ;for _ ,_gcg :=range _dffb {if _gfa .Get (_gcg )==nil {_ggdc =false ;break ;};};if _ggdc {return true ;};};};_gf .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_baeaa *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _baeaa .DecodeBytes (streamObj .Stream );};func _ccd (_ebcbc uint ,_ccdc ,_eecc float64 )float64 {return (_ccdc +(float64 (_ebcbc )*(_eecc -_ccdc )/255))*255;};


// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eggg *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_dfbf *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _ccaad []int ;for _ ,_adcg :=range _dfbf .Elements (){if _bggb ,_eaag :=_adcg .(*PdfObjectInteger );_eaag {_ccaad =append (_ccaad ,int (*_bggb ));}else {return nil ,ErrTypeError ;};};return _ccaad ,nil ;
};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_cgdb map[PdfObjectName ]PdfObject ;_gaccg []PdfObjectName ;_fefbg *_g .Mutex ;_cbdf *PdfParser ;};

// LookupByReference looks up a PdfObject by a reference.
func (_ecc *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_gf .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _ecc .LookupByNumber (int (ref .ObjectNumber ));
};var _bdfe _g .Map ;

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_gefb *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _fdbc :=val .(type ){case *PdfObjectName :if _fdbc !=nil {_gefb .Set (key ,val );};case *PdfObjectDictionary :if _fdbc !=nil {_gefb .Set (key ,val );
};case *PdfObjectStream :if _fdbc !=nil {_gefb .Set (key ,val );};case *PdfObjectString :if _fdbc !=nil {_gefb .Set (key ,val );};case *PdfObjectNull :if _fdbc !=nil {_gefb .Set (key ,val );};case *PdfObjectInteger :if _fdbc !=nil {_gefb .Set (key ,val );
};case *PdfObjectArray :if _fdbc !=nil {_gefb .Set (key ,val );};case *PdfObjectBool :if _fdbc !=nil {_gefb .Set (key ,val );};case *PdfObjectFloat :if _fdbc !=nil {_gefb .Set (key ,val );};case *PdfObjectReference :if _fdbc !=nil {_gefb .Set (key ,val );
};case *PdfIndirectObject :if _fdbc !=nil {_gefb .Set (key ,val );};default:_gf .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// WriteString outputs the object as it is to be written to file.
func (_gdaa *PdfObjectInteger )WriteString ()string {return _db .FormatInt (int64 (*_gdaa ),10)};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_gfgfc *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _bfag []int64 ;for _ ,_fccafg :=range _gfgfc .Elements (){if _ggcd ,_efdcc :=_fccafg .(*PdfObjectInteger );_efdcc {_bfag =append (_bfag ,int64 (*_ggcd ));}else {return nil ,ErrTypeError ;
};};return _bfag ,nil ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_abfe *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_gdge *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_bcae error ){const _gfde ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _gdge ==nil {return _ag .Error (_gfde ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_gdge .DefaultPageSettings ;};if _gdge ._bacd ==nil {_gdge ._bacd =_ccb .InitEncodeDocument (settings .FileMode );
};if _bcae =settings .Validate ();_bcae !=nil {return _ag .Wrap (_bcae ,_gfde ,"");};_cgcfb ,_bcae :=img .toBitmap ();if _bcae !=nil {return _ag .Wrap (_bcae ,_gfde ,"");};switch settings .Compression {case JB2Generic :if _bcae =_gdge ._bacd .AddGenericPage (_cgcfb ,settings .DuplicatedLinesRemoval );
_bcae !=nil {return _ag .Wrap (_bcae ,_gfde ,"");};case JB2SymbolCorrelation :return _ag .Error (_gfde ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _ag .Error (_gfde ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _ag .Error (_gfde ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ddc *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_cffa *PdfParser )GetPreviousRevisionReadSeeker ()(_cb .ReadSeeker ,error ){if _bfbd :=_cffa .seekToEOFMarker (_cffa ._fbbge -_adgbd );_bfbd !=nil {return nil ,_bfbd ;};_fddb ,_bcege :=_cffa ._bcdda .Seek (0,_cb .SeekCurrent );if _bcege !=nil {return nil ,_bcege ;
};_fddb +=_adgbd ;return _dfga (_cffa ._bcdda ,_fddb );};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_gdfde :objects };};func (_ecd *PdfParser )checkPostEOFData ()error {const _ccef ="\u0025\u0025\u0045O\u0046";_ ,_cdeg :=_ecd ._bcdda .Seek (-int64 (len ([]byte (_ccef )))-1,_cb .SeekEnd );
if _cdeg !=nil {return _cdeg ;};_cceg :=make ([]byte ,len ([]byte (_ccef ))+1);_ ,_cdeg =_ecd ._bcdda .Read (_cceg );if _cdeg !=nil {if _cdeg !=_cb .EOF {return _cdeg ;};};if string (_cceg )==_ccef ||string (_cceg )==_ccef +"\u000a"{_ecd ._ebaa ._cbe =true ;
};return nil ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_bec *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _bec .isDecrypted (obj ){return nil ;};switch _beg :=obj .(type ){case *PdfIndirectObject :_bec ._dbe [_beg ]=true ;_gf .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_beg .ObjectNumber ,_beg .GenerationNumber );
_gcb :=_beg .ObjectNumber ;_bafb :=_beg .GenerationNumber ;_gefe :=_bec .Decrypt (_beg .PdfObject ,_gcb ,_bafb );if _gefe !=nil {return _gefe ;};return nil ;case *PdfObjectStream :_bec ._dbe [_beg ]=true ;_dfgb :=_beg .PdfObjectDictionary ;if _bec ._acc .R !=5{if _aadg ,_ddd :=_dfgb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_ddd &&*_aadg =="\u0058\u0052\u0065\u0066"{return nil ;};};_bcg :=_beg .ObjectNumber ;_gbgf :=_beg .GenerationNumber ;_gf .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_bcg ,_gbgf );
_afb :=_fgf ;if _bec ._ffgd .V >=4{_afb =_bec ._bfe ;_gf .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_bec ._bfe );if _baec ,_gdb :=_dfgb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_gdb {if _ecfa ,_cea :=GetName (_baec .Get (0));_cea {if *_ecfa =="\u0043\u0072\u0079p\u0074"{_afb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _eeacg ,_deb :=_dfgb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_deb {if _abd ,_faa :=_eeacg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_faa {if _ ,_eeaa :=_bec ._fcag [string (*_abd )];_eeaa {_gf .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_abd );
_afb =string (*_abd );};};};};};};_gf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_afb );if _afb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_ccaa :=_bec .Decrypt (_dfgb ,_bcg ,_gbgf );
if _ccaa !=nil {return _ccaa ;};_cde ,_ccaa :=_bec .makeKey (_afb ,uint32 (_bcg ),uint32 (_gbgf ),_bec ._dbbe );if _ccaa !=nil {return _ccaa ;};_beg .Stream ,_ccaa =_bec .decryptBytes (_beg .Stream ,_afb ,_cde );if _ccaa !=nil {return _ccaa ;};_dfgb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_beg .Stream ))));
return nil ;case *PdfObjectString :_gf .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gdba :=_fgf ;if _bec ._ffgd .V >=4{_gf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bec ._eab );
if _bec ._eab =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gdba =_bec ._eab ;};_abe ,_gdc :=_bec .makeKey (_gdba ,uint32 (parentObjNum ),uint32 (parentGenNum ),_bec ._dbbe );if _gdc !=nil {return _gdc ;};_ddae :=_beg .Str ();_bed :=make ([]byte ,len (_ddae ));
for _efg :=0;_efg < len (_ddae );_efg ++{_bed [_efg ]=_ddae [_efg ];};if len (_bed )> 0{_gf .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bed ,_bed );
_bed ,_gdc =_bec .decryptBytes (_bed ,_gdba ,_abe );if _gdc !=nil {return _gdc ;};};_beg ._addg =string (_bed );return nil ;case *PdfObjectArray :for _ ,_dec :=range _beg .Elements (){_gcfbf :=_bec .Decrypt (_dec ,parentObjNum ,parentGenNum );if _gcfbf !=nil {return _gcfbf ;
};};return nil ;case *PdfObjectDictionary :_fcc :=false ;if _ceeb :=_beg .Get ("\u0054\u0079\u0070\u0065");_ceeb !=nil {_affa ,_bgg :=_ceeb .(*PdfObjectName );if _bgg &&*_affa =="\u0053\u0069\u0067"{_fcc =true ;};};for _ ,_gga :=range _beg .Keys (){_bcgf :=_beg .Get (_gga );
if _fcc &&string (_gga )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_gga )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_gga )!="\u0050\u0072\u0065\u0076"&&string (_gga )!="\u004c\u0061\u0073\u0074"{_fge :=_bec .Decrypt (_bcgf ,parentObjNum ,parentGenNum );
if _fge !=nil {return _fge ;};};};return nil ;};return nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_afd Version )String ()string {return _af .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_afd .Major ,_afd .Minor );};var _faadf =_ga .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");
func (_cfc *PdfParser )skipSpaces ()(int ,error ){_adda :=0;for {_bcgeg ,_ebcbe :=_cfc ._fdc .ReadByte ();if _ebcbe !=nil {return 0,_ebcbe ;};if IsWhiteSpace (_bcgeg ){_adda ++;}else {_cfc ._fdc .UnreadByte ();break ;};};return _adda ,nil ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_ffcg *PdfParser )IsEncrypted ()(bool ,error ){if _ffcg ._bcgfc !=nil {return true ,nil ;}else if _ffcg ._ffe ==nil {return false ,nil ;};_gf .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_fbag :=_ffcg ._ffe .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _fbag ==nil {return false ,nil ;};_gf .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_edbb *PdfObjectDictionary ;);switch _dgcbfe :=_fbag .(type ){case *PdfObjectDictionary :_edbb =_dgcbfe ;
case *PdfObjectReference :_gf .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_dgcbfe );_fede ,_dcbge :=_ffcg .LookupByReference (*_dgcbfe );_gf .Log .Trace ("\u0031\u003a\u0020%\u0071",_fede );
if _dcbge !=nil {return false ,_dcbge ;};_afde ,_febf :=_fede .(*PdfIndirectObject );if !_febf {_gf .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_gdbce ,_febf :=_afde .PdfObject .(*PdfObjectDictionary );_ffcg ._efda =_afde ;_gf .Log .Trace ("\u0032\u003a\u0020%\u0071",_gdbce );if !_febf {return false ,_d .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
};_edbb =_gdbce ;case *PdfObjectNull :_gf .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_af .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_dgcbfe );};_fdfgcd ,_gegdf :=PdfCryptNewDecrypt (_ffcg ,_edbb ,_ffcg ._ffe );if _gegdf !=nil {return false ,_gegdf ;
};for _ ,_bbag :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_efe :=_ffcg ._ffe .Get (PdfObjectName (_bbag ));if _efe ==nil {continue ;};switch _afdb :=_efe .(type ){case *PdfObjectReference :_fdfgcd ._dbdb [int (_afdb .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_fdfgcd ._dbe [_afdb ]=true ;_fdfgcd ._dbdb [int (_afdb .ObjectNumber )]=struct{}{};};};_ffcg ._bcgfc =_fdfgcd ;_gf .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_fdfgcd );
return true ,nil ;};func _dfga (_fagc _cb .ReadSeeker ,_edgc int64 )(*limitedReadSeeker ,error ){_ ,_bga :=_fagc .Seek (0,_cb .SeekStart );if _bga !=nil {return nil ,_bga ;};return &limitedReadSeeker {_dcb :_fagc ,_adad :_edgc },nil ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_fadf :=&ASCII85Encoder {};return _fadf };

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_dcgeg *PdfParser )GetUpdatedObjects (prevParser *PdfParser )(map[int64 ]PdfObject ,error ){if prevParser ==nil {return nil ,_d .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_cfca ,_fbgfc :=_dcgeg .getNumbersOfUpdatedObjects (prevParser );if _fbgfc !=nil {return nil ,_fbgfc ;};_eegc :=make (map[int64 ]PdfObject );for _ ,_eebeb :=range _cfca {if _cgcg ,_gadge :=_dcgeg .LookupByNumber (_eebeb );_gadge ==nil {_eegc [int64 (_eebeb )]=_cgcg ;
}else {return nil ,_gadge ;};};return _eegc ,nil ;};

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_gdgb *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _gdgb ._efda };

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
//
//	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _cc .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _bfdd ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_ag .Error (_bfdd ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_aedf uint8 ;_bfdag _bb .Image ;_cfbd error ;);if bwThreshold ==JB2ImageAutoThreshold {_bfdag ,_cfbd =_bb .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_ag .Error (_bfdd ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_aedf =uint8 (255*bwThreshold );_bfdag ,_cfbd =_bb .MonochromeThresholdConverter (_aedf ).Convert (i );};if _cfbd !=nil {return nil ,_cfbd ;};return _edba (_bfdag ),nil ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_bacg :=MakeArray ();for _ ,_bbdd :=range vals {_bacg .Append (MakeInteger (int64 (_bbdd )));};return _bacg ;};func _egeg (_bdba string )(PdfObjectReference ,error ){_aabg :=PdfObjectReference {};
_bfec :=_faadf .FindStringSubmatch (_bdba );if len (_bfec )< 3{_gf .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _aabg ,_d .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};_ccff ,_ :=_db .Atoi (_bfec [1]);_gdee ,_ :=_db .Atoi (_bfec [2]);_aabg .ObjectNumber =int64 (_ccff );_aabg .GenerationNumber =int64 (_gdee );return _aabg ,nil ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_gc .Reader )(PdfObject ,error ){_fbdeb :=false ;_deaf :=true ;var _ecae _gbg .Buffer ;for {if _gf .Log .IsLogLevel (_gf .LogLevelTrace ){_gf .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_ecae .String ());
};_fdfa ,_fded :=buf .Peek (1);if _fded ==_cb .EOF {break ;};if _fded !=nil {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_fded );return nil ,_fded ;};if _deaf &&(_fdfa [0]=='-'||_fdfa [0]=='+'){_cccc ,_ :=buf .ReadByte ();_ecae .WriteByte (_cccc );
_deaf =false ;}else if IsDecimalDigit (_fdfa [0]){_ecacf ,_ :=buf .ReadByte ();_ecae .WriteByte (_ecacf );}else if _fdfa [0]=='.'{_daebe ,_ :=buf .ReadByte ();_ecae .WriteByte (_daebe );_fbdeb =true ;}else if _fdfa [0]=='e'||_fdfa [0]=='E'{_dafef ,_ :=buf .ReadByte ();
_ecae .WriteByte (_dafef );_fbdeb =true ;_deaf =true ;}else {break ;};};var _afgfg PdfObject ;if _fbdeb {_cfdb ,_fedb :=_db .ParseFloat (_ecae .String (),64);if _fedb !=nil {_gf .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_ecae .String (),_fedb );
_cfdb =0.0;};_baaa :=PdfObjectFloat (_cfdb );_afgfg =&_baaa ;}else {_egecc ,_bdge :=_db .ParseInt (_ecae .String (),10,64);if _bdge !=nil {_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_ecae .String (),_bdge );
_egecc =0;};_aefe :=PdfObjectInteger (_egecc );_afgfg =&_aefe ;};return _afgfg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dgdd *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };func (_gbed *PdfObjectDictionary )setWithLock (_gfbd PdfObjectName ,_dfce PdfObject ,_bfeea bool ){if _bfeea {_gbed ._fefbg .Lock ();defer _gbed ._fefbg .Unlock ();};
_ ,_gbcf :=_gbed ._cgdb [_gfbd ];if !_gbcf {_gbed ._gaccg =append (_gbed ._gaccg ,_gfbd );};_gbed ._cgdb [_gfbd ]=_dfce ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_efggd *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _efggd .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
// renamed to String() as a pretty string to use in debugging etc.
func (_ddag *MultiEncoder )GetFilterName ()string {_ddgb :="";for _ebeg ,_fdfe :=range _ddag ._fcge {_ddgb +=_fdfe .GetFilterName ();if _ebeg < len (_ddag ._fcge )-1{_ddgb +="\u0020";};};return _ddgb ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_dbdd Version ;_bcdda _cb .ReadSeeker ;_fdc *_gc .Reader ;_fbbge int64 ;_gfdb XrefTable ;_agfae int64 ;_cbae *xrefType ;_feaf objectStreams ;_ffe *PdfObjectDictionary ;_bcgfc *PdfCrypt ;_efda *PdfIndirectObject ;_edbc bool ;ObjCache objectCache ;
_fcbe map[int ]bool ;_fbge map[int64 ]bool ;_ebaa ParserMetadata ;_fdgb bool ;_fcca []int64 ;_decec int ;_ecbbe bool ;_gced int64 ;_fefb map[*PdfParser ]*PdfParser ;_acaa []*PdfParser ;};func (_aad *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_dda :=MakeDict ();
_dda .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_dda .Set ("\u0056",MakeInteger (int64 (_aad ._ffgd .V )));_dda .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_aad ._ffgd .Length )));
return _dda ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cdbc *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_gacfe :=&ASCIIHexEncoder {};return _gacfe };func (_bbbef *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_cb .SeekStart {offset +=_bbbef ._fbdd ;};_cgcfa ,_agdd :=_bbbef ._fgge .Seek (offset ,whence );
if _agdd !=nil {return _cgcfa ,_agdd ;};if whence ==_cb .SeekCurrent {_cgcfa -=_bbbef ._fbdd ;};if _cgcfa < 0{return 0,_d .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _cgcfa ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gdbc *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_cdae string ,_fagg bool ){_gbae ,_fagg :=TraceToDirectObject (obj ).(*PdfObjectName );if _fagg {return string (*_gbae ),true ;};return ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gf .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_aeaaa ,_afffg :=NewEncoderFromStream (streamObj );if _afffg !=nil {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_afffg );
return nil ,_afffg ;};_gf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_aeaaa );_gcdbe ,_afffg :=_aeaaa .DecodeStream (streamObj );if _afffg !=nil {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_afffg );
return nil ,_afffg ;};return _gcdbe ,nil ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _abeg _gbg .Buffer ;_abeg .Write ([]byte {0xFE,0xFF});_abeg .WriteString (_gfg .StringToUTF16 (s ));return &PdfObjectString {_addg :_abeg .String (),_ffff :true };};return &PdfObjectString {_addg :string (_gfg .StringToPDFDocEncoding (s )),_ffff :false };
};func (_fbee *PdfParser )parseArray ()(*PdfObjectArray ,error ){_ffee :=MakeArray ();_fbee ._fdc .ReadByte ();for {_fbee .skipSpaces ();_cffb ,_dgbfa :=_fbee ._fdc .Peek (1);if _dgbfa !=nil {return _ffee ,_dgbfa ;};if _cffb [0]==']'{_fbee ._fdc .ReadByte ();
break ;};_fgfg ,_dgbfa :=_fbee .parseObject ();if _dgbfa !=nil {return _ffee ,_dgbfa ;};_ffee .Append (_fgfg );};return _ffee ,nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _ceeca ,_baffg :=obj .(*PdfObjectReference );_baffg {obj =_ceeca .Resolve ();};_ggae ,_efcf :=obj .(*PdfIndirectObject );_acgf :=0;for _efcf {obj =_ggae .PdfObject ;_ggae ,_efcf =GetIndirect (obj );
_acgf ++;if _acgf > _dacf {_gf .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_dacf );
return nil ;};};return obj ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// String returns a string describing `ref`.
func (_ebdb *PdfObjectReference )String ()string {return _af .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_ebdb .ObjectNumber ,_ebdb .GenerationNumber );};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_bdfd :=&DCTEncoder {};_bdfd .ColorComponents =3;_bdfd .BitsPerComponent =8;_bdfd .Quality =DefaultJPEGQuality ;_bdfd .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};return _bdfd ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_ddad :=MultiEncoder {};_ddad ._fcge =[]StreamEncoder {};return &_ddad ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_bacd *_ccb .Document ;

// Globals are the JBIG2 global segments.
Globals _ef .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_bcgb ParserMetadata )HasDataAfterEOF ()bool {return _bcgb ._cbe };

// Append appends PdfObject(s) to the array.
func (_bgae *PdfObjectArray )Append (objects ...PdfObject ){if _bgae ==nil {_gf .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_bgae ._dcgec =append (_bgae ._dcgec ,objects ...);};func (_dab *PdfCrypt )loadCryptFilters (_acgd *PdfObjectDictionary )error {_dab ._fcag =cryptFilters {};_cbg :=_acgd .Get ("\u0043\u0046");_cbg =TraceToDirectObject (_cbg );if _ebdd ,_eedc :=_cbg .(*PdfObjectReference );
_eedc {_ecb ,_ddaa :=_dab ._bcc .LookupByReference (*_ebdd );if _ddaa !=nil {_gf .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _ddaa ;};_cbg =TraceToDirectObject (_ecb );};_bbf ,_cab :=_cbg .(*PdfObjectDictionary );if !_cab {_gf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_cbg );return _d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_cec :=range _bbf .Keys (){_cce :=_bbf .Get (_cec );if _eedd ,_gde :=_cce .(*PdfObjectReference );_gde {_bcb ,_gacf :=_dab ._bcc .LookupByReference (*_eedd );if _gacf !=nil {_gf .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _gacf ;};_cce =TraceToDirectObject (_bcb );};_ccbf ,_agf :=_cce .(*PdfObjectDictionary );if !_agf {return _af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_cec ,_cce );
};if _cec =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _ebdde _ee .FilterDict ;if _fgb :=_dae (&_ebdde ,_ccbf );_fgb !=nil {return _fgb ;};_cdb ,_agfa :=_ee .NewFilter (_ebdde );if _agfa !=nil {return _agfa ;};_dab ._fcag [string (_cec )]=_cdb ;};_dab ._fcag ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ee .NewIdentity ();
_dab ._eab ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dad ,_ggcg :=_acgd .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ggcg {if _ ,_bccf :=_dab ._fcag [string (*_dad )];!_bccf {return _af .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_dad );
};_dab ._eab =string (*_dad );};_dab ._bfe ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _face ,_aade :=_acgd .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_aade {if _ ,_abc :=_dab ._fcag [string (*_face )];!_abc {return _af .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_face );
};_dab ._bfe =string (*_face );};return nil ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_gcga *PdfIndirectObject ,_cgeg bool ){obj =ResolveReference (obj );_gcga ,_cgeg =obj .(*PdfIndirectObject );return _gcga ,_cgeg ;};

// HeaderPosition gets the file header position.
func (_gdfa ParserMetadata )HeaderPosition ()int {return _gdfa ._fbe };

// String returns a string describing `streams`.
func (_aeab *PdfObjectStreams )String ()string {return _af .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_aeab .ObjectNumber );};var (ErrUnsupportedEncodingParameters =_d .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");
ErrNoCCITTFaxDecode =_d .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_d .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_d .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_gg .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_d .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);const _fgf ="\u0053\u0074\u0064C\u0046";

// Seek implementation of Seek interface.
func (_edga *limitedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){var _gea int64 ;switch whence {case _cb .SeekStart :_gea =offset ;case _cb .SeekCurrent :_dgcbf ,_ecabd :=_edga ._dcb .Seek (0,_cb .SeekCurrent );if _ecabd !=nil {return 0,_ecabd ;
};_gea =_dgcbf +offset ;case _cb .SeekEnd :_gea =_edga ._adad +offset ;};if _fccc :=_edga .getError (_gea );_fccc !=nil {return 0,_fccc ;};if _ ,_edfb :=_edga ._dcb .Seek (_gea ,_cb .SeekStart );_edfb !=nil {return 0,_edfb ;};return _gea ,nil ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_cdbd *PdfObjectArray )Elements ()[]PdfObject {if _cdbd ==nil {return nil ;};return _cdbd ._dcgec ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_aggfg *PdfObjectDictionary ,_bbdgf bool ){_aggfg ,_bbdgf =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _aggfg ,_bbdgf ;};func (_cgafg *PdfObjectInteger )String ()string {return _af .Sprintf ("\u0025\u0064",*_cgafg )};


// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_aae *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_bbc :=MakeDict ();_bbc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aae .GetFilterName ()));_bbc .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_aae .MakeDecodeParams ());
return _bbc ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_baf *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_edd ,_ ,_bdb :=_baf .lookupByNumberWrapper (objNumber ,true );return _edd ,_bdb ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_cbgg :=&PdfCrypt {_cbcb :false ,_dbe :make (map[PdfObject ]bool ),_cae :make (map[PdfObject ]bool ),_dbdb :make (map[int ]struct{}),_bcc :parser };_gccc ,_efd :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_efd {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _cbgg ,_d .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_gccc !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_gf .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_gccc );
return _cbgg ,_d .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_cbgg ._ffgd .Filter =string (*_gccc );if _egbb ,_aac :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_aac {_cbgg ._ffgd .SubFilter =_egbb .Str ();
_gf .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_egbb );};if L ,_gcfb :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_gcfb {if (*L %8)!=0{_gf .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _cbgg ,_d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_cbgg ._ffgd .Length =int (*L );}else {_cbgg ._ffgd .Length =40;};_cbgg ._ffgd .V =0;if _gad ,_dac :=ed .Get ("\u0056").(*PdfObjectInteger );
_dac {V :=int (*_gad );_cbgg ._ffgd .V =V ;if V >=1&&V <=2{_cbgg ._fcag =_gcf (_cbgg ._ffgd .Length );}else if V >=4&&V <=5{if _babf :=_cbgg .loadCryptFilters (ed );_babf !=nil {return _cbgg ,_babf ;};}else {_gf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _cbgg ,_d .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _fgd :=_ggb (&_cbgg ._acc ,ed );_fgd !=nil {return _cbgg ,_fgd ;};_ccbfc :="";if _ebf ,_eebd :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_eebd &&_ebf .Len ()>=1{_bceb ,_ggfd :=GetString (_ebf .Get (0));if !_ggfd {return _cbgg ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_ccbfc =_bceb .Str ();}else {_gf .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_cbgg ._bc =_ccbfc ;return _cbgg ,nil ;};func _ggb (_dfd *_fg .StdEncryptDict ,_gbgc *PdfObjectDictionary )error {R ,_ece :=_gbgc .Get ("\u0052").(*PdfObjectInteger );if !_ece {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");
};if *R < 2||*R > 6{return _af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_dfd .R =int (*R );O ,_ece :=_gbgc .GetString ("\u004f");if !_ece {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");
};if _dfd .R ==5||_dfd .R ==6{if len (O )< 48{return _af .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _af .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));
};_dfd .O =[]byte (O );U ,_ece :=_gbgc .GetString ("\u0055");if !_ece {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _dfd .R ==5||_dfd .R ==6{if len (U )< 48{return _af .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));
};}else if len (U )!=32{_gf .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_dfd .U =[]byte (U );if _dfd .R >=5{OE ,_cba :=_gbgc .GetString ("\u004f\u0045");
if !_cba {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _af .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));
};_dfd .OE =[]byte (OE );UE ,_cba :=_gbgc .GetString ("\u0055\u0045");if !_cba {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _af .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_dfd .UE =[]byte (UE );};P ,_ece :=_gbgc .Get ("\u0050").(*PdfObjectInteger );if !_ece {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_dfd .P =_fg .Permissions (*P );if _dfd .R ==6{Perms ,_eee :=_gbgc .GetString ("\u0050\u0065\u0072m\u0073");if !_eee {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _af .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_dfd .Perms =[]byte (Perms );};if _bce ,_gef :=_gbgc .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_gef {_dfd .EncryptMetadata =bool (*_bce );}else {_dfd .EncryptMetadata =true ;};return nil ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_ggefc *PdfObjectReference )Resolve ()PdfObject {if _ggefc ._gcdb ==nil {return MakeNull ();};_agdgbb ,_ ,_bcfdf :=_ggefc ._gcdb .resolveReference (_ggefc );if _bcfdf !=nil {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_bcfdf );
return MakeNull ();};if _agdgbb ==nil {_gf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _agdgbb ;};func _ebcga (_gedg ,_bade ,_fbfbd int )error {if _bade < 0||_bade > _gedg {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _fbfbd < _bade {return _d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _fbfbd > _gedg {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_faad *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _geb ,_aabdc :=GetNumberAsInt64 (params .Get ("\u004b"));_aabdc ==nil {_faad .K =int (_geb );};if _fbfb ,_fcd :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_fcd ==nil {_faad .Columns =int (_fbfb );}else if _fbfb ,_fcd =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_fcd ==nil {_faad .Columns =int (_fbfb );};if _ebcb ,_dceec :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_dceec ==nil {_faad .BlackIs1 =_ebcb > 0;}else {if _bfeg ,_gbcd :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gbcd {_faad .BlackIs1 =_bfeg ;}else {if _bfbg ,_gfca :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_gfca {_gfab ,_eggbb :=_bfbg .ToIntegerArray ();if _eggbb ==nil {_faad .BlackIs1 =_gfab [0]==1&&_gfab [1]==0;};};};};if _geff ,_cfeg :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_cfeg ==nil {_faad .EncodedByteAlign =_geff > 0;}else {if _cdca ,_ddfa :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ddfa {_faad .EncodedByteAlign =_cdca ;};};if _ddcg ,_feff :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_feff ==nil {_faad .EndOfLine =_ddcg > 0;}else {if _cccd ,_egccg :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_egccg {_faad .EndOfLine =_cccd ;};};if _eegd ,_bagg :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_bagg ==nil {_faad .Rows =int (_eegd );}else if _eegd ,_bagg =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_bagg ==nil {_faad .Rows =int (_eegd );};if _cada ,_bdcb :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_bdcb ==nil {_faad .EndOfBlock =_cada > 0;}else {if _edg ,_ebef :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ebef {_faad .EndOfBlock =_edg ;};};if _gcdf ,_dbbf :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_dbbf !=nil {_faad .DamagedRowsBeforeError =int (_gcdf );};};

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_fbgb ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _fbgb ._ccaab };func (_aagd *FlateEncoder )postDecodePredict (_ced []byte )([]byte ,error ){if _aagd .Predictor > 1{if _aagd .Predictor ==2{_gf .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_gf .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_aagd .Colors );_cgd :=_aagd .Columns *_aagd .Colors ;if _cgd < 1{return []byte {},nil ;};_daada :=len (_ced )/_cgd ;if len (_ced )%_cgd !=0{_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ced ),_cgd );};if _cgd %_aagd .Colors !=0{return nil ,_af .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_cgd ,_aagd .Colors );
};if _cgd > len (_ced ){_gf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cgd ,len (_ced ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gf .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_ced ),_ced );
_fgeb :=_gbg .NewBuffer (nil );for _afe :=0;_afe < _daada ;_afe ++{_fcb :=_ced [_cgd *_afe :_cgd *(_afe +1)];for _gaceg :=_aagd .Colors ;_gaceg < _cgd ;_gaceg ++{_fcb [_gaceg ]+=_fcb [_gaceg -_aagd .Colors ];};_fgeb .Write (_fcb );};_cff :=_fgeb .Bytes ();
_gf .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_cff ),_cff );return _cff ,nil ;}else if _aagd .Predictor >=10&&_aagd .Predictor <=15{_gf .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_cagb :=_aagd .Columns *_aagd .Colors +1;_abfa :=len (_ced )/_cagb ;if len (_ced )%_cagb !=0{return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ced ),_cagb );
};if _cagb > len (_ced ){_gf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cagb ,len (_ced ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dgd :=_gbg .NewBuffer (nil );_gf .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_aagd .Columns );
_gf .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_ced ),_cagb ,_abfa );_bcec :=make ([]byte ,_cagb );for _cfab :=0;_cfab < _cagb ;_cfab ++{_bcec [_cfab ]=0;
};_cbff :=_aagd .Colors ;for _afcf :=0;_afcf < _abfa ;_afcf ++{_eddf :=_ced [_cagb *_afcf :_cagb *(_afcf +1)];_agef :=_eddf [0];switch _agef {case _dgb :case _gae :for _gdg :=1+_cbff ;_gdg < _cagb ;_gdg ++{_eddf [_gdg ]+=_eddf [_gdg -_cbff ];};case _adef :for _cef :=1;
_cef < _cagb ;_cef ++{_eddf [_cef ]+=_bcec [_cef ];};case _fbfa :for _bca :=1;_bca < _cbff +1;_bca ++{_eddf [_bca ]+=_bcec [_bca ]/2;};for _beb :=_cbff +1;_beb < _cagb ;_beb ++{_eddf [_beb ]+=byte ((int (_eddf [_beb -_cbff ])+int (_bcec [_beb ]))/2);};
case _abfga :for _fdec :=1;_fdec < _cagb ;_fdec ++{var _accf ,_cbaa ,_abfb byte ;_cbaa =_bcec [_fdec ];if _fdec >=_cbff +1{_accf =_eddf [_fdec -_cbff ];_abfb =_bcec [_fdec -_cbff ];};_eddf [_fdec ]+=_dbgb (_accf ,_cbaa ,_abfb );};default:_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_agef ,_afcf );
return nil ,_af .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_agef );};copy (_bcec ,_eddf );_dgd .Write (_eddf [1:]);};_aggf :=_dgd .Bytes ();return _aggf ,nil ;
}else {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_aagd .Predictor );return nil ,_af .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_aagd .Predictor );
};};return _ced ,nil ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;Decode []float64 ;};func (_fbeef *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_fbeef ._bcdda .Seek (0,_cb .SeekStart );_fbeef ._fdc =_gc .NewReader (_fbeef ._bcdda );
_cebb :=20;_cedg :=make ([]byte ,_cebb );for {_ddab ,_ggeaa :=_fbeef ._fdc .ReadByte ();if _ggeaa !=nil {if _ggeaa ==_cb .EOF {break ;}else {return 0,0,_ggeaa ;};};if IsDecimalDigit (_ddab )&&_cedg [_cebb -1]=='.'&&IsDecimalDigit (_cedg [_cebb -2])&&_cedg [_cebb -3]=='-'&&_cedg [_cebb -4]=='F'&&_cedg [_cebb -5]=='D'&&_cedg [_cebb -6]=='P'{_dcgef :=int (_cedg [_cebb -2]-'0');
_fcdg :=int (_ddab -'0');return _dcgef ,_fcdg ,nil ;};_cedg =append (_cedg [1:_cebb ],_ddab );};return 0,0,_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_cdc *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_efdfc :=_gbg .NewReader (encoded );var _affbf []byte ;for {_cfef ,_cdgc :=_efdfc .ReadByte ();if _cdgc !=nil {return nil ,_cdgc ;};if _cfef > 128{_cade ,_baee :=_efdfc .ReadByte ();
if _baee !=nil {return nil ,_baee ;};for _fag :=0;_fag < 257-int (_cfef );_fag ++{_affbf =append (_affbf ,_cade );};}else if _cfef < 128{for _cbec :=0;_cbec < int (_cfef )+1;_cbec ++{_afebd ,_aeac :=_efdfc .ReadByte ();if _aeac !=nil {return nil ,_aeac ;
};_affbf =append (_affbf ,_afebd );};}else {break ;};};return _affbf ,nil ;};

// ParserMetadata gets the pdf parser metadata.
func (_affb *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_affb ._fdgb {return ParserMetadata {},_af .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _affb ._ebaa ,nil ;};func (_baagc *PdfParser )parseXrefStream (_abgb *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _abgb !=nil {_gf .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_abgb );
_baagc ._bcdda .Seek (int64 (*_abgb ),_cb .SeekStart );_baagc ._fdc =_gc .NewReader (_baagc ._bcdda );};_dbeg :=_baagc .GetFileOffset ();_adbg ,_egca :=_baagc .ParseIndirectObject ();if _egca !=nil {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_gf .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_adbg );
_cecb ,_edcg :=_adbg .(*PdfObjectStream );if !_edcg {_gf .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_dbfg :=_cecb .PdfObjectDictionary ;
_aegf ,_edcg :=_cecb .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_edcg {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_d .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_aegf )> 8388607{_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_aegf );
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gdgf :=_cecb .PdfObjectDictionary .Get ("\u0057");_gbcc ,_edcg :=_gdgf .(*PdfObjectArray );if !_edcg {return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_gfga :=_gbcc .Len ();if _gfga !=3{_gf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_gfga );
return nil ,_d .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _cfbb []int64 ;for _agdgg :=0;_agdgg < 3;
_agdgg ++{_adgbe ,_eabc :=GetInt (_gbcc .Get (_agdgg ));if !_eabc {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_cfbb =append (_cfbb ,int64 (*_adgbe ));};_eeab ,_egca :=DecodeStream (_cecb );
if _egca !=nil {_gf .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_egca );return nil ,_egca ;};_daag :=int (_cfbb [0]);
_afbb :=int (_cfbb [0]+_cfbb [1]);_acgdf :=int (_cfbb [0]+_cfbb [1]+_cfbb [2]);_fbgf :=int (_cfbb [0]+_cfbb [1]+_cfbb [2]);if _daag < 0||_afbb < 0||_acgdf < 0{_gf .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_daag ,_afbb ,_acgdf );
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _fbgf ==0{_gf .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _dbfg ,nil ;};_gbcg :=len (_eeab )/_fbgf ;_edeb :=0;_bbee :=_cecb .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _ffbe []int ;if _bbee !=nil {_gf .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_bbee );_baabc ,_cbfc :=_bbee .(*PdfObjectArray );
if !_cbfc {_gf .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_d .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _baabc .Len ()%2!=0{_gf .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_edeb =0;_fbegf ,_abbag :=_baabc .ToIntegerArray ();if _abbag !=nil {_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_abbag );
return nil ,_abbag ;};for _fedf :=0;_fedf < len (_fbegf );_fedf +=2{_dade :=_fbegf [_fedf ];_ecef :=_fbegf [_fedf +1];for _bfgg :=0;_bfgg < _ecef ;_bfgg ++{_ffbe =append (_ffbe ,_dade +_bfgg );};_edeb +=_ecef ;};}else {for _bbgg :=0;_bbgg < int (*_aegf );
_bbgg ++{_ffbe =append (_ffbe ,_bbgg );};_edeb =int (*_aegf );};if _gbcg ==_edeb +1{_gf .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_bgedd :=_edeb -1;for _ ,_daagc :=range _ffbe {if _daagc > _bgedd {_bgedd =_daagc ;};};_ffbe =append (_ffbe ,_bgedd +1);_edeb ++;};if _gbcg !=len (_ffbe ){_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_gbcg ,len (_ffbe ));
return nil ,_d .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_gf .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_edeb );
_gf .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_ffbe );_ddaf :=func (_egccd []byte )int64 {var _adabd int64 ;for _afdd :=0;_afdd < len (_egccd );_afdd ++{_adabd +=int64 (_egccd [_afdd ])*(1<<uint (8*(len (_egccd )-_afdd -1)));
};return _adabd ;};_gf .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_eeab ));_dgca :=0;for _fdebf :=0;_fdebf < len (_eeab );_fdebf +=_fbgf {_cegbf :=_ebcga (len (_eeab ),_fdebf ,_fdebf +_daag );
if _cegbf !=nil {_gf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cegbf );return nil ,_cegbf ;};_abdb :=_eeab [_fdebf :_fdebf +_daag ];_cegbf =_ebcga (len (_eeab ),_fdebf +_daag ,_fdebf +_afbb );
if _cegbf !=nil {_gf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cegbf );return nil ,_cegbf ;};_gfcd :=_eeab [_fdebf +_daag :_fdebf +_afbb ];_cegbf =_ebcga (len (_eeab ),_fdebf +_afbb ,_fdebf +_acgdf );
if _cegbf !=nil {_gf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cegbf );return nil ,_cegbf ;};_dacg :=_eeab [_fdebf +_afbb :_fdebf +_acgdf ];_daeec :=_ddaf (_abdb );
_gba :=_ddaf (_gfcd );_acbfe :=_ddaf (_dacg );if _cfbb [0]==0{_daeec =1;};if _dgca >=len (_ffbe ){_gf .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_begde :=_ffbe [_dgca ];_dgca ++;_gf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_begde ,_abdb );_gf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_begde ,_gfcd );_gf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_begde ,_dacg );
_gf .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_begde ,_daeec ,_gba ,_acbfe );if _daeec ==0{_gf .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _daeec ==1{_gf .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_gfcd );if _gba ==_dbeg {_gf .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_begde ,_cecb .ObjectNumber );
_begde =int (_cecb .ObjectNumber );};if _gggac ,_addc :=_baagc ._gfdb .ObjectMap [_begde ];!_addc ||int (_acbfe )> _gggac .Generation {_bgfgb :=XrefObject {ObjectNumber :_begde ,XType :XrefTypeTableEntry ,Offset :_gba ,Generation :int (_acbfe )};_baagc ._gfdb .ObjectMap [_begde ]=_bgfgb ;
};}else if _daeec ==2{_gf .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_dfcc :=_baagc ._gfdb .ObjectMap [_begde ];!_dfcc {_gbfef :=XrefObject {ObjectNumber :_begde ,XType :XrefTypeObjectStream ,OsObjNumber :int (_gba ),OsObjIndex :int (_acbfe )};
_baagc ._gfdb .ObjectMap [_begde ]=_gbfef ;_gf .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_gbfef );};}else {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _baagc ._cbae ==nil {_dbc :=XrefTypeObjectStream ;_baagc ._cbae =&_dbc ;};return _dbfg ,nil ;};func _gcf (_bee int )cryptFilters {return cryptFilters {_fgf :_ee .NewFilterV2 (_bee )}};

// GetFilterName returns the name of the encoding filter.
func (_ddg *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };func _cbdc (_egfd *PdfObjectStream ,_fddc *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _fdfgc ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";
_eagdf :=NewJBIG2Encoder ();_cbbg :=_egfd .PdfObjectDictionary ;if _cbbg ==nil {return _eagdf ,nil ;};if _fddc ==nil {_cbcd :=_cbbg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _cbcd !=nil {switch _eacg :=_cbcd .(type ){case *PdfObjectDictionary :_fddc =_eacg ;
case *PdfObjectArray :if _eacg .Len ()==1{if _ccdb ,_eefaf :=GetDict (_eacg .Get (0));_eefaf {_fddc =_ccdb ;};};default:_gf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_cbcd );
return nil ,_ag .Errorf (_fdfgc ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_eacg );};};};if _fddc ==nil {return _eagdf ,nil ;};_eagdf .UpdateParams (_fddc );
_eccg ,_caaf :=GetStream (_fddc .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_caaf {return _eagdf ,nil ;};var _fddca error ;_eagdf .Globals ,_fddca =_ef .DecodeGlobals (_eccg .Stream );if _fddca !=nil {_fddca =_ag .Wrap (_fddca ,_fdfgc ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_gf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fddca );return nil ,_fddca ;};return _eagdf ,nil ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_aba *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_aba .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};

// WriteString outputs the object as it is to be written to file.
func (_ggcgc *PdfObjectString )WriteString ()string {var _baad _gbg .Buffer ;if _ggcgc ._ffff {_dfbgc :=_cg .EncodeToString (_ggcgc .Bytes ());_baad .WriteString ("\u003c");_baad .WriteString (_dfbgc );_baad .WriteString ("\u003e");return _baad .String ();
};_abeee :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_baad .WriteString ("\u0028");for _dcbb :=0;_dcbb < len (_ggcgc ._addg );
_dcbb ++{_dacga :=_ggcgc ._addg [_dcbb ];if _fecbd ,_eddfa :=_abeee [_dacga ];_eddfa {_baad .WriteString (_fecbd );}else {_baad .WriteByte (_dacga );};};_baad .WriteString ("\u0029");return _baad .String ();};func (_bad *PdfCrypt )securityHandler ()_fg .StdHandler {if _bad ._acc .R >=5{return _fg .NewHandlerR6 ();
};return _fg .NewHandlerR4 (_bad ._bc ,_bad ._ffgd .Length );};

// GetFilterName returns the name of the encoding filter.
func (_efad *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };func (_dege *PdfParser )skipComments ()error {if _ ,_dgfed :=_dege .skipSpaces ();_dgfed !=nil {return _dgfed ;};_gedd :=true ;for {_caca ,_ddb :=_dege ._fdc .Peek (1);
if _ddb !=nil {_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ddb .Error ());return _ddb ;};if _gedd &&_caca [0]!='%'{return nil ;};_gedd =false ;if (_caca [0]!='\r')&&(_caca [0]!='\n'){_dege ._fdc .ReadByte ();}else {break ;};};return _dege .skipComments ();
};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cbeb *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// WriteString outputs the object as it is to be written to file.
func (_dcaa *PdfIndirectObject )WriteString ()string {var _fbgd _cf .Builder ;_fbgd .WriteString (_db .FormatInt (_dcaa .ObjectNumber ,10));_fbgd .WriteString ("\u0020\u0030\u0020\u0052");return _fbgd .String ();};

// GetFilterName returns the name of the encoding filter.
func (_bedfb *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };func (_ddfdg *PdfParser )inspect ()(map[string ]int ,error ){_gf .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_gf .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_aegd :=map[string ]int {};_ecff :=0;_gdbab :=0;var _bdbbb []int ;for _adaae :=range _ddfdg ._gfdb .ObjectMap {_bdbbb =append (_bdbbb ,_adaae );};_ff .Ints (_bdbbb );_cdag :=0;
for _ ,_dacfc :=range _bdbbb {_dacfd :=_ddfdg ._gfdb .ObjectMap [_dacfc ];if _dacfd .ObjectNumber ==0{continue ;};_ecff ++;_gf .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_gf .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_dacfd .ObjectNumber );
_bgedf ,_adaec :=_ddfdg .LookupByNumber (_dacfd .ObjectNumber );if _adaec !=nil {_gf .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_dacfd .ObjectNumber ,_adaec );
_gdbab ++;continue ;};_gf .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_bgedf );_bgaf ,_aeedd :=_bgedf .(*PdfIndirectObject );if _aeedd {_gf .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_dacfd .ObjectNumber ,_bgaf );
_abgc ,_bfaag :=_bgaf .PdfObject .(*PdfObjectDictionary );if _bfaag {if _fabfc ,_aaed :=_abgc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_aaed {_eeeg :=string (*_fabfc );_gf .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_eeeg );
_ ,_dbbdc :=_aegd [_eeeg ];if _dbbdc {_aegd [_eeeg ]++;}else {_aegd [_eeeg ]=1;};}else if _adgbc ,_gddcb :=_abgc .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_gddcb {_edaec :=string (*_adgbc );_gf .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_edaec );
_ ,_ccga :=_aegd [_edaec ];if _ccga {_aegd [_edaec ]++;}else {_aegd [_edaec ]=1;};};if _dgffa ,_fcbfb :=_abgc .Get ("\u0053").(*PdfObjectName );_fcbfb &&*_dgffa =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_addbf :=_aegd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _addbf {_aegd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_aegd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _eacfb ,_efbg :=_bgedf .(*PdfObjectStream );_efbg {if _dbbda ,_gcef :=_eacfb .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_gcef {_gf .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_dbbda );_bcfe :=string (*_dbbda );_aegd [_bcfe ]++;};}else {_gecb ,_cdgb :=_bgedf .(*PdfObjectDictionary );
if _cdgb {_bfbdc ,_cggg :=_gecb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _cggg {_ddbc :=string (*_bfbdc );_gf .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_ddbc );_aegd [_ddbc ]++;};};_gf .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_dacfd .ObjectNumber ,_bgedf );
};_cdag ++;};_gf .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_gf .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");
_gf .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_ecff );_gf .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_gdbab );for _daggf ,_agcga :=range _aegd {_gf .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_daggf ,_agcga );
};_gf .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_ddfdg ._gfdb .ObjectMap )< 1{_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_af .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_fdecd ,_gbcfde :=_aegd ["\u0046\u006f\u006e\u0074"];
if !_gbcfde ||_fdecd < 2{_gf .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_gf .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _aegd ,nil ;};

// String returns a string describing `stream`.
func (_edgac *PdfObjectStream )String ()string {return _af .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_edgac .ObjectNumber ,_edgac .PdfObjectDictionary );};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_degbd :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_degbd .PdfObjectDictionary =encoder .MakeStreamDict ();_fgdf ,_dbga :=encoder .EncodeBytes (contents );
if _dbga !=nil {return nil ,_dbga ;};_degbd .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fgdf ))));_degbd .Stream =_fgdf ;return _degbd ,nil ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_fgec *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fgec .DecodeBytes (streamObj .Stream );};func (_adcf *JBIG2Image )toBitmap ()(_aaeg *_ca .Bitmap ,_ffdc error ){const _aaff ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";
if _adcf .Data ==nil {return nil ,_ag .Error (_aaff ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _adcf .Width ==0||_adcf .Height ==0{return nil ,_ag .Error (_aaff ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _adcf .HasPadding {_aaeg ,_ffdc =_ca .NewWithData (_adcf .Width ,_adcf .Height ,_adcf .Data );}else {_aaeg ,_ffdc =_ca .NewWithUnpaddedData (_adcf .Width ,_adcf .Height ,_adcf .Data );};if _ffdc !=nil {return nil ,_ag .Wrap (_ffdc ,_aaff ,"");};return _aaeg ,nil ;
};func (_febae *limitedReadSeeker )getError (_bcegb int64 )error {switch {case _bcegb < 0:return _af .Errorf ("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064",_bcegb );
case _bcegb > _febae ._adad :return _af .Errorf ("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064",_bcegb );};return nil ;};

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_ebe ParserMetadata )HasInvalidHexRunes ()bool {return _ebe ._eecf };func _begdc (_ddgd int )int {_fddf :=_ddgd >>(_ffab -1);return (_ddgd ^_fddf )-_fddf };

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_ddgdg *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_ddgdg ._gdfde ){return _d .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_ddgdg ._gdfde [i ]=obj ;return nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_acdc JBIG2EncoderSettings )Validate ()error {const _fbef ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _acdc .Threshold < 0||_acdc .Threshold > 1.0{return _ag .Errorf (_fbef ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_acdc .Threshold );
};if _acdc .ResolutionX < 0{return _ag .Errorf (_fbef ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_acdc .ResolutionX );
};if _acdc .ResolutionY < 0{return _ag .Errorf (_fbef ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_acdc .ResolutionY );
};if _acdc .DefaultPixelValue !=0&&_acdc .DefaultPixelValue !=1{return _ag .Errorf (_fbef ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_acdc .DefaultPixelValue );
};if _acdc .Compression !=JB2Generic {return _ag .Errorf (_fbef ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};func (_cddg *PdfParser )readTextLine ()(string ,error ){var _bdeg _gbg .Buffer ;for {_dcbg ,_gdce :=_cddg ._fdc .Peek (1);if _gdce !=nil {_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gdce .Error ());return _bdeg .String (),_gdce ;
};if (_dcbg [0]!='\r')&&(_dcbg [0]!='\n'){_fdad ,_ :=_cddg ._fdc .ReadByte ();_bdeg .WriteByte (_fdad );}else {break ;};};return _bdeg .String (),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gbff *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};type offsetReader struct{_fgge _cb .ReadSeeker ;_fbdd int64 ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_dggg *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ffde :=_gbg .NewReader (encoded );_cgab ,_fgce :=_c .Decode (_ffde );if _fgce !=nil {_gf .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_fgce );
return nil ,_fgce ;};_gfgd :=_cgab .Bounds ();var _fbde =make ([]byte ,_gfgd .Dx ()*_gfgd .Dy ()*_dggg .ColorComponents *_dggg .BitsPerComponent /8);_egcf :=0;switch _dggg .ColorComponents {case 1:_cgad :=[]float64 {_dggg .Decode [0],_dggg .Decode [1]};
for _ebg :=_gfgd .Min .Y ;_ebg < _gfgd .Max .Y ;_ebg ++{for _gbgb :=_gfgd .Min .X ;_gbgb < _gfgd .Max .X ;_gbgb ++{_cfd :=_cgab .At (_gbgb ,_ebg );if _dggg .BitsPerComponent ==16{_cbcff ,_acbf :=_cfd .(_gb .Gray16 );if !_acbf {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_fdf :=_ccd (uint (_cbcff .Y >>8),_cgad [0],_cgad [1]);_gbdg :=_ccd (uint (_cbcff .Y ),_cgad [0],_cgad [1]);_fbde [_egcf ]=byte (_fdf );_egcf ++;_fbde [_egcf ]=byte (_gbdg );_egcf ++;}else {_eeae ,_ecab :=_cfd .(_gb .Gray );if !_ecab {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_fbde [_egcf ]=byte (_ccd (uint (_eeae .Y ),_cgad [0],_cgad [1]));_egcf ++;};};};case 3:_dcfg :=[]float64 {_dggg .Decode [0],_dggg .Decode [1]};_deab :=[]float64 {_dggg .Decode [2],_dggg .Decode [3]};_gadg :=[]float64 {_dggg .Decode [4],_dggg .Decode [5]};
for _bfaf :=_gfgd .Min .Y ;_bfaf < _gfgd .Max .Y ;_bfaf ++{for _ccea :=_gfgd .Min .X ;_ccea < _gfgd .Max .X ;_ccea ++{_bbad :=_cgab .At (_ccea ,_bfaf );if _dggg .BitsPerComponent ==16{_gbfe ,_bfdc :=_bbad .(_gb .RGBA64 );if !_bfdc {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_bcd :=_ccd (uint (_gbfe .R >>8),_dcfg [0],_dcfg [1]);_cccb :=_ccd (uint (_gbfe .R ),_dcfg [0],_dcfg [1]);_bdg :=_ccd (uint (_gbfe .G >>8),_deab [0],_deab [1]);_cccf :=_ccd (uint (_gbfe .G ),_deab [0],_deab [1]);_bbfg :=_ccd (uint (_gbfe .B >>8),_gadg [0],_gadg [1]);
_dbeb :=_ccd (uint (_gbfe .B ),_gadg [0],_gadg [1]);_fbde [_egcf ]=byte (_bcd );_egcf ++;_fbde [_egcf ]=byte (_cccb );_egcf ++;_fbde [_egcf ]=byte (_bdg );_egcf ++;_fbde [_egcf ]=byte (_cccf );_egcf ++;_fbde [_egcf ]=byte (_bbfg );_egcf ++;_fbde [_egcf ]=byte (_dbeb );
_egcf ++;}else {_fcae ,_bfac :=_bbad .(_gb .RGBA );if _bfac {_ccg :=_ccd (uint (_fcae .R ),_dcfg [0],_dcfg [1]);_eba :=_ccd (uint (_fcae .G ),_deab [0],_deab [1]);_bcef :=_ccd (uint (_fcae .B ),_gadg [0],_gadg [1]);_fbde [_egcf ]=byte (_ccg );_egcf ++;
_fbde [_egcf ]=byte (_eba );_egcf ++;_fbde [_egcf ]=byte (_bcef );_egcf ++;}else {_bdfg ,_edbe :=_bbad .(_gb .YCbCr );if !_edbe {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_caga ,_gdbae ,_egcg ,_ :=_bdfg .RGBA ();
_addb :=_ccd (uint (_caga >>8),_dcfg [0],_dcfg [1]);_ebddb :=_ccd (uint (_gdbae >>8),_deab [0],_deab [1]);_eeaac :=_ccd (uint (_egcg >>8),_gadg [0],_gadg [1]);_fbde [_egcf ]=byte (_addb );_egcf ++;_fbde [_egcf ]=byte (_ebddb );_egcf ++;_fbde [_egcf ]=byte (_eeaac );
_egcf ++;};};};};case 4:_fdga :=[]float64 {_dggg .Decode [0],_dggg .Decode [1]};_feba :=[]float64 {_dggg .Decode [2],_dggg .Decode [3]};_agc :=[]float64 {_dggg .Decode [4],_dggg .Decode [5]};_eeff :=[]float64 {_dggg .Decode [6],_dggg .Decode [7]};for _baca :=_gfgd .Min .Y ;
_baca < _gfgd .Max .Y ;_baca ++{for _ddde :=_gfgd .Min .X ;_ddde < _gfgd .Max .X ;_ddde ++{_efdf :=_cgab .At (_ddde ,_baca );_agefb ,_gcgf :=_efdf .(_gb .CMYK );if !_gcgf {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_adf :=255-_ccd (uint (_agefb .C ),_fdga [0],_fdga [1]);_gfgg :=255-_ccd (uint (_agefb .M ),_feba [0],_feba [1]);_dbdc :=255-_ccd (uint (_agefb .Y ),_agc [0],_agc [1]);_gfge :=255-_ccd (uint (_agefb .K ),_eeff [0],_eeff [1]);_fbde [_egcf ]=byte (_adf );
_egcf ++;_fbde [_egcf ]=byte (_gfgg );_egcf ++;_fbde [_egcf ]=byte (_dbdc );_egcf ++;_fbde [_egcf ]=byte (_gfge );_egcf ++;};};};return _fbde ,nil ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_efaa *PdfObjectDictionary )Keys ()[]PdfObjectName {if _efaa ==nil {return nil ;};return _efaa ._gaccg ;};

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_bfda ParserMetadata )HasEOLAfterHeader ()bool {return _bfda ._gaad };

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_dggf *PdfParser )GetRevision (revisionNumber int )(*PdfParser ,error ){_babfg :=_dggf ._decec ;if _babfg ==revisionNumber {return _dggf ,nil ;};if _babfg < revisionNumber {return nil ,_d .New ("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e");
};if _dggf ._acaa [revisionNumber ]!=nil {return _dggf ._acaa [revisionNumber ],nil ;};_cfebd :=_dggf ;for ;_babfg > revisionNumber ;_babfg --{_fcgc ,_cfcgd :=_cfebd .GetPreviousRevisionParser ();if _cfcgd !=nil {return nil ,_cfcgd ;};_dggf ._acaa [_babfg -1]=_fcgc ;
_dggf ._fefb [_cfebd ]=_fcgc ;_cfebd =_fcgc ;};return _cfebd ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_cdd *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_aaa ,_agga :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _agga ==nil {_cdd .Predictor =int (_aaa );};_dcfa ,_agga :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _agga ==nil {_cdd .BitsPerComponent =int (_dcfa );};_ebde ,_agga :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _agga ==nil {_cdd .Columns =int (_ebde );};_cggc ,_agga :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _agga ==nil {_cdd .Colors =int (_cggc );};_fbbc ,_agga :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _agga ==nil {_cdd .EarlyChange =int (_fbbc );};};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_edc *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_dffc :=MakeDict ();_dffc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_edc .GetFilterName ()));return _dffc ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _egcfg (obj ,0)};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_abfd *PdfParser )GetTrailer ()*PdfObjectDictionary {return _abfd ._ffe };

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_bega :=PdfObjectNull {};return &_bega };

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_gdab *PdfObjectArray )Get (i int )PdfObject {if _gdab ==nil ||i >=len (_gdab ._dcgec )||i < 0{return nil ;};return _gdab ._dcgec [i ];};func _cgbc (_bgdb int )int {if _bgdb < 0{return -_bgdb ;};return _bgdb ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dddg *LZWEncoder )MakeDecodeParams ()PdfObject {if _dddg .Predictor > 1{_acab :=MakeDict ();_acab .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_dddg .Predictor )));if _dddg .BitsPerComponent !=8{_acab .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_dddg .BitsPerComponent )));
};if _dddg .Columns !=1{_acab .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_dddg .Columns )));};if _dddg .Colors !=1{_acab .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_dddg .Colors )));};return _acab ;};return nil ;
};func _ddbf (_cafg string )(int ,int ,error ){_dgee :=_cdegb .FindStringSubmatch (_cafg );if len (_dgee )< 3{return 0,0,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_ffcd ,_ :=_db .Atoi (_dgee [1]);_bbdf ,_ :=_db .Atoi (_dgee [2]);return _ffcd ,_bbdf ,nil ;};

// Len returns the number of elements in the array.
func (_aafa *PdfObjectArray )Len ()int {if _aafa ==nil {return 0;};return len (_aafa ._dcgec );};func (_daded *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_daded ._gfdb .ObjectMap =make (map[int ]XrefObject );_daded ._feaf =make (objectStreams );
_caba ,_dafb :=_daded ._bcdda .Seek (0,_cb .SeekEnd );if _dafb !=nil {return nil ,_dafb ;};_gf .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_caba );_daded ._fbbge =_caba ;_dafb =_daded .seekToEOFMarker (_caba );if _dafb !=nil {_gf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_dafb );
return nil ,_dafb ;};_eacb ,_dafb :=_daded ._bcdda .Seek (0,_cb .SeekCurrent );if _dafb !=nil {return nil ,_dafb ;};var _cadf int64 =64;_gbda :=_eacb -_cadf ;if _gbda < 0{_gbda =0;};_ ,_dafb =_daded ._bcdda .Seek (_gbda ,_cb .SeekStart );if _dafb !=nil {return nil ,_dafb ;
};_gecf :=make ([]byte ,_cadf );_ ,_dafb =_daded ._bcdda .Read (_gecf );if _dafb !=nil {_gf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_dafb );
return nil ,_dafb ;};_abfdg :=_fbae .FindStringSubmatch (string (_gecf ));if len (_abfdg )< 2{_gf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");
return nil ,_d .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_abfdg )> 2{_gf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_gecf );
return nil ,_d .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_gfed ,_ :=_db .ParseInt (_abfdg [1],10,64);_gf .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_gfed );
if _gfed > _caba {_gf .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_gf .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");
_gfed ,_dafb =_daded .repairLocateXref ();if _dafb !=nil {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_dafb ;};};_daded ._bcdda .Seek (_gfed ,_cb .SeekStart );_daded ._fdc =_gc .NewReader (_daded ._bcdda );_cfge ,_dafb :=_daded .parseXref ();if _dafb !=nil {return nil ,_dafb ;};_eccf :=_cfge .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _eccf !=nil {_fgbc ,_dgada :=_eccf .(*PdfObjectInteger );
if !_dgada {return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_dafb =_daded .parseXrefStream (_fgbc );if _dafb !=nil {return nil ,_dafb ;};};var _dgdb []int64 ;_aebd :=func (_fecd int64 ,_ffba []int64 )bool {for _ ,_fdb :=range _ffba {if _fdb ==_fecd {return true ;
};};return false ;};_eccf =_cfge .Get ("\u0050\u0072\u0065\u0076");for _eccf !=nil {_dbge ,_abgd :=_eccf .(*PdfObjectInteger );if !_abgd {_gf .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_eccf );
return _cfge ,nil ;};_bcfac :=*_dbge ;_gf .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_bcfac );_daded ._bcdda .Seek (int64 (_bcfac ),_cb .SeekStart );
_daded ._fdc =_gc .NewReader (_daded ._bcdda );_abff ,_efac :=_daded .parseXref ();if _efac !=nil {_gf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_gf .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_daded ._fcca =append (_daded ._fcca ,int64 (_bcfac ));
_eccf =_abff .Get ("\u0050\u0072\u0065\u0076");if _eccf !=nil {_fgef :=*(_eccf .(*PdfObjectInteger ));if _aebd (int64 (_fgef ),_dgdb ){_gf .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_dgdb =append (_dgdb ,int64 (_fgef ));};};return _cfge ,nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_gdbba *PdfParser )GetXrefType ()*xrefType {return _gdbba ._cbae };

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_egea *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_gbfed :=range another .Keys (){_febaa :=another .Get (_gbfed );_egea .Set (_gbfed ,_febaa );};};return _egea ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _abaf (o ,0,traversed );};type objectCache map[int ]PdfObject ;

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_efb *PdfObjectFloat ,_afgf bool ){_efb ,_afgf =TraceToDirectObject (obj ).(*PdfObjectFloat );return _efb ,_afgf ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_eefb :=&LZWEncoder {};_eefb .Predictor =1;_eefb .BitsPerComponent =8;_eefb .Colors =1;_eefb .Columns =1;_eefb .EarlyChange =1;return _eefb ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_eebef :=&PdfIndirectObject {};_eebef .PdfObject =obj ;return _eebef ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// String returns a string describing `ind`.
func (_fbfae *PdfIndirectObject )String ()string {return _af .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_fbfae ).ObjectNumber );};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_feag *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _cfba _gbg .Buffer ;_agge :=_gbg .NewReader (encoded );var _geea _cb .ReadCloser ;if _feag .EarlyChange ==1{_geea =_fa .NewReader (_agge ,_fa .MSB ,8);}else {_geea =_ae .NewReader (_agge ,_ae .MSB ,8);
};defer _geea .Close ();if _ ,_dbaf :=_cfba .ReadFrom (_geea );_dbaf !=nil {if _dbaf !=_cb .ErrUnexpectedEOF ||_cfba .Len ()==0{return nil ,_dbaf ;};_gf .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_dbaf );
};return _cfba .Bytes (),nil ;};const _ffab =32<<(^uint (0)>>63);const JB2ImageAutoThreshold =-1.0;var _eafg =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");func (_bgfg *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _dfbg *PdfObjectDictionary ;
_gdfc ,_bggag :=_bgfg .readTextLine ();if _bggag !=nil {return nil ,_bggag ;};if _bgfg ._fdgb &&_cf .Count (_cf .TrimPrefix (_gdfc ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_bgfg ._ebaa ._ccaab =true ;};_gf .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_gdfc );
_faaa :=-1;_fagba :=0;_gcea :=false ;_ebbd :="";for {_bgfg .skipSpaces ();_ ,_bfdae :=_bgfg ._fdc .Peek (1);if _bfdae !=nil {return nil ,_bfdae ;};_gdfc ,_bfdae =_bgfg .readTextLine ();if _bfdae !=nil {return nil ,_bfdae ;};_dgff :=_adff .FindStringSubmatch (_gdfc );
if len (_dgff )==0{_bgde :=len (_ebbd )> 0;_ebbd +=_gdfc +"\u000a";if _bgde {_dgff =_adff .FindStringSubmatch (_ebbd );};};if len (_dgff )==3{if _bgfg ._fdgb &&!_bgfg ._ebaa ._daf {var (_ffdef bool ;_eecg int ;);for _ ,_aagcb :=range _gdfc {if _fd .IsDigit (_aagcb ){if _ffdef {break ;
};continue ;};if !_ffdef {_ffdef =true ;};_eecg ++;};if _eecg > 1{_bgfg ._ebaa ._daf =true ;};};_ggga ,_ :=_db .Atoi (_dgff [1]);_adae ,_ :=_db .Atoi (_dgff [2]);_faaa =_ggga ;_fagba =_adae ;_gcea =true ;_ebbd ="";_gf .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_faaa ,_fagba );
continue ;};_ccda :=_bcgd .FindStringSubmatch (_gdfc );if len (_ccda )==4{if !_gcea {_gf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_d .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_afec ,_ :=_db .ParseInt (_ccda [1],10,64);_facc ,_ :=_db .Atoi (_ccda [2]);_gfgbe :=_ccda [3];_ebbd ="";if _cf .ToLower (_gfgbe )=="\u006e"&&_afec > 1{_cacb ,_acbc :=_bgfg ._gfdb .ObjectMap [_faaa ];if !_acbc ||_facc > _cacb .Generation {_dagg :=XrefObject {ObjectNumber :_faaa ,XType :XrefTypeTableEntry ,Offset :_afec ,Generation :_facc };
_bgfg ._gfdb .ObjectMap [_faaa ]=_dagg ;};};_faaa ++;continue ;};if (len (_gdfc )> 6)&&(_gdfc [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_gf .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_gdfc );
if len (_gdfc )> 9{_bbgcc :=_bgfg .GetFileOffset ();_bgfg .SetFileOffset (_bbgcc -int64 (len (_gdfc ))+7);};_bgfg .skipSpaces ();_bgfg .skipComments ();_gf .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_gf .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_gdfc );_dfbg ,_bfdae =_bgfg .ParseDict ();_gf .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _bfdae !=nil {_gf .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bfdae );return nil ,_bfdae ;};break ;};if _gdfc =="\u0025\u0025\u0045O\u0046"{_gf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_d .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_gf .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_gdfc );
};_gf .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _bgfg ._cbae ==nil {_fcac :=XrefTypeTableEntry ;_bgfg ._cbae =&_fcac ;};return _dfbg ,nil ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_ccegd *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_ggfea :=data ;var _ebfd error ;for _ceecg :=len (_ccegd ._fcge )-1;_ceecg >=0;_ceecg --{_fdff :=_ccegd ._fcge [_ceecg ];_ggfea ,_ebfd =_fdff .EncodeBytes (_ggfea );if _ebfd !=nil {return nil ,_ebfd ;
};};return _ggfea ,nil ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _caea ,_dgda :=obj .(*PdfObjectReference );_dgda {return _caea .Resolve ();};return obj ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_dbec string ,_gdabc bool ){_beeea ,_gdabc :=TraceToDirectObject (obj ).(*PdfObjectString );if _gdabc {return _beeea .Str (),true ;};return ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_ecda :=MakeArray ();for _ ,_deegg :=range vals {_ecda .Append (MakeFloat (_deegg ));};return _ecda ;};func _dbgb (_gdga ,_bgd ,_ebdab uint8 )uint8 {_geba :=int (_ebdab );_cfgc :=int (_bgd )-_geba ;
_bgcf :=int (_gdga )-_geba ;_geba =_begdc (_cfgc +_bgcf );_cfgc =_begdc (_cfgc );_bgcf =_begdc (_bgcf );if _cfgc <=_bgcf &&_cfgc <=_geba {return _gdga ;}else if _bgcf <=_geba {return _bgd ;};return _ebdab ;};var _ffgc =_ga .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");


// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bbfb *PdfCrypt )GetAccessPermissions ()_fg .Permissions {return _bbfb ._acc .P };

// HasNonConformantStream implements core.ParserMetadata.
func (_agg ParserMetadata )HasNonConformantStream ()bool {return _agg ._fbg };func (_efaf *PdfParser )parseObject ()(PdfObject ,error ){_gf .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_efaf .skipSpaces ();
for {_agad ,_cegb :=_efaf ._fdc .Peek (2);if _cegb !=nil {if _cegb !=_cb .EOF ||len (_agad )==0{return nil ,_cegb ;};if len (_agad )==1{_agad =append (_agad ,' ');};};_gf .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_agad ));
if _agad [0]=='/'{_badd ,_deef :=_efaf .parseName ();_gf .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_badd );return &_badd ,_deef ;}else if _agad [0]=='('{_gf .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");
_cadaa ,_abdcf :=_efaf .parseString ();return _cadaa ,_abdcf ;}else if _agad [0]=='['{_gf .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_fcgee ,_gdgbd :=_efaf .parseArray ();return _fcgee ,_gdgbd ;}else if (_agad [0]=='<')&&(_agad [1]=='<'){_gf .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_deed ,_ffbg :=_efaf .ParseDict ();return _deed ,_ffbg ;}else if _agad [0]=='<'{_gf .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_fabc ,_bbec :=_efaf .parseHexString ();return _fabc ,_bbec ;}else if _agad [0]=='%'{_efaf .readComment ();
_efaf .skipSpaces ();}else {_gf .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_agad ,_ =_efaf ._fdc .Peek (15);_efafe :=string (_agad );_gf .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_efafe );
if (len (_efafe )> 3)&&(_efafe [:4]=="\u006e\u0075\u006c\u006c"){_acdf ,_begccg :=_efaf .parseNull ();return &_acdf ,_begccg ;}else if (len (_efafe )> 4)&&(_efafe [:5]=="\u0066\u0061\u006cs\u0065"){_afdf ,_gceb :=_efaf .parseBool ();return &_afdf ,_gceb ;
}else if (len (_efafe )> 3)&&(_efafe [:4]=="\u0074\u0072\u0075\u0065"){_caeg ,_eafe :=_efaf .parseBool ();return &_caeg ,_eafe ;};_eaaa :=_faadf .FindStringSubmatch (_efafe );if len (_eaaa )> 1{_agad ,_ =_efaf ._fdc .ReadBytes ('R');_gf .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_agad [:]));
_fgff ,_geed :=_egeg (string (_agad ));_fgff ._gcdb =_efaf ;return &_fgff ,_geed ;};_bfaa :=_bbga .FindStringSubmatch (_efafe );if len (_bfaa )> 1{_gf .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_ggfb ,_dgcc :=_efaf .parseNumber ();
return _ggfb ,_dgcc ;};_bfaa =_ffgc .FindStringSubmatch (_efafe );if len (_bfaa )> 1{_gf .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_gf .Log .Trace ("\u0025\u0020\u0073",_bfaa );
_fggee ,_ddeg :=_efaf .parseNumber ();return _fggee ,_ddeg ;};_gf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_efafe );return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};var _ccbcf =_ga .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_daadg *PdfParser )CheckAccessRights (password []byte )(bool ,_fg .Permissions ,error ){if _daadg ._bcgfc ==nil {return true ,_fg .PermOwner ,nil ;};return _daadg ._bcgfc .checkAccessRights (password );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gega *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_fefbd float64 ,_eaca bool ){_aegg ,_eaca :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _eaca {return float64 (*_aegg ),true ;};return 0,false ;};func (_gcecf *PdfParser )rebuildXrefTable ()error {_cdegd :=XrefTable {};
_cdegd .ObjectMap =map[int ]XrefObject {};_dbeba :=make ([]int ,0,len (_gcecf ._gfdb .ObjectMap ));for _dgfbd :=range _gcecf ._gfdb .ObjectMap {_dbeba =append (_dbeba ,_dgfbd );};_ff .Ints (_dbeba );for _ ,_geeea :=range _dbeba {_edac :=_gcecf ._gfdb .ObjectMap [_geeea ];
_adba ,_ ,_ddee :=_gcecf .lookupByNumberWrapper (_geeea ,false );if _ddee !=nil {_gf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_ddee );
_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_bgffc ,_caad :=_gcecf .repairRebuildXrefsTopDown ();if _caad !=nil {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_caad );
return _caad ;};_gcecf ._gfdb =*_bgffc ;_gf .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_gdbf ,_def ,_ddee :=_ec (_adba );if _ddee !=nil {return _ddee ;
};_edac .ObjectNumber =int (_gdbf );_edac .Generation =int (_def );_cdegd .ObjectMap [int (_gdbf )]=_edac ;};_gcecf ._gfdb =_cdegd ;_gf .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_bge (_gcecf ._gfdb );
return nil ;};func _ggc (_feb *_fg .StdEncryptDict ,_egb *PdfObjectDictionary ){_egb .Set ("\u0052",MakeInteger (int64 (_feb .R )));_egb .Set ("\u0050",MakeInteger (int64 (_feb .P )));_egb .Set ("\u004f",MakeStringFromBytes (_feb .O ));_egb .Set ("\u0055",MakeStringFromBytes (_feb .U ));
if _feb .R >=5{_egb .Set ("\u004f\u0045",MakeStringFromBytes (_feb .OE ));_egb .Set ("\u0055\u0045",MakeStringFromBytes (_feb .UE ));_egb .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_feb .EncryptMetadata ));
if _feb .R > 5{_egb .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_feb .Perms ));};};};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_addg string ;_ffff bool ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cgdc *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };func (_fbdbb *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_dcfgb :=_fbdbb ._fdc .Discard (4);return PdfObjectNull {},_dcfgb ;};var _cdegb =_ga .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");


// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_ecce *JBIG2Encoder )EncodeImage (img _cc .Image )([]byte ,error ){return _ecce .encodeImage (img )};

// String returns a descriptive information string about the encryption method used.
func (_abbd *PdfCrypt )String ()string {if _abbd ==nil {return "";};_gbcb :=_abbd ._ffgd .Filter +"\u0020\u002d\u0020";if _abbd ._ffgd .V ==0{_gbcb +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _abbd ._ffgd .V ==1{_gbcb +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _abbd ._ffgd .V ==2{_gbcb +=_af .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_abbd ._ffgd .Length );}else if _abbd ._ffgd .V ==3{_gbcb +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _abbd ._ffgd .V >=4{_gbcb +=_af .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_abbd ._bfe ,_abbd ._eab );
_gbcb +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _aca ,_fgg :=range _abbd ._fcag {_gbcb +=_af .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_aca ,_fgg .Name (),_fgg .KeyLength ());
};};_bab :=_abbd .GetAccessPermissions ();_gbcb +=_af .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_bab );return _gbcb ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_abg *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_aced :=MakeDict ();_aced .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_abg .GetFilterName ()));_gab :=_abg .MakeDecodeParams ();if _gab !=nil {_aced .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gab );
};_aced .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_abg .EarlyChange )));return _aced ;};

// WriteString outputs the object as it is to be written to file.
func (_adbcd *PdfObjectFloat )WriteString ()string {return _db .FormatFloat (float64 (*_adbcd ),'f',-1,64);};

// WriteString outputs the object as it is to be written to file.
func (_deegd *PdfObjectDictionary )WriteString ()string {var _bgaa _cf .Builder ;_bgaa .WriteString ("\u003c\u003c");for _ ,_gbcdg :=range _deegd ._gaccg {_dcgdc :=_deegd ._cgdb [_gbcdg ];_bgaa .WriteString (_gbcdg .WriteString ());_bgaa .WriteString ("\u0020");
_bgaa .WriteString (_dcgdc .WriteString ());};_bgaa .WriteString ("\u003e\u003e");return _bgaa .String ();};func (_dbfe *PdfParser )xrefNextObjectOffset (_ebcbf int64 )int64 {_afab :=int64 (0);if len (_dbfe ._gfdb .ObjectMap )==0{return 0;};if len (_dbfe ._gfdb ._eg )==0{_cecf :=0;
for _ ,_dcda :=range _dbfe ._gfdb .ObjectMap {if _dcda .Offset > 0{_cecf ++;};};if _cecf ==0{return 0;};_dbfe ._gfdb ._eg =make ([]XrefObject ,_cecf );_abge :=0;for _ ,_cfce :=range _dbfe ._gfdb .ObjectMap {if _cfce .Offset > 0{_dbfe ._gfdb ._eg [_abge ]=_cfce ;
_abge ++;};};_ff .Slice (_dbfe ._gfdb ._eg ,func (_dafe ,_cda int )bool {return _dbfe ._gfdb ._eg [_dafe ].Offset < _dbfe ._gfdb ._eg [_cda ].Offset });};_edfc :=_ff .Search (len (_dbfe ._gfdb ._eg ),func (_bbbc int )bool {return _dbfe ._gfdb ._eg [_bbbc ].Offset >=_ebcbf });
if _edfc < len (_dbfe ._gfdb ._eg ){_afab =_dbfe ._gfdb ._eg [_edfc ].Offset ;};return _afab ;};

// MakeLazy create temporary file for stream to reduce memory usage.
// It can be used for creating PDF with many images.
// Temporary files are removed automatically when Write/WriteToFile is called for creator object.
func (_cace *PdfObjectStream )MakeLazy ()error {if _cace .Lazy {return nil ;};_becga ,_fgae :=_a .CreateTemp ("","\u0078o\u0062\u006a\u0065\u0063\u0074");if _fgae !=nil {return _fgae ;};defer _becga .Close ();_ ,_fgae =_becga .Write (_cace .Stream );if _fgae !=nil {return _fgae ;
};_cace .Lazy =true ;_cace .Stream =nil ;_cace .TempFile =_becga .Name ();return nil ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_eafb :=&PdfObjectDictionary {};_eafb ._cgdb =map[PdfObjectName ]PdfObject {};_eafb ._gaccg =[]PdfObjectName {};_eafb ._fefbg =&_g .Mutex {};return _eafb ;};var _fbae =_ga .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");


// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_gfdf *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_afegg :=encoded ;var _eaea error ;for _ ,_efga :=range _gfdf ._fcge {_gf .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_efga ,_efga );
_afegg ,_eaea =_efga .DecodeBytes (_afegg );if _eaea !=nil {return nil ,_eaea ;};};return _afegg ,nil ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_gcdb *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// WriteString outputs the object as it is to be written to file.
func (_cdcaf *PdfObjectArray )WriteString ()string {var _egdb _cf .Builder ;_egdb .WriteString ("\u005b");for _gdac ,_cbeba :=range _cdcaf .Elements (){_egdb .WriteString (_cbeba .WriteString ());if _gdac < (_cdcaf .Len ()-1){_egdb .WriteString ("\u0020");
};};_egdb .WriteString ("\u005d");return _egdb .String ();};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};const _dacf =10;

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_bdfe .Store (filterName ,customStreamEncoder );};func (_bcgbe *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){_bcgbe .skipSpaces ();const _acae =20;_dgbe ,_ :=_bcgbe ._fdc .Peek (_acae );
for _ggbg :=0;_ggbg < 2;_ggbg ++{if _bcgbe ._agfae ==0{_bcgbe ._agfae =_bcgbe .GetFileOffset ();};if _cdegb .Match (_dgbe ){_gf .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_gf .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_dgbe ));return _bcgbe .parseXrefStream (nil );};if _gfcb .Match (_dgbe ){_gf .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _bcgbe .parseXrefTable ();};_gccf :=_bcgbe .GetFileOffset ();if _bcgbe ._agfae ==0{_bcgbe ._agfae =_gccf ;};_bcgbe .SetFileOffset (_gccf -_acae );defer _bcgbe .SetFileOffset (_gccf );_gcgd ,_ :=_bcgbe ._fdc .Peek (_acae );_dgbe =append (_gcgd ,_dgbe ...);
};_gf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _bbfa :=_bcgbe .repairSeekXrefMarker ();_bbfa !=nil {_gf .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_bbfa );return nil ,_bbfa ;};return _bcgbe .parseXrefTable ();};type cryptFilters map[string ]_ee .Filter ;


// PdfVersion returns version of the PDF file.
func (_fbfc *PdfParser )PdfVersion ()Version {return _fbfc ._dbdd };

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_gf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_beca ,_cced :=NewEncoderFromStream (streamObj );if _cced !=nil {_gf .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cced );
return _cced ;};if _aada ,_fcfa :=_beca .(*LZWEncoder );_fcfa {_aada .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_gf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_beca );
_gebgd ,_cced :=_beca .EncodeBytes (streamObj .Stream );if _cced !=nil {_gf .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cced );return _cced ;
};streamObj .Stream =_gebgd ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gebgd ))));return nil ;};

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_eeffa *PdfParser )GetPreviousRevisionParser ()(*PdfParser ,error ){if _eeffa ._decec ==0{return nil ,_d .New ("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e");};if _ecge ,_gddd :=_eeffa ._fefb [_eeffa ];
_gddd {return _ecge ,nil ;};_cgbbf ,_ggeg :=_eeffa .GetPreviousRevisionReadSeeker ();if _ggeg !=nil {return nil ,_ggeg ;};_ecgef ,_ggeg :=NewParser (_cgbbf );_ecgef ._fefb =_eeffa ._fefb ;if _ggeg !=nil {return nil ,_ggeg ;};_eeffa ._fefb [_eeffa ]=_ecgef ;
return _ecgef ,nil ;};

// Clear resets the dictionary to an empty state.
func (_bdbba *PdfObjectDictionary )Clear (){_bdbba ._gaccg =[]PdfObjectName {};_bdbba ._cgdb =map[PdfObjectName ]PdfObject {};_bdbba ._fefbg =&_g .Mutex {};};func _dae (_cfb *_ee .FilterDict ,_eed *PdfObjectDictionary )error {if _gge ,_eff :=_eed .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_eff {if _cdf :=string (*_gge );_cdf !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_gf .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_cdf );
};};_ada ,_ebd :=_eed .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_ebd {return _af .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_cfb .CFM =string (*_ada );if _cdg ,_egg :=_eed .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_egg {_cfb .AuthEvent =_fg .AuthEvent (*_cdg );}else {_cfb .AuthEvent =_fg .EventDocOpen ;};if _daad ,_efc :=_eed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_efc {_cfb .Length =int (*_daad );};return nil ;};func _daed (_gdbb *PdfObjectStream ,_gbd *PdfObjectDictionary )(*FlateEncoder ,error ){_eded :=NewFlateEncoder ();_dbf :=_gdbb .PdfObjectDictionary ;if _dbf ==nil {return _eded ,nil ;};_eded ._dgg =_aaeb (_dbf );
if _gbd ==nil {_dabd :=TraceToDirectObject (_dbf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _deda :=_dabd .(type ){case *PdfObjectArray :if _deda .Len ()!=1{_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_deda .Len ());
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _bcbe ,_gag :=GetDict (_deda .Get (0));_gag {_gbd =_bcbe ;};case *PdfObjectDictionary :_gbd =_deda ;case *PdfObjectNull ,nil :default:_gf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_dabd );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gbd ==nil {return _eded ,nil ;};_gf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_gbd .String ());
_aeaa :=_gbd .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _aeaa ==nil {_gf .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_fccd ,_ecg :=_aeaa .(*PdfObjectInteger );if !_ecg {_gf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_aeaa );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_eded .Predictor =int (*_fccd );};_aeaa =_gbd .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _aeaa !=nil {_dgfb ,_gfgbg :=_aeaa .(*PdfObjectInteger );if !_gfgbg {_gf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_af .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_eded .BitsPerComponent =int (*_dgfb );if _eded .BitsPerComponent !=_eded ._dgg .BitsPerComponent {_gf .Log .Debug ("\u0057A\u0052\u004e\u0049\u004eG\u003a \u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006di\u0073\u006d\u0061\u0074\u0063\u0068\u0020\u0077\u0069\u0074\u0068 \u0069\u006d\u0061\u0067\u0065\u0020\u0028\u0025\u0064\u002f%\u0064\u0029\u002c\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020i\u006da\u0067\u0065",_eded .BitsPerComponent ,_eded ._dgg .BitsPerComponent );
_eded .BitsPerComponent =_eded ._dgg .BitsPerComponent ;};};if _eded .Predictor > 1{_eded .Columns =1;_aeaa =_gbd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _aeaa !=nil {_ddff ,_gee :=_aeaa .(*PdfObjectInteger );if !_gee {return nil ,_af .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_eded .Columns =int (*_ddff );};_eded .Colors =1;_aeaa =_gbd .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _aeaa !=nil {_cbf ,_afaa :=_aeaa .(*PdfObjectInteger );if !_afaa {return nil ,_af .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_eded .Colors =int (*_cbf );};};return _eded ,nil ;};func (_bbe *PdfParser )lookupByNumberWrapper (_ggfg int ,_cbc bool )(PdfObject ,bool ,error ){_egfe ,_cca ,_df :=_bbe .lookupByNumber (_ggfg ,_cbc );if _df !=nil {return nil ,_cca ,_df ;};if !_cca &&_bbe ._bcgfc !=nil &&_bbe ._bcgfc ._cbcb &&!_bbe ._bcgfc .isDecrypted (_egfe ){_bgf :=_bbe ._bcgfc .Decrypt (_egfe ,0,0);
if _bgf !=nil {return nil ,_cca ,_bgf ;};};return _egfe ,_cca ,nil ;};

// String returns a string describing `array`.
func (_aacf *PdfObjectArray )String ()string {_aged :="\u005b";for _cfcfg ,_efff :=range _aacf .Elements (){_aged +=_efff .String ();if _cfcfg < (_aacf .Len ()-1){_aged +="\u002c\u0020";};};_aged +="\u005d";return _aged ;};const (_dgb =0;_gae =1;_adef =2;
_fbfa =3;_abfga =4;);

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_dgbb *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _bfed ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _bbged :=_dgbb .AddPageImage (img ,&_dgbb .DefaultPageSettings );
_bbged !=nil {return nil ,_ag .Wrap (_bbged ,_bfed ,"");};return _dgbb .Encode ();};func (_gdbd *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _gdbd ._edbc {return nil ,_af .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_gdbd ._edbc =true ;_gdbd ._bcdda .Seek (0,_cb .SeekStart );_gdbd ._fdc =_gc .NewReader (_gdbd ._bcdda );_ccegg :=20;_dgece :=make ([]byte ,_ccegg );_dada :=XrefTable {};_dada .ObjectMap =make (map[int ]XrefObject );for {_cfae ,_geeac :=_gdbd ._fdc .ReadByte ();
if _geeac !=nil {if _geeac ==_cb .EOF {break ;}else {return nil ,_geeac ;};};if _cfae =='j'&&_dgece [_ccegg -1]=='b'&&_dgece [_ccegg -2]=='o'&&IsWhiteSpace (_dgece [_ccegg -3]){_fagdb :=_ccegg -4;for IsWhiteSpace (_dgece [_fagdb ])&&_fagdb > 0{_fagdb --;
};if _fagdb ==0||!IsDecimalDigit (_dgece [_fagdb ]){continue ;};for IsDecimalDigit (_dgece [_fagdb ])&&_fagdb > 0{_fagdb --;};if _fagdb ==0||!IsWhiteSpace (_dgece [_fagdb ]){continue ;};for IsWhiteSpace (_dgece [_fagdb ])&&_fagdb > 0{_fagdb --;};if _fagdb ==0||!IsDecimalDigit (_dgece [_fagdb ]){continue ;
};for IsDecimalDigit (_dgece [_fagdb ])&&_fagdb > 0{_fagdb --;};if _fagdb ==0{continue ;};_aaad :=_gdbd .GetFileOffset ()-int64 (_ccegg -_fagdb );_begaf :=append (_dgece [_fagdb +1:],_cfae );_efdb ,_ebdbg ,_aafc :=_ddbf (string (_begaf ));if _aafc !=nil {_gf .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_aafc );
return nil ,_aafc ;};if _debga ,_cbcbb :=_dada .ObjectMap [_efdb ];!_cbcbb ||_debga .Generation < _ebdbg {_cgda :=XrefObject {};_cgda .XType =XrefTypeTableEntry ;_cgda .ObjectNumber =_efdb ;_cgda .Generation =_ebdbg ;_cgda .Offset =_aaad ;_dada .ObjectMap [_efdb ]=_cgda ;
};};_dgece =append (_dgece [1:_ccegg ],_cfae );};_gdbd ._fcbe =nil ;return &_dada ,nil ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_cbcbe *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gf .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_gf .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cbcbe .Predictor );
_dbed ,_feaa :=_cbcbe .DecodeBytes (streamObj .Stream );if _feaa !=nil {return nil ,_feaa ;};_gf .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_gf .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_dbed ),_dbed );
if _cbcbe .Predictor > 1{if _cbcbe .Predictor ==2{_gf .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_adgda :=_cbcbe .Columns *_cbcbe .Colors ;if _adgda < 1{return []byte {},nil ;};_egbg :=len (_dbed )/_adgda ;
if len (_dbed )%_adgda !=0{_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dbed ),_adgda );};if _adgda %_cbcbe .Colors !=0{return nil ,_af .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_adgda ,_cbcbe .Colors );
};if _adgda > len (_dbed ){_gf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_adgda ,len (_dbed ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gf .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_dbed ),_dbed );
_bfa :=_gbg .NewBuffer (nil );for _gcfa :=0;_gcfa < _egbg ;_gcfa ++{_bdd :=_dbed [_adgda *_gcfa :_adgda *(_gcfa +1)];for _aabd :=_cbcbe .Colors ;_aabd < _adgda ;_aabd ++{_bdd [_aabd ]=byte (int (_bdd [_aabd ]+_bdd [_aabd -_cbcbe .Colors ])%256);};_bfa .Write (_bdd );
};_caae :=_bfa .Bytes ();_gf .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_caae ),_caae );return _caae ,nil ;}else if _cbcbe .Predictor >=10&&_cbcbe .Predictor <=15{_gf .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_baff :=_cbcbe .Columns *_cbcbe .Colors +1;if _baff < 1{return []byte {},nil ;};_cedb :=len (_dbed )/_baff ;if len (_dbed )%_baff !=0{return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dbed ),_baff );
};if _baff > len (_dbed ){_gf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_baff ,len (_dbed ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bedd :=_gbg .NewBuffer (nil );_gf .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_cbcbe .Columns );
_gf .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_dbed ),_baff ,_cedb );_gec :=make ([]byte ,_baff );for _dcccc :=0;_dcccc < _baff ;_dcccc ++{_gec [_dcccc ]=0;
};for _dfgbf :=0;_dfgbf < _cedb ;_dfgbf ++{_cefg :=_dbed [_baff *_dfgbf :_baff *(_dfgbf +1)];_fdd :=_cefg [0];switch _fdd {case 0:case 1:for _edeg :=2;_edeg < _baff ;_edeg ++{_cefg [_edeg ]=byte (int (_cefg [_edeg ]+_cefg [_edeg -1])%256);};case 2:for _baab :=1;
_baab < _baff ;_baab ++{_cefg [_baab ]=byte (int (_cefg [_baab ]+_gec [_baab ])%256);};default:_gf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fdd );
return nil ,_af .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fdd );};for _acgb :=0;_acgb < _baff ;_acgb ++{_gec [_acgb ]=_cefg [_acgb ];};_bedd .Write (_cefg [1:]);
};_ffcf :=_bedd .Bytes ();return _ffcf ,nil ;}else {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_cbcbe .Predictor );
return nil ,_af .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_cbcbe .Predictor );};};return _dbed ,nil ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_dgeca int ,_eadc bool ){_fdfcc ,_eadc :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _eadc &&_fdfcc !=nil {return int (*_fdfcc ),true ;};return 0,false ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_dgae *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _fcab _gbg .Buffer ;for _ ,_debf :=range data {_fcab .WriteString (_af .Sprintf ("\u0025\u002e\u0032X\u0020",_debf ));};_fcab .WriteByte ('>');return _fcab .Bytes (),nil ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_gbfc *PdfParser )Inspect ()(map[string ]int ,error ){return _gbfc .inspect ()};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_aagb *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bef []byte ;_gf .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_aafb :=0;_faf :=false ;for _aafb < len (encoded )&&!_faf {_cccfd :=[5]byte {0,0,0,0,0};
_gacef :=0;_caf :=0;_eac :=4;for _caf < 5+_gacef {if _aafb +_caf ==len (encoded ){break ;};_bcfa :=encoded [_aafb +_caf ];if IsWhiteSpace (_bcfa ){_gacef ++;_caf ++;continue ;}else if _bcfa =='~'&&_aafb +_caf +1< len (encoded )&&encoded [_aafb +_caf +1]=='>'{_eac =(_caf -_gacef )-1;
if _eac < 0{_eac =0;};_faf =true ;break ;}else if _bcfa >='!'&&_bcfa <='u'{_bcfa -='!';}else if _bcfa =='z'&&_caf -_gacef ==0{_eac =4;_caf ++;break ;}else {_gf .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_cccfd [_caf -_gacef ]=_bcfa ;_caf ++;};_aafb +=_caf ;for _cceae :=_eac +1;_cceae < 5;_cceae ++{_cccfd [_cceae ]=84;
};_cece :=uint32 (_cccfd [0])*85*85*85*85+uint32 (_cccfd [1])*85*85*85+uint32 (_cccfd [2])*85*85+uint32 (_cccfd [3])*85+uint32 (_cccfd [4]);_dca :=[]byte {byte ((_cece >>24)&0xff),byte ((_cece >>16)&0xff),byte ((_cece >>8)&0xff),byte (_cece &0xff)};_bef =append (_bef ,_dca [:_eac ]...);
};_gf .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_gf .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_bef );
return _bef ,nil ;};

// String returns a string describing `null`.
func (_fbga *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};func _abaf (_gcebc PdfObject ,_dcbd int ,_ecag map[PdfObject ]struct{})error {_gf .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_dcbd );
if _ ,_ffffe :=_ecag [_gcebc ];_ffffe {_gf .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_ecag [_gcebc ]=struct{}{};switch _ggeae :=_gcebc .(type ){case *PdfIndirectObject :_feae :=_ggeae ;
_gf .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_feae );_gf .Log .Trace ("\u002d\u0020\u0025\u0073",_feae .PdfObject );return _abaf (_feae .PdfObject ,_dcbd +1,_ecag );case *PdfObjectStream :_dceg :=_ggeae ;return _abaf (_dceg .PdfObjectDictionary ,_dcbd +1,_ecag );
case *PdfObjectDictionary :_cebe :=_ggeae ;_gf .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_cebe );for _ ,_bedfe :=range _cebe .Keys (){_gbbb :=_cebe .Get (_bedfe );if _fgfdg ,_aeeg :=_gbbb .(*PdfObjectReference );_aeeg {_bfba :=_fgfdg .Resolve ();
_cebe .Set (_bedfe ,_bfba );_bbece :=_abaf (_bfba ,_dcbd +1,_ecag );if _bbece !=nil {return _bbece ;};}else {_eabb :=_abaf (_gbbb ,_dcbd +1,_ecag );if _eabb !=nil {return _eabb ;};};};return nil ;case *PdfObjectArray :_edff :=_ggeae ;_gf .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_edff );
for _fbege ,_degf :=range _edff .Elements (){if _dddb ,_bgcfb :=_degf .(*PdfObjectReference );_bgcfb {_abbe :=_dddb .Resolve ();_edff .Set (_fbege ,_abbe );_gedc :=_abaf (_abbe ,_dcbd +1,_ecag );if _gedc !=nil {return _gedc ;};}else {_gbgcg :=_abaf (_degf ,_dcbd +1,_ecag );
if _gbgcg !=nil {return _gbgcg ;};};};return nil ;case *PdfObjectReference :_gf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _d .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_bdaa *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_eddgf ,_gabd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _gabd ==nil {_bdaa .BitsPerComponent =int (_eddgf );
};_afg ,_gabd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _gabd ==nil {_bdaa .Width =int (_afg );};_bgfd ,_gabd :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _gabd ==nil {_bdaa .Height =int (_bgfd );
};_cbag ,_gabd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _gabd ==nil {_bdaa .ColorComponents =int (_cbag );};};func (_dabe *JBIG2Encoder )encodeImage (_ddcb _cc .Image )([]byte ,error ){const _affad ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";
_cfaa ,_afgc :=GoImageToJBIG2 (_ddcb ,JB2ImageAutoThreshold );if _afgc !=nil {return nil ,_ag .Wrap (_afgc ,_affad ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");
};if _afgc =_dabe .AddPageImage (_cfaa ,&_dabe .DefaultPageSettings );_afgc !=nil {return nil ,_ag .Wrap (_afgc ,_affad ,"");};return _dabe .Encode ();};func (_baef *PdfParser )seekToEOFMarker (_dafa int64 )error {var _facb int64 ;var _addac int64 =2048;
for _facb < _dafa -4{if _dafa <=(_addac +_facb ){_addac =_dafa -_facb ;};_ ,_bcfd :=_baef ._bcdda .Seek (_dafa -_facb -_addac ,_cb .SeekStart );if _bcfd !=nil {return _bcfd ;};_daae :=make ([]byte ,_addac );_baef ._bcdda .Read (_daae );_gf .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_daae ));
_cfcb :=_edgg .FindAllStringIndex (string (_daae ),-1);if _cfcb !=nil {_aage :=_cfcb [len (_cfcb )-1];_gf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cfcb );_ggec :=_dafa -_facb -_addac +int64 (_aage [0]);_baef ._bcdda .Seek (_ggec ,_cb .SeekStart );
return nil ;};_gf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_facb +=_addac -4;};_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _cagf ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_gdfde []PdfObject ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_bedde *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ef .Globals ,error ){return _ef .DecodeGlobals (encoded );};

// DecodeStream implements ASCII85 stream decoding.
func (_bcfab *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bcfab .DecodeBytes (streamObj .Stream );};func (_agdg *offsetReader )Read (p []byte )(_adgb int ,_febd error ){return _agdg ._fgge .Read (p )};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_dcgec []PdfObject };

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_egcgg *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_cdde :=_gbg .NewReader (data );var _beeeb []byte ;var _cdec []byte ;_ebgd ,_fddef :=_cdde .ReadByte ();if _fddef ==_cb .EOF {return []byte {},nil ;}else if _fddef !=nil {return nil ,_fddef ;
};_beba :=1;for {_dfc ,_cbbb :=_cdde .ReadByte ();if _cbbb ==_cb .EOF {break ;}else if _cbbb !=nil {return nil ,_cbbb ;};if _dfc ==_ebgd {if len (_cdec )> 0{_cdec =_cdec [:len (_cdec )-1];if len (_cdec )> 0{_beeeb =append (_beeeb ,byte (len (_cdec )-1));
_beeeb =append (_beeeb ,_cdec ...);};_beba =1;_cdec =[]byte {};};_beba ++;if _beba >=127{_beeeb =append (_beeeb ,byte (257-_beba ),_ebgd );_beba =0;};}else {if _beba > 0{if _beba ==1{_cdec =[]byte {_ebgd };}else {_beeeb =append (_beeeb ,byte (257-_beba ),_ebgd );
};_beba =0;};_cdec =append (_cdec ,_dfc );if len (_cdec )>=127{_beeeb =append (_beeeb ,byte (len (_cdec )-1));_beeeb =append (_beeeb ,_cdec ...);_cdec =[]byte {};};};_ebgd =_dfc ;};if len (_cdec )> 0{_beeeb =append (_beeeb ,byte (len (_cdec )-1));_beeeb =append (_beeeb ,_cdec ...);
}else if _beba > 0{_beeeb =append (_beeeb ,byte (257-_beba ),_ebgd );};_beeeb =append (_beeeb ,128);return _beeeb ,nil ;};type objectStream struct{N int ;_aeb []byte ;_ce map[int ]int64 ;};func _bbfgc (_bdgd *PdfObjectStream ,_fef *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;
};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_efddf []byte ,_cgeaa bool ){_bfgec ,_cgeaa :=TraceToDirectObject (obj ).(*PdfObjectString );if _cgeaa {return _bfgec .Bytes (),true ;};return ;};

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_eacf :=MakeDict ();return _eacf .Update (objmap );};func _dfeb ()string {return _gf .Version };

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_bacb *PdfObjectInteger ,_bfece bool ){_bacb ,_bfece =TraceToDirectObject (obj ).(*PdfObjectInteger );return _bacb ,_bfece ;};var _edgg =_ga .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_fddce bool ,_dfab bool ){_aegb ,_dfab :=TraceToDirectObject (obj ).(*PdfObjectBool );if _dfab {return bool (*_aegb ),true ;};return false ,false ;};func (_edb *PdfCrypt )decryptBytes (_ega []byte ,_cgcf string ,_dffbg []byte )([]byte ,error ){_gf .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_bae ,_fed :=_edb ._fcag [_cgcf ];if !_fed {return nil ,_af .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cgcf );};return _bae .DecryptBytes (_ega ,_dffbg );};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_befb *PdfObjectBool ,_dbgc bool ){_befb ,_dbgc =TraceToDirectObject (obj ).(*PdfObjectBool );return _befb ,_dbgc ;};var _bcgd =_ga .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");


// WriteString outputs the object as it is to be written to file.
func (_bcdag *PdfObjectStreams )WriteString ()string {var _fefcd _cf .Builder ;_fefcd .WriteString (_db .FormatInt (_bcdag .ObjectNumber ,10));_fefcd .WriteString ("\u0020\u0030\u0020\u0052");return _fefcd .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_bbg *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;Lazy bool ;TempFile string ;};

// GetXrefOffset returns the offset of the xref table.
func (_fdfb *PdfParser )GetXrefOffset ()int64 {return _fdfb ._agfae };

// String returns a string representation of `name`.
func (_cfaf *PdfObjectName )String ()string {return string (*_cfaf )};

// WriteString outputs the object as it is to be written to file.
func (_eeabe *PdfObjectBool )WriteString ()string {if *_eeabe {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_gdbaf :=PdfObjectString {_addg :s };return &_gdbaf };

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_ddcd *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ddcd .setWithLock (key ,val ,true );};

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_cgf *PdfObjectString )IsHexadecimal ()bool {return _cgf ._ffff };func _begd (_cbbf *PdfObjectStream )(*MultiEncoder ,error ){_cbbec :=NewMultiEncoder ();_facag :=_cbbf .PdfObjectDictionary ;if _facag ==nil {return _cbbec ,nil ;};var _gaab *PdfObjectDictionary ;
var _eacc []PdfObject ;_fbfd :=_facag .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _fbfd !=nil {_dcab ,_bcgg :=_fbfd .(*PdfObjectDictionary );if _bcgg {_gaab =_dcab ;};_aadb ,_aecac :=_fbfd .(*PdfObjectArray );if _aecac {for _ ,_acgbg :=range _aadb .Elements (){_acgbg =TraceToDirectObject (_acgbg );
if _fgfd ,_fdgab :=_acgbg .(*PdfObjectDictionary );_fdgab {_eacc =append (_eacc ,_fgfd );}else {_eacc =append (_eacc ,MakeDict ());};};};};_fbfd =_facag .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _fbfd ==nil {return nil ,_af .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");
};_dgcbe ,_abdc :=_fbfd .(*PdfObjectArray );if !_abdc {return nil ,_af .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _ffa ,_bcge :=range _dgcbe .Elements (){_acff ,_bbed :=_bcge .(*PdfObjectName );if !_bbed {return nil ,_af .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _afff PdfObject ;if _gaab !=nil {_afff =_gaab ;}else {if len (_eacc )> 0{if _ffa >=len (_eacc ){return nil ,_af .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_afff =_eacc [_ffa ];};};var _bfbb *PdfObjectDictionary ;if _aagc ,_fdag :=_afff .(*PdfObjectDictionary );_fdag {_bfbb =_aagc ;};_gf .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_acff ,_afff ,_bfbb );
if *_acff ==StreamEncodingFilterNameFlate {_bcdb ,_adbb :=_daed (_cbbf ,_bfbb );if _adbb !=nil {return nil ,_adbb ;};_cbbec .AddEncoder (_bcdb );}else if *_acff ==StreamEncodingFilterNameLZW {_bgef ,_fefdb :=_adge (_cbbf ,_bfbb );if _fefdb !=nil {return nil ,_fefdb ;
};_cbbec .AddEncoder (_bgef );}else if *_acff ==StreamEncodingFilterNameASCIIHex {_eadb :=NewASCIIHexEncoder ();_cbbec .AddEncoder (_eadb );}else if *_acff ==StreamEncodingFilterNameASCII85 {_bccb :=NewASCII85Encoder ();_cbbec .AddEncoder (_bccb );}else if *_acff ==StreamEncodingFilterNameDCT {_eecac ,_gfac :=_ecgf (_cbbf ,_cbbec );
if _gfac !=nil {return nil ,_gfac ;};_cbbec .AddEncoder (_eecac );_gf .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_gf .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_cbbec );
}else if *_acff ==StreamEncodingFilterNameCCITTFax {_agaa ,_egfc :=_fbaa (_cbbf ,_bfbb );if _egfc !=nil {return nil ,_egfc ;};_cbbec .AddEncoder (_agaa );}else {_gf .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_acff );
return nil ,_af .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _cbbec ,nil ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_cfdga *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cfdga .DecodeBytes (streamObj .Stream );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_agfc *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_aeeb :=MakeDict ();_aeeb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_agfc .GetFilterName ()));return _aeeb ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _gcab (obj1 ,obj2 ,0)};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// Remove removes an element specified by key.
func (_cccfb *PdfObjectDictionary )Remove (key PdfObjectName ){_ffbf :=-1;for _adfe ,_bgbeg :=range _cccfb ._gaccg {if _bgbeg ==key {_ffbf =_adfe ;break ;};};if _ffbf >=0{_cccfb ._gaccg =append (_cccfb ._gaccg [:_ffbf ],_cccfb ._gaccg [_ffbf +1:]...);delete (_cccfb ._cgdb ,key );
};};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_fbdb *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gf .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_ceb :=_gbg .NewReader (encoded );_ceaa ,_bff :=_daa .NewReader (_ceb );if _bff !=nil {_gf .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_bff );_gf .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_bff ;};defer _ceaa .Close ();var _fbbd _gbg .Buffer ;_fbbd .ReadFrom (_ceaa );return _fbbd .Bytes (),nil ;};func _bge (_dga XrefTable ){_gf .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_gf .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");
_efa :=0;for _ ,_eda :=range _dga .ObjectMap {_gf .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_efa +1,_eda .ObjectNumber ,_eda .Generation ,_eda .Offset );
_efa ++;};};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_bfeb :=TraceToDirectObject (obj ).(*PdfObjectNull );return _bfeb ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";
StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _gcfdd :=obj .(type ){case *PdfObjectFloat :_gf .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_gcfdd ),nil ;case *PdfObjectInteger :return int64 (*_gcfdd ),nil ;case *PdfObjectReference :_dfdc :=TraceToDirectObject (obj );return GetNumberAsInt64 (_dfdc );case *PdfIndirectObject :return GetNumberAsInt64 (_gcfdd .PdfObject );};return 0,ErrNotANumber ;
};func (_aabb *PdfCrypt )isEncrypted (_becg PdfObject )bool {_ ,_gcfd :=_aabb ._cae [_becg ];if _gcfd {_gf .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_gf .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// Len returns the number of elements in the streams.
func (_afbc *PdfObjectStreams )Len ()int {if _afbc ==nil {return 0;};return len (_afbc ._gdfde );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ddec *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_gb .Model ;Bounds ()_cc .Rectangle ;At (_edegg ,_cbde int )_gb .Color ;Set (_bffe ,_ecaa int ,_caac _gb .Color );};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_fabf :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _fabf ==nil {return NewRawEncoder (),nil ;};if _ ,_eecd :=_fabf .(*PdfObjectNull );
_eecd {return NewRawEncoder (),nil ;};_baacg ,_cffaa :=_fabf .(*PdfObjectName );if !_cffaa {_dbea ,_cdgdc :=_fabf .(*PdfObjectArray );if !_cdgdc {return nil ,_af .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _dbea .Len ()==0{return NewRawEncoder (),nil ;};if _dbea .Len ()!=1{_efdfcg ,_gbcgd :=_begd (streamObj );if _gbcgd !=nil {_gf .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_gbcgd );
return nil ,_gbcgd ;};_gf .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_efdfcg );return _efdfcg ,nil ;};_fabf =_dbea .Get (0);_baacg ,_cdgdc =_fabf .(*PdfObjectName );if !_cdgdc {return nil ,_af .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _fage ,_gfgc :=_bdfe .Load (_baacg .String ());_gfgc {return _fage .(StreamEncoder ),nil ;};switch *_baacg {case StreamEncodingFilterNameFlate :return _daed (streamObj ,nil );case StreamEncodingFilterNameLZW :return _adge (streamObj ,nil );case StreamEncodingFilterNameDCT :return _ecgf (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _bbfgc (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _fbaa (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _cbdc (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_gf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_af .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_baacg );};

// HeaderCommentBytes gets the header comment bytes.
func (_fff ParserMetadata )HeaderCommentBytes ()[4]byte {return _fff ._fccg };type limitedReadSeeker struct{_dcb _cb .ReadSeeker ;_adad int64 ;};

// UpdateParams updates the parameter values of the encoder.
func (_bgcdb *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_dbag ,_eag :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _eag ==nil {_bgcdb .ColorComponents =int (_dbag );
};_eddg ,_eag :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _eag ==nil {_bgcdb .BitsPerComponent =int (_eddg );};_gcca ,_eag :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _eag ==nil {_bgcdb .Width =int (_gcca );};_aee ,_eag :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _eag ==nil {_bgcdb .Height =int (_aee );};_cdgd ,_eag :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _eag ==nil {_bgcdb .Quality =int (_cdgd );};_cge ,_eddc :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));if _eddc {_bgcdb .Decode ,_eag =_cge .ToFloat64Array ();if _eag !=nil {_gf .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020de\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006eto\u0020\u0061r\u0072\u0061\u0079\u0073\u003a\u0020\u0025\u0076",_eag );
};};};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_dgfe *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _dgfe .isEncrypted (obj ){return nil ;};switch _bcbb :=obj .(type ){case *PdfIndirectObject :_dgfe ._cae [_bcbb ]=true ;_gf .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_bcbb .ObjectNumber ,_bcbb .GenerationNumber );
_aec :=_bcbb .ObjectNumber ;_cgba :=_bcbb .GenerationNumber ;_cgg :=_dgfe .Encrypt (_bcbb .PdfObject ,_aec ,_cgba );if _cgg !=nil {return _cgg ;};return nil ;case *PdfObjectStream :_dgfe ._cae [_bcbb ]=true ;_acbd :=_bcbb .PdfObjectDictionary ;if _baea ,_cabg :=_acbd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_cabg &&*_baea =="\u0058\u0052\u0065\u0066"{return nil ;};_dc :=_bcbb .ObjectNumber ;_eccc :=_bcbb .GenerationNumber ;_gf .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_dc ,_eccc );
_fee :=_fgf ;if _dgfe ._ffgd .V >=4{_fee =_dgfe ._bfe ;_gf .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_dgfe ._bfe );if _dcf ,_dcc :=_acbd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_dcc {if _eebb ,_cgbag :=GetName (_dcf .Get (0));_cgbag {if *_eebb =="\u0043\u0072\u0079p\u0074"{_fee ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dfe ,_ffd :=_acbd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_ffd {if _cfa ,_afbd :=_dfe .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_afbd {if _ ,_egab :=_dgfe ._fcag [string (*_cfa )];_egab {_gf .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_cfa );
_fee =string (*_cfa );};};};};};};_gf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fee );if _fee =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_cad :=_dgfe .Encrypt (_bcbb .PdfObjectDictionary ,_dc ,_eccc );
if _cad !=nil {return _cad ;};_bbbf ,_cad :=_dgfe .makeKey (_fee ,uint32 (_dc ),uint32 (_eccc ),_dgfe ._dbbe );if _cad !=nil {return _cad ;};_bcbb .Stream ,_cad =_dgfe .encryptBytes (_bcbb .Stream ,_fee ,_bbbf );if _cad !=nil {return _cad ;};_acbd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bcbb .Stream ))));
return nil ;case *PdfObjectString :_gf .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_eae :=_fgf ;if _dgfe ._ffgd .V >=4{_gf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dgfe ._eab );
if _dgfe ._eab =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_eae =_dgfe ._eab ;};_beee ,_acf :=_dgfe .makeKey (_eae ,uint32 (parentObjNum ),uint32 (parentGenNum ),_dgfe ._dbbe );if _acf !=nil {return _acf ;};_fab :=_bcbb .Str ();_ace :=make ([]byte ,len (_fab ));
for _efdc :=0;_efdc < len (_fab );_efdc ++{_ace [_efdc ]=_fab [_efdc ];};_gf .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_ace ,_ace );_ace ,_acf =_dgfe .encryptBytes (_ace ,_eae ,_beee );
if _acf !=nil {return _acf ;};_bcbb ._addg =string (_ace );return nil ;case *PdfObjectArray :for _ ,_afba :=range _bcbb .Elements (){_faca :=_dgfe .Encrypt (_afba ,parentObjNum ,parentGenNum );if _faca !=nil {return _faca ;};};return nil ;case *PdfObjectDictionary :_ead :=false ;
if _dee :=_bcbb .Get ("\u0054\u0079\u0070\u0065");_dee !=nil {_bfd ,_deea :=_dee .(*PdfObjectName );if _deea &&*_bfd =="\u0053\u0069\u0067"{_ead =true ;};};for _ ,_ded :=range _bcbb .Keys (){_bbbe :=_bcbb .Get (_ded );if _ead &&string (_ded )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;
};if string (_ded )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_ded )!="\u0050\u0072\u0065\u0076"&&string (_ded )!="\u004c\u0061\u0073\u0074"{_becgf :=_dgfe .Encrypt (_bbbe ,parentObjNum ,parentGenNum );if _becgf !=nil {return _becgf ;};};};return nil ;
};return nil ;};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_badc *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_badc ._fefbg .Lock ();defer _badc ._fefbg .Unlock ();for _cadfg ,_aeaf :=range objmap {_badc .setWithLock (PdfObjectName (_cadfg ),_aeaf ,false );};return _badc ;
};

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_gfgb ParserMetadata )HasOddLengthHexStrings ()bool {return _gfgb ._add };

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_cfcd *PdfParser )Decrypt (password []byte )(bool ,error ){if _cfcd ._bcgfc ==nil {return false ,_d .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_fbefc ,_ddcbd :=_cfcd ._bcgfc .authenticate (password );
if _ddcbd !=nil {return false ,_ddcbd ;};if !_fbefc {_fbefc ,_ddcbd =_cfcd ._bcgfc .authenticate ([]byte (""));};return _fbefc ,_ddcbd ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_gff *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _dbgd []float64 ;for _ ,_cggd :=range _gff .Elements (){_fgba ,_eebbf :=GetNumberAsFloat (TraceToDirectObject (_cggd ));if _eebbf !=nil {return nil ,_af .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_dbgd =append (_dbgd ,_fgba );};return _dbgd ,nil ;};func (_egaa *PdfParser )checkLinearizedInformation (_bbadb *PdfObjectDictionary )(bool ,error ){var _ddeba error ;_egaa ._gced ,_ddeba =GetNumberAsInt64 (_bbadb .Get ("\u004c"));if _ddeba !=nil {return false ,_ddeba ;
};_ddeba =_egaa .seekToEOFMarker (_egaa ._gced );switch _ddeba {case nil :return true ,nil ;case _cagf :return false ,nil ;default:return false ,_ddeba ;};};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_gfbb *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_gfbb ._fefbg .Lock ();defer _gfbb ._fefbg .Unlock ();_gbcfd ,_faac :=_gfbb ._cgdb [key ];if !_faac {return nil ;};return _gbcfd ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_fced :=PdfObjectString {_addg :s ,_ffff :true };return &_fced ;};func (_gca *PdfParser )parseBool ()(PdfObjectBool ,error ){_dbdcf ,_dfcf :=_gca ._fdc .Peek (4);if _dfcf !=nil {return PdfObjectBool (false ),_dfcf ;
};if (len (_dbdcf )>=4)&&(string (_dbdcf [:4])=="\u0074\u0072\u0075\u0065"){_gca ._fdc .Discard (4);return PdfObjectBool (true ),nil ;};_dbdcf ,_dfcf =_gca ._fdc .Peek (5);if _dfcf !=nil {return PdfObjectBool (false ),_dfcf ;};if (len (_dbdcf )>=5)&&(string (_dbdcf [:5])=="\u0066\u0061\u006cs\u0065"){_gca ._fdc .Discard (5);
return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_d .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_bccfb *PdfObjectString ,_fcaga bool ){_bccfb ,_fcaga =TraceToDirectObject (obj ).(*PdfObjectString );return _bccfb ,_fcaga ;};var _dffb =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_fcge []StreamEncoder };

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_gagg *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_gagg ._dcgec ){return _d .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_gagg ._dcgec [i ]=obj ;return nil ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_gbec *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gbec .DecodeBytes (streamObj .Stream );};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_aefcb []float64 ,_afda error ){for _ ,_fada :=range objects {_gadb ,_gdbcb :=GetNumberAsFloat (_fada );if _gdbcb !=nil {return nil ,_gdbcb ;};_aefcb =append (_aefcb ,_gadb );};return _aefcb ,nil ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_eadbc *PdfObjectName ,_ggab bool ){_eadbc ,_ggab =TraceToDirectObject (obj ).(*PdfObjectName );return _eadbc ,_ggab ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_bbade *JBIG2Image )ToGoImage ()(_cc .Image ,error ){const _ecgfg ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _bbade .Data ==nil {return nil ,_ag .Error (_ecgfg ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _bbade .Width ==0||_bbade .Height ==0{return nil ,_ag .Error (_ecgfg ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_fagb ,_gda :=_bb .NewImage (_bbade .Width ,_bbade .Height ,1,1,_bbade .Data ,nil ,nil );if _gda !=nil {return nil ,_gda ;};return _fagb ,nil ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_adfea *PdfObjectStreams ,_cgfg bool ){_adfea ,_cgfg =obj .(*PdfObjectStreams );return _adfea ,_cgfg ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _dcbc :=obj .(type ){case *PdfObjectFloat :return float64 (*_dcbc ),nil ;case *PdfObjectInteger :return float64 (*_dcbc ),nil ;case *PdfObjectReference :_gbef :=TraceToDirectObject (obj );return GetNumberAsFloat (_gbef );
case *PdfIndirectObject :return GetNumberAsFloat (_dcbc .PdfObject );};return 0,ErrNotANumber ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_cecd *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_afef :=n ;_bfga :=0;_bdcbc :=0;for _afef > 0{_ggdg ,_gdegd :=_cecd ._fdc .Read (p [_bfga :]);if _gdegd !=nil {_gf .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_ggdg ,_bdcbc ,_gdegd .Error ());
return _bfga ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_bdcbc ++;_bfga +=_ggdg ;_afef -=_ggdg ;};return _bfga ,nil ;};func (_dbg *PdfParser )lookupObjectViaOS (_bf int ,_dg int )(PdfObject ,error ){var _aa *_gbg .Reader ;
var _cgc objectStream ;var _gfe bool ;_cgc ,_gfe =_dbg ._feaf [_bf ];if !_gfe {_fc ,_ggf :=_dbg .LookupByNumber (_bf );if _ggf !=nil {_gf .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_bf );
return nil ,_ggf ;};_cee ,_bd :=_fc .(*PdfObjectStream );if !_bd {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _dbg ._bcgfc !=nil &&!_dbg ._bcgfc .isDecrypted (_cee ){return nil ,_d .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_ffg :=_cee .PdfObjectDictionary ;_gf .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_ffg .String ());_ebc ,_bd :=_ffg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_bd {_gf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _cf .ToLower (string (*_ebc ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_d .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_bd :=_ffg .Get ("\u004e").(*PdfObjectInteger );if !_bd {return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_be ,_bd :=_ffg .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_bd {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_gf .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ebc ,*N );_ab ,_ggf :=DecodeStream (_cee );if _ggf !=nil {return nil ,_ggf ;
};_gf .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ab );_gac :=_dbg .GetFileOffset ();defer func (){_dbg .SetFileOffset (_gac )}();_aa =_gbg .NewReader (_ab );_dbg ._fdc =_gc .NewReader (_aa );_gf .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_dbd :=map[int ]int64 {};for _cbb :=0;_cbb < int (*N );_cbb ++{_dbg .skipSpaces ();_ed ,_cd :=_dbg .parseNumber ();if _cd !=nil {return nil ,_cd ;};_ba ,_bg :=_ed .(*PdfObjectInteger );if !_bg {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_dbg .skipSpaces ();_ed ,_cd =_dbg .parseNumber ();if _cd !=nil {return nil ,_cd ;};_gd ,_bg :=_ed .(*PdfObjectInteger );if !_bg {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_gf .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_ba ,*_gd );_dbd [int (*_ba )]=int64 (*_be +*_gd );};_cgc =objectStream {N :int (*N ),_aeb :_ab ,_ce :_dbd };_dbg ._feaf [_bf ]=_cgc ;}else {_dbb :=_dbg .GetFileOffset ();
defer func (){_dbg .SetFileOffset (_dbb )}();_aa =_gbg .NewReader (_cgc ._aeb );_dbg ._fdc =_gc .NewReader (_aa );};_ffc :=_cgc ._ce [_dg ];_gf .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_dg ,_ffc );
_aa .Seek (_ffc ,_cb .SeekStart );_dbg ._fdc =_gc .NewReader (_aa );_ea ,_ :=_dbg ._fdc .Peek (100);_gf .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_ea ));_fde ,_cag :=_dbg .parseObject ();if _cag !=nil {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_cag );
return nil ,_cag ;};if _fde ==nil {return nil ,_d .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_egf :=PdfIndirectObject {};_egf .ObjectNumber =int64 (_dg );_egf .PdfObject =_fde ;_egf ._gcdb =_dbg ;
return &_egf ,nil ;};func _aaeb (_dffcb *PdfObjectDictionary )(_agdda *_bb .ImageBase ){var (_fedag *PdfObjectInteger ;_gdfaa bool ;);if _fedag ,_gdfaa =_dffcb .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_gdfaa {_agdda =&_bb .ImageBase {Width :int (*_fedag )};
}else {return nil ;};if _fedag ,_gdfaa =_dffcb .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_gdfaa {_agdda .Height =int (*_fedag );};if _fedag ,_gdfaa =_dffcb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_gdfaa {_agdda .BitsPerComponent =int (*_fedag );};if _fedag ,_gdfaa =_dffcb .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_gdfaa {_agdda .ColorComponents =int (*_fedag );};return _agdda ;
};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_dgg *_bb .ImageBase ;};func _ec (_eec PdfObject )(int64 ,int64 ,error ){if _acg ,_aab :=_eec .(*PdfIndirectObject );_aab {return _acg .ObjectNumber ,_acg .GenerationNumber ,nil ;};if _ffb ,_gbb :=_eec .(*PdfObjectStream );
_gbb {return _ffb .ObjectNumber ,_ffb .GenerationNumber ,nil ;};return 0,0,_d .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// String returns a string describing `d`.
func (_bece *PdfObjectDictionary )String ()string {var _dbda _cf .Builder ;_dbda .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_bcgde :=range _bece ._gaccg {_aedfc :=_bece ._cgdb [_bcgde ];_dbda .WriteString ("\u0022"+_bcgde .String ()+"\u0022\u003a\u0020");
_dbda .WriteString (_aedfc .String ());_dbda .WriteString ("\u002c\u0020");};_dbda .WriteString ("\u0029");return _dbda .String ();};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_aega *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_bebc :=_aega .GetFileOffset ();_ ,_dece :=_aega ._bcdda .Seek (offset ,_cb .SeekStart );if _dece !=nil {return nil ,_dece ;};_cbce :=make ([]byte ,len );_ ,_dece =_cb .ReadAtLeast (_aega ._bcdda ,_cbce ,int (len ));
if _dece !=nil {return nil ,_dece ;};_aega .SetFileOffset (_bebc );return _cbce ,nil ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_aga *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _aga .Predictor !=1{return nil ,_af .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _aga .EarlyChange ==1{return nil ,_af .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _egcc _gbg .Buffer ;_agd :=_ae .NewWriter (&_egcc ,_ae .MSB ,8);_agd .Write (data );_agd .Close ();return _egcc .Bytes (),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_egge *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// SetImage sets the image base for given flate encoder.
func (_adb *FlateEncoder )SetImage (img *_bb .ImageBase ){_adb ._dgg =img };

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// DecodeStream implements ASCII hex decoding.
func (_bebd *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bebd .DecodeBytes (streamObj .Stream );};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_ebfda *PdfObjectString )Str ()string {return _ebfda ._addg };func (_fgeba *PdfParser )parseString ()(*PdfObjectString ,error ){_fgeba ._fdc .ReadByte ();var _dcad _gbg .Buffer ;_cddeb :=1;for {_acge ,_gbfg :=_fgeba ._fdc .Peek (1);if _gbfg !=nil {return MakeString (_dcad .String ()),_gbfg ;
};if _acge [0]=='\\'{_fgeba ._fdc .ReadByte ();_bgca ,_edfa :=_fgeba ._fdc .ReadByte ();if _edfa !=nil {return MakeString (_dcad .String ()),_edfa ;};if IsOctalDigit (_bgca ){_bdgb ,_ecec :=_fgeba ._fdc .Peek (2);if _ecec !=nil {return MakeString (_dcad .String ()),_ecec ;
};var _bcff []byte ;_bcff =append (_bcff ,_bgca );for _ ,_cgdce :=range _bdgb {if IsOctalDigit (_cgdce ){_bcff =append (_bcff ,_cgdce );}else {break ;};};_fgeba ._fdc .Discard (len (_bcff )-1);_gf .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_bcff );
_ceeeb ,_ecec :=_db .ParseUint (string (_bcff ),8,32);if _ecec !=nil {return MakeString (_dcad .String ()),_ecec ;};_dcad .WriteByte (byte (_ceeeb ));continue ;};switch _bgca {case 'n':_dcad .WriteRune ('\n');case 'r':_dcad .WriteRune ('\r');case 't':_dcad .WriteRune ('\t');
case 'b':_dcad .WriteRune ('\b');case 'f':_dcad .WriteRune ('\f');case '(':_dcad .WriteRune ('(');case ')':_dcad .WriteRune (')');case '\\':_dcad .WriteRune ('\\');};continue ;}else if _acge [0]=='('{_cddeb ++;}else if _acge [0]==')'{_cddeb --;if _cddeb ==0{_fgeba ._fdc .ReadByte ();
break ;};};_eecaa ,_ :=_fgeba ._fdc .ReadByte ();_dcad .WriteByte (_eecaa );};return MakeString (_dcad .String ()),nil ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_fgde *PdfObjectStream ,_adgf bool ){obj =ResolveReference (obj );_fgde ,_adgf =obj .(*PdfObjectStream );return _fgde ,_adgf ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_dcgec :objects }};

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _cb .ReadSeeker )(_eeg *PdfParser ,_gcfbc error ){_eeg =&PdfParser {_bcdda :rs ,ObjCache :make (objectCache ),_fbge :map[int64 ]bool {},_fdgb :true ,_fefb :make (map[*PdfParser ]*PdfParser )};if _gcfbc =_eeg .parseDetailedHeader ();
_gcfbc !=nil {return nil ,_gcfbc ;};if _eeg ._ffe ,_gcfbc =_eeg .loadXrefs ();_gcfbc !=nil {_gf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_gcfbc );
return nil ,_gcfbc ;};_gf .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_eeg ._ffe );if len (_eeg ._gfdb .ObjectMap )==0{return nil ,_af .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _eeg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_agdb *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_fcg :=MakeDict ();_fcg .Set ("\u004b",MakeInteger (int64 (_agdb .K )));_fcg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_agdb .Columns )));if _agdb .BlackIs1 {_fcg .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_agdb .BlackIs1 ));
};if _agdb .EncodedByteAlign {_fcg .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_agdb .EncodedByteAlign ));};if _agdb .EndOfLine &&_agdb .K >=0{_fcg .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_agdb .EndOfLine ));
};if _agdb .Rows !=0&&!_agdb .EndOfBlock {_fcg .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_agdb .Rows )));};if !_agdb .EndOfBlock {_fcg .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_agdb .EndOfBlock ));};if _agdb .DamagedRowsBeforeError !=0{_fcg .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_agdb .DamagedRowsBeforeError )));
};return _fcg ;};

// Append appends PdfObject(s) to the streams.
func (_ecca *PdfObjectStreams )Append (objects ...PdfObject ){if _ecca ==nil {_gf .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_ecca ._gdfde =append (_ecca ._gdfde ,objects ...);};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_de *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_gccg ,_ebb :=obj .(*PdfObjectReference );if !_ebb {return obj ,nil ;};_cbbe :=_de .GetFileOffset ();defer func (){_de .SetFileOffset (_cbbe )}();_eea ,_egd :=_de .LookupByReference (*_gccg );
if _egd !=nil {return nil ,_egd ;};_dff ,_gace :=_eea .(*PdfIndirectObject );if !_gace {return _eea ,nil ;};_eea =_dff .PdfObject ;_ ,_ebb =_eea .(*PdfObjectReference );if _ebb {return _dff ,_d .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _eea ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_acbdc *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_ggea ,_dgc :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _dgc ==nil {_acbdc .Predictor =int (_ggea );};_bag ,_dgc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _dgc ==nil {_acbdc .BitsPerComponent =int (_bag );};_eefa ,_dgc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _dgc ==nil {_acbdc .Columns =int (_eefa );};_fffg ,_dgc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _dgc ==nil {_acbdc .Colors =int (_fffg );};};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_geedb *PdfObjectStreams )Elements ()[]PdfObject {if _geedb ==nil {return nil ;};return _geedb ._gdfde ;};

// GetFilterName returns the name of the encoding filter.
func (_bcbf *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_abec *JBIG2Encoder )DecodeImages (encoded []byte )([]_cc .Image ,error ){const _aaae ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_ggcf ,_ddce :=_fb .Decode (encoded ,_fb .Parameters {},_abec .Globals .ToDocumentGlobals ());
if _ddce !=nil {return nil ,_ag .Wrap (_ddce ,_aaae ,"");};_cgea ,_ddce :=_ggcf .PageNumber ();if _ddce !=nil {return nil ,_ag .Wrap (_ddce ,_aaae ,"");};_ebee :=[]_cc .Image {};var _abbf _cc .Image ;for _fgaa :=1;_fgaa <=_cgea ;_fgaa ++{_abbf ,_ddce =_ggcf .DecodePageImage (_fgaa );
if _ddce !=nil {return nil ,_ag .Wrapf (_ddce ,_aaae ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fgaa );};_ebee =append (_ebee ,_abbf );};return _ebee ,nil ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_ddega *PdfObjectString )Bytes ()[]byte {return []byte (_ddega ._addg )};func (_ggg *PdfCrypt )checkAccessRights (_dfg []byte )(bool ,_fg .Permissions ,error ){_egce :=_ggg .securityHandler ();_cbd ,_ecac ,_adg :=_egce .Authenticate (&_ggg ._acc ,_dfg );
if _adg !=nil {return false ,0,_adg ;}else if _ecac ==0||len (_cbd )==0{return false ,0,nil ;};return true ,_ecac ,nil ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_fcgd *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _befd ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _fcgd .ColorComponents !=1||_fcgd .BitsPerComponent !=1{return nil ,_ag .Errorf (_befd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_fgbb *_ca .Bitmap ;_ffgb error ;);_bfge :=(_fcgd .Width *_fcgd .Height )==len (data );if _bfge {_fgbb ,_ffgb =_ca .NewWithUnpaddedData (_fcgd .Width ,_fcgd .Height ,data );}else {_fgbb ,_ffgb =_ca .NewWithData (_fcgd .Width ,_fcgd .Height ,data );
};if _ffgb !=nil {return nil ,_ffgb ;};_baae :=_fcgd .DefaultPageSettings ;if _ffgb =_baae .Validate ();_ffgb !=nil {return nil ,_ag .Wrap (_ffgb ,_befd ,"");};if _fcgd ._bacd ==nil {_fcgd ._bacd =_ccb .InitEncodeDocument (_baae .FileMode );};switch _baae .Compression {case JB2Generic :if _ffgb =_fcgd ._bacd .AddGenericPage (_fgbb ,_baae .DuplicatedLinesRemoval );
_ffgb !=nil {return nil ,_ag .Wrap (_ffgb ,_befd ,"");};case JB2SymbolCorrelation :return nil ,_ag .Error (_befd ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_ag .Error (_befd ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_ag .Error (_befd ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _fcgd .Encode ();};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_ffgd encryptDict ;_acc _fg .StdEncryptDict ;_bc string ;_dbbe []byte ;_dbe map[PdfObject ]bool ;_cae map[PdfObject ]bool ;_cbcb bool ;_fcag cryptFilters ;_bfe string ;_eab string ;_bcc *PdfParser ;_dbdb map[int ]struct{};};func (_edbag *PdfObjectFloat )String ()string {return _af .Sprintf ("\u0025\u0066",*_edbag )};


// SetFileOffset sets the file to an offset position and resets buffer.
func (_aaaf *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_aaaf ._bcdda .Seek (offset ,_cb .SeekStart );_aaaf ._fdc =_gc .NewReader (_aaaf ._bcdda );};

// GetFilterName returns the name of the encoding filter.
func (_dcee *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };func (_age *PdfCrypt )saveCryptFilters (_eeac *PdfObjectDictionary )error {if _age ._ffgd .V < 4{return _d .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_dfa :=MakeDict ();_eeac .Set ("\u0043\u0046",_dfa );for _afc ,_geg :=range _age ._fcag {if _afc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_cdfe :=_ege (_geg ,"");_dfa .Set (PdfObjectName (_afc ),_cdfe );};_eeac .Set ("\u0053\u0074\u0072\u0046",MakeName (_age ._eab ));
_eeac .Set ("\u0053\u0074\u006d\u0046",MakeName (_age ._bfe ));return nil ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_egag *JBIG2Encoder )Encode ()(_cega []byte ,_gegd error ){const _cdeee ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _egag ._bacd ==nil {return nil ,_ag .Errorf (_cdeee ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_egag ._bacd .FullHeaders =_egag .DefaultPageSettings .FileMode ;_cega ,_gegd =_egag ._bacd .Encode ();if _gegd !=nil {return nil ,_ag .Wrap (_gegd ,_cdeee ,"");};return _cega ,nil ;};func (_gdef *PdfCrypt )authenticate (_afce []byte )(bool ,error ){_gdef ._cbcb =false ;
_gefa :=_gdef .securityHandler ();_deg ,_gbf ,_fda :=_gefa .Authenticate (&_gdef ._acc ,_afce );if _fda !=nil {return false ,_fda ;}else if _gbf ==0||len (_deg )==0{return false ,nil ;};_gdef ._cbcb =true ;_gdef ._dbbe =_deg ;return true ,nil ;};func (_dd *PdfParser )lookupByNumber (_dba int ,_abf bool )(PdfObject ,bool ,error ){_fad ,_gcd :=_dd .ObjCache [_dba ];
if _gcd {_gf .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_dba );return _fad ,false ,nil ;};if _dd ._fcbe ==nil {_dd ._fcbe =map[int ]bool {};
};if _dd ._fcbe [_dba ]{_gf .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_dba );
return nil ,false ,_d .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_dd ._fcbe [_dba ]=true ;defer delete (_dd ._fcbe ,_dba );
_ad ,_gcd :=_dd ._gfdb .ObjectMap [_dba ];if !_gcd {_gf .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _ggd PdfObjectNull ;return &_ggd ,false ,nil ;};_gf .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_dba );if _ad .XType ==XrefTypeTableEntry {_gf .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_ad .ObjectNumber );
_gf .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_ad .Generation );_gf .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_ad .Offset );_dd ._bcdda .Seek (_ad .Offset ,_cb .SeekStart );
_dd ._fdc =_gc .NewReader (_dd ._bcdda );_cfe ,_eef :=_dd .ParseIndirectObject ();if _eef !=nil {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_eef );
if _abf {_gf .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_abb ,_gfgf :=_dd .repairRebuildXrefsTopDown ();
if _gfgf !=nil {_gf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_gfgf );return nil ,false ,_gfgf ;};_dd ._gfdb =*_abb ;return _dd .lookupByNumber (_dba ,false );
};return nil ,false ,_eef ;};if _abf {_cac ,_ ,_ :=_ec (_cfe );if int (_cac )!=_dba {_gf .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_aea :=_dd .rebuildXrefTable ();
if _aea !=nil {return nil ,false ,_aea ;};_dd .ObjCache =objectCache {};return _dd .lookupByNumberWrapper (_dba ,false );};};_gf .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_dd .ObjCache [_dba ]=_cfe ;
return _cfe ,false ,nil ;}else if _ad .XType ==XrefTypeObjectStream {_gf .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_gf .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_gf .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_ad .OsObjNumber ,_ad .OsObjIndex );
if _ad .OsObjNumber ==_dba {_gf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_d .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_aef :=_dd ._gfdb .ObjectMap [_ad .OsObjNumber ];_aef {_ecf ,_bgc :=_dd .lookupObjectViaOS (_ad .OsObjNumber ,_dba );if _bgc !=nil {_gf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_bgc );
return nil ,true ,_bgc ;};_gf .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_dd .ObjCache [_dba ]=_ecf ;if _dd ._bcgfc !=nil {_dd ._bcgfc ._dbe [_ecf ]=true ;};return _ecf ,true ,nil ;};_gf .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_d .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_d .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_adec :=PdfObjectName (s );return &_adec };func (_daga *PdfParser )parseHexString ()(*PdfObjectString ,error ){_daga ._fdc .ReadByte ();var _bbgc _gbg .Buffer ;for {_cbaeb ,_bcfag :=_daga ._fdc .Peek (1);if _bcfag !=nil {return MakeString (""),_bcfag ;
};if _cbaeb [0]=='>'{_daga ._fdc .ReadByte ();break ;};_gfefd ,_ :=_daga ._fdc .ReadByte ();if _daga ._fdgb {if _gbg .IndexByte (_eafg ,_gfefd )==-1{_daga ._ebaa ._eecf =true ;};};if !IsWhiteSpace (_gfefd ){_bbgc .WriteByte (_gfefd );};};if _bbgc .Len ()%2==1{_daga ._ebaa ._add =true ;
_bbgc .WriteRune ('0');};_bcddg ,_ :=_cg .DecodeString (_bbgc .String ());return MakeHexString (string (_bcddg )),nil ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_eg []XrefObject ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_edfe *MultiEncoder )GetFilterArray ()*PdfObjectArray {_cfga :=make ([]PdfObject ,len (_edfe ._fcge ));for _debg ,_edef :=range _edfe ._fcge {_cfga [_debg ]=MakeName (_edef .GetFilterName ());};return MakeArray (_cfga ...);};func _ecgf (_bggf *PdfObjectStream ,_gbe *MultiEncoder )(*DCTEncoder ,error ){_babg :=NewDCTEncoder ();
_eddga :=_bggf .PdfObjectDictionary ;if _eddga ==nil {return _babg ,nil ;};_debd :=_bggf .Stream ;if _gbe !=nil {_eggb ,_cdfd :=_gbe .DecodeBytes (_debd );if _cdfd !=nil {return nil ,_cdfd ;};_debd =_eggb ;};_fdde :=_gbg .NewReader (_debd );_dgfbe ,_aeba :=_c .DecodeConfig (_fdde );
if _aeba !=nil {_gf .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_aeba );return nil ,_aeba ;};switch _dgfbe .ColorModel {case _gb .RGBAModel :_babg .BitsPerComponent =8;
_babg .ColorComponents =3;_babg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _gb .RGBA64Model :_babg .BitsPerComponent =16;_babg .ColorComponents =3;_babg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _gb .GrayModel :_babg .BitsPerComponent =8;
_babg .ColorComponents =1;_babg .Decode =[]float64 {0.0,1.0};case _gb .Gray16Model :_babg .BitsPerComponent =16;_babg .ColorComponents =1;_babg .Decode =[]float64 {0.0,1.0};case _gb .CMYKModel :_babg .BitsPerComponent =8;_babg .ColorComponents =4;_babg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0};
case _gb .YCbCrModel :_babg .BitsPerComponent =8;_babg .ColorComponents =3;_babg .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};default:return nil ,_d .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_babg .Width =_dgfbe .Width ;_babg .Height =_dgfbe .Height ;_gf .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_babg );_babg .Quality =DefaultJPEGQuality ;_egda ,_gece :=GetArray (_eddga .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
if _gece {_ccbc ,_gbcbc :=_egda .ToFloat64Array ();if _gbcbc !=nil {return _babg ,_gbcbc ;};_babg .Decode =_ccbc ;};return _babg ,nil ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};func _egcfg (_fceg PdfObject ,_adbe int )PdfObject {if _adbe > _dacf {_gf .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_dacf );
return MakeNull ();};switch _gcabb :=_fceg .(type ){case *PdfIndirectObject :_fceg =_egcfg ((*_gcabb ).PdfObject ,_adbe +1);case *PdfObjectArray :for _eeeb ,_cfggc :=range (*_gcabb )._dcgec {(*_gcabb )._dcgec [_eeeb ]=_egcfg (_cfggc ,_adbe +1);};case *PdfObjectDictionary :for _acffg ,_acef :=range (*_gcabb )._cgdb {(*_gcabb )._cgdb [_acffg ]=_egcfg (_acef ,_adbe +1);
};_ff .Slice ((*_gcabb )._gaccg ,func (_egee ,_gcgef int )bool {return (*_gcabb )._gaccg [_egee ]< (*_gcabb )._gaccg [_gcgef ]});};return _fceg ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_bbea *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _bbea .Predictor !=1&&_bbea .Predictor !=11{_gf .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _bbea .Predictor ==11{_bdbb :=_bbea .Columns ;_acac :=len (data )/_bdbb ;if len (data )%_bdbb !=0{_gf .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_dgad :=_gbg .NewBuffer (nil );_eedg :=make ([]byte ,_bdbb );for _cga :=0;_cga < _acac ;_cga ++{_ecgd :=data [_bdbb *_cga :_bdbb *(_cga +1)];
_eedg [0]=_ecgd [0];for _dde :=1;_dde < _bdbb ;_dde ++{_eedg [_dde ]=byte (int (_ecgd [_dde ]-_ecgd [_dde -1])%256);};_dgad .WriteByte (1);_dgad .Write (_eedg );};data =_dgad .Bytes ();};var _fcba _gbg .Buffer ;_adgd :=_daa .NewWriter (&_fcba );_adgd .Write (data );
_adgd .Close ();return _fcba .Bytes (),nil ;};func _gcab (_dcfd ,_aegac PdfObject ,_bfc int )bool {if _bfc > _dacf {_gf .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_dacf );
return false ;};if _dcfd ==nil &&_aegac ==nil {return true ;}else if _dcfd ==nil ||_aegac ==nil {return false ;};if _da .TypeOf (_dcfd )!=_da .TypeOf (_aegac ){return false ;};switch _bfedf :=_dcfd .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_bfedf ==*(_aegac .(*PdfObjectName ));case *PdfObjectString :return *_bfedf ==*(_aegac .(*PdfObjectString ));case *PdfObjectInteger :return *_bfedf ==*(_aegac .(*PdfObjectInteger ));case *PdfObjectBool :return *_bfedf ==*(_aegac .(*PdfObjectBool ));
case *PdfObjectFloat :return *_bfedf ==*(_aegac .(*PdfObjectFloat ));case *PdfIndirectObject :return _gcab (TraceToDirectObject (_dcfd ),TraceToDirectObject (_aegac ),_bfc +1);case *PdfObjectArray :_afdbc :=_aegac .(*PdfObjectArray );if len ((*_bfedf )._dcgec )!=len ((*_afdbc )._dcgec ){return false ;
};for _gegb ,_cdbf :=range (*_bfedf )._dcgec {if !_gcab (_cdbf ,(*_afdbc )._dcgec [_gegb ],_bfc +1){return false ;};};return true ;case *PdfObjectDictionary :_cfacd :=_aegac .(*PdfObjectDictionary );_acdfg ,_afbda :=(*_bfedf )._cgdb ,(*_cfacd )._cgdb ;
if len (_acdfg )!=len (_afbda ){return false ;};for _bgea ,_abgcd :=range _acdfg {_ddcc ,_fgfee :=_afbda [_bgea ];if !_fgfee ||!_gcab (_abgcd ,_ddcc ,_bfc +1){return false ;};};return true ;case *PdfObjectStream :_fbff :=_aegac .(*PdfObjectStream );return _gcab ((*_bfedf ).PdfObjectDictionary ,(*_fbff ).PdfObjectDictionary ,_bfc +1);
default:_gf .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_dcfd );
};return false ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_geged *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _gfae _gbg .Buffer ;for _ccf :=0;_ccf < len (data );_ccf +=4{_gbba :=data [_ccf ];_ecbb :=1;_ceed :=byte (0);if _ccf +1< len (data ){_ceed =data [_ccf +1];_ecbb ++;};_fcaa :=byte (0);
if _ccf +2< len (data ){_fcaa =data [_ccf +2];_ecbb ++;};_gaf :=byte (0);if _ccf +3< len (data ){_gaf =data [_ccf +3];_ecbb ++;};_ebec :=(uint32 (_gbba )<<24)|(uint32 (_ceed )<<16)|(uint32 (_fcaa )<<8)|uint32 (_gaf );if _ebec ==0{_gfae .WriteByte ('z');
}else {_dabg :=_geged .base256Tobase85 (_ebec );for _ ,_ebgf :=range _dabg [:_ecbb +1]{_gfae .WriteByte (_ebgf +'!');};};};_gfae .WriteString ("\u007e\u003e");return _gfae .Bytes (),nil ;};func (_gada *PdfParser )repairSeekXrefMarker ()error {_fade ,_caag :=_gada ._bcdda .Seek (0,_cb .SeekEnd );
if _caag !=nil {return _caag ;};_edae :=_ga .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _gfda int64 ;var _gbad int64 =1000;for _gfda < _fade {if _fade <=(_gbad +_gfda ){_gbad =_fade -_gfda ;};_ ,_egcec :=_gada ._bcdda .Seek (-_gfda -_gbad ,_cb .SeekEnd );
if _egcec !=nil {return _egcec ;};_ccba :=make ([]byte ,_gbad );_gada ._bcdda .Read (_ccba );_gf .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_ccba ));
_dfcae :=_edae .FindAllStringIndex (string (_ccba ),-1);if _dfcae !=nil {_cedd :=_dfcae [len (_dfcae )-1];_gf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_dfcae );_gada ._bcdda .Seek (-_gfda -_gbad +int64 (_cedd [0]),_cb .SeekEnd );
_gada ._fdc =_gc .NewReader (_gada ._bcdda );for {_cgdd ,_bcba :=_gada ._fdc .Peek (1);if _bcba !=nil {return _bcba ;};_gf .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_cgdd [0],_cgdd [0]);if !IsWhiteSpace (_cgdd [0]){break ;};_gada ._fdc .Discard (1);
};return nil ;};_gf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_gfda +=_gbad ;};_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _d .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_fefg *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_gbgfe *PdfParser )GetFileOffset ()int64 {_cged ,_ :=_gbgfe ._bcdda .Seek (0,_cb .SeekCurrent );_cged -=int64 (_gbgfe ._fdc .Buffered ());return _cged ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;var _gfcb =_ga .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_ebff *PdfParser )IsAuthenticated ()bool {return _ebff ._bcgfc ._cbcb };const (DefaultJPEGQuality =75;);func _cbgdc (_bdbe _cb .ReadSeeker ,_egfde int64 )(*offsetReader ,error ){_dge :=&offsetReader {_fgge :_bdbe ,_fbdd :_egfde };_ ,_fgac :=_dge .Seek (0,_cb .SeekStart );
return _dge ,_fgac ;};func _eagb (_fdcd PdfObject )(*float64 ,error ){switch _ecfg :=_fdcd .(type ){case *PdfObjectFloat :_fcad :=float64 (*_ecfg );return &_fcad ,nil ;case *PdfObjectInteger :_dbca :=float64 (*_ecfg );return &_dbca ,nil ;case *PdfObjectNull :return nil ,nil ;
};return nil ,ErrNotANumber ;};func _ege (_eca _ee .Filter ,_caa _fg .AuthEvent )*PdfObjectDictionary {if _caa ==""{_caa =_fg .EventDocOpen ;};_gaa :=MakeDict ();_gaa .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));
_gaa .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_caa )));_gaa .Set ("\u0043\u0046\u004d",MakeName (_eca .Name ()));_gaa .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_eca .KeyLength ())));return _gaa ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_gdfd *FlateEncoder )SetPredictor (columns int ){_gdfd .Predictor =11;_gdfd .Columns =columns };func _fbaa (_bceg *PdfObjectStream ,_bggg *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_dbbd :=NewCCITTFaxEncoder ();_ceec :=_bceg .PdfObjectDictionary ;
if _ceec ==nil {return _dbbd ,nil ;};if _bggg ==nil {_ccgg :=TraceToDirectObject (_ceec .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _ccgg !=nil {switch _degb :=_ccgg .(type ){case *PdfObjectDictionary :_bggg =_degb ;case *PdfObjectArray :if _degb .Len ()==1{if _eebe ,_afeg :=GetDict (_degb .Get (0));
_afeg {_bggg =_eebe ;};};default:_gf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_ccgg );return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _bggg ==nil {_gf .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_ccgg );return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _afbg ,_fefc :=GetNumberAsInt64 (_bggg .Get ("\u004b"));_fefc ==nil {_dbbd .K =int (_afbg );};if _baag ,_afag :=GetNumberAsInt64 (_bggg .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_afag ==nil {_dbbd .Columns =int (_baag );}else {_dbbd .Columns =1728;
};if _cfdc ,_fefa :=GetNumberAsInt64 (_bggg .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_fefa ==nil {_dbbd .BlackIs1 =_cfdc > 0;}else {if _gbdc ,_aeed :=GetBoolVal (_bggg .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_aeed {_dbbd .BlackIs1 =_gbdc ;
}else {if _cdbg ,_fadg :=GetArray (_bggg .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_fadg {_aebe ,_bbac :=_cdbg .ToIntegerArray ();if _bbac ==nil {_dbbd .BlackIs1 =_aebe [0]==1&&_aebe [1]==0;};};};};if _bfg ,_dbdg :=GetNumberAsInt64 (_bggg .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_dbdg ==nil {_dbbd .EncodedByteAlign =_bfg > 0;}else {if _bbd ,_abba :=GetBoolVal (_bggg .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_abba {_dbbd .EncodedByteAlign =_bbd ;};};if _beef ,_fefd :=GetNumberAsInt64 (_bggg .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_fefd ==nil {_dbbd .EndOfLine =_beef > 0;}else {if _dacb ,_bbdg :=GetBoolVal (_bggg .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bbdg {_dbbd .EndOfLine =_dacb ;};};if _befc ,_dfgg :=GetNumberAsInt64 (_bggg .Get ("\u0052\u006f\u0077\u0073"));
_dfgg ==nil {_dbbd .Rows =int (_befc );};_dbbd .EndOfBlock =true ;if _efdg ,_faea :=GetNumberAsInt64 (_bggg .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_faea ==nil {_dbbd .EndOfBlock =_efdg > 0;}else {if _fdeb ,_degc :=GetBoolVal (_bggg .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_degc {_dbbd .EndOfBlock =_fdeb ;};};if _bgcdd ,_ccegb :=GetNumberAsInt64 (_bggg .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_ccegb !=nil {_dbbd .DamagedRowsBeforeError =int (_bgcdd );
};_gf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bggg .String ());return _dbbd ,nil ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// String returns the state of the bool as "true" or "false".
func (_bagb *PdfObjectBool )String ()string {if *_bagb {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_befg *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_befg .GetFilterName ());
return data ,ErrNoJPXDecode ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_bded *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_agb :=PdfIndirectObject {};_agb ._gcdb =_bded ;_gf .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_gegc ,_ccbd :=_bded ._fdc .Peek (20);
if _ccbd !=nil {if _ccbd !=_cb .EOF {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_agb ,_ccbd ;
};};_gf .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_gegc ));_agbf :=_cdegb .FindStringSubmatchIndex (string (_gegc ));if len (_agbf )< 6{if _ccbd ==_cb .EOF {return nil ,_ccbd ;
};_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gegc ));
return &_agb ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_bded ._fdc .Discard (_agbf [0]);_gf .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_agbf );_ggcfc :=_agbf [1]-_agbf [0];_cccfe :=make ([]byte ,_ggcfc );_ ,_ccbd =_bded .ReadAtLeast (_cccfe ,_ggcfc );if _ccbd !=nil {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_ccbd );
return nil ,_ccbd ;};_gf .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_cccfe );_bfea :=_cdegb .FindStringSubmatch (string (_cccfe ));if len (_bfea )< 3{_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_cccfe ));
return &_agb ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_dddgc ,_ :=_db .Atoi (_bfea [1]);_cgbd ,_ :=_db .Atoi (_bfea [2]);_agb .ObjectNumber =int64 (_dddgc );_agb .GenerationNumber =int64 (_cgbd );for {_gccd ,_ggbf :=_bded ._fdc .Peek (2);if _ggbf !=nil {return &_agb ,_ggbf ;};_gf .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_gccd ),string (_gccd ));
if IsWhiteSpace (_gccd [0]){_bded .skipSpaces ();}else if _gccd [0]=='%'{_bded .skipComments ();}else if (_gccd [0]=='<')&&(_gccd [1]=='<'){_gf .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_agb .PdfObject ,_ggbf =_bded .ParseDict ();
_gf .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_ggbf );if _ggbf !=nil {return &_agb ,_ggbf ;};_gf .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_gccd [0]=='/')||(_gccd [0]=='(')||(_gccd [0]=='[')||(_gccd [0]=='<'){_agb .PdfObject ,_ggbf =_bded .parseObject ();if _ggbf !=nil {return &_agb ,_ggbf ;};_gf .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _gccd [0]==']'{_gf .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_bded ._fdc .Discard (1);}else {if _gccd [0]=='e'{_fcfe ,_effg :=_bded .readTextLine ();if _effg !=nil {return nil ,_effg ;};if len (_fcfe )>=6&&_fcfe [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _gccd [0]=='s'{_gccd ,_ =_bded ._fdc .Peek (10);
if string (_gccd [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_eggf :=6;if len (_gccd )> 6{if IsWhiteSpace (_gccd [_eggf ])&&_gccd [_eggf ]!='\r'&&_gccd [_eggf ]!='\n'{_gf .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_bded ._ebaa ._fbg =true ;_eggf ++;};if _gccd [_eggf ]=='\r'{_eggf ++;if _gccd [_eggf ]=='\n'{_eggf ++;};}else if _gccd [_eggf ]=='\n'{_eggf ++;}else {_bded ._ebaa ._fbg =true ;};};_bded ._fdc .Discard (_eggf );_dbcg ,_bbfgd :=_agb .PdfObject .(*PdfObjectDictionary );
if !_bbfgd {return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_gf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_dbcg );
_dcabc ,_fgacf :=_bded .traceStreamLength (_dbcg .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _fgacf !=nil {_gf .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_fgacf );
return nil ,_fgacf ;};_gf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_dcabc );_ffbed ,_ggbc :=_dcabc .(*PdfObjectInteger );if !_ggbc {return nil ,_d .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_egcb :=*_ffbed ;if _egcb < 0{return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_bbccg :=_bded .GetFileOffset ();
_gdefff :=_bded .xrefNextObjectOffset (_bbccg );if _bbccg +int64 (_egcb )> _gdefff &&_gdefff > _bbccg {_gf .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_bbccg +int64 (_egcb ));_gf .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_gdefff );
_cgedd :=_gdefff -_bbccg -17;if _cgedd < 0{return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_gf .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_cgedd );_egcb =PdfObjectInteger (_cgedd );
_dbcg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_cgedd ));};if int64 (_egcb )> _bded ._fbbge {_gf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_bcgc :=make ([]byte ,_egcb );
_ ,_fgacf =_bded .ReadAtLeast (_bcgc ,int (_egcb ));if _fgacf !=nil {_gf .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_bcgc ),_bcgc );_gf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fgacf );
return nil ,_fgacf ;};_agdgb :=PdfObjectStream {};_agdgb .Stream =_bcgc ;_agdgb .PdfObjectDictionary =_agb .PdfObject .(*PdfObjectDictionary );_agdgb .ObjectNumber =_agb .ObjectNumber ;_agdgb .GenerationNumber =_agb .GenerationNumber ;_agdgb .PdfObjectReference ._gcdb =_bded ;
_bded .skipSpaces ();_bded ._fdc .Discard (9);_bded .skipSpaces ();return &_agdgb ,nil ;};};_agb .PdfObject ,_ggbf =_bded .parseObject ();if _agb .PdfObject ==nil {_gf .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_agb .PdfObject =MakeNull ();};return &_agb ,_ggbf ;};};if _agb .PdfObject ==nil {_gf .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_agb .PdfObject =MakeNull ();};_gf .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_agb ,nil ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_gged :=&FlateEncoder {};_gged .Predictor =1;_gged .BitsPerComponent =8;_gged .Colors =1;_gged .Columns =1;return _gged ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_bbae :=MakeArray ();for _ ,_aebg :=range vals {_bbae .Append (MakeInteger (_aebg ));};return _bbae ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_dfdg *PdfParser )GetObjectNums ()[]int {var _ccfg []int ;for _ ,_aaffg :=range _dfdg ._gfdb .ObjectMap {_ccfg =append (_ccfg ,_aaffg .ObjectNumber );};_ff .Ints (_ccfg );return _ccfg ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_efdfcf *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_deeg :=MakeDict ();_deeg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_efdfcf .GetFilterName ()));return _deeg ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_accfb *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fdfg :=_gbg .NewReader (encoded );var _dadb []byte ;for {_fdef ,_bcda :=_fdfg .ReadByte ();if _bcda !=nil {return nil ,_bcda ;};if _fdef =='>'{break ;};if IsWhiteSpace (_fdef ){continue ;
};if (_fdef >='a'&&_fdef <='f')||(_fdef >='A'&&_fdef <='F')||(_fdef >='0'&&_fdef <='9'){_dadb =append (_dadb ,_fdef );}else {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_fdef );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_fdef );};};if len (_dadb )%2==1{_dadb =append (_dadb ,'0');
};_gf .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_dadb );_ged :=make ([]byte ,_cg .DecodedLen (len (_dadb )));_ ,_cdff :=_cg .Decode (_ged ,_dadb );if _cdff !=nil {return nil ,_cdff ;};return _ged ,nil ;};func (_daee *PdfParser )parseName ()(PdfObjectName ,error ){var _cgbb _gbg .Buffer ;
_eefba :=false ;for {_fagd ,_bddc :=_daee ._fdc .Peek (1);if _bddc ==_cb .EOF {break ;};if _bddc !=nil {return PdfObjectName (_cgbb .String ()),_bddc ;};if !_eefba {if _fagd [0]=='/'{_eefba =true ;_daee ._fdc .ReadByte ();}else if _fagd [0]=='%'{_daee .readComment ();
_daee .skipSpaces ();}else {_gf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_fagd ,_fagd );return PdfObjectName (_cgbb .String ()),_af .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_fagd [0]);
};}else {if IsWhiteSpace (_fagd [0]){break ;}else if (_fagd [0]=='/')||(_fagd [0]=='[')||(_fagd [0]=='(')||(_fagd [0]==']')||(_fagd [0]=='<')||(_fagd [0]=='>'){break ;}else if _fagd [0]=='#'{_eddde ,_bdec :=_daee ._fdc .Peek (3);if _bdec !=nil {return PdfObjectName (_cgbb .String ()),_bdec ;
};_bcfc ,_bdec :=_cg .DecodeString (string (_eddde [1:3]));if _bdec !=nil {_gf .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_cgbb .WriteByte ('#');_daee ._fdc .Discard (1);continue ;};_daee ._fdc .Discard (3);_cgbb .Write (_bcfc );}else {_dgbf ,_ :=_daee ._fdc .ReadByte ();_cgbb .WriteByte (_dgbf );};};};return PdfObjectName (_cgbb .String ()),nil ;};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_efdd *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_efdd .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};type objectStreams map[int ]objectStream ;var _adff =_ga .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_acee :=PdfObjectBool (val );return &_acee };

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_gfc *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _dedb _cc .Image ;if _gfc .ColorComponents ==1&&_gfc .BitsPerComponent ==8{_dedb =&_cc .Gray {Rect :_cc .Rect (0,0,_gfc .Width ,_gfc .Height ),Pix :data ,Stride :_bb .BytesPerLine (_gfc .Width ,_gfc .BitsPerComponent ,_gfc .ColorComponents )};
}else {var _bdc error ;_dedb ,_bdc =_bb .NewImage (_gfc .Width ,_gfc .Height ,_gfc .BitsPerComponent ,_gfc .ColorComponents ,data ,nil ,nil );if _bdc !=nil {return nil ,_bdc ;};};_ddfc :=_c .Options {};_ddfc .Quality =_gfc .Quality ;var _faced _gbg .Buffer ;
if _ebad :=_c .Encode (&_faced ,_dedb ,&_ddfc );_ebad !=nil {return nil ,_ebad ;};return _faced .Bytes (),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bggfa *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_bafg :=MakeDict ();_bafg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bggfa .GetFilterName ()));return _bafg ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_eeea *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gf .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_gf .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_eeea .Predictor );
if _eeea .BitsPerComponent !=8{return nil ,_af .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_eeea .BitsPerComponent );
};_ffgg ,_gdcb :=_eeea .DecodeBytes (streamObj .Stream );if _gdcb !=nil {return nil ,_gdcb ;};_ffgg ,_gdcb =_eeea .postDecodePredict (_ffgg );if _gdcb !=nil {return nil ,_gdcb ;};return _ffgg ,nil ;};func (_ffaf *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_ffaf ._fdc )};


// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ee .Filter ,userPass ,ownerPass []byte ,perm _fg .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_fdg :=&PdfCrypt {_cae :make (map[PdfObject ]bool ),_fcag :make (cryptFilters ),_acc :_fg .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _fca Version ;if cf !=nil {_eeb :=cf .PDFVersion ();_fca .Major ,_fca .Minor =_eeb [0],_eeb [1];V ,R :=cf .HandlerVersion ();_fdg ._ffgd .V =V ;_fdg ._acc .R =R ;_fdg ._ffgd .Length =cf .KeyLength ()*8;};const (_ddf =_fgf ;);_fdg ._fcag [_ddf ]=cf ;
if _fdg ._ffgd .V >=4{_fdg ._bfe =_ddf ;_fdg ._eab =_ddf ;};_ge :=_fdg .newEncryptDict ();_ede :=_e .Sum ([]byte (_b .Now ().Format (_b .RFC850 )));_egc :=string (_ede [:]);_acb :=make ([]byte ,100);_eb .Read (_acb );_ede =_e .Sum (_acb );_fac :=string (_ede [:]);
_gf .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_acb );_gf .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_egc );_fdg ._bc =_egc ;_aag :=_fdg .generateParams (userPass ,ownerPass );
if _aag !=nil {return nil ,nil ,_aag ;};_ggc (&_fdg ._acc ,_ge );if _fdg ._ffgd .V >=4{if _dbbb :=_fdg .saveCryptFilters (_ge );_dbbb !=nil {return nil ,nil ,_dbbb ;};};return _fdg ,&EncryptInfo {Version :_fca ,Encrypt :_ge ,ID0 :_egc ,ID1 :_fac },nil ;
};func (_agfca *PdfParser )readComment ()(string ,error ){var _dcge _gbg .Buffer ;_ ,_cgada :=_agfca .skipSpaces ();if _cgada !=nil {return _dcge .String (),_cgada ;};_eddd :=true ;for {_fgfe ,_begcc :=_agfca ._fdc .Peek (1);if _begcc !=nil {_gf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_begcc .Error ());
return _dcge .String (),_begcc ;};if _eddd &&_fgfe [0]!='%'{return _dcge .String (),_d .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_eddd =false ;if (_fgfe [0]!='\r')&&(_fgfe [0]!='\n'){_deac ,_ :=_agfca ._fdc .ReadByte ();
_dcge .WriteByte (_deac );}else {break ;};};return _dcge .String (),nil ;};

// GetXrefTable returns the PDFs xref table.
func (_dgggc *PdfParser )GetXrefTable ()XrefTable {return _dgggc ._gfdb };

// GetFilterName returns the name of the encoding filter.
func (_bcf *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// WriteString outputs the object as it is to be written to file.
func (_gefea *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// WriteString outputs the object as it is to be written to file.
func (_bcaed *PdfObjectName )WriteString ()string {var _faeb _gbg .Buffer ;if len (*_bcaed )> 127{_gf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_bcaed );};_faeb .WriteString ("\u002f");
for _afed :=0;_afed < len (*_bcaed );_afed ++{_ggbcd :=(*_bcaed )[_afed ];if !IsPrintable (_ggbcd )||_ggbcd =='#'||IsDelimiter (_ggbcd ){_faeb .WriteString (_af .Sprintf ("\u0023\u0025\u002e2\u0078",_ggbcd ));}else {_faeb .WriteByte (_ggbcd );};};return _faeb .String ();
};

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_fbe int ;_gaad bool ;_fccg [4]byte ;_cbe bool ;_add bool ;_eecf bool ;_fbg bool ;_daf bool ;_ccaab bool ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_dcgd :=PdfObjectFloat (val );return &_dcgd };