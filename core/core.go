//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_af "bufio";_bb "bytes";_ec "compress/lzw";_cc "compress/zlib";_ad "crypto/md5";_ff "crypto/rand";_ea "encoding/hex";_d "errors";_fgf "fmt";_ac "github.com/unidoc/unipdf/v3/common";_gd "github.com/unidoc/unipdf/v3/core/security";_aed "github.com/unidoc/unipdf/v3/core/security/crypt";
_df "github.com/unidoc/unipdf/v3/internal/ccittfax";_gg "github.com/unidoc/unipdf/v3/internal/imageutil";_cf "github.com/unidoc/unipdf/v3/internal/jbig2";_bf "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_dgc "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";
_ae "github.com/unidoc/unipdf/v3/internal/jbig2/document";_eg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_fa "github.com/unidoc/unipdf/v3/internal/precision";_acg "github.com/unidoc/unipdf/v3/internal/strutils";_dg "golang.org/x/image/tiff/lzw";
_fge "golang.org/x/xerrors";_c "image";_bd "image/color";_e "image/jpeg";_cb "io";_f "os";_gb "reflect";_fg "regexp";_fc "sort";_bc "strconv";_cd "strings";_b "sync";_a "time";_fd "unicode";);func _badfa (_acac PdfObject ,_fcgg int ,_fdg map[PdfObject ]struct{})error {_ac .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_fcgg );
if _ ,_befa :=_fdg [_acac ];_befa {_ac .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_fdg [_acac ]=struct{}{};switch _ccce :=_acac .(type ){case *PdfIndirectObject :_aeegf :=_ccce ;
_ac .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_aeegf );_ac .Log .Trace ("\u002d\u0020\u0025\u0073",_aeegf .PdfObject );return _badfa (_aeegf .PdfObject ,_fcgg +1,_fdg );case *PdfObjectStream :_dgbf :=_ccce ;return _badfa (_dgbf .PdfObjectDictionary ,_fcgg +1,_fdg );
case *PdfObjectDictionary :_abfca :=_ccce ;_ac .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_abfca );for _ ,_fgbf :=range _abfca .Keys (){_ecgb :=_abfca .Get (_fgbf );if _ggae ,_cbcde :=_ecgb .(*PdfObjectReference );_cbcde {_gfgac :=_ggae .Resolve ();
_abfca .Set (_fgbf ,_gfgac );_ebae :=_badfa (_gfgac ,_fcgg +1,_fdg );if _ebae !=nil {return _ebae ;};}else {_dcfa :=_badfa (_ecgb ,_fcgg +1,_fdg );if _dcfa !=nil {return _dcfa ;};};};return nil ;case *PdfObjectArray :_faefe :=_ccce ;_ac .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_faefe );
for _gcfd ,_cgbg :=range _faefe .Elements (){if _cdcef ,_cgfaae :=_cgbg .(*PdfObjectReference );_cgfaae {_adfgd :=_cdcef .Resolve ();_faefe .Set (_gcfd ,_adfgd );_cdcc :=_badfa (_adfgd ,_fcgg +1,_fdg );if _cdcc !=nil {return _cdcc ;};}else {_ecdge :=_badfa (_cgbg ,_fcgg +1,_fdg );
if _ecdge !=nil {return _ecdge ;};};};return nil ;case *PdfObjectReference :_ac .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _d .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};type cryptFilters map[string ]_aed .Filter ;

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bgaa *PdfCrypt )GetAccessPermissions ()_gd .Permissions {return _bgaa ._ed .P };

// String returns a string describing `array`.
func (_eabgg *PdfObjectArray )String ()string {_ceagf :="\u005b";for _fadfb ,_cfefa :=range _eabgg .Elements (){_ceagf +=_cfefa .String ();if _fadfb < (_eabgg .Len ()-1){_ceagf +="\u002c\u0020";};};_ceagf +="\u005d";return _ceagf ;};func _aefe (_adg *PdfObjectStream )(*MultiEncoder ,error ){_fgbg :=NewMultiEncoder ();
_acddb :=_adg .PdfObjectDictionary ;if _acddb ==nil {return _fgbg ,nil ;};var _geabe *PdfObjectDictionary ;var _fffa []PdfObject ;_ccea :=_acddb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _ccea !=nil {_dffe ,_fggc :=_ccea .(*PdfObjectDictionary );
if _fggc {_geabe =_dffe ;};_dddee ,_gbfa :=_ccea .(*PdfObjectArray );if _gbfa {for _ ,_fgec :=range _dddee .Elements (){_fgec =TraceToDirectObject (_fgec );if _bcbaa ,_defag :=_fgec .(*PdfObjectDictionary );_defag {_fffa =append (_fffa ,_bcbaa );}else {_fffa =append (_fffa ,MakeDict ());
};};};};_ccea =_acddb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _ccea ==nil {return nil ,_fgf .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_aaacb ,_afbg :=_ccea .(*PdfObjectArray );if !_afbg {return nil ,_fgf .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _edfd ,_gfefb :=range _aaacb .Elements (){_eabc ,_eea :=_gfefb .(*PdfObjectName );if !_eea {return nil ,_fgf .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _beec PdfObject ;if _geabe !=nil {_beec =_geabe ;}else {if len (_fffa )> 0{if _edfd >=len (_fffa ){return nil ,_fgf .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_beec =_fffa [_edfd ];};};var _gdb *PdfObjectDictionary ;if _aeeg ,_bebf :=_beec .(*PdfObjectDictionary );_bebf {_gdb =_aeeg ;};_ac .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_eabc ,_beec ,_gdb );
if *_eabc ==StreamEncodingFilterNameFlate {_afa ,_cded :=_efcf (_adg ,_gdb );if _cded !=nil {return nil ,_cded ;};_fgbg .AddEncoder (_afa );}else if *_eabc ==StreamEncodingFilterNameLZW {_cfbaf ,_dcb :=_fbef (_adg ,_gdb );if _dcb !=nil {return nil ,_dcb ;
};_fgbg .AddEncoder (_cfbaf );}else if *_eabc ==StreamEncodingFilterNameASCIIHex {_bcbb :=NewASCIIHexEncoder ();_fgbg .AddEncoder (_bcbb );}else if *_eabc ==StreamEncodingFilterNameASCII85 {_bbgg :=NewASCII85Encoder ();_fgbg .AddEncoder (_bbgg );}else if *_eabc ==StreamEncodingFilterNameDCT {_fadc ,_bafcd :=_abe (_adg ,_fgbg );
if _bafcd !=nil {return nil ,_bafcd ;};_fgbg .AddEncoder (_fadc );_ac .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_ac .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_fgbg );
}else if *_eabc ==StreamEncodingFilterNameCCITTFax {_aggc ,_fda :=_fdb (_adg ,_gdb );if _fda !=nil {return nil ,_fda ;};_fgbg .AddEncoder (_aggc );}else {_ac .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_eabc );
return nil ,_fgf .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _fgbg ,nil ;};func (_edbec *PdfParser )parseObject ()(PdfObject ,error ){_ac .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");
_edbec .skipSpaces ();for {_cade ,_cfbe :=_edbec ._bgbab .Peek (2);if _cfbe !=nil {if _cfbe !=_cb .EOF ||len (_cade )==0{return nil ,_cfbe ;};if len (_cade )==1{_cade =append (_cade ,' ');};};_ac .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_cade ));
if _cade [0]=='/'{_adf ,_bbaad :=_edbec .parseName ();_ac .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_adf );return &_adf ,_bbaad ;}else if _cade [0]=='('{_ac .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");
_agfgf ,_cbcg :=_edbec .parseString ();return _agfgf ,_cbcg ;}else if _cade [0]=='['{_ac .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_eebfd ,_bdecb :=_edbec .parseArray ();return _eebfd ,_bdecb ;}else if (_cade [0]=='<')&&(_cade [1]=='<'){_ac .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_faedb ,_agbf :=_edbec .ParseDict ();return _faedb ,_agbf ;}else if _cade [0]=='<'{_ac .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_feeef ,_eggda :=_edbec .parseHexString ();return _feeef ,_eggda ;}else if _cade [0]=='%'{_edbec .readComment ();
_edbec .skipSpaces ();}else {_ac .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_cade ,_ =_edbec ._bgbab .Peek (15);_ggcd :=string (_cade );_ac .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_ggcd );
if (len (_ggcd )> 3)&&(_ggcd [:4]=="\u006e\u0075\u006c\u006c"){_ccdf ,_abgc :=_edbec .parseNull ();return &_ccdf ,_abgc ;}else if (len (_ggcd )> 4)&&(_ggcd [:5]=="\u0066\u0061\u006cs\u0065"){_bbec ,_ceebe :=_edbec .parseBool ();return &_bbec ,_ceebe ;}else if (len (_ggcd )> 3)&&(_ggcd [:4]=="\u0074\u0072\u0075\u0065"){_ddee ,_ceff :=_edbec .parseBool ();
return &_ddee ,_ceff ;};_dcege :=_egad .FindStringSubmatch (_ggcd );if len (_dcege )> 1{_cade ,_ =_edbec ._bgbab .ReadBytes ('R');_ac .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_cade [:]));_ebbdd ,_bgbee :=_afbe (string (_cade ));
_ebbdd ._gafag =_edbec ;return &_ebbdd ,_bgbee ;};_cgccb :=_efdf .FindStringSubmatch (_ggcd );if len (_cgccb )> 1{_ac .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_facag ,_fcfd :=_edbec .parseNumber ();return _facag ,_fcfd ;
};_cgccb =_aada .FindStringSubmatch (_ggcd );if len (_cgccb )> 1{_ac .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_ac .Log .Trace ("\u0025\u0020\u0073",_cgccb );_ccee ,_eabgd :=_edbec .parseNumber ();
return _ccee ,_eabgd ;};_ac .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_ggcd );return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};func _afff (_bdea _cb .ReadSeeker ,_dfccc int64 )(*offsetReader ,error ){_cefbb :=&offsetReader {_agfd :_bdea ,_acaaf :_dfccc };_ ,_cgaab :=_cefbb .Seek (0,_cb .SeekStart );return _cefbb ,_cgaab ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_ccfd *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ccfd .DecodeBytes (streamObj .Stream );};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_bfeb *PdfParser )GetFileOffset ()int64 {_gabb ,_ :=_bfeb ._eebf .Seek (0,_cb .SeekCurrent );_gabb -=int64 (_bfeb ._bgbab .Buffered ());return _gabb ;};func (_dge *PdfCrypt )loadCryptFilters (_afdb *PdfObjectDictionary )error {_dge ._cdf =cryptFilters {};
_bgaed :=_afdb .Get ("\u0043\u0046");_bgaed =TraceToDirectObject (_bgaed );if _dda ,_abd :=_bgaed .(*PdfObjectReference );_abd {_dfc ,_bccg :=_dge ._agg .LookupByReference (*_dda );if _bccg !=nil {_ac .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _bccg ;};_bgaed =TraceToDirectObject (_dfc );};_abb ,_cdb :=_bgaed .(*PdfObjectDictionary );if !_cdb {_ac .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_bgaed );return _d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_bbe :=range _abb .Keys (){_edc :=_abb .Get (_bbe );if _cgc ,_acbe :=_edc .(*PdfObjectReference );_acbe {_dgb ,_ggge :=_dge ._agg .LookupByReference (*_cgc );if _ggge !=nil {_ac .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _ggge ;};_edc =TraceToDirectObject (_dgb );};_aff ,_dag :=_edc .(*PdfObjectDictionary );if !_dag {return _fgf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_bbe ,_edc );
};if _bbe =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _eabg _aed .FilterDict ;if _cad :=_afd (&_eabg ,_aff );_cad !=nil {return _cad ;};_fgc ,_cbac :=_aed .NewFilter (_eabg );if _cbac !=nil {return _cbac ;};_dge ._cdf [string (_bbe )]=_fgc ;};_dge ._cdf ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_aed .NewIdentity ();
_dge ._gca ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _aegb ,_dgcfc :=_afdb .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_dgcfc {if _ ,_fdda :=_dge ._cdf [string (*_aegb )];!_fdda {return _fgf .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_aegb );
};_dge ._gca =string (*_aegb );};_dge ._cgd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fag ,_age :=_afdb .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_age {if _ ,_abf :=_dge ._cdf [string (*_fag )];!_abf {return _fgf .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fag );
};_dge ._cgd =string (*_fag );};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_dcdad *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// GetXrefOffset returns the offset of the xref table.
func (_dfbfe *PdfParser )GetXrefOffset ()int64 {return _dfbfe ._ebbd };func (_cffcd *PdfParser )getNumbersOfUpdatedObjects (_adfe *PdfParser )([]int ,error ){if _adfe ==nil {return nil ,_d .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_fgeee :=_adfe ._fggb ;_ddadd :=make ([]int ,0);_bgee :=make (map[int ]interface{});_aeee :=make (map[int ]int64 );for _cffe ,_effgg :=range _cffcd ._adcd .ObjectMap {if _effgg .Offset ==0{if _effgg .OsObjNumber !=0{if _dcddg ,_ecef :=_cffcd ._adcd .ObjectMap [_effgg .OsObjNumber ];
_ecef {_bgee [_effgg .OsObjNumber ]=struct{}{};_aeee [_cffe ]=_dcddg .Offset ;}else {return nil ,_d .New ("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065");};};}else {_aeee [_cffe ]=_effgg .Offset ;};};for _aafc ,_bdegf :=range _aeee {if _ ,_gfcbd :=_bgee [_aafc ];
_gfcbd {continue ;};if _bdegf > _fgeee {_ddadd =append (_ddadd ,_aafc );};};return _ddadd ,nil ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// WriteString outputs the object as it is to be written to file.
func (_acfdc *PdfObjectReference )WriteString ()string {var _cdgf _cd .Builder ;_cdgf .WriteString (_bc .FormatInt (_acfdc .ObjectNumber ,10));_cdgf .WriteString ("\u0020");_cdgf .WriteString (_bc .FormatInt (_acfdc .GenerationNumber ,10));_cdgf .WriteString ("\u0020\u0052");
return _cdgf .String ();};

// DecodeStream implements ASCII85 stream decoding.
func (_begb *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _begb .DecodeBytes (streamObj .Stream );};func (_acgb *PdfParser )lookupByNumber (_ggc int ,_bdg bool )(PdfObject ,bool ,error ){_cfb ,_ceb :=_acgb .ObjCache [_ggc ];
if _ceb {_ac .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_ggc );return _cfb ,false ,nil ;};if _acgb ._eefg ==nil {_acgb ._eefg =map[int ]bool {};
};if _acgb ._eefg [_ggc ]{_ac .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_ggc );
return nil ,false ,_d .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_acgb ._eefg [_ggc ]=true ;defer delete (_acgb ._eefg ,_ggc );
_dcg ,_ceb :=_acgb ._adcd .ObjectMap [_ggc ];if !_ceb {_ac .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _acd PdfObjectNull ;return &_acd ,false ,nil ;};_ac .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_ggc );if _dcg .XType ==XrefTypeTableEntry {_ac .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_dcg .ObjectNumber );
_ac .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_dcg .Generation );_ac .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_dcg .Offset );_acgb ._eebf .Seek (_dcg .Offset ,_cb .SeekStart );
_acgb ._bgbab =_af .NewReader (_acgb ._eebf );_ga ,_gbg :=_acgb .ParseIndirectObject ();if _gbg !=nil {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_gbg );
if _bdg {_ac .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_dde ,_gc :=_acgb .repairRebuildXrefsTopDown ();
if _gc !=nil {_ac .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_gc );return nil ,false ,_gc ;};_acgb ._adcd =*_dde ;return _acgb .lookupByNumber (_ggc ,false );
};return nil ,false ,_gbg ;};if _bdg {_fdd ,_ ,_ :=_de (_ga );if int (_fdd )!=_ggc {_ac .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_acge :=_acgb .rebuildXrefTable ();
if _acge !=nil {return nil ,false ,_acge ;};_acgb .ObjCache =objectCache {};return _acgb .lookupByNumberWrapper (_ggc ,false );};};_ac .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_acgb .ObjCache [_ggc ]=_ga ;
return _ga ,false ,nil ;}else if _dcg .XType ==XrefTypeObjectStream {_ac .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_ac .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_ac .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_dcg .OsObjNumber ,_dcg .OsObjIndex );
if _dcg .OsObjNumber ==_ggc {_ac .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_d .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_bbaa :=_acgb ._adcd .ObjectMap [_dcg .OsObjNumber ];_bbaa {_fff ,_ca :=_acgb .lookupObjectViaOS (_dcg .OsObjNumber ,_ggc );if _ca !=nil {_ac .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_ca );
return nil ,true ,_ca ;};_ac .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_acgb .ObjCache [_ggc ]=_fff ;if _acgb ._ccbg !=nil {_acgb ._ccbg ._fbg [_fff ]=true ;};return _fff ,true ,nil ;};_ac .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_d .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_d .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};func (_bdada *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_bdada ._eebf .Seek (0,_cb .SeekStart );_bdada ._bgbab =_af .NewReader (_bdada ._eebf );
_ddcb :=20;_fedc :=make ([]byte ,_ddcb );for {_eggfd ,_dcdf :=_bdada ._bgbab .ReadByte ();if _dcdf !=nil {if _dcdf ==_cb .EOF {break ;}else {return 0,0,_dcdf ;};};if IsDecimalDigit (_eggfd )&&_fedc [_ddcb -1]=='.'&&IsDecimalDigit (_fedc [_ddcb -2])&&_fedc [_ddcb -3]=='-'&&_fedc [_ddcb -4]=='F'&&_fedc [_ddcb -5]=='D'&&_fedc [_ddcb -6]=='P'{_gcca :=int (_fedc [_ddcb -2]-'0');
_geeff :=int (_eggfd -'0');return _gcca ,_geeff ,nil ;};_fedc =append (_fedc [1:_ddcb ],_eggfd );};return 0,0,_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};func (_gcdg *PdfParser )xrefNextObjectOffset (_fdcfd int64 )int64 {_ecaa :=int64 (0);
if len (_gcdg ._adcd .ObjectMap )==0{return 0;};if len (_gcdg ._adcd ._cde )==0{_facf :=0;for _ ,_gcbdb :=range _gcdg ._adcd .ObjectMap {if _gcbdb .Offset > 0{_facf ++;};};if _facf ==0{return 0;};_gcdg ._adcd ._cde =make ([]XrefObject ,_facf );_ebag :=0;
for _ ,_afcfc :=range _gcdg ._adcd .ObjectMap {if _afcfc .Offset > 0{_gcdg ._adcd ._cde [_ebag ]=_afcfc ;_ebag ++;};};_fc .Slice (_gcdg ._adcd ._cde ,func (_abfc ,_cfbd int )bool {return _gcdg ._adcd ._cde [_abfc ].Offset < _gcdg ._adcd ._cde [_cfbd ].Offset });
};_ccbe :=_fc .Search (len (_gcdg ._adcd ._cde ),func (_fcfb int )bool {return _gcdg ._adcd ._cde [_fcfb ].Offset >=_fdcfd });if _ccbe < len (_gcdg ._adcd ._cde ){_ecaa =_gcdg ._adcd ._cde [_ccbe ].Offset ;};return _ecaa ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_agde *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bgeb []byte ;_ac .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_ffbb :=0;_cefb :=false ;for _ffbb < len (encoded )&&!_cefb {_ffffd :=[5]byte {0,0,0,0,0};
_abcg :=0;_cfff :=0;_aebd :=4;for _cfff < 5+_abcg {if _ffbb +_cfff ==len (encoded ){break ;};_beag :=encoded [_ffbb +_cfff ];if IsWhiteSpace (_beag ){_abcg ++;_cfff ++;continue ;}else if _beag =='~'&&_ffbb +_cfff +1< len (encoded )&&encoded [_ffbb +_cfff +1]=='>'{_aebd =(_cfff -_abcg )-1;
if _aebd < 0{_aebd =0;};_cefb =true ;break ;}else if _beag >='!'&&_beag <='u'{_beag -='!';}else if _beag =='z'&&_cfff -_abcg ==0{_aebd =4;_cfff ++;break ;}else {_ac .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_ffffd [_cfff -_abcg ]=_beag ;_cfff ++;};_ffbb +=_cfff ;for _bgaf :=_aebd +1;_bgaf < 5;_bgaf ++{_ffffd [_bgaf ]=84;
};_fgcg :=uint32 (_ffffd [0])*85*85*85*85+uint32 (_ffffd [1])*85*85*85+uint32 (_ffffd [2])*85*85+uint32 (_ffffd [3])*85+uint32 (_ffffd [4]);_dgfe :=[]byte {byte ((_fgcg >>24)&0xff),byte ((_fgcg >>16)&0xff),byte ((_fgcg >>8)&0xff),byte (_fgcg &0xff)};_bgeb =append (_bgeb ,_dgfe [:_aebd ]...);
};_ac .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_ac .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_bgeb );
return _bgeb ,nil ;};func (_bdf *PdfParser )lookupObjectViaOS (_acb int ,_fe int )(PdfObject ,error ){var _cfe *_bb .Reader ;var _ce objectStream ;var _bec bool ;_ce ,_bec =_bdf ._fdfa [_acb ];if !_bec {_bcd ,_bdd :=_bdf .LookupByNumber (_acb );if _bdd !=nil {_ac .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_acb );
return nil ,_bdd ;};_db ,_dbf :=_bcd .(*PdfObjectStream );if !_dbf {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _bdf ._ccbg !=nil &&!_bdf ._ccbg .isDecrypted (_db ){return nil ,_d .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_dc :=_db .PdfObjectDictionary ;_ac .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_dc .String ());_cfa ,_dbf :=_dc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_dbf {_ac .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _cd .ToLower (string (*_cfa ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_d .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_dbf :=_dc .Get ("\u004e").(*PdfObjectInteger );if !_dbf {return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_cee ,_dbf :=_dc .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_dbf {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_ac .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_cfa ,*N );_ccd ,_bdd :=DecodeStream (_db );if _bdd !=nil {return nil ,_bdd ;
};_ac .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ccd );_dcf :=_bdf .GetFileOffset ();defer func (){_bdf .SetFileOffset (_dcf )}();_cfe =_bb .NewReader (_ccd );_bdf ._bgbab =_af .NewReader (_cfe );_ac .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_gf :=map[int ]int64 {};for _cfc :=0;_cfc < int (*N );_cfc ++{_bdf .skipSpaces ();_fb ,_eae :=_bdf .parseNumber ();if _eae !=nil {return nil ,_eae ;};_eac ,_afc :=_fb .(*PdfObjectInteger );if !_afc {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_bdf .skipSpaces ();_fb ,_eae =_bdf .parseNumber ();if _eae !=nil {return nil ,_eae ;};_gdg ,_afc :=_fb .(*PdfObjectInteger );if !_afc {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_ac .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_eac ,*_gdg );_gf [int (*_eac )]=int64 (*_cee +*_gdg );};_ce =objectStream {N :int (*N ),_bba :_ccd ,_be :_gf };_bdf ._fdfa [_acb ]=_ce ;}else {_bfa :=_bdf .GetFileOffset ();
defer func (){_bdf .SetFileOffset (_bfa )}();_cfe =_bb .NewReader (_ce ._bba );_bdf ._bgbab =_af .NewReader (_cfe );};_ee :=_ce ._be [_fe ];_ac .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_fe ,_ee );
_cfe .Seek (_ee ,_cb .SeekStart );_bdf ._bgbab =_af .NewReader (_cfe );_gfg ,_ :=_bdf ._bgbab .Peek (100);_ac .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_gfg ));_bg ,_cbd :=_bdf .parseObject ();
if _cbd !=nil {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_cbd );return nil ,_cbd ;};if _bg ==nil {return nil ,_d .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");
};_ge :=PdfIndirectObject {};_ge .ObjectNumber =int64 (_fe );_ge .PdfObject =_bg ;_ge ._gafag =_bdf ;return &_ge ,nil ;};

// Seek implementation of Seek interface.
func (_gged *limitedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){var _fagb int64 ;switch whence {case _cb .SeekStart :_fagb =offset ;case _cb .SeekCurrent :_cgcea ,_gefb :=_gged ._ecbb .Seek (0,_cb .SeekCurrent );if _gefb !=nil {return 0,_gefb ;
};_fagb =_cgcea +offset ;case _cb .SeekEnd :_fagb =_gged ._geea +offset ;};if _effb :=_gged .getError (_fagb );_effb !=nil {return 0,_effb ;};if _ ,_gagd :=_gged ._ecbb .Seek (_fagb ,_cb .SeekStart );_gagd !=nil {return 0,_gagd ;};return _fagb ,nil ;};


// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// WriteString outputs the object as it is to be written to file.
func (_bgfgb *PdfObjectStreams )WriteString ()string {var _accec _cd .Builder ;_accec .WriteString (_bc .FormatInt (_bgfgb .ObjectNumber ,10));_accec .WriteString ("\u0020\u0030\u0020\u0052");return _accec .String ();};

// GetFilterName returns the name of the encoding filter.
func (_ccaa *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_edbf *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_bcdge Version ;_eebf _cb .ReadSeeker ;_bgbab *_af .Reader ;_fggb int64 ;_adcd XrefTable ;_ebbd int64 ;_aegca *xrefType ;_fdfa objectStreams ;_afbc *PdfObjectDictionary ;_ccbg *PdfCrypt ;_bccb *PdfIndirectObject ;_bfga bool ;ObjCache objectCache ;
_eefg map[int ]bool ;_bgdf map[int64 ]bool ;_daag ParserMetadata ;_gfdba bool ;_fccg []int64 ;_bgafa int ;_baad bool ;_eafc int64 ;_afab map[*PdfParser ]*PdfParser ;_bbede []*PdfParser ;

// Opts holds different parsing options.
Opts *ParserOpts ;};

// GetFilterName returns the name of the encoding filter.
func (_dggg *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_aadg *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_dfdg ,_ebed :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ebed ==nil {_aadg .BitsPerComponent =int (_dfdg );
};_dfbfc ,_ebed :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ebed ==nil {_aadg .Width =int (_dfbfc );};_fdag ,_ebed :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _ebed ==nil {_aadg .Height =int (_fdag );
};_gddb ,_ebed :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ebed ==nil {_aadg .ColorComponents =int (_gddb );};};

// WriteString outputs the object as it is to be written to file.
func (_adce *PdfObjectFloat )WriteString ()string {return _bc .FormatFloat (float64 (*_adce ),'f',-1,64);};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_fcec :=&FlateEncoder {};_fcec .Predictor =1;_fcec .BitsPerComponent =8;_fcec .Colors =1;_fcec .Columns =1;return _fcec ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_gaec *PdfObjectReference )Resolve ()PdfObject {if _gaec ._gafag ==nil {return MakeNull ();};_adee ,_ ,_fbfde :=_gaec ._gafag .resolveReference (_gaec );if _fbfde !=nil {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_fbfde );
return MakeNull ();};if _adee ==nil {_ac .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _adee ;};

// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_abba *PdfParser )GetPreviousRevisionReadSeeker ()(_cb .ReadSeeker ,error ){if _bebg :=_abba .seekToEOFMarker (_abba ._fggb -_dab );_bebg !=nil {return nil ,_bebg ;};_aafe ,_faedd :=_abba ._eebf .Seek (0,_cb .SeekCurrent );if _faedd !=nil {return nil ,_faedd ;
};_aafe +=_dab ;return _bbed (_abba ._eebf ,_aafe );};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;Decode []float64 ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_cbdc *JBIG2Encoder )Encode ()(_ddbf []byte ,_efcg error ){const _gcbba ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _cbdc ._eccg ==nil {return nil ,_eg .Errorf (_gcbba ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_cbdc ._eccg .FullHeaders =_cbdc .DefaultPageSettings .FileMode ;_ddbf ,_efcg =_cbdc ._eccg .Encode ();if _efcg !=nil {return nil ,_eg .Wrap (_efcg ,_gcbba ,"");};return _ddbf ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfab *LZWEncoder )MakeDecodeParams ()PdfObject {if _bfab .Predictor > 1{_dbcb :=MakeDict ();_dbcb .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_bfab .Predictor )));if _bfab .BitsPerComponent !=8{_dbcb .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_bfab .BitsPerComponent )));
};if _bfab .Columns !=1{_dbcb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bfab .Columns )));};if _bfab .Colors !=1{_dbcb .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_bfab .Colors )));};return _dbcb ;};return nil ;
};

// String returns the state of the bool as "true" or "false".
func (_gbde *PdfObjectBool )String ()string {if *_gbde {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_dbbb string ,_cfcea bool ){_gdgf ,_cfcea :=TraceToDirectObject (obj ).(*PdfObjectString );if _cfcea {return _gdgf .Str (),true ;};return ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_eacaa *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _cabc ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _eacaa .ColorComponents !=1||_eacaa .BitsPerComponent !=1{return nil ,_eg .Errorf (_cabc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_cebb *_bf .Bitmap ;_agda error ;);_ecdb :=(_eacaa .Width *_eacaa .Height )==len (data );if _ecdb {_cebb ,_agda =_bf .NewWithUnpaddedData (_eacaa .Width ,_eacaa .Height ,data );}else {_cebb ,_agda =_bf .NewWithData (_eacaa .Width ,_eacaa .Height ,data );
};if _agda !=nil {return nil ,_agda ;};_caea :=_eacaa .DefaultPageSettings ;if _agda =_caea .Validate ();_agda !=nil {return nil ,_eg .Wrap (_agda ,_cabc ,"");};if _eacaa ._eccg ==nil {_eacaa ._eccg =_ae .InitEncodeDocument (_caea .FileMode );};switch _caea .Compression {case JB2Generic :if _agda =_eacaa ._eccg .AddGenericPage (_cebb ,_caea .DuplicatedLinesRemoval );
_agda !=nil {return nil ,_eg .Wrap (_agda ,_cabc ,"");};case JB2SymbolCorrelation :return nil ,_eg .Error (_cabc ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_eg .Error (_cabc ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_eg .Error (_cabc ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _eacaa .Encode ();};

// UpdateParams updates the parameter values of the encoder.
func (_agb *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_bfg ,_gde :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _gde ==nil {_agb .Predictor =int (_bfg );};_bcca ,_gde :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _gde ==nil {_agb .BitsPerComponent =int (_bcca );};_cdaf ,_gde :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _gde ==nil {_agb .Columns =int (_cdaf );};_aeac ,_gde :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _gde ==nil {_agb .Colors =int (_aeac );};_cdae ,_gde :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _gde ==nil {_agb .EarlyChange =int (_cdae );};};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_feafa *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_fcaa :=PdfObjectBool (val );return &_fcaa };func _abfcd (_beeca string )(int ,int ,error ){_eggag :=_abfbd .FindStringSubmatch (_beeca );if len (_eggag )< 3{return 0,0,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_agae ,_ :=_bc .Atoi (_eggag [1]);_cbeb ,_ :=_bc .Atoi (_eggag [2]);return _agae ,_cbeb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_egbe *PdfIndirectObject )WriteString ()string {var _dacaf _cd .Builder ;_dacaf .WriteString (_bc .FormatInt (_egbe .ObjectNumber ,10));_dacaf .WriteString ("\u0020\u0030\u0020\u0052");return _dacaf .String ();};

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_fgfa ParserMetadata )HasEOLAfterHeader ()bool {return _fgfa ._fbba };

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_caf ParserMetadata )HasOddLengthHexStrings ()bool {return _caf ._ggbb };

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_bd .Model ;Bounds ()_c .Rectangle ;At (_ccac ,_dbb int )_bd .Color ;Set (_bac ,_dga int ,_fdee _bd .Color );};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_cbba *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cbba .DecodeBytes (streamObj .Stream );};func (_bdfb *JBIG2Image )toBitmap ()(_cacd *_bf .Bitmap ,_caef error ){const _efbg ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";
if _bdfb .Data ==nil {return nil ,_eg .Error (_efbg ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _bdfb .Width ==0||_bdfb .Height ==0{return nil ,_eg .Error (_efbg ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _bdfb .HasPadding {_cacd ,_caef =_bf .NewWithData (_bdfb .Width ,_bdfb .Height ,_bdfb .Data );}else {_cacd ,_caef =_bf .NewWithUnpaddedData (_bdfb .Width ,_bdfb .Height ,_bdfb .Data );};if _caef !=nil {return nil ,_eg .Wrap (_caef ,_efbg ,"");};return _cacd ,nil ;
};

// GetFilterName returns the name of the encoding filter.
func (_ggd *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };func (_daeb *PdfParser )rebuildXrefTable ()error {_gded :=XrefTable {};_gded .ObjectMap =map[int ]XrefObject {};_dbea :=make ([]int ,0,len (_daeb ._adcd .ObjectMap ));
for _afba :=range _daeb ._adcd .ObjectMap {_dbea =append (_dbea ,_afba );};_fc .Ints (_dbea );for _ ,_fdae :=range _dbea {_eacd :=_daeb ._adcd .ObjectMap [_fdae ];_edeg ,_ ,_cdefb :=_daeb .lookupByNumberWrapper (_fdae ,false );if _cdefb !=nil {_ac .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_cdefb );
_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_fbeceb ,_gbcg :=_daeb .repairRebuildXrefsTopDown ();if _gbcg !=nil {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_gbcg );
return _gbcg ;};_daeb ._adcd =*_fbeceb ;_ac .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_gfee ,_aabe ,_cdefb :=_de (_edeg );if _cdefb !=nil {return _cdefb ;
};_eacd .ObjectNumber =int (_gfee );_eacd .Generation =int (_aabe );_gded .ObjectMap [int (_gfee )]=_eacd ;};_daeb ._adcd =_gded ;_ac .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_fbd (_daeb ._adcd );
return nil ;};

// Append appends PdfObject(s) to the array.
func (_aaag *PdfObjectArray )Append (objects ...PdfObject ){if _aaag ==nil {_ac .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_aaag ._dcfc =append (_aaag ._dcfc ,objects ...);};

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_gfd ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _gfd ._dbce };func (_gfegf *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_cb .SeekStart {offset +=_gfegf ._acaaf ;};_egce ,_aefb :=_gfegf ._agfd .Seek (offset ,whence );
if _aefb !=nil {return _egce ,_aefb ;};if whence ==_cb .SeekCurrent {_egce -=_gfegf ._acaaf ;};if _egce < 0{return 0,_d .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _egce ,nil ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_cde []XrefObject ;};

// LookupByReference looks up a PdfObject by a reference.
func (_gab *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_ac .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _gab .LookupByNumber (int (ref .ObjectNumber ));
};

// Append appends PdfObject(s) to the streams.
func (_afefb *PdfObjectStreams )Append (objects ...PdfObject ){if _afefb ==nil {_ac .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_afefb ._aefg =append (_afefb ._aefg ,objects ...);};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};func (_baeg *JBIG2Encoder )encodeImage (_gggb _c .Image )([]byte ,error ){const _bcfd ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_bgc ,_egga :=GoImageToJBIG2 (_gggb ,JB2ImageAutoThreshold );if _egga !=nil {return nil ,_eg .Wrap (_egga ,_bcfd ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");
};if _egga =_baeg .AddPageImage (_bgc ,&_baeg .DefaultPageSettings );_egga !=nil {return nil ,_eg .Wrap (_egga ,_bcfd ,"");};return _baeg .Encode ();};

// UpdateParams updates the parameter values of the encoder.
func (_gbf *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};func _afbe (_cebbfd string )(PdfObjectReference ,error ){_aefd :=PdfObjectReference {};_gfggc :=_egad .FindStringSubmatch (_cebbfd );if len (_gfggc )< 3{_ac .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
return _aefd ,_d .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_bdee ,_ :=_bc .Atoi (_gfggc [1]);_egebc ,_ :=_bc .Atoi (_gfggc [2]);_aefd .ObjectNumber =int64 (_bdee );
_aefd .GenerationNumber =int64 (_egebc );return _aefd ,nil ;};var _ebbfc =_fg .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fegd *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_dbe :=MakeDict ();_dbe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fegd .GetFilterName ()));return _dbe ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_egge *FlateEncoder )SetPredictor (columns int ){_egge .Predictor =11;_egge .Columns =columns };

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_abga *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _eege _bb .Buffer ;_aec :=_bb .NewReader (encoded );var _bggb _cb .ReadCloser ;if _abga .EarlyChange ==1{_bggb =_dg .NewReader (_aec ,_dg .MSB ,8);}else {_bggb =_ec .NewReader (_aec ,_ec .MSB ,8);
};defer _bggb .Close ();if _ ,_cfba :=_eege .ReadFrom (_bggb );_cfba !=nil {if _cfba !=_cb .ErrUnexpectedEOF ||_eege .Len ()==0{return nil ,_cfba ;};_ac .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_cfba );
};return _eege .Bytes (),nil ;};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_efeb *JBIG2Encoder )DecodeImages (encoded []byte )([]_c .Image ,error ){const _badf ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_ebd ,_fdbf :=_dgc .Decode (encoded ,_dgc .Parameters {},_efeb .Globals .ToDocumentGlobals ());
if _fdbf !=nil {return nil ,_eg .Wrap (_fdbf ,_badf ,"");};_bdad ,_fdbf :=_ebd .PageNumber ();if _fdbf !=nil {return nil ,_eg .Wrap (_fdbf ,_badf ,"");};_efac :=[]_c .Image {};var _cgff _c .Image ;for _bgfbb :=1;_bgfbb <=_bdad ;_bgfbb ++{_cgff ,_fdbf =_ebd .DecodePageImage (_bgfbb );
if _fdbf !=nil {return nil ,_eg .Wrapf (_fdbf ,_badf ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bgfbb );};_efac =append (_efac ,_cgff );};return _efac ,nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);var _cbcf =_fg .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");


// WriteString outputs the object as it is to be written to file.
func (_efce *PdfObjectName )WriteString ()string {var _gdad _bb .Buffer ;if len (*_efce )> 127{_ac .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_efce );};_gdad .WriteString ("\u002f");
for _bgfe :=0;_bgfe < len (*_efce );_bgfe ++{_aebb :=(*_efce )[_bgfe ];if !IsPrintable (_aebb )||_aebb =='#'||IsDelimiter (_aebb ){_gdad .WriteString (_fgf .Sprintf ("\u0023\u0025\u002e2\u0078",_aebb ));}else {_gdad .WriteByte (_aebb );};};return _gdad .String ();
};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_egfc *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};func (_cg *PdfParser )lookupByNumberWrapper (_dce int ,_fbb bool )(PdfObject ,bool ,error ){_eb ,_bbad ,_cgg :=_cg .lookupByNumber (_dce ,_fbb );if _cgg !=nil {return nil ,_bbad ,_cgg ;
};if !_bbad &&_cg ._ccbg !=nil &&_cg ._ccbg ._gba &&!_cg ._ccbg .isDecrypted (_eb ){_dd :=_cg ._ccbg .Decrypt (_eb ,0,0);if _dd !=nil {return nil ,_bbad ,_dd ;};};return _eb ,_bbad ,nil ;};func (_gfcg *ASCII85Encoder )base256Tobase85 (_ccaf uint32 )[5]byte {_acddd :=[5]byte {0,0,0,0,0};
_fabb :=_ccaf ;for _gcace :=0;_gcace < 5;_gcace ++{_ffcd :=uint32 (1);for _bafa :=0;_bafa < 4-_gcace ;_bafa ++{_ffcd *=85;};_febd :=_fabb /_ffcd ;_fabb =_fabb %_ffcd ;_acddd [_gcace ]=byte (_febd );};return _acddd ;};var _dae =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};


// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eca *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_cdfce *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_cdfce ._caefg .Lock ();defer _cdfce ._caefg .Unlock ();_fgfc ,_dadc :=_cdfce ._cedfc [key ];if !_dadc {return nil ;};return _fgfc ;};

// GetFilterName returns the name of the encoding filter.
func (_acfd *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// Remove removes an element specified by key.
func (_gcead *PdfObjectDictionary )Remove (key PdfObjectName ){_dacae :=-1;for _abaa ,_afda :=range _gcead ._gggg {if _afda ==key {_dacae =_abaa ;break ;};};if _dacae >=0{_gcead ._gggg =append (_gcead ._gggg [:_dacae ],_gcead ._gggg [_dacae +1:]...);delete (_gcead ._cedfc ,key );
};};func _fdb (_dfgd *PdfObjectStream ,_faec *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_gbe :=NewCCITTFaxEncoder ();_efef :=_dfgd .PdfObjectDictionary ;if _efef ==nil {return _gbe ,nil ;};if _faec ==nil {_gad :=TraceToDirectObject (_efef .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));
if _gad !=nil {switch _abfb :=_gad .(type ){case *PdfObjectDictionary :_faec =_abfb ;case *PdfObjectArray :if _abfb .Len ()==1{if _ggcf ,_bacd :=GetDict (_abfb .Get (0));_bacd {_faec =_ggcf ;};};default:_ac .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_gad );
return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _faec ==nil {_ac .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_gad );
return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _eage ,_fcae :=GetNumberAsInt64 (_faec .Get ("\u004b"));_fcae ==nil {_gbe .K =int (_eage );};if _effg ,_gggeg :=GetNumberAsInt64 (_faec .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_gggeg ==nil {_gbe .Columns =int (_effg );}else {_gbe .Columns =1728;};if _befg ,_gdab :=GetNumberAsInt64 (_faec .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gdab ==nil {_gbe .BlackIs1 =_befg > 0;}else {if _dac ,_agcb :=GetBoolVal (_faec .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_agcb {_gbe .BlackIs1 =_dac ;}else {if _bgge ,_cgcc :=GetArray (_faec .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_cgcc {_edaa ,_caeeg :=_bgge .ToIntegerArray ();if _caeeg ==nil {_gbe .BlackIs1 =_edaa [0]==1&&_edaa [1]==0;};};};};if _ccdc ,_cfde :=GetNumberAsInt64 (_faec .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_cfde ==nil {_gbe .EncodedByteAlign =_ccdc > 0;}else {if _gcag ,_bgfg :=GetBoolVal (_faec .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bgfg {_gbe .EncodedByteAlign =_gcag ;};};if _geg ,_bda :=GetNumberAsInt64 (_faec .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_bda ==nil {_gbe .EndOfLine =_geg > 0;}else {if _dgcff ,_ggce :=GetBoolVal (_faec .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_ggce {_gbe .EndOfLine =_dgcff ;};};if _bdaa ,_bcbd :=GetNumberAsInt64 (_faec .Get ("\u0052\u006f\u0077\u0073"));_bcbd ==nil {_gbe .Rows =int (_bdaa );
};_gbe .EndOfBlock =true ;if _fafc ,_deg :=GetNumberAsInt64 (_faec .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_deg ==nil {_gbe .EndOfBlock =_fafc > 0;}else {if _deeb ,_gfbg :=GetBoolVal (_faec .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_gfbg {_gbe .EndOfBlock =_deeb ;};};if _gfaa ,_cbg :=GetNumberAsInt64 (_faec .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_cbg !=nil {_gbe .DamagedRowsBeforeError =int (_gfaa );
};_ac .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_faec .String ());return _gbe ,nil ;};func (_eddb *PdfObjectFloat )String ()string {return _fgf .Sprintf ("\u0025\u0066",*_eddb )};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _cb .ReadSeeker )(*PdfParser ,error ){_gece :=&PdfParser {_eebf :rs ,ObjCache :make (objectCache ),_bgdf :map[int64 ]bool {},_fccg :make ([]int64 ,0),_afab :make (map[*PdfParser ]*PdfParser )};_bcfb :=_gece .initParser ();if _bcfb !=nil {return nil ,_bcfb ;
};return _gece ,nil ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_aed .FilterDict ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gbbd *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };func (_eagd *PdfCrypt )makeKey (_edb string ,_dfcc ,_dca uint32 ,_cgdb []byte )([]byte ,error ){_ada ,_gbab :=_eagd ._cdf [_edb ];if !_gbab {return nil ,_fgf .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_edb );
};return _ada .MakeKey (_dfcc ,_dca ,_cgdb );};func _cdgd ()string {return _ac .Version };func (_cgfb *PdfParser )readComment ()(string ,error ){var _gbeb _bb .Buffer ;_ ,_agfc :=_cgfb .skipSpaces ();if _agfc !=nil {return _gbeb .String (),_agfc ;};_cabe :=true ;
for {_cgbf ,_fgad :=_cgfb ._bgbab .Peek (1);if _fgad !=nil {_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_fgad .Error ());return _gbeb .String (),_fgad ;};if _cabe &&_cgbf [0]!='%'{return _gbeb .String (),_d .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");
};_cabe =false ;if (_cgbf [0]!='\r')&&(_cgbf [0]!='\n'){_ecbad ,_ :=_cgfb ._bgbab .ReadByte ();_gbeb .WriteByte (_ecbad );}else {break ;};};return _gbeb .String (),nil ;};

// String returns a string describing `ref`.
func (_agbaa *PdfObjectReference )String ()string {return _fgf .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_agbaa .ObjectNumber ,_agbaa .GenerationNumber );};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};func (_dafe *PdfParser )resolveReference (_agdaf *PdfObjectReference )(PdfObject ,bool ,error ){_gfac ,_abef :=_dafe .ObjCache [int (_agdaf .ObjectNumber )];if _abef {return _gfac ,true ,nil ;
};_accg ,_egbf :=_dafe .LookupByReference (*_agdaf );if _egbf !=nil {return nil ,false ,_egbf ;};_dafe .ObjCache [int (_agdaf .ObjectNumber )]=_accg ;return _accg ,false ,nil ;};

// GetRevisionNumber returns the current version of the Pdf document.
func (_cfeba *PdfParser )GetRevisionNumber ()int {return _cfeba ._bgafa };

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _cebbb (obj ,0)};

// Bytes returns the PdfObjectString content as a []byte array.
func (_ccde *PdfObjectString )Bytes ()[]byte {return []byte (_ccde ._agdge )};func _eba (_eda _aed .Filter ,_ced _gd .AuthEvent )*PdfObjectDictionary {if _ced ==""{_ced =_gd .EventDocOpen ;};_dfb :=MakeDict ();_dfb .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));
_dfb .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_ced )));_dfb .Set ("\u0043\u0046\u004d",MakeName (_eda .Name ()));_dfb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_eda .KeyLength ())));return _dfb ;};var _efdf =_fg .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");
type offsetReader struct{_agfd _cb .ReadSeeker ;_acaaf int64 ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_ffbd *PdfParser )CheckAccessRights (password []byte )(bool ,_gd .Permissions ,error ){if _ffbd ._ccbg ==nil {return true ,_gd .PermOwner ,nil ;};return _ffbd ._ccbg .checkAccessRights (password );};func (_dfcf *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _dfcf ._bfga {return nil ,_fgf .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_dfcf ._bfga =true ;_dfcf ._eebf .Seek (0,_cb .SeekStart );_dfcf ._bgbab =_af .NewReader (_dfcf ._eebf );_aadfc :=20;_bdfdc :=make ([]byte ,_aadfc );_gbbag :=XrefTable {};_gbbag .ObjectMap =make (map[int ]XrefObject );for {_caad ,_dcgd :=_dfcf ._bgbab .ReadByte ();
if _dcgd !=nil {if _dcgd ==_cb .EOF {break ;}else {return nil ,_dcgd ;};};if _caad =='j'&&_bdfdc [_aadfc -1]=='b'&&_bdfdc [_aadfc -2]=='o'&&IsWhiteSpace (_bdfdc [_aadfc -3]){_eddbe :=_aadfc -4;for IsWhiteSpace (_bdfdc [_eddbe ])&&_eddbe > 0{_eddbe --;};
if _eddbe ==0||!IsDecimalDigit (_bdfdc [_eddbe ]){continue ;};for IsDecimalDigit (_bdfdc [_eddbe ])&&_eddbe > 0{_eddbe --;};if _eddbe ==0||!IsWhiteSpace (_bdfdc [_eddbe ]){continue ;};for IsWhiteSpace (_bdfdc [_eddbe ])&&_eddbe > 0{_eddbe --;};if _eddbe ==0||!IsDecimalDigit (_bdfdc [_eddbe ]){continue ;
};for IsDecimalDigit (_bdfdc [_eddbe ])&&_eddbe > 0{_eddbe --;};if _eddbe ==0{continue ;};_gfeec :=_dfcf .GetFileOffset ()-int64 (_aadfc -_eddbe );_cbgad :=append (_bdfdc [_eddbe +1:],_caad );_gfabd ,_gbffe ,_gfce :=_abfcd (string (_cbgad ));if _gfce !=nil {_ac .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_gfce );
return nil ,_gfce ;};if _cfgef ,_acff :=_gbbag .ObjectMap [_gfabd ];!_acff ||_cfgef .Generation < _gbffe {_face :=XrefObject {};_face .XType =XrefTypeTableEntry ;_face .ObjectNumber =_gfabd ;_face .Generation =_gbffe ;_face .Offset =_gfeec ;_gbbag .ObjectMap [_gfabd ]=_face ;
};};_bdfdc =append (_bdfdc [1:_aadfc ],_caad );};_dfcf ._eefg =nil ;return &_gbbag ,nil ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_ecba *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ecba .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_cefbf *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_bdec ParserMetadata )HasInvalidHexRunes ()bool {return _bdec ._ddc };

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_baaaf *PdfObjectInteger ,_fgca bool ){_baaaf ,_fgca =TraceToDirectObject (obj ).(*PdfObjectInteger );return _baaaf ,_fgca ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// WriteString outputs the object as it is to be written to file.
func (_gcba *PdfObjectStream )WriteString ()string {var _daefg _cd .Builder ;_daefg .WriteString (_bc .FormatInt (_gcba .ObjectNumber ,10));_daefg .WriteString ("\u0020\u0030\u0020\u0052");return _daefg .String ();};func (_eabe *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_fea :=MakeDict ();
_fea .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_fea .Set ("\u0056",MakeInteger (int64 (_eabe ._gea .V )));_fea .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_eabe ._gea .Length )));
return _fea ;};func (_faeca *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_efaf :=_faeca ._bgbab .Discard (4);return PdfObjectNull {},_efaf ;};func _bcdg (_cbaaf *PdfObjectStream ,_dfee *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _abab ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";
_ffdc :=NewJBIG2Encoder ();_efae :=_cbaaf .PdfObjectDictionary ;if _efae ==nil {return _ffdc ,nil ;};if _dfee ==nil {_cgfa :=_efae .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _cgfa !=nil {switch _bdcd :=_cgfa .(type ){case *PdfObjectDictionary :_dfee =_bdcd ;
case *PdfObjectArray :if _bdcd .Len ()==1{if _adbb ,_cddc :=GetDict (_bdcd .Get (0));_cddc {_dfee =_adbb ;};};default:_ac .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_cgfa );
return nil ,_eg .Errorf (_abab ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_bdcd );};};};if _dfee ==nil {return _ffdc ,nil ;};_ffdc .UpdateParams (_dfee );
_fbc ,_ffdag :=GetStream (_dfee .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_ffdag {return _ffdc ,nil ;};var _abec error ;_ffdc .Globals ,_abec =_cf .DecodeGlobals (_fbc .Stream );if _abec !=nil {_abec =_eg .Wrap (_abec ,_abab ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_ac .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_abec );return nil ,_abec ;};return _ffdc ,nil ;};func (_cfbb *PdfParser )checkLinearizedInformation (_bgcd *PdfObjectDictionary )(bool ,error ){var _gadb error ;_cfbb ._eafc ,_gadb =GetNumberAsInt64 (_bgcd .Get ("\u004c"));
if _gadb !=nil {return false ,_gadb ;};_gadb =_cfbb .seekToEOFMarker (_cfbb ._eafc );switch _gadb {case nil :return true ,nil ;case _efgd :return false ,nil ;default:return false ,_gadb ;};};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_abff []StreamEncoder };

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_ggbc :=MakeArray ();for _ ,_ddca :=range vals {_ggbc .Append (MakeInteger (int64 (_ddca )));};return _ggbc ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_feegd *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_feegd .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_egdda *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_baba :=MakeDict ();_baba .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_egdda .GetFilterName ()));return _baba ;};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_bfde *PdfObjectString ,_dacaa bool ){_bfde ,_dacaa =TraceToDirectObject (obj ).(*PdfObjectString );return _bfde ,_dacaa ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_fagd *PdfParser )GetObjectNums ()[]int {var _ebegd []int ;for _ ,_abcbb :=range _fagd ._adcd .ObjectMap {_ebegd =append (_ebegd ,_abcbb .ObjectNumber );};_fc .Ints (_ebegd );return _ebegd ;};func _fbef (_fegea *PdfObjectStream ,_geab *PdfObjectDictionary )(*LZWEncoder ,error ){_fbdd :=NewLZWEncoder ();
_edcd :=_fegea .PdfObjectDictionary ;if _edcd ==nil {return _fbdd ,nil ;};if _geab ==nil {_fbbd :=TraceToDirectObject (_edcd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _fbbd !=nil {if _fage ,_caeea :=_fbbd .(*PdfObjectDictionary );
_caeea {_geab =_fage ;}else if _cea ,_effc :=_fbbd .(*PdfObjectArray );_effc {if _cea .Len ()==1{if _afdbc ,_ded :=GetDict (_cea .Get (0));_ded {_geab =_afdbc ;};};};if _geab ==nil {_ac .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_fbbd );
return nil ,_fgf .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_fadf :=_edcd .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _fadf !=nil {_cfge ,_dcec :=_fadf .(*PdfObjectInteger );
if !_dcec {_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_fadf );
return nil ,_fgf .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_cfge !=0&&*_cfge !=1{return nil ,_fgf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_fbdd .EarlyChange =int (*_cfge );}else {_fbdd .EarlyChange =1;};if _geab ==nil {return _fbdd ,nil ;};if _begf ,_ggfd :=GetIntVal (_geab .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_ggfd {if _begf ==0||_begf ==1{_fbdd .EarlyChange =_begf ;
}else {_ac .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_begf );};};_fadf =_geab .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _fadf !=nil {_fec ,_fdfe :=_fadf .(*PdfObjectInteger );if !_fdfe {_ac .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_fadf );
return nil ,_fgf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_fbdd .Predictor =int (*_fec );};_fadf =_geab .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _fadf !=nil {_aga ,_aacg :=_fadf .(*PdfObjectInteger );if !_aacg {_ac .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_fgf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_fbdd .BitsPerComponent =int (*_aga );};if _fbdd .Predictor > 1{_fbdd .Columns =1;_fadf =_geab .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _fadf !=nil {_fed ,_eada :=_fadf .(*PdfObjectInteger );if !_eada {return nil ,_fgf .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_fbdd .Columns =int (*_fed );
};_fbdd .Colors =1;_fadf =_geab .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _fadf !=nil {_gbag ,_ebc :=_fadf .(*PdfObjectInteger );if !_ebc {return nil ,_fgf .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_fbdd .Colors =int (*_gbag );};};_ac .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_geab .String ());return _fbdd ,nil ;};

// String returns a string describing `d`.
func (_fbddf *PdfObjectDictionary )String ()string {var _adfg _cd .Builder ;_adfg .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_afac :=range _fbddf ._gggg {_dgad :=_fbddf ._cedfc [_afac ];_adfg .WriteString ("\u0022"+_afac .String ()+"\u0022\u003a\u0020");
_adfg .WriteString (_dgad .String ());_adfg .WriteString ("\u002c\u0020");};_adfg .WriteString ("\u0029");return _adfg .String ();};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _afbf ,_bgdfa :=obj .(*PdfObjectReference );_bgdfa {obj =_afbf .Resolve ();};_cceec ,_bedc :=obj .(*PdfIndirectObject );_ebfe :=0;for _bedc {obj =_cceec .PdfObject ;_cceec ,_bedc =GetIndirect (obj );
_ebfe ++;if _ebfe > _edaec {_ac .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_edaec );
return nil ;};};return obj ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_cbcb bool ,_aefaf bool ){_dbeg ,_aefaf :=TraceToDirectObject (obj ).(*PdfObjectBool );if _aefaf {return bool (*_dbeg ),true ;};return false ,false ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_ebfb *PdfObjectBool ,_gegd bool ){_ebfb ,_gegd =TraceToDirectObject (obj ).(*PdfObjectBool );return _ebfb ,_gegd ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_aefg []PdfObject ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// WriteString outputs the object as it is to be written to file.
func (_gddf *PdfObjectString )WriteString ()string {var _ffefg _bb .Buffer ;if _gddf ._eedg {_bgcb :=_ea .EncodeToString (_gddf .Bytes ());_ffefg .WriteString ("\u003c");_ffefg .WriteString (_bgcb );_ffefg .WriteString ("\u003e");return _ffefg .String ();
};_fbbdg :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_ffefg .WriteString ("\u0028");for _aabd :=0;_aabd < len (_gddf ._agdge );
_aabd ++{_gfdaf :=_gddf ._agdge [_aabd ];if _eafa ,_fbecb :=_fbbdg [_gfdaf ];_fbecb {_ffefg .WriteString (_eafa );}else {_ffefg .WriteByte (_gfdaf );};};_ffefg .WriteString ("\u0029");return _ffefg .String ();};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_aeed *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aeed .DecodeBytes (streamObj .Stream );};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};func (_ffef *PdfCrypt )generateParams (_fcb ,_ebbc []byte )error {_aabc :=_ffef .securityHandler ();_bgfa ,_aca :=_aabc .GenerateParams (&_ffef ._ed ,_ebbc ,_fcb );
if _aca !=nil {return _aca ;};_ffef ._cffda =_bgfa ;return nil ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_agdge string ;_eedg bool ;};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_ddgg .Store (filterName ,customStreamEncoder );};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_edda *JBIG2Encoder )DecodeGlobals (encoded []byte )(_cf .Globals ,error ){return _cf .DecodeGlobals (encoded );};

// UpdateParams updates the parameter values of the encoder.
func (_facg *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_eff ,_caee :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _caee ==nil {_facg .Predictor =int (_eff );};_bee ,_caee :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _caee ==nil {_facg .BitsPerComponent =int (_bee );};_baga ,_caee :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _caee ==nil {_facg .Columns =int (_baga );};_ace ,_caee :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _caee ==nil {_facg .Colors =int (_ace );};};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_becd *PdfParser )Inspect ()(map[string ]int ,error ){return _becd .inspect ()};

// NewParserWithOpts creates and initializes a new PdfParser using the provided options.
// It creates a parser that tolerates certain non-critical PDF errors.
// Returns a PdfParser or an error if initialization fails.
func NewParserWithOpts (rs _cb .ReadSeeker ,opts ParserOpts )(*PdfParser ,error ){_abcb :=&PdfParser {_eebf :rs ,ObjCache :make (objectCache ),_bgdf :map[int64 ]bool {},_fccg :make ([]int64 ,0),_afab :make (map[*PdfParser ]*PdfParser ),Opts :&opts };_aeabf :=_abcb .initParser ();
if _aeabf !=nil {return nil ,_aeabf ;};return _abcb ,nil ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};const _cca ="\u0053\u0074\u0064C\u0046";

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {val =_fa .RoundDefault (val );_gccc :=PdfObjectFloat (val );return &_gccc ;};

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_cacfb *PdfParser )GetUpdatedObjects (prevParser *PdfParser )(map[int64 ]PdfObject ,error ){if prevParser ==nil {return nil ,_d .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_afaad ,_fcdba :=_cacfb .getNumbersOfUpdatedObjects (prevParser );if _fcdba !=nil {return nil ,_fcdba ;};_ggcfc :=make (map[int64 ]PdfObject );for _ ,_beecg :=range _afaad {if _ceae ,_ebbde :=_cacfb .LookupByNumber (_beecg );_ebbde ==nil {_ggcfc [int64 (_beecg )]=_ceae ;
}else {return nil ,_ebbde ;};};return _ggcfc ,nil ;};func _fbd (_dbfg XrefTable ){_ac .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_ac .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_dgcf :=0;for _ ,_cffd :=range _dbfg .ObjectMap {_ac .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_dgcf +1,_cffd .ObjectNumber ,_cffd .Generation ,_cffd .Offset );
_dgcf ++;};};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_edae *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_faaa ,_affg :=_df .NewDecoder (encoded ,_df .DecodeOptions {Columns :_edae .Columns ,Rows :_edae .Rows ,K :_edae .K ,EncodedByteAligned :_edae .EncodedByteAlign ,BlackIsOne :_edae .BlackIs1 ,EndOfBlock :_edae .EndOfBlock ,EndOfLine :_edae .EndOfLine ,DamagedRowsBeforeError :_edae .DamagedRowsBeforeError });
if _affg !=nil {return nil ,_affg ;};_daed ,_affg :=_cb .ReadAll (_faaa );if _affg !=nil {return nil ,_affg ;};return _daed ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_aegc *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_bffe :=MakeDict ();_bffe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_aegc .GetFilterArray ());for _ ,_daaa :=range _aegc ._abff {_bed :=_daaa .MakeStreamDict ();for _ ,_gbea :=range _bed .Keys (){_cdfe :=_bed .Get (_gbea );
if _gbea !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_gbea !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_bffe .Set (_gbea ,_cdfe );};};};_gfbb :=_aegc .MakeDecodeParams ();if _gfbb !=nil {_bffe .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gfbb );
};return _bffe ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_bddg :=&ASCII85Encoder {};return _bddg };

// HeaderCommentBytes gets the header comment bytes.
func (_bcbg ParserMetadata )HeaderCommentBytes ()[4]byte {return _bcbg ._ecg };

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_efcd *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _bcgb []float64 ;for _ ,_adge :=range _efcd .Elements (){_dcag ,_gedeb :=GetNumberAsFloat (TraceToDirectObject (_adge ));if _gedeb !=nil {return nil ,_fgf .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_bcgb =append (_bcgb ,_dcag );};return _bcgb ,nil ;};func (_cgad *PdfParser )parseDetailedHeader ()(_cfad error ){_cgad ._eebf .Seek (0,_cb .SeekStart );_cgad ._bgbab =_af .NewReader (_cgad ._eebf );_cbfd :=20;_fdcf :=make ([]byte ,_cbfd );var (_abbg bool ;
_bdce int ;);for {_gfef ,_fddf :=_cgad ._bgbab .ReadByte ();if _fddf !=nil {if _fddf ==_cb .EOF {break ;}else {return _fddf ;};};if IsDecimalDigit (_gfef )&&_fdcf [_cbfd -1]=='.'&&IsDecimalDigit (_fdcf [_cbfd -2])&&_fdcf [_cbfd -3]=='-'&&_fdcf [_cbfd -4]=='F'&&_fdcf [_cbfd -5]=='D'&&_fdcf [_cbfd -6]=='P'&&_fdcf [_cbfd -7]=='%'{_cgad ._bcdge =Version {Major :int (_fdcf [_cbfd -2]-'0'),Minor :int (_gfef -'0')};
_cgad ._daag ._aad =_bdce -7;_abbg =true ;break ;};_bdce ++;_fdcf =append (_fdcf [1:_cbfd ],_gfef );};if !_abbg {return _fgf .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_dbcc ,_cfad :=_cgad ._bgbab .ReadByte ();
if _cfad ==_cb .EOF {return _fgf .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _cfad !=nil {return _cfad ;};_cgad ._daag ._fbba =_dbcc =='\n';_dbcc ,_cfad =_cgad ._bgbab .ReadByte ();
if _cfad !=nil {return _fgf .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_cfad );};if _dbcc !='%'{return nil ;};_acag :=make ([]byte ,4);
_ ,_cfad =_cgad ._bgbab .Read (_acag );if _cfad !=nil {return _fgf .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_cfad );};_cgad ._daag ._ecg =[4]byte {_acag [0],_acag [1],_acag [2],_acag [3]};
return nil ;};func (_beage *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_beage ._bgbab )};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_dfef :=PdfObjectString {_agdge :s ,_eedg :true };return &_dfef ;};var _cead =_fg .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");const (_bef =0;_edca =1;_baaa =2;_cede =3;_abc =4;);

// GetXrefTable returns the PDFs xref table.
func (_dbgd *PdfParser )GetXrefTable ()XrefTable {return _dbgd ._adcd };

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_edgb :=&PdfObjectDictionary {};_edgb ._cedfc =map[PdfObjectName ]PdfObject {};_edgb ._gggg =[]PdfObjectName {};_edgb ._caefg =&_b .Mutex {};return _edgb ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_dbdb *PdfObjectArray ,_ddae bool ){_dbdb ,_ddae =TraceToDirectObject (obj ).(*PdfObjectArray );return _dbdb ,_ddae ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_ebgg *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_eedb :=n ;_cdgbf :=0;_acegc :=0;for _eedb > 0{_faag ,_ggccg :=_ebgg ._bgbab .Read (p [_cdgbf :]);if _ggccg !=nil {_ac .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_faag ,_acegc ,_ggccg .Error ());
return _cdgbf ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_acegc ++;_cdgbf +=_faag ;_eedb -=_faag ;};return _cdgbf ,nil ;};func _bcc (_gcaf *_gd .StdEncryptDict ,_cace *PdfObjectDictionary ){_cace .Set ("\u0052",MakeInteger (int64 (_gcaf .R )));
_cace .Set ("\u0050",MakeInteger (int64 (_gcaf .P )));_cace .Set ("\u004f",MakeStringFromBytes (_gcaf .O ));_cace .Set ("\u0055",MakeStringFromBytes (_gcaf .U ));if _gcaf .R >=5{_cace .Set ("\u004f\u0045",MakeStringFromBytes (_gcaf .OE ));_cace .Set ("\u0055\u0045",MakeStringFromBytes (_gcaf .UE ));
_cace .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_gcaf .EncryptMetadata ));if _gcaf .R > 5{_cace .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_gcaf .Perms ));};};};

// String returns a string describing `streams`.
func (_adbgb *PdfObjectStreams )String ()string {return _fgf .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_adbgb .ObjectNumber );};

// GetXrefType returns the type of the first xref object (table or stream).
func (_cccg *PdfParser )GetXrefType ()*xrefType {return _cccg ._aegca };

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_dccbbb *PdfParser )IsEncrypted ()(bool ,error ){if _dccbbb ._ccbg !=nil {return true ,nil ;}else if _dccbbb ._afbc ==nil {return false ,nil ;};_ac .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_edcg :=_dccbbb ._afbc .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _edcg ==nil {return false ,nil ;};_ac .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_eceg *PdfObjectDictionary ;);switch _adgd :=_edcg .(type ){case *PdfObjectDictionary :_eceg =_adgd ;
case *PdfObjectReference :_ac .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_adgd );_cegd ,_dfaba :=_dccbbb .LookupByReference (*_adgd );_ac .Log .Trace ("\u0031\u003a\u0020%\u0071",_cegd );
if _dfaba !=nil {return false ,_dfaba ;};_fdfg ,_eeafg :=_cegd .(*PdfIndirectObject );if !_eeafg {_ac .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_geca ,_eeafg :=_fdfg .PdfObject .(*PdfObjectDictionary );_dccbbb ._bccb =_fdfg ;_ac .Log .Trace ("\u0032\u003a\u0020%\u0071",_geca );if !_eeafg {return false ,_d .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
};_eceg =_geca ;case *PdfObjectNull :_ac .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_fgf .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_adgd );};_fcdab ,_cbfb :=PdfCryptNewDecrypt (_dccbbb ,_eceg ,_dccbbb ._afbc );if _cbfb !=nil {return false ,_cbfb ;
};for _ ,_ffad :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_bbge :=_dccbbb ._afbc .Get (PdfObjectName (_ffad ));if _bbge ==nil {continue ;};switch _bdfc :=_bbge .(type ){case *PdfObjectReference :_fcdab ._bbg [int (_bdfc .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_fcdab ._fbg [_bdfc ]=true ;_fcdab ._bbg [int (_bdfc .ObjectNumber )]=struct{}{};};};_dccbbb ._ccbg =_fcdab ;_ac .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_fcdab );
return true ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gcf *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// PdfVersion returns version of the PDF file.
func (_ggfeb *PdfParser )PdfVersion ()Version {return _ggfeb ._bcdge };

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_bbgcg *PdfObjectString )IsHexadecimal ()bool {return _bbgcg ._eedg };

// DecodeStream implements ASCII hex decoding.
func (_aacd *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aacd .DecodeBytes (streamObj .Stream );};func (_bcbac *PdfParser )repairLocateXref ()(int64 ,error ){_ggfce :=int64 (1000);_bcbac ._eebf .Seek (-_ggfce ,_cb .SeekCurrent );
_feff ,_afdd :=_bcbac ._eebf .Seek (0,_cb .SeekCurrent );if _afdd !=nil {return 0,_afdd ;};_egbbg :=make ([]byte ,_ggfce );_bcbac ._eebf .Read (_egbbg );_acbg :=_cbcf .FindAllStringIndex (string (_egbbg ),-1);if len (_acbg )< 1{_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");
return 0,_d .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_dffd :=int64 (_acbg [len (_acbg )-1][0]);_cdbc :=_feff +_dffd ;return _cdbc ,nil ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_begc *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_abbf :=PdfIndirectObject {};_abbf ._gafag =_begc ;_ac .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_edef ,_efaab :=_begc ._bgbab .Peek (20);
if _efaab !=nil {if _efaab !=_cb .EOF {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_abbf ,_efaab ;
};};_ac .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_edef ));_febg :=_abfbd .FindStringSubmatchIndex (string (_edef ));if len (_febg )< 6{if _efaab ==_cb .EOF {return nil ,_efaab ;
};_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_edef ));
return &_abbf ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_begc ._bgbab .Discard (_febg [0]);_ac .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_febg );_cfgb :=_febg [1]-_febg [0];_fcfa :=make ([]byte ,_cfgb );_ ,_efaab =_begc .ReadAtLeast (_fcfa ,_cfgb );if _efaab !=nil {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_efaab );
return nil ,_efaab ;};_ac .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fcfa );_gbba :=_abfbd .FindStringSubmatch (string (_fcfa ));if len (_gbba )< 3{_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_fcfa ));
return &_abbf ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_dabd ,_ :=_bc .Atoi (_gbba [1]);_dcece ,_ :=_bc .Atoi (_gbba [2]);_abbf .ObjectNumber =int64 (_dabd );_abbf .GenerationNumber =int64 (_dcece );for {_agdbd ,_bafb :=_begc ._bgbab .Peek (2);if _bafb !=nil {return &_abbf ,_bafb ;};_ac .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_agdbd ),string (_agdbd ));
if IsWhiteSpace (_agdbd [0]){_begc .skipSpaces ();}else if _agdbd [0]=='%'{_begc .skipComments ();}else if (_agdbd [0]=='<')&&(_agdbd [1]=='<'){_ac .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_abbf .PdfObject ,_bafb =_begc .ParseDict ();
_ac .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_bafb );if _bafb !=nil {return &_abbf ,_bafb ;};_ac .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_agdbd [0]=='/')||(_agdbd [0]=='(')||(_agdbd [0]=='[')||(_agdbd [0]=='<'){_abbf .PdfObject ,_bafb =_begc .parseObject ();if _bafb !=nil {return &_abbf ,_bafb ;};_ac .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _agdbd [0]==']'{_ac .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_begc ._bgbab .Discard (1);}else {if _agdbd [0]=='e'{_bgff ,_adga :=_begc .readTextLine ();if _adga !=nil {return nil ,_adga ;};if len (_bgff )>=6&&_bgff [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _agdbd [0]=='s'{_agdbd ,_ =_begc ._bgbab .Peek (10);
if string (_agdbd [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_cbcd :=6;if len (_agdbd )> 6{if IsWhiteSpace (_agdbd [_cbcd ])&&_agdbd [_cbcd ]!='\r'&&_agdbd [_cbcd ]!='\n'{_ac .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_begc ._daag ._eeg =true ;_cbcd ++;};if _agdbd [_cbcd ]=='\r'{_cbcd ++;if _agdbd [_cbcd ]=='\n'{_cbcd ++;};}else if _agdbd [_cbcd ]=='\n'{_cbcd ++;}else {_begc ._daag ._eeg =true ;};};_begc ._bgbab .Discard (_cbcd );_cedf ,_cebbd :=_abbf .PdfObject .(*PdfObjectDictionary );
if !_cebbd {return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_ac .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_cedf );
_fccgg ,_dgedc :=_begc .traceStreamLength (_cedf .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _dgedc !=nil {_ac .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_dgedc );
return nil ,_dgedc ;};_ac .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_fccgg );_dade ,_fgdf :=_fccgg .(*PdfObjectInteger );if !_fgdf {return nil ,_d .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_cdad :=*_dade ;if _cdad < 0{return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_aece :=_begc .GetFileOffset ();
_eded :=_begc .xrefNextObjectOffset (_aece );if _aece +int64 (_cdad )> _eded &&_eded > _aece {_ac .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_aece +int64 (_cdad ));_ac .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_eded );
_dbef :=_eded -_aece -17;if _dbef < 0{return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_ac .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_dbef );_cdad =PdfObjectInteger (_dbef );
_cedf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_dbef ));};if int64 (_cdad )> _begc ._fggb {_ac .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_cbga :=make ([]byte ,_cdad );
_ ,_dgedc =_begc .ReadAtLeast (_cbga ,int (_cdad ));if _dgedc !=nil {_ac .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_cbga ),_cbga );_ac .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dgedc );
return nil ,_dgedc ;};_bca :=PdfObjectStream {};_bca .Stream =_cbga ;_bca .PdfObjectDictionary =_abbf .PdfObject .(*PdfObjectDictionary );_bca .ObjectNumber =_abbf .ObjectNumber ;_bca .GenerationNumber =_abbf .GenerationNumber ;_bca .PdfObjectReference ._gafag =_begc ;
_begc .skipSpaces ();_begc ._bgbab .Discard (9);_begc .skipSpaces ();return &_bca ,nil ;};};_abbf .PdfObject ,_bafb =_begc .parseObject ();if _abbf .PdfObject ==nil {_ac .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_abbf .PdfObject =MakeNull ();};return &_abbf ,_bafb ;};};if _abbf .PdfObject ==nil {_ac .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_abbf .PdfObject =MakeNull ();};_ac .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_abbf ,nil ;};var _ddgg _b .Map ;

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_edf *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _edf .isEncrypted (obj ){return nil ;};switch _egcd :=obj .(type ){case *PdfIndirectObject :_edf ._fcg [_egcd ]=true ;_ac .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_egcd .ObjectNumber ,_egcd .GenerationNumber );
_gaf :=_egcd .ObjectNumber ;_aag :=_egcd .GenerationNumber ;_cbag :=_edf .Encrypt (_egcd .PdfObject ,_gaf ,_aag );if _cbag !=nil {return _cbag ;};return nil ;case *PdfObjectStream :_edf ._fcg [_egcd ]=true ;_gbd :=_egcd .PdfObjectDictionary ;if _cggb ,_fced :=_gbd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_fced &&*_cggb =="\u0058\u0052\u0065\u0066"{return nil ;};_cga :=_egcd .ObjectNumber ;_fbga :=_egcd .GenerationNumber ;_ac .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_cga ,_fbga );
_dbcg :=_cca ;if _edf ._gea .V >=4{_dbcg =_edf ._cgd ;_ac .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_edf ._cgd );if _daeg ,_gffe :=_gbd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_gffe {if _ffd ,_cfcg :=GetName (_daeg .Get (0));_cfcg {if *_ffd =="\u0043\u0072\u0079p\u0074"{_dbcg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _add ,_aggg :=_gbd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_aggg {if _bcb ,_gdc :=_add .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_gdc {if _ ,_egb :=_edf ._cdf [string (*_bcb )];_egb {_ac .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_bcb );
_dbcg =string (*_bcb );};};};};};};_ac .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dbcg );if _dbcg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bcg :=_edf .Encrypt (_egcd .PdfObjectDictionary ,_cga ,_fbga );
if _bcg !=nil {return _bcg ;};_cec ,_bcg :=_edf .makeKey (_dbcg ,uint32 (_cga ),uint32 (_fbga ),_edf ._cffda );if _bcg !=nil {return _bcg ;};_egcd .Stream ,_bcg =_edf .encryptBytes (_egcd .Stream ,_dbcg ,_cec );if _bcg !=nil {return _bcg ;};_gbd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_egcd .Stream ))));
return nil ;case *PdfObjectString :_ac .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_efc :=_cca ;if _edf ._gea .V >=4{_ac .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_edf ._gca );
if _edf ._gca =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_efc =_edf ._gca ;};_bbfe ,_ccb :=_edf .makeKey (_efc ,uint32 (parentObjNum ),uint32 (parentGenNum ),_edf ._cffda );if _ccb !=nil {return _ccb ;};_dcd :=_egcd .Str ();_fbe :=make ([]byte ,len (_dcd ));
for _bfae :=0;_bfae < len (_dcd );_bfae ++{_fbe [_bfae ]=_dcd [_bfae ];};_ac .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_fbe ,_fbe );_fbe ,_ccb =_edf .encryptBytes (_fbe ,_efc ,_bbfe );
if _ccb !=nil {return _ccb ;};_egcd ._agdge =string (_fbe );return nil ;case *PdfObjectArray :for _ ,_ceec :=range _egcd .Elements (){_adea :=_edf .Encrypt (_ceec ,parentObjNum ,parentGenNum );if _adea !=nil {return _adea ;};};return nil ;case *PdfObjectDictionary :_fffb :=false ;
if _ead :=_egcd .Get ("\u0054\u0079\u0070\u0065");_ead !=nil {_aaf ,_bagb :=_ead .(*PdfObjectName );if _bagb &&*_aaf =="\u0053\u0069\u0067"{_fffb =true ;};};for _ ,_ecdg :=range _egcd .Keys (){_cdfd :=_egcd .Get (_ecdg );if _fffb &&string (_ecdg )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;
};if string (_ecdg )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_ecdg )!="\u0050\u0072\u0065\u0076"&&string (_ecdg )!="\u004c\u0061\u0073\u0074"{_gafb :=_edf .Encrypt (_cdfd ,parentObjNum ,parentGenNum );if _gafb !=nil {return _gafb ;};};};return nil ;
};return nil ;};func (_gaae *offsetReader )Read (p []byte )(_ccfbc int ,_babd error ){return _gaae ._agfd .Read (p )};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _dbefa ,_bgbeg :=obj .(*PdfObjectReference );_bgbeg {return _dbefa .Resolve ();};return obj ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};type objectCache map[int ]PdfObject ;

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_dcaac *PdfObjectName ,_gfab bool ){_dcaac ,_gfab =TraceToDirectObject (obj ).(*PdfObjectName );return _dcaac ,_gfab ;};var _cadf =_fg .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");
func _cebbb (_gdda PdfObject ,_dgcbd int )PdfObject {if _dgcbd > _edaec {_ac .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_edaec );
return MakeNull ();};switch _cecd :=_gdda .(type ){case *PdfIndirectObject :_gdda =_cebbb ((*_cecd ).PdfObject ,_dgcbd +1);case *PdfObjectArray :for _fffee ,_ceegg :=range (*_cecd )._dcfc {(*_cecd )._dcfc [_fffee ]=_cebbb (_ceegg ,_dgcbd +1);};case *PdfObjectDictionary :for _bdeb ,_bege :=range (*_cecd )._cedfc {(*_cecd )._cedfc [_bdeb ]=_cebbb (_bege ,_dgcbd +1);
};_fc .Slice ((*_cecd )._gggg ,func (_facca ,_fgbge int )bool {return (*_cecd )._gggg [_facca ]< (*_cecd )._gggg [_fgbge ]});};return _gdda ;};func (_dbbg *PdfParser )parseName ()(PdfObjectName ,error ){var _ebeg _bb .Buffer ;_ccaaa :=false ;for {_ccfff ,_cgbfd :=_dbbg ._bgbab .Peek (1);
if _cgbfd ==_cb .EOF {break ;};if _cgbfd !=nil {return PdfObjectName (_ebeg .String ()),_cgbfd ;};if !_ccaaa {if _ccfff [0]=='/'{_ccaaa =true ;_dbbg ._bgbab .ReadByte ();}else if _ccfff [0]=='%'{_dbbg .readComment ();_dbbg .skipSpaces ();}else {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_ccfff ,_ccfff );
return PdfObjectName (_ebeg .String ()),_fgf .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_ccfff [0]);};}else {if IsWhiteSpace (_ccfff [0]){break ;}else if (_ccfff [0]=='/')||(_ccfff [0]=='[')||(_ccfff [0]=='(')||(_ccfff [0]==']')||(_ccfff [0]=='<')||(_ccfff [0]=='>'){break ;
}else if _ccfff [0]=='#'{_gccb ,_dgba :=_dbbg ._bgbab .Peek (3);if _dgba !=nil {return PdfObjectName (_ebeg .String ()),_dgba ;};_egcce ,_dgba :=_ea .DecodeString (string (_gccb [1:3]));if _dgba !=nil {_ac .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_ebeg .WriteByte ('#');_dbbg ._bgbab .Discard (1);continue ;};_dbbg ._bgbab .Discard (3);_ebeg .Write (_egcce );}else {_agec ,_ :=_dbbg ._bgbab .ReadByte ();_ebeg .WriteByte (_agec );};};};return PdfObjectName (_ebeg .String ()),nil ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_egfaa *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _dffa ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _gdbf :=_egfaa .AddPageImage (img ,&_egfaa .DefaultPageSettings );
_gdbf !=nil {return nil ,_eg .Wrap (_gdbf ,_dffa ,"");};return _egfaa .Encode ();};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};func (_cabd *PdfParser )parseXrefStream (_bbac *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _bbac !=nil {_ac .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_bbac );
_cabd ._eebf .Seek (int64 (*_bbac ),_cb .SeekStart );_cabd ._bgbab =_af .NewReader (_cabd ._eebf );};_gdecc :=_cabd .GetFileOffset ();_cfdec ,_gddd :=_cabd .ParseIndirectObject ();if _gddd !=nil {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_ac .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_cfdec );
_afef ,_eeec :=_cfdec .(*PdfObjectStream );if !_eeec {_ac .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_dagf :=_afef .PdfObjectDictionary ;
_abae ,_eeec :=_afef .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_eeec {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_d .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_abae )> 8388607{_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_abae );
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dfccf :=_afef .PdfObjectDictionary .Get ("\u0057");_gfedb ,_eeec :=_dfccf .(*PdfObjectArray );if !_eeec {return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_aeacg :=_gfedb .Len ();if _aeacg !=3{_ac .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_aeacg );
return nil ,_d .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _gdecg []int64 ;for _cdfc :=0;_cdfc < 3;
_cdfc ++{_fbee ,_bcff :=GetInt (_gfedb .Get (_cdfc ));if !_bcff {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_gdecg =append (_gdecg ,int64 (*_fbee ));};_bcgc ,_gddd :=DecodeStream (_afef );
if _gddd !=nil {_ac .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_gddd );return nil ,_gddd ;};_acedc :=int (_gdecg [0]);
_gedd :=int (_gdecg [0]+_gdecg [1]);_beab :=int (_gdecg [0]+_gdecg [1]+_gdecg [2]);_ccge :=int (_gdecg [0]+_gdecg [1]+_gdecg [2]);if _acedc < 0||_gedd < 0||_beab < 0{_ac .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_acedc ,_gedd ,_beab );
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _ccge ==0{_ac .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _dagf ,nil ;};_gcbdf :=len (_bcgc )/_ccge ;_cecg :=0;_daef :=_afef .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _cfdef []int ;if _daef !=nil {_ac .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_daef );_fdab ,_eccf :=_daef .(*PdfObjectArray );
if !_eccf {_ac .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_d .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _fdab .Len ()%2!=0{_ac .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cecg =0;_aae ,_fddb :=_fdab .ToIntegerArray ();if _fddb !=nil {_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_fddb );
return nil ,_fddb ;};for _cfag :=0;_cfag < len (_aae );_cfag +=2{_ggdg :=_aae [_cfag ];_baaf :=_aae [_cfag +1];for _beed :=0;_beed < _baaf ;_beed ++{_cfdef =append (_cfdef ,_ggdg +_beed );};_cecg +=_baaf ;};}else {for _fcdb :=0;_fcdb < int (*_abae );_fcdb ++{_cfdef =append (_cfdef ,_fcdb );
};_cecg =int (*_abae );};if _gcbdf ==_cecg +1{_ac .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_cdgg :=_cecg -1;for _ ,_baec :=range _cfdef {if _baec > _cdgg {_cdgg =_baec ;};};_cfdef =append (_cfdef ,_cdgg +1);_cecg ++;};if _gcbdf !=len (_cfdef ){_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_gcbdf ,len (_cfdef ));
return nil ,_d .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_ac .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_cecg );
_ac .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_cfdef );_cfed :=func (_beabc []byte )int64 {var _fabbg int64 ;for _fafcg :=0;_fafcg < len (_beabc );_fafcg ++{_fabbg +=int64 (_beabc [_fafcg ])*(1<<uint (8*(len (_beabc )-_fafcg -1)));
};return _fabbg ;};_ac .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_bcgc ));_fdfcg :=0;for _gccd :=0;_gccd < len (_bcgc );_gccd +=_ccge {_dcgec :=_gbgd (len (_bcgc ),_gccd ,_gccd +_acedc );
if _dcgec !=nil {_ac .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dcgec );return nil ,_dcgec ;};_dccbb :=_bcgc [_gccd :_gccd +_acedc ];_dcgec =_gbgd (len (_bcgc ),_gccd +_acedc ,_gccd +_gedd );
if _dcgec !=nil {_ac .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dcgec );return nil ,_dcgec ;};_defg :=_bcgc [_gccd +_acedc :_gccd +_gedd ];_dcgec =_gbgd (len (_bcgc ),_gccd +_gedd ,_gccd +_beab );
if _dcgec !=nil {_ac .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dcgec );return nil ,_dcgec ;};_dffag :=_bcgc [_gccd +_gedd :_gccd +_beab ];_gcff :=_cfed (_dccbb );
_adgg :=_cfed (_defg );_beeec :=_cfed (_dffag );if _gdecg [0]==0{_gcff =1;};if _fdfcg >=len (_cfdef ){_ac .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_caaa :=_cfdef [_fdfcg ];_fdfcg ++;_ac .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_caaa ,_dccbb );_ac .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_caaa ,_defg );_ac .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_caaa ,_dffag );
_ac .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_caaa ,_gcff ,_adgg ,_beeec );if _gcff ==0{_ac .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _gcff ==1{_ac .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_defg );if _adgg ==_gdecc {_ac .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_caaa ,_afef .ObjectNumber );
_caaa =int (_afef .ObjectNumber );};if _ceebg ,_dfca :=_cabd ._adcd .ObjectMap [_caaa ];!_dfca ||int (_beeec )> _ceebg .Generation {_fddg :=XrefObject {ObjectNumber :_caaa ,XType :XrefTypeTableEntry ,Offset :_adgg ,Generation :int (_beeec )};_cabd ._adcd .ObjectMap [_caaa ]=_fddg ;
};}else if _gcff ==2{_ac .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_bega :=_cabd ._adcd .ObjectMap [_caaa ];!_bega {_fgeg :=XrefObject {ObjectNumber :_caaa ,XType :XrefTypeObjectStream ,OsObjNumber :int (_adgg ),OsObjIndex :int (_beeec )};
_cabd ._adcd .ObjectMap [_caaa ]=_fgeg ;_ac .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_fgeg );};}else {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _cabd ._aegca ==nil {_adbg :=XrefTypeObjectStream ;_cabd ._aegca =&_adbg ;};return _dagf ,nil ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_deed *PdfParser )Decrypt (password []byte )(bool ,error ){if _deed ._ccbg ==nil {return false ,_d .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_dcddd ,_ggdf :=_deed ._ccbg .authenticate (password );
if _ggdf !=nil {return false ,_ggdf ;};if !_dcddd {_dcddd ,_ggdf =_deed ._ccbg .authenticate ([]byte (""));};return _dcddd ,_ggdf ;};func (_eedc *PdfParser )parseHexString ()(*PdfObjectString ,error ){_eedc ._bgbab .ReadByte ();var _eggf _bb .Buffer ;for {_ggfc ,_adbd :=_eedc ._bgbab .Peek (1);
if _adbd !=nil {return MakeString (""),_adbd ;};if _ggfc [0]=='>'{_eedc ._bgbab .ReadByte ();break ;};_gcbfa ,_ :=_eedc ._bgbab .ReadByte ();if _eedc ._gfdba {if _bb .IndexByte (_ggfg ,_gcbfa )==-1{_eedc ._daag ._ddc =true ;};};if !IsWhiteSpace (_gcbfa ){_eggf .WriteByte (_gcbfa );
};};if _eggf .Len ()%2==1{_eedc ._daag ._ggbb =true ;_eggf .WriteRune ('0');};_fdeg ,_ :=_ea .DecodeString (_eggf .String ());return MakeHexString (string (_fdeg )),nil ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_ecda *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ecda .DecodeBytes (streamObj .Stream );};

// Len returns the number of elements in the streams.
func (_bggg *PdfObjectStreams )Len ()int {if _bggg ==nil {return 0;};return len (_bggg ._aefg );};

// WriteString outputs the object as it is to be written to file.
func (_bbcb *PdfObjectBool )WriteString ()string {if *_bbcb {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ggfdc *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _aace []int64 ;for _ ,_fcca :=range _ggfdc .Elements (){if _gagb ,_acad :=_fcca .(*PdfObjectInteger );_acad {_aace =append (_aace ,int64 (*_gagb ));}else {return nil ,ErrTypeError ;};};
return _aace ,nil ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_dcfc []PdfObject };

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_aafb *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ac .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_ac .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_aafb .Predictor );
if _aafb .BitsPerComponent !=8{return nil ,_fgf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_aafb .BitsPerComponent );
};_bafc ,_dgge :=_aafb .DecodeBytes (streamObj .Stream );if _dgge !=nil {return nil ,_dgge ;};_bafc ,_dgge =_aafb .postDecodePredict (_bafc );if _dgge !=nil {return nil ,_dgge ;};return _bafc ,nil ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_cfd *PdfObjectDictionary );EncodeBytes (_gcb []byte )([]byte ,error );DecodeBytes (_agf []byte )([]byte ,error );DecodeStream (_gfgb *PdfObjectStream )([]byte ,error );
};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_gafag *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_dcgaf *JBIG2Image )ToGoImage ()(_c .Image ,error ){const _gdac ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _dcgaf .Data ==nil {return nil ,_eg .Error (_gdac ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _dcgaf .Width ==0||_dcgaf .Height ==0{return nil ,_eg .Error (_gdac ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_gdbe ,_bbbf :=_gg .NewImage (_dcgaf .Width ,_dcgaf .Height ,1,1,_dcgaf .Data ,nil ,nil );if _bbbf !=nil {return nil ,_bbbf ;};return _gdbe ,nil ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_ggg *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_dfd ,_aa :=obj .(*PdfObjectReference );if !_aa {return obj ,nil ;};_ag :=_ggg .GetFileOffset ();defer func (){_ggg .SetFileOffset (_ag )}();_cebe ,_cff :=_ggg .LookupByReference (*_dfd );
if _cff !=nil {return nil ,_cff ;};_da ,_bga :=_cebe .(*PdfIndirectObject );if !_bga {return _cebe ,nil ;};_cebe =_da .PdfObject ;_ ,_aa =_cebe .(*PdfObjectReference );if _aa {return _da ,_d .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _cebe ,nil ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_gaee *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_dbcgb :=MakeDict ();_dbcgb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gaee .GetFilterName ()));return _dbcgb ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_gbdd *JBIG2Encoder )EncodeImage (img _c .Image )([]byte ,error ){return _gbdd .encodeImage (img )};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_cdabf float64 ,_eebd bool ){_gaca ,_eebd :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _eebd {return float64 (*_gaca ),true ;};return 0,false ;};

// ParserOpts defines configuration options for Parser.
// These options allow setting customization flags to control parsing behaviors.
type ParserOpts struct{

// RelaxedMode enables tolerant parsing by ignoring certain non-critical PDF errors.
// When set to true, the parser will attempt to continue processing despite certain
// structural errors such as:
// - Missing or invalid /XRefStm entries
// - Non-/Page or non-/Pages objects found in the page tree (/Kids array)
RelaxedMode bool ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_efgc *PdfObjectReference )GetParser ()*PdfParser {return _efgc ._gafag };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_acdcc *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_fbdb :=_acdcc .GetFileOffset ();_ ,_acef :=_acdcc ._eebf .Seek (offset ,_cb .SeekStart );if _acef !=nil {return nil ,_acef ;};_deb :=make ([]byte ,len );_ ,_acef =_cb .ReadAtLeast (_acdcc ._eebf ,_deb ,int (len ));
if _acef !=nil {return nil ,_acef ;};_acdcc .SetFileOffset (_fbdb );return _deb ,nil ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_eccg :_ae .InitEncodeDocument (false )}};func _dgee (_eeaf uint ,_bafcf ,_eggeg float64 )float64 {_dcca :=_fa .RoundFloat ((float64 (_eeaf )/255.0),6);_cfadf :=_fa .RoundFloat ((_eggeg -_bafcf )*_dcca ,6);
return _fa .RoundFloat ((_bafcf +_cfadf )*255.0,6);};

// UpdateParams updates the parameter values of the encoder.
func (_eafd *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _feeg ,_daea :=GetNumberAsInt64 (params .Get ("\u004b"));_daea ==nil {_eafd .K =int (_feeg );};if _fcff ,_aba :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_aba ==nil {_eafd .Columns =int (_fcff );}else if _fcff ,_aba =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_aba ==nil {_eafd .Columns =int (_fcff );};if _caa ,_dccb :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_dccb ==nil {_eafd .BlackIs1 =_caa > 0;}else {if _aaac ,_bgaaa :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_bgaaa {_eafd .BlackIs1 =_aaac ;}else {if _ecdd ,_gdec :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_gdec {_gdf ,_gcd :=_ecdd .ToIntegerArray ();if _gcd ==nil {_eafd .BlackIs1 =_gdf [0]==1&&_gdf [1]==0;};};};};if _baac ,_affc :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_affc ==nil {_eafd .EncodedByteAlign =_baac > 0;
}else {if _fabg ,_gag :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gag {_eafd .EncodedByteAlign =_fabg ;};};if _dbfd ,_dgab :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_dgab ==nil {_eafd .EndOfLine =_dbfd > 0;}else {if _daf ,_dea :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_dea {_eafd .EndOfLine =_daf ;};};if _aced ,_dafg :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_dafg ==nil {_eafd .Rows =int (_aced );
}else if _aced ,_dafg =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_dafg ==nil {_eafd .Rows =int (_aced );};if _fecd ,_gfed :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gfed ==nil {_eafd .EndOfBlock =_fecd > 0;
}else {if _ffag ,_faged :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_faged {_eafd .EndOfBlock =_ffag ;};};if _bfaa ,_cgb :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_cgb !=nil {_eafd .DamagedRowsBeforeError =int (_bfaa );};};

// String returns a descriptive information string about the encryption method used.
func (_ddb *PdfCrypt )String ()string {if _ddb ==nil {return "";};_cdeb :=_ddb ._gea .Filter +"\u0020\u002d\u0020";if _ddb ._gea .V ==0{_cdeb +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _ddb ._gea .V ==1{_cdeb +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _ddb ._gea .V ==2{_cdeb +=_fgf .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_ddb ._gea .Length );}else if _ddb ._gea .V ==3{_cdeb +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _ddb ._gea .V >=4{_cdeb +=_fgf .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_ddb ._cgd ,_ddb ._gca );
_cdeb +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _bde ,_cgeb :=range _ddb ._cdf {_cdeb +=_fgf .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_bde ,_cgeb .Name (),_cgeb .KeyLength ());
};};_cfae :=_ddb .GetAccessPermissions ();_cdeb +=_fgf .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_cfae );return _cdeb ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
// renamed to String() as a pretty string to use in debugging etc.
func (_agagd *MultiEncoder )GetFilterName ()string {_efda :="";for _bfaaf ,_cced :=range _agagd ._abff {_efda +=_cced .GetFilterName ();if _bfaaf < len (_agagd ._abff )-1{_efda +="\u0020";};};return _efda ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_cafb *_gg .ImageBase ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_fged *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_dcfc :objects }};

// WriteString outputs the object as it is to be written to file.
func (_afgd *PdfObjectInteger )WriteString ()string {return _bc .FormatInt (int64 (*_afgd ),10)};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_gfbgf *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _ccfee []float64 ;for _ ,_gdba :=range _gfbgf .Elements (){switch _aagb :=_gdba .(type ){case *PdfObjectInteger :_ccfee =append (_ccfee ,float64 (*_aagb ));case *PdfObjectFloat :_ccfee =append (_ccfee ,float64 (*_aagb ));
default:return nil ,ErrTypeError ;};};return _ccfee ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gfbf *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetFilterName returns the name of the encoding filter.
func (_afb *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };func (_dbfc *PdfParser )seekToEOFMarker (_bafac int64 )error {var _eaea int64 ;var _beeg int64 =2048;for _eaea < _bafac -4{if _bafac <=(_beeg +_eaea ){_beeg =_bafac -_eaea ;
};_ ,_agdab :=_dbfc ._eebf .Seek (_bafac -_eaea -_beeg ,_cb .SeekStart );if _agdab !=nil {return _agdab ;};_afae :=make ([]byte ,_beeg );_dbfc ._eebf .Read (_afae );_ac .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_afae ));
_ceaf :=_cead .FindAllStringIndex (string (_afae ),-1);if _ceaf !=nil {_acba :=_ceaf [len (_ceaf )-1];_ac .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ceaf );_ffdg :=_bafac -_eaea -_beeg +int64 (_acba [0]);_dbfc ._eebf .Seek (_ffdg ,_cb .SeekStart );
return nil ;};_ac .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_eaea +=_beeg -4;};_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _efgd ;};func (_bdfd *PdfCrypt )saveCryptFilters (_bce *PdfObjectDictionary )error {if _bdfd ._gea .V < 4{return _d .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_dbg :=MakeDict ();_bce .Set ("\u0043\u0046",_dbg );for _bfd ,_gfb :=range _bdfd ._cdf {if _bfd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_ddd :=_eba (_gfb ,"");_dbg .Set (PdfObjectName (_bfd ),_ddd );};_bce .Set ("\u0053\u0074\u0072\u0046",MakeName (_bdfd ._gca ));
_bce .Set ("\u0053\u0074\u006d\u0046",MakeName (_bdfd ._cgd ));return nil ;};

// String returns a string describing `null`.
func (_gffb *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_edga *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_aad int ;_fbba bool ;_ecg [4]byte ;_edgc bool ;_ggbb bool ;_ddc bool ;_eeg bool ;_ccf bool ;_dbce bool ;};func (_dcaa *PdfParser )readTextLine ()(string ,error ){var _cgfg _bb .Buffer ;for {_cbea ,_bgccc :=_dcaa ._bgbab .Peek (1);
if _bgccc !=nil {_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_bgccc .Error ());return _cgfg .String (),_bgccc ;};if (_cbea [0]!='\r')&&(_cbea [0]!='\n'){_gegg ,_ :=_dcaa ._bgbab .ReadByte ();_cgfg .WriteByte (_gegg );}else {break ;
};};return _cgfg .String (),nil ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_egcdc :=PdfObjectName (s );return &_egcdc };

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_dcaf *PdfParser )GetPreviousRevisionParser ()(*PdfParser ,error ){if _dcaf ._bgafa ==0{return nil ,_d .New ("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e");};if _ecec ,_degg :=_dcaf ._afab [_dcaf ];
_degg {return _ecec ,nil ;};_gdfc ,_geed :=_dcaf .GetPreviousRevisionReadSeeker ();if _geed !=nil {return nil ,_geed ;};_eddae ,_geed :=NewParser (_gdfc );_eddae ._afab =_dcaf ._afab ;if _geed !=nil {return nil ,_geed ;};_dcaf ._afab [_dcaf ]=_eddae ;return _eddae ,nil ;
};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_gcefe *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _abcdg :=val .(type ){case *PdfObjectName :if _abcdg !=nil {_gcefe .Set (key ,val );};case *PdfObjectDictionary :if _abcdg !=nil {_gcefe .Set (key ,val );
};case *PdfObjectStream :if _abcdg !=nil {_gcefe .Set (key ,val );};case *PdfObjectString :if _abcdg !=nil {_gcefe .Set (key ,val );};case *PdfObjectNull :if _abcdg !=nil {_gcefe .Set (key ,val );};case *PdfObjectInteger :if _abcdg !=nil {_gcefe .Set (key ,val );
};case *PdfObjectArray :if _abcdg !=nil {_gcefe .Set (key ,val );};case *PdfObjectBool :if _abcdg !=nil {_gcefe .Set (key ,val );};case *PdfObjectFloat :if _abcdg !=nil {_gcefe .Set (key ,val );};case *PdfObjectReference :if _abcdg !=nil {_gcefe .Set (key ,val );
};case *PdfIndirectObject :if _abcdg !=nil {_gcefe .Set (key ,val );};default:_ac .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};func (_cfdc *limitedReadSeeker )getError (_dgfa int64 )error {switch {case _dgfa < 0:return _fgf .Errorf ("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064",_dgfa );
case _dgfa > _cfdc ._geea :return _fgf .Errorf ("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064",_dgfa );};return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gcee *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };const (DefaultJPEGQuality =75;);func (_dbbc *PdfParser )traceStreamLength (_abfcf PdfObject )(PdfObject ,error ){_gaefe ,_eeee :=_abfcf .(*PdfObjectReference );if _eeee {_bggc ,_defe :=_dbbc ._bgdf [_gaefe .ObjectNumber ];
if _defe &&_bggc {_ac .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_d .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_dbbc ._bgdf [_gaefe .ObjectNumber ]=true ;};_cdfcg ,_efed :=_dbbc .Resolve (_abfcf );if _efed !=nil {return nil ,_efed ;
};_ac .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_cdfcg );if _eeee {_dbbc ._bgdf [_gaefe .ObjectNumber ]=false ;};return _cdfcg ,nil ;};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_cdfeg *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_cdfeg ._caefg .Lock ();defer _cdfeg ._caefg .Unlock ();for _cdafb ,_efbb :=range objmap {_cdfeg .setWithLock (PdfObjectName (_cdafb ),_efbb ,false );};return _cdfeg ;
};

// Read implementation of Read interface.
func (_dceg *limitedReadSeeker )Read (p []byte )(_bgcc int ,_fdeeb error ){_agdg ,_fdeeb :=_dceg ._ecbb .Seek (0,_cb .SeekCurrent );if _fdeeb !=nil {return 0,_fdeeb ;};_gbfg :=_dceg ._geea -_agdg ;if _gbfg ==0{return 0,_cb .EOF ;};if _cffa :=int64 (len (p ));
_cffa < _gbfg {_gbfg =_cffa ;};_bcee :=make ([]byte ,_gbfg );_bgcc ,_fdeeb =_dceg ._ecbb .Read (_bcee );copy (p ,_bcee );return _bgcc ,_fdeeb ;};func _efcf (_feeb *PdfObjectStream ,_aded *PdfObjectDictionary )(*FlateEncoder ,error ){_fegc :=NewFlateEncoder ();
_fege :=_feeb .PdfObjectDictionary ;if _fege ==nil {return _fegc ,nil ;};_fegc ._cafb =_bccd (_fege );if _aded ==nil {_fbec :=TraceToDirectObject (_fege .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _feed :=_fbec .(type ){case *PdfObjectArray :if _feed .Len ()!=1{_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_feed .Len ());
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _dgca ,_fgfd :=GetDict (_feed .Get (0));_fgfd {_aded =_dgca ;};case *PdfObjectDictionary :_aded =_feed ;case *PdfObjectNull ,nil :default:_ac .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_fbec );
return nil ,_fgf .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _aded ==nil {return _fegc ,nil ;};_ac .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_aded .String ());
_bcbe :=_aded .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _bcbe ==nil {_ac .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_cccb ,_effa :=_bcbe .(*PdfObjectInteger );if !_effa {_ac .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_bcbe );
return nil ,_fgf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_fegc .Predictor =int (*_cccb );};_bcbe =_aded .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _bcbe !=nil {_cbaa ,_bfag :=_bcbe .(*PdfObjectInteger );if !_bfag {_ac .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_fgf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_fegc .BitsPerComponent =int (*_cbaa );if _fegc .BitsPerComponent !=_fegc ._cafb .BitsPerComponent {_ac .Log .Debug ("\u0057A\u0052\u004e\u0049\u004eG\u003a \u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006di\u0073\u006d\u0061\u0074\u0063\u0068\u0020\u0077\u0069\u0074\u0068 \u0069\u006d\u0061\u0067\u0065\u0020\u0028\u0025\u0064\u002f%\u0064\u0029\u002c\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020i\u006da\u0067\u0065",_fegc .BitsPerComponent ,_fegc ._cafb .BitsPerComponent );
_fegc .BitsPerComponent =_fegc ._cafb .BitsPerComponent ;};};if _fegc .Predictor > 1{_fegc .Columns =1;_bcbe =_aded .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _bcbe !=nil {_efd ,_gec :=_bcbe .(*PdfObjectInteger );if !_gec {return nil ,_fgf .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_fegc .Columns =int (*_efd );};_fegc .Colors =1;_bcbe =_aded .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _bcbe !=nil {_dba ,_edd :=_bcbe .(*PdfObjectInteger );if !_edd {return nil ,_fgf .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_fegc .Colors =int (*_dba );};};return _fegc ,nil ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;Lazy bool ;TempFile string ;};func _afd (_gfe *_aed .FilterDict ,_fbac *PdfObjectDictionary )error {if _aac ,_adc :=_fbac .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_adc {if _ccc :=string (*_aac );_ccc !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_ac .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_ccc );
};};_faca ,_ebb :=_fbac .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_ebb {return _fgf .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_gfe .CFM =string (*_faca );if _ggga ,_abg :=_fbac .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_abg {_gfe .AuthEvent =_gd .AuthEvent (*_ggga );}else {_gfe .AuthEvent =_gd .EventDocOpen ;};if _gge ,_egee :=_fbac .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_egee {_gfe .Length =int (*_gge );};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_bbae *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_gceg :=range _bbae ._abff {_gceg .UpdateParams (params );};};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_cfeb *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cfeb .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};const _gcfe =32<<(^uint (0)>>63);func _facd (_aebdf ,_dbdd PdfObject ,_fada int )bool {if _fada > _edaec {_ac .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_edaec );
return false ;};if _aebdf ==nil &&_dbdd ==nil {return true ;}else if _aebdf ==nil ||_dbdd ==nil {return false ;};if _gb .TypeOf (_aebdf )!=_gb .TypeOf (_dbdd ){return false ;};switch _ccfbeb :=_aebdf .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_ccfbeb ==*(_dbdd .(*PdfObjectName ));case *PdfObjectString :return *_ccfbeb ==*(_dbdd .(*PdfObjectString ));case *PdfObjectInteger :return *_ccfbeb ==*(_dbdd .(*PdfObjectInteger ));case *PdfObjectBool :return *_ccfbeb ==*(_dbdd .(*PdfObjectBool ));
case *PdfObjectFloat :return *_ccfbeb ==*(_dbdd .(*PdfObjectFloat ));case *PdfIndirectObject :return _facd (TraceToDirectObject (_aebdf ),TraceToDirectObject (_dbdd ),_fada +1);case *PdfObjectArray :_cgccbb :=_dbdd .(*PdfObjectArray );if len ((*_ccfbeb )._dcfc )!=len ((*_cgccbb )._dcfc ){return false ;
};for _deeda ,_gbcf :=range (*_ccfbeb )._dcfc {if !_facd (_gbcf ,(*_cgccbb )._dcfc [_deeda ],_fada +1){return false ;};};return true ;case *PdfObjectDictionary :_beedf :=_dbdd .(*PdfObjectDictionary );_egadb ,_fdbfc :=(*_ccfbeb )._cedfc ,(*_beedf )._cedfc ;
if len (_egadb )!=len (_fdbfc ){return false ;};for _cfecc ,_fcdg :=range _egadb {_cbcfd ,_cafbe :=_fdbfc [_cfecc ];if !_cafbe ||!_facd (_fcdg ,_cbcfd ,_fada +1){return false ;};};return true ;case *PdfObjectStream :_ccced :=_dbdd .(*PdfObjectStream );
return _facd ((*_ccfbeb ).PdfObjectDictionary ,(*_ccced ).PdfObjectDictionary ,_fada +1);default:_ac .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_aebdf );
};return false ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_fgd *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fgd .GetFilterName ());
return data ,ErrNoJPXDecode ;};func (_acc *PdfCrypt )encryptBytes (_fddaa []byte ,_cebca string ,_efb []byte )([]byte ,error ){_ac .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_cda ,_eedf :=_acc ._cdf [_cebca ];
if !_eedf {return nil ,_fgf .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cebca );};return _cda .EncryptBytes (_fddaa ,_efb );};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_efee *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _efee .Predictor !=1&&_efee .Predictor !=11{_ac .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _efee .Predictor ==11{_faed :=_efee .Columns ;_fcc :=len (data )/_faed ;if len (data )%_faed !=0{_ac .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_gfa :=_bb .NewBuffer (nil );_eeb :=make ([]byte ,_faed );for _cdda :=0;_cdda < _fcc ;_cdda ++{_bgbe :=data [_faed *_cdda :_faed *(_cdda +1)];
_eeb [0]=_bgbe [0];for _defa :=1;_defa < _faed ;_defa ++{_eeb [_defa ]=byte (int (_bgbe [_defa ]-_bgbe [_defa -1])%256);};_gfa .WriteByte (1);_gfa .Write (_eeb );};data =_gfa .Bytes ();};var _cffg _bb .Buffer ;_bcgg :=_cc .NewWriter (&_cffg );_bcgg .Write (data );
_bcgg .Close ();return _cffg .Bytes (),nil ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _aed .Filter ,userPass ,ownerPass []byte ,perm _gd .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_bfe :=&PdfCrypt {_fcg :make (map[PdfObject ]bool ),_cdf :make (cryptFilters ),_ed :_gd .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _dcge Version ;if cf !=nil {_bdc :=cf .PDFVersion ();_dcge .Major ,_dcge .Minor =_bdc [0],_bdc [1];V ,R :=cf .HandlerVersion ();_bfe ._gea .V =V ;_bfe ._ed .R =R ;_bfe ._gea .Length =cf .KeyLength ()*8;};const (_cba =_cca ;);_bfe ._cdf [_cba ]=cf ;
if _bfe ._gea .V >=4{_bfe ._cgd =_cba ;_bfe ._gca =_cba ;};_fbab :=_bfe .newEncryptDict ();_ffe :=_ad .Sum ([]byte (_a .Now ().Format (_a .RFC850 )));_cac :=string (_ffe [:]);_bfc :=make ([]byte ,100);_ff .Read (_bfc );_ffe =_ad .Sum (_bfc );_fdf :=string (_ffe [:]);
_ac .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_bfc );_ac .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_cac );_bfe ._bbf =_cac ;_bddd :=_bfe .generateParams (userPass ,ownerPass );
if _bddd !=nil {return nil ,nil ,_bddd ;};_bcc (&_bfe ._ed ,_fbab );if _bfe ._gea .V >=4{if _eaca :=_bfe .saveCryptFilters (_fbab );_eaca !=nil {return nil ,nil ,_eaca ;};};return _bfe ,&EncryptInfo {Version :_dcge ,Encrypt :_fbab ,ID0 :_cac ,ID1 :_fdf },nil ;
};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_gefa :=&DCTEncoder {};_gefa .ColorComponents =3;_gefa .BitsPerComponent =8;_gefa .Quality =DefaultJPEGQuality ;_gefa .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};return _gefa ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_feg *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_fac ,_ ,_egc :=_feg .lookupByNumberWrapper (objNumber ,true );return _fac ,_egc ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_fgdd *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ffcdb :=encoded ;var _gaef error ;for _ ,_edcc :=range _fgdd ._abff {_ac .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_edcc ,_edcc );
_ffcdb ,_gaef =_edcc .DecodeBytes (_ffcdb );if _gaef !=nil {return nil ,_gaef ;};};return _ffcdb ,nil ;};func _eef (_aeg int )cryptFilters {return cryptFilters {_cca :_aed .NewFilterV2 (_aeg )}};func (_dfge *PdfParser )parseLinearizedDictionary ()(*PdfObjectDictionary ,error ){_debc ,_baeca :=_dfge ._eebf .Seek (0,_cb .SeekEnd );
if _baeca !=nil {return nil ,_baeca ;};var _ebec int64 ;var _agdfd int64 =2048;for _ebec < _debc -4{if _debc <=(_agdfd +_ebec ){_agdfd =_debc -_ebec ;};_ ,_gcafd :=_dfge ._eebf .Seek (_ebec ,_cb .SeekStart );if _gcafd !=nil {return nil ,_gcafd ;};_fgab :=make ([]byte ,_agdfd );
_ ,_gcafd =_dfge ._eebf .Read (_fgab );if _gcafd !=nil {return nil ,_gcafd ;};_ac .Log .Trace ("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022",string (_fgab ));
_egbb :=_abfbd .FindAllStringIndex (string (_fgab ),-1);if _egbb !=nil {_cebff :=_egbb [0];_ac .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_egbb );_ ,_eeae :=_dfge ._eebf .Seek (int64 (_cebff [0]),_cb .SeekStart );if _eeae !=nil {return nil ,_eeae ;
};_dfge ._bgbab =_af .NewReader (_dfge ._eebf );_gadf ,_eeae :=_dfge .ParseIndirectObject ();if _eeae !=nil {return nil ,nil ;};if _agfda ,_gcea :=GetIndirect (_gadf );_gcea {if _beagf ,_bgaeb :=GetDict (_agfda .PdfObject );_bgaeb {if _cdge :=_beagf .Get ("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064");
_cdge !=nil {return _beagf ,nil ;};return nil ,nil ;};};return nil ,nil ;};_ebec +=_agdfd -4;};return nil ,_d .New ("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064");
};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_ffgb *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _fgb _gg .Gray ;switch len (data ){case _ffgb .Rows *_ffgb .Columns :_ffcde ,_fdccg :=_gg .NewImage (_ffgb .Columns ,_ffgb .Rows ,8,1,data ,nil ,nil );if _fdccg !=nil {return nil ,_fdccg ;
};_fgb =_ffcde .(_gg .Gray );case (_ffgb .Columns *_ffgb .Rows )+7>>3:_dfedb ,_edfa :=_gg .NewImage (_ffgb .Columns ,_ffgb .Rows ,1,1,data ,nil ,nil );if _edfa !=nil {return nil ,_edfa ;};_ffbba :=_dfedb .(*_gg .Monochrome );if _edfa =_ffbba .AddPadding ();
_edfa !=nil {return nil ,_edfa ;};_fgb =_ffbba ;default:if len (data )< _gg .BytesPerLine (_ffgb .Columns ,1,1)*_ffgb .Rows {return nil ,_d .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_gcbb ,_ffba :=_gg .NewImage (_ffgb .Columns ,_ffgb .Rows ,1,1,data ,nil ,nil );if _ffba !=nil {return nil ,_ffba ;};_bad :=_gcbb .(*_gg .Monochrome );_fgb =_bad ;};_gdae :=make ([][]byte ,_ffgb .Rows );for _gffc :=0;_gffc < _ffgb .Rows ;_gffc ++{_ceda :=make ([]byte ,_ffgb .Columns );
for _bacb :=0;_bacb < _ffgb .Columns ;_bacb ++{_edff :=_fgb .GrayAt (_bacb ,_gffc );_ceda [_bacb ]=_edff .Y >>7;};_gdae [_gffc ]=_ceda ;};_cedc :=&_df .Encoder {K :_ffgb .K ,Columns :_ffgb .Columns ,EndOfLine :_ffgb .EndOfLine ,EndOfBlock :_ffgb .EndOfBlock ,BlackIs1 :_ffgb .BlackIs1 ,DamagedRowsBeforeError :_ffgb .DamagedRowsBeforeError ,Rows :_ffgb .Rows ,EncodedByteAlign :_ffgb .EncodedByteAlign };
return _cedc .Encode (_gdae ),nil ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_adbf *PdfIndirectObject ,_cgcca bool ){obj =ResolveReference (obj );_adbf ,_cgcca =obj .(*PdfIndirectObject );return _adbf ,_cgcca ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_fgag *PdfParser )IsAuthenticated ()bool {return _fgag ._ccbg ._gba };

// String returns a string representation of `name`.
func (_fgeb *PdfObjectName )String ()string {return string (*_fgeb )};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_gebed *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_acgfc :=_bb .NewReader (data );var _aeb []byte ;var _fadfg []byte ;_feee ,_faea :=_acgfc .ReadByte ();if _faea ==_cb .EOF {return []byte {},nil ;}else if _faea !=nil {return nil ,_faea ;
};_cefg :=1;for {_afde ,_aceg :=_acgfc .ReadByte ();if _aceg ==_cb .EOF {break ;}else if _aceg !=nil {return nil ,_aceg ;};if _afde ==_feee {if len (_fadfg )> 0{_fadfg =_fadfg [:len (_fadfg )-1];if len (_fadfg )> 0{_aeb =append (_aeb ,byte (len (_fadfg )-1));
_aeb =append (_aeb ,_fadfg ...);};_cefg =1;_fadfg =[]byte {};};_cefg ++;if _cefg >=127{_aeb =append (_aeb ,byte (257-_cefg ),_feee );_cefg =0;};}else {if _cefg > 0{if _cefg ==1{_fadfg =[]byte {_feee };}else {_aeb =append (_aeb ,byte (257-_cefg ),_feee );
};_cefg =0;};_fadfg =append (_fadfg ,_afde );if len (_fadfg )>=127{_aeb =append (_aeb ,byte (len (_fadfg )-1));_aeb =append (_aeb ,_fadfg ...);_fadfg =[]byte {};};};_feee =_afde ;};if len (_fadfg )> 0{_aeb =append (_aeb ,byte (len (_fadfg )-1));_aeb =append (_aeb ,_fadfg ...);
}else if _cefg > 0{_aeb =append (_aeb ,byte (257-_cefg ),_feee );};_aeb =append (_aeb ,128);return _aeb ,nil ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// GetFilterName returns the name of the encoding filter.
func (_cafg *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_def *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ac .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_efbe :=_bb .NewReader (encoded );_facc ,_cdc :=_cc .NewReader (_efbe );if _cdc !=nil {_ac .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_cdc );_ac .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_cdc ;};defer _facc .Close ();var _egf _bb .Buffer ;_egf .ReadFrom (_facc );return _egf .Bytes (),nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_fbece :=PdfObjectString {_agdge :s };return &_fbece };

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_cgf :=&ASCIIHexEncoder {};return _cgf };

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_afbd *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_ecegf :=range another .Keys (){_ffbg :=another .Get (_ecegf );_afbd .Set (_ecegf ,_ffbg );};};return _afbd ;};func (_cggf *PdfCrypt )isEncrypted (_fcda PdfObject )bool {_ ,_ade :=_cggf ._fcg [_fcda ];
if _ade {_ac .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_ac .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _gcbdc _bb .Buffer ;_gcbdc .Write ([]byte {0xFE,0xFF});_gcbdc .WriteString (_acg .StringToUTF16 (s ));return &PdfObjectString {_agdge :_gcbdc .String (),_eedg :true };};return &PdfObjectString {_agdge :string (_acg .StringToPDFDocEncoding (s )),_eedg :false };
};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_cfbc *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _cfbc .Predictor !=1{return nil ,_fgf .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _cfbc .EarlyChange ==1{return nil ,_fgf .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _fddd _bb .Buffer ;_fadff :=_ec .NewWriter (&_fddd ,_ec .MSB ,8);_fadff .Write (data );_fadff .Close ();return _fddd .Bytes (),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_efa *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };func (_aafg *PdfParser )repairSeekXrefMarker ()error {_adef ,_ebega :=_aafg ._eebf .Seek (0,_cb .SeekEnd );if _ebega !=nil {return _ebega ;};_cdfb :=_fg .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");
var _aabdc int64 ;var _cddcg int64 =1000;for _aabdc < _adef {if _adef <=(_cddcg +_aabdc ){_cddcg =_adef -_aabdc ;};_ ,_gccbd :=_aafg ._eebf .Seek (-_aabdc -_cddcg ,_cb .SeekEnd );if _gccbd !=nil {return _gccbd ;};_egfd :=make ([]byte ,_cddcg );_aafg ._eebf .Read (_egfd );
_ac .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_egfd ));_dbbef :=_cdfb .FindAllStringIndex (string (_egfd ),-1);if _dbbef !=nil {_abaf :=_dbbef [len (_dbbef )-1];
_ac .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_dbbef );_aafg ._eebf .Seek (-_aabdc -_cddcg +int64 (_abaf [0]),_cb .SeekEnd );_aafg ._bgbab =_af .NewReader (_aafg ._eebf );for {_bfec ,_cfgd :=_aafg ._bgbab .Peek (1);if _cfgd !=nil {return _cfgd ;
};_ac .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_bfec [0],_bfec [0]);if !IsWhiteSpace (_bfec [0]){break ;};_aafg ._bgbab .Discard (1);};return nil ;};_ac .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_aabdc +=_cddcg ;};_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _d .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gfdd *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_afeb :=MakeDict ();_afeb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gfdd .GetFilterName ()));return _afeb ;};const _dab =6;

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_cfbbe :=PdfObjectNull {};return &_cfbbe };

// Clear resets the array to an empty state.
func (_eeef *PdfObjectArray )Clear (){_eeef ._dcfc =[]PdfObject {}};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_gcgd *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_dffc :=data ;var _fdcff error ;for _ecbe :=len (_gcgd ._abff )-1;_ecbe >=0;_ecbe --{_eega :=_gcgd ._abff [_ecbe ];_dffc ,_fdcff =_eega .EncodeBytes (_dffc );if _fdcff !=nil {return nil ,_fdcff ;
};};return _dffc ,nil ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_bfge *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_agag :=_bb .NewReader (encoded );var _dee []byte ;for {_cffc ,_bffa :=_agag .ReadByte ();if _bffa !=nil {return nil ,_bffa ;};if _cffc =='>'{break ;};if IsWhiteSpace (_cffc ){continue ;
};if (_cffc >='a'&&_cffc <='f')||(_cffc >='A'&&_cffc <='F')||(_cffc >='0'&&_cffc <='9'){_dee =append (_dee ,_cffc );}else {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_cffc );
return nil ,_fgf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_cffc );};};if len (_dee )%2==1{_dee =append (_dee ,'0');
};_ac .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_dee );_gfdb :=make ([]byte ,_ea .DecodedLen (len (_dee )));_ ,_effce :=_ea .Decode (_gfdb ,_dee );if _effce !=nil {return nil ,_effce ;};return _gfdb ,nil ;};func (_faef *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_faef ._adcd .ObjectMap =make (map[int ]XrefObject );
_faef ._fdfa =make (objectStreams );_ecff ,_agba :=_faef ._eebf .Seek (0,_cb .SeekEnd );if _agba !=nil {return nil ,_agba ;};_ac .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_ecff );_faef ._fggb =_ecff ;_agba =_faef .seekToEOFMarker (_ecff );
if _agba !=nil {_ac .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_agba );return nil ,_agba ;};_ggde ,_agba :=_faef ._eebf .Seek (0,_cb .SeekCurrent );
if _agba !=nil {return nil ,_agba ;};var _babf int64 =64;_bacdd :=_ggde -_babf ;if _bacdd < 0{_bacdd =0;};_ ,_agba =_faef ._eebf .Seek (_bacdd ,_cb .SeekStart );if _agba !=nil {return nil ,_agba ;};_ecea :=make ([]byte ,_babf );_ ,_agba =_faef ._eebf .Read (_ecea );
if _agba !=nil {_ac .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_agba );
return nil ,_agba ;};_cddcc :=_cdde .FindStringSubmatch (string (_ecea ));if len (_cddcc )< 2{_ac .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");
return nil ,_d .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_cddcc )> 2{_ac .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_ecea );
return nil ,_d .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_gdca ,_ :=_bc .ParseInt (_cddcc [1],10,64);_ac .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_gdca );
if _gdca > _ecff {_ac .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_ac .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");
_gdca ,_agba =_faef .repairLocateXref ();if _agba !=nil {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_agba ;};};_faef ._eebf .Seek (_gdca ,_cb .SeekStart );_faef ._bgbab =_af .NewReader (_faef ._eebf );_aeaf ,_agba :=_faef .parseXref ();if _agba !=nil {return nil ,_agba ;};_edde :=_aeaf .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _edde !=nil {_gdfg ,_ecdf :=_edde .(*PdfObjectInteger );
if !_ecdf {return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_agba =_faef .parseXrefStream (_gdfg );if _agba !=nil &&_faef .Opts !=nil &&!_faef .Opts .RelaxedMode {return nil ,_agba ;};};var _ggbe []int64 ;
_gbbgc :=func (_cdeae int64 ,_daca []int64 )bool {for _ ,_gefg :=range _daca {if _gefg ==_cdeae {return true ;};};return false ;};_edde =_aeaf .Get ("\u0050\u0072\u0065\u0076");for _edde !=nil {_babc ,_afedb :=_edde .(*PdfObjectInteger );if !_afedb {_ac .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_edde );
return _aeaf ,nil ;};_dfgg :=*_babc ;_ac .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_dfgg );_faef ._eebf .Seek (int64 (_dfgg ),_cb .SeekStart );
_faef ._bgbab =_af .NewReader (_faef ._eebf );_feeea ,_acda :=_faef .parseXref ();if _acda !=nil {_ac .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_ac .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_faef ._fccg =append (_faef ._fccg ,int64 (_dfgg ));
_edde =_feeea .Get ("\u0050\u0072\u0065\u0076");if _edde !=nil {_ceba :=*(_edde .(*PdfObjectInteger ));if _gbbgc (int64 (_ceba ),_ggbe ){_ac .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_ggbe =append (_ggbe ,int64 (_ceba ));};};return _aeaf ,nil ;};func _ffa (_cbf *_gd .StdEncryptDict ,_cgda *PdfObjectDictionary )error {R ,_gfff :=_cgda .Get ("\u0052").(*PdfObjectInteger );if !_gfff {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");
};if *R < 2||*R > 6{return _fgf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_cbf .R =int (*R );O ,_gfff :=_cgda .GetString ("\u004f");if !_gfff {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");
};if _cbf .R ==5||_cbf .R ==6{if len (O )< 48{return _fgf .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _fgf .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));
};_cbf .O =[]byte (O );U ,_gfff :=_cgda .GetString ("\u0055");if !_gfff {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _cbf .R ==5||_cbf .R ==6{if len (U )< 48{return _fgf .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));
};}else if len (U )!=32{_ac .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_cbf .U =[]byte (U );if _cbf .R >=5{OE ,_fgg :=_cgda .GetString ("\u004f\u0045");
if !_fgg {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _fgf .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));
};_cbf .OE =[]byte (OE );UE ,_fgg :=_cgda .GetString ("\u0055\u0045");if !_fgg {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _fgf .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_cbf .UE =[]byte (UE );};P ,_gfff :=_cgda .Get ("\u0050").(*PdfObjectInteger );if !_gfff {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_cbf .P =_gd .Permissions (*P );if _cbf .R ==6{Perms ,_bgae :=_cgda .GetString ("\u0050\u0065\u0072m\u0073");if !_bgae {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _fgf .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_cbf .Perms =[]byte (Perms );};if _ffg ,_ab :=_cgda .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_ab {_cbf .EncryptMetadata =bool (*_ffg );}else {_cbf .EncryptMetadata =true ;};return nil ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_fef *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_ac .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_daagg :=MakeDict ();_daagg ._cdce =_fef ;_gbc ,_ :=_fef ._bgbab .ReadByte ();
if _gbc !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_gbc ,_ =_fef ._bgbab .ReadByte ();if _gbc !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_fef .skipSpaces ();
_fef .skipComments ();_cacf ,_degd :=_fef ._bgbab .Peek (2);if _degd !=nil {return nil ,_degd ;};_ac .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_cacf ),string (_cacf ));if (_cacf [0]=='>')&&(_cacf [1]=='>'){_ac .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
_fef ._bgbab .ReadByte ();_fef ._bgbab .ReadByte ();break ;};_ac .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_aaff ,_degd :=_fef .parseName ();_ac .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_aaff );
if _degd !=nil {_ac .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_degd );return nil ,_degd ;};if len (_aaff )> 4&&_aaff [len (_aaff )-4:]=="\u006e\u0075\u006c\u006c"{_dfbff :=_aaff [0:len (_aaff )-4];
_ac .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_aaff );_ac .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_dfbff );
_fef .skipSpaces ();_bdgc ,_ :=_fef ._bgbab .Peek (1);if _bdgc [0]=='/'{_daagg .Set (_dfbff ,MakeNull ());continue ;};};_fef .skipSpaces ();_gceb ,_degd :=_fef .parseObject ();if _degd !=nil {return nil ,_degd ;};_daagg .Set (_aaff ,_gceb );if _ac .Log .IsLogLevel (_ac .LogLevelTrace ){_ac .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_aaff ,_gceb .String ());
};};_ac .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _daagg ,nil ;};func _eee (_ddde *PdfObjectStream ,_cafd *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;
};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_fgcc *PdfObjectStreams )Elements ()[]PdfObject {if _fgcc ==nil {return nil ;};return _fgcc ._aefg ;};

// HeaderPosition gets the file header position.
func (_dgd ParserMetadata )HeaderPosition ()int {return _dgd ._aad };

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_fbf *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _fbf .isDecrypted (obj ){return nil ;};switch _fcd :=obj .(type ){case *PdfIndirectObject :_fbf ._fbg [_fcd ]=true ;_ac .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fcd .ObjectNumber ,_fcd .GenerationNumber );
_ddgb :=_fcd .ObjectNumber ;_bab :=_fcd .GenerationNumber ;_cebc :=_fbf .Decrypt (_fcd .PdfObject ,_ddgb ,_bab );if _cebc !=nil {return _cebc ;};return nil ;case *PdfObjectStream :_fbf ._fbg [_fcd ]=true ;_adb :=_fcd .PdfObjectDictionary ;if _fbf ._ed .R !=5{if _gbb ,_bag :=_adb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_bag &&*_gbb =="\u0058\u0052\u0065\u0066"{return nil ;};};_egd :=_fcd .ObjectNumber ;_dcc :=_fcd .GenerationNumber ;_ac .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_egd ,_dcc );
_ecd :=_cca ;if _fbf ._gea .V >=4{_ecd =_fbf ._cgd ;_ac .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_fbf ._cgd );if _afce ,_bgfb :=_adb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_bgfb {if _dgcb ,_dgef :=GetName (_afce .Get (0));_dgef {if *_dgcb =="\u0043\u0072\u0079p\u0074"{_ecd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gef ,_fbfd :=_adb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_fbfd {if _beb ,_baa :=_gef .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_baa {if _ ,_baag :=_fbf ._cdf [string (*_beb )];_baag {_ac .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_beb );
_ecd =string (*_beb );};};};};};};_ac .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_ecd );if _ecd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_fbfb :=_fbf .Decrypt (_adb ,_egd ,_dcc );
if _fbfb !=nil {return _fbfb ;};_ged ,_fbfb :=_fbf .makeKey (_ecd ,uint32 (_egd ),uint32 (_dcc ),_fbf ._cffda );if _fbfb !=nil {return _fbfb ;};_fcd .Stream ,_fbfb =_fbf .decryptBytes (_fcd .Stream ,_ecd ,_ged );if _fbfb !=nil {return _fbfb ;};_adb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fcd .Stream ))));
return nil ;case *PdfObjectString :_ac .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gfeg :=_cca ;if _fbf ._gea .V >=4{_ac .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fbf ._gca );
if _fbf ._gca =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gfeg =_fbf ._gca ;};_cef ,_bbd :=_fbf .makeKey (_gfeg ,uint32 (parentObjNum ),uint32 (parentGenNum ),_fbf ._cffda );if _bbd !=nil {return _bbd ;};_faa :=_fcd .Str ();_fdc :=make ([]byte ,len (_faa ));
for _bbeb :=0;_bbeb < len (_faa );_bbeb ++{_fdc [_bbeb ]=_faa [_bbeb ];};if len (_fdc )> 0{_ac .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_fdc ,_fdc );
_fdc ,_bbd =_fbf .decryptBytes (_fdc ,_gfeg ,_cef );if _bbd !=nil {return _bbd ;};};_fcd ._agdge =string (_fdc );return nil ;case *PdfObjectArray :for _ ,_cefd :=range _fcd .Elements (){_ef :=_fbf .Decrypt (_cefd ,parentObjNum ,parentGenNum );if _ef !=nil {return _ef ;
};};return nil ;case *PdfObjectDictionary :_bgg :=false ;if _eafe :=_fcd .Get ("\u0054\u0079\u0070\u0065");_eafe !=nil {_fae ,_baf :=_eafe .(*PdfObjectName );if _baf &&*_fae =="\u0053\u0069\u0067"{_bgg =true ;};};for _ ,_dbc :=range _fcd .Keys (){_eaeb :=_fcd .Get (_dbc );
if _bgg &&string (_dbc )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_dbc )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_dbc )!="\u0050\u0072\u0065\u0076"&&string (_dbc )!="\u004c\u0061\u0073\u0074"{_adba :=_fbf .Decrypt (_eaeb ,parentObjNum ,parentGenNum );
if _adba !=nil {return _adba ;};};};return nil ;};return nil ;};var _efgd =_d .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_bdbb :=&PdfIndirectObject {};_bdbb .PdfObject =obj ;return _bdbb ;};var (ErrUnsupportedEncodingParameters =_d .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");
ErrNoCCITTFaxDecode =_d .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_d .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_d .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_fge .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_d .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_aabca :=MakeDict ();return _aabca .Update (objmap );};func (_gccf *PdfParser )parsePdfVersion ()(int ,int ,error ){var _eggg int64 =20;_dbca :=make ([]byte ,_eggg );_gccf ._eebf .Seek (0,_cb .SeekStart );
_gccf ._eebf .Read (_dbca );var _fccd error ;var _daaae ,_bdeg int ;if _cfea :=_gbbg .FindStringSubmatch (string (_dbca ));len (_cfea )< 3{if _daaae ,_bdeg ,_fccd =_gccf .seekPdfVersionTopDown ();_fccd !=nil {_ac .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_fccd ;};_gccf ._eebf ,_fccd =_afff (_gccf ._eebf ,_gccf .GetFileOffset ()-8);if _fccd !=nil {return 0,0,_fccd ;};}else {if _daaae ,_fccd =_bc .Atoi (_cfea [1]);_fccd !=nil {return 0,0,_fccd ;};if _bdeg ,_fccd =_bc .Atoi (_cfea [2]);_fccd !=nil {return 0,0,_fccd ;
};_gccf .SetFileOffset (0);};_gccf ._bgbab =_af .NewReader (_gccf ._eebf );_ac .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_daaae ,_bdeg );return _daaae ,_bdeg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bbgc *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_bbgc ._abff )==0{return nil ;};if len (_bbgc ._abff )==1{return _bbgc ._abff [0].MakeDecodeParams ();};_fcfg :=MakeArray ();_efg :=true ;for _ ,_ggff :=range _bbgc ._abff {_acfe :=_ggff .MakeDecodeParams ();
if _acfe ==nil {_fcfg .Append (MakeNull ());}else {_efg =false ;_fcfg .Append (_acfe );};};if _efg {return nil ;};return _fcfg ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_cedfc map[PdfObjectName ]PdfObject ;_gggg []PdfObjectName ;_caefg *_b .Mutex ;_cdce *PdfParser ;};func (_ceeb *PdfParser )checkPostEOFData ()error {const _aabb ="\u0025\u0025\u0045O\u0046";_ ,_cae :=_ceeb ._eebf .Seek (-int64 (len ([]byte (_aabb )))-1,_cb .SeekEnd );
if _cae !=nil {return _cae ;};_egdd :=make ([]byte ,len ([]byte (_aabb ))+1);_ ,_cae =_ceeb ._eebf .Read (_egdd );if _cae !=nil {if _cae !=_cb .EOF {return _cae ;};};if string (_egdd )==_aabb ||string (_egdd )==_aabb +"\u000a"{_ceeb ._daag ._edgc =true ;
};return nil ;};func (_bade *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _ccfad *PdfObjectDictionary ;_bffc ,_eabec :=_bade .readTextLine ();if _eabec !=nil {return nil ,_eabec ;};if _bade ._gfdba &&_cd .Count (_cd .TrimPrefix (_bffc ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_bade ._daag ._dbce =true ;
};_ac .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_bffc );_bbfg :=-1;_egcg :=0;_fbafc :=false ;_bfbb :="";for {_bade .skipSpaces ();_ ,_fgdc :=_bade ._bgbab .Peek (1);if _fgdc !=nil {return nil ,_fgdc ;
};_bffc ,_fgdc =_bade .readTextLine ();if _fgdc !=nil {return nil ,_fgdc ;};_fbdg :=_cadf .FindStringSubmatch (_bffc );if len (_fbdg )==0{_dfdf :=len (_bfbb )> 0;_bfbb +=_bffc +"\u000a";if _dfdf {_fbdg =_cadf .FindStringSubmatch (_bfbb );};};if len (_fbdg )==3{if _bade ._gfdba &&!_bade ._daag ._ccf {var (_gdef bool ;
_eggb int ;);for _ ,_gcbd :=range _bffc {if _fd .IsDigit (_gcbd ){if _gdef {break ;};continue ;};if !_gdef {_gdef =true ;};_eggb ++;};if _eggb > 1{_bade ._daag ._ccf =true ;};};_afegb ,_ :=_bc .Atoi (_fbdg [1]);_feea ,_ :=_bc .Atoi (_fbdg [2]);_bbfg =_afegb ;
_egcg =_feea ;_fbafc =true ;_bfbb ="";_ac .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_bbfg ,_egcg );
continue ;};_bgbaf :=_fgdda .FindStringSubmatch (_bffc );if len (_bgbaf )==4{if !_fbafc {_ac .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_d .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_ffga ,_ :=_bc .ParseInt (_bgbaf [1],10,64);_gcdb ,_ :=_bc .Atoi (_bgbaf [2]);_fbcd :=_bgbaf [3];_bfbb ="";if _cd .ToLower (_fbcd )=="\u006e"&&_ffga > 1{_ggca ,_bcec :=_bade ._adcd .ObjectMap [_bbfg ];if !_bcec ||_gcdb > _ggca .Generation {_gdbfg :=XrefObject {ObjectNumber :_bbfg ,XType :XrefTypeTableEntry ,Offset :_ffga ,Generation :_gcdb };
_bade ._adcd .ObjectMap [_bbfg ]=_gdbfg ;};};_bbfg ++;continue ;};if (len (_bffc )> 6)&&(_bffc [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_ac .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_bffc );
if len (_bffc )> 9{_ecdbg :=_bade .GetFileOffset ();_bade .SetFileOffset (_ecdbg -int64 (len (_bffc ))+7);};_bade .skipSpaces ();_bade .skipComments ();_ac .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_ac .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_bffc );_ccfad ,_fgdc =_bade .ParseDict ();_ac .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _fgdc !=nil {_ac .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_fgdc );return nil ,_fgdc ;};break ;};if _bffc =="\u0025\u0025\u0045O\u0046"{_ac .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_d .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_ac .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_bffc );
};_ac .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _bade ._aegca ==nil {_ede :=XrefTypeTableEntry ;_bade ._aegca =&_ede ;};return _ccfad ,nil ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_eccg *_ae .Document ;

// Globals are the JBIG2 global segments.
Globals _cf .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};func (_dbdc *PdfObjectDictionary )setWithLock (_cgfc PdfObjectName ,_cbfa PdfObject ,_edaf bool ){if _edaf {_dbdc ._caefg .Lock ();defer _dbdc ._caefg .Unlock ();};_ ,_adae :=_dbdc ._cedfc [_cgfc ];if !_adae {_dbdc ._gggg =append (_dbdc ._gggg ,_cgfc );
};_dbdc ._cedfc [_cgfc ]=_cbfa ;};

// UpdateParams updates the parameter values of the encoder.
func (_bbb *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_ac .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_fbbaf ,_eegb :=NewEncoderFromStream (streamObj );if _eegb !=nil {_ac .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_eegb );
return _eegb ;};if _bfee ,_bbgf :=_fbbaf .(*LZWEncoder );_bbgf {_bfee .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_ac .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_fbbaf );
_bgce ,_eegb :=_fbbaf .EncodeBytes (streamObj .Stream );if _eegb !=nil {_ac .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_eegb );return _eegb ;
};streamObj .Stream =_bgce ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bgce ))));return nil ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_bgdb *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _agfg _bb .Buffer ;for _egedg :=0;_egedg < len (data );_egedg +=4{_dbbe :=data [_egedg ];_cffde :=1;_fbeg :=byte (0);if _egedg +1< len (data ){_fbeg =data [_egedg +1];_cffde ++;
};_gdd :=byte (0);if _egedg +2< len (data ){_gdd =data [_egedg +2];_cffde ++;};_efbee :=byte (0);if _egedg +3< len (data ){_efbee =data [_egedg +3];_cffde ++;};_abcf :=(uint32 (_dbbe )<<24)|(uint32 (_fbeg )<<16)|(uint32 (_gdd )<<8)|uint32 (_efbee );if _abcf ==0{_agfg .WriteByte ('z');
}else {_ggcc :=_bgdb .base256Tobase85 (_abcf );for _ ,_acegf :=range _ggcc [:_cffde +1]{_agfg .WriteByte (_acegf +'!');};};};_agfg .WriteString ("\u007e\u003e");return _agfg .Bytes (),nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_abgcd *PdfObjectString )Decoded ()string {if _abgcd ==nil {return "";};_afee :=[]byte (_abgcd ._agdge );if len (_afee )>=2&&_afee [0]==0xFE&&_afee [1]==0xFF{return _acg .UTF16ToString (_afee [2:]);};return _acg .PDFDocEncodingToString (_afee );};
const JB2ImageAutoThreshold =-1.0;func _fbgb (_cbe int )int {_dffg :=_cbe >>(_gcfe -1);return (_cbe ^_dffg )-_dffg };

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_effd *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _gdag []int ;for _ ,_bcdb :=range _effd .Elements (){if _fdbd ,_becf :=_bcdb .(*PdfObjectInteger );_becf {_gdag =append (_gdag ,int (*_fdbd ));}else {return nil ,ErrTypeError ;};};return _gdag ,nil ;
};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ac .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_ggcfe ,_dgaa :=NewEncoderFromStream (streamObj );if _dgaa !=nil {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_dgaa );
return nil ,_dgaa ;};_ac .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_ggcfe );_efcad ,_dgaa :=_ggcfe .DecodeStream (streamObj );if _dgaa !=nil {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_dgaa );
return nil ,_dgaa ;};return _efcad ,nil ;};

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_bfb ParserMetadata )HasDataAfterEOF ()bool {return _bfb ._edgc };

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_bcgcc :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_bcgcc .PdfObjectDictionary =encoder .MakeStreamDict ();_bgef ,_acca :=encoder .EncodeBytes (contents );
if _acca !=nil {return nil ,_acca ;};_bcgcc .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bgef ))));_bcgcc .Stream =_bgef ;return _bcgcc ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fagca *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};type xrefType int ;func (_afdca *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){_afdca .skipSpaces ();const _ceeg =20;_gac ,_ :=_afdca ._bgbab .Peek (_ceeg );for _fgee :=0;
_fgee < 2;_fgee ++{if _afdca ._ebbd ==0{_afdca ._ebbd =_afdca .GetFileOffset ();};if _abfbd .Match (_gac ){_ac .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_ac .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_gac ));return _afdca .parseXrefStream (nil );};if _ebbfc .Match (_gac ){_ac .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _afdca .parseXrefTable ();};_efaeb :=_afdca .GetFileOffset ();if _afdca ._ebbd ==0{_afdca ._ebbd =_efaeb ;};_afdca .SetFileOffset (_efaeb -_ceeg );defer _afdca .SetFileOffset (_efaeb );_cddd ,_ :=_afdca ._bgbab .Peek (_ceeg );_gac =append (_cddd ,_gac ...);
};_ac .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _bdab :=_afdca .repairSeekXrefMarker ();_bdab !=nil {_ac .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_bdab );return nil ,_bdab ;};return _afdca .parseXrefTable ();};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bacda Version )String ()string {return _fgf .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_bacda .Major ,_bacda .Minor );};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _badfa (o ,0,traversed );};func (_cdfde *PdfParser )inspect ()(map[string ]int ,error ){_ac .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_ac .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_bced :=map[string ]int {};_cbdcg :=0;_cefbd :=0;var _fcgff []int ;for _bcgf :=range _cdfde ._adcd .ObjectMap {_fcgff =append (_fcgff ,_bcgf );};_fc .Ints (_fcgff );_edcdd :=0;
for _ ,_efdad :=range _fcgff {_acadf :=_cdfde ._adcd .ObjectMap [_efdad ];if _acadf .ObjectNumber ==0{continue ;};_cbdcg ++;_ac .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_ac .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_acadf .ObjectNumber );
_efdcg ,_bgeg :=_cdfde .LookupByNumber (_acadf .ObjectNumber );if _bgeg !=nil {_ac .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_acadf .ObjectNumber ,_bgeg );
_cefbd ++;continue ;};_ac .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_efdcg );_aacbd ,_eddfd :=_efdcg .(*PdfIndirectObject );if _eddfd {_ac .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_acadf .ObjectNumber ,_aacbd );
_adca ,_eefd :=_aacbd .PdfObject .(*PdfObjectDictionary );if _eefd {if _bcfdb ,_eagba :=_adca .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eagba {_eegf :=string (*_bcfdb );_ac .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_eegf );
_ ,_afgcf :=_bced [_eegf ];if _afgcf {_bced [_eegf ]++;}else {_bced [_eegf ]=1;};}else if _dgaba ,_fcedf :=_adca .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_fcedf {_gadff :=string (*_dgaba );_ac .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_gadff );
_ ,_gaeb :=_bced [_gadff ];if _gaeb {_bced [_gadff ]++;}else {_bced [_gadff ]=1;};};if _fefd ,_fbce :=_adca .Get ("\u0053").(*PdfObjectName );_fbce &&*_fefd =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_bceb :=_bced ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _bceb {_bced ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_bced ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _fgcd ,_caeaa :=_efdcg .(*PdfObjectStream );_caeaa {if _acgea ,_ddef :=_fgcd .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_ddef {_ac .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_acgea );_adgdg :=string (*_acgea );_bced [_adgdg ]++;};}else {_fbfc ,_ebca :=_efdcg .(*PdfObjectDictionary );
if _ebca {_ebece ,_bbaee :=_fbfc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _bbaee {_ggbg :=string (*_ebece );_ac .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_ggbg );_bced [_ggbg ]++;};};_ac .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_acadf .ObjectNumber ,_efdcg );
};_edcdd ++;};_ac .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_ac .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");
_ac .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_cbdcg );_ac .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_cefbd );for _cacac ,_aaffg :=range _bced {_ac .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_cacac ,_aaffg );
};_ac .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_cdfde ._adcd .ObjectMap )< 1{_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_fgf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_abed ,_gdfb :=_bced ["\u0046\u006f\u006e\u0074"];
if !_gdfb ||_abed < 2{_ac .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_ac .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _bced ,nil ;};type objectStream struct{N int ;_bba []byte ;_be map[int ]int64 ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_afgc *PdfObjectString )Str ()string {return _afgc ._agdge };

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_fegg *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_deda :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _deda ==nil {return NewRawEncoder (),nil ;};if _ ,_eafaf :=_deda .(*PdfObjectNull );
_eafaf {return NewRawEncoder (),nil ;};_aaaca ,_bacf :=_deda .(*PdfObjectName );if !_bacf {_aecd ,_ffdf :=_deda .(*PdfObjectArray );if !_ffdf {return nil ,_fgf .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _aecd .Len ()==0{return NewRawEncoder (),nil ;};if _aecd .Len ()!=1{_dbgc ,_dgcbc :=_aefe (streamObj );if _dgcbc !=nil {_ac .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_dgcbc );
return nil ,_dgcbc ;};_ac .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_dbgc );return _dbgc ,nil ;};_deda =_aecd .Get (0);_aaaca ,_ffdf =_deda .(*PdfObjectName );if !_ffdf {return nil ,_fgf .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _cafa ,_ebedg :=_ddgg .Load (_aaaca .String ());_ebedg {return _cafa .(StreamEncoder ),nil ;};switch *_aaaca {case StreamEncodingFilterNameFlate :return _efcf (streamObj ,nil );case StreamEncodingFilterNameLZW :return _fbef (streamObj ,nil );case StreamEncodingFilterNameDCT :return _abe (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _eee (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _fdb (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _bcdg (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_ac .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_fgf .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_aaaca );};func (_bddb *PdfCrypt )checkAccessRights (_afdc []byte )(bool ,_gd .Permissions ,error ){_eag :=_bddb .securityHandler ();
_edg ,_gcg ,_cdbb :=_eag .Authenticate (&_bddb ._ed ,_afdc );if _cdbb !=nil {return false ,0,_cdbb ;}else if _gcg ==0||len (_edg )==0{return false ,0,nil ;};return true ,_gcg ,nil ;};func _bccd (_fcbb *PdfObjectDictionary )(_gaefc *_gg .ImageBase ){var (_gdcca *PdfObjectInteger ;
_afaeg bool ;);if _gdcca ,_afaeg =_fcbb .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_afaeg {_gaefc =&_gg .ImageBase {Width :int (*_gdcca )};}else {return nil ;};if _gdcca ,_afaeg =_fcbb .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );
_afaeg {_gaefc .Height =int (*_gdcca );};if _gdcca ,_afaeg =_fcbb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_afaeg {_gaefc .BitsPerComponent =int (*_gdcca );};if _gdcca ,_afaeg =_fcbb .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );
_afaeg {_gaefc .ColorComponents =int (*_gdcca );};return _gaefc ;};

// Clear resets the dictionary to an empty state.
func (_ecbd *PdfObjectDictionary )Clear (){_ecbd ._gggg =[]PdfObjectName {};_ecbd ._cedfc =map[PdfObjectName ]PdfObject {};_ecbd ._caefg =&_b .Mutex {};};func (_faagd *PdfParser )skipSpaces ()(int ,error ){_dfde :=0;for {_edgd ,_gffea :=_faagd ._bgbab .ReadByte ();
if _gffea !=nil {return 0,_gffea ;};if IsWhiteSpace (_edgd ){_dfde ++;}else {_faagd ._bgbab .UnreadByte ();break ;};};return _dfde ,nil ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dbgg *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};var _aada =_fg .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");func _eecf (_gdafb PdfObject )(*float64 ,error ){switch _edgdf :=_gdafb .(type ){case *PdfObjectFloat :_gdcaa :=float64 (*_edgdf );
return &_gdcaa ,nil ;case *PdfObjectInteger :_aadb :=float64 (*_edgdf );return &_aadb ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_defba :=_bb .NewReader ([]byte (txt ));_defga :=&PdfParser {ObjCache :objectCache {},_eebf :_defba ,_bgbab :_af .NewReader (_defba ),_fggb :int64 (len (txt )),_bgdf :map[int64 ]bool {},_afab :make (map[*PdfParser ]*PdfParser )};
_defga ._adcd .ObjectMap =make (map[int ]XrefObject );return _defga ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_eeafa *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_eeafa .setWithLock (key ,val ,true );};func (_bff *PdfCrypt )securityHandler ()_gd .StdHandler {if _bff ._ed .R >=5{return _gd .NewHandlerR6 ();};return _gd .NewHandlerR4 (_bff ._bbf ,_bff ._gea .Length );
};var _fgdda =_fg .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_gbfgb *PdfObjectDictionary )Keys ()[]PdfObjectName {if _gbfgb ==nil {return nil ;};return _gbfgb ._gggg ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_cebbf *PdfParser )GetCrypter ()*PdfCrypt {return _cebbf ._ccbg };

// UpdateParams updates the parameter values of the encoder.
func (_gebe *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_befb ,_fabf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fabf ==nil {_gebe .ColorComponents =int (_befb );
};_cebf ,_fabf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fabf ==nil {_gebe .BitsPerComponent =int (_cebf );};_ceebc ,_fabf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _fabf ==nil {_gebe .Width =int (_ceebc );};_defb ,_fabf :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _fabf ==nil {_gebe .Height =int (_defb );};_aaba ,_fabf :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _fabf ==nil {_gebe .Quality =int (_aaba );};_acdd ,_fbebb :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));if _fbebb {_gebe .Decode ,_fabf =_acdd .ToFloat64Array ();if _fabf !=nil {_ac .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020de\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006eto\u0020\u0061r\u0072\u0061\u0079\u0073\u003a\u0020\u0025\u0076",_fabf );
};};};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_dbfa string ,_cggd bool ){_cadfd ,_cggd :=TraceToDirectObject (obj ).(*PdfObjectName );if _cggd {return string (*_cadfd ),true ;};return ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_decg :=MakeArray ();for _ ,_abbgg :=range vals {_decg .Append (MakeFloat (_abbgg ));};return _decg ;};func _bbed (_ffcdbc _cb .ReadSeeker ,_acfg int64 )(*limitedReadSeeker ,error ){_ ,_ggede :=_ffcdbc .Seek (0,_cb .SeekStart );
if _ggede !=nil {return nil ,_ggede ;};return &limitedReadSeeker {_ecbb :_ffcdbc ,_geea :_acfg },nil ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_bacc :=MultiEncoder {};_bacc ._abff =[]StreamEncoder {};return &_bacc ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_af .Reader )(PdfObject ,error ){_edac :=false ;_abgd :=true ;var _ffdca _bb .Buffer ;for {if _ac .Log .IsLogLevel (_ac .LogLevelTrace ){_ac .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_ffdca .String ());
};_aeag ,_ccfbeg :=buf .Peek (1);if _ccfbeg ==_cb .EOF {break ;};if _ccfbeg !=nil {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_ccfbeg );return nil ,_ccfbeg ;};if _abgd &&(_aeag [0]=='-'||_aeag [0]=='+'){_fcag ,_ :=buf .ReadByte ();
_ffdca .WriteByte (_fcag );_abgd =false ;}else if IsDecimalDigit (_aeag [0]){_cedfcd ,_ :=buf .ReadByte ();_ffdca .WriteByte (_cedfcd );}else if _aeag [0]=='.'{_gfbe ,_ :=buf .ReadByte ();_ffdca .WriteByte (_gfbe );_edac =true ;}else if _aeag [0]=='e'||_aeag [0]=='E'{_bdgd ,_ :=buf .ReadByte ();
_ffdca .WriteByte (_bdgd );_edac =true ;_abgd =true ;}else {break ;};};var _dagg PdfObject ;if _edac {_affe ,_aede :=_bc .ParseFloat (_ffdca .String (),64);if _aede !=nil {_ac .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_ffdca .String (),_aede );
_affe =0.0;};_ddaff :=PdfObjectFloat (_affe );_dagg =&_ddaff ;}else {_bgfac ,_eabeb :=_bc .ParseInt (_ffdca .String (),10,64);if _eabeb !=nil {_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_ffdca .String (),_eabeb );
_bgfac =0;};_accae :=PdfObjectInteger (_bgfac );_dagg =&_accae ;};return _dagg ,nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_dfed *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bgba :=_bb .NewReader (encoded );_gdgc ,_bbc :=_e .Decode (_bgba );if _bbc !=nil {_ac .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bbc );
return nil ,_bbc ;};_bea :=_gdgc .Bounds ();var _fcf =make ([]byte ,_bea .Dx ()*_bea .Dy ()*_dfed .ColorComponents *_dfed .BitsPerComponent /8);_fbeba :=0;switch _dfed .ColorComponents {case 1:_cgaa :=[]float64 {_dfed .Decode [0],_dfed .Decode [1]};for _aee :=_bea .Min .Y ;
_aee < _bea .Max .Y ;_aee ++{for _ccg :=_bea .Min .X ;_ccg < _bea .Max .X ;_ccg ++{_dbcea :=_gdgc .At (_ccg ,_aee );if _dfed .BitsPerComponent ==16{_dddb ,_acf :=_dbcea .(_bd .Gray16 );if !_acf {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_eddf :=_dgee (uint (_dddb .Y >>8),_cgaa [0],_cgaa [1]);_bcga :=_dgee (uint (_dddb .Y ),_cgaa [0],_cgaa [1]);_fcf [_fbeba ]=byte (_eddf );_fbeba ++;_fcf [_fbeba ]=byte (_bcga );_fbeba ++;}else {_bfda ,_gaa :=_dbcea .(_bd .Gray );if !_gaa {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_fcf [_fbeba ]=byte (_dgee (uint (_bfda .Y ),_cgaa [0],_cgaa [1]));_fbeba ++;};};};case 3:_aeab :=[]float64 {_dfed .Decode [0],_dfed .Decode [1]};_fcgf :=[]float64 {_dfed .Decode [2],_dfed .Decode [3]};_acaa :=[]float64 {_dfed .Decode [4],_dfed .Decode [5]};
for _cgcee :=_bea .Min .Y ;_cgcee < _bea .Max .Y ;_cgcee ++{for _gafa :=_bea .Min .X ;_gafa < _bea .Max .X ;_gafa ++{_ega :=_gdgc .At (_gafa ,_cgcee );if _dfed .BitsPerComponent ==16{_feag ,_gcbf :=_ega .(_bd .RGBA64 );if !_gcbf {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_cebg :=_dgee (uint (_feag .R >>8),_aeab [0],_aeab [1]);_ddac :=_dgee (uint (_feag .R ),_aeab [0],_aeab [1]);_fecf :=_dgee (uint (_feag .G >>8),_fcgf [0],_fcgf [1]);_bdfg :=_dgee (uint (_feag .G ),_fcgf [0],_fcgf [1]);_efbc :=_dgee (uint (_feag .B >>8),_acaa [0],_acaa [1]);
_efdc :=_dgee (uint (_feag .B ),_acaa [0],_acaa [1]);_fcf [_fbeba ]=byte (_cebg );_fbeba ++;_fcf [_fbeba ]=byte (_ddac );_fbeba ++;_fcf [_fbeba ]=byte (_fecf );_fbeba ++;_fcf [_fbeba ]=byte (_bdfg );_fbeba ++;_fcf [_fbeba ]=byte (_efbc );_fbeba ++;_fcf [_fbeba ]=byte (_efdc );
_fbeba ++;}else {_aadc ,_cceg :=_ega .(_bd .RGBA );if _cceg {_fedb :=_dgee (uint (_aadc .R ),_aeab [0],_aeab [1]);_accc :=_dgee (uint (_aadc .G ),_fcgf [0],_fcgf [1]);_dfeg :=_dgee (uint (_aadc .B ),_acaa [0],_acaa [1]);_fcf [_fbeba ]=byte (_fedb );_fbeba ++;
_fcf [_fbeba ]=byte (_accc );_fbeba ++;_fcf [_fbeba ]=byte (_dfeg );_fbeba ++;}else {_dged ,_dcda :=_ega .(_bd .YCbCr );if !_dcda {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_baed ,_egfe ,_acea ,_ :=_dged .RGBA ();
_dgfb :=_dgee (uint (_baed >>8),_aeab [0],_aeab [1]);_adeg :=_dgee (uint (_egfe >>8),_fcgf [0],_fcgf [1]);_dfab :=_dgee (uint (_acea >>8),_acaa [0],_acaa [1]);_fcf [_fbeba ]=byte (_dgfb );_fbeba ++;_fcf [_fbeba ]=byte (_adeg );_fbeba ++;_fcf [_fbeba ]=byte (_dfab );
_fbeba ++;};};};};case 4:_agee :=[]float64 {_dfed .Decode [0],_dfed .Decode [1]};_bcfg :=[]float64 {_dfed .Decode [2],_dfed .Decode [3]};_cfef :=[]float64 {_dfed .Decode [4],_dfed .Decode [5]};_ebf :=[]float64 {_dfed .Decode [6],_dfed .Decode [7]};for _baff :=_bea .Min .Y ;
_baff < _bea .Max .Y ;_baff ++{for _acdc :=_bea .Min .X ;_acdc < _bea .Max .X ;_acdc ++{_abfd :=_gdgc .At (_acdc ,_baff );_dcdd ,_ecf :=_abfd .(_bd .CMYK );if !_ecf {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_dff :=255-_dgee (uint (_dcdd .C ),_agee [0],_agee [1]);_gdaf :=255-_dgee (uint (_dcdd .M ),_bcfg [0],_bcfg [1]);_dcfd :=255-_dgee (uint (_dcdd .Y ),_cfef [0],_cfef [1]);_gae :=255-_dgee (uint (_dcdd .K ),_ebf [0],_ebf [1]);_fcf [_fbeba ]=byte (_dff );
_fbeba ++;_fcf [_fbeba ]=byte (_gdaf );_fbeba ++;_fcf [_fbeba ]=byte (_dcfd );_fbeba ++;_fcf [_fbeba ]=byte (_gae );_fbeba ++;};};};return _fcf ,nil ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_bebc *PdfObjectArray )Get (i int )PdfObject {if _bebc ==nil ||i >=len (_bebc ._dcfc )||i < 0{return nil ;};return _bebc ._dcfc [i ];};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_dbced *PdfParser )GetTrailer ()*PdfObjectDictionary {return _dbced ._afbc };

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
//
//	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _c .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _dffeb ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_eg .Error (_dffeb ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_dbac uint8 ;_dec _gg .Image ;_cfceg error ;);if bwThreshold ==JB2ImageAutoThreshold {_dec ,_cfceg =_gg .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_eg .Error (_dffeb ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_dbac =uint8 (255*bwThreshold );_dec ,_cfceg =_gg .MonochromeThresholdConverter (_dbac ).Convert (i );};if _cfceg !=nil {return nil ,_cfceg ;};return _gffgc (_dec ),nil ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_agfe int ,_dggga bool ){_cbabd ,_dggga :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _dggga &&_cbabd !=nil {return int (*_cbabd ),true ;};return 0,false ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_begge *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_begge ._eebf .Seek (offset ,_cb .SeekStart );_begge ._bgbab =_af .NewReader (_begge ._eebf );};

// SetImage sets the image base for given flate encoder.
func (_eabf *FlateEncoder )SetImage (img *_gg .ImageBase ){_eabf ._cafb =img };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fdcc *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_bebe :=MakeDict ();_bebe .Set ("\u004b",MakeInteger (int64 (_fdcc .K )));_bebe .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fdcc .Columns )));if _fdcc .BlackIs1 {_bebe .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_fdcc .BlackIs1 ));
};if _fdcc .EncodedByteAlign {_bebe .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_fdcc .EncodedByteAlign ));};if _fdcc .EndOfLine &&_fdcc .K >=0{_bebe .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_fdcc .EndOfLine ));
};if _fdcc .Rows !=0&&!_fdcc .EndOfBlock {_bebe .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_fdcc .Rows )));};if !_fdcc .EndOfBlock {_bebe .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_fdcc .EndOfBlock ));};if _fdcc .DamagedRowsBeforeError !=0{_bebe .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_fdcc .DamagedRowsBeforeError )));
};return _bebe ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_cbbf :=TraceToDirectObject (obj ).(*PdfObjectNull );return _cbbf ;};func _gbgd (_egdfa ,_dbff ,_aceac int )error {if _dbff < 0||_dbff > _egdfa {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _aceac < _dbff {return _d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _aceac > _egdfa {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_gcae :=MakeArray ();for _ ,_gagf :=range vals {_gcae .Append (MakeInteger (_gagf ));};return _gcae ;};

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _cb .ReadSeeker )(_fab *PdfParser ,_cgga error ){_fab =&PdfParser {_eebf :rs ,ObjCache :make (objectCache ),_bgdf :map[int64 ]bool {},_gfdba :true ,_afab :make (map[*PdfParser ]*PdfParser )};if _cgga =_fab .parseDetailedHeader ();
_cgga !=nil {return nil ,_cgga ;};if _fab ._afbc ,_cgga =_fab .loadXrefs ();_cgga !=nil {_ac .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_cgga );
return nil ,_cgga ;};_ac .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_fab ._afbc );if len (_fab ._adcd .ObjectMap )==0{return nil ,_fgf .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _fab ,nil ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_ecbf []byte ,_bcbab bool ){_dfea ,_bcbab :=TraceToDirectObject (obj ).(*PdfObjectString );if _bcbab {return _dfea .Bytes (),true ;};return ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;
);var _gbbg =_fg .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// GetFilterName returns the name of the encoding filter.
func (_edbe *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_baef *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_aeca error ){const _dad ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _baef ==nil {return _eg .Error (_dad ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_baef .DefaultPageSettings ;};if _baef ._eccg ==nil {_baef ._eccg =_ae .InitEncodeDocument (settings .FileMode );
};if _aeca =settings .Validate ();_aeca !=nil {return _eg .Wrap (_aeca ,_dad ,"");};_dgaf ,_aeca :=img .toBitmap ();if _aeca !=nil {return _eg .Wrap (_aeca ,_dad ,"");};switch settings .Compression {case JB2Generic :if _aeca =_baef ._eccg .AddGenericPage (_dgaf ,settings .DuplicatedLinesRemoval );
_aeca !=nil {return _eg .Wrap (_aeca ,_dad ,"");};case JB2SymbolCorrelation :return _eg .Error (_dad ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _eg .Error (_dad ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _eg .Error (_dad ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};func (_fde *PdfCrypt )decryptBytes (_gee []byte ,_gabd string ,_gcac []byte )([]byte ,error ){_ac .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_ffb ,_afcf :=_fde ._cdf [_gabd ];if !_afcf {return nil ,_fgf .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_gabd );};return _ffb .DecryptBytes (_gee ,_gcac );};type objectStreams map[int ]objectStream ;
func (_fbeb *FlateEncoder )postDecodePredict (_ceg []byte )([]byte ,error ){if _fbeb .Predictor > 1{if _fbeb .Predictor ==2{_ac .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ac .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_fbeb .Colors );
_eagbe :=_fbeb .Columns *_fbeb .Colors ;if _eagbe < 1{return []byte {},nil ;};_gede :=len (_ceg )/_eagbe ;if len (_ceg )%_eagbe !=0{_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_fgf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ceg ),_eagbe );};if _eagbe %_fbeb .Colors !=0{return nil ,_fgf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_eagbe ,_fbeb .Colors );
};if _eagbe > len (_ceg ){_ac .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_eagbe ,len (_ceg ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ac .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_ceg ),_ceg );
_faga :=_bb .NewBuffer (nil );for _feb :=0;_feb < _gede ;_feb ++{_bafg :=_ceg [_eagbe *_feb :_eagbe *(_feb +1)];for _beee :=_fbeb .Colors ;_beee < _eagbe ;_beee ++{_bafg [_beee ]+=_bafg [_beee -_fbeb .Colors ];};_faga .Write (_bafg );};_baaae :=_faga .Bytes ();
_ac .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_baaae ),_baaae );return _baaae ,nil ;}else if _fbeb .Predictor >=10&&_fbeb .Predictor <=15{_ac .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_dfa :=_fbeb .Columns *_fbeb .Colors +1;_bddc :=len (_ceg )/_dfa ;if len (_ceg )%_dfa !=0{return nil ,_fgf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ceg ),_dfa );
};if _dfa > len (_ceg ){_ac .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dfa ,len (_ceg ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ffdb :=_bb .NewBuffer (nil );_ac .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_fbeb .Columns );
_ac .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_ceg ),_dfa ,_bddc );_faad :=make ([]byte ,_dfa );for _beca :=0;_beca < _dfa ;_beca ++{_faad [_beca ]=0;};_bfed :=_fbeb .Colors ;
for _dgg :=0;_dgg < _bddc ;_dgg ++{_deff :=_ceg [_dfa *_dgg :_dfa *(_dgg +1)];_bfad :=_deff [0];switch _bfad {case _bef :case _edca :for _acce :=1+_bfed ;_acce < _dfa ;_acce ++{_deff [_acce ]+=_deff [_acce -_bfed ];};case _baaa :for _geee :=1;_geee < _dfa ;
_geee ++{_deff [_geee ]+=_faad [_geee ];};case _cede :for _fbfdd :=1;_fbfdd < _bfed +1;_fbfdd ++{_deff [_fbfdd ]+=_faad [_fbfdd ]/2;};for _bbaf :=_bfed +1;_bbaf < _dfa ;_bbaf ++{_deff [_bbaf ]+=byte ((int (_deff [_bbaf -_bfed ])+int (_faad [_bbaf ]))/2);
};case _abc :for _fbfa :=1;_fbfa < _dfa ;_fbfa ++{var _aefa ,_ccff ,_cdd byte ;_ccff =_faad [_fbfa ];if _fbfa >=_bfed +1{_aefa =_deff [_fbfa -_bfed ];_cdd =_faad [_fbfa -_bfed ];};_deff [_fbfa ]+=_ggbd (_aefa ,_ccff ,_cdd );};default:_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_bfad ,_dgg );
return nil ,_fgf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bfad );};copy (_faad ,_deff );_ffdb .Write (_deff [1:]);};_ebg :=_ffdb .Bytes ();return _ebg ,nil ;
}else {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_fbeb .Predictor );return nil ,_fgf .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_fbeb .Predictor );
};};return _ceg ,nil ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _afaef :=obj .(type ){case *PdfObjectFloat :_ac .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_afaef ),nil ;case *PdfObjectInteger :return int64 (*_afaef ),nil ;case *PdfObjectReference :_dcdc :=TraceToDirectObject (obj );return GetNumberAsInt64 (_dcdc );case *PdfIndirectObject :return GetNumberAsInt64 (_afaef .PdfObject );};return 0,ErrNotANumber ;
};

// HasNonConformantStream implements core.ParserMetadata.
func (_fcdf ParserMetadata )HasNonConformantStream ()bool {return _fcdf ._eeg };

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_efe ParserMetadata )HasInvalidSubsectionHeader ()bool {return _efe ._ccf };func (_ddaa *PdfParser )parseArray ()(*PdfObjectArray ,error ){_fbfg :=MakeArray ();_ddaa ._bgbab .ReadByte ();for {_ddaa .skipSpaces ();_agbd ,_bfabb :=_ddaa ._bgbab .Peek (1);
if _bfabb !=nil {return _fbfg ,_bfabb ;};if _agbd [0]==']'{_ddaa ._bgbab .ReadByte ();break ;};_agdf ,_bfabb :=_ddaa .parseObject ();if _bfabb !=nil {return _fbfg ,_bfabb ;};_fbfg .Append (_agdf );};return _fbfg ,nil ;};

// String returns a string representation of the *PdfObjectString.
func (_debb *PdfObjectString )String ()string {return _debb ._agdge };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cfg *FlateEncoder )MakeDecodeParams ()PdfObject {if _cfg .Predictor > 1{_cdaa :=MakeDict ();_cdaa .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_cfg .Predictor )));if _cfg .BitsPerComponent !=8{_cdaa .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_cfg .BitsPerComponent )));
};if _cfg .Columns !=1{_cdaa .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_cfg .Columns )));};if _cfg .Colors !=1{_cdaa .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_cfg .Colors )));};return _cdaa ;};return nil ;
};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_gddde *PdfObjectFloat ,_gfga bool ){_gddde ,_gfga =TraceToDirectObject (obj ).(*PdfObjectFloat );return _gddde ,_gfga ;};

// Len returns the number of elements in the array.
func (_gdbef *PdfObjectArray )Len ()int {if _gdbef ==nil {return 0;};return len (_gdbef ._dcfc );};func (_agdb *PdfParser )parseString ()(*PdfObjectString ,error ){_agdb ._bgbab .ReadByte ();var _dabf _bb .Buffer ;_efaa :=1;for {_gddg ,_agfa :=_agdb ._bgbab .Peek (1);
if _agfa !=nil {return MakeString (_dabf .String ()),_agfa ;};if _gddg [0]=='\\'{_agdb ._bgbab .ReadByte ();_ddeg ,_ccfag :=_agdb ._bgbab .ReadByte ();if _ccfag !=nil {return MakeString (_dabf .String ()),_ccfag ;};if IsOctalDigit (_ddeg ){_cdedg ,_baffg :=_agdb ._bgbab .Peek (2);
if _baffg !=nil {return MakeString (_dabf .String ()),_baffg ;};var _bgcf []byte ;_bgcf =append (_bgcf ,_ddeg );for _ ,_cffaa :=range _cdedg {if IsOctalDigit (_cffaa ){_bgcf =append (_bgcf ,_cffaa );}else {break ;};};_agdb ._bgbab .Discard (len (_bgcf )-1);
_ac .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_bgcf );_fffe ,_baffg :=_bc .ParseUint (string (_bgcf ),8,32);if _baffg !=nil {return MakeString (_dabf .String ()),_baffg ;};_dabf .WriteByte (byte (_fffe ));
continue ;};switch _ddeg {case 'n':_dabf .WriteRune ('\n');case 'r':_dabf .WriteRune ('\r');case 't':_dabf .WriteRune ('\t');case 'b':_dabf .WriteRune ('\b');case 'f':_dabf .WriteRune ('\f');case '(':_dabf .WriteRune ('(');case ')':_dabf .WriteRune (')');
case '\\':_dabf .WriteRune ('\\');};continue ;}else if _gddg [0]=='('{_efaa ++;}else if _gddg [0]==')'{_efaa --;if _efaa ==0{_agdb ._bgbab .ReadByte ();break ;};};_dfcg ,_ :=_agdb ._bgbab .ReadByte ();_dabf .WriteByte (_dfcg );};return MakeString (_dabf .String ()),nil ;
};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_cbc *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_eedfb :=MakeDict ();_eedfb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cbc .GetFilterName ()));_faf :=_cbc .MakeDecodeParams ();if _faf !=nil {_eedfb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_faf );
};return _eedfb ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_gdfcc []float64 ,_cebcb error ){for _ ,_aacf :=range objects {_cfbae ,_aecc :=GetNumberAsFloat (_aacf );if _aecc !=nil {return nil ,_aecc ;};_gdfcc =append (_gdfcc ,_cfbae );};return _gdfcc ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbcf *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_aadf :=MakeDict ();_aadf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bbcf .GetFilterName ()));_aadf .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bbcf .MakeDecodeParams ());
return _aadf ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _fbgf :=obj .(type ){case *PdfObjectFloat :return float64 (*_fbgf ),nil ;case *PdfObjectInteger :return float64 (*_fbgf ),nil ;case *PdfObjectReference :_cbabe :=TraceToDirectObject (obj );
return GetNumberAsFloat (_cbabe );case *PdfIndirectObject :return GetNumberAsFloat (_fbgf .PdfObject );};return 0,ErrNotANumber ;};func (_ggbdg *PdfParser )parseBool ()(PdfObjectBool ,error ){_fbca ,_ddad :=_ggbdg ._bgbab .Peek (4);if _ddad !=nil {return PdfObjectBool (false ),_ddad ;
};if (len (_fbca )>=4)&&(string (_fbca [:4])=="\u0074\u0072\u0075\u0065"){_ggbdg ._bgbab .Discard (4);return PdfObjectBool (true ),nil ;};_fbca ,_ddad =_ggbdg ._bgbab .Peek (5);if _ddad !=nil {return PdfObjectBool (false ),_ddad ;};if (len (_fbca )>=5)&&(string (_fbca [:5])=="\u0066\u0061\u006cs\u0065"){_ggbdg ._bgbab .Discard (5);
return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_d .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_gfda *MultiEncoder )AddEncoder (encoder StreamEncoder ){_gfda ._abff =append (_gfda ._abff ,encoder );};

// String returns a string describing `ind`.
func (_fbae *PdfIndirectObject )String ()string {return _fgf .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_fbae ).ObjectNumber );};type limitedReadSeeker struct{_ecbb _cb .ReadSeeker ;_geea int64 ;};func _abe (_cdea *PdfObjectStream ,_adde *MultiEncoder )(*DCTEncoder ,error ){_dgea :=NewDCTEncoder ();
_ccfb :=_cdea .PdfObjectDictionary ;if _ccfb ==nil {return _dgea ,nil ;};_cfac :=_cdea .Stream ;if _adde !=nil {_gdcc ,_eadg :=_adde .DecodeBytes (_cfac );if _eadg !=nil {return nil ,_eadg ;};_cfac =_gdcc ;};_bbaaf :=_bb .NewReader (_cfac );_feba ,_bcf :=_e .DecodeConfig (_bbaaf );
if _bcf !=nil {_ac .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_bcf );return nil ,_bcf ;};switch _feba .ColorModel {case _bd .RGBAModel :_dgea .BitsPerComponent =8;
_dgea .ColorComponents =3;_dgea .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _bd .RGBA64Model :_dgea .BitsPerComponent =16;_dgea .ColorComponents =3;_dgea .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _bd .GrayModel :_dgea .BitsPerComponent =8;
_dgea .ColorComponents =1;_dgea .Decode =[]float64 {0.0,1.0};case _bd .Gray16Model :_dgea .BitsPerComponent =16;_dgea .ColorComponents =1;_dgea .Decode =[]float64 {0.0,1.0};case _bd .CMYKModel :_dgea .BitsPerComponent =8;_dgea .ColorComponents =4;_dgea .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0};
case _bd .YCbCrModel :_dgea .BitsPerComponent =8;_dgea .ColorComponents =3;_dgea .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};default:return nil ,_d .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_dgea .Width =_feba .Width ;_dgea .Height =_feba .Height ;_ac .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_dgea );_dgea .Quality =DefaultJPEGQuality ;_bfgd ,_gfgg :=GetArray (_ccfb .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
if _gfgg {_bdb ,_gfcb :=_bfgd .ToFloat64Array ();if _gfcb !=nil {return _dgea ,_gfcb ;};_dgea .Decode =_bdb ;};return _dgea ,nil ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};func (_dddg *PdfParser )initParser ()error {_gebc ,_baefg ,_cfgf :=_dddg .parsePdfVersion ();if _cfgf !=nil {_ac .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_cfgf );
return _cfgf ;};_dddg ._bcdge .Major =_gebc ;_dddg ._bcdge .Minor =_baefg ;if _dddg ._afbc ,_cfgf =_dddg .loadXrefs ();_cfgf !=nil {_ac .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_cfgf );
return _cfgf ;};_ac .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_dddg ._afbc );_bgec ,_cfgf :=_dddg .parseLinearizedDictionary ();if _cfgf !=nil {return _cfgf ;};if _bgec !=nil {_dddg ._baad ,_cfgf =_dddg .checkLinearizedInformation (_bgec );
if _cfgf !=nil {return _cfgf ;};};if len (_dddg ._adcd .ObjectMap )==0{return _fgf .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};_dddg ._bgafa =len (_dddg ._fccg );
if _dddg ._baad &&_dddg ._bgafa !=0{_dddg ._bgafa --;};_dddg ._bbede =make ([]*PdfParser ,_dddg ._bgafa );return nil ;};func (_badd *PdfObjectInteger )String ()string {return _fgf .Sprintf ("\u0025\u0064",*_badd )};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_agef *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_eddcg :=_agef .Get (key );if _eddcg ==nil {return "",false ;};_afag ,_aafed :=_eddcg .(*PdfObjectString );if !_aafed {return "",false ;};return _afag .Str (),true ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_gcc *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_gfbc :=MakeDict ();_gfbc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gcc .GetFilterName ()));_bage :=_gcc .MakeDecodeParams ();if _bage !=nil {_gfbc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bage );
};_gfbc .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_gcc .EarlyChange )));return _gfbc ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_ceag *PdfObjectArray )Elements ()[]PdfObject {if _ceag ==nil {return nil ;};return _ceag ._dcfc ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_caeab *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_caeab ._aefg ){return _d .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_caeab ._aefg [i ]=obj ;return nil ;};

// ParserMetadata gets the pdf parser metadata.
func (_aagf *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_aagf ._gfdba {return ParserMetadata {},_fgf .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _aagf ._daag ,nil ;};func _gffgc (_dfege _gg .Image )*JBIG2Image {_ccafc :=_dfege .Base ();return &JBIG2Image {Data :_ccafc .Data ,Width :_ccafc .Width ,Height :_ccafc .Height ,HasPadding :true };};var _cdde =_fg .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");


// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// MakeLazy create temporary file for stream to reduce memory usage.
// It can be used for creating PDF with many images.
// Temporary files are removed automatically when Write/WriteToFile is called for creator object.
func (_eefa *PdfObjectStream )MakeLazy ()error {if _eefa .Lazy {return nil ;};_ccag ,_bbgea :=_f .CreateTemp ("","\u0078o\u0062\u006a\u0065\u0063\u0074");if _bbgea !=nil {return _bbgea ;};defer _ccag .Close ();_ ,_bbgea =_ccag .Write (_eefa .Stream );if _bbgea !=nil {return _bbgea ;
};_eefa .Lazy =true ;_eefa .Stream =nil ;_eefa .TempFile =_ccag .Name ();return nil ;};func (_ggf *PdfCrypt )authenticate (_fad []byte )(bool ,error ){_ggf ._gba =false ;_ecce :=_ggf .securityHandler ();_afe ,_ba ,_cbdf :=_ecce .Authenticate (&_ggf ._ed ,_fad );
if _cbdf !=nil {return false ,_cbdf ;}else if _ba ==0||len (_afe )==0{return false ,nil ;};_ggf ._gba =true ;_ggf ._cffda =_afe ;return true ,nil ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_adgga *PdfObjectStream ,_cffdg bool ){obj =ResolveReference (obj );_adgga ,_cffdg =obj .(*PdfObjectStream );return _adgga ,_cffdg ;};

// WriteString outputs the object as it is to be written to file.
func (_ceca *PdfObjectArray )WriteString ()string {var _gbee _cd .Builder ;_gbee .WriteString ("\u005b");for _ebea ,_beaf :=range _ceca .Elements (){_gbee .WriteString (_beaf .WriteString ());if _ebea < (_ceca .Len ()-1){_gbee .WriteString ("\u0020");};
};_gbee .WriteString ("\u005d");return _gbee .String ();};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_daa :=&LZWEncoder {};_daa .Predictor =1;_daa .BitsPerComponent =8;_daa .Colors =1;_daa .Columns =1;_daa .EarlyChange =1;return _daa ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_ddaf *PdfObjectStreams ,_gfbfa bool ){_ddaf ,_gfbfa =obj .(*PdfObjectStreams );return _ddaf ,_gfbfa ;};const _edaec =10;

// String returns a string describing `stream`.
func (_fgac *PdfObjectStream )String ()string {return _fgf .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_fgac .ObjectNumber ,_fgac .PdfObjectDictionary );};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_egbg *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _eddc _c .Image ;if _egbg .ColorComponents ==1&&_egbg .BitsPerComponent ==8{_eddc =&_c .Gray {Rect :_c .Rect (0,0,_egbg .Width ,_egbg .Height ),Pix :data ,Stride :_gg .BytesPerLine (_egbg .Width ,_egbg .BitsPerComponent ,_egbg .ColorComponents )};
}else {var _ecgf error ;_eddc ,_ecgf =_gg .NewImage (_egbg .Width ,_egbg .Height ,_egbg .BitsPerComponent ,_egbg .ColorComponents ,data ,nil ,nil );if _ecgf !=nil {return nil ,_ecgf ;};};_ccfe :=_e .Options {};_ccfe .Quality =_egbg .Quality ;var _cdfa _bb .Buffer ;
if _afed :=_e .Encode (&_cdfa ,_eddc ,&_ccfe );_afed !=nil {return nil ,_afed ;};return _cdfa .Bytes (),nil ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_ccgeg *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_ccgeg ._dcfc ){return _d .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_ccgeg ._dcfc [i ]=obj ;return nil ;};func _ggbd (_baae ,_dacg ,_acfa uint8 )uint8 {_gfde :=int (_acfa );
_agfgc :=int (_dacg )-_gfde ;_ccfbe :=int (_baae )-_gfde ;_gfde =_fbgb (_agfgc +_ccfbe );_agfgc =_fbgb (_agfgc );_ccfbe =_fbgb (_ccfbe );if _agfgc <=_ccfbe &&_agfgc <=_gfde {return _baae ;}else if _ccfbe <=_gfde {return _dacg ;};return _acfa ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_badfb :=PdfObjectInteger (val );return &_badfb };

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_begg *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_adaf :=_bb .NewReader (encoded );var _cgaag []byte ;for {_dbba ,_dfbf :=_adaf .ReadByte ();if _dfbf !=nil {return nil ,_dfbf ;};if _dbba > 128{_caeg ,_egdf :=_adaf .ReadByte ();
if _egdf !=nil {return nil ,_egdf ;};for _dgga :=0;_dgga < 257-int (_dbba );_dgga ++{_cgaag =append (_cgaag ,_caeg );};}else if _dbba < 128{for _ddeb :=0;_ddeb < int (_dbba )+1;_ddeb ++{_egfa ,_ebbf :=_adaf .ReadByte ();if _ebbf !=nil {return nil ,_ebbf ;
};_cgaag =append (_cgaag ,_egfa );};}else {break ;};};return _cgaag ,nil ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_bbbe *MultiEncoder )GetFilterArray ()*PdfObjectArray {_fbgc :=make ([]PdfObject ,len (_bbbe ._abff ));for _badc ,_dcga :=range _bbbe ._abff {_fbgc [_badc ]=MakeName (_dcga .GetFilterName ());};return MakeArray (_fbgc ...);};

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_dafc *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _dafc ._bccb };

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_cfce :=&PdfCrypt {_gba :false ,_fbg :make (map[PdfObject ]bool ),_fcg :make (map[PdfObject ]bool ),_bbg :make (map[int ]struct{}),_agg :parser };_geb ,_ffff :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_ffff {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _cfce ,_d .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_geb !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_ac .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_geb );
return _cfce ,_d .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_cfce ._gea .Filter =string (*_geb );if _ece ,_fee :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_fee {_cfce ._gea .SubFilter =_ece .Str ();
_ac .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_ece );};if L ,_bgbc :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_bgbc {if (*L %8)!=0{_ac .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _cfce ,_d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_cfce ._gea .Length =int (*L );}else {_cfce ._gea .Length =40;};_cfce ._gea .V =0;if _gce ,_eed :=ed .Get ("\u0056").(*PdfObjectInteger );
_eed {V :=int (*_gce );_cfce ._gea .V =V ;if V >=1&&V <=2{_cfce ._cdf =_eef (_cfce ._gea .Length );}else if V >=4&&V <=5{if _fca :=_cfce .loadCryptFilters (ed );_fca !=nil {return _cfce ,_fca ;};}else {_ac .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _cfce ,_d .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _dgf :=_ffa (&_cfce ._ed ,ed );_dgf !=nil {return _cfce ,_dgf ;};_fffd :="";if _cgcf ,_aea :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_aea &&_cgcf .Len ()>=1{_cdg ,_egg :=GetString (_cgcf .Get (0));if !_egg {return _cfce ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_fffd =_cdg .Str ();}else {_ac .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_cfce ._bbf =_fffd ;return _cfce ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bccf *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_gdee *PdfParser )GetRevision (revisionNumber int )(*PdfParser ,error ){_cacee :=_gdee ._bgafa ;if _cacee ==revisionNumber {return _gdee ,nil ;};if _cacee < revisionNumber {return nil ,_d .New ("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e");
};if _gdee ._bbede [revisionNumber ]!=nil {return _gdee ._bbede [revisionNumber ],nil ;};_fbed :=_gdee ;for ;_cacee > revisionNumber ;_cacee --{_ffcb ,_abcd :=_fbed .GetPreviousRevisionParser ();if _abcd !=nil {return nil ,_abcd ;};_gdee ._bbede [_cacee -1]=_ffcb ;
_gdee ._afab [_fbed ]=_ffcb ;_fbed =_ffcb ;};return _fbed ,nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_ccgg JBIG2EncoderSettings )Validate ()error {const _eggd ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _ccgg .Threshold < 0||_ccgg .Threshold > 1.0{return _eg .Errorf (_eggd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_ccgg .Threshold );
};if _ccgg .ResolutionX < 0{return _eg .Errorf (_eggd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_ccgg .ResolutionX );
};if _ccgg .ResolutionY < 0{return _eg .Errorf (_eggd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_ccgg .ResolutionY );
};if _ccgg .DefaultPixelValue !=0&&_ccgg .DefaultPixelValue !=1{return _eg .Errorf (_eggd ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_ccgg .DefaultPixelValue );
};if _ccgg .Compression !=JB2Generic {return _eg .Errorf (_eggd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};func (_cgce *PdfCrypt )isDecrypted (_agd PdfObject )bool {_ ,_cdbe :=_cgce ._fbg [_agd ];if _cdbe {_ac .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _cce :=_agd .(type ){case *PdfObjectStream :if _cgce ._ed .R !=5{if _cceb ,_feaf :=_cce .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_feaf &&*_cceb =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_cdbe =_cgce ._bbg [int (_cce .ObjectNumber )];_cdbe {return true ;};switch _egcc :=_cce .PdfObject .(type ){case *PdfObjectDictionary :_ffc :=true ;for _ ,_beg :=range _dae {if _egcc .Get (_beg )==nil {_ffc =false ;
break ;};};if _ffc {return true ;};};};_ac .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_aegg *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _cf .DecodeBytes (encoded ,_dgc .Parameters {},_aegg .Globals );};var _ggfg =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");


// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _facd (obj1 ,obj2 ,0)};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_abdg *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _cab _bb .Buffer ;for _ ,_bggf :=range data {_cab .WriteString (_fgf .Sprintf ("\u0025\u002e\u0032X\u0020",_bggf ));};_cab .WriteByte ('>');return _cab .Bytes (),nil ;};

// WriteString outputs the object as it is to be written to file.
func (_gada *PdfObjectDictionary )WriteString ()string {var _gcage _cd .Builder ;_gcage .WriteString ("\u003c\u003c");for _ ,_agfdd :=range _gada ._gggg {_aecf :=_gada ._cedfc [_agfdd ];_gcage .WriteString (_agfdd .WriteString ());_gcage .WriteString ("\u0020");
_gcage .WriteString (_aecf .WriteString ());};_gcage .WriteString ("\u003e\u003e");return _gcage .String ();};var _egad =_fg .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");


// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bcba *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_gea encryptDict ;_ed _gd .StdEncryptDict ;_bbf string ;_cffda []byte ;_fbg map[PdfObject ]bool ;_fcg map[PdfObject ]bool ;_gba bool ;_cdf cryptFilters ;_cgd string ;_gca string ;_agg *PdfParser ;_bbg map[int ]struct{};};func _ebfd (_agfdc int )int {if _agfdc < 0{return -_agfdc ;
};return _agfdc ;};func _de (_eaf PdfObject )(int64 ,int64 ,error ){if _bgf ,_cge :=_eaf .(*PdfIndirectObject );_cge {return _bgf .ObjectNumber ,_bgf .GenerationNumber ,nil ;};if _bgd ,_afg :=_eaf .(*PdfObjectStream );_afg {return _bgd .ObjectNumber ,_bgd .GenerationNumber ,nil ;
};return 0,0,_d .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};var _abfbd =_fg .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");


// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_aefg :objects };};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_adff *PdfObjectDictionary ,_adfc bool ){_adff ,_adfc =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _adff ,_adfc ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_ecb *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_acgf :=MakeDict ();_acgf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ecb .GetFilterName ()));return _acgf ;};func (_bagbe *PdfParser )skipComments ()error {if _ ,_cbde :=_bagbe .skipSpaces ();
_cbde !=nil {return _cbde ;};_dcbd :=true ;for {_aacb ,_ccfa :=_bagbe ._bgbab .Peek (1);if _ccfa !=nil {_ac .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ccfa .Error ());return _ccfa ;};if _dcbd &&_aacb [0]!='%'{return nil ;};_dcbd =false ;
if (_aacb [0]!='\r')&&(_aacb [0]!='\n'){_bagbe ._bgbab .ReadByte ();}else {break ;};};return _bagbe .skipComments ();};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// GetFilterName returns the name of the encoding filter.
func (_cfbg *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_ccfc *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ac .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_ac .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ccfc .Predictor );
_egeb ,_fafg :=_ccfc .DecodeBytes (streamObj .Stream );if _fafg !=nil {return nil ,_fafg ;};_ac .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_ac .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_egeb ),_egeb );
if _ccfc .Predictor > 1{if _ccfc .Predictor ==2{_ac .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_fga :=_ccfc .Columns *_ccfc .Colors ;if _fga < 1{return []byte {},nil ;};_cggaf :=len (_egeb )/_fga ;if len (_egeb )%_fga !=0{_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_fgf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_egeb ),_fga );};if _fga %_ccfc .Colors !=0{return nil ,_fgf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_fga ,_ccfc .Colors );
};if _fga > len (_egeb ){_ac .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fga ,len (_egeb ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ac .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_egeb ),_egeb );
_ebe :=_bb .NewBuffer (nil );for _bbde :=0;_bbde < _cggaf ;_bbde ++{_agc :=_egeb [_fga *_bbde :_fga *(_bbde +1)];for _bcbgd :=_ccfc .Colors ;_bcbgd < _fga ;_bcbgd ++{_agc [_bcbgd ]=byte (int (_agc [_bcbgd ]+_agc [_bcbgd -_ccfc .Colors ])%256);};_ebe .Write (_agc );
};_eadf :=_ebe .Bytes ();_ac .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_eadf ),_eadf );return _eadf ,nil ;}else if _ccfc .Predictor >=10&&_ccfc .Predictor <=15{_ac .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_ffda :=_ccfc .Columns *_ccfc .Colors +1;if _ffda < 1{return []byte {},nil ;};_dfbe :=len (_egeb )/_ffda ;if len (_egeb )%_ffda !=0{return nil ,_fgf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_egeb ),_ffda );
};if _ffda > len (_egeb ){_ac .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ffda ,len (_egeb ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fdfc :=_bb .NewBuffer (nil );_ac .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_ccfc .Columns );
_ac .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_egeb ),_ffda ,_dfbe );_dfe :=make ([]byte ,_ffda );for _cdgb :=0;_cdgb < _ffda ;_cdgb ++{_dfe [_cdgb ]=0;};
for _gfc :=0;_gfc < _dfbe ;_gfc ++{_eace :=_egeb [_ffda *_gfc :_ffda *(_gfc +1)];_abbc :=_eace [0];switch _abbc {case 0:case 1:for _cbb :=2;_cbb < _ffda ;_cbb ++{_eace [_cbb ]=byte (int (_eace [_cbb ]+_eace [_cbb -1])%256);};case 2:for _eged :=1;_eged < _ffda ;
_eged ++{_eace [_eged ]=byte (int (_eace [_eged ]+_dfe [_eged ])%256);};default:_ac .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_abbc );
return nil ,_fgf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_abbc );};for _fbabb :=0;_fbabb < _ffda ;_fbabb ++{_dfe [_fbabb ]=_eace [_fbabb ];};_fdfc .Write (_eace [1:]);
};_agcf :=_fdfc .Bytes ();return _agcf ,nil ;}else {_ac .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_ccfc .Predictor );
return nil ,_fgf .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_ccfc .Predictor );};};return _egeb ,nil ;};