//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_ce "bufio";_gff "bytes";_dc "compress/lzw";_gg "compress/zlib";_f "crypto/md5";_de "crypto/rand";_ag "encoding/hex";_ca "errors";_ggc "fmt";_cc "github.com/unidoc/unipdf/v3/common";_dec "github.com/unidoc/unipdf/v3/core/security";
_ba "github.com/unidoc/unipdf/v3/core/security/crypt";_cag "github.com/unidoc/unipdf/v3/internal/ccittfax";_fe "github.com/unidoc/unipdf/v3/internal/imageutil";_ee "github.com/unidoc/unipdf/v3/internal/jbig2";_fbf "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";
_gce "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_gbg "github.com/unidoc/unipdf/v3/internal/jbig2/document";_b "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_fb "github.com/unidoc/unipdf/v3/internal/strutils";_eb "golang.org/x/image/tiff/lzw";
_ge "golang.org/x/xerrors";_dd "image";_gc "image/color";_gf "image/jpeg";_ae "io";_cgb "io/ioutil";_aa "os";_cf "reflect";_e "regexp";_cg "sort";_g "strconv";_gb "strings";_a "sync";_gfb "time";_d "unicode";);

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_eagf []PdfObject ;};

// Len returns the number of elements in the streams.
func (_acef *PdfObjectStreams )Len ()int {if _acef ==nil {return 0;};return len (_acef ._eagf );};func (_gfggc *PdfParser )parseArray ()(*PdfObjectArray ,error ){_egfae :=MakeArray ();_gfggc ._dced .ReadByte ();for {_gfggc .skipSpaces ();_daacc ,_afaa :=_gfggc ._dced .Peek (1);
if _afaa !=nil {return _egfae ,_afaa ;};if _daacc [0]==']'{_gfggc ._dced .ReadByte ();break ;};_bfdcg ,_afaa :=_gfggc .parseObject ();if _afaa !=nil {return _egfae ,_afaa ;};_egfae .Append (_bfdcg );};return _egfae ,nil ;};

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_dbg ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _dbg ._ggg };

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_ddc ParserMetadata )HasEOLAfterHeader ()bool {return _ddc ._gabc };func (_ccga *PdfCrypt )securityHandler ()_dec .StdHandler {if _ccga ._bccd .R >=5{return _dec .NewHandlerR6 ();};return _dec .NewHandlerR4 (_ccga ._ccb ,_ccga ._dg .Length );};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_feddf :=TraceToDirectObject (obj ).(*PdfObjectNull );return _feddf ;};func (_ccdg *PdfParser )readComment ()(string ,error ){var _fedde _gff .Buffer ;_ ,_fdec :=_ccdg .skipSpaces ();if _fdec !=nil {return _fedde .String (),_fdec ;
};_afdb :=true ;for {_ddgg ,_cadae :=_ccdg ._dced .Peek (1);if _cadae !=nil {_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cadae .Error ());return _fedde .String (),_cadae ;};if _afdb &&_ddgg [0]!='%'{return _fedde .String (),_ca .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");
};_afdb =false ;if (_ddgg [0]!='\r')&&(_ddgg [0]!='\n'){_abbg ,_ :=_ccdg ._dced .ReadByte ();_fedde .WriteByte (_abbg );}else {break ;};};return _fedde .String (),nil ;};func (_ded *PdfCrypt )encryptBytes (_gacc []byte ,_bee string ,_gbec []byte )([]byte ,error ){_cc .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_ggca ,_beef :=_ded ._eebc [_bee ];if !_beef {return nil ,_ggc .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bee );};return _ggca .EncryptBytes (_gacc ,_gbec );};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_ceba []StreamEncoder };

// GetFilterName returns the name of the encoding filter.
func (_beg *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };func _eebd (_agba uint ,_acga ,_agcg float64 )float64 {return (_acga +(float64 (_agba )*(_agcg -_acga )/255))*255;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_gabg *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _gabg .Predictor !=1&&_gabg .Predictor !=11{_cc .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _gabg .Predictor ==11{_accg :=_gabg .Columns ;_accgb :=len (data )/_accg ;if len (data )%_accg !=0{_cc .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_ca .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_gggg :=_gff .NewBuffer (nil );_bbcb :=make ([]byte ,_accg );for _deee :=0;_deee < _accgb ;_deee ++{_eedg :=data [_accg *_deee :_accg *(_deee +1)];
_bbcb [0]=_eedg [0];for _abde :=1;_abde < _accg ;_abde ++{_bbcb [_abde ]=byte (int (_eedg [_abde ]-_eedg [_abde -1])%256);};_gggg .WriteByte (1);_gggg .Write (_bbcb );};data =_gggg .Bytes ();};var _ccgac _gff .Buffer ;_bgd :=_gg .NewWriter (&_ccgac );_bgd .Write (data );
_bgd .Close ();return _ccgac .Bytes (),nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_gbfg *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aefg :=_gff .NewReader (encoded );_bbaa ,_faag :=_gf .Decode (_aefg );if _faag !=nil {_cc .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_faag );
return nil ,_faag ;};_ceef :=_bbaa .Bounds ();var _gagg =make ([]byte ,_ceef .Dx ()*_ceef .Dy ()*_gbfg .ColorComponents *_gbfg .BitsPerComponent /8);_bedg :=0;switch _gbfg .ColorComponents {case 1:_beaf :=[]float64 {_gbfg .Decode [0],_gbfg .Decode [1]};
for _fdc :=_ceef .Min .Y ;_fdc < _ceef .Max .Y ;_fdc ++{for _fbef :=_ceef .Min .X ;_fbef < _ceef .Max .X ;_fbef ++{_ffba :=_bbaa .At (_fbef ,_fdc );if _gbfg .BitsPerComponent ==16{_ffdf ,_gca :=_ffba .(_gc .Gray16 );if !_gca {return nil ,_ca .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_cbac :=_eebd (uint (_ffdf .Y >>8),_beaf [0],_beaf [1]);_faad :=_eebd (uint (_ffdf .Y ),_beaf [0],_beaf [1]);_gagg [_bedg ]=byte (_cbac );_bedg ++;_gagg [_bedg ]=byte (_faad );_bedg ++;}else {_gbfgg ,_dece :=_ffba .(_gc .Gray );if !_dece {return nil ,_ca .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gagg [_bedg ]=byte (_eebd (uint (_gbfgg .Y ),_beaf [0],_beaf [1]));_bedg ++;};};};case 3:_bdc :=[]float64 {_gbfg .Decode [0],_gbfg .Decode [1]};_gef :=[]float64 {_gbfg .Decode [2],_gbfg .Decode [3]};_eedf :=[]float64 {_gbfg .Decode [4],_gbfg .Decode [5]};
for _faab :=_ceef .Min .Y ;_faab < _ceef .Max .Y ;_faab ++{for _ebea :=_ceef .Min .X ;_ebea < _ceef .Max .X ;_ebea ++{_fgc :=_bbaa .At (_ebea ,_faab );if _gbfg .BitsPerComponent ==16{_bgc ,_dac :=_fgc .(_gc .RGBA64 );if !_dac {return nil ,_ca .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_ggga :=_eebd (uint (_bgc .R >>8),_bdc [0],_bdc [1]);_dacc :=_eebd (uint (_bgc .R ),_bdc [0],_bdc [1]);_bbgg :=_eebd (uint (_bgc .G >>8),_gef [0],_gef [1]);_debec :=_eebd (uint (_bgc .G ),_gef [0],_gef [1]);_geed :=_eebd (uint (_bgc .B >>8),_eedf [0],_eedf [1]);
_gfed :=_eebd (uint (_bgc .B ),_eedf [0],_eedf [1]);_gagg [_bedg ]=byte (_ggga );_bedg ++;_gagg [_bedg ]=byte (_dacc );_bedg ++;_gagg [_bedg ]=byte (_bbgg );_bedg ++;_gagg [_bedg ]=byte (_debec );_bedg ++;_gagg [_bedg ]=byte (_geed );_bedg ++;_gagg [_bedg ]=byte (_gfed );
_bedg ++;}else {_fage ,_ffbc :=_fgc .(_gc .RGBA );if _ffbc {_fefb :=_eebd (uint (_fage .R ),_bdc [0],_bdc [1]);_dgb :=_eebd (uint (_fage .G ),_gef [0],_gef [1]);_acd :=_eebd (uint (_fage .B ),_eedf [0],_eedf [1]);_gagg [_bedg ]=byte (_fefb );_bedg ++;_gagg [_bedg ]=byte (_dgb );
_bedg ++;_gagg [_bedg ]=byte (_acd );_bedg ++;}else {_geb ,_gfc :=_fgc .(_gc .YCbCr );if !_gfc {return nil ,_ca .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_dcfe ,_bde ,_gecc ,_ :=_geb .RGBA ();_dgf :=_eebd (uint (_dcfe >>8),_bdc [0],_bdc [1]);
_daac :=_eebd (uint (_bde >>8),_gef [0],_gef [1]);_aeb :=_eebd (uint (_gecc >>8),_eedf [0],_eedf [1]);_gagg [_bedg ]=byte (_dgf );_bedg ++;_gagg [_bedg ]=byte (_daac );_bedg ++;_gagg [_bedg ]=byte (_aeb );_bedg ++;};};};};case 4:_affe :=[]float64 {_gbfg .Decode [0],_gbfg .Decode [1]};
_gbdg :=[]float64 {_gbfg .Decode [2],_gbfg .Decode [3]};_adc :=[]float64 {_gbfg .Decode [4],_gbfg .Decode [5]};_dba :=[]float64 {_gbfg .Decode [6],_gbfg .Decode [7]};for _ebb :=_ceef .Min .Y ;_ebb < _ceef .Max .Y ;_ebb ++{for _afc :=_ceef .Min .X ;_afc < _ceef .Max .X ;
_afc ++{_ebgb :=_bbaa .At (_afc ,_ebb );_fbfbd ,_fed :=_ebgb .(_gc .CMYK );if !_fed {return nil ,_ca .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fcbd :=255-_eebd (uint (_fbfbd .C ),_affe [0],_affe [1]);
_bfed :=255-_eebd (uint (_fbfbd .M ),_gbdg [0],_gbdg [1]);_ccfc :=255-_eebd (uint (_fbfbd .Y ),_adc [0],_adc [1]);_ddeca :=255-_eebd (uint (_fbfbd .K ),_dba [0],_dba [1]);_gagg [_bedg ]=byte (_fcbd );_bedg ++;_gagg [_bedg ]=byte (_bfed );_bedg ++;_gagg [_bedg ]=byte (_ccfc );
_bedg ++;_gagg [_bedg ]=byte (_ddeca );_bedg ++;};};};return _gagg ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gaga *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_bfdc :=MakeDict ();_bfdc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gaga .GetFilterName ()));return _bfdc ;};func _aabb (_gefgb ,_deaeg PdfObject ,_gagdg int )bool {if _gagdg > _faabe {_cc .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_faabe );
return false ;};if _gefgb ==nil &&_deaeg ==nil {return true ;}else if _gefgb ==nil ||_deaeg ==nil {return false ;};if _cf .TypeOf (_gefgb )!=_cf .TypeOf (_deaeg ){return false ;};switch _dbcf :=_gefgb .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_dbcf ==*(_deaeg .(*PdfObjectName ));case *PdfObjectString :return *_dbcf ==*(_deaeg .(*PdfObjectString ));case *PdfObjectInteger :return *_dbcf ==*(_deaeg .(*PdfObjectInteger ));case *PdfObjectBool :return *_dbcf ==*(_deaeg .(*PdfObjectBool ));
case *PdfObjectFloat :return *_dbcf ==*(_deaeg .(*PdfObjectFloat ));case *PdfIndirectObject :return _aabb (TraceToDirectObject (_gefgb ),TraceToDirectObject (_deaeg ),_gagdg +1);case *PdfObjectArray :_dffa :=_deaeg .(*PdfObjectArray );if len ((*_dbcf )._gcgad )!=len ((*_dffa )._gcgad ){return false ;
};for _ccfbb ,_bdec :=range (*_dbcf )._gcgad {if !_aabb (_bdec ,(*_dffa )._gcgad [_ccfbb ],_gagdg +1){return false ;};};return true ;case *PdfObjectDictionary :_eecd :=_deaeg .(*PdfObjectDictionary );_bfgd ,_bbccc :=(*_dbcf )._cdebe ,(*_eecd )._cdebe ;
if len (_bfgd )!=len (_bbccc ){return false ;};for _egce ,_dacac :=range _bfgd {_gbcec ,_bdgge :=_bbccc [_egce ];if !_bdgge ||!_aabb (_dacac ,_gbcec ,_gagdg +1){return false ;};};return true ;case *PdfObjectStream :_dafcb :=_deaeg .(*PdfObjectStream );
return _aabb ((*_dbcf ).PdfObjectDictionary ,(*_dafcb ).PdfObjectDictionary ,_gagdg +1);default:_cc .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_gefgb );
};return false ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _ae .ReadSeeker )(*PdfParser ,error ){_fefgg :=&PdfParser {_bbdc :rs ,ObjCache :make (objectCache ),_debg :map[int64 ]bool {},_gfbd :make ([]int64 ,0),_dbag :make (map[*PdfParser ]*PdfParser )};_edcag ,_fbdbb ,_gdfga :=_fefgg .parsePdfVersion ();
if _gdfga !=nil {_cc .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_gdfga );return nil ,_gdfga ;};_fefgg ._beeag .Major =_edcag ;_fefgg ._beeag .Minor =_fbdbb ;
if _fefgg ._cege ,_gdfga =_fefgg .loadXrefs ();_gdfga !=nil {_cc .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_gdfga );return nil ,_gdfga ;
};_cc .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_fefgg ._cege );_bgfg ,_gdfga :=_fefgg .parseLinearizedDictionary ();if _gdfga !=nil {return nil ,_gdfga ;};if _bgfg !=nil {_fefgg ._cebe ,_gdfga =_fefgg .checkLinearizedInformation (_bgfg );
if _gdfga !=nil {return nil ,_gdfga ;};};if len (_fefgg ._daea .ObjectMap )==0{return nil ,_ggc .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};_fefgg ._dcbdf =len (_fefgg ._gfbd );if _fefgg ._cebe &&_fefgg ._dcbdf !=0{_fefgg ._dcbdf --;};_fefgg ._bbad =make ([]*PdfParser ,_fefgg ._dcbdf );return _fefgg ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fgeda *PdfObjectInteger )WriteString ()string {return _g .FormatInt (int64 (*_fgeda ),10)};

// SetImage sets the image base for given flate encoder.
func (_fbed *FlateEncoder )SetImage (img *_fe .ImageBase ){_fbed ._cfdg =img };var _bbd =_e .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// GetFilterName returns the name of the encoding filter.
func (_effe *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_cfga *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_fefd :=MakeDict ();_fefd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cfga .GetFilterName ()));return _fefd ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_bgaga *PdfParser )IsAuthenticated ()bool {return _bgaga ._bcgf ._efe };const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ggfa *RawEncoder )MakeDecodeParams ()PdfObject {return nil };type offsetReader struct{_dafec _ae .ReadSeeker ;_dafcg int64 ;};func (_cac *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_bfea :=MakeDict ();_bfea .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));
_bfea .Set ("\u0056",MakeInteger (int64 (_cac ._dg .V )));_bfea .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_cac ._dg .Length )));return _bfea ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_ggcda *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ee .DecodeBytes (encoded ,_gce .Parameters {},_ggcda .Globals );};type objectCache map[int ]PdfObject ;

// UpdateParams updates the parameter values of the encoder.
func (_deae *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _aabc ,_ggaf :=GetNumberAsInt64 (params .Get ("\u004b"));_ggaf ==nil {_deae .K =int (_aabc );};if _bafg ,_dgee :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_dgee ==nil {_deae .Columns =int (_bafg );}else if _bafg ,_dgee =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_dgee ==nil {_deae .Columns =int (_bafg );};if _gbffb ,_cfcc :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_cfcc ==nil {_deae .BlackIs1 =_gbffb > 0;}else {if _baca ,_affa :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_affa {_deae .BlackIs1 =_baca ;}else {if _bcec ,_egfad :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_egfad {_ccce ,_eaad :=_bcec .ToIntegerArray ();if _eaad ==nil {_deae .BlackIs1 =_ccce [0]==1&&_ccce [1]==0;};};};};if _fbcdf ,_dcbc :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_dcbc ==nil {_deae .EncodedByteAlign =_fbcdf > 0;}else {if _bacde ,_ggab :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ggab {_deae .EncodedByteAlign =_bacde ;};};if _dbcd ,_ccbc :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_ccbc ==nil {_deae .EndOfLine =_dbcd > 0;}else {if _gdac ,_dfec :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_dfec {_deae .EndOfLine =_gdac ;};};if _badfg ,_bfbcd :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_bfbcd ==nil {_deae .Rows =int (_badfg );}else if _badfg ,_bfbcd =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_bfbcd ==nil {_deae .Rows =int (_badfg );};if _fdfb ,_cage :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_cage ==nil {_deae .EndOfBlock =_fdfb > 0;}else {if _gfceb ,_agag :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_agag {_deae .EndOfBlock =_gfceb ;};};if _ffeff ,_gabbd :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_gabbd !=nil {_deae .DamagedRowsBeforeError =int (_ffeff );};};

// String returns a string representation of the *PdfObjectString.
func (_aceae *PdfObjectString )String ()string {return _aceae ._abcf };

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dbea *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_ebbd *PdfParser )GetCrypter ()*PdfCrypt {return _ebbd ._bcgf };

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_dead *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dead .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_fbad *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _gaggf []int64 ;for _ ,_bgff :=range _fbad .Elements (){if _gedfc ,_eaeae :=_bgff .(*PdfObjectInteger );_eaeae {_gaggf =append (_gaggf ,int64 (*_gedfc ));}else {return nil ,ErrTypeError ;
};};return _gaggf ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gbcf *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_gade :=range _gbcf ._ceba {_gade .UpdateParams (params );};};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_efcea *PdfObjectStream ,_gbgd bool ){obj =ResolveReference (obj );_efcea ,_gbgd =obj .(*PdfObjectStream );return _efcea ,_gbgd ;};func (_abca *PdfParser )parseXrefStream (_eegeg *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _eegeg !=nil {_cc .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_eegeg );
_abca ._bbdc .Seek (int64 (*_eegeg ),_ae .SeekStart );_abca ._dced =_ce .NewReader (_abca ._bbdc );};_dceef :=_abca .GetFileOffset ();_bgbd ,_gceab :=_abca .ParseIndirectObject ();if _gceab !=nil {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_ca .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_cc .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_bgbd );
_cdff ,_geaf :=_bgbd .(*PdfObjectStream );if !_geaf {_cc .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_ca .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_fcce :=_cdff .PdfObjectDictionary ;
_edg ,_geaf :=_cdff .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_geaf {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_ca .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_edg )> 8388607{_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_edg );
return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_defg :=_cdff .PdfObjectDictionary .Get ("\u0057");_gabcd ,_geaf :=_defg .(*PdfObjectArray );if !_geaf {return nil ,_ca .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_bcfea :=_gabcd .Len ();if _bcfea !=3{_cc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_bcfea );
return nil ,_ca .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _agdae []int64 ;for _gddaa :=0;_gddaa < 3;
_gddaa ++{_dddf ,_aabae :=GetInt (_gabcd .Get (_gddaa ));if !_aabae {return nil ,_ca .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_agdae =append (_agdae ,int64 (*_dddf ));};_adga ,_gceab :=DecodeStream (_cdff );
if _gceab !=nil {_cc .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_gceab );return nil ,_gceab ;};_bafb :=int (_agdae [0]);
_aacd :=int (_agdae [0]+_agdae [1]);_eead :=int (_agdae [0]+_agdae [1]+_agdae [2]);_bdda :=int (_agdae [0]+_agdae [1]+_agdae [2]);if _bafb < 0||_aacd < 0||_eead < 0{_cc .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_bafb ,_aacd ,_eead );
return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _bdda ==0{_cc .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _fcce ,nil ;};_ccadb :=len (_adga )/_bdda ;_cgcc :=0;_fcad :=_cdff .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _dcaga []int ;if _fcad !=nil {_cc .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_fcad );_abdc ,_bfead :=_fcad .(*PdfObjectArray );
if !_bfead {_cc .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_ca .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _abdc .Len ()%2!=0{_cc .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cgcc =0;_gdcc ,_bddad :=_abdc .ToIntegerArray ();if _bddad !=nil {_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_bddad );
return nil ,_bddad ;};for _ccab :=0;_ccab < len (_gdcc );_ccab +=2{_dbgbe :=_gdcc [_ccab ];_aece :=_gdcc [_ccab +1];for _gcbc :=0;_gcbc < _aece ;_gcbc ++{_dcaga =append (_dcaga ,_dbgbe +_gcbc );};_cgcc +=_aece ;};}else {for _ebba :=0;_ebba < int (*_edg );
_ebba ++{_dcaga =append (_dcaga ,_ebba );};_cgcc =int (*_edg );};if _ccadb ==_cgcc +1{_cc .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_cbbb :=_cgcc -1;for _ ,_gddca :=range _dcaga {if _gddca > _cbbb {_cbbb =_gddca ;};};_dcaga =append (_dcaga ,_cbbb +1);_cgcc ++;};if _ccadb !=len (_dcaga ){_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_ccadb ,len (_dcaga ));
return nil ,_ca .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_cc .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_cgcc );
_cc .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_dcaga );_eedb :=func (_fdef []byte )int64 {var _cffff int64 ;for _gdad :=0;_gdad < len (_fdef );_gdad ++{_cffff +=int64 (_fdef [_gdad ])*(1<<uint (8*(len (_fdef )-_gdad -1)));
};return _cffff ;};_cc .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_adga ));_gadaa :=0;for _afgf :=0;_afgf < len (_adga );_afgf +=_bdda {_gcacf :=_cdad (len (_adga ),_afgf ,_afgf +_bafb );
if _gcacf !=nil {_cc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_gcacf );return nil ,_gcacf ;};_dfeg :=_adga [_afgf :_afgf +_bafb ];_gcacf =_cdad (len (_adga ),_afgf +_bafb ,_afgf +_aacd );
if _gcacf !=nil {_cc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_gcacf );return nil ,_gcacf ;};_bbfcd :=_adga [_afgf +_bafb :_afgf +_aacd ];_gcacf =_cdad (len (_adga ),_afgf +_aacd ,_afgf +_eead );
if _gcacf !=nil {_cc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_gcacf );return nil ,_gcacf ;};_dbae :=_adga [_afgf +_aacd :_afgf +_eead ];_fggb :=_eedb (_dfeg );
_daca :=_eedb (_bbfcd );_ecdc :=_eedb (_dbae );if _agdae [0]==0{_fggb =1;};if _gadaa >=len (_dcaga ){_cc .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_beadc :=_dcaga [_gadaa ];_gadaa ++;_cc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_beadc ,_dfeg );_cc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_beadc ,_bbfcd );_cc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_beadc ,_dbae );
_cc .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_beadc ,_fggb ,_daca ,_ecdc );if _fggb ==0{_cc .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _fggb ==1{_cc .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_bbfcd );if _daca ==_dceef {_cc .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_beadc ,_cdff .ObjectNumber );
_beadc =int (_cdff .ObjectNumber );};if _ffcc ,_edgg :=_abca ._daea .ObjectMap [_beadc ];!_edgg ||int (_ecdc )> _ffcc .Generation {_ccbd :=XrefObject {ObjectNumber :_beadc ,XType :XrefTypeTableEntry ,Offset :_daca ,Generation :int (_ecdc )};_abca ._daea .ObjectMap [_beadc ]=_ccbd ;
};}else if _fggb ==2{_cc .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_ecgd :=_abca ._daea .ObjectMap [_beadc ];!_ecgd {_caeeb :=XrefObject {ObjectNumber :_beadc ,XType :XrefTypeObjectStream ,OsObjNumber :int (_daca ),OsObjIndex :int (_ecdc )};
_abca ._daea .ObjectMap [_beadc ]=_caeeb ;_cc .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_caeeb );};}else {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _abca ._fefbf ==nil {_agdge :=XrefTypeObjectStream ;_abca ._fefbf =&_agdge ;};return _fcce ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_bcbf *PdfObjectFloat )WriteString ()string {return _g .FormatFloat (float64 (*_bcbf ),'f',-1,64);};func _fefe (_bbed _ae .ReadSeeker ,_gfbbd int64 )(*offsetReader ,error ){_ecfb :=&offsetReader {_dafec :_bbed ,_dafcg :_gfbbd };_ ,_ffefd :=_ecfb .Seek (0,_ae .SeekStart );
return _ecfb ,_ffefd ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};func _ebgbe (_ced _ae .ReadSeeker ,_acdf int64 )(*limitedReadSeeker ,error ){_ ,_ccffa :=_ced .Seek (0,_ae .SeekStart );if _ccffa !=nil {return nil ,_ccffa ;};return &limitedReadSeeker {_aaca :_ced ,_ffbdf :_acdf },nil ;};

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_gbfe *PdfParser )GetPreviousRevisionParser ()(*PdfParser ,error ){if _gbfe ._dcbdf ==0{return nil ,_ca .New ("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e");};if _gdcce ,_gebf :=_gbfe ._dbag [_gbfe ];
_gebf {return _gdcce ,nil ;};_fgbgba ,_adaaa :=_gbfe .GetPreviousRevisionReadSeeker ();if _adaaa !=nil {return nil ,_adaaa ;};_dcfb ,_adaaa :=NewParser (_fgbgba );_dcfb ._dbag =_gbfe ._dbag ;if _adaaa !=nil {return nil ,_adaaa ;};_gbfe ._dbag [_gbfe ]=_dcfb ;
return _dcfb ,nil ;};func _bffd (_beea *PdfObjectStream )(*MultiEncoder ,error ){_fdcc :=NewMultiEncoder ();_fdff :=_beea .PdfObjectDictionary ;if _fdff ==nil {return _fdcc ,nil ;};var _edcf *PdfObjectDictionary ;var _bebg []PdfObject ;_cebcf :=_fdff .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
if _cebcf !=nil {_gad ,_bdcg :=_cebcf .(*PdfObjectDictionary );if _bdcg {_edcf =_gad ;};_fbdb ,_fgda :=_cebcf .(*PdfObjectArray );if _fgda {for _ ,_ccfd :=range _fbdb .Elements (){_ccfd =TraceToDirectObject (_ccfd );if _gaafg ,_babg :=_ccfd .(*PdfObjectDictionary );
_babg {_bebg =append (_bebg ,_gaafg );}else {_bebg =append (_bebg ,MakeDict ());};};};};_cebcf =_fdff .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _cebcf ==nil {return nil ,_ggc .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");
};_gcbg ,_dcgb :=_cebcf .(*PdfObjectArray );if !_dcgb {return nil ,_ggc .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _gcea ,_fccd :=range _gcbg .Elements (){_gfggb ,_adff :=_fccd .(*PdfObjectName );if !_adff {return nil ,_ggc .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _fgfb PdfObject ;if _edcf !=nil {_fgfb =_edcf ;}else {if len (_bebg )> 0{if _gcea >=len (_bebg ){return nil ,_ggc .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_fgfb =_bebg [_gcea ];};};var _cgee *PdfObjectDictionary ;if _cgad ,_gcf :=_fgfb .(*PdfObjectDictionary );_gcf {_cgee =_cgad ;};_cc .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_gfggb ,_fgfb ,_cgee );
if *_gfggb ==StreamEncodingFilterNameFlate {_deeee ,_fgff :=_ddec (_beea ,_cgee );if _fgff !=nil {return nil ,_fgff ;};_fdcc .AddEncoder (_deeee );}else if *_gfggb ==StreamEncodingFilterNameLZW {_face ,_befc :=_beae (_beea ,_cgee );if _befc !=nil {return nil ,_befc ;
};_fdcc .AddEncoder (_face );}else if *_gfggb ==StreamEncodingFilterNameASCIIHex {_dega :=NewASCIIHexEncoder ();_fdcc .AddEncoder (_dega );}else if *_gfggb ==StreamEncodingFilterNameASCII85 {_bccef :=NewASCII85Encoder ();_fdcc .AddEncoder (_bccef );}else if *_gfggb ==StreamEncodingFilterNameDCT {_aeg ,_eafbf :=_fdea (_beea ,_fdcc );
if _eafbf !=nil {return nil ,_eafbf ;};_fdcc .AddEncoder (_aeg );_cc .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_cc .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_fdcc );
}else if *_gfggb ==StreamEncodingFilterNameCCITTFax {_cacf ,_cggd :=_egfb (_beea ,_cgee );if _cggd !=nil {return nil ,_cggd ;};_fdcc .AddEncoder (_cacf );}else {_cc .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_gfggb );
return nil ,_ggc .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _fdcc ,nil ;};func (_dfdf *ASCII85Encoder )base256Tobase85 (_gege uint32 )[5]byte {_deed :=[5]byte {0,0,0,0,0};
_fdfe :=_gege ;for _aeec :=0;_aeec < 5;_aeec ++{_ggbg :=uint32 (1);for _dddbd :=0;_dddbd < 4-_aeec ;_dddbd ++{_ggbg *=85;};_dgef :=_fdfe /_ggbg ;_fdfe =_fdfe %_ggbg ;_deed [_aeec ]=byte (_dgef );};return _deed ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_aacab *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_bbbb :=_gff .NewReader ([]byte (txt ));_cdbea :=&PdfParser {ObjCache :objectCache {},_bbdc :_bbbb ,_dced :_ce .NewReader (_bbbb ),_ddgd :int64 (len (txt )),_debg :map[int64 ]bool {},_dbag :make (map[*PdfParser ]*PdfParser )};
_cdbea ._daea .ObjectMap =make (map[int ]XrefObject );return _cdbea ;};var _eeef =_e .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_faaa *JBIG2Encoder )Encode ()(_becad []byte ,_fca error ){const _cdba ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _faaa ._degb ==nil {return nil ,_b .Errorf (_cdba ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_faaa ._degb .FullHeaders =_faaa .DefaultPageSettings .FileMode ;_becad ,_fca =_faaa ._degb .Encode ();if _fca !=nil {return nil ,_b .Wrap (_fca ,_cdba ,"");};return _becad ,nil ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_bafe *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_bafe .setWithLock (key ,val ,true );};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_ebfc :=PdfObjectName (s );return &_ebfc };

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_degb *_gbg .Document ;

// Globals are the JBIG2 global segments.
Globals _ee .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_badag *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_gada :=data ;var _cecga error ;for _ebcd :=len (_badag ._ceba )-1;_ebcd >=0;_ebcd --{_abaa :=_badag ._ceba [_ebcd ];_gada ,_cecga =_abaa .EncodeBytes (_gada );if _cecga !=nil {return nil ,_cecga ;
};};return _gada ,nil ;};var (ErrUnsupportedEncodingParameters =_ca .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_ca .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_ca .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_ca .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_ca .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_ca .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_ge .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_ca .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);func _egbb (_bcee string )(PdfObjectReference ,error ){_daec :=PdfObjectReference {};_fgcae :=_fgbf .FindStringSubmatch (_bcee );if len (_fgcae )< 3{_cc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
return _daec ,_ca .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_ggcaea ,_ :=_g .Atoi (_fgcae [1]);_gbde ,_ :=_g .Atoi (_fgcae [2]);_daec .ObjectNumber =int64 (_ggcaea );
_daec .GenerationNumber =int64 (_gbde );return _daec ,nil ;};func (_gfbf *PdfCrypt )authenticate (_gda []byte )(bool ,error ){_gfbf ._efe =false ;_dafc :=_gfbf .securityHandler ();_fece ,_db ,_bbb :=_dafc .Authenticate (&_gfbf ._bccd ,_gda );if _bbb !=nil {return false ,_bbb ;
}else if _db ==0||len (_fece )==0{return false ,nil ;};_gfbf ._efe =true ;_gfbf ._fgfa =_fece ;return true ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_edea *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_bga :=MakeDict ();_bga .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_edea .GetFilterName ()));_bga .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_edea .MakeDecodeParams ());
return _bga ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_afbgd int ,_bfab bool ){_ccbae ,_bfab :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _bfab &&_ccbae !=nil {return int (*_ccbae ),true ;};return 0,false ;};var _adffg =_e .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");


// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;type objectStreams map[int ]objectStream ;func _baeg (_ebgbf _fe .Image )*JBIG2Image {_gaac :=_ebgbf .Base ();return &JBIG2Image {Data :_gaac .Data ,Width :_gaac .Width ,Height :_gaac .Height ,HasPadding :true };};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_cfddc float64 ,_ebdfe bool ){_bdfd ,_ebdfe :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _ebdfe {return float64 (*_bdfd ),true ;};return 0,false ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_cbadg :=PdfObjectInteger (val );return &_cbadg };

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_bggc *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dgba :=encoded ;var _cef error ;for _ ,_ggee :=range _bggc ._ceba {_cc .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_ggee ,_ggee );
_dgba ,_cef =_ggee .DecodeBytes (_dgba );if _cef !=nil {return nil ,_cef ;};};return _dgba ,nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_cbc :=&PdfCrypt {_efe :false ,_dce :make (map[PdfObject ]bool ),_cfa :make (map[PdfObject ]bool ),_gbee :make (map[int ]struct{}),_ece :parser };_gfa ,_bdb :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_bdb {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _cbc ,_ca .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_gfa !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_cc .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_gfa );
return _cbc ,_ca .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_cbc ._dg .Filter =string (*_gfa );if _ecad ,_daad :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_daad {_cbc ._dg .SubFilter =_ecad .Str ();
_cc .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_ecad );};if L ,_geef :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_geef {if (*L %8)!=0{_cc .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _cbc ,_ca .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_cbc ._dg .Length =int (*L );}else {_cbc ._dg .Length =40;};_cbc ._dg .V =0;if _cagg ,_aba :=ed .Get ("\u0056").(*PdfObjectInteger );
_aba {V :=int (*_cagg );_cbc ._dg .V =V ;if V >=1&&V <=2{_cbc ._eebc =_aae (_cbc ._dg .Length );}else if V >=4&&V <=5{if _fea :=_cbc .loadCryptFilters (ed );_fea !=nil {return _cbc ,_fea ;};}else {_cc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _cbc ,_ca .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _fgbd :=_cdd (&_cbc ._bccd ,ed );_fgbd !=nil {return _cbc ,_fgbd ;};_gdfe :="";if _dea ,_dee :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_dee &&_dea .Len ()>=1{_fge ,_fcd :=GetString (_dea .Get (0));if !_fcd {return _cbc ,_ca .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_gdfe =_fge .Str ();}else {_cc .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_cbc ._ccb =_gdfe ;return _cbc ,nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_gded *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_cabe :=range another .Keys (){_aedee :=another .Get (_cabe );_gded .Set (_cabe ,_aedee );};};return _gded ;};func (_eag *PdfParser )parseDetailedHeader ()(_dddd error ){_eag ._bbdc .Seek (0,_ae .SeekStart );
_eag ._dced =_ce .NewReader (_eag ._bbdc );_gabb :=20;_cbe :=make ([]byte ,_gabb );var (_fdd bool ;_cafa int ;);for {_gfd ,_faee :=_eag ._dced .ReadByte ();if _faee !=nil {if _faee ==_ae .EOF {break ;}else {return _faee ;};};if IsDecimalDigit (_gfd )&&_cbe [_gabb -1]=='.'&&IsDecimalDigit (_cbe [_gabb -2])&&_cbe [_gabb -3]=='-'&&_cbe [_gabb -4]=='F'&&_cbe [_gabb -5]=='D'&&_cbe [_gabb -6]=='P'&&_cbe [_gabb -7]=='%'{_eag ._beeag =Version {Major :int (_cbe [_gabb -2]-'0'),Minor :int (_gfd -'0')};
_eag ._ggcdd ._fef =_cafa -7;_fdd =true ;break ;};_cafa ++;_cbe =append (_cbe [1:_gabb ],_gfd );};if !_fdd {return _ggc .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_fcfb ,_dddd :=_eag ._dced .ReadByte ();
if _dddd ==_ae .EOF {return _ggc .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _dddd !=nil {return _dddd ;};_eag ._ggcdd ._gabc =_fcfb =='\n';_fcfb ,_dddd =_eag ._dced .ReadByte ();
if _dddd !=nil {return _ggc .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_dddd );};if _fcfb !='%'{return nil ;};_ecdb :=make ([]byte ,4);
_ ,_dddd =_eag ._dced .Read (_ecdb );if _dddd !=nil {return _ggc .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_dddd );};_eag ._ggcdd ._fcda =[4]byte {_ecdb [0],_ecdb [1],_ecdb [2],_ecdb [3]};
return nil ;};

// String returns a descriptive information string about the encryption method used.
func (_daf *PdfCrypt )String ()string {if _daf ==nil {return "";};_efb :=_daf ._dg .Filter +"\u0020\u002d\u0020";if _daf ._dg .V ==0{_efb +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _daf ._dg .V ==1{_efb +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _daf ._dg .V ==2{_efb +=_ggc .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_daf ._dg .Length );}else if _daf ._dg .V ==3{_efb +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _daf ._dg .V >=4{_efb +=_ggc .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_daf ._gcd ,_daf ._bad );
_efb +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _baa ,_fbfa :=range _daf ._eebc {_efb +=_ggc .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_baa ,_fbfa .Name (),_fbfa .KeyLength ());
};};_gdd :=_daf .GetAccessPermissions ();_efb +=_ggc .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_gdd );return _efb ;};

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _ae .ReadSeeker )(_afge *PdfParser ,_ebg error ){_afge =&PdfParser {_bbdc :rs ,ObjCache :make (objectCache ),_debg :map[int64 ]bool {},_cgaa :true ,_dbag :make (map[*PdfParser ]*PdfParser )};if _ebg =_afge .parseDetailedHeader ();
_ebg !=nil {return nil ,_ebg ;};if _afge ._cege ,_ebg =_afge .loadXrefs ();_ebg !=nil {_cc .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_ebg );
return nil ,_ebg ;};_cc .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_afge ._cege );if len (_afge ._daea .ObjectMap )==0{return nil ,_ggc .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _afge ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cgeeb *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_bcgeb *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_dfc :=MakeDict ();_dfc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bcgeb .GetFilterName ()));_eege :=_bcgeb .MakeDecodeParams ();if _eege !=nil {_dfc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_eege );
};return _dfc ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gfbfb *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };func (_eae *PdfCrypt )generateParams (_cgg ,_agcc []byte )error {_fbe :=_eae .securityHandler ();_bba ,_gafd :=_fbe .GenerateParams (&_eae ._bccd ,_agcc ,_cgg );if _gafd !=nil {return _gafd ;
};_eae ._fgfa =_bba ;return nil ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_ccbcc *PdfParser )GetTrailer ()*PdfObjectDictionary {return _ccbcc ._cege };

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bcgec Version )String ()string {return _ggc .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_bcgec .Major ,_bcgec .Minor );};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_bgdc *PdfObjectStreams )Elements ()[]PdfObject {if _bgdc ==nil {return nil ;};return _bgdc ._eagf ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fdbe *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ba .Filter ,userPass ,ownerPass []byte ,perm _dec .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_afee :=&PdfCrypt {_cfa :make (map[PdfObject ]bool ),_eebc :make (cryptFilters ),_bccd :_dec .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _bab Version ;if cf !=nil {_cca :=cf .PDFVersion ();_bab .Major ,_bab .Minor =_cca [0],_cca [1];V ,R :=cf .HandlerVersion ();_afee ._dg .V =V ;_afee ._bccd .R =R ;_afee ._dg .Length =cf .KeyLength ()*8;};const (_gffc =_gee ;);_afee ._eebc [_gffc ]=cf ;
if _afee ._dg .V >=4{_afee ._gcd =_gffc ;_afee ._bad =_gffc ;};_bbc :=_afee .newEncryptDict ();_ede :=_f .Sum ([]byte (_gfb .Now ().Format (_gfb .RFC850 )));_ggad :=string (_ede [:]);_cgc :=make ([]byte ,100);_de .Read (_cgc );_ede =_f .Sum (_cgc );_eef :=string (_ede [:]);
_cc .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_cgc );_cc .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_ggad );_afee ._ccb =_ggad ;_dcaa :=_afee .generateParams (userPass ,ownerPass );
if _dcaa !=nil {return nil ,nil ,_dcaa ;};_bada (&_afee ._bccd ,_bbc );if _afee ._dg .V >=4{if _fbfb :=_afee .saveCryptFilters (_bbc );_fbfb !=nil {return nil ,nil ,_fbfb ;};};return _afee ,&EncryptInfo {Version :_bab ,Encrypt :_bbc ,ID0 :_ggad ,ID1 :_eef },nil ;
};var _edcd =_e .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_fef int ;_gabc bool ;_fcda [4]byte ;_cdde bool ;_edc bool ;_fcde bool ;_fcb bool ;_cafe bool ;_ggg bool ;};func (_becf *PdfCrypt )isDecrypted (_beca PdfObject )bool {_ ,_dcbd :=_becf ._dce [_beca ];if _dcbd {_cc .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};switch _fee :=_beca .(type ){case *PdfObjectStream :if _becf ._bccd .R !=5{if _gbbg ,_feg :=_fee .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_feg &&*_gbbg =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_dcbd =_becf ._gbee [int (_fee .ObjectNumber )];
_dcbd {return true ;};switch _gaf :=_fee .PdfObject .(type ){case *PdfObjectDictionary :_bdd :=true ;for _ ,_fdb :=range _afa {if _gaf .Get (_fdb )==nil {_bdd =false ;break ;};};if _bdd {return true ;};};};_cc .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_cgccc :=MakeArray ();for _ ,_cgefde :=range vals {_cgccc .Append (MakeInteger (int64 (_cgefde )));};return _cgccc ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gcee *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_feabb :=MakeDict ();_feabb .Set ("\u004b",MakeInteger (int64 (_gcee .K )));_feabb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gcee .Columns )));if _gcee .BlackIs1 {_feabb .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_gcee .BlackIs1 ));
};if _gcee .EncodedByteAlign {_feabb .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_gcee .EncodedByteAlign ));};if _gcee .EndOfLine &&_gcee .K >=0{_feabb .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_gcee .EndOfLine ));
};if _gcee .Rows !=0&&!_gcee .EndOfBlock {_feabb .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_gcee .Rows )));};if !_gcee .EndOfBlock {_feabb .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_gcee .EndOfBlock ));};
if _gcee .DamagedRowsBeforeError !=0{_feabb .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_gcee .DamagedRowsBeforeError )));};return _feabb ;};var _egdb =_e .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");


// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _ddcab ,_afeca :=obj .(*PdfObjectReference );_afeca {return _ddcab .Resolve ();};return obj ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_cc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_dbec ,_eaaf :=NewEncoderFromStream (streamObj );if _eaaf !=nil {_cc .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_eaaf );
return _eaaf ;};if _cggf ,_bdbg :=_dbec .(*LZWEncoder );_bdbg {_cggf .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_cc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_dbec );
_gdbe ,_eaaf :=_dbec .EncodeBytes (streamObj .Stream );if _eaaf !=nil {_cc .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_eaaf );return _eaaf ;
};streamObj .Stream =_gdbe ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gdbe ))));return nil ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};func _cfg (_gbe PdfObject )(int64 ,int64 ,error ){if _dcf ,_bce :=_gbe .(*PdfIndirectObject );_bce {return _dcf .ObjectNumber ,_dcf .GenerationNumber ,nil ;};if _geg ,_cb :=_gbe .(*PdfObjectStream );_cb {return _geg .ObjectNumber ,_geg .GenerationNumber ,nil ;
};return 0,0,_ca .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// MakeLazy create temporary file for stream to reduce memory usage.
// It can be used for creating PDF with many images.
// Temporary files are removed automatically when Write/WriteToFile is called for creator object.
func (_cbba *PdfObjectStream )MakeLazy ()error {if _cbba .Lazy {return nil ;};_gage ,_ddga :=_aa .CreateTemp ("","\u0078o\u0062\u006a\u0065\u0063\u0074");if _ddga !=nil {return _ddga ;};defer _gage .Close ();_ ,_ddga =_gage .Write (_cbba .Stream );if _ddga !=nil {return _ddga ;
};_cbba .Lazy =true ;_cbba .Stream =nil ;_cbba .TempFile =_gage .Name ();return nil ;};func _fedd (_bdae int )int {_ebaa :=_bdae >>(_acea -1);return (_bdae ^_ebaa )-_ebaa };func (_ebae *PdfParser )readTextLine ()(string ,error ){var _fgae _gff .Buffer ;
for {_fdbf ,_acedb :=_ebae ._dced .Peek (1);if _acedb !=nil {_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_acedb .Error ());return _fgae .String (),_acedb ;};if (_fdbf [0]!='\r')&&(_fdbf [0]!='\n'){_fdga ,_ :=_ebae ._dced .ReadByte ();
_fgae .WriteByte (_fdga );}else {break ;};};return _fgae .String (),nil ;};func _afec (_ccdd ,_fgad ,_fagb uint8 )uint8 {_ebfe :=int (_fagb );_gdee :=int (_fgad )-_ebfe ;_geaa :=int (_ccdd )-_ebfe ;_ebfe =_fedd (_gdee +_geaa );_gdee =_fedd (_gdee );_geaa =_fedd (_geaa );
if _gdee <=_geaa &&_gdee <=_ebfe {return _ccdd ;}else if _geaa <=_ebfe {return _fgad ;};return _fagb ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_edde :=&DCTEncoder {};_edde .ColorComponents =3;_edde .BitsPerComponent =8;_edde .Quality =DefaultJPEGQuality ;_edde .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};return _edde ;};

// WriteString outputs the object as it is to be written to file.
func (_dcfa *PdfIndirectObject )WriteString ()string {var _adcb _gb .Builder ;_adcb .WriteString (_g .FormatInt (_dcfa .ObjectNumber ,10));_adcb .WriteString ("\u0020\u0030\u0020\u0052");return _adcb .String ();};var _fcdf =_e .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");


// Append appends PdfObject(s) to the array.
func (_bbcg *PdfObjectArray )Append (objects ...PdfObject ){if _bbcg ==nil {_cc .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_bbcg ._gcgad =append (_bbcg ._gcgad ,objects ...);};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_bdfg :=PdfObjectBool (val );return &_bdfg };func (_gggc *PdfParser )parseBool ()(PdfObjectBool ,error ){_bgcd ,_cbae :=_gggc ._dced .Peek (4);if _cbae !=nil {return PdfObjectBool (false ),_cbae ;};if (len (_bgcd )>=4)&&(string (_bgcd [:4])=="\u0074\u0072\u0075\u0065"){_gggc ._dced .Discard (4);
return PdfObjectBool (true ),nil ;};_bgcd ,_cbae =_gggc ._dced .Peek (5);if _cbae !=nil {return PdfObjectBool (false ),_cbae ;};if (len (_bgcd )>=5)&&(string (_bgcd [:5])=="\u0066\u0061\u006cs\u0065"){_gggc ._dced .Discard (5);return PdfObjectBool (false ),nil ;
};return PdfObjectBool (false ),_ca .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ffbf *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_ceefa :=MakeDict ();_ceefa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ffbf .GetFilterName ()));return _ceefa ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_cfaae *PdfObjectInteger ,_eeag bool ){_cfaae ,_eeag =TraceToDirectObject (obj ).(*PdfObjectInteger );return _cfaae ,_eeag ;};func (_cbf *PdfCrypt )makeKey (_bfec string ,_agc ,_bbba uint32 ,_gbb []byte )([]byte ,error ){_cfff ,_dfba :=_cbf ._eebc [_bfec ];
if !_dfba {return nil ,_ggc .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bfec );};return _cfff .MakeKey (_agc ,_bbba ,_gbb );};

// HeaderPosition gets the file header position.
func (_egb ParserMetadata )HeaderPosition ()int {return _egb ._fef };func (_bdgg *PdfParser )repairSeekXrefMarker ()error {_gagae ,_cgac :=_bdgg ._bbdc .Seek (0,_ae .SeekEnd );if _cgac !=nil {return _cgac ;};_fcgd :=_e .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");
var _cggc int64 ;var _eaecg int64 =1000;for _cggc < _gagae {if _gagae <=(_eaecg +_cggc ){_eaecg =_gagae -_cggc ;};_ ,_bdfa :=_bdgg ._bbdc .Seek (-_cggc -_eaecg ,_ae .SeekEnd );if _bdfa !=nil {return _bdfa ;};_bbcc :=make ([]byte ,_eaecg );_bdgg ._bbdc .Read (_bbcc );
_cc .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_bbcc ));_ecbaf :=_fcgd .FindAllStringIndex (string (_bbcc ),-1);if _ecbaf !=nil {_egddce :=_ecbaf [len (_ecbaf )-1];
_cc .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ecbaf );_bdgg ._bbdc .Seek (-_cggc -_eaecg +int64 (_egddce [0]),_ae .SeekEnd );_bdgg ._dced =_ce .NewReader (_bdgg ._bbdc );for {_gcgb ,_ebac :=_bdgg ._dced .Peek (1);if _ebac !=nil {return _ebac ;
};_cc .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_gcgb [0],_gcgb [0]);if !IsWhiteSpace (_gcgb [0]){break ;};_bdgg ._dced .Discard (1);};return nil ;};_cc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_cggc +=_eaecg ;};_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _ca .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};func _caa (_efef _ba .Filter ,_ade _dec .AuthEvent )*PdfObjectDictionary {if _ade ==""{_ade =_dec .EventDocOpen ;};_gac :=MakeDict ();_gac .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));
_gac .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_ade )));_gac .Set ("\u0043\u0046\u004d",MakeName (_efef .Name ()));_gac .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_efef .KeyLength ())));return _gac ;};
func (_aede *offsetReader )Read (p []byte )(_ffcg int ,_gdde error ){return _aede ._dafec .Read (p )};const _acea =32<<(^uint (0)>>63);func (_gceg *PdfParser )parseString ()(*PdfObjectString ,error ){_gceg ._dced .ReadByte ();var _gfaaf _gff .Buffer ;_dgdg :=1;
for {_cbd ,_dgea :=_gceg ._dced .Peek (1);if _dgea !=nil {return MakeString (_gfaaf .String ()),_dgea ;};if _cbd [0]=='\\'{_gceg ._dced .ReadByte ();_bbggd ,_febg :=_gceg ._dced .ReadByte ();if _febg !=nil {return MakeString (_gfaaf .String ()),_febg ;
};if IsOctalDigit (_bbggd ){_acbf ,_fcaf :=_gceg ._dced .Peek (2);if _fcaf !=nil {return MakeString (_gfaaf .String ()),_fcaf ;};var _acdee []byte ;_acdee =append (_acdee ,_bbggd );for _ ,_dfgd :=range _acbf {if IsOctalDigit (_dfgd ){_acdee =append (_acdee ,_dfgd );
}else {break ;};};_gceg ._dced .Discard (len (_acdee )-1);_cc .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_acdee );_gdce ,_fcaf :=_g .ParseUint (string (_acdee ),8,32);if _fcaf !=nil {return MakeString (_gfaaf .String ()),_fcaf ;
};_gfaaf .WriteByte (byte (_gdce ));continue ;};switch _bbggd {case 'n':_gfaaf .WriteRune ('\n');case 'r':_gfaaf .WriteRune ('\r');case 't':_gfaaf .WriteRune ('\t');case 'b':_gfaaf .WriteRune ('\b');case 'f':_gfaaf .WriteRune ('\f');case '(':_gfaaf .WriteRune ('(');
case ')':_gfaaf .WriteRune (')');case '\\':_gfaaf .WriteRune ('\\');};continue ;}else if _cbd [0]=='('{_dgdg ++;}else if _cbd [0]==')'{_dgdg --;if _dgdg ==0{_gceg ._dced .ReadByte ();break ;};};_beaec ,_ :=_gceg ._dced .ReadByte ();_gfaaf .WriteByte (_beaec );
};return MakeString (_gfaaf .String ()),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_bffg *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eff *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };func (_fdfc *PdfParser )skipComments ()error {if _ ,_gdc :=_fdfc .skipSpaces ();_gdc !=nil {return _gdc ;};_adeea :=true ;for {_fffb ,_cacd :=_fdfc ._dced .Peek (1);if _cacd !=nil {_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cacd .Error ());
return _cacd ;};if _adeea &&_fffb [0]!='%'{return nil ;};_adeea =false ;if (_fffb [0]!='\r')&&(_fffb [0]!='\n'){_fdfc ._dced .ReadByte ();}else {break ;};};return _fdfc .skipComments ();};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_bcgg bool ,_deab bool ){_dfac ,_deab :=TraceToDirectObject (obj ).(*PdfObjectBool );if _deab {return bool (*_dfac ),true ;};return false ,false ;};func _ebfebb (_bcaab PdfObject )(*float64 ,error ){switch _fdfg :=_bcaab .(type ){case *PdfObjectFloat :_gdcd :=float64 (*_fdfg );
return &_gdcd ,nil ;case *PdfObjectInteger :_bedgga :=float64 (*_fdfg );return &_bedgga ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_beb *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_aeceg *PdfObjectFloat ,_bfbfa bool ){_aeceg ,_bfbfa =TraceToDirectObject (obj ).(*PdfObjectFloat );return _aeceg ,_bfbfa ;};

// GetFilterName returns the name of the encoding filter.
func (_adaac *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_degb :_gbg .InitEncodeDocument (false )}};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// GetFilterName returns the name of the encoding filter.
func (_feced *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_agfa *PdfObjectDictionary )Keys ()[]PdfObjectName {if _agfa ==nil {return nil ;};return _agfa ._gccc ;};func _cdd (_bfb *_dec .StdEncryptDict ,_aedf *PdfObjectDictionary )error {R ,_ccg :=_aedf .Get ("\u0052").(*PdfObjectInteger );if !_ccg {return _ca .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");
};if *R < 2||*R > 6{return _ggc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_bfb .R =int (*R );O ,_ccg :=_aedf .GetString ("\u004f");if !_ccg {return _ca .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");
};if _bfb .R ==5||_bfb .R ==6{if len (O )< 48{return _ggc .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _ggc .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));
};_bfb .O =[]byte (O );U ,_ccg :=_aedf .GetString ("\u0055");if !_ccg {return _ca .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _bfb .R ==5||_bfb .R ==6{if len (U )< 48{return _ggc .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));
};}else if len (U )!=32{_cc .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_bfb .U =[]byte (U );if _bfb .R >=5{OE ,_ggd :=_aedf .GetString ("\u004f\u0045");
if !_ggd {return _ca .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _ggc .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));
};_bfb .OE =[]byte (OE );UE ,_ggd :=_aedf .GetString ("\u0055\u0045");if !_ggd {return _ca .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _ggc .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_bfb .UE =[]byte (UE );};P ,_ccg :=_aedf .Get ("\u0050").(*PdfObjectInteger );if !_ccg {return _ca .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_bfb .P =_dec .Permissions (*P );if _bfb .R ==6{Perms ,_fec :=_aedf .GetString ("\u0050\u0065\u0072m\u0073");if !_fec {return _ca .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _ggc .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_bfb .Perms =[]byte (Perms );};if _daa ,_gfgg :=_aedf .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_gfgg {_bfb .EncryptMetadata =bool (*_daa );}else {_bfb .EncryptMetadata =true ;};return nil ;};func (_gegcf *PdfParser )inspect ()(map[string ]int ,error ){_cc .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_cc .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_afecg :=map[string ]int {};_dbfc :=0;_gaef :=0;var _debee []int ;for _cgae :=range _gegcf ._daea .ObjectMap {_debee =append (_debee ,_cgae );};_cg .Ints (_debee );_aaeb :=0;
for _ ,_cfece :=range _debee {_deceg :=_gegcf ._daea .ObjectMap [_cfece ];if _deceg .ObjectNumber ==0{continue ;};_dbfc ++;_cc .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_cc .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_deceg .ObjectNumber );
_aeefe ,_agdd :=_gegcf .LookupByNumber (_deceg .ObjectNumber );if _agdd !=nil {_cc .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_deceg .ObjectNumber ,_agdd );
_gaef ++;continue ;};_cc .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_aeefe );_caced ,_cdgb :=_aeefe .(*PdfIndirectObject );if _cdgb {_cc .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_deceg .ObjectNumber ,_caced );
_cbee ,_efag :=_caced .PdfObject .(*PdfObjectDictionary );if _efag {if _edba ,_gagcf :=_cbee .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gagcf {_agdb :=string (*_edba );_cc .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_agdb );
_ ,_dbgf :=_afecg [_agdb ];if _dbgf {_afecg [_agdb ]++;}else {_afecg [_agdb ]=1;};}else if _afdf ,_acge :=_cbee .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_acge {_bgfcb :=string (*_afdf );_cc .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_bgfcb );
_ ,_cfgf :=_afecg [_bgfcb ];if _cfgf {_afecg [_bgfcb ]++;}else {_afecg [_bgfcb ]=1;};};if _eacbe ,_abfc :=_cbee .Get ("\u0053").(*PdfObjectName );_abfc &&*_eacbe =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_ceee :=_afecg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _ceee {_afecg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_afecg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _fcdg ,_deac :=_aeefe .(*PdfObjectStream );_deac {if _gfbcd ,_gcgfa :=_fcdg .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_gcgfa {_cc .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_gfbcd );_egdc :=string (*_gfbcd );_afecg [_egdc ]++;};}else {_gbge ,_dfef :=_aeefe .(*PdfObjectDictionary );
if _dfef {_eaeef ,_bbde :=_gbge .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _bbde {_aebfg :=string (*_eaeef );_cc .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_aebfg );_afecg [_aebfg ]++;};};
_cc .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_deceg .ObjectNumber ,_aeefe );};_aaeb ++;};_cc .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");
_cc .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_cc .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_dbfc );_cc .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_gaef );
for _bcggf ,_feggg :=range _afecg {_cc .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_bcggf ,_feggg );};_cc .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_gegcf ._daea .ObjectMap )< 1{_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_ggc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_bfge ,_aebccb :=_afecg ["\u0046\u006f\u006e\u0074"];
if !_aebccb ||_bfge < 2{_cc .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_cc .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _afecg ,nil ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_cbfc *MultiEncoder )GetFilterArray ()*PdfObjectArray {_gceb :=make ([]PdfObject ,len (_cbfc ._ceba ));for _gbac ,_efd :=range _cbfc ._ceba {_gceb [_gbac ]=MakeName (_efd .GetFilterName ());};return MakeArray (_gceb ...);};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_beec :=MultiEncoder {};_beec ._ceba =[]StreamEncoder {};return &_beec ;};func _gfag (_cbacb *PdfObjectStream ,_gecca *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _fbaf ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";
_bcb :=NewJBIG2Encoder ();_beab :=_cbacb .PdfObjectDictionary ;if _beab ==nil {return _bcb ,nil ;};if _gecca ==nil {_aeda :=_beab .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _aeda !=nil {switch _bggce :=_aeda .(type ){case *PdfObjectDictionary :_gecca =_bggce ;
case *PdfObjectArray :if _bggce .Len ()==1{if _ddbb ,_egdd :=GetDict (_bggce .Get (0));_egdd {_gecca =_ddbb ;};};default:_cc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_aeda );
return nil ,_b .Errorf (_fbaf ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_bggce );};};};if _gecca ==nil {return _bcb ,nil ;};_bcb .UpdateParams (_gecca );
_fabbc ,_fddg :=GetStream (_gecca .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_fddg {return _bcb ,nil ;};var _bgdf error ;_bcb .Globals ,_bgdf =_ee .DecodeGlobals (_fabbc .Stream );if _bgdf !=nil {_bgdf =_b .Wrap (_bgdf ,_fbaf ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_cc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bgdf );return nil ,_bgdf ;};return _bcb ,nil ;};type cryptFilters map[string ]_ba .Filter ;

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_adaa *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _adaa .DecodeBytes (streamObj .Stream );};func (_eccfb *PdfParser )parseObject ()(PdfObject ,error ){_cc .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");
_eccfb .skipSpaces ();for {_ebaea ,_fafc :=_eccfb ._dced .Peek (2);if _fafc !=nil {if _fafc !=_ae .EOF ||len (_ebaea )==0{return nil ,_fafc ;};if len (_ebaea )==1{_ebaea =append (_ebaea ,' ');};};_cc .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_ebaea ));
if _ebaea [0]=='/'{_cgfa ,_beada :=_eccfb .parseName ();_cc .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_cgfa );return &_cgfa ,_beada ;}else if _ebaea [0]=='('{_cc .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");
_dffdf ,_afbf :=_eccfb .parseString ();return _dffdf ,_afbf ;}else if _ebaea [0]=='['{_cc .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_feabc ,_bgba :=_eccfb .parseArray ();return _feabc ,_bgba ;}else if (_ebaea [0]=='<')&&(_ebaea [1]=='<'){_cc .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_ggafd ,_bfcb :=_eccfb .ParseDict ();return _ggafd ,_bfcb ;}else if _ebaea [0]=='<'{_cc .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_acbbb ,_ffac :=_eccfb .parseHexString ();return _acbbb ,_ffac ;}else if _ebaea [0]=='%'{_eccfb .readComment ();
_eccfb .skipSpaces ();}else {_cc .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_ebaea ,_ =_eccfb ._dced .Peek (15);_gaba :=string (_ebaea );_cc .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_gaba );
if (len (_gaba )> 3)&&(_gaba [:4]=="\u006e\u0075\u006c\u006c"){_fbeg ,_gfbc :=_eccfb .parseNull ();return &_fbeg ,_gfbc ;}else if (len (_gaba )> 4)&&(_gaba [:5]=="\u0066\u0061\u006cs\u0065"){_bebgc ,_degf :=_eccfb .parseBool ();return &_bebgc ,_degf ;}else if (len (_gaba )> 3)&&(_gaba [:4]=="\u0074\u0072\u0075\u0065"){_eaca ,_abad :=_eccfb .parseBool ();
return &_eaca ,_abad ;};_cece :=_fgbf .FindStringSubmatch (_gaba );if len (_cece )> 1{_ebaea ,_ =_eccfb ._dced .ReadBytes ('R');_cc .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_ebaea [:]));_gggd ,_caee :=_egbb (string (_ebaea ));
_gggd ._aacab =_eccfb ;return &_gggd ,_caee ;};_gfab :=_bbd .FindStringSubmatch (_gaba );if len (_gfab )> 1{_cc .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_fafe ,_gabbf :=_eccfb .parseNumber ();return _fafe ,_gabbf ;};
_gfab =_acbb .FindStringSubmatch (_gaba );if len (_gfab )> 1{_cc .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_cc .Log .Trace ("\u0025\u0020\u0073",_gfab );_egcc ,_gdga :=_eccfb .parseNumber ();
return _egcc ,_gdga ;};_cc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_gaba );return nil ,_ca .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_fcbde *PdfParser )CheckAccessRights (password []byte )(bool ,_dec .Permissions ,error ){if _fcbde ._bcgf ==nil {return true ,_dec .PermOwner ,nil ;};return _fcbde ._bcgf .checkAccessRights (password );};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_dbf *JBIG2Image )ToGoImage ()(_dd .Image ,error ){const _eebcd ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _dbf .Data ==nil {return nil ,_b .Error (_eebcd ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _dbf .Width ==0||_dbf .Height ==0{return nil ,_b .Error (_eebcd ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_dbfb ,_faeef :=_fe .NewImage (_dbf .Width ,_dbf .Height ,1,1,_dbf .Data ,nil ,nil );if _faeef !=nil {return nil ,_faeef ;};return _dbfb ,nil ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_dcec *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dcec .DecodeBytes (streamObj .Stream );};func (_ccgad *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_ccgad ._daea .ObjectMap =make (map[int ]XrefObject );
_ccgad ._dgbe =make (objectStreams );_cfdb ,_ebfeb :=_ccgad ._bbdc .Seek (0,_ae .SeekEnd );if _ebfeb !=nil {return nil ,_ebfeb ;};_cc .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_cfdb );_ccgad ._ddgd =_cfdb ;_ebfeb =_ccgad .seekToEOFMarker (_cfdb );
if _ebfeb !=nil {_cc .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_ebfeb );return nil ,_ebfeb ;};_agbab ,_ebfeb :=_ccgad ._bbdc .Seek (0,_ae .SeekCurrent );
if _ebfeb !=nil {return nil ,_ebfeb ;};var _edca int64 =64;_ffaed :=_agbab -_edca ;if _ffaed < 0{_ffaed =0;};_ ,_ebfeb =_ccgad ._bbdc .Seek (_ffaed ,_ae .SeekStart );if _ebfeb !=nil {return nil ,_ebfeb ;};_eaeb :=make ([]byte ,_edca );_ ,_ebfeb =_ccgad ._bbdc .Read (_eaeb );
if _ebfeb !=nil {_cc .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_ebfeb );
return nil ,_ebfeb ;};_fegg :=_gdaec .FindStringSubmatch (string (_eaeb ));if len (_fegg )< 2{_cc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");
return nil ,_ca .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_fegg )> 2{_cc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_eaeb );
return nil ,_ca .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_gagaa ,_ :=_g .ParseInt (_fegg [1],10,64);_cc .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_gagaa );
if _gagaa > _cfdb {_cc .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_cc .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");
_gagaa ,_ebfeb =_ccgad .repairLocateXref ();if _ebfeb !=nil {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_ebfeb ;};};_ccgad ._bbdc .Seek (_gagaa ,_ae .SeekStart );_ccgad ._dced =_ce .NewReader (_ccgad ._bbdc );_dbbae ,_ebfeb :=_ccgad .parseXref ();if _ebfeb !=nil {return nil ,_ebfeb ;};_cabc :=_dbbae .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");
if _cabc !=nil {_fbge ,_gefe :=_cabc .(*PdfObjectInteger );if !_gefe {return nil ,_ca .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_ebfeb =_ccgad .parseXrefStream (_fbge );if _ebfeb !=nil {return nil ,_ebfeb ;
};};var _faeg []int64 ;_bfeg :=func (_ffcf int64 ,_bfbcf []int64 )bool {for _ ,_afdg :=range _bfbcf {if _afdg ==_ffcf {return true ;};};return false ;};_cabc =_dbbae .Get ("\u0050\u0072\u0065\u0076");for _cabc !=nil {_cadeg ,_ddca :=_cabc .(*PdfObjectInteger );
if !_ddca {_cc .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_cabc );
return _dbbae ,nil ;};_bcff :=*_cadeg ;_cc .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_bcff );_ccgad ._bbdc .Seek (int64 (_bcff ),_ae .SeekStart );
_ccgad ._dced =_ce .NewReader (_ccgad ._bbdc );_ebee ,_egec :=_ccgad .parseXref ();if _egec !=nil {_cc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_cc .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_ccgad ._gfbd =append (_ccgad ._gfbd ,int64 (_bcff ));
_cabc =_ebee .Get ("\u0050\u0072\u0065\u0076");if _cabc !=nil {_gcgc :=*(_cabc .(*PdfObjectInteger ));if _bfeg (int64 (_gcgc ),_faeg ){_cc .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_faeg =append (_faeg ,int64 (_gcgc ));};};return _dbbae ,nil ;};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_aaced *PdfObjectString ,_becfe bool ){_aaced ,_becfe =TraceToDirectObject (obj ).(*PdfObjectString );return _aaced ,_becfe ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_dfff *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cc .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_cc .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_dfff .Predictor );
_eac ,_gedc :=_dfff .DecodeBytes (streamObj .Stream );if _gedc !=nil {return nil ,_gedc ;};_cc .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_cc .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_eac ),_eac );
if _dfff .Predictor > 1{if _dfff .Predictor ==2{_cc .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_gafdd :=_dfff .Columns *_dfff .Colors ;if _gafdd < 1{return []byte {},nil ;};_dcab :=len (_eac )/_gafdd ;
if len (_eac )%_gafdd !=0{_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_ggc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_eac ),_gafdd );};if _gafdd %_dfff .Colors !=0{return nil ,_ggc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_gafdd ,_dfff .Colors );
};if _gafdd > len (_eac ){_cc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_gafdd ,len (_eac ));
return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cc .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_eac ),_eac );
_bfee :=_gff .NewBuffer (nil );for _bcea :=0;_bcea < _dcab ;_bcea ++{_cbad :=_eac [_gafdd *_bcea :_gafdd *(_bcea +1)];for _bacd :=_dfff .Colors ;_bacd < _gafdd ;_bacd ++{_cbad [_bacd ]=byte (int (_cbad [_bacd ]+_cbad [_bacd -_dfff .Colors ])%256);};_bfee .Write (_cbad );
};_bdag :=_bfee .Bytes ();_cc .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_bdag ),_bdag );return _bdag ,nil ;}else if _dfff .Predictor >=10&&_dfff .Predictor <=15{_cc .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_gecd :=_dfff .Columns *_dfff .Colors +1;if _gecd < 1{return []byte {},nil ;};_ccf :=len (_eac )/_gecd ;if len (_eac )%_gecd !=0{return nil ,_ggc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_eac ),_gecd );
};if _gecd > len (_eac ){_cc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_gecd ,len (_eac ));
return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_egc :=_gff .NewBuffer (nil );_cc .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_dfff .Columns );
_cc .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_eac ),_gecd ,_ccf );_cfbf :=make ([]byte ,_gecd );for _dag :=0;_dag < _gecd ;_dag ++{_cfbf [_dag ]=0;};for _eafa :=0;
_eafa < _ccf ;_eafa ++{_aee :=_eac [_gecd *_eafa :_gecd *(_eafa +1)];_gfde :=_aee [0];switch _gfde {case 0:case 1:for _fgfc :=2;_fgfc < _gecd ;_fgfc ++{_aee [_fgfc ]=byte (int (_aee [_fgfc ]+_aee [_fgfc -1])%256);};case 2:for _abfa :=1;_abfa < _gecd ;_abfa ++{_aee [_abfa ]=byte (int (_aee [_abfa ]+_cfbf [_abfa ])%256);
};default:_cc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_gfde );return nil ,_ggc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_gfde );
};for _ecbg :=0;_ecbg < _gecd ;_ecbg ++{_cfbf [_ecbg ]=_aee [_ecbg ];};_egc .Write (_aee [1:]);};_eeba :=_egc .Bytes ();return _eeba ,nil ;}else {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_dfff .Predictor );
return nil ,_ggc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_dfff .Predictor );};};return _eac ,nil ;};type xrefType int ;func _beae (_ddcf *PdfObjectStream ,_bccg *PdfObjectDictionary )(*LZWEncoder ,error ){_dgc :=NewLZWEncoder ();
_dfdg :=_ddcf .PdfObjectDictionary ;if _dfdg ==nil {return _dgc ,nil ;};if _bccg ==nil {_aaef :=TraceToDirectObject (_dfdg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _aaef !=nil {if _fdg ,_cdg :=_aaef .(*PdfObjectDictionary );
_cdg {_bccg =_fdg ;}else if _feae ,_cbed :=_aaef .(*PdfObjectArray );_cbed {if _feae .Len ()==1{if _agd ,_gaag :=GetDict (_feae .Get (0));_gaag {_bccg =_agd ;};};};if _bccg ==nil {_cc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_aaef );
return nil ,_ggc .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_gde :=_dfdg .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _gde !=nil {_gbdd ,_gdb :=_gde .(*PdfObjectInteger );
if !_gdb {_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_gde );
return nil ,_ggc .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_gbdd !=0&&*_gbdd !=1{return nil ,_ggc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_dgc .EarlyChange =int (*_gbdd );}else {_dgc .EarlyChange =1;};if _bccg ==nil {return _dgc ,nil ;};if _dcag ,_cafb :=GetIntVal (_bccg .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_cafb {if _dcag ==0||_dcag ==1{_dgc .EarlyChange =_dcag ;
}else {_cc .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_dcag );};};_gde =_bccg .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _gde !=nil {_eafb ,_fecf :=_gde .(*PdfObjectInteger );if !_fecf {_cc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_gde );
return nil ,_ggc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_dgc .Predictor =int (*_eafb );};_gde =_bccg .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _gde !=nil {_ddaf ,_fbcd :=_gde .(*PdfObjectInteger );if !_fbcd {_cc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_ggc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_dgc .BitsPerComponent =int (*_ddaf );};if _dgc .Predictor > 1{_dgc .Columns =1;_gde =_bccg .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _gde !=nil {_bgga ,_cggbd :=_gde .(*PdfObjectInteger );if !_cggbd {return nil ,_ggc .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_dgc .Columns =int (*_bgga );
};_dgc .Colors =1;_gde =_bccg .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _gde !=nil {_begf ,_abdd :=_gde .(*PdfObjectInteger );if !_abdd {return nil ,_ggc .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_dgc .Colors =int (*_begf );};};_cc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bccg .String ());return _dgc ,nil ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_cbeb *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_fbb :=MakeDict ();_fbb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cbeb .GetFilterName ()));_cffg :=_cbeb .MakeDecodeParams ();if _cffg !=nil {_fbb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cffg );
};_fbb .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_cbeb .EarlyChange )));return _fbb ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_ace ParserMetadata )HasInvalidHexRunes ()bool {return _ace ._fcde };func _egfb (_beaee *PdfObjectStream ,_ggbe *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_ffbfg :=NewCCITTFaxEncoder ();_gbeea :=_beaee .PdfObjectDictionary ;if _gbeea ==nil {return _ffbfg ,nil ;
};if _ggbe ==nil {_dcbgf :=TraceToDirectObject (_gbeea .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _dcbgf !=nil {switch _ffc :=_dcbgf .(type ){case *PdfObjectDictionary :_ggbe =_ffc ;case *PdfObjectArray :if _ffc .Len ()==1{if _ebbg ,_abb :=GetDict (_ffc .Get (0));
_abb {_ggbe =_ebbg ;};};default:_cc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_dcbgf );return nil ,_ca .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _ggbe ==nil {_cc .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_dcbgf );return nil ,_ca .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _aabe ,_gaed :=GetNumberAsInt64 (_ggbe .Get ("\u004b"));_gaed ==nil {_ffbfg .K =int (_aabe );};if _cfgb ,_eccc :=GetNumberAsInt64 (_ggbe .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_eccc ==nil {_ffbfg .Columns =int (_cfgb );}else {_ffbfg .Columns =1728;
};if _dae ,_fcc :=GetNumberAsInt64 (_ggbe .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_fcc ==nil {_ffbfg .BlackIs1 =_dae > 0;}else {if _eeae ,_adfb :=GetBoolVal (_ggbe .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_adfb {_ffbfg .BlackIs1 =_eeae ;
}else {if _eaa ,_acg :=GetArray (_ggbe .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_acg {_cdgf ,_gbff :=_eaa .ToIntegerArray ();if _gbff ==nil {_ffbfg .BlackIs1 =_cdgf [0]==1&&_cdgf [1]==0;};};};};if _ccaa ,_eggg :=GetNumberAsInt64 (_ggbe .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_eggg ==nil {_ffbfg .EncodedByteAlign =_ccaa > 0;}else {if _ebcb ,_ebed :=GetBoolVal (_ggbe .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ebed {_ffbfg .EncodedByteAlign =_ebcb ;};};if _bge ,_gbfa :=GetNumberAsInt64 (_ggbe .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_gbfa ==nil {_ffbfg .EndOfLine =_bge > 0;}else {if _eaef ,_baga :=GetBoolVal (_ggbe .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_baga {_ffbfg .EndOfLine =_eaef ;};};if _ecgf ,_ecbf :=GetNumberAsInt64 (_ggbe .Get ("\u0052\u006f\u0077\u0073"));
_ecbf ==nil {_ffbfg .Rows =int (_ecgf );};_ffbfg .EndOfBlock =true ;if _cgbd ,_ccfb :=GetNumberAsInt64 (_ggbe .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ccfb ==nil {_ffbfg .EndOfBlock =_cgbd > 0;}else {if _fbff ,_bgag :=GetBoolVal (_ggbe .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_bgag {_ffbfg .EndOfBlock =_fbff ;};};if _bdf ,_gfce :=GetNumberAsInt64 (_ggbe .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_gfce !=nil {_ffbfg .DamagedRowsBeforeError =int (_bdf );
};_cc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_ggbe .String ());return _ffbfg ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_ebga *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_gcga :=MakeDict ();_gcga .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ebga .GetFilterName ()));return _gcga ;};

// WriteString outputs the object as it is to be written to file.
func (_daaa *PdfObjectReference )WriteString ()string {var _gecde _gb .Builder ;_gecde .WriteString (_g .FormatInt (_daaa .ObjectNumber ,10));_gecde .WriteString ("\u0020");_gecde .WriteString (_g .FormatInt (_daaa .GenerationNumber ,10));_gecde .WriteString ("\u0020\u0052");
return _gecde .String ();};

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_agac :=MakeDict ();return _agac .Update (objmap );};

// UpdateParams updates the parameter values of the encoder.
func (_fedb *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_cfdg *_fe .ImageBase ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_aeef *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ee .Globals ,error ){return _ee .DecodeGlobals (encoded );};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_fga *PdfParser )GetFileOffset ()int64 {_afbd ,_ :=_fga ._bbdc .Seek (0,_ae .SeekCurrent );_afbd -=int64 (_fga ._dced .Buffered ());return _afbd ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_aced *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_geeda :=_gff .NewReader (encoded );var _eeda []byte ;for {_gfbb ,_bffc :=_geeda .ReadByte ();if _bffc !=nil {return nil ,_bffc ;};if _gfbb =='>'{break ;};if IsWhiteSpace (_gfbb ){continue ;
};if (_gfbb >='a'&&_gfbb <='f')||(_gfbb >='A'&&_gfbb <='F')||(_gfbb >='0'&&_gfbb <='9'){_eeda =append (_eeda ,_gfbb );}else {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_gfbb );
return nil ,_ggc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_gfbb );};};if len (_eeda )%2==1{_eeda =append (_eeda ,'0');
};_cc .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_eeda );_acde :=make ([]byte ,_ag .DecodedLen (len (_eeda )));_ ,_gdfd :=_ag .Decode (_acde ,_eeda );if _gdfd !=nil {return nil ,_gdfd ;};return _acde ,nil ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_cdgfg *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_cdgfg ._eagf ){return _ca .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_cdgfg ._eagf [i ]=obj ;return nil ;};func (_bdfc *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_bdfc ._bbdc .Seek (0,_ae .SeekStart );
_bdfc ._dced =_ce .NewReader (_bdfc ._bbdc );_geged :=20;_bggag :=make ([]byte ,_geged );for {_eefed ,_fggec :=_bdfc ._dced .ReadByte ();if _fggec !=nil {if _fggec ==_ae .EOF {break ;}else {return 0,0,_fggec ;};};if IsDecimalDigit (_eefed )&&_bggag [_geged -1]=='.'&&IsDecimalDigit (_bggag [_geged -2])&&_bggag [_geged -3]=='-'&&_bggag [_geged -4]=='F'&&_bggag [_geged -5]=='D'&&_bggag [_geged -6]=='P'{_gcec :=int (_bggag [_geged -2]-'0');
_cbdbg :=int (_eefed -'0');return _gcec ,_cbdbg ,nil ;};_bggag =append (_bggag [1:_geged ],_eefed );};return 0,0,_ca .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_fbd :=&FlateEncoder {};_fbd .Predictor =1;_fbd .BitsPerComponent =8;_fbd .Colors =1;_fbd .Columns =1;return _fbd ;};func _afg (_gea *_ba .FilterDict ,_cecc *PdfObjectDictionary )error {if _dff ,_cfb :=_cecc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_cfb {if _aef :=string (*_dff );_aef !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_cc .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_aef );
};};_ac ,_gcg :=_cecc .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_gcg {return _ggc .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_gea .CFM =string (*_ac );if _eg ,_dfg :=_cecc .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_dfg {_gea .AuthEvent =_dec .AuthEvent (*_eg );}else {_gea .AuthEvent =_dec .EventDocOpen ;};if _dde ,_bfa :=_cecc .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_bfa {_gea .Length =int (*_dde );};return nil ;};func (_eddc *JBIG2Encoder )encodeImage (_egeb _dd .Image )([]byte ,error ){const _gagd ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_dccb ,_cbff :=GoImageToJBIG2 (_egeb ,JB2ImageAutoThreshold );
if _cbff !=nil {return nil ,_b .Wrap (_cbff ,_gagd ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _cbff =_eddc .AddPageImage (_dccb ,&_eddc .DefaultPageSettings );
_cbff !=nil {return nil ,_b .Wrap (_cbff ,_gagd ,"");};return _eddc .Encode ();};

// Len returns the number of elements in the array.
func (_afbg *PdfObjectArray )Len ()int {if _afbg ==nil {return 0;};return len (_afbg ._gcgad );};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_fffd :=MakeArray ();for _ ,_dgfdf :=range vals {_fffd .Append (MakeInteger (_dgfdf ));};return _fffd ;};

// UpdateParams updates the parameter values of the encoder.
func (_ebdf *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_aaff ,_ecbb :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _ecbb ==nil {_ebdf .Predictor =int (_aaff );};_ffb ,_ecbb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _ecbb ==nil {_ebdf .BitsPerComponent =int (_ffb );};_dgd ,_ecbb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ecbb ==nil {_ebdf .Columns =int (_dgd );};_ecfd ,_ecbb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _ecbb ==nil {_ebdf .Colors =int (_ecfd );};};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_eagf :objects };};const _faabe =10;func (_ffga *PdfObjectInteger )String ()string {return _ggc .Sprintf ("\u0025\u0064",*_ffga )};const (_ccc =0;_abf =1;_dfbe =2;
_bgfe =3;_ffeg =4;);func (_gfe *PdfParser )lookupObjectViaOS (_ebe int ,_dcc int )(PdfObject ,error ){var _gd *_gff .Reader ;var _af objectStream ;var _ga bool ;_af ,_ga =_gfe ._dgbe [_ebe ];if !_ga {_bb ,_cd :=_gfe .LookupByNumber (_ebe );if _cd !=nil {_cc .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_ebe );
return nil ,_cd ;};_bf ,_df :=_bb .(*PdfObjectStream );if !_df {return nil ,_ca .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _gfe ._bcgf !=nil &&!_gfe ._bcgf .isDecrypted (_bf ){return nil ,_ca .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_bfg :=_bf .PdfObjectDictionary ;_cc .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_bfg .String ());_fc ,_df :=_bfg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_df {_cc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_ca .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _gb .ToLower (string (*_fc ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_ca .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_df :=_bfg .Get ("\u004e").(*PdfObjectInteger );if !_df {return nil ,_ca .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_ed ,_df :=_bfg .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_df {return nil ,_ca .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_cc .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_fc ,*N );_bc ,_cd :=DecodeStream (_bf );if _cd !=nil {return nil ,_cd ;
};_cc .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_bc );_bag :=_gfe .GetFileOffset ();defer func (){_gfe .SetFileOffset (_bag )}();_gd =_gff .NewReader (_bc );_gfe ._dced =_ce .NewReader (_gd );_cc .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_cgeb :=map[int ]int64 {};for _gae :=0;_gae < int (*N );_gae ++{_gfe .skipSpaces ();_eee ,_be :=_gfe .parseNumber ();if _be !=nil {return nil ,_be ;};_eba ,_gga :=_eee .(*PdfObjectInteger );if !_gga {return nil ,_ca .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_gfe .skipSpaces ();_eee ,_be =_gfe .parseNumber ();if _be !=nil {return nil ,_be ;};_bg ,_gga :=_eee .(*PdfObjectInteger );if !_gga {return nil ,_ca .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_cc .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_eba ,*_bg );_cgeb [int (*_eba )]=int64 (*_ed +*_bg );};_af =objectStream {N :int (*N ),_aed :_bc ,_ea :_cgeb };_gfe ._dgbe [_ebe ]=_af ;}else {_dca :=_gfe .GetFileOffset ();
defer func (){_gfe .SetFileOffset (_dca )}();_gd =_gff .NewReader (_af ._aed );_gfe ._dced =_ce .NewReader (_gd );};_da :=_af ._ea [_dcc ];_cc .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_dcc ,_da );
_gd .Seek (_da ,_ae .SeekStart );_gfe ._dced =_ce .NewReader (_gd );_aaf ,_ :=_gfe ._dced .Peek (100);_cc .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_aaf ));_ec ,_edb :=_gfe .parseObject ();if _edb !=nil {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_edb );
return nil ,_edb ;};if _ec ==nil {return nil ,_ca .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_age :=PdfIndirectObject {};_age .ObjectNumber =int64 (_dcc );_age .PdfObject =_ec ;_age ._aacab =_gfe ;
return &_age ,nil ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};func (_aac *PdfParser )lookupByNumber (_cff int ,_eeb bool )(PdfObject ,bool ,error ){_fg ,_caf :=_aac .ObjCache [_cff ];if _caf {_cc .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_cff );
return _fg ,false ,nil ;};if _aac ._gfgfc ==nil {_aac ._gfgfc =map[int ]bool {};};if _aac ._gfgfc [_cff ]{_cc .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_cff );
return nil ,false ,_ca .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_aac ._gfgfc [_cff ]=true ;defer delete (_aac ._gfgfc ,_cff );
_cffe ,_caf :=_aac ._daea .ObjectMap [_cff ];if !_caf {_cc .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _cab PdfObjectNull ;return &_cab ,false ,nil ;};_cc .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_cff );if _cffe .XType ==XrefTypeTableEntry {_cc .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_cffe .ObjectNumber );
_cc .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_cffe .Generation );_cc .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_cffe .Offset );
_aac ._bbdc .Seek (_cffe .Offset ,_ae .SeekStart );_aac ._dced =_ce .NewReader (_aac ._bbdc );_bcfd ,_cea :=_aac .ParseIndirectObject ();if _cea !=nil {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_cea );
if _eeb {_cc .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_fad ,_bfe :=_aac .repairRebuildXrefsTopDown ();
if _bfe !=nil {_cc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_bfe );return nil ,false ,_bfe ;};_aac ._daea =*_fad ;return _aac .lookupByNumber (_cff ,false );
};return nil ,false ,_cea ;};if _eeb {_cad ,_ ,_ :=_cfg (_bcfd );if int (_cad )!=_cff {_cc .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_ceag :=_aac .rebuildXrefTable ();
if _ceag !=nil {return nil ,false ,_ceag ;};_aac .ObjCache =objectCache {};return _aac .lookupByNumberWrapper (_cff ,false );};};_cc .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_aac .ObjCache [_cff ]=_bcfd ;
return _bcfd ,false ,nil ;}else if _cffe .XType ==XrefTypeObjectStream {_cc .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_cc .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_cc .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_cffe .OsObjNumber ,_cffe .OsObjIndex );
if _cffe .OsObjNumber ==_cff {_cc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_ca .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_bcg :=_aac ._daea .ObjectMap [_cffe .OsObjNumber ];_bcg {_eca ,_dcb :=_aac .lookupObjectViaOS (_cffe .OsObjNumber ,_cff );if _dcb !=nil {_cc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_dcb );
return nil ,true ,_dcb ;};_cc .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_aac .ObjCache [_cff ]=_eca ;if _aac ._bcgf !=nil {_aac ._bcgf ._dce [_eca ]=true ;};return _eca ,true ,nil ;};_cc .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_ca .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_ca .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_agda *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _agda .Predictor !=1{return nil ,_ggc .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _agda .EarlyChange ==1{return nil ,_ggc .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _fab _gff .Buffer ;_eced :=_dc .NewWriter (&_fab ,_dc .MSB ,8);_eced .Write (data );_eced .Close ();return _fab .Bytes (),nil ;};var _fgbf =_e .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");


// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;var _fgfgd _a .Map ;

// String returns a string describing `streams`.
func (_efbfa *PdfObjectStreams )String ()string {return _ggc .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_efbfa .ObjectNumber );};func (_dgg *PdfParser )xrefNextObjectOffset (_daga int64 )int64 {_cgefd :=int64 (0);
if len (_dgg ._daea .ObjectMap )==0{return 0;};if len (_dgg ._daea ._cge )==0{_fabc :=0;for _ ,_aeab :=range _dgg ._daea .ObjectMap {if _aeab .Offset > 0{_fabc ++;};};if _fabc ==0{return 0;};_dgg ._daea ._cge =make ([]XrefObject ,_fabc );_ffaa :=0;for _ ,_fbbb :=range _dgg ._daea .ObjectMap {if _fbbb .Offset > 0{_dgg ._daea ._cge [_ffaa ]=_fbbb ;
_ffaa ++;};};_cg .Slice (_dgg ._daea ._cge ,func (_dgcee ,_dgcca int )bool {return _dgg ._daea ._cge [_dgcee ].Offset < _dgg ._daea ._cge [_dgcca ].Offset });};_fdgd :=_cg .Search (len (_dgg ._daea ._cge ),func (_adfba int )bool {return _dgg ._daea ._cge [_adfba ].Offset >=_daga });
if _fdgd < len (_dgg ._daea ._cge ){_cgefd =_dgg ._daea ._cge [_fdgd ].Offset ;};return _cgefd ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_gbeeb *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _gbeeb .isEncrypted (obj ){return nil ;};switch _ggda :=obj .(type ){case *PdfIndirectObject :_gbeeb ._cfa [_ggda ]=true ;_cc .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_ggda .ObjectNumber ,_ggda .GenerationNumber );
_ged :=_ggda .ObjectNumber ;_fbc :=_ggda .GenerationNumber ;_ccgg :=_gbeeb .Encrypt (_ggda .PdfObject ,_ged ,_fbc );if _ccgg !=nil {return _ccgg ;};return nil ;case *PdfObjectStream :_gbeeb ._cfa [_ggda ]=true ;_badg :=_ggda .PdfObjectDictionary ;if _dfa ,_gfgcd :=_badg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_gfgcd &&*_dfa =="\u0058\u0052\u0065\u0066"{return nil ;};_egdg :=_ggda .ObjectNumber ;_acb :=_ggda .GenerationNumber ;_cc .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_egdg ,_acb );
_agcb :=_gee ;if _gbeeb ._dg .V >=4{_agcb =_gbeeb ._gcd ;_cc .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_gbeeb ._gcd );if _gba ,_bea :=_badg .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_bea {if _feca ,_gace :=GetName (_gba .Get (0));_gace {if *_feca =="\u0043\u0072\u0079p\u0074"{_agcb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _edeg ,_efc :=_badg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_efc {if _cfaa ,_cdedd :=_edeg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_cdedd {if _ ,_fbgc :=_gbeeb ._eebc [string (*_cfaa )];_fbgc {_cc .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_cfaa );
_agcb =string (*_cfaa );};};};};};};_cc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_agcb );if _agcb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bbg :=_gbeeb .Encrypt (_ggda .PdfObjectDictionary ,_egdg ,_acb );
if _bbg !=nil {return _bbg ;};_ceb ,_bbg :=_gbeeb .makeKey (_agcb ,uint32 (_egdg ),uint32 (_acb ),_gbeeb ._fgfa );if _bbg !=nil {return _bbg ;};_ggda .Stream ,_bbg =_gbeeb .encryptBytes (_ggda .Stream ,_agcb ,_ceb );if _bbg !=nil {return _bbg ;};_badg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ggda .Stream ))));
return nil ;case *PdfObjectString :_cc .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_cfeb :=_gee ;if _gbeeb ._dg .V >=4{_cc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gbeeb ._bad );
if _gbeeb ._bad =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_cfeb =_gbeeb ._bad ;};_dfgg ,_ddd :=_gbeeb .makeKey (_cfeb ,uint32 (parentObjNum ),uint32 (parentGenNum ),_gbeeb ._fgfa );if _ddd !=nil {return _ddd ;};_cgf :=_ggda .Str ();
_dga :=make ([]byte ,len (_cgf ));for _ebf :=0;_ebf < len (_cgf );_ebf ++{_dga [_ebf ]=_cgf [_ebf ];};_cc .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_dga ,_dga );
_dga ,_ddd =_gbeeb .encryptBytes (_dga ,_cfeb ,_dfgg );if _ddd !=nil {return _ddd ;};_ggda ._abcf =string (_dga );return nil ;case *PdfObjectArray :for _ ,_bgf :=range _ggda .Elements (){_gfeg :=_gbeeb .Encrypt (_bgf ,parentObjNum ,parentGenNum );if _gfeg !=nil {return _gfeg ;
};};return nil ;case *PdfObjectDictionary :_gaa :=false ;if _gcdc :=_ggda .Get ("\u0054\u0079\u0070\u0065");_gcdc !=nil {_dfed ,_fgd :=_gcdc .(*PdfObjectName );if _fgd &&*_dfed =="\u0053\u0069\u0067"{_gaa =true ;};};for _ ,_eceg :=range _ggda .Keys (){_ggcae :=_ggda .Get (_eceg );
if _gaa &&string (_eceg )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_eceg )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_eceg )!="\u0050\u0072\u0065\u0076"&&string (_eceg )!="\u004c\u0061\u0073\u0074"{_cafg :=_gbeeb .Encrypt (_ggcae ,parentObjNum ,parentGenNum );
if _cafg !=nil {return _cafg ;};};};return nil ;};return nil ;};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_ccd *JBIG2Encoder )DecodeImages (encoded []byte )([]_dd .Image ,error ){const _gcfd ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_agdg ,_gddf :=_gce .Decode (encoded ,_gce .Parameters {},_ccd .Globals .ToDocumentGlobals ());
if _gddf !=nil {return nil ,_b .Wrap (_gddf ,_gcfd ,"");};_abba ,_gddf :=_agdg .PageNumber ();if _gddf !=nil {return nil ,_b .Wrap (_gddf ,_gcfd ,"");};_gced :=[]_dd .Image {};var _cgbaf _dd .Image ;for _geff :=1;_geff <=_abba ;_geff ++{_cgbaf ,_gddf =_agdg .DecodePageImage (_geff );
if _gddf !=nil {return nil ,_b .Wrapf (_gddf ,_gcfd ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_geff );};_gced =append (_gced ,_cgbaf );};return _gced ,nil ;};func (_cgfc *PdfObjectDictionary )setWithLock (_cfbfa PdfObjectName ,_fdgb PdfObject ,_gaea bool ){if _gaea {_cgfc ._cbbc .Lock ();
defer _cgfc ._cbbc .Unlock ();};_ ,_gbaaa :=_cgfc ._cdebe [_cfbfa ];if !_gbaaa {_cgfc ._gccc =append (_cgfc ._gccc ,_cfbfa );};_cgfc ._cdebe [_cfbfa ]=_fdgb ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_ce .Reader )(PdfObject ,error ){_agcba :=false ;_dage :=true ;var _bagfd _gff .Buffer ;for {if _cc .Log .IsLogLevel (_cc .LogLevelTrace ){_cc .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_bagfd .String ());
};_afgeb ,_cbeda :=buf .Peek (1);if _cbeda ==_ae .EOF {break ;};if _cbeda !=nil {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_cbeda );return nil ,_cbeda ;};if _dage &&(_afgeb [0]=='-'||_afgeb [0]=='+'){_geacb ,_ :=buf .ReadByte ();
_bagfd .WriteByte (_geacb );_dage =false ;}else if IsDecimalDigit (_afgeb [0]){_gbeg ,_ :=buf .ReadByte ();_bagfd .WriteByte (_gbeg );}else if _afgeb [0]=='.'{_dabe ,_ :=buf .ReadByte ();_bagfd .WriteByte (_dabe );_agcba =true ;}else if _afgeb [0]=='e'||_afgeb [0]=='E'{_cbaa ,_ :=buf .ReadByte ();
_bagfd .WriteByte (_cbaa );_agcba =true ;_dage =true ;}else {break ;};};var _ecdg PdfObject ;if _agcba {_cdeg ,_geee :=_g .ParseFloat (_bagfd .String (),64);if _geee !=nil {_cc .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_bagfd .String (),_geee );
_cdeg =0.0;};_dcce :=PdfObjectFloat (_cdeg );_ecdg =&_dcce ;}else {_dacca ,_gaaag :=_g .ParseInt (_bagfd .String (),10,64);if _gaaag !=nil {_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_bagfd .String (),_gaaag );
_dacca =0;};_abfcc :=PdfObjectInteger (_dacca );_ecdg =&_abfcc ;};return _ecdg ,nil ;};func _facd (_baef PdfObject ,_agbgf int ,_gcef map[PdfObject ]struct{})error {_cc .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_agbgf );
if _ ,_eefff :=_gcef [_baef ];_eefff {_cc .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_gcef [_baef ]=struct{}{};switch _ebacc :=_baef .(type ){case *PdfIndirectObject :_daeac :=_ebacc ;
_cc .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_daeac );_cc .Log .Trace ("\u002d\u0020\u0025\u0073",_daeac .PdfObject );return _facd (_daeac .PdfObject ,_agbgf +1,_gcef );case *PdfObjectStream :_cccea :=_ebacc ;return _facd (_cccea .PdfObjectDictionary ,_agbgf +1,_gcef );
case *PdfObjectDictionary :_daab :=_ebacc ;_cc .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_daab );for _ ,_bgdfa :=range _daab .Keys (){_eeace :=_daab .Get (_bgdfa );if _ccced ,_fgagb :=_eeace .(*PdfObjectReference );_fgagb {_gdbd :=_ccced .Resolve ();
_daab .Set (_bgdfa ,_gdbd );_bdea :=_facd (_gdbd ,_agbgf +1,_gcef );if _bdea !=nil {return _bdea ;};}else {_ddcde :=_facd (_eeace ,_agbgf +1,_gcef );if _ddcde !=nil {return _ddcde ;};};};return nil ;case *PdfObjectArray :_addeb :=_ebacc ;_cc .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_addeb );
for _bbefe ,_ceeg :=range _addeb .Elements (){if _ecfede ,_bdfcf :=_ceeg .(*PdfObjectReference );_bdfcf {_gcaca :=_ecfede .Resolve ();_addeb .Set (_bbefe ,_gcaca );_decd :=_facd (_gcaca ,_agbgf +1,_gcef );if _decd !=nil {return _decd ;};}else {_gbece :=_facd (_ceeg ,_agbgf +1,_gcef );
if _gbece !=nil {return _gbece ;};};};return nil ;case *PdfObjectReference :_cc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _ca .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};func _aae (_ad int )cryptFilters {return cryptFilters {_gee :_ba .NewFilterV2 (_ad )}};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eea *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetParser returns the parser for lazy-loading or compare references.
func (_aecc *PdfObjectReference )GetParser ()*PdfParser {return _aecc ._aacab };var _afa =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};func (_egfga *PdfParser )parsePdfVersion ()(int ,int ,error ){var _caeg int64 =20;_aebc :=make ([]byte ,_caeg );
_egfga ._bbdc .Seek (0,_ae .SeekStart );_egfga ._bbdc .Read (_aebc );var _ebbdf error ;var _acfd ,_aadg int ;if _dedb :=_edcd .FindStringSubmatch (string (_aebc ));len (_dedb )< 3{if _acfd ,_aadg ,_ebbdf =_egfga .seekPdfVersionTopDown ();_ebbdf !=nil {_cc .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_ebbdf ;};_egfga ._bbdc ,_ebbdf =_fefe (_egfga ._bbdc ,_egfga .GetFileOffset ()-8);if _ebbdf !=nil {return 0,0,_ebbdf ;};}else {if _acfd ,_ebbdf =_g .Atoi (_dedb [1]);_ebbdf !=nil {return 0,0,_ebbdf ;};if _aadg ,_ebbdf =_g .Atoi (_dedb [2]);
_ebbdf !=nil {return 0,0,_ebbdf ;};_egfga .SetFileOffset (0);};_egfga ._dced =_ce .NewReader (_egfga ._bbdc );_cc .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_acfd ,_aadg );return _acfd ,_aadg ,nil ;
};

// UpdateParams updates the parameter values of the encoder.
func (_gcgg *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_cbcc ,_adfd :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _adfd ==nil {_gcgg .Predictor =int (_cbcc );};_cdf ,_adfd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _adfd ==nil {_gcgg .BitsPerComponent =int (_cdf );};_abaeg ,_adfd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _adfd ==nil {_gcgg .Columns =int (_abaeg );};_dbgb ,_adfd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _adfd ==nil {_gcgg .Colors =int (_dbgb );};_fefa ,_adfd :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _adfd ==nil {_gcgg .EarlyChange =int (_fefa );};};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_dg encryptDict ;_bccd _dec .StdEncryptDict ;_ccb string ;_fgfa []byte ;_dce map[PdfObject ]bool ;_cfa map[PdfObject ]bool ;_efe bool ;_eebc cryptFilters ;_gcd string ;_bad string ;_ece *PdfParser ;_gbee map[int ]struct{};};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_gc .Model ;Bounds ()_dd .Rectangle ;At (_gdae ,_bfbf int )_gc .Color ;Set (_afag ,_ddcd int ,_afeg _gc .Color );};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_eccf *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_cgbb error ){const _cdb ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _eccf ==nil {return _b .Error (_cdb ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_eccf .DefaultPageSettings ;};if _eccf ._degb ==nil {_eccf ._degb =_gbg .InitEncodeDocument (settings .FileMode );
};if _cgbb =settings .Validate ();_cgbb !=nil {return _b .Wrap (_cgbb ,_cdb ,"");};_bfdb ,_cgbb :=img .toBitmap ();if _cgbb !=nil {return _b .Wrap (_cgbb ,_cdb ,"");};switch settings .Compression {case JB2Generic :if _cgbb =_eccf ._degb .AddGenericPage (_bfdb ,settings .DuplicatedLinesRemoval );
_cgbb !=nil {return _b .Wrap (_cgbb ,_cdb ,"");};case JB2SymbolCorrelation :return _b .Error (_cdb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _b .Error (_cdb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _b .Error (_cdb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// Seek implementation of Seek interface.
func (_bgef *limitedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){var _dgce int64 ;switch whence {case _ae .SeekStart :_dgce =offset ;case _ae .SeekCurrent :_ecba ,_gcbd :=_bgef ._aaca .Seek (0,_ae .SeekCurrent );if _gcbd !=nil {return 0,_gcbd ;
};_dgce =_ecba +offset ;case _ae .SeekEnd :_dgce =_bgef ._ffbdf +offset ;};if _fdda :=_bgef .getError (_dgce );_fdda !=nil {return 0,_fdda ;};if _ ,_egbf :=_bgef ._aaca .Seek (_dgce ,_ae .SeekStart );_egbf !=nil {return 0,_egbf ;};return _dgce ,nil ;};


// ParserMetadata gets the pdf parser metadata.
func (_aff *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_aff ._cgaa {return ParserMetadata {},_ggc .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _aff ._ggcdd ,nil ;};func (_feddb *PdfParser )parseLinearizedDictionary ()(*PdfObjectDictionary ,error ){_cbffa ,_aedg :=_feddb ._bbdc .Seek (0,_ae .SeekEnd );if _aedg !=nil {return nil ,_aedg ;};var _dadc int64 ;var _gfcc int64 =2048;for _dadc < _cbffa -4{if _cbffa <=(_gfcc +_dadc ){_gfcc =_cbffa -_dadc ;
};_ ,_dbab :=_feddb ._bbdc .Seek (_dadc ,_ae .SeekStart );if _dbab !=nil {return nil ,_dbab ;};_efcg :=make ([]byte ,_gfcc );_ ,_dbab =_feddb ._bbdc .Read (_efcg );if _dbab !=nil {return nil ,_dbab ;};_cc .Log .Trace ("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022",string (_efcg ));
_agaf :=_eeef .FindAllStringIndex (string (_efcg ),-1);if _agaf !=nil {_bacb :=_agaf [0];_cc .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_agaf );_ ,_daed :=_feddb ._bbdc .Seek (int64 (_bacb [0]),_ae .SeekStart );if _daed !=nil {return nil ,_daed ;
};_feddb ._dced =_ce .NewReader (_feddb ._bbdc );_cfdec ,_daed :=_feddb .ParseIndirectObject ();if _daed !=nil {return nil ,nil ;};if _fged ,_dagd :=GetIndirect (_cfdec );_dagd {if _gcbe ,_dbaa :=GetDict (_fged .PdfObject );_dbaa {if _gcaac :=_gcbe .Get ("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064");
_gcaac !=nil {return _gcbe ,nil ;};return nil ,nil ;};};return nil ,nil ;};_dadc +=_gfcc -4;};return nil ,_ca .New ("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064");
};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_adgc *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _gbce []byte ;_cc .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_ggba :=0;_cgfd :=false ;for _ggba < len (encoded )&&!_cgfd {_facb :=[5]byte {0,0,0,0,0};
_dcac :=0;_gegf :=0;_eabc :=4;for _gegf < 5+_dcac {if _ggba +_gegf ==len (encoded ){break ;};_geba :=encoded [_ggba +_gegf ];if IsWhiteSpace (_geba ){_dcac ++;_gegf ++;continue ;}else if _geba =='~'&&_ggba +_gegf +1< len (encoded )&&encoded [_ggba +_gegf +1]=='>'{_eabc =(_gegf -_dcac )-1;
if _eabc < 0{_eabc =0;};_cgfd =true ;break ;}else if _geba >='!'&&_geba <='u'{_geba -='!';}else if _geba =='z'&&_gegf -_dcac ==0{_eabc =4;_gegf ++;break ;}else {_cc .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_ca .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_facb [_gegf -_dcac ]=_geba ;_gegf ++;};_ggba +=_gegf ;for _dfbbc :=_eabc +1;_dfbbc < 5;_dfbbc ++{_facb [_dfbbc ]=84;
};_babe :=uint32 (_facb [0])*85*85*85*85+uint32 (_facb [1])*85*85*85+uint32 (_facb [2])*85*85+uint32 (_facb [3])*85+uint32 (_facb [4]);_efbf :=[]byte {byte ((_babe >>24)&0xff),byte ((_babe >>16)&0xff),byte ((_babe >>8)&0xff),byte (_babe &0xff)};_gbce =append (_gbce ,_efbf [:_eabc ]...);
};_cc .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_cc .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_gbce );
return _gbce ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ggebc *PdfObjectArray )WriteString ()string {var _cdgec _gb .Builder ;_cdgec .WriteString ("\u005b");for _ffbbd ,_gfbef :=range _ggebc .Elements (){_cdgec .WriteString (_gfbef .WriteString ());if _ffbbd < (_ggebc .Len ()-1){_cdgec .WriteString ("\u0020");
};};_cdgec .WriteString ("\u005d");return _cdgec .String ();};

// LookupByReference looks up a PdfObject by a reference.
func (_aag *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_cc .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _aag .LookupByNumber (int (ref .ObjectNumber ));
};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _ebeg _gff .Buffer ;_ebeg .Write ([]byte {0xFE,0xFF});_ebeg .WriteString (_fb .StringToUTF16 (s ));return &PdfObjectString {_abcf :_ebeg .String (),_caeb :true };};return &PdfObjectString {_abcf :string (_fb .StringToPDFDocEncoding (s )),_caeb :false };
};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// DecodeStream implements ASCII85 stream decoding.
func (_cadf *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cadf .DecodeBytes (streamObj .Stream );};

// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_dfggf *PdfParser )GetPreviousRevisionReadSeeker ()(_ae .ReadSeeker ,error ){if _cbdb :=_dfggf .seekToEOFMarker (_dfggf ._ddgd -_gdaf );_cbdb !=nil {return nil ,_cbdb ;};_gcab ,_aebcf :=_dfggf ._bbdc .Seek (0,_ae .SeekCurrent );if _aebcf !=nil {return nil ,_aebcf ;
};_gcab +=_gdaf ;return _ebgbe (_dfggf ._bbdc ,_gcab );};func _bada (_eefd *_dec .StdEncryptDict ,_dfb *PdfObjectDictionary ){_dfb .Set ("\u0052",MakeInteger (int64 (_eefd .R )));_dfb .Set ("\u0050",MakeInteger (int64 (_eefd .P )));_dfb .Set ("\u004f",MakeStringFromBytes (_eefd .O ));
_dfb .Set ("\u0055",MakeStringFromBytes (_eefd .U ));if _eefd .R >=5{_dfb .Set ("\u004f\u0045",MakeStringFromBytes (_eefd .OE ));_dfb .Set ("\u0055\u0045",MakeStringFromBytes (_eefd .UE ));_dfb .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_eefd .EncryptMetadata ));
if _eefd .R > 5{_dfb .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_eefd .Perms ));};};};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";
StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);func (_afba *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_ae .SeekStart {offset +=_afba ._dafcg ;
};_ggef ,_bcfdf :=_afba ._dafec .Seek (offset ,whence );if _bcfdf !=nil {return _ggef ,_bcfdf ;};if whence ==_ae .SeekCurrent {_ggef -=_afba ._dafcg ;};if _ggef < 0{return 0,_ca .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _ggef ,nil ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_gcgad :objects }};

// GetRevisionNumber returns the current version of the Pdf document.
func (_afgga *PdfParser )GetRevisionNumber ()int {return _afgga ._dcbdf };

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_ggggc *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _faae []float64 ;for _ ,_becfb :=range _ggggc .Elements (){_eacf ,_eggfd :=GetNumberAsFloat (TraceToDirectObject (_becfb ));if _eggfd !=nil {return nil ,_ggc .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_faae =append (_faae ,_eacf );};return _faae ,nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_effd *PdfParser )GetXrefType ()*xrefType {return _effd ._fefbf };

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_eadf *MultiEncoder )AddEncoder (encoder StreamEncoder ){_eadf ._ceba =append (_eadf ._ceba ,encoder );};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_dbge *PdfObjectArray )Get (i int )PdfObject {if _dbge ==nil ||i >=len (_dbge ._gcgad )||i < 0{return nil ;};return _dbge ._gcgad [i ];};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_adcc *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _afdgd []float64 ;for _ ,_cbgd :=range _adcc .Elements (){switch _bdeb :=_cbgd .(type ){case *PdfObjectInteger :_afdgd =append (_afdgd ,float64 (*_bdeb ));case *PdfObjectFloat :_afdgd =append (_afdgd ,float64 (*_bdeb ));
default:return nil ,ErrTypeError ;};};return _afdgd ,nil ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_dfdb :=&PdfIndirectObject {};_dfdb .PdfObject =obj ;return _dfdb ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_afggab *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _cgeeg []int ;for _ ,_fgag :=range _afggab .Elements (){if _fagbd ,_aabg :=_fgag .(*PdfObjectInteger );_aabg {_cgeeg =append (_cgeeg ,int (*_fagbd ));}else {return nil ,ErrTypeError ;};
};return _cgeeg ,nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_cfaf JBIG2EncoderSettings )Validate ()error {const _fccf ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _cfaf .Threshold < 0||_cfaf .Threshold > 1.0{return _b .Errorf (_fccf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_cfaf .Threshold );
};if _cfaf .ResolutionX < 0{return _b .Errorf (_fccf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_cfaf .ResolutionX );
};if _cfaf .ResolutionY < 0{return _b .Errorf (_fccf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_cfaf .ResolutionY );
};if _cfaf .DefaultPixelValue !=0&&_cfaf .DefaultPixelValue !=1{return _b .Errorf (_fccf ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_cfaf .DefaultPixelValue );
};if _cfaf .Compression !=JB2Generic {return _b .Errorf (_fccf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_ccgc *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ccgc .DecodeBytes (streamObj .Stream );};func (_bacdd *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_bacdd ._dced )};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_dgcg *PdfObjectString )Decoded ()string {if _dgcg ==nil {return "";};_caed :=[]byte (_dgcg ._abcf );if len (_caed )>=2&&_caed [0]==0xFE&&_caed [1]==0xFF{return _fb .UTF16ToString (_caed [2:]);};return _fb .PDFDocEncodingToString (_caed );};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_eeged :=PdfObjectNull {};return &_eeged };

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_adg *PdfObjectDictionary );EncodeBytes (_deaf []byte )([]byte ,error );DecodeBytes (_bcge []byte )([]byte ,error );
DecodeStream (_bcad *PdfObjectStream )([]byte ,error );};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_cdab *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_cdab ._cbbc .Lock ();defer _cdab ._cbbc .Unlock ();for _ababa ,_adac :=range objmap {_cdab .setWithLock (PdfObjectName (_ababa ),_adac ,false );};return _cdab ;
};func (_eefg *PdfParser )checkLinearizedInformation (_fbcdfa *PdfObjectDictionary )(bool ,error ){var _gdfgc error ;_eefg ._bdbe ,_gdfgc =GetNumberAsInt64 (_fbcdfa .Get ("\u004c"));if _gdfgc !=nil {return false ,_gdfgc ;};_gdfgc =_eefg .seekToEOFMarker (_eefg ._bdbe );
switch _gdfgc {case nil :return true ,nil ;case _ffae :return false ,nil ;default:return false ,_gdfgc ;};};

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_cda *PdfObjectString )IsHexadecimal ()bool {return _cda ._caeb };

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_cdebe map[PdfObjectName ]PdfObject ;_gccc []PdfObjectName ;_cbbc *_a .Mutex ;_dbcgf *PdfParser ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _facd (o ,0,traversed );};

// String returns a string describing `array`.
func (_geec *PdfObjectArray )String ()string {_faga :="\u005b";for _acae ,_beee :=range _geec .Elements (){_faga +=_beee .String ();if _acae < (_geec .Len ()-1){_faga +="\u002c\u0020";};};_faga +="\u005d";return _faga ;};func (_afgfe *PdfParser )seekToEOFMarker (_egbe int64 )error {var _ffbb int64 ;
var _ddbbb int64 =2048;for _ffbb < _egbe -4{if _egbe <=(_ddbbb +_ffbb ){_ddbbb =_egbe -_ffbb ;};_ ,_ffgbb :=_afgfe ._bbdc .Seek (_egbe -_ffbb -_ddbbb ,_ae .SeekStart );if _ffgbb !=nil {return _ffgbb ;};_abagc :=make ([]byte ,_ddbbb );_afgfe ._bbdc .Read (_abagc );
_cc .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_abagc ));_feea :=_fcdf .FindAllStringIndex (string (_abagc ),-1);if _feea !=nil {_edce :=_feea [len (_feea )-1];
_cc .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_feea );_degfe :=_egbe -_ffbb -_ddbbb +int64 (_edce [0]);_afgfe ._bbdc .Seek (_degfe ,_ae .SeekStart );return nil ;};_cc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_ffbb +=_ddbbb -4;};_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _ffae ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// GetFilterName returns the name of the encoding filter.
func (_cbag *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };func (_aeaae *PdfObjectFloat )String ()string {return _ggc .Sprintf ("\u0025\u0066",*_aeaae )};func (_cbge *PdfParser )checkPostEOFData ()error {const _cebc ="\u0025\u0025\u0045O\u0046";
_ ,_dddb :=_cbge ._bbdc .Seek (-int64 (len ([]byte (_cebc )))-1,_ae .SeekEnd );if _dddb !=nil {return _dddb ;};_edef :=make ([]byte ,len ([]byte (_cebc ))+1);_ ,_dddb =_cbge ._bbdc .Read (_edef );if _dddb !=nil {if _dddb !=_ae .EOF {return _dddb ;};};if string (_edef )==_cebc ||string (_edef )==_cebc +"\u000a"{_cbge ._ggcdd ._cdde =true ;
};return nil ;};

// GetXrefTable returns the PDFs xref table.
func (_abdfg *PdfParser )GetXrefTable ()XrefTable {return _abdfg ._daea };type objectStream struct{N int ;_aed []byte ;_ea map[int ]int64 ;};

// UpdateParams updates the parameter values of the encoder.
func (_agbg *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// Append appends PdfObject(s) to the streams.
func (_eebag *PdfObjectStreams )Append (objects ...PdfObject ){if _eebag ==nil {_cc .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_eebag ._eagf =append (_eebag ._eagf ,objects ...);};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_feac :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _feac ==nil {return NewRawEncoder (),nil ;};if _ ,_bggae :=_feac .(*PdfObjectNull );
_bggae {return NewRawEncoder (),nil ;};_eedd ,_gcebf :=_feac .(*PdfObjectName );if !_gcebf {_gggae ,_fbfc :=_feac .(*PdfObjectArray );if !_fbfc {return nil ,_ggc .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _gggae .Len ()==0{return NewRawEncoder (),nil ;};if _gggae .Len ()!=1{_eedc ,_eebe :=_bffd (streamObj );if _eebe !=nil {_cc .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_eebe );
return nil ,_eebe ;};_cc .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_eedc );return _eedc ,nil ;};_feac =_gggae .Get (0);_eedd ,_fbfc =_feac .(*PdfObjectName );if !_fbfc {return nil ,_ggc .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _efefb ,_dgab :=_fgfgd .Load (_eedd .String ());_dgab {return _efefb .(StreamEncoder ),nil ;};switch *_eedd {case StreamEncodingFilterNameFlate :return _ddec (streamObj ,nil );case StreamEncodingFilterNameLZW :return _beae (streamObj ,nil );case StreamEncodingFilterNameDCT :return _fdea (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _ecgc (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _egfb (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _gfag (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_cc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_ggc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_eedd );};func _bacg (_caded string )(int ,int ,error ){_gbacb :=_eeef .FindStringSubmatch (_caded );
if len (_gbacb )< 3{return 0,0,_ca .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_ddggb ,_ :=_g .Atoi (_gbacb [1]);_efff ,_ :=_g .Atoi (_gbacb [2]);return _ddggb ,_efff ,nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_gdeda *PdfObjectBool ,_fgfd bool ){_gdeda ,_fgfd =TraceToDirectObject (obj ).(*PdfObjectBool );return _gdeda ,_fgfd ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_ebcbg *PdfObjectName ,_bbac bool ){_ebcbg ,_bbac =TraceToDirectObject (obj ).(*PdfObjectName );return _ebcbg ,_bbac ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _aabb (obj1 ,obj2 ,0)};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dffd *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_aegf :=MakeDict ();_aegf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_dffd .GetFilterArray ());for _ ,_ggfc :=range _dffd ._ceba {_ffad :=_ggfc .MakeStreamDict ();for _ ,_aeed :=range _ffad .Keys (){_gafc :=_ffad .Get (_aeed );
if _aeed !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_aeed !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_aegf .Set (_aeed ,_gafc );};};};_dddc :=_dffd .MakeDecodeParams ();if _dddc !=nil {_aegf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dddc );
};return _aegf ;};

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_eaee *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _eaee ._fgbfd };

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ddf *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ggde *PdfObjectStream )WriteString ()string {var _gcfc _gb .Builder ;_gcfc .WriteString (_g .FormatInt (_ggde .ObjectNumber ,10));_gcfc .WriteString ("\u0020\u0030\u0020\u0052");return _gcfc .String ();};func (_aceg *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){_aceg .skipSpaces ();
const _cdge =20;_cgfb ,_ :=_aceg ._dced .Peek (_cdge );for _fdgf :=0;_fdgf < 2;_fdgf ++{if _aceg ._defc ==0{_aceg ._defc =_aceg .GetFileOffset ();};if _eeef .Match (_cgfb ){_cc .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_cc .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_cgfb ));return _aceg .parseXrefStream (nil );};if _cbb .Match (_cgfb ){_cc .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _aceg .parseXrefTable ();};_gabcg :=_aceg .GetFileOffset ();if _aceg ._defc ==0{_aceg ._defc =_gabcg ;};_aceg .SetFileOffset (_gabcg -_cdge );defer _aceg .SetFileOffset (_gabcg );_bfca ,_ :=_aceg ._dced .Peek (_cdge );_cgfb =append (_bfca ,_cgfb ...);
};_cc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _gfee :=_aceg .repairSeekXrefMarker ();_gfee !=nil {_cc .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_gfee );return nil ,_gfee ;};return _aceg .parseXrefTable ();};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_ddagg *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_ddagg ._gcgad ){return _ca .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_ddagg ._gcgad [i ]=obj ;return nil ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_cdggb :=&PdfObjectDictionary {};_cdggb ._cdebe =map[PdfObjectName ]PdfObject {};_cdggb ._gccc =[]PdfObjectName {};_cdggb ._cbbc =&_a .Mutex {};return _cdggb ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_cbaf *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bgde _gff .Buffer ;_cfde :=_gff .NewReader (encoded );var _gaaf _ae .ReadCloser ;if _cbaf .EarlyChange ==1{_gaaf =_eb .NewReader (_cfde ,_eb .MSB ,8);}else {_gaaf =_dc .NewReader (_cfde ,_dc .MSB ,8);
};defer _gaaf .Close ();if _ ,_aea :=_bgde .ReadFrom (_gaaf );_aea !=nil {if _aea !=_ae .ErrUnexpectedEOF ||_bgde .Len ()==0{return nil ,_aea ;};_cc .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_aea );
};return _bgde .Bytes (),nil ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_beeag Version ;_bbdc _ae .ReadSeeker ;_dced *_ce .Reader ;_ddgd int64 ;_daea XrefTable ;_defc int64 ;_fefbf *xrefType ;_dgbe objectStreams ;_cege *PdfObjectDictionary ;_bcgf *PdfCrypt ;_fgbfd *PdfIndirectObject ;_acee bool ;ObjCache objectCache ;
_gfgfc map[int ]bool ;_debg map[int64 ]bool ;_ggcdd ParserMetadata ;_cgaa bool ;_gfbd []int64 ;_dcbdf int ;_cebe bool ;_bdbe int64 ;_dbag map[*PdfParser ]*PdfParser ;_bbad []*PdfParser ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_fbac *PdfParser )IsEncrypted ()(bool ,error ){if _fbac ._bcgf !=nil {return true ,nil ;}else if _fbac ._cege ==nil {return false ,nil ;};_cc .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_dacf :=_fbac ._cege .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _dacf ==nil {return false ,nil ;};_cc .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_feec *PdfObjectDictionary ;);switch _efac :=_dacf .(type ){case *PdfObjectDictionary :_feec =_efac ;
case *PdfObjectReference :_cc .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_efac );_ddaa ,_cfea :=_fbac .LookupByReference (*_efac );_cc .Log .Trace ("\u0031\u003a\u0020%\u0071",_ddaa );
if _cfea !=nil {return false ,_cfea ;};_ebadf ,_badae :=_ddaa .(*PdfIndirectObject );if !_badae {_cc .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_ca .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_babgg ,_badae :=_ebadf .PdfObject .(*PdfObjectDictionary );_fbac ._fgbfd =_ebadf ;_cc .Log .Trace ("\u0032\u003a\u0020%\u0071",_babgg );
if !_badae {return false ,_ca .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_feec =_babgg ;
case *PdfObjectNull :_cc .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_ggc .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_efac );};_deag ,_aecb :=PdfCryptNewDecrypt (_fbac ,_feec ,_fbac ._cege );if _aecb !=nil {return false ,_aecb ;
};for _ ,_agefe :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_fceg :=_fbac ._cege .Get (PdfObjectName (_agefe ));if _fceg ==nil {continue ;};switch _aeecc :=_fceg .(type ){case *PdfObjectReference :_deag ._gbee [int (_aeecc .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_deag ._dce [_aeecc ]=true ;_deag ._gbee [int (_aeecc .ObjectNumber )]=struct{}{};};};_fbac ._bcgf =_deag ;_cc .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_deag );
return true ,nil ;};func (_bcc *PdfParser )lookupByNumberWrapper (_fd int ,_fa bool )(PdfObject ,bool ,error ){_bcd ,_gfg ,_bcf :=_bcc .lookupByNumber (_fd ,_fa );if _bcf !=nil {return nil ,_gfg ,_bcf ;};if !_gfg &&_bcc ._bcgf !=nil &&_bcc ._bcgf ._efe &&!_bcc ._bcgf .isDecrypted (_bcd ){_cec :=_bcc ._bcgf .Decrypt (_bcd ,0,0);
if _cec !=nil {return nil ,_gfg ,_cec ;};};return _bcd ,_gfg ,nil ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_aafd *PdfParser )Inspect ()(map[string ]int ,error ){return _aafd .inspect ()};func (_eaefa *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _eaefa ._acee {return nil ,_ggc .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_eaefa ._acee =true ;_eaefa ._bbdc .Seek (0,_ae .SeekStart );_eaefa ._dced =_ce .NewReader (_eaefa ._bbdc );_dcbba :=20;_cbafg :=make ([]byte ,_dcbba );_fabcg :=XrefTable {};_fabcg .ObjectMap =make (map[int ]XrefObject );for {_addd ,_dcff :=_eaefa ._dced .ReadByte ();
if _dcff !=nil {if _dcff ==_ae .EOF {break ;}else {return nil ,_dcff ;};};if _addd =='j'&&_cbafg [_dcbba -1]=='b'&&_cbafg [_dcbba -2]=='o'&&IsWhiteSpace (_cbafg [_dcbba -3]){_bfgf :=_dcbba -4;for IsWhiteSpace (_cbafg [_bfgf ])&&_bfgf > 0{_bfgf --;};if _bfgf ==0||!IsDecimalDigit (_cbafg [_bfgf ]){continue ;
};for IsDecimalDigit (_cbafg [_bfgf ])&&_bfgf > 0{_bfgf --;};if _bfgf ==0||!IsWhiteSpace (_cbafg [_bfgf ]){continue ;};for IsWhiteSpace (_cbafg [_bfgf ])&&_bfgf > 0{_bfgf --;};if _bfgf ==0||!IsDecimalDigit (_cbafg [_bfgf ]){continue ;};for IsDecimalDigit (_cbafg [_bfgf ])&&_bfgf > 0{_bfgf --;
};if _bfgf ==0{continue ;};_cgge :=_eaefa .GetFileOffset ()-int64 (_dcbba -_bfgf );_bgdd :=append (_cbafg [_bfgf +1:],_addd );_abfg ,_gdacg ,_cfec :=_bacg (string (_bgdd ));if _cfec !=nil {_cc .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_cfec );
return nil ,_cfec ;};if _cdfb ,_gfga :=_fabcg .ObjectMap [_abfg ];!_gfga ||_cdfb .Generation < _gdacg {_eage :=XrefObject {};_eage .XType =XrefTypeTableEntry ;_eage .ObjectNumber =_abfg ;_eage .Generation =_gdacg ;_eage .Offset =_cgge ;_fabcg .ObjectMap [_abfg ]=_eage ;
};};_cbafg =append (_cbafg [1:_dcbba ],_addd );};_eaefa ._gfgfc =nil ;return &_fabcg ,nil ;};func (_bed *PdfCrypt )loadCryptFilters (_gcb *PdfObjectDictionary )error {_bed ._eebc =cryptFilters {};_ggcd :=_gcb .Get ("\u0043\u0046");_ggcd =TraceToDirectObject (_ggcd );
if _ecd ,_dcd :=_ggcd .(*PdfObjectReference );_dcd {_fgg ,_gec :=_bed ._ece .LookupByReference (*_ecd );if _gec !=nil {_cc .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _gec ;};_ggcd =TraceToDirectObject (_fgg );};_gdfc ,_bda :=_ggcd .(*PdfObjectDictionary );if !_bda {_cc .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_ggcd );return _ca .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_dfd :=range _gdfc .Keys (){_adf :=_gdfc .Get (_dfd );if _cde ,_cada :=_adf .(*PdfObjectReference );_cada {_acc ,_dcdc :=_bed ._ece .LookupByReference (*_cde );if _dcdc !=nil {_cc .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _dcdc ;};_adf =TraceToDirectObject (_acc );};_agb ,_ccba :=_adf .(*PdfObjectDictionary );if !_ccba {return _ggc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_dfd ,_adf );
};if _dfd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _gge _ba .FilterDict ;if _ege :=_afg (&_gge ,_agb );_ege !=nil {return _ege ;};_dffg ,_bec :=_ba .NewFilter (_gge );if _bec !=nil {return _bec ;};_bed ._eebc [string (_dfd )]=_dffg ;};_bed ._eebc ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ba .NewIdentity ();
_bed ._bad ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fde ,_fgbg :=_gcb .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_fgbg {if _ ,_cee :=_bed ._eebc [string (*_fde )];!_cee {return _ggc .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fde );
};_bed ._bad =string (*_fde );};_bed ._gcd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fgge ,_ffd :=_gcb .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_ffd {if _ ,_bfgg :=_bed ._eebc [string (*_fgge )];!_bfgg {return _ggc .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fgge );
};_bed ._gcd =string (*_fgge );};return nil ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};var _afff =_e .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bedd *PdfCrypt )GetAccessPermissions ()_dec .Permissions {return _bedd ._bccd .P };

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_agdag *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_agdag ._cbbc .Lock ();defer _agdag ._cbbc .Unlock ();_cafbcf ,_cgcf :=_agdag ._cdebe [key ];if !_cgcf {return nil ;};return _cafbcf ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// GetFilterName returns the name of the encoding filter.
func (_eddf *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_ceac *PdfParser )Decrypt (password []byte )(bool ,error ){if _ceac ._bcgf ==nil {return false ,_ca .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_gcc ,_aged :=_ceac ._bcgf .authenticate (password );
if _aged !=nil {return false ,_aged ;};if !_gcc {_gcc ,_aged =_ceac ._bcgf .authenticate ([]byte (""));};return _gcc ,_aged ;};func _ecgc (_feff *PdfObjectStream ,_ffbd *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;
};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_badaf *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_beddf :=_gff .NewReader (data );var _agbde []byte ;var _bgb []byte ;_cfbg ,_acag :=_beddf .ReadByte ();if _acag ==_ae .EOF {return []byte {},nil ;}else if _acag !=nil {return nil ,_acag ;
};_cecf :=1;for {_bgfc ,_efea :=_beddf .ReadByte ();if _efea ==_ae .EOF {break ;}else if _efea !=nil {return nil ,_efea ;};if _bgfc ==_cfbg {if len (_bgb )> 0{_bgb =_bgb [:len (_bgb )-1];if len (_bgb )> 0{_agbde =append (_agbde ,byte (len (_bgb )-1));_agbde =append (_agbde ,_bgb ...);
};_cecf =1;_bgb =[]byte {};};_cecf ++;if _cecf >=127{_agbde =append (_agbde ,byte (257-_cecf ),_cfbg );_cecf =0;};}else {if _cecf > 0{if _cecf ==1{_bgb =[]byte {_cfbg };}else {_agbde =append (_agbde ,byte (257-_cecf ),_cfbg );};_cecf =0;};_bgb =append (_bgb ,_bgfc );
if len (_bgb )>=127{_agbde =append (_agbde ,byte (len (_bgb )-1));_agbde =append (_agbde ,_bgb ...);_bgb =[]byte {};};};_cfbg =_bgfc ;};if len (_bgb )> 0{_agbde =append (_agbde ,byte (len (_bgb )-1));_agbde =append (_agbde ,_bgb ...);}else if _cecf > 0{_agbde =append (_agbde ,byte (257-_cecf ),_cfbg );
};_agbde =append (_agbde ,128);return _agbde ,nil ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// WriteString outputs the object as it is to be written to file.
func (_abab *PdfObjectString )WriteString ()string {var _baba _gff .Buffer ;if _abab ._caeb {_febd :=_ag .EncodeToString (_abab .Bytes ());_baba .WriteString ("\u003c");_baba .WriteString (_febd );_baba .WriteString ("\u003e");return _baba .String ();};
_gabgd :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_baba .WriteString ("\u0028");for _gaca :=0;_gaca < len (_abab ._abcf );
_gaca ++{_cfgd :=_abab ._abcf [_gaca ];if _adb ,_bbdcd :=_gabgd [_cfgd ];_bbdcd {_baba .WriteString (_adb );}else {_baba .WriteByte (_cfgd );};};_baba .WriteString ("\u0029");return _baba .String ();};

// HeaderCommentBytes gets the header comment bytes.
func (_dbc ParserMetadata )HeaderCommentBytes ()[4]byte {return _dbc ._fcda };func (_bgaa *PdfParser )getNumbersOfUpdatedObjects (_gacg *PdfParser )([]int ,error ){if _gacg ==nil {return nil ,_ca .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_gfefb :=_gacg ._ddgd ;_bgaf :=make ([]int ,0);_cdfd :=make (map[int ]interface{});_gaae :=make (map[int ]int64 );for _afbabb ,_cbdd :=range _bgaa ._daea .ObjectMap {if _cbdd .Offset ==0{if _cbdd .OsObjNumber !=0{if _deebg ,_cbab :=_bgaa ._daea .ObjectMap [_cbdd .OsObjNumber ];
_cbab {_cdfd [_cbdd .OsObjNumber ]=struct{}{};_gaae [_afbabb ]=_deebg .Offset ;}else {return nil ,_ca .New ("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065");};};}else {_gaae [_afbabb ]=_cbdd .Offset ;};
};for _dbdb ,_eda :=range _gaae {if _ ,_ecfe :=_cdfd [_dbdb ];_ecfe {continue ;};if _eda > _gfefb {_bgaf =append (_bgaf ,_dbdb );};};return _bgaf ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_adee *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_cbcca *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _acbc :=val .(type ){case *PdfObjectName :if _acbc !=nil {_cbcca .Set (key ,val );};case *PdfObjectDictionary :if _acbc !=nil {_cbcca .Set (key ,val );
};case *PdfObjectStream :if _acbc !=nil {_cbcca .Set (key ,val );};case *PdfObjectString :if _acbc !=nil {_cbcca .Set (key ,val );};case *PdfObjectNull :if _acbc !=nil {_cbcca .Set (key ,val );};case *PdfObjectInteger :if _acbc !=nil {_cbcca .Set (key ,val );
};case *PdfObjectArray :if _acbc !=nil {_cbcca .Set (key ,val );};case *PdfObjectBool :if _acbc !=nil {_cbcca .Set (key ,val );};case *PdfObjectFloat :if _acbc !=nil {_cbcca .Set (key ,val );};case *PdfObjectReference :if _acbc !=nil {_cbcca .Set (key ,val );
};case *PdfIndirectObject :if _acbc !=nil {_cbcca .Set (key ,val );};default:_cc .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//
//	renamed to String() as a pretty string to use in debugging etc.
func (_adeg *MultiEncoder )GetFilterName ()string {_adfg :="";for _bgbb ,_eaec :=range _adeg ._ceba {_adfg +=_eaec .GetFilterName ();if _bgbb < len (_adeg ._ceba )-1{_adfg +="\u0020";};};return _adfg ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_gfef *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_fggba :=PdfIndirectObject {};_fggba ._aacab =_gfef ;_cc .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_abded ,_geadg :=_gfef ._dced .Peek (20);
if _geadg !=nil {if _geadg !=_ae .EOF {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_fggba ,_geadg ;
};};_cc .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_abded ));_cdbe :=_eeef .FindStringSubmatchIndex (string (_abded ));if len (_cdbe )< 6{if _geadg ==_ae .EOF {return nil ,_geadg ;
};_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_abded ));
return &_fggba ,_ca .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_gfef ._dced .Discard (_cdbe [0]);_cc .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_cdbe );_caaf :=_cdbe [1]-_cdbe [0];_cgab :=make ([]byte ,_caaf );_ ,_geadg =_gfef .ReadAtLeast (_cgab ,_caaf );if _geadg !=nil {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_geadg );
return nil ,_geadg ;};_cc .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_cgab );_gfcd :=_eeef .FindStringSubmatch (string (_cgab ));if len (_gfcd )< 3{_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_cgab ));
return &_fggba ,_ca .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_fcfdf ,_ :=_g .Atoi (_gfcd [1]);_agce ,_ :=_g .Atoi (_gfcd [2]);_fggba .ObjectNumber =int64 (_fcfdf );_fggba .GenerationNumber =int64 (_agce );for {_ffcd ,_aebcc :=_gfef ._dced .Peek (2);if _aebcc !=nil {return &_fggba ,_aebcc ;};_cc .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_ffcd ),string (_ffcd ));
if IsWhiteSpace (_ffcd [0]){_gfef .skipSpaces ();}else if _ffcd [0]=='%'{_gfef .skipComments ();}else if (_ffcd [0]=='<')&&(_ffcd [1]=='<'){_cc .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_fggba .PdfObject ,_aebcc =_gfef .ParseDict ();
_cc .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_aebcc );if _aebcc !=nil {return &_fggba ,_aebcc ;};_cc .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_ffcd [0]=='/')||(_ffcd [0]=='(')||(_ffcd [0]=='[')||(_ffcd [0]=='<'){_fggba .PdfObject ,_aebcc =_gfef .parseObject ();if _aebcc !=nil {return &_fggba ,_aebcc ;};_cc .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _ffcd [0]==']'{_cc .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_gfef ._dced .Discard (1);}else {if _ffcd [0]=='e'{_dcafa ,_bbga :=_gfef .readTextLine ();if _bbga !=nil {return nil ,_bbga ;};if len (_dcafa )>=6&&_dcafa [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _ffcd [0]=='s'{_ffcd ,_ =_gfef ._dced .Peek (10);
if string (_ffcd [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_cgcdd :=6;if len (_ffcd )> 6{if IsWhiteSpace (_ffcd [_cgcdd ])&&_ffcd [_cgcdd ]!='\r'&&_ffcd [_cgcdd ]!='\n'{_cc .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_gfef ._ggcdd ._fcb =true ;_cgcdd ++;};if _ffcd [_cgcdd ]=='\r'{_cgcdd ++;if _ffcd [_cgcdd ]=='\n'{_cgcdd ++;};}else if _ffcd [_cgcdd ]=='\n'{_cgcdd ++;}else {_gfef ._ggcdd ._fcb =true ;};};_gfef ._dced .Discard (_cgcdd );_agff ,_egca :=_fggba .PdfObject .(*PdfObjectDictionary );
if !_egca {return nil ,_ca .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_cc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_agff );
_egbd ,_gdcg :=_gfef .traceStreamLength (_agff .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _gdcg !=nil {_cc .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_gdcg );
return nil ,_gdcg ;};_cc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_egbd );_fgcac ,_dddcg :=_egbd .(*PdfObjectInteger );if !_dddcg {return nil ,_ca .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_fcga :=*_fgcac ;if _fcga < 0{return nil ,_ca .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_adgcf :=_gfef .GetFileOffset ();
_gddd :=_gfef .xrefNextObjectOffset (_adgcf );if _adgcf +int64 (_fcga )> _gddd &&_gddd > _adgcf {_cc .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_adgcf +int64 (_fcga ));_cc .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_gddd );
_aeecf :=_gddd -_adgcf -17;if _aeecf < 0{return nil ,_ca .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_cc .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_aeecf );_fcga =PdfObjectInteger (_aeecf );
_agff .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_aeecf ));};if int64 (_fcga )> _gfef ._ddgd {_cc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_ca .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_dgfa :=make ([]byte ,_fcga );
_ ,_gdcg =_gfef .ReadAtLeast (_dgfa ,int (_fcga ));if _gdcg !=nil {_cc .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_dgfa ),_dgfa );_cc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gdcg );
return nil ,_gdcg ;};_facbb :=PdfObjectStream {};_facbb .Stream =_dgfa ;_facbb .PdfObjectDictionary =_fggba .PdfObject .(*PdfObjectDictionary );_facbb .ObjectNumber =_fggba .ObjectNumber ;_facbb .GenerationNumber =_fggba .GenerationNumber ;_facbb .PdfObjectReference ._aacab =_gfef ;
_gfef .skipSpaces ();_gfef ._dced .Discard (9);_gfef .skipSpaces ();return &_facbb ,nil ;};};_fggba .PdfObject ,_aebcc =_gfef .parseObject ();if _fggba .PdfObject ==nil {_cc .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_fggba .PdfObject =MakeNull ();};return &_fggba ,_aebcc ;};};if _fggba .PdfObject ==nil {_cc .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_fggba .PdfObject =MakeNull ();};_cc .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_fggba ,nil ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_cgcg []byte ,_gdgb bool ){_bfga ,_gdgb :=TraceToDirectObject (obj ).(*PdfObjectString );if _gdgb {return _bfga .Bytes (),true ;};return ;};const _gdaf =6;var _ffae =_ca .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");


// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_gcgad []PdfObject };

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_gfbe *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_cgd ,_bd :=obj .(*PdfObjectReference );if !_bd {return obj ,nil ;};_baf :=_gfbe .GetFileOffset ();defer func (){_gfbe .SetFileOffset (_baf )}();_ebd ,_cfd :=_gfbe .LookupByReference (*_cgd );
if _cfd !=nil {return nil ,_cfd ;};_fgf ,_gab :=_ebd .(*PdfIndirectObject );if !_gab {return _ebd ,nil ;};_ebd =_fgf .PdfObject ;_ ,_bd =_ebd .(*PdfObjectReference );if _bd {return _fgf ,_ca .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _ebd ,nil ;};

// GetXrefOffset returns the offset of the xref table.
func (_dceb *PdfParser )GetXrefOffset ()int64 {return _dceb ._defc };func _ddec (_bedad *PdfObjectStream ,_bcaa *PdfObjectDictionary )(*FlateEncoder ,error ){_efce :=NewFlateEncoder ();_gecf :=_bedad .PdfObjectDictionary ;if _gecf ==nil {return _efce ,nil ;
};_efce ._cfdg =_cacc (_gecf );if _bcaa ==nil {_gedf :=TraceToDirectObject (_gecf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _eaff :=_gedf .(type ){case *PdfObjectArray :if _eaff .Len ()!=1{_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_eaff .Len ());
return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _fce ,_gdg :=GetDict (_eaff .Get (0));_gdg {_bcaa =_fce ;};case *PdfObjectDictionary :_bcaa =_eaff ;case *PdfObjectNull ,nil :default:_cc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_gedf );
return nil ,_ggc .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _bcaa ==nil {return _efce ,nil ;};_cc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bcaa .String ());
_bae :=_bcaa .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _bae ==nil {_cc .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_bead ,_cba :=_bae .(*PdfObjectInteger );if !_cba {_cc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_bae );
return nil ,_ggc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_efce .Predictor =int (*_bead );};_bae =_bcaa .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _bae !=nil {_dcaf ,_abae :=_bae .(*PdfObjectInteger );if !_abae {_cc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_ggc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_efce .BitsPerComponent =int (*_dcaf );};if _efce .Predictor > 1{_efce .Columns =1;_bae =_bcaa .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _bae !=nil {_cabd ,_dcdg :=_bae .(*PdfObjectInteger );if !_dcdg {return nil ,_ggc .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_efce .Columns =int (*_cabd );
};_efce .Colors =1;_bae =_bcaa .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _bae !=nil {_ffa ,_eagd :=_bae .(*PdfObjectInteger );if !_eagd {return nil ,_ggc .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_efce .Colors =int (*_ffa );};};return _efce ,nil ;};

// Read implementation of Read interface.
func (_eada *limitedReadSeeker )Read (p []byte )(_badd int ,_acf error ){_gddc ,_acf :=_eada ._aaca .Seek (0,_ae .SeekCurrent );if _acf !=nil {return 0,_acf ;};_dgcc :=_eada ._ffbdf -_gddc ;if _dgcc ==0{return 0,_ae .EOF ;};if _ecea :=int64 (len (p ));
_ecea < _dgcc {_dgcc =_ecea ;};_gddb :=make ([]byte ,_dgcc );_badd ,_acf =_eada ._aaca .Read (_gddb );copy (p ,_gddb );return _badd ,_acf ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_abda *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_abda ._bbdc .Seek (offset ,_ae .SeekStart );_abda ._dced =_ce .NewReader (_abda ._bbdc );};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_fba *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_eeec ,_ ,_ef :=_fba .lookupByNumberWrapper (objNumber ,true );return _eeec ,_ef ;};func (_cae *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_faaad :=_cae ._dced .Discard (4);
return PdfObjectNull {},_faaad ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_becfc :=&ASCIIHexEncoder {};return _becfc };

// Remove removes an element specified by key.
func (_gefa *PdfObjectDictionary )Remove (key PdfObjectName ){_eec :=-1;for _gcdf ,_eefa :=range _gefa ._gccc {if _eefa ==key {_eec =_gcdf ;break ;};};if _eec >=0{_gefa ._gccc =append (_gefa ._gccc [:_eec ],_gefa ._gccc [_eec +1:]...);delete (_gefa ._cdebe ,key );
};};var _acbb =_e .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// String returns a string describing `ref`.
func (_cace *PdfObjectReference )String ()string {return _ggc .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_cace .ObjectNumber ,_cace .GenerationNumber );};func (_abagg *PdfParser )parseName ()(PdfObjectName ,error ){var _dbba _gff .Buffer ;
_egfaa :=false ;for {_cddd ,_gdgc :=_abagg ._dced .Peek (1);if _gdgc ==_ae .EOF {break ;};if _gdgc !=nil {return PdfObjectName (_dbba .String ()),_gdgc ;};if !_egfaa {if _cddd [0]=='/'{_egfaa =true ;_abagg ._dced .ReadByte ();}else if _cddd [0]=='%'{_abagg .readComment ();
_abagg .skipSpaces ();}else {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_cddd ,_cddd );return PdfObjectName (_dbba .String ()),_ggc .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_cddd [0]);
};}else {if IsWhiteSpace (_cddd [0]){break ;}else if (_cddd [0]=='/')||(_cddd [0]=='[')||(_cddd [0]=='(')||(_cddd [0]==']')||(_cddd [0]=='<')||(_cddd [0]=='>'){break ;}else if _cddd [0]=='#'{_afgg ,_fggee :=_abagg ._dced .Peek (3);if _fggee !=nil {return PdfObjectName (_dbba .String ()),_fggee ;
};_cafbc ,_fggee :=_ag .DecodeString (string (_afgg [1:3]));if _fggee !=nil {_cc .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_dbba .WriteByte ('#');_abagg ._dced .Discard (1);continue ;};_abagg ._dced .Discard (3);_dbba .Write (_cafbc );}else {_edfe ,_ :=_abagg ._dced .ReadByte ();_dbba .WriteByte (_edfe );};};};return PdfObjectName (_dbba .String ()),nil ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_fegb *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fegb .GetFilterName ());
return data ,ErrNoJPXDecode ;};

// UpdateParams updates the parameter values of the encoder.
func (_cdea *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_ba .FilterDict ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_ebeb :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_ebeb .PdfObjectDictionary =encoder .MakeStreamDict ();_agfb ,_deebe :=encoder .EncodeBytes (contents );
if _deebe !=nil {return nil ,_deebe ;};_ebeb .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_agfb ))));_ebeb .Stream =_agfb ;return _ebeb ,nil ;};func _aadgg ()string {return _cc .Version };

// String returns a string representation of `name`.
func (_cbbg *PdfObjectName )String ()string {return string (*_cbbg )};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_bfdd *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _ddddb ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _bfdd .ColorComponents !=1||_bfdd .BitsPerComponent !=1{return nil ,_b .Errorf (_ddddb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_acdg *_fbf .Bitmap ;_egfg error ;);_efgd :=(_bfdd .Width *_bfdd .Height )==len (data );if _efgd {_acdg ,_egfg =_fbf .NewWithUnpaddedData (_bfdd .Width ,_bfdd .Height ,data );}else {_acdg ,_egfg =_fbf .NewWithData (_bfdd .Width ,_bfdd .Height ,data );
};if _egfg !=nil {return nil ,_egfg ;};_cdbc :=_bfdd .DefaultPageSettings ;if _egfg =_cdbc .Validate ();_egfg !=nil {return nil ,_b .Wrap (_egfg ,_ddddb ,"");};if _bfdd ._degb ==nil {_bfdd ._degb =_gbg .InitEncodeDocument (_cdbc .FileMode );};switch _cdbc .Compression {case JB2Generic :if _egfg =_bfdd ._degb .AddGenericPage (_acdg ,_cdbc .DuplicatedLinesRemoval );
_egfg !=nil {return nil ,_b .Wrap (_egfg ,_ddddb ,"");};case JB2SymbolCorrelation :return nil ,_b .Error (_ddddb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_b .Error (_ddddb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_b .Error (_ddddb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _bfdd .Encode ();};

// PdfVersion returns version of the PDF file.
func (_gbfgb *PdfParser )PdfVersion ()Version {return _gbfgb ._beeag };

// Clear resets the dictionary to an empty state.
func (_cfaac *PdfObjectDictionary )Clear (){_cfaac ._gccc =[]PdfObjectName {};_cfaac ._cdebe =map[PdfObjectName ]PdfObject {};_cfaac ._cbbc =&_a .Mutex {};};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_fefdg *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_eace :=_fefdg .GetFileOffset ();_ ,_cecca :=_fefdg ._bbdc .Seek (offset ,_ae .SeekStart );if _cecca !=nil {return nil ,_cecca ;};_cgef :=make ([]byte ,len );_ ,_cecca =_ae .ReadAtLeast (_fefdg ._bbdc ,_cgef ,int (len ));
if _cecca !=nil {return nil ,_cecca ;};_fefdg .SetFileOffset (_eace );return _cgef ,nil ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_bgea *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_cc .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_abdde :=MakeDict ();_abdde ._dbcgf =_bgea ;_eeed ,_ :=_bgea ._dced .ReadByte ();
if _eeed !='<'{return nil ,_ca .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_eeed ,_ =_bgea ._dced .ReadByte ();if _eeed !='<'{return nil ,_ca .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");
};for {_bgea .skipSpaces ();_bgea .skipComments ();_eeff ,_bgcg :=_bgea ._dced .Peek (2);if _bgcg !=nil {return nil ,_bgcg ;};_cc .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_eeff ),string (_eeff ));
if (_eeff [0]=='>')&&(_eeff [1]=='>'){_cc .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_bgea ._dced .ReadByte ();_bgea ._dced .ReadByte ();break ;};_cc .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");
_ggcdc ,_bgcg :=_bgea .parseName ();_cc .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_ggcdc );if _bgcg !=nil {_cc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_bgcg );
return nil ,_bgcg ;};if len (_ggcdc )> 4&&_ggcdc [len (_ggcdc )-4:]=="\u006e\u0075\u006c\u006c"{_aege :=_ggcdc [0:len (_ggcdc )-4];_cc .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_ggcdc );
_cc .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_aege );_bgea .skipSpaces ();_efdb ,_ :=_bgea ._dced .Peek (1);if _efdb [0]=='/'{_abdde .Set (_aege ,MakeNull ());continue ;};};
_bgea .skipSpaces ();_fccb ,_bgcg :=_bgea .parseObject ();if _bgcg !=nil {return nil ,_bgcg ;};_abdde .Set (_ggcdc ,_fccb );if _cc .Log .IsLogLevel (_cc .LogLevelTrace ){_cc .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_ggcdc ,_fccb .String ());
};};_cc .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _abdde ,nil ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _ffadg (obj ,0)};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// UpdateParams updates the parameter values of the encoder.
func (_cgba *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_cdddf *PdfParser )parseHexString ()(*PdfObjectString ,error ){_cdddf ._dced .ReadByte ();var _ebgf _gff .Buffer ;for {_efcb ,_ebad :=_cdddf ._dced .Peek (1);if _ebad !=nil {return MakeString (""),_ebad ;
};if _efcb [0]=='>'{_cdddf ._dced .ReadByte ();break ;};_faed ,_ :=_cdddf ._dced .ReadByte ();if _cdddf ._cgaa {if _gff .IndexByte (_bffgf ,_faed )==-1{_cdddf ._ggcdd ._fcde =true ;};};if !IsWhiteSpace (_faed ){_ebgf .WriteByte (_faed );};};if _ebgf .Len ()%2==1{_cdddf ._ggcdd ._edc =true ;
_ebgf .WriteRune ('0');};_bgfd ,_ :=_ag .DecodeString (_ebgf .String ());return MakeHexString (string (_bgfd )),nil ;};var _cbb =_e .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// DecodeStream implements ASCII hex decoding.
func (_fffa *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fffa .DecodeBytes (streamObj .Stream );};

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_eaed ParserMetadata )HasOddLengthHexStrings ()bool {return _eaed ._edc };

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_deadd *PdfObjectStreams ,_acac bool ){_deadd ,_acac =obj .(*PdfObjectStreams );return _deadd ,_acac ;};func (_ggag *PdfCrypt )isEncrypted (_cded PdfObject )bool {_ ,_aca :=_ggag ._cfa [_cded ];if _aca {_cc .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};_cc .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_cgfg *PdfParser )GetUpdatedObjects (prevParser *PdfParser )(map[int64 ]PdfObject ,error ){if prevParser ==nil {return nil ,_ca .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_ggbb ,_eccd :=_cgfg .getNumbersOfUpdatedObjects (prevParser );if _eccd !=nil {return nil ,_eccd ;};_bfgc :=make (map[int64 ]PdfObject );for _ ,_bgagb :=range _ggbb {if _dcbb ,_aebf :=_cgfg .LookupByNumber (_bgagb );_aebf ==nil {_bfgc [int64 (_bgagb )]=_dcbb ;
}else {return nil ,_aebf ;};};return _bfgc ,nil ;};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_bfba *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _bbfc _dd .Image ;if _bfba .ColorComponents ==1&&_bfba .BitsPerComponent ==8{_bbfc =&_dd .Gray {Rect :_dd .Rect (0,0,_bfba .Width ,_bfba .Height ),Pix :data ,Stride :_fe .BytesPerLine (_bfba .Width ,_bfba .BitsPerComponent ,_bfba .ColorComponents )};
}else {var _afd error ;_bbfc ,_afd =_fe .NewImage (_bfba .Width ,_bfba .Height ,_bfba .BitsPerComponent ,_bfba .ColorComponents ,data ,nil ,nil );if _afd !=nil {return nil ,_afd ;};};_cga :=_gf .Options {};_cga .Quality =_bfba .Quality ;var _afad _gff .Buffer ;
if _dgdc :=_gf .Encode (&_afad ,_bbfc ,&_cga );_dgdc !=nil {return nil ,_dgdc ;};return _afad .Bytes (),nil ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_bafc []float64 ,_gfbea error ){for _ ,_caca :=range objects {_dgfb ,_bffe :=GetNumberAsFloat (_caca );if _bffe !=nil {return nil ,_bffe ;};_bafc =append (_bafc ,_dgfb );};return _bafc ,nil ;};func (_ddfb *PdfParser )traceStreamLength (_dbaf PdfObject )(PdfObject ,error ){_agef ,_baege :=_dbaf .(*PdfObjectReference );
if _baege {_gbfb ,_afbab :=_ddfb ._debg [_agef .ObjectNumber ];if _afbab &&_gbfb {_cc .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_ca .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_ddfb ._debg [_agef .ObjectNumber ]=true ;};_fddc ,_bggg :=_ddfb .Resolve (_dbaf );if _bggg !=nil {return nil ,_bggg ;
};_cc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_fddc );if _baege {_ddfb ._debg [_agef .ObjectNumber ]=false ;};return _fddc ,nil ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_faca *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _faca .DecodeBytes (streamObj .Stream );};const _gee ="\u0053\u0074\u0064C\u0046";

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_dbbe *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _cce ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _bfbce :=_dbbe .AddPageImage (img ,&_dbbe .DefaultPageSettings );
_bfbce !=nil {return nil ,_b .Wrap (_bfbce ,_cce ,"");};return _dbbe .Encode ();};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_abcf string ;_caeb bool ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_aaae *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// WriteString outputs the object as it is to be written to file.
func (_bdba *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_daaf *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _bfcf _fe .Gray ;switch len (data ){case _daaf .Rows *_daaf .Columns :_bdce ,_cbec :=_fe .NewImage (_daaf .Columns ,_daaf .Rows ,8,1,data ,nil ,nil );if _cbec !=nil {return nil ,_cbec ;
};_bfcf =_bdce .(_fe .Gray );case (_daaf .Columns *_daaf .Rows )+7>>3:_aad ,_gcggg :=_fe .NewImage (_daaf .Columns ,_daaf .Rows ,1,1,data ,nil ,nil );if _gcggg !=nil {return nil ,_gcggg ;};_bfdcf :=_aad .(*_fe .Monochrome );if _gcggg =_bfdcf .AddPadding ();
_gcggg !=nil {return nil ,_gcggg ;};_bfcf =_bfdcf ;default:if len (data )< _fe .BytesPerLine (_daaf .Columns ,1,1)*_daaf .Rows {return nil ,_ca .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_bbe ,_gacb :=_fe .NewImage (_daaf .Columns ,_daaf .Rows ,1,1,data ,nil ,nil );if _gacb !=nil {return nil ,_gacb ;};_bef :=_bbe .(*_fe .Monochrome );_bfcf =_bef ;};_bcfa :=make ([][]byte ,_daaf .Rows );for _bdaga :=0;_bdaga < _daaf .Rows ;_bdaga ++{_dacb :=make ([]byte ,_daaf .Columns );
for _egcg :=0;_egcg < _daaf .Columns ;_egcg ++{_cdgg :=_bfcf .GrayAt (_egcg ,_bdaga );_dacb [_egcg ]=_cdgg .Y >>7;};_bcfa [_bdaga ]=_dacb ;};_egbg :=&_cag .Encoder {K :_daaf .K ,Columns :_daaf .Columns ,EndOfLine :_daaf .EndOfLine ,EndOfBlock :_daaf .EndOfBlock ,BlackIs1 :_daaf .BlackIs1 ,DamagedRowsBeforeError :_daaf .DamagedRowsBeforeError ,Rows :_daaf .Rows ,EncodedByteAlign :_daaf .EncodedByteAlign };
return _egbg .Encode (_bcfa ),nil ;};

// String returns a string describing `null`.
func (_cffc *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_ebab *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ebab .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_cagb *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aec ,_def :=_cag .NewDecoder (encoded ,_cag .DecodeOptions {Columns :_cagb .Columns ,Rows :_cagb .Rows ,K :_cagb .K ,EncodedByteAligned :_cagb .EncodedByteAlign ,BlackIsOne :_cagb .BlackIs1 ,EndOfBlock :_cagb .EndOfBlock ,EndOfLine :_cagb .EndOfLine ,DamagedRowsBeforeError :_cagb .DamagedRowsBeforeError });
if _def !=nil {return nil ,_def ;};_bcce ,_def :=_cgb .ReadAll (_aec );if _def !=nil {return nil ,_def ;};return _bcce ,nil ;};

// String returns a string describing `ind`.
func (_gaaeg *PdfIndirectObject )String ()string {return _ggc .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_gaaeg ).ObjectNumber );};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_ggfcf :=MakeArray ();for _ ,_eabb :=range vals {_ggfcf .Append (MakeFloat (_eabb ));};return _ggfcf ;};const (DefaultJPEGQuality =75;);func (_fda *PdfParser )skipSpaces ()(int ,error ){_fdfbe :=0;
for {_fgca ,_edbb :=_fda ._dced .ReadByte ();if _edbb !=nil {return 0,_edbb ;};if IsWhiteSpace (_fgca ){_fdfbe ++;}else {_fda ._dced .UnreadByte ();break ;};};return _fdfbe ,nil ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_aecf *PdfParser )GetObjectNums ()[]int {var _ebda []int ;for _ ,_acagg :=range _aecf ._daea .ObjectMap {_ebda =append (_ebda ,_acagg .ObjectNumber );};_cg .Ints (_ebda );return _ebda ;};func (_bfag *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _bebc *PdfObjectDictionary ;
_cfgg ,_fcg :=_bfag .readTextLine ();if _fcg !=nil {return nil ,_fcg ;};if _bfag ._cgaa &&_gb .Count (_gb .TrimPrefix (_cfgg ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_bfag ._ggcdd ._ggg =true ;};_cc .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_cfgg );
_eefe :=-1;_dcca :=0;_ggagc :=false ;_bgcc :="";for {_bfag .skipSpaces ();_ ,_dfgb :=_bfag ._dced .Peek (1);if _dfgb !=nil {return nil ,_dfgb ;};_cfgg ,_dfgb =_bfag .readTextLine ();if _dfgb !=nil {return nil ,_dfgb ;};_abac :=_adffg .FindStringSubmatch (_cfgg );
if len (_abac )==0{_aeaa :=len (_bgcc )> 0;_bgcc +=_cfgg +"\u000a";if _aeaa {_abac =_adffg .FindStringSubmatch (_bgcc );};};if len (_abac )==3{if _bfag ._cgaa &&!_bfag ._ggcdd ._cafe {var (_aaeg bool ;_baad int ;);for _ ,_dbcdb :=range _cfgg {if _d .IsDigit (_dbcdb ){if _aaeg {break ;
};continue ;};if !_aaeg {_aaeg =true ;};_baad ++;};if _baad > 1{_bfag ._ggcdd ._cafe =true ;};};_gfda ,_ :=_g .Atoi (_abac [1]);_agfge ,_ :=_g .Atoi (_abac [2]);_eefe =_gfda ;_dcca =_agfge ;_ggagc =true ;_bgcc ="";_cc .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_eefe ,_dcca );
continue ;};_fbedg :=_egdb .FindStringSubmatch (_cfgg );if len (_fbedg )==4{if !_ggagc {_cc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_ca .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_cabg ,_ :=_g .ParseInt (_fbedg [1],10,64);_fgbgb ,_ :=_g .Atoi (_fbedg [2]);_cagab :=_fbedg [3];_bgcc ="";if _gb .ToLower (_cagab )=="\u006e"&&_cabg > 1{_egff ,_gdge :=_bfag ._daea .ObjectMap [_eefe ];if !_gdge ||_fgbgb > _egff .Generation {_abddf :=XrefObject {ObjectNumber :_eefe ,XType :XrefTypeTableEntry ,Offset :_cabg ,Generation :_fgbgb };
_bfag ._daea .ObjectMap [_eefe ]=_abddf ;};};_eefe ++;continue ;};if (len (_cfgg )> 6)&&(_cfgg [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_cc .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_cfgg );
if len (_cfgg )> 9{_dbeda :=_bfag .GetFileOffset ();_bfag .SetFileOffset (_dbeda -int64 (len (_cfgg ))+7);};_bfag .skipSpaces ();_bfag .skipComments ();_cc .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_cc .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_cfgg );_bebc ,_dfgb =_bfag .ParseDict ();_cc .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _dfgb !=nil {_cc .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_dfgb );return nil ,_dfgb ;};break ;};if _cfgg =="\u0025\u0025\u0045O\u0046"{_cc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_ca .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_cc .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_cfgg );
};_cc .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _bfag ._fefbf ==nil {_feceg :=XrefTypeTableEntry ;_bfag ._fefbf =&_feceg ;};return _bebc ,nil ;};func _bbgaa (_eeab int )int {if _eeab < 0{return -_eeab ;
};return _eeab ;};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_fgfgd .Store (filterName ,customStreamEncoder );};

// HasNonConformantStream implements core.ParserMetadata.
func (_ffgb ParserMetadata )HasNonConformantStream ()bool {return _ffgb ._fcb };

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};var _gdaec =_e .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_beeg *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eafc *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_cbecb :=MakeDict ();_cbecb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_eafc .GetFilterName ()));return _cbecb ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_bfddg *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_beeaa ,_dded :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _dded ==nil {_bfddg .BitsPerComponent =int (_beeaa );
};_gead ,_dded :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _dded ==nil {_bfddg .Width =int (_gead );};_dfdff ,_dded :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _dded ==nil {_bfddg .Height =int (_dfdff );
};_cfdcd ,_dded :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _dded ==nil {_bfddg .ColorComponents =int (_cfdcd );};};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_dbeg *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _fdbg _gff .Buffer ;for _abdf :=0;_abdf < len (data );_abdf +=4{_gebg :=data [_abdf ];_agf :=1;_cdec :=byte (0);if _abdf +1< len (data ){_cdec =data [_abdf +1];_agf ++;};_ada :=byte (0);
if _abdf +2< len (data ){_ada =data [_abdf +2];_agf ++;};_afdc :=byte (0);if _abdf +3< len (data ){_afdc =data [_abdf +3];_agf ++;};_abee :=(uint32 (_gebg )<<24)|(uint32 (_cdec )<<16)|(uint32 (_ada )<<8)|uint32 (_afdc );if _abee ==0{_fdbg .WriteByte ('z');
}else {_dbed :=_dbeg .base256Tobase85 (_abee );for _ ,_gbda :=range _dbed [:_agf +1]{_fdbg .WriteByte (_gbda +'!');};};};_fdbg .WriteString ("\u007e\u003e");return _fdbg .Bytes (),nil ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_cge []XrefObject ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bbcf *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_bbcf ._ceba )==0{return nil ;};if len (_bbcf ._ceba )==1{return _bbcf ._ceba [0].MakeDecodeParams ();};_dbd :=MakeArray ();_dcef :=true ;for _ ,_abbc :=range _bbcf ._ceba {_fdeb :=_abbc .MakeDecodeParams ();
if _fdeb ==nil {_dbd .Append (MakeNull ());}else {_dcef =false ;_dbd .Append (_fdeb );};};if _dcef {return nil ;};return _dbd ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_ggfec *PdfObjectDictionary ,_cefa bool ){_ggfec ,_cefa =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _ggfec ,_cefa ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _cdeab ,_fbba :=obj .(*PdfObjectReference );_fbba {obj =_cdeab .Resolve ();};_eagad ,_bdcag :=obj .(*PdfIndirectObject );_dfcf :=0;for _bdcag {obj =_eagad .PdfObject ;_eagad ,_bdcag =GetIndirect (obj );
_dfcf ++;if _dfcf > _faabe {_cc .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_faabe );
return nil ;};};return obj ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_bfbc :=&LZWEncoder {};_bfbc .Predictor =1;_bfbc .BitsPerComponent =8;_bfbc .Colors =1;_bfbc .Columns =1;_bfbc .EarlyChange =1;return _bfbc ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_dcdcf string ,_bcbg bool ){_bgccb ,_bcbg :=TraceToDirectObject (obj ).(*PdfObjectString );if _bcbg {return _bgccb .Str (),true ;};return ;};

// UpdateParams updates the parameter values of the encoder.
func (_aead *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_gfgcdc ,_fabb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fabb ==nil {_aead .ColorComponents =int (_gfgcdc );
};_ffef ,_fabb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fabb ==nil {_aead .BitsPerComponent =int (_ffef );};_ddg ,_fabb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _fabb ==nil {_aead .Width =int (_ddg );};_bcfe ,_fabb :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _fabb ==nil {_aead .Height =int (_bcfe );};_gcdb ,_fabb :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _fabb ==nil {_aead .Quality =int (_gcdb );};_aceb ,_aaag :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));if _aaag {_aead .Decode ,_fabb =_aceb .ToFloat64Array ();if _fabb !=nil {_cc .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020de\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006eto\u0020\u0061r\u0072\u0061\u0079\u0073\u003a\u0020\u0025\u0076",_fabb );
};};};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};func _cacc (_ddac *PdfObjectDictionary )(_gffd *_fe .ImageBase ){var (_geefg *PdfObjectInteger ;_fadf bool ;);if _geefg ,_fadf =_ddac .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_fadf {_gffd =&_fe .ImageBase {Width :int (*_geefg )};
}else {return nil ;};if _geefg ,_fadf =_ddac .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_fadf {_gffd .Height =int (*_geefg );};if _geefg ,_fadf =_ddac .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_fadf {_gffd .BitsPerComponent =int (*_geefg );};if _geefg ,_fadf =_ddac .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_fadf {_gffd .ColorComponents =int (*_geefg );};return _gffd ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_bbab :=PdfObjectString {_abcf :s ,_caeb :true };return &_bbab ;};

// String returns the state of the bool as "true" or "false".
func (_gebb *PdfObjectBool )String ()string {if *_gebb {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_gaaa *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ebff _gff .Buffer ;for _ ,_fege :=range data {_ebff .WriteString (_ggc .Sprintf ("\u0025\u002e\u0032X\u0020",_fege ));};_ebff .WriteByte ('>');return _ebff .Bytes (),nil ;};func (_edefb *PdfParser )resolveReference (_gdba *PdfObjectReference )(PdfObject ,bool ,error ){_aceaa ,_gcaa :=_edefb .ObjCache [int (_gdba .ObjectNumber )];
if _gcaa {return _aceaa ,true ,nil ;};_efa ,_eadb :=_edefb .LookupByReference (*_gdba );if _eadb !=nil {return nil ,false ,_eadb ;};_edefb .ObjCache [int (_gdba .ObjectNumber )]=_efa ;return _efa ,false ,nil ;};func (_dggf *PdfParser )rebuildXrefTable ()error {_dace :=XrefTable {};
_dace .ObjectMap =map[int ]XrefObject {};_agbc :=make ([]int ,0,len (_dggf ._daea .ObjectMap ));for _gcbb :=range _dggf ._daea .ObjectMap {_agbc =append (_agbc ,_gcbb );};_cg .Ints (_agbc );for _ ,_cegef :=range _agbc {_caeef :=_dggf ._daea .ObjectMap [_cegef ];
_bddd ,_ ,_accdb :=_dggf .lookupByNumberWrapper (_cegef ,false );if _accdb !=nil {_cc .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_accdb );
_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_gcfda ,_gafcd :=_dggf .repairRebuildXrefsTopDown ();if _gafcd !=nil {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_gafcd );
return _gafcd ;};_dggf ._daea =*_gcfda ;_cc .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_aebfda ,_dbgee ,_accdb :=_cfg (_bddd );if _accdb !=nil {return _accdb ;
};_caeef .ObjectNumber =int (_aebfda );_caeef .Generation =int (_dbgee );_dace .ObjectMap [int (_aebfda )]=_caeef ;};_dggf ._daea =_dace ;_cc .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");
_gbf (_dggf ._daea );return nil ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};func _ffadg (_babd PdfObject ,_gdddc int )PdfObject {if _gdddc > _faabe {_cc .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_faabe );
return MakeNull ();};switch _ebfb :=_babd .(type ){case *PdfIndirectObject :_babd =_ffadg ((*_ebfb ).PdfObject ,_gdddc +1);case *PdfObjectArray :for _fbgce ,_effdb :=range (*_ebfb )._gcgad {(*_ebfb )._gcgad [_fbgce ]=_ffadg (_effdb ,_gdddc +1);};case *PdfObjectDictionary :for _cgccb ,_ecfc :=range (*_ebfb )._cdebe {(*_ebfb )._cdebe [_cgccb ]=_ffadg (_ecfc ,_gdddc +1);
};_cg .Slice ((*_ebfb )._gccc ,func (_ggfg ,_edbce int )bool {return (*_ebfb )._gccc [_ggfg ]< (*_ebfb )._gccc [_edbce ]});};return _babd ;};

// String returns a string describing `stream`.
func (_caag *PdfObjectStream )String ()string {return _ggc .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_caag .ObjectNumber ,_caag .PdfObjectDictionary );};func (_ccbf *FlateEncoder )postDecodePredict (_geegc []byte )([]byte ,error ){if _ccbf .Predictor > 1{if _ccbf .Predictor ==2{_cc .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_cc .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_ccbf .Colors );_fdf :=_ccbf .Columns *_ccbf .Colors ;if _fdf < 1{return []byte {},nil ;};_dcee :=len (_geegc )/_fdf ;if len (_geegc )%_fdf !=0{_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_ggc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_geegc ),_fdf );};if _fdf %_ccbf .Colors !=0{return nil ,_ggc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_fdf ,_ccbf .Colors );
};if _fdf > len (_geegc ){_cc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fdf ,len (_geegc ));
return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cc .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_geegc ),_geegc );
_egfa :=_gff .NewBuffer (nil );for _bff :=0;_bff < _dcee ;_bff ++{_dbcg :=_geegc [_fdf *_bff :_fdf *(_bff +1)];for _gbad :=_ccbf .Colors ;_gbad < _fdf ;_gbad ++{_dbcg [_gbad ]+=_dbcg [_gbad -_ccbf .Colors ];};_egfa .Write (_dbcg );};_aaa :=_egfa .Bytes ();
_cc .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_aaa ),_aaa );return _aaa ,nil ;}else if _ccbf .Predictor >=10&&_ccbf .Predictor <=15{_cc .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_efbg :=_ccbf .Columns *_ccbf .Colors +1;_aagb :=len (_geegc )/_efbg ;if len (_geegc )%_efbg !=0{return nil ,_ggc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_geegc ),_efbg );
};if _efbg > len (_geegc ){_cc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_efbg ,len (_geegc ));
return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dcdge :=_gff .NewBuffer (nil );_cc .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_ccbf .Columns );
_cc .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_geegc ),_efbg ,_aagb );_gcgf :=make ([]byte ,_efbg );for _gdda :=0;_gdda < _efbg ;_gdda ++{_gcgf [_gdda ]=0;
};_cbca :=_ccbf .Colors ;for _ccad :=0;_ccad < _aagb ;_ccad ++{_abe :=_geegc [_efbg *_ccad :_efbg *(_ccad +1)];_dad :=_abe [0];switch _dad {case _ccc :case _abf :for _gbd :=1+_cbca ;_gbd < _efbg ;_gbd ++{_abe [_gbd ]+=_abe [_gbd -_cbca ];};case _dfbe :for _bac :=1;
_bac < _efbg ;_bac ++{_abe [_bac ]+=_gcgf [_bac ];};case _bgfe :for _feab :=1;_feab < _cbca +1;_feab ++{_abe [_feab ]+=_gcgf [_feab ]/2;};for _cffb :=_cbca +1;_cffb < _efbg ;_cffb ++{_abe [_cffb ]+=byte ((int (_abe [_cffb -_cbca ])+int (_gcgf [_cffb ]))/2);
};case _ffeg :for _aace :=1;_aace < _efbg ;_aace ++{var _adde ,_babf ,_caab byte ;_babf =_gcgf [_aace ];if _aace >=_cbca +1{_adde =_abe [_aace -_cbca ];_caab =_gcgf [_aace -_cbca ];};_abe [_aace ]+=_afec (_adde ,_babf ,_caab );};default:_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_dad ,_ccad );
return nil ,_ggc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dad );};copy (_gcgf ,_abe );_dcdge .Write (_abe [1:]);};_cggb :=_dcdge .Bytes ();return _cggb ,nil ;
}else {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_ccbf .Predictor );return nil ,_ggc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_ccbf .Predictor );
};};return _geegc ,nil ;};var _bffgf =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_dfbb *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_caae :=_gff .NewReader (encoded );var _dcbg []byte ;for {_eafe ,_dgfd :=_caae .ReadByte ();if _dgfd !=nil {return nil ,_dgfd ;};if _eafe > 128{_gfgf ,_dcbgg :=_caae .ReadByte ();
if _dcbgg !=nil {return nil ,_dcbgg ;};for _afb :=0;_afb < 257-int (_eafe );_afb ++{_dcbg =append (_dcbg ,_gfgf );};}else if _eafe < 128{for _dcdd :=0;_dcdd < int (_eafe )+1;_dcdd ++{_badf ,_egg :=_caae .ReadByte ();if _egg !=nil {return nil ,_egg ;};_dcbg =append (_dcbg ,_badf );
};}else {break ;};};return _dcbg ,nil ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_egfe *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cc .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_fefg :=_gff .NewReader (encoded );_ega ,_ffe :=_gg .NewReader (_fefg );if _ffe !=nil {_cc .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_ffe );_cc .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_ffe ;};defer _ega .Close ();var _acba _gff .Buffer ;_acba .ReadFrom (_ega );return _acba .Bytes (),nil ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_adag *JBIG2Encoder )EncodeImage (img _dd .Image )([]byte ,error ){return _adag .encodeImage (img )};func (_gbaff *PdfParser )repairLocateXref ()(int64 ,error ){_egfd :=int64 (1000);_gbaff ._bbdc .Seek (-_egfd ,_ae .SeekCurrent );_egfc ,_edga :=_gbaff ._bbdc .Seek (0,_ae .SeekCurrent );
if _edga !=nil {return 0,_edga ;};_ddcac :=make ([]byte ,_egfd );_gbaff ._bbdc .Read (_ddcac );_gbfd :=_afff .FindAllStringIndex (string (_ddcac ),-1);if len (_gbfd )< 1{_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");
return 0,_ca .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_cdddfc :=int64 (_gbfd [len (_gbfd )-1][0]);_ecdd :=_egfc +_cdddfc ;return _ecdd ,nil ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;Decode []float64 ;};

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_ddb ParserMetadata )HasDataAfterEOF ()bool {return _ddb ._cdde };func _cdad (_cdcc ,_ccca ,_cfcg int )error {if _ccca < 0||_ccca > _cdcc {return _ca .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _cfcg < _ccca {return _ca .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _cfcg > _cdcc {return _ca .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_deb *LZWEncoder )MakeDecodeParams ()PdfObject {if _deb .Predictor > 1{_edf :=MakeDict ();_edf .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_deb .Predictor )));if _deb .BitsPerComponent !=8{_edf .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_deb .BitsPerComponent )));
};if _deb .Columns !=1{_edf .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_deb .Columns )));};if _deb .Colors !=1{_edf .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_deb .Colors )));};return _edf ;};return nil ;};


// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_bdca *PdfParser )GetRevision (revisionNumber int )(*PdfParser ,error ){_ebcc :=_bdca ._dcbdf ;if _ebcc ==revisionNumber {return _bdca ,nil ;};if _ebcc < revisionNumber {return nil ,_ca .New ("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e");
};if _bdca ._bbad [revisionNumber ]!=nil {return _bdca ._bbad [revisionNumber ],nil ;};_gfea :=_bdca ;for ;_ebcc > revisionNumber ;_ebcc --{_bedgg ,_cfdd :=_gfea .GetPreviousRevisionParser ();if _cfdd !=nil {return nil ,_cfdd ;};_bdca ._bbad [_ebcc -1]=_bedgg ;
_bdca ._dbag [_gfea ]=_bedgg ;_gfea =_bedgg ;};return _gfea ,nil ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_ggfe *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ggfe .DecodeBytes (streamObj .Stream );};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};func _fdea (_ccff *PdfObjectStream ,_cebb *MultiEncoder )(*DCTEncoder ,error ){_debe :=NewDCTEncoder ();_dcbf :=_ccff .PdfObjectDictionary ;if _dcbf ==nil {return _debe ,nil ;};_dbb :=_ccff .Stream ;if _cebb !=nil {_gdef ,_gagf :=_cebb .DecodeBytes (_dbb );
if _gagf !=nil {return nil ,_gagf ;};_dbb =_gdef ;};_gagc :=_gff .NewReader (_dbb );_gcda ,_dbe :=_gf .DecodeConfig (_gagc );if _dbe !=nil {_cc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_dbe );
return nil ,_dbe ;};switch _gcda .ColorModel {case _gc .RGBAModel :_debe .BitsPerComponent =8;_debe .ColorComponents =3;_debe .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _gc .RGBA64Model :_debe .BitsPerComponent =16;_debe .ColorComponents =3;_debe .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};
case _gc .GrayModel :_debe .BitsPerComponent =8;_debe .ColorComponents =1;_debe .Decode =[]float64 {0.0,1.0};case _gc .Gray16Model :_debe .BitsPerComponent =16;_debe .ColorComponents =1;_debe .Decode =[]float64 {0.0,1.0};case _gc .CMYKModel :_debe .BitsPerComponent =8;
_debe .ColorComponents =4;_debe .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0};case _gc .YCbCrModel :_debe .BitsPerComponent =8;_debe .ColorComponents =3;_debe .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};default:return nil ,_ca .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_debe .Width =_gcda .Width ;_debe .Height =_gcda .Height ;_cc .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_debe );_debe .Quality =DefaultJPEGQuality ;_cgbc ,_eaea :=GetArray (_dcbf .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
if _eaea {_caga ,_aga :=_cgbc .ToFloat64Array ();if _aga !=nil {return _debe ,_aga ;};_debe .Decode =_caga ;};return _debe ,nil ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_afgd :=&ASCII85Encoder {};return _afgd };func (_gegc *PdfCrypt )checkAccessRights (_ggb []byte )(bool ,_dec .Permissions ,error ){_egf :=_gegc .securityHandler ();_gdfg ,_bgg ,_ffg :=_egf .Authenticate (&_gegc ._bccd ,_ggb );
if _ffg !=nil {return false ,0,_ffg ;}else if _bgg ==0||len (_gdfg )==0{return false ,0,nil ;};return true ,_bgg ,nil ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
//
//	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _dd .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _gefd ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_b .Error (_gefd ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_baae uint8 ;_dafa _fe .Image ;_cdcd error ;);if bwThreshold ==JB2ImageAutoThreshold {_dafa ,_cdcd =_fe .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_b .Error (_gefd ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_baae =uint8 (255*bwThreshold );_dafa ,_cdcd =_fe .MonochromeThresholdConverter (_baae ).Convert (i );};if _cdcd !=nil {return nil ,_cdcd ;};return _baeg (_dafa ),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_abag *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };const JB2ImageAutoThreshold =-1.0;

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_adbg *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_fefc :=_adbg .Get (key );if _fefc ==nil {return "",false ;};_dccca ,_abfda :=_fefc .(*PdfObjectString );if !_abfda {return "",false ;};return _dccca .Str (),true ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_eacb *PdfObjectString )Bytes ()[]byte {return []byte (_eacb ._abcf )};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// WriteString outputs the object as it is to be written to file.
func (_gbaf *PdfObjectDictionary )WriteString ()string {var _dbaeg _gb .Builder ;_dbaeg .WriteString ("\u003c\u003c");for _ ,_ebebb :=range _gbaf ._gccc {_afcd :=_gbaf ._cdebe [_ebebb ];_dbaeg .WriteString (_ebebb .WriteString ());_dbaeg .WriteString ("\u0020");
_dbaeg .WriteString (_afcd .WriteString ());};_dbaeg .WriteString ("\u003e\u003e");return _dbaeg .String ();};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_dbfg :=PdfObjectFloat (val );return &_dbfg };

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_eggf *PdfObjectString )Str ()string {return _eggf ._abcf };

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_bgggd *PdfObjectReference )Resolve ()PdfObject {if _bgggd ._aacab ==nil {return MakeNull ();};_agcf ,_ ,_bcda :=_bgggd ._aacab .resolveReference (_bgggd );if _bcda !=nil {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_bcda );
return MakeNull ();};if _agcf ==nil {_cc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _agcf ;};func (_fecg *JBIG2Image )toBitmap ()(_cced *_fbf .Bitmap ,_bfbd error ){const _bcbd ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _fecg .Data ==nil {return nil ,_b .Error (_bcbd ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _fecg .Width ==0||_fecg .Height ==0{return nil ,_b .Error (_bcbd ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _fecg .HasPadding {_cced ,_bfbd =_fbf .NewWithData (_fecg .Width ,_fecg .Height ,_fecg .Data );}else {_cced ,_bfbd =_fbf .NewWithUnpaddedData (_fecg .Width ,_fecg .Height ,_fecg .Data );};if _bfbd !=nil {return nil ,_b .Wrap (_bfbd ,_bcbd ,"");};return _cced ,nil ;
};

// Clear resets the array to an empty state.
func (_dab *PdfObjectArray )Clear (){_dab ._gcgad =[]PdfObject {}};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_dgfac *PdfObjectArray ,_ebaeac bool ){_dgfac ,_ebaeac =TraceToDirectObject (obj ).(*PdfObjectArray );return _dgfac ,_ebaeac ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dcg *FlateEncoder )MakeDecodeParams ()PdfObject {if _dcg .Predictor > 1{_cgcd :=MakeDict ();_cgcd .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_dcg .Predictor )));if _dcg .BitsPerComponent !=8{_cgcd .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_dcg .BitsPerComponent )));
};if _dcg .Columns !=1{_cgcd .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_dcg .Columns )));};if _dcg .Colors !=1{_cgcd .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_dcg .Colors )));};return _cgcd ;};return nil ;
};

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_eeg ParserMetadata )HasInvalidSubsectionHeader ()bool {return _eeg ._cafe };func (_abfd *limitedReadSeeker )getError (_acec int64 )error {switch {case _acec < 0:return _ggc .Errorf ("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064",_acec );
case _acec > _abfd ._ffbdf :return _ggc .Errorf ("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064",_acec );};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_feeb *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };func _gbf (_ebc XrefTable ){_cc .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_cc .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");
_ab :=0;for _ ,_eab :=range _ebc .ObjectMap {_cc .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_ab +1,_eab .ObjectNumber ,_eab .Generation ,_eab .Offset );
_ab ++;};};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_cccd *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cc .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_cc .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cccd .Predictor );
if _cccd .BitsPerComponent !=8{return nil ,_ggc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_cccd .BitsPerComponent );
};_egee ,_bagd :=_cccd .DecodeBytes (streamObj .Stream );if _bagd !=nil {return nil ,_bagd ;};_egee ,_bagd =_cccd .postDecodePredict (_egee );if _bagd !=nil {return nil ,_bagd ;};return _egee ,nil ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_becfef *PdfIndirectObject ,_bfcd bool ){obj =ResolveReference (obj );_becfef ,_bfcd =obj .(*PdfIndirectObject );return _becfef ,_bfcd ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_gfaab *FlateEncoder )SetPredictor (columns int ){_gfaab .Predictor =11;_gfaab .Columns =columns ;};

// WriteString outputs the object as it is to be written to file.
func (_aebfd *PdfObjectBool )WriteString ()string {if *_aebfd {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;Lazy bool ;TempFile string ;};func (_baaa *PdfCrypt )saveCryptFilters (_aab *PdfObjectDictionary )error {if _baaa ._dg .V < 4{return _ca .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_eed :=MakeDict ();_aab .Set ("\u0043\u0046",_eed );for _aaba ,_fag :=range _baaa ._eebc {if _aaba =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_gag :=_caa (_fag ,"");_eed .Set (PdfObjectName (_aaba ),_gag );};_aab .Set ("\u0053\u0074\u0072\u0046",MakeName (_baaa ._bad ));
_aab .Set ("\u0053\u0074\u006d\u0046",MakeName (_baaa ._gcd ));return nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_dgfdg :=PdfObjectString {_abcf :s };return &_dgfdg };

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_debc *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cc .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_effdd ,_edaf :=NewEncoderFromStream (streamObj );if _edaf !=nil {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_edaf );
return nil ,_edaf ;};_cc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_effdd );_fbdd ,_edaf :=_effdd .DecodeStream (streamObj );if _edaf !=nil {_cc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_edaf );
return nil ,_edaf ;};return _fbdd ,nil ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_fdgg *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_fgcg :=n ;_deeb :=0;_agfg :=0;for _fgcg > 0{_fecgc ,_gbaa :=_fdgg ._dced .Read (p [_deeb :]);if _gbaa !=nil {_cc .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_fecgc ,_agfg ,_gbaa .Error ());
return _deeb ,_ca .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_agfg ++;_deeb +=_fecgc ;_fgcg -=_fecgc ;};return _deeb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_cbece *PdfObjectName )WriteString ()string {var _bfdbb _gff .Buffer ;if len (*_cbece )> 127{_cc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_cbece );};_bfdbb .WriteString ("\u002f");
for _cfcf :=0;_cfcf < len (*_cbece );_cfcf ++{_ecfed :=(*_cbece )[_cfcf ];if !IsPrintable (_ecfed )||_ecfed =='#'||IsDelimiter (_ecfed ){_bfdbb .WriteString (_ggc .Sprintf ("\u0023\u0025\u002e2\u0078",_ecfed ));}else {_bfdbb .WriteByte (_ecfed );};};return _bfdbb .String ();
};type limitedReadSeeker struct{_aaca _ae .ReadSeeker ;_ffbdf int64 ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _bfegb :=obj .(type ){case *PdfObjectFloat :return float64 (*_bfegb ),nil ;case *PdfObjectInteger :return float64 (*_bfegb ),nil ;case *PdfObjectReference :_ccdf :=TraceToDirectObject (obj );
return GetNumberAsFloat (_ccdf );case *PdfIndirectObject :return GetNumberAsFloat (_bfegb .PdfObject );};return 0,ErrNotANumber ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_eacff string ,_afae bool ){_gbfc ,_afae :=TraceToDirectObject (obj ).(*PdfObjectName );if _afae {return string (*_gbfc ),true ;};return ;};func (_bca *PdfCrypt )decryptBytes (_fff []byte ,_ecc string ,_cbg []byte )([]byte ,error ){_cc .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_dfe ,_becg :=_bca ._eebc [_ecc ];if !_becg {return nil ,_ggc .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ecc );};return _dfe .DecryptBytes (_fff ,_cbg );};

// WriteString outputs the object as it is to be written to file.
func (_dbef *PdfObjectStreams )WriteString ()string {var _cedd _gb .Builder ;_cedd .WriteString (_g .FormatInt (_dbef .ObjectNumber ,10));_cedd .WriteString ("\u0020\u0030\u0020\u0052");return _cedd .String ();};

// String returns a string describing `d`.
func (_agbb *PdfObjectDictionary )String ()string {var _gffcf _gb .Builder ;_gffcf .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_ccge :=range _agbb ._gccc {_efec :=_agbb ._cdebe [_ccge ];_gffcf .WriteString ("\u0022"+_ccge .String ()+"\u0022\u003a\u0020");
_gffcf .WriteString (_efec .String ());_gffcf .WriteString ("\u002c\u0020");};_gffcf .WriteString ("\u0029");return _gffcf .String ();};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_cfdc *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _cfdc .isDecrypted (obj ){return nil ;};switch _fac :=obj .(type ){case *PdfIndirectObject :_cfdc ._dce [_fac ]=true ;_cc .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fac .ObjectNumber ,_fac .GenerationNumber );
_aagc :=_fac .ObjectNumber ;_beda :=_fac .GenerationNumber ;_abd :=_cfdc .Decrypt (_fac .PdfObject ,_aagc ,_beda );if _abd !=nil {return _abd ;};return nil ;case *PdfObjectStream :_cfdc ._dce [_fac ]=true ;_dcbe :=_fac .PdfObjectDictionary ;if _cfdc ._bccd .R !=5{if _fcf ,_edbc :=_dcbe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_edbc &&*_fcf =="\u0058\u0052\u0065\u0066"{return nil ;};};_fgfg :=_fac .ObjectNumber ;_feb :=_fac .GenerationNumber ;_cc .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_fgfg ,_feb );
_gfaa :=_gee ;if _cfdc ._dg .V >=4{_gfaa =_cfdc ._gcd ;_cc .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_cfdc ._gcd );if _dda ,_cdc :=_dcbe .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_cdc {if _geeg ,_cdeb :=GetName (_dda .Get (0));_cdeb {if *_geeg =="\u0043\u0072\u0079p\u0074"{_gfaa ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gegg ,_bfeag :=_dcbe .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_bfeag {if _dafe ,_bfd :=_gegg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bfd {if _ ,_abg :=_cfdc ._eebc [string (*_dafe )];_abg {_cc .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_dafe );
_gfaa =string (*_dafe );};};};};};};_cc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gfaa );if _gfaa =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_egd :=_cfdc .Decrypt (_dcbe ,_fgfg ,_feb );
if _egd !=nil {return _egd ;};_bfc ,_egd :=_cfdc .makeKey (_gfaa ,uint32 (_fgfg ),uint32 (_feb ),_cfdc ._fgfa );if _egd !=nil {return _egd ;};_fac .Stream ,_egd =_cfdc .decryptBytes (_fac .Stream ,_gfaa ,_bfc );if _egd !=nil {return _egd ;};_dcbe .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fac .Stream ))));
return nil ;case *PdfObjectString :_cc .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_fgeb :=_gee ;if _cfdc ._dg .V >=4{_cc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_cfdc ._bad );
if _cfdc ._bad =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_fgeb =_cfdc ._bad ;};_gfgc ,_ggeb :=_cfdc .makeKey (_fgeb ,uint32 (parentObjNum ),uint32 (parentGenNum ),_cfdc ._fgfa );if _ggeb !=nil {return _ggeb ;};_ceg :=_fac .Str ();
_fbg :=make ([]byte ,len (_ceg ));for _abc :=0;_abc < len (_ceg );_abc ++{_fbg [_abc ]=_ceg [_abc ];};if len (_fbg )> 0{_cc .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_fbg ,_fbg );
_fbg ,_ggeb =_cfdc .decryptBytes (_fbg ,_fgeb ,_gfgc );if _ggeb !=nil {return _ggeb ;};};_fac ._abcf =string (_fbg );return nil ;case *PdfObjectArray :for _ ,_cbfa :=range _fac .Elements (){_gffb :=_cfdc .Decrypt (_cbfa ,parentObjNum ,parentGenNum );if _gffb !=nil {return _gffb ;
};};return nil ;case *PdfObjectDictionary :_degg :=false ;if _bdg :=_fac .Get ("\u0054\u0079\u0070\u0065");_bdg !=nil {_faa ,_ead :=_bdg .(*PdfObjectName );if _ead &&*_faa =="\u0053\u0069\u0067"{_degg =true ;};};for _ ,_efg :=range _fac .Keys (){_add :=_fac .Get (_efg );
if _degg &&string (_efg )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_efg )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_efg )!="\u0050\u0072\u0065\u0076"&&string (_efg )!="\u004c\u0061\u0073\u0074"{_cgbg :=_cfdc .Decrypt (_add ,parentObjNum ,parentGenNum );
if _cgbg !=nil {return _cgbg ;};};};return nil ;};return nil ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _bfedc :=obj .(type ){case *PdfObjectFloat :_cc .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_bfedc ),nil ;case *PdfObjectInteger :return int64 (*_bfedc ),nil ;case *PdfObjectReference :_bcac :=TraceToDirectObject (obj );return GetNumberAsInt64 (_bcac );case *PdfIndirectObject :return GetNumberAsInt64 (_bfedc .PdfObject );};return 0,ErrNotANumber ;
};

// Elements returns a slice of the PdfObject elements in the array.
func (_fbgcf *PdfObjectArray )Elements ()[]PdfObject {if _fbgcf ==nil {return nil ;};return _fbgcf ._gcgad ;};

// GetFilterName returns the name of the encoding filter.
func (_fdbd *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };