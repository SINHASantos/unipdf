//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ed "bytes";_de "crypto/aes";_b "crypto/cipher";_f "crypto/md5";_bd "crypto/rand";_bc "crypto/rc4";_a "crypto/sha256";_dc "crypto/sha512";_g "encoding/binary";_ae "errors";_gc "fmt";_ga "github.com/unidoc/unipdf/v3/common";_dd "hash";
_d "io";_be "math";);func (_ace stdHandlerR4 )alg3 (R int ,_ece ,_eabc []byte )([]byte ,error ){var _abg []byte ;if len (_eabc )> 0{_abg =_ace .alg3Key (R ,_eabc );}else {_abg =_ace .alg3Key (R ,_ece );};_ad ,_dca :=_bc .NewCipher (_abg );if _dca !=nil {return nil ,_ae .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ba :=_ace .paddedPass (_ece );_af :=make ([]byte ,len (_ba ));_ad .XORKeyStream (_af ,_ba );if R >=3{_dg :=make ([]byte ,len (_abg ));for _cac :=0;_cac < 19;_cac ++{for _afe :=0;_afe < len (_abg );_afe ++{_dg [_afe ]=_abg [_afe ]^byte (_cac +1);};_bgb ,_eef :=_bc .NewCipher (_dg );
if _eef !=nil {return nil ,_ae .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bgb .XORKeyStream (_af ,_af );};};return _af ,nil ;};func (_ada stdHandlerR4 )alg4 (_dcf []byte ,_aba []byte )([]byte ,error ){_fd ,_aae :=_bc .NewCipher (_dcf );
if _aae !=nil {return nil ,_ae .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ffa :=[]byte (_acg );_bga :=make ([]byte ,len (_ffa ));_fd .XORKeyStream (_bga ,_ffa );return _bga ,nil ;};func _ge (_c _b .Block )*ecb {return &ecb {_ac :_c ,_ab :_c .BlockSize ()}};


// Allowed checks if a set of permissions can be granted.
func (_edb Permissions )Allowed (p2 Permissions )bool {return _edb &p2 ==p2 };func (_aac stdHandlerR6 )alg12 (_cedb *StdEncryptDict ,_cgde []byte )([]byte ,error ){if _ggf :=_db ("\u0061\u006c\u00671\u0032","\u0055",48,_cedb .U );_ggf !=nil {return nil ,_ggf ;
};if _eda :=_db ("\u0061\u006c\u00671\u0032","\u004f",48,_cedb .O );_eda !=nil {return nil ,_eda ;};_ded :=make ([]byte ,len (_cgde )+8+48);_eggff :=copy (_ded ,_cgde );_eggff +=copy (_ded [_eggff :],_cedb .O [32:40]);_eggff +=copy (_ded [_eggff :],_cedb .U [0:48]);
_fba ,_bdeb :=_aac .alg2b (_cedb .R ,_ded ,_cgde ,_cedb .U [0:48]);if _bdeb !=nil {return nil ,_bdeb ;};_fba =_fba [:32];if !_ed .Equal (_fba ,_cedb .O [:32]){return nil ,nil ;};return _fba ,nil ;};var _ StdHandler =stdHandlerR6 {};func (_dbac stdHandlerR6 )alg9 (_cgg *StdEncryptDict ,_gbg []byte ,_gee []byte )error {if _deb :=_db ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_gbg );
_deb !=nil {return _deb ;};if _eabd :=_db ("\u0061\u006c\u0067\u0039","\u0055",48,_cgg .U );_eabd !=nil {return _eabd ;};var _dde [16]byte ;if _ ,_bad :=_d .ReadFull (_bd .Reader ,_dde [:]);_bad !=nil {return _bad ;};_bgd :=_dde [0:8];_aecb :=_dde [8:16];
_febc :=_cgg .U [:48];_gbf :=make ([]byte ,len (_gee )+len (_bgd )+len (_febc ));_cda :=copy (_gbf ,_gee );_cda +=copy (_gbf [_cda :],_bgd );_cda +=copy (_gbf [_cda :],_febc );_dfg ,_agcc :=_dbac .alg2b (_cgg .R ,_gbf ,_gee ,_febc );if _agcc !=nil {return _agcc ;
};O :=make ([]byte ,len (_dfg )+len (_bgd )+len (_aecb ));_cda =copy (O ,_dfg [:32]);_cda +=copy (O [_cda :],_bgd );_cda +=copy (O [_cda :],_aecb );_cgg .O =O ;_cda =len (_gee );_cda +=copy (_gbf [_cda :],_aecb );_dfg ,_agcc =_dbac .alg2b (_cgg .R ,_gbf ,_gee ,_febc );
if _agcc !=nil {return _agcc ;};_gae ,_agcc :=_gda (_dfg [:32]);if _agcc !=nil {return _agcc ;};_cddg :=make ([]byte ,_de .BlockSize );_badc :=_b .NewCBCEncrypter (_gae ,_cddg );OE :=make ([]byte ,32);_badc .CryptBlocks (OE ,_gbg [:32]);_cgg .OE =OE ;return nil ;
};

// Authenticate implements StdHandler interface.
func (_affe stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _affe .alg2a (d ,pass );};func (_gb *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gb ._ab !=0{_ga .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ga .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_gb ._ac .Encrypt (dst ,src [:_gb ._ab ]);src =src [_gb ._ab :];dst =dst [_gb ._ab :];};};func (_gab stdHandlerR6 )alg8 (_eggf *StdEncryptDict ,_cfab []byte ,_fcg []byte )error {if _adge :=_db ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_cfab );
_adge !=nil {return _adge ;};var _gad [16]byte ;if _ ,_dbf :=_d .ReadFull (_bd .Reader ,_gad [:]);_dbf !=nil {return _dbf ;};_aga :=_gad [0:8];_cdeg :=_gad [8:16];_gdb :=make ([]byte ,len (_fcg )+len (_aga ));_bgc :=copy (_gdb ,_fcg );copy (_gdb [_bgc :],_aga );
_eefc ,_fbca :=_gab .alg2b (_eggf .R ,_gdb ,_fcg ,nil );if _fbca !=nil {return _fbca ;};U :=make ([]byte ,len (_eefc )+len (_aga )+len (_cdeg ));_bgc =copy (U ,_eefc [:32]);_bgc +=copy (U [_bgc :],_aga );copy (U [_bgc :],_cdeg );_eggf .U =U ;_bgc =len (_fcg );
copy (_gdb [_bgc :],_cdeg );_eefc ,_fbca =_gab .alg2b (_eggf .R ,_gdb ,_fcg ,nil );if _fbca !=nil {return _fbca ;};_febe ,_fbca :=_gda (_eefc [:32]);if _fbca !=nil {return _fbca ;};_cbf :=make ([]byte ,_de .BlockSize );_cfca :=_b .NewCBCEncrypter (_febe ,_cbf );
UE :=make ([]byte ,32);_cfca .CryptBlocks (UE ,_cfab [:32]);_eggf .UE =UE ;return nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_adb stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_gfb :=_adb .alg3 (d .R ,upass ,opass );if _gfb !=nil {_ga .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_gfb );
return nil ,_gfb ;};d .O =O ;_ga .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_gba :=_adb .alg2 (d ,upass );U ,_gfb :=_adb .alg5 (_gba ,upass );if _gfb !=nil {_ga .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_gfb );
return nil ,_gfb ;};d .U =U ;_ga .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _gba ,nil ;};func _ebb (_aff []byte ,_ecf int ){_gagf :=_ecf ;for _gagf < len (_aff ){copy (_aff [_gagf :],_aff [:_gagf ]);_gagf *=2;
};};func (_fgf stdHandlerR6 )alg10 (_cc *StdEncryptDict ,_bef []byte )error {if _cge :=_db ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_bef );_cge !=nil {return _cge ;};_bdc :=uint64 (uint32 (_cc .P ))|(_be .MaxUint32 <<32);Perms :=make ([]byte ,16);
_g .LittleEndian .PutUint64 (Perms [:8],_bdc );if _cc .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_acge :=_d .ReadFull (_bd .Reader ,Perms [12:16]);_acge !=nil {return _acge ;};_gbc ,_ged :=_gda (_bef [:32]);
if _ged !=nil {return _ged ;};_ced :=_gaa (_gbc );_ced .CryptBlocks (Perms ,Perms );_cc .Perms =Perms [:16];return nil ;};func (_aa *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_aa ._ab !=0{_ga .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ga .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_aa ._ac .Decrypt (dst ,src [:_aa ._ab ]);src =src [_aa ._ab :];dst =dst [_aa ._ab :];};};func (stdHandlerR4 )paddedPass (_ca []byte )[]byte {_eg :=make ([]byte ,32);_ddc :=copy (_eg ,_ca );for ;_ddc < 32;_ddc ++{_eg [_ddc ]=_acg [_ddc -len (_ca )];
};return _eg ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_gfg stdHandlerR6 )alg2a (_geg *StdEncryptDict ,_eea []byte )([]byte ,Permissions ,error ){if _eaa :=_db ("\u0061\u006c\u00672\u0061","\u004f",48,_geg .O );
_eaa !=nil {return nil ,0,_eaa ;};if _bce :=_db ("\u0061\u006c\u00672\u0061","\u0055",48,_geg .U );_bce !=nil {return nil ,0,_bce ;};if len (_eea )> 127{_eea =_eea [:127];};_cdd ,_bee :=_gfg .alg12 (_geg ,_eea );if _bee !=nil {return nil ,0,_bee ;};var (_bcf []byte ;
_bebf []byte ;_ce []byte ;);var _eb Permissions ;if len (_cdd )!=0{_eb =PermOwner ;_abb :=make ([]byte ,len (_eea )+8+48);_aea :=copy (_abb ,_eea );_aea +=copy (_abb [_aea :],_geg .O [40:48]);copy (_abb [_aea :],_geg .U [0:48]);_bcf =_abb ;_bebf =_geg .OE ;
_ce =_geg .U [0:48];}else {_cdd ,_bee =_gfg .alg11 (_geg ,_eea );if _bee ==nil &&len (_cdd )==0{_cdd ,_bee =_gfg .alg11 (_geg ,[]byte (""));};if _bee !=nil {return nil ,0,_bee ;}else if len (_cdd )==0{return nil ,0,nil ;};_eb =_geg .P ;_fdf :=make ([]byte ,len (_eea )+8);
_cab :=copy (_fdf ,_eea );copy (_fdf [_cab :],_geg .U [40:48]);_bcf =_fdf ;_bebf =_geg .UE ;_ce =nil ;};if _ebc :=_db ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_bebf );_ebc !=nil {return nil ,0,_ebc ;};_bebf =_bebf [:32];_egf ,_bee :=_gfg .alg2b (_geg .R ,_bcf ,_eea ,_ce );
if _bee !=nil {return nil ,0,_bee ;};_feb ,_bee :=_de .NewCipher (_egf [:32]);if _bee !=nil {return nil ,0,_bee ;};_acfb :=make ([]byte ,_de .BlockSize );_cgd :=_b .NewCBCDecrypter (_feb ,_acfb );_gff :=make ([]byte ,32);_cgd .CryptBlocks (_gff ,_bebf );
if _geg .R ==5{return _gff ,_eb ,nil ;};_bee =_gfg .alg13 (_geg ,_gff );if _bee !=nil {return nil ,0,_bee ;};return _gff ,_eb ,nil ;};var _ StdHandler =stdHandlerR4 {};func _gg (_gbd _b .Block )_b .BlockMode {return (*ecbDecrypter )(_ge (_gbd ))};func (_dfb stdHandlerR6 )alg13 (_gce *StdEncryptDict ,_aedf []byte )error {if _bgg :=_db ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_aedf );
_bgg !=nil {return _bgg ;};if _dff :=_db ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_gce .Perms );_dff !=nil {return _dff ;};_gcbf :=make ([]byte ,16);copy (_gcbf ,_gce .Perms [:16]);_acb ,_gec :=_de .NewCipher (_aedf [:32]);if _gec !=nil {return _gec ;
};_cgfec :=_gg (_acb );_cgfec .CryptBlocks (_gcbf ,_gcbf );if !_ed .Equal (_gcbf [9:12],[]byte ("\u0061\u0064\u0062")){return _ae .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_cgea :=Permissions (_g .LittleEndian .Uint32 (_gcbf [0:4]));if _cgea !=_gce .P {return _ae .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _dbg bool ;if _gcbf [8]=='T'{_dbg =true ;}else if _gcbf [8]=='F'{_dbg =false ;}else {return _ae .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _dbg !=_gce .EncryptMetadata {return _ae .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;type ecbEncrypter ecb ;func _gaa (_fe _b .Block )_b .BlockMode {return (*ecbEncrypter )(_ge (_fe ))};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ec *StdEncryptDict ,_ag ,_bcb []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_cf *StdEncryptDict ,_ggd []byte )([]byte ,Permissions ,error );};func (_agdd stdHandlerR6 )alg2b (R int ,_gegf ,_dcae ,_gde []byte )([]byte ,error ){if R ==5{return _abbc (_gegf );};return _dag (_gegf ,_dcae ,_gde );};func (_dbd stdHandlerR4 )alg5 (_agcf []byte ,_bf []byte )([]byte ,error ){_cg :=_f .New ();
_cg .Write ([]byte (_acg ));_cg .Write ([]byte (_dbd .ID0 ));_dcc :=_cg .Sum (nil );_ga .Log .Trace ("\u0061\u006c\u0067\u0035");_ga .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_agcf );_ga .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_dbd .ID0 );
if len (_dcc )!=16{return nil ,_ae .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_cfc ,_cfa :=_bc .NewCipher (_agcf );if _cfa !=nil {return nil ,_ae .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_gf :=make ([]byte ,16);_cfc .XORKeyStream (_gf ,_dcc );_cgf :=make ([]byte ,len (_agcf ));for _bcg :=0;_bcg < 19;_bcg ++{for _fb :=0;_fb < len (_agcf );_fb ++{_cgf [_fb ]=_agcf [_fb ]^byte (_bcg +1);};_cfc ,_cfa =_bc .NewCipher (_cgf );if _cfa !=nil {return nil ,_ae .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_cfc .XORKeyStream (_gf ,_gf );_ga .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_bcg ,_cgf );_ga .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_bcg ,_gf );
};_fce :=make ([]byte ,32);for _gbb :=0;_gbb < 16;_gbb ++{_fce [_gbb ]=_gf [_gbb ];};_ ,_cfa =_bd .Read (_fce [16:32]);if _cfa !=nil {return nil ,_ae .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _fce ,nil ;};type stdHandlerR6 struct{};func _db (_cff ,_ea string ,_dee int ,_dcb []byte )error {if len (_dcb )< _dee {return errInvalidField {Func :_cff ,Field :_ea ,Exp :_dee ,Got :len (_dcb )};};return nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_gd stdHandlerR4 )alg3Key (R int ,_eab []byte )[]byte {_bgf :=_f .New ();_aag :=_gd .paddedPass (_eab );_bgf .Write (_aag );if R >=3{for _df :=0;_df < 50;_df ++{_bb :=_bgf .Sum (nil );_bgf =_f .New ();_bgf .Write (_bb );};
};_cd :=_bgf .Sum (nil );if R ==2{_cd =_cd [0:5];}else {_cd =_cd [0:_gd .Length /8];};return _cd ;};func _dag (_cde ,_egee ,_bced []byte )([]byte ,error ){var (_eefb ,_aaga ,_cddd _dd .Hash ;);_eefb =_a .New ();_abgd :=make ([]byte ,64);_gbdg :=_eefb ;
_gbdg .Write (_cde );K :=_gbdg .Sum (_abgd [:0]);_fdb :=make ([]byte ,64*(127+64+48));_caa :=func (_ebd int )([]byte ,error ){_ddac :=len (_egee )+len (K )+len (_bced );_dbda :=_fdb [:_ddac ];_bde :=copy (_dbda ,_egee );_bde +=copy (_dbda [_bde :],K [:]);
_bde +=copy (_dbda [_bde :],_bced );if _bde !=_ddac {_ga .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_ae .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_fdb [:_ddac *64];_ebb (K1 ,_ddac );_feca ,_dbb :=_gda (K [0:16]);if _dbb !=nil {return nil ,_dbb ;};_feac :=_b .NewCBCEncrypter (_feca ,K [16:32]);_feac .CryptBlocks (K1 ,K1 );
E :=K1 ;_agg :=0;for _fa :=0;_fa < 16;_fa ++{_agg +=int (E [_fa ]%3);};var _acgc _dd .Hash ;switch _agg %3{case 0:_acgc =_eefb ;case 1:if _aaga ==nil {_aaga =_dc .New384 ();};_acgc =_aaga ;case 2:if _cddd ==nil {_cddd =_dc .New ();};_acgc =_cddd ;};_acgc .Reset ();
_acgc .Write (E );K =_acgc .Sum (_abgd [:0]);return E ,nil ;};for _ecbf :=0;;{E ,_dgc :=_caa (_ecbf );if _dgc !=nil {return nil ,_dgc ;};_bebfe :=E [len (E )-1];_ecbf ++;if _ecbf >=64&&_bebfe <=uint8 (_ecbf -32){break ;};};return K [:32],nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};const (PermOwner =Permissions (_be .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);
PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););type ecb struct{_ac _b .Block ;_ab int ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_ddacd stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_eag :=make ([]byte ,32);if _ ,_cad :=_d .ReadFull (_bd .Reader ,_eag );_cad !=nil {return nil ,_cad ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _cdb :=_ddacd .alg8 (d ,_eag ,upass );_cdb !=nil {return nil ,_cdb ;};if _edfd :=_ddacd .alg9 (d ,_eag ,opass );_edfd !=nil {return nil ,_edfd ;};if d .R ==5{return _eag ,nil ;
};if _gcea :=_ddacd .alg10 (d ,_eag );_gcea !=nil {return nil ,_gcea ;};return _eag ,nil ;};type ecbDecrypter ecb ;func (_ff stdHandlerR4 )alg2 (_agc *StdEncryptDict ,_fg []byte )[]byte {_ga .Log .Trace ("\u0061\u006c\u0067\u0032");_bg :=_ff .paddedPass (_fg );
_edf :=_f .New ();_edf .Write (_bg );_edf .Write (_agc .O );var _ee [4]byte ;_g .LittleEndian .PutUint32 (_ee [:],uint32 (_agc .P ));_edf .Write (_ee [:]);_ga .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_ee );_edf .Write ([]byte (_ff .ID0 ));
_ga .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_agc .R ,_agc .EncryptMetadata );if (_agc .R >=4)&&!_agc .EncryptMetadata {_edf .Write ([]byte {0xff,0xff,0xff,0xff});
};_acf :=_edf .Sum (nil );if _agc .R >=3{_edf =_f .New ();for _fc :=0;_fc < 50;_fc ++{_edf .Reset ();_edf .Write (_acf [0:_ff .Length /8]);_acf =_edf .Sum (nil );};};if _agc .R >=3{return _acf [0:_ff .Length /8];};return _acf [0:5];};func _abbc (_cfd []byte )([]byte ,error ){_bdf :=_a .New ();
_bdf .Write (_cfd );return _bdf .Sum (nil ),nil ;};func (_agd errInvalidField )Error ()string {return _gc .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_agd .Func ,_agd .Field ,_agd .Exp ,_agd .Got );
};const _acg ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func _gda (_egg []byte )(_b .Block ,error ){_ege ,_fda :=_de .NewCipher (_egg );if _fda !=nil {_ga .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_fda );
return nil ,_fda ;};return _ege ,nil ;};func (_fec stdHandlerR4 )alg6 (_dba *StdEncryptDict ,_gbba []byte )([]byte ,error ){var (_da []byte ;_aab error ;);_agb :=_fec .alg2 (_dba ,_gbba );if _dba .R ==2{_da ,_aab =_fec .alg4 (_agb ,_gbba );}else if _dba .R >=3{_da ,_aab =_fec .alg5 (_agb ,_gbba );
}else {return nil ,_ae .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _aab !=nil {return nil ,_aab ;};_ga .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_da ),string (_dba .U ));
_ecb :=_da ;_fecb :=_dba .U ;if _dba .R >=3{if len (_ecb )> 16{_ecb =_ecb [0:16];};if len (_fecb )> 16{_fecb =_fecb [0:16];};};if !_ed .Equal (_ecb ,_fecb ){return nil ,nil ;};return _agb ,nil ;};func (_beb *ecbEncrypter )BlockSize ()int {return _beb ._ab };
func (_gcb stdHandlerR4 )alg7 (_dga *StdEncryptDict ,_fbc []byte )([]byte ,error ){_aabe :=_gcb .alg3Key (_dga .R ,_fbc );_gag :=make ([]byte ,len (_dga .O ));if _dga .R ==2{_ecg ,_acec :=_bc .NewCipher (_aabe );if _acec !=nil {return nil ,_ae .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_ecg .XORKeyStream (_gag ,_dga .O );}else if _dga .R >=3{_gge :=append ([]byte {},_dga .O ...);for _ef :=0;_ef < 20;_ef ++{_ffb :=append ([]byte {},_aabe ...);for _abd :=0;_abd < len (_aabe );_abd ++{_ffb [_abd ]^=byte (19-_ef );};_cb ,_dda :=_bc .NewCipher (_ffb );
if _dda !=nil {return nil ,_ae .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_cb .XORKeyStream (_gag ,_gge );_gge =append ([]byte {},_gag ...);};}else {return nil ,_ae .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");
};_aec ,_edba :=_gcb .alg6 (_dga ,_gag );if _edba !=nil {return nil ,nil ;};return _aec ,nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_fee *ecbDecrypter )BlockSize ()int {return _fee ._ab };


// Authenticate implements StdHandler interface.
func (_gcc stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ga .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_adg ,_bgbg :=_gcc .alg7 (d ,pass );if _bgbg !=nil {return nil ,0,_bgbg ;};if _adg !=nil {_ga .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _adg ,PermOwner ,nil ;
};_ga .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_adg ,_bgbg =_gcc .alg6 (d ,pass );if _bgbg !=nil {return nil ,0,_bgbg ;
};if _adg !=nil {_ga .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _adg ,d .P ,nil ;};return nil ,0,nil ;};func (_aed stdHandlerR6 )alg11 (_abgc *StdEncryptDict ,_cgfe []byte )([]byte ,error ){if _eca :=_db ("\u0061\u006c\u00671\u0031","\u0055",48,_abgc .U );
_eca !=nil {return nil ,_eca ;};_bec :=make ([]byte ,len (_cgfe )+8);_fbg :=copy (_bec ,_cgfe );_fbg +=copy (_bec [_fbg :],_abgc .U [32:40]);_cgdb ,_egfd :=_aed .alg2b (_abgc .R ,_bec ,_cgfe ,nil );if _egfd !=nil {return nil ,_egfd ;};_cgdb =_cgdb [:32];
if !_ed .Equal (_cgdb ,_abgc .U [:32]){return nil ,nil ;};return _cgdb ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};