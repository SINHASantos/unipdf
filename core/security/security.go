//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_df "bytes";_dg "crypto/aes";_g "crypto/cipher";_cg "crypto/md5";_fc "crypto/rand";_ed "crypto/rc4";_e "crypto/sha256";_ff "crypto/sha512";_cf "encoding/binary";_b "errors";_fb "fmt";_ec "github.com/unidoc/unipdf/v4/common";_c "hash";
_f "io";_ee "math";);

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func _fa (_ea _g .Block )_g .BlockMode {return (*ecbDecrypter )(_a (_ea ))};func (_eceg stdHandlerR6 )alg9 (_cdg *StdEncryptDict ,_edfd []byte ,_aaeg []byte )error {if _bgag :=_cb ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_edfd );
_bgag !=nil {return _bgag ;};if _aeg :=_cb ("\u0061\u006c\u0067\u0039","\u0055",48,_cdg .U );_aeg !=nil {return _aeg ;};var _geg [16]byte ;if _ ,_ccc :=_f .ReadFull (_fc .Reader ,_geg [:]);_ccc !=nil {return _ccc ;};_dfgc :=_geg [0:8];_gea :=_geg [8:16];
_dda :=_cdg .U [:48];_bfb :=make ([]byte ,len (_aaeg )+len (_dfgc )+len (_dda ));_cga :=copy (_bfb ,_aaeg );_cga +=copy (_bfb [_cga :],_dfgc );_cga +=copy (_bfb [_cga :],_dda );_abeg ,_bdf :=_eceg .alg2b (_cdg .R ,_bfb ,_aaeg ,_dda );if _bdf !=nil {return _bdf ;
};O :=make ([]byte ,len (_abeg )+len (_dfgc )+len (_gea ));_cga =copy (O ,_abeg [:32]);_cga +=copy (O [_cga :],_dfgc );_cga +=copy (O [_cga :],_gea );_cdg .O =O ;_cga =len (_aaeg );_cga +=copy (_bfb [_cga :],_gea );_abeg ,_bdf =_eceg .alg2b (_cdg .R ,_bfb ,_aaeg ,_dda );
if _bdf !=nil {return _bdf ;};_adef ,_bdf :=_ede (_abeg [:32]);if _bdf !=nil {return _bdf ;};_gdb :=make ([]byte ,_dg .BlockSize );_bcc :=_g .NewCBCEncrypter (_adef ,_gdb );OE :=make ([]byte ,32);_bcc .CryptBlocks (OE ,_edfd [:32]);_cdg .OE =OE ;return nil ;
};

// Authenticate implements StdHandler interface.
func (_bdab stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _bdab .alg2a (d ,pass );};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};const _ada ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";


// Authenticate implements StdHandler interface.
func (_dcg stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ec .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_cdc ,_fe :=_dcg .alg7 (d ,pass );if _fe !=nil {return nil ,0,_fe ;};if _cdc !=nil {_ec .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cdc ,PermOwner ,nil ;
};_ec .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_cdc ,_fe =_dcg .alg6 (d ,pass );if _fe !=nil {return nil ,0,_fe ;};
if _cdc !=nil {_ec .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cdc ,d .P ,nil ;};return nil ,0,nil ;};func (_eb stdHandlerR4 )alg3Key (R int ,_ade []byte )[]byte {_ggf :=_cg .New ();
_ac :=_eb .paddedPass (_ade );_ggf .Write (_ac );if R >=3{for _acc :=0;_acc < 50;_acc ++{_eab :=_ggf .Sum (nil );_ggf =_cg .New ();_ggf .Write (_eab );};};_aff :=_ggf .Sum (nil );if R ==2{_aff =_aff [0:5];}else {_aff =_aff [0:_eb .Length /8];};return _aff ;
};func _edb (_eca _g .Block )_g .BlockMode {return (*ecbEncrypter )(_a (_eca ))};type ecb struct{_ecb _g .Block ;_cc int ;};func (_db *ecbEncrypter )BlockSize ()int {return _db ._cc };func _ede (_fae []byte )(_g .Block ,error ){_fdc ,_ggc :=_dg .NewCipher (_fae );
if _ggc !=nil {_ec .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_ggc );
return nil ,_ggc ;};return _fdc ,nil ;};const (PermOwner =Permissions (_ee .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);
PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_fge stdHandlerR6 )alg10 (_geaf *StdEncryptDict ,_dccc []byte )error {if _eff :=_cb ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_dccc );
_eff !=nil {return _eff ;};_cbg :=uint64 (uint32 (_geaf .P ))|(_ee .MaxUint32 <<32);Perms :=make ([]byte ,16);_cf .LittleEndian .PutUint64 (Perms [:8],_cbg );if _geaf .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_ega :=_f .ReadFull (_fc .Reader ,Perms [12:16]);_ega !=nil {return _ega ;};_cea ,_fef :=_ede (_dccc [:32]);if _fef !=nil {return _fef ;};_adcg :=_edb (_cea );_adcg .CryptBlocks (Perms ,Perms );_geaf .Perms =Perms [:16];return nil ;};func (_cag stdHandlerR6 )alg12 (_gcb *StdEncryptDict ,_fgcb []byte )([]byte ,error ){if _gega :=_cb ("\u0061\u006c\u00671\u0032","\u0055",48,_gcb .U );
_gega !=nil {return nil ,_gega ;};if _dcf :=_cb ("\u0061\u006c\u00671\u0032","\u004f",48,_gcb .O );_dcf !=nil {return nil ,_dcf ;};_fbc :=make ([]byte ,len (_fgcb )+8+48);_eac :=copy (_fbc ,_fgcb );_eac +=copy (_fbc [_eac :],_gcb .O [32:40]);_eac +=copy (_fbc [_eac :],_gcb .U [0:48]);
_bed ,_fcf :=_cag .alg2b (_gcb .R ,_fbc ,_fgcb ,_gcb .U [0:48]);if _fcf !=nil {return nil ,_fcf ;};_bed =_bed [:32];if !_df .Equal (_bed ,_gcb .O [:32]){return nil ,nil ;};return _bed ,nil ;};var _ StdHandler =stdHandlerR6 {};func (_gc stdHandlerR4 )alg6 (_bdd *StdEncryptDict ,_ebbg []byte )([]byte ,error ){var (_dea []byte ;
_da error ;);_dcc :=_gc .alg2 (_bdd ,_ebbg );if _bdd .R ==2{_dea ,_da =_gc .alg4 (_dcc ,_ebbg );}else if _bdd .R >=3{_dea ,_da =_gc .alg5 (_dcc ,_ebbg );}else {return nil ,_b .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _da !=nil {return nil ,_da ;
};_ec .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_dea ),string (_bdd .U ));_gfc :=_dea ;_daf :=_bdd .U ;if _bdd .R >=3{if len (_gfc )> 16{_gfc =_gfc [0:16];};if len (_daf )> 16{_daf =_daf [0:16];
};};if !_df .Equal (_gfc ,_daf ){return nil ,nil ;};return _dcc ,nil ;};func (_gfdb stdHandlerR6 )alg11 (_aeb *StdEncryptDict ,_efag []byte )([]byte ,error ){if _fca :=_cb ("\u0061\u006c\u00671\u0031","\u0055",48,_aeb .U );_fca !=nil {return nil ,_fca ;
};_afff :=make ([]byte ,len (_efag )+8);_cbgc :=copy (_afff ,_efag );_cbgc +=copy (_afff [_cbgc :],_aeb .U [32:40]);_dbd ,_aab :=_gfdb .alg2b (_aeb .R ,_afff ,_efag ,nil );if _aab !=nil {return nil ,_aab ;};_dbd =_dbd [:32];if !_df .Equal (_dbd ,_aeb .U [:32]){return nil ,nil ;
};return _dbd ,nil ;};func (_gf stdHandlerR4 )alg2 (_bb *StdEncryptDict ,_fde []byte )[]byte {_ec .Log .Trace ("\u0061\u006c\u0067\u0032");_bg :=_gf .paddedPass (_fde );_dd :=_cg .New ();_dd .Write (_bg );_dd .Write (_bb .O );var _ca [4]byte ;_cf .LittleEndian .PutUint32 (_ca [:],uint32 (_bb .P ));
_dd .Write (_ca [:]);_ec .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_ca );_dd .Write ([]byte (_gf .ID0 ));_ec .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_bb .R ,_bb .EncryptMetadata );
if (_bb .R >=4)&&!_bb .EncryptMetadata {_dd .Write ([]byte {0xff,0xff,0xff,0xff});};_cce :=_dd .Sum (nil );if _bb .R >=3{_dd =_cg .New ();for _faf :=0;_faf < 50;_faf ++{_dd .Reset ();_dd .Write (_cce [0:_gf .Length /8]);_cce =_dd .Sum (nil );};};if _bb .R >=3{return _cce [0:_gf .Length /8];
};return _cce [0:5];};func (_gd *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gd ._cc !=0{_ec .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ec .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_gd ._ecb .Encrypt (dst ,src [:_gd ._cc ]);src =src [_gd ._cc :];dst =dst [_gd ._cc :];};};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_gb stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_ebfe :=_gb .alg3 (d .R ,upass ,opass );if _ebfe !=nil {_ec .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ebfe );
return nil ,_ebfe ;};d .O =O ;_ec .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_adb :=_gb .alg2 (d ,upass );U ,_ebfe :=_gb .alg5 (_adb ,upass );if _ebfe !=nil {_ec .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ebfe );
return nil ,_ebfe ;};d .U =U ;_ec .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _adb ,nil ;};func (_ece stdHandlerR4 )alg5 (_aef []byte ,_bae []byte )([]byte ,error ){_fdd :=_cg .New ();_fdd .Write ([]byte (_ada ));
_fdd .Write ([]byte (_ece .ID0 ));_gda :=_fdd .Sum (nil );_ec .Log .Trace ("\u0061\u006c\u0067\u0035");_ec .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_aef );_ec .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_ece .ID0 );if len (_gda )!=16{return nil ,_b .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_ebb ,_ecc :=_ed .NewCipher (_aef );if _ecc !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eg :=make ([]byte ,16);_ebb .XORKeyStream (_eg ,_gda );_dfg :=make ([]byte ,len (_aef ));for _affc :=0;
_affc < 19;_affc ++{for _ebf :=0;_ebf < len (_aef );_ebf ++{_dfg [_ebf ]=_aef [_ebf ]^byte (_affc +1);};_ebb ,_ecc =_ed .NewCipher (_dfg );if _ecc !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ebb .XORKeyStream (_eg ,_eg );_ec .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_affc ,_dfg );_ec .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_affc ,_eg );
};_bbb :=make ([]byte ,32);for _ddd :=0;_ddd < 16;_ddd ++{_bbb [_ddd ]=_eg [_ddd ];};_ ,_ecc =_fc .Read (_bbb [16:32]);if _ecc !=nil {return nil ,_b .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _bbb ,nil ;};func _a (_ef _g .Block )*ecb {return &ecb {_ecb :_ef ,_cc :_ef .BlockSize ()}};func (_fff stdHandlerR6 )alg13 (_cfdg *StdEncryptDict ,_bdc []byte )error {if _agd :=_cb ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_bdc );_agd !=nil {return _agd ;
};if _gce :=_cb ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_cfdg .Perms );_gce !=nil {return _gce ;};_gbe :=make ([]byte ,16);copy (_gbe ,_cfdg .Perms [:16]);_egf ,_fgg :=_dg .NewCipher (_bdc [:32]);if _fgg !=nil {return _fgg ;};_efab :=_fa (_egf );
_efab .CryptBlocks (_gbe ,_gbe );if !_df .Equal (_gbe [9:12],[]byte ("\u0061\u0064\u0062")){return _b .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_cdb :=Permissions (_cf .LittleEndian .Uint32 (_gbe [0:4]));if _cdb !=_cfdg .P {return _b .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _dfb bool ;if _gbe [8]=='T'{_dfb =true ;}else if _gbe [8]=='F'{_dfb =false ;}else {return _b .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _dfb !=_cfdg .EncryptMetadata {return _b .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func (_cba stdHandlerR6 )alg8 (_afcc *StdEncryptDict ,_fegd []byte ,_gbbg []byte )error {if _gdef :=_cb ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_fegd );_gdef !=nil {return _gdef ;};var _gbd [16]byte ;if _ ,_ffg :=_f .ReadFull (_fc .Reader ,_gbd [:]);
_ffg !=nil {return _ffg ;};_fgcg :=_gbd [0:8];_dbgf :=_gbd [8:16];_bcac :=make ([]byte ,len (_gbbg )+len (_fgcg ));_ga :=copy (_bcac ,_gbbg );copy (_bcac [_ga :],_fgcg );_ebbe ,_bgab :=_cba .alg2b (_afcc .R ,_bcac ,_gbbg ,nil );if _bgab !=nil {return _bgab ;
};U :=make ([]byte ,len (_ebbe )+len (_fgcg )+len (_dbgf ));_ga =copy (U ,_ebbe [:32]);_ga +=copy (U [_ga :],_fgcg );copy (U [_ga :],_dbgf );_afcc .U =U ;_ga =len (_gbbg );copy (_bcac [_ga :],_dbgf );_ebbe ,_bgab =_cba .alg2b (_afcc .R ,_bcac ,_gbbg ,nil );
if _bgab !=nil {return _bgab ;};_baa ,_bgab :=_ede (_ebbe [:32]);if _bgab !=nil {return _bgab ;};_gaf :=make ([]byte ,_dg .BlockSize );_gag :=_g .NewCBCEncrypter (_baa ,_gaf );UE :=make ([]byte ,32);_gag .CryptBlocks (UE ,_fegd [:32]);_afcc .UE =UE ;return nil ;
};func _bga (_dee []byte ,_ace int ){_afc :=_ace ;for _afc < len (_dee ){copy (_dee [_afc :],_dee [:_afc ]);_afc *=2;};};func _dgb (_feb []byte )([]byte ,error ){_fee :=_e .New ();_fee .Write (_feb );return _fee .Sum (nil ),nil };

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_acec stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_cdf :=make ([]byte ,32);if _ ,_gced :=_f .ReadFull (_fc .Reader ,_cdf );_gced !=nil {return nil ,_gced ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;
d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _aaad :=_acec .alg8 (d ,_cdf ,upass );_aaad !=nil {return nil ,_aaad ;};if _fgd :=_acec .alg9 (d ,_cdf ,opass );_fgd !=nil {return nil ,_fgd ;};if d .R ==5{return _cdf ,nil ;
};if _bef :=_acec .alg10 (d ,_cdf );_bef !=nil {return nil ,_bef ;};return _cdf ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};func (_gg *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gg ._cc !=0{_ec .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ec .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_gg ._ecb .Decrypt (dst ,src [:_gg ._cc ]);src =src [_gg ._cc :];dst =dst [_gg ._cc :];};};func (stdHandlerR4 )paddedPass (_fcg []byte )[]byte {_aa :=make ([]byte ,32);_ae :=copy (_aa ,_fcg );for ;_ae < 32;_ae ++{_aa [_ae ]=_ada [_ae -len (_fcg )];
};return _aa ;};func (_bd *ecbDecrypter )BlockSize ()int {return _bd ._cc };func _cb (_dbg ,_fd string ,_ad int ,_ce []byte )error {if len (_ce )< _ad {return errInvalidField {Func :_dbg ,Field :_fd ,Exp :_ad ,Got :len (_ce )};};return nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};type ecbDecrypter ecb ;func _cca (_gbb ,_gfd ,_aaa []byte )([]byte ,error ){var (_edef ,_ebg ,_gff _c .Hash ;);_edef =_e .New ();_gba :=make ([]byte ,64);_bfa :=_edef ;_bfa .Write (_gbb );K :=_bfa .Sum (_gba [:0]);
_ggd :=make ([]byte ,64*(127+64+48));_aga :=func (_cfg int )([]byte ,error ){_dab :=len (_gfd )+len (K )+len (_aaa );_ccfg :=_ggd [:_dab ];_agb :=copy (_ccfg ,_gfd );_agb +=copy (_ccfg [_agb :],K [:]);_agb +=copy (_ccfg [_agb :],_aaa );if _agb !=_dab {_ec .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_b .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_ggd [:_dab *64];_bga (K1 ,_dab );_gdcg ,_cdea :=_ede (K [0:16]);if _cdea !=nil {return nil ,_cdea ;};_efege :=_g .NewCBCEncrypter (_gdcg ,K [16:32]);_efege .CryptBlocks (K1 ,K1 );
E :=K1 ;_cdcf :=0;for _faa :=0;_faa < 16;_faa ++{_cdcf +=int (E [_faa ]%3);};var _agg _c .Hash ;switch _cdcf %3{case 0:_agg =_edef ;case 1:if _ebg ==nil {_ebg =_ff .New384 ();};_agg =_ebg ;case 2:if _gff ==nil {_gff =_ff .New ();};_agg =_gff ;};_agg .Reset ();
_agg .Write (E );K =_agg .Sum (_gba [:0]);return E ,nil ;};for _ecce :=0;;{E ,_gcg :=_aga (_ecce );if _gcg !=nil {return nil ,_gcg ;};_caf :=E [len (E )-1];_ecce ++;if _ecce >=64&&_caf <=uint8 (_ecce -32){break ;};};return K [:32],nil ;};

// Allowed checks if a set of permissions can be granted.
func (_cd Permissions )Allowed (p2 Permissions )bool {return _cd &p2 ==p2 };const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_bgg stdHandlerR4 )alg4 (_bcg []byte ,_fdb []byte )([]byte ,error ){_cgd ,_adg :=_ed .NewCipher (_bcg );
if _adg !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_aae :=[]byte (_ada );_de :=make ([]byte ,len (_aae ));_cgd .XORKeyStream (_de ,_aae );return _de ,nil ;};type stdHandlerR6 struct{};
func (_bfg stdHandlerR6 )alg2a (_cde *StdEncryptDict ,_afb []byte )([]byte ,Permissions ,error ){if _cbf :=_cb ("\u0061\u006c\u00672\u0061","\u004f",48,_cde .O );_cbf !=nil {return nil ,0,_cbf ;};if _feg :=_cb ("\u0061\u006c\u00672\u0061","\u0055",48,_cde .U );
_feg !=nil {return nil ,0,_feg ;};if len (_afb )> 127{_afb =_afb [:127];};_ffbe ,_eec :=_bfg .alg12 (_cde ,_afb );if _eec !=nil {return nil ,0,_eec ;};var (_aaf []byte ;_eed []byte ;_fcb []byte ;);var _ccf Permissions ;if len (_ffbe )!=0{_ccf =PermOwner ;
_fdbf :=make ([]byte ,len (_afb )+8+48);_ebd :=copy (_fdbf ,_afb );_ebd +=copy (_fdbf [_ebd :],_cde .O [40:48]);copy (_fdbf [_ebd :],_cde .U [0:48]);_aaf =_fdbf ;_eed =_cde .OE ;_fcb =_cde .U [0:48];}else {_ffbe ,_eec =_bfg .alg11 (_cde ,_afb );if _eec ==nil &&len (_ffbe )==0{_ffbe ,_eec =_bfg .alg11 (_cde ,[]byte (""));
};if _eec !=nil {return nil ,0,_eec ;}else if len (_ffbe )==0{return nil ,0,nil ;};_ccf =_cde .P ;_efb :=make ([]byte ,len (_afb )+8);_aada :=copy (_efb ,_afb );copy (_efb [_aada :],_cde .U [40:48]);_aaf =_efb ;_eed =_cde .UE ;_fcb =nil ;};if _bca :=_cb ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_eed );
_bca !=nil {return nil ,0,_bca ;};_eed =_eed [:32];_ag ,_eec :=_bfg .alg2b (_cde .R ,_aaf ,_afb ,_fcb );if _eec !=nil {return nil ,0,_eec ;};_ge ,_eec :=_dg .NewCipher (_ag [:32]);if _eec !=nil {return nil ,0,_eec ;};_fgc :=make ([]byte ,_dg .BlockSize );
_cfd :=_g .NewCBCDecrypter (_ge ,_fgc );_cfdf :=make ([]byte ,32);_cfd .CryptBlocks (_cfdf ,_eed );if _cde .R ==5{return _cfdf ,_ccf ,nil ;};_eec =_bfg .alg13 (_cde ,_cfdf );if _eec !=nil {return nil ,0,_eec ;};return _cfdf ,_ccf ,nil ;};func (_fab stdHandlerR6 )alg2b (R int ,_efg ,_ceb ,_ege []byte )([]byte ,error ){if R ==5{return _dgb (_efg );
};return _cca (_efg ,_ceb ,_ege );};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_afg stdHandlerR4 )alg7 (_efe *StdEncryptDict ,_bec []byte )([]byte ,error ){_bda :=_afg .alg3Key (_efe .R ,_bec );_gdc :=make ([]byte ,len (_efe .O ));if _efe .R ==2{_bdb ,_ggb :=_ed .NewCipher (_bda );if _ggb !=nil {return nil ,_b .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_bdb .XORKeyStream (_gdc ,_efe .O );}else if _efe .R >=3{_aad :=append ([]byte {},_efe .O ...);for _cff :=0;_cff < 20;_cff ++{_fce :=append ([]byte {},_bda ...);for _adc :=0;_adc < len (_bda );_adc ++{_fce [_adc ]^=byte (19-_cff );};_acg ,_efeg :=_ed .NewCipher (_fce );
if _efeg !=nil {return nil ,_b .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_acg .XORKeyStream (_gdc ,_aad );_aad =append ([]byte {},_gdc ...);};}else {return nil ,_b .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");
};_bgd ,_bba :=_afg .alg6 (_efe ,_gdc );if _bba !=nil {return nil ,nil ;};return _bgd ,nil ;};type ecbEncrypter ecb ;var _ StdHandler =stdHandlerR4 {};func (_ceg errInvalidField )Error ()string {return _fb .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ceg .Func ,_ceg .Field ,_ceg .Exp ,_ceg .Got );
};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ecd *StdEncryptDict ,_fg ,_ab []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_edf *StdEncryptDict ,_af []byte )([]byte ,Permissions ,error );};func (_gdf stdHandlerR4 )alg3 (R int ,_be ,_ba []byte )([]byte ,error ){var _bf []byte ;if len (_ba )> 0{_bf =_gdf .alg3Key (R ,_ba );}else {_bf =_gdf .alg3Key (R ,_be );};
_dbf ,_bea :=_ed .NewCipher (_bf );if _bea !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_adad :=_gdf .paddedPass (_be );_efa :=make ([]byte ,len (_adad ));_dbf .XORKeyStream (_efa ,_adad );
if R >=3{_bc :=make ([]byte ,len (_bf ));for _fbg :=0;_fbg < 19;_fbg ++{for _dc :=0;_dc < len (_bf );_dc ++{_bc [_dc ]=_bf [_dc ]^byte (_fbg +1);};_ffb ,_gde :=_ed .NewCipher (_bc );if _gde !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ffb .XORKeyStream (_efa ,_efa );};};return _efa ,nil ;};