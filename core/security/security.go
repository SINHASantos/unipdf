//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_fg "bytes";_bc "crypto/aes";_b "crypto/cipher";_fef "crypto/md5";_ba "crypto/rand";_fe "crypto/rc4";_e "crypto/sha256";_gg "crypto/sha512";_d "encoding/binary";_a "errors";_dd "fmt";_aa "github.com/unidoc/unipdf/v3/common";_f "hash";
_be "io";_af "math";);func _ae (_efc _b .Block )_b .BlockMode {return (*ecbEncrypter )(_ef (_efc ))};func (_bgd stdHandlerR4 )alg6 (_cfga *StdEncryptDict ,_fge []byte )([]byte ,error ){var (_aea []byte ;_egg error ;);_bd :=_bgd .alg2 (_cfga ,_fge );if _cfga .R ==2{_aea ,_egg =_bgd .alg4 (_bd ,_fge );
}else if _cfga .R >=3{_aea ,_egg =_bgd .alg5 (_bd ,_fge );}else {return nil ,_a .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _egg !=nil {return nil ,_egg ;};_aa .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_aea ),string (_cfga .U ));
_ca :=_aea ;_dfe :=_cfga .U ;if _cfga .R >=3{if len (_ca )> 16{_ca =_ca [0:16];};if len (_dfe )> 16{_dfe =_dfe [0:16];};};if !_fg .Equal (_ca ,_dfe ){return nil ,nil ;};return _bd ,nil ;};func (_de stdHandlerR4 )alg7 (_cgd *StdEncryptDict ,_gc []byte )([]byte ,error ){_bgf :=_de .alg3Key (_cgd .R ,_gc );
_cefg :=make ([]byte ,len (_cgd .O ));if _cgd .R ==2{_dge ,_aad :=_fe .NewCipher (_bgf );if _aad !=nil {return nil ,_a .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_dge .XORKeyStream (_cefg ,_cgd .O );}else if _cgd .R >=3{_bea :=append ([]byte {},_cgd .O ...);
for _fca :=0;_fca < 20;_fca ++{_bfb :=append ([]byte {},_bgf ...);for _bba :=0;_bba < len (_bgf );_bba ++{_bfb [_bba ]^=byte (19-_fca );};_ace ,_fbf :=_fe .NewCipher (_bfb );if _fbf !=nil {return nil ,_a .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_ace .XORKeyStream (_cefg ,_bea );_bea =append ([]byte {},_cefg ...);};}else {return nil ,_a .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_gb ,_bgb :=_de .alg6 (_cgd ,_cefg );if _bgb !=nil {return nil ,nil ;};return _gb ,nil ;};var _ StdHandler =stdHandlerR4 {};
func _ebd (_fdb []byte ,_aec int ){_fgc :=_aec ;for _fgc < len (_fdb ){copy (_fdb [_fgc :],_fdb [:_fgc ]);_fgc *=2;};};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_fga stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_ded :=_fga .alg3 (d .R ,upass ,opass );if _ded !=nil {_aa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ded );
return nil ,_ded ;};d .O =O ;_aa .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_agb :=_fga .alg2 (d ,upass );U ,_ded :=_fga .alg5 (_agb ,upass );if _ded !=nil {_aa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ded );
return nil ,_ded ;};d .U =U ;_aa .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _agb ,nil ;};func (stdHandlerR4 )paddedPass (_geg []byte )[]byte {_bab :=make ([]byte ,32);_cfg :=copy (_bab ,_geg );for ;_cfg < 32;
_cfg ++{_bab [_cfg ]=_bg [_cfg -len (_geg )];};return _bab ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_ebf stdHandlerR6 )alg11 (_def *StdEncryptDict ,_dab []byte )([]byte ,error ){if _bde :=_ggfe ("\u0061\u006c\u00671\u0031","\u0055",48,_def .U );_bde !=nil {return nil ,_bde ;};_daa :=make ([]byte ,len (_dab )+8);_fgg :=copy (_daa ,_dab );
_fgg +=copy (_daa [_fgg :],_def .U [32:40]);_dfc ,_fefb :=_ebf .alg2b (_def .R ,_daa ,_dab ,nil );if _fefb !=nil {return nil ,_fefb ;};_dfc =_dfc [:32];if !_fg .Equal (_dfc ,_def .U [:32]){return nil ,nil ;};return _dfc ,nil ;};

// Authenticate implements StdHandler interface.
func (_effg stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _effg .alg2a (d ,pass );};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_ee *ecbDecrypter )BlockSize ()int {return _ee ._aaf };var _ StdHandler =stdHandlerR6 {};func (_fgf stdHandlerR4 )alg3 (R int ,_dba ,_aaa []byte )([]byte ,error ){var _ece []byte ;if len (_aaa )> 0{_ece =_fgf .alg3Key (R ,_aaa );
}else {_ece =_fgf .alg3Key (R ,_dba );};_cfb ,_cce :=_fe .NewCipher (_ece );if _cce !=nil {return nil ,_a .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eaa :=_fgf .paddedPass (_dba );_eb :=make ([]byte ,len (_eaa ));
_cfb .XORKeyStream (_eb ,_eaa );if R >=3{_ga :=make ([]byte ,len (_ece ));for _geb :=0;_geb < 19;_geb ++{for _eef :=0;_eef < len (_ece );_eef ++{_ga [_eef ]=_ece [_eef ]^byte (_geb +1);};_fd ,_ac :=_fe .NewCipher (_ga );if _ac !=nil {return nil ,_a .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_fd .XORKeyStream (_eb ,_eb );};};return _eb ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_cf errInvalidField )Error ()string {return _dd .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_cf .Func ,_cf .Field ,_cf .Exp ,_cf .Got );
};func _ddfc (_ebe ,_afd ,_dbg []byte )([]byte ,error ){var (_fee ,_feg ,_ebeb _f .Hash ;);_fee =_e .New ();_eedc :=make ([]byte ,64);_dbaf :=_fee ;_dbaf .Write (_ebe );K :=_dbaf .Sum (_eedc [:0]);_ab :=make ([]byte ,64*(127+64+48));_acf :=func (_bfbe int )([]byte ,error ){_ddgb :=len (_afd )+len (K )+len (_dbg );
_egca :=_ab [:_ddgb ];_fefe :=copy (_egca ,_afd );_fefe +=copy (_egca [_fefe :],K [:]);_fefe +=copy (_egca [_fefe :],_dbg );if _fefe !=_ddgb {_aa .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_a .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_ab [:_ddgb *64];_ebd (K1 ,_ddgb );_ffb ,_gbb :=_dbb (K [0:16]);if _gbb !=nil {return nil ,_gbb ;};_aee :=_b .NewCBCEncrypter (_ffb ,K [16:32]);_aee .CryptBlocks (K1 ,K1 );
E :=K1 ;_bcf :=0;for _cgda :=0;_cgda < 16;_cgda ++{_bcf +=int (E [_cgda ]%3);};var _fce _f .Hash ;switch _bcf %3{case 0:_fce =_fee ;case 1:if _feg ==nil {_feg =_gg .New384 ();};_fce =_feg ;case 2:if _ebeb ==nil {_ebeb =_gg .New ();};_fce =_ebeb ;};_fce .Reset ();
_fce .Write (E );K =_fce .Sum (_eedc [:0]);return E ,nil ;};for _bge :=0;;{E ,_bbc :=_acf (_bge );if _bbc !=nil {return nil ,_bbc ;};_abb :=E [len (E )-1];_bge ++;if _bge >=64&&_abb <=uint8 (_bge -32){break ;};};return K [:32],nil ;};const (PermOwner =Permissions (_af .MaxUint32 );
PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11);
);type ecbEncrypter ecb ;func (_c *ecbEncrypter )BlockSize ()int {return _c ._aaf };

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_fb *StdEncryptDict ,_ad ,_ggf []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_gf *StdEncryptDict ,_ec []byte )([]byte ,Permissions ,error );};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_gee stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_efdce :=make ([]byte ,32);if _ ,_afa :=_be .ReadFull (_ba .Reader ,_efdce );_afa !=nil {return nil ,_afa ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;
d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _fea :=_gee .alg8 (d ,_efdce ,upass );_fea !=nil {return nil ,_fea ;};if _dec :=_gee .alg9 (d ,_efdce ,opass );_dec !=nil {return nil ,_dec ;};if d .R ==5{return _efdce ,nil ;
};if _fcca :=_gee .alg10 (d ,_efdce );_fcca !=nil {return nil ,_fcca ;};return _efdce ,nil ;};type stdHandlerR6 struct{};func _ggfe (_da ,_ddf string ,_aed int ,_cde []byte )error {if len (_cde )< _aed {return errInvalidField {Func :_da ,Field :_ddf ,Exp :_aed ,Got :len (_cde )};
};return nil ;};func (_gfa stdHandlerR4 )alg5 (_ed []byte ,_ggcd []byte )([]byte ,error ){_egf :=_fef .New ();_egf .Write ([]byte (_bg ));_egf .Write ([]byte (_gfa .ID0 ));_ade :=_egf .Sum (nil );_aa .Log .Trace ("\u0061\u006c\u0067\u0035");_aa .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_ed );
_aa .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_gfa .ID0 );if len (_ade )!=16{return nil ,_a .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_agg ,_fcd :=_fe .NewCipher (_ed );
if _fcd !=nil {return nil ,_a .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fdc :=make ([]byte ,16);_agg .XORKeyStream (_fdc ,_ade );_egc :=make ([]byte ,len (_ed ));for _bfe :=0;_bfe < 19;_bfe ++{for _bb :=0;
_bb < len (_ed );_bb ++{_egc [_bb ]=_ed [_bb ]^byte (_bfe +1);};_agg ,_fcd =_fe .NewCipher (_egc );if _fcd !=nil {return nil ,_a .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_agg .XORKeyStream (_fdc ,_fdc );
_aa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_bfe ,_egc );_aa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_bfe ,_fdc );};_fcbe :=make ([]byte ,32);
for _ff :=0;_ff < 16;_ff ++{_fcbe [_ff ]=_fdc [_ff ];};_ ,_fcd =_ba .Read (_fcbe [16:32]);if _fcd !=nil {return nil ,_a .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};
return _fcbe ,nil ;};func (_acd stdHandlerR6 )alg9 (_eba *StdEncryptDict ,_cdb []byte ,_ccb []byte )error {if _cbc :=_ggfe ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_cdb );_cbc !=nil {return _cbc ;};if _eec :=_ggfe ("\u0061\u006c\u0067\u0039","\u0055",48,_eba .U );
_eec !=nil {return _eec ;};var _bgda [16]byte ;if _ ,_fbad :=_be .ReadFull (_ba .Reader ,_bgda [:]);_fbad !=nil {return _fbad ;};_gde :=_bgda [0:8];_deed :=_bgda [8:16];_caa :=_eba .U [:48];_cfe :=make ([]byte ,len (_ccb )+len (_gde )+len (_caa ));_beac :=copy (_cfe ,_ccb );
_beac +=copy (_cfe [_beac :],_gde );_beac +=copy (_cfe [_beac :],_caa );_cbf ,_ebb :=_acd .alg2b (_eba .R ,_cfe ,_ccb ,_caa );if _ebb !=nil {return _ebb ;};O :=make ([]byte ,len (_cbf )+len (_gde )+len (_deed ));_beac =copy (O ,_cbf [:32]);_beac +=copy (O [_beac :],_gde );
_beac +=copy (O [_beac :],_deed );_eba .O =O ;_beac =len (_ccb );_beac +=copy (_cfe [_beac :],_deed );_cbf ,_ebb =_acd .alg2b (_eba .R ,_cfe ,_ccb ,_caa );if _ebb !=nil {return _ebb ;};_gfe ,_ebb :=_dbb (_cbf [:32]);if _ebb !=nil {return _ebb ;};_ggb :=make ([]byte ,_bc .BlockSize );
_bdc :=_b .NewCBCEncrypter (_gfe ,_ggb );OE :=make ([]byte ,32);_bdc .CryptBlocks (OE ,_cdb [:32]);_eba .OE =OE ;return nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};func (_df stdHandlerR4 )alg2 (_ag *StdEncryptDict ,_ea []byte )[]byte {_aa .Log .Trace ("\u0061\u006c\u0067\u0032");
_dg :=_df .paddedPass (_ea );_beg :=_fef .New ();_beg .Write (_dg );_beg .Write (_ag .O );var _fa [4]byte ;_d .LittleEndian .PutUint32 (_fa [:],uint32 (_ag .P ));_beg .Write (_fa [:]);_aa .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_fa );
_beg .Write ([]byte (_df .ID0 ));_aa .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ag .R ,_ag .EncryptMetadata );
if (_ag .R >=4)&&!_ag .EncryptMetadata {_beg .Write ([]byte {0xff,0xff,0xff,0xff});};_db :=_beg .Sum (nil );if _ag .R >=3{_beg =_fef .New ();for _cc :=0;_cc < 50;_cc ++{_beg .Reset ();_beg .Write (_db [0:_df .Length /8]);_db =_beg .Sum (nil );};};if _ag .R >=3{return _db [0:_df .Length /8];
};return _db [0:5];};func (_eab stdHandlerR6 )alg12 (_gea *StdEncryptDict ,_eedd []byte )([]byte ,error ){if _dgf :=_ggfe ("\u0061\u006c\u00671\u0032","\u0055",48,_gea .U );_dgf !=nil {return nil ,_dgf ;};if _gcf :=_ggfe ("\u0061\u006c\u00671\u0032","\u004f",48,_gea .O );
_gcf !=nil {return nil ,_gcf ;};_efdc :=make ([]byte ,len (_eedd )+8+48);_fgd :=copy (_efdc ,_eedd );_fgd +=copy (_efdc [_fgd :],_gea .O [32:40]);_fgd +=copy (_efdc [_fgd :],_gea .U [0:48]);_efb ,_gdb :=_eab .alg2b (_gea .R ,_efdc ,_eedd ,_gea .U [0:48]);
if _gdb !=nil {return nil ,_gdb ;};_efb =_efb [:32];if !_fg .Equal (_efb ,_gea .O [:32]){return nil ,nil ;};return _efb ,nil ;};func (_beae stdHandlerR6 )alg10 (_gag *StdEncryptDict ,_cac []byte )error {if _bdb :=_ggfe ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_cac );
_bdb !=nil {return _bdb ;};_eae :=uint64 (uint32 (_gag .P ))|(_af .MaxUint32 <<32);Perms :=make ([]byte ,16);_d .LittleEndian .PutUint64 (Perms [:8],_eae );if _gag .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_bbd :=_be .ReadFull (_ba .Reader ,Perms [12:16]);_bbd !=nil {return _bbd ;};_gaa ,_aab :=_dbb (_cac [:32]);if _aab !=nil {return _aab ;};_ccg :=_ae (_gaa );_ccg .CryptBlocks (Perms ,Perms );_gag .Perms =Perms [:16];return nil ;};type errInvalidField struct{Func string ;
Field string ;Exp int ;Got int ;};func (_eg *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_eg ._aaf !=0{_aa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_aa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_eg ._ddg .Encrypt (dst ,src [:_eg ._aaf ]);src =src [_eg ._aaf :];dst =dst [_eg ._aaf :];};};type ecbDecrypter ecb ;func (_gdd stdHandlerR4 )alg4 (_bff []byte ,_cef []byte )([]byte ,error ){_fcb ,_cg :=_fe .NewCipher (_bff );
if _cg !=nil {return nil ,_a .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fcc :=[]byte (_bg );_dgd :=make ([]byte ,len (_fcc ));_fcb .XORKeyStream (_dgd ,_fcc );return _dgd ,nil ;};func _dade (_fbd []byte )([]byte ,error ){_cffca :=_e .New ();
_cffca .Write (_fbd );return _cffca .Sum (nil ),nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func _ce (_ge _b .Block )_b .BlockMode {return (*ecbDecrypter )(_ef (_ge ))};func (_ggc stdHandlerR4 )alg3Key (R int ,_ccf []byte )[]byte {_aef :=_fef .New ();_gef :=_ggc .paddedPass (_ccf );_aef .Write (_gef );
if R >=3{for _dag :=0;_dag < 50;_dag ++{_fc :=_aef .Sum (nil );_aef =_fef .New ();_aef .Write (_fc );};};_bf :=_aef .Sum (nil );if R ==2{_bf =_bf [0:5];}else {_bf =_bf [0:_ggc .Length /8];};return _bf ;};

// Allowed checks if a set of permissions can be granted.
func (_gd Permissions )Allowed (p2 Permissions )bool {return _gd &p2 ==p2 };const _bg ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_cd *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cd ._aaf !=0{_aa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_aa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cd ._ddg .Decrypt (dst ,src [:_cd ._aaf ]);src =src [_cd ._aaf :];dst =dst [_cd ._aaf :];};};func (_cff stdHandlerR6 )alg2a (_eed *StdEncryptDict ,_ced []byte )([]byte ,Permissions ,error ){if _cb :=_ggfe ("\u0061\u006c\u00672\u0061","\u004f",48,_eed .O );
_cb !=nil {return nil ,0,_cb ;};if _aadg :=_ggfe ("\u0061\u006c\u00672\u0061","\u0055",48,_eed .U );_aadg !=nil {return nil ,0,_aadg ;};if len (_ced )> 127{_ced =_ced [:127];};_gfd ,_ffe :=_cff .alg12 (_eed ,_ced );if _ffe !=nil {return nil ,0,_ffe ;};
var (_fcg []byte ;_gbc []byte ;_eff []byte ;);var _eac Permissions ;if len (_gfd )!=0{_eac =PermOwner ;_cda :=make ([]byte ,len (_ced )+8+48);_cdg :=copy (_cda ,_ced );_cdg +=copy (_cda [_cdg :],_eed .O [40:48]);copy (_cda [_cdg :],_eed .U [0:48]);_fcg =_cda ;
_gbc =_eed .OE ;_eff =_eed .U [0:48];}else {_gfd ,_ffe =_cff .alg11 (_eed ,_ced );if _ffe ==nil &&len (_gfd )==0{_gfd ,_ffe =_cff .alg11 (_eed ,[]byte (""));};if _ffe !=nil {return nil ,0,_ffe ;}else if len (_gfd )==0{return nil ,0,nil ;};_eac =_eed .P ;
_efd :=make ([]byte ,len (_ced )+8);_egcb :=copy (_efd ,_ced );copy (_efd [_egcb :],_eed .U [40:48]);_fcg =_efd ;_gbc =_eed .UE ;_eff =nil ;};if _bffc :=_ggfe ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_gbc );_bffc !=nil {return nil ,0,_bffc ;
};_gbc =_gbc [:32];_bgfe ,_ffe :=_cff .alg2b (_eed .R ,_fcg ,_ced ,_eff );if _ffe !=nil {return nil ,0,_ffe ;};_ffg ,_ffe :=_bc .NewCipher (_bgfe [:32]);if _ffe !=nil {return nil ,0,_ffe ;};_dfd :=make ([]byte ,_bc .BlockSize );_cffc :=_b .NewCBCDecrypter (_ffg ,_dfd );
_afg :=make ([]byte ,32);_cffc .CryptBlocks (_afg ,_gbc );if _eed .R ==5{return _afg ,_eac ,nil ;};_ffe =_cff .alg13 (_eed ,_afg );if _ffe !=nil {return nil ,0,_ffe ;};return _afg ,_eac ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_fdf stdHandlerR6 )alg13 (_gfb *StdEncryptDict ,_acfb []byte )error {if _bffd :=_ggfe ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_acfb );
_bffd !=nil {return _bffd ;};if _aece :=_ggfe ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_gfb .Perms );_aece !=nil {return _aece ;};_efg :=make ([]byte ,16);copy (_efg ,_gfb .Perms [:16]);_feec ,_cdef :=_bc .NewCipher (_acfb [:32]);if _cdef !=nil {return _cdef ;
};_cffe :=_ce (_feec );_cffe .CryptBlocks (_efg ,_efg );if !_fg .Equal (_efg [9:12],[]byte ("\u0061\u0064\u0062")){return _a .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_dfa :=Permissions (_d .LittleEndian .Uint32 (_efg [0:4]));if _dfa !=_gfb .P {return _a .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _dc bool ;if _efg [8]=='T'{_dc =true ;}else if _efg [8]=='F'{_dc =false ;}else {return _a .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _dc !=_gfb .EncryptMetadata {return _a .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};
return nil ;};func _ef (_dda _b .Block )*ecb {return &ecb {_ddg :_dda ,_aaf :_dda .BlockSize ()}};

// Authenticate implements StdHandler interface.
func (_bgc stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_aa .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_gebb ,_edb :=_bgc .alg7 (d ,pass );if _edb !=nil {return nil ,0,_edb ;};if _gebb !=nil {_aa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gebb ,PermOwner ,nil ;
};_aa .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_gebb ,_edb =_bgc .alg6 (d ,pass );if _edb !=nil {return nil ,0,_edb ;
};if _gebb !=nil {_aa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gebb ,d .P ,nil ;};return nil ,0,nil ;};type ecb struct{_ddg _b .Block ;_aaf int ;};func (_gcg stdHandlerR6 )alg8 (_fbc *StdEncryptDict ,_ffbd []byte ,_fbfa []byte )error {if _bac :=_ggfe ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_ffbd );
_bac !=nil {return _bac ;};var _gfg [16]byte ;if _ ,_dee :=_be .ReadFull (_ba .Reader ,_gfg [:]);_dee !=nil {return _dee ;};_acfc :=_gfg [0:8];_add :=_gfg [8:16];_cec :=make ([]byte ,len (_fbfa )+len (_acfc ));_cfff :=copy (_cec ,_fbfa );copy (_cec [_cfff :],_acfc );
_gfdf ,_ccd :=_gcg .alg2b (_fbc .R ,_cec ,_fbfa ,nil );if _ccd !=nil {return _ccd ;};U :=make ([]byte ,len (_gfdf )+len (_acfc )+len (_add ));_cfff =copy (U ,_gfdf [:32]);_cfff +=copy (U [_cfff :],_acfc );copy (U [_cfff :],_add );_fbc .U =U ;_cfff =len (_fbfa );
copy (_cec [_cfff :],_add );_gfdf ,_ccd =_gcg .alg2b (_fbc .R ,_cec ,_fbfa ,nil );if _ccd !=nil {return _ccd ;};_cfa ,_ccd :=_dbb (_gfdf [:32]);if _ccd !=nil {return _ccd ;};_fba :=make ([]byte ,_bc .BlockSize );_gcb :=_b .NewCBCEncrypter (_cfa ,_fba );
UE :=make ([]byte ,32);_gcb .CryptBlocks (UE ,_ffbd [:32]);_fbc .UE =UE ;return nil ;};func _dbb (_aeb []byte )(_b .Block ,error ){_fde ,_fad :=_bc .NewCipher (_aeb );if _fad !=nil {_aa .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_fad );
return nil ,_fad ;};return _fde ,nil ;};func (_eefa stdHandlerR6 )alg2b (R int ,_bfg ,_dgb ,_acea []byte )([]byte ,error ){if R ==5{return _dade (_bfg );};return _ddfc (_bfg ,_dgb ,_acea );};