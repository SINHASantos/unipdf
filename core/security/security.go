//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_db "bytes";_eb "crypto/aes";_gf "crypto/cipher";_fd "crypto/md5";_ebe "crypto/rand";_ec "crypto/rc4";_ad "crypto/sha256";_a "crypto/sha512";_f "encoding/binary";_eg "errors";_ed "fmt";_ee "github.com/unidoc/unipdf/v4/common";
_d "hash";_e "io";_ada "math";);func (_gdfb stdHandlerR6 )alg2b (R int ,_ccf ,_eag ,_fad []byte )([]byte ,error ){if R ==5{return _bgd (_ccf );};return _afd (_ccf ,_eag ,_fad );};func _deab (_aag []byte )(_gf .Block ,error ){_gbg ,_ccb :=_eb .NewCipher (_aag );
if _ccb !=nil {_ee .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_ccb );
return nil ,_ccb ;};return _gbg ,nil ;};type ecbDecrypter ecb ;type ecb struct{_ga _gf .Block ;_eda int ;};func (_ebef stdHandlerR4 )alg7 (_dab *StdEncryptDict ,_dd []byte )([]byte ,error ){_fcf :=_ebef .alg3Key (_dab .R ,_dd );_ea :=make ([]byte ,len (_dab .O ));
if _dab .R ==2{_agg ,_aed :=_ec .NewCipher (_fcf );if _aed !=nil {return nil ,_eg .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_agg .XORKeyStream (_ea ,_dab .O );}else if _dab .R >=3{_dabe :=append ([]byte {},_dab .O ...);
for _cdc :=0;_cdc < 20;_cdc ++{_gcf :=append ([]byte {},_fcf ...);for _afge :=0;_afge < len (_fcf );_afge ++{_gcf [_afge ]^=byte (19-_cdc );};_ceg ,_dgec :=_ec .NewCipher (_gcf );if _dgec !=nil {return nil ,_eg .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_ceg .XORKeyStream (_ea ,_dabe );_dabe =append ([]byte {},_ea ...);};}else {return nil ,_eg .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_gg ,_aaa :=_ebef .alg6 (_dab ,_ea );if _aaa !=nil {return nil ,nil ;};return _gg ,nil ;};func (_afdf stdHandlerR6 )alg11 (_aegb *StdEncryptDict ,_ffa []byte )([]byte ,error ){if _eddg :=_ac ("\u0061\u006c\u00671\u0031","\u0055",48,_aegb .U );
_eddg !=nil {return nil ,_eddg ;};_fedc :=make ([]byte ,len (_ffa )+8);_gabd :=copy (_fedc ,_ffa );_gabd +=copy (_fedc [_gabd :],_aegb .U [32:40]);_ace ,_bagb :=_afdf .alg2b (_aegb .R ,_fedc ,_ffa ,nil );if _bagb !=nil {return nil ,_bagb ;};_ace =_ace [:32];
if !_db .Equal (_ace ,_aegb .U [:32]){return nil ,nil ;};return _ace ,nil ;};func (_cgd *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cgd ._eda !=0{_ee .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ee .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cgd ._ga .Decrypt (dst ,src [:_cgd ._eda ]);src =src [_cgd ._eda :];dst =dst [_cgd ._eda :];};};func _agb (_bbg []byte ,_bgec int ){_gaf :=_bgec ;for _gaf < len (_bbg ){copy (_bbg [_gaf :],_bbg [:_gaf ]);_gaf *=2;};};

// Authenticate implements StdHandler interface.
func (_agc stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _agc .alg2a (d ,pass );};type stdHandlerR6 struct{};func (stdHandlerR4 )paddedPass (_bg []byte )[]byte {_bd :=make ([]byte ,32);_ca :=copy (_bd ,_bg );
for ;_ca < 32;_ca ++{_bd [_ca ]=_cd [_ca -len (_bg )];};return _bd ;};func _af (_de _gf .Block )*ecb {return &ecb {_ga :_de ,_eda :_de .BlockSize ()}};type ecbEncrypter ecb ;

// Authenticate implements StdHandler interface.
func (_aef stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ee .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_bad ,_ddg :=_aef .alg7 (d ,pass );if _ddg !=nil {return nil ,0,_ddg ;};if _bad !=nil {_ee .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _bad ,PermOwner ,nil ;
};_ee .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_bad ,_ddg =_aef .alg6 (d ,pass );if _ddg !=nil {return nil ,0,_ddg ;
};if _bad !=nil {_ee .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _bad ,d .P ,nil ;};return nil ,0,nil ;};var _ StdHandler =stdHandlerR4 {};func (_df stdHandlerR4 )alg3Key (R int ,_dga []byte )[]byte {_dfa :=_fd .New ();
_ce :=_df .paddedPass (_dga );_dfa .Write (_ce );if R >=3{for _ae :=0;_ae < 50;_ae ++{_fe :=_dfa .Sum (nil );_dfa =_fd .New ();_dfa .Write (_fe );};};_aeg :=_dfa .Sum (nil );if R ==2{_aeg =_aeg [0:5];}else {_aeg =_aeg [0:_df .Length /8];};return _aeg ;
};func (_aeb stdHandlerR4 )alg3 (R int ,_dgb ,_bb []byte )([]byte ,error ){var _ecf []byte ;if len (_bb )> 0{_ecf =_aeb .alg3Key (R ,_bb );}else {_ecf =_aeb .alg3Key (R ,_dgb );};_gcb ,_be :=_ec .NewCipher (_ecf );if _be !=nil {return nil ,_eg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_da :=_aeb .paddedPass (_dgb );_cda :=make ([]byte ,len (_da ));_gcb .XORKeyStream (_cda ,_da );if R >=3{_fbd :=make ([]byte ,len (_ecf ));for _aff :=0;_aff < 19;_aff ++{for _adae :=0;_adae < len (_ecf );_adae ++{_fbd [_adae ]=_ecf [_adae ]^byte (_aff +1);
};_cgg ,_fdf :=_ec .NewCipher (_fbd );if _fdf !=nil {return nil ,_eg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cgg .XORKeyStream (_cda ,_cda );};};return _cda ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_dabd stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_fcd :=_dabd .alg3 (d .R ,upass ,opass );if _fcd !=nil {_ee .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fcd );
return nil ,_fcd ;};d .O =O ;_ee .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_dbae :=_dabd .alg2 (d ,upass );U ,_fcd :=_dabd .alg5 (_dbae ,upass );if _fcd !=nil {_ee .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fcd );
return nil ,_fcd ;};d .U =U ;_ee .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _dbae ,nil ;};func (_gce stdHandlerR6 )alg13 (_fec *StdEncryptDict ,_bdg []byte )error {if _ebc :=_ac ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_bdg );
_ebc !=nil {return _ebc ;};if _cbf :=_ac ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_fec .Perms );_cbf !=nil {return _cbf ;};_dbc :=make ([]byte ,16);copy (_dbc ,_fec .Perms [:16]);_cbef ,_afa :=_eb .NewCipher (_bdg [:32]);if _afa !=nil {return _afa ;
};_abba :=_gd (_cbef );_abba .CryptBlocks (_dbc ,_dbc );if !_db .Equal (_dbc [9:12],[]byte ("\u0061\u0064\u0062")){return _eg .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_fda :=Permissions (_f .LittleEndian .Uint32 (_dbc [0:4]));if _fda !=_fec .P {return _eg .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _dfda bool ;if _dbc [8]=='T'{_dfda =true ;}else if _dbc [8]=='F'{_dfda =false ;}else {return _eg .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _dfda !=_fec .EncryptMetadata {return _eg .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};const (PermOwner =Permissions (_ada .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);
PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_bbc stdHandlerR6 )alg10 (_adag *StdEncryptDict ,_bde []byte )error {if _gab :=_ac ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_bde );_gab !=nil {return _gab ;
};_dcd :=uint64 (uint32 (_adag .P ))|(_ada .MaxUint32 <<32);Perms :=make ([]byte ,16);_f .LittleEndian .PutUint64 (Perms [:8],_dcd );if _adag .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_cgad :=_e .ReadFull (_ebe .Reader ,Perms [12:16]);
_cgad !=nil {return _cgad ;};_aegg ,_ccc :=_deab (_bde [:32]);if _ccc !=nil {return _ccc ;};_fff :=_dc (_aegg );_fff .CryptBlocks (Perms ,Perms );_adag .Perms =Perms [:16];return nil ;};func (_afb stdHandlerR4 )alg5 (_gb []byte ,_gec []byte )([]byte ,error ){_cc :=_fd .New ();
_cc .Write ([]byte (_cd ));_cc .Write ([]byte (_afb .ID0 ));_bdd :=_cc .Sum (nil );_ee .Log .Trace ("\u0061\u006c\u0067\u0035");_ee .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_gb );_ee .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_afb .ID0 );
if len (_bdd )!=16{return nil ,_eg .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_dcf ,_gfe :=_ec .NewCipher (_gb );if _gfe !=nil {return nil ,_eg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bga :=make ([]byte ,16);_dcf .XORKeyStream (_bga ,_bdd );_cac :=make ([]byte ,len (_gb ));for _fef :=0;_fef < 19;_fef ++{for _gea :=0;_gea < len (_gb );_gea ++{_cac [_gea ]=_gb [_gea ]^byte (_fef +1);};_dcf ,_gfe =_ec .NewCipher (_cac );if _gfe !=nil {return nil ,_eg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_dcf .XORKeyStream (_bga ,_bga );_ee .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_fef ,_cac );_ee .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_fef ,_bga );
};_bf :=make ([]byte ,32);for _fbb :=0;_fbb < 16;_fbb ++{_bf [_fbb ]=_bga [_fbb ];};_ ,_gfe =_ebe .Read (_bf [16:32]);if _gfe !=nil {return nil ,_eg .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _bf ,nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_gdf stdHandlerR4 )alg4 (_abf []byte ,_aegc []byte )([]byte ,error ){_fca ,_cgc :=_ec .NewCipher (_abf );if _cgc !=nil {return nil ,_eg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_aee :=[]byte (_cd );_beb :=make ([]byte ,len (_aee ));_fca .XORKeyStream (_beb ,_aee );return _beb ,nil ;};func (_b *ecbDecrypter )BlockSize ()int {return _b ._eda };func (_fee stdHandlerR6 )alg9 (_dcfa *StdEncryptDict ,_eae []byte ,_fbc []byte )error {if _bgdd :=_ac ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_eae );
_bgdd !=nil {return _bgdd ;};if _gca :=_ac ("\u0061\u006c\u0067\u0039","\u0055",48,_dcfa .U );_gca !=nil {return _gca ;};var _cbe [16]byte ;if _ ,_gbd :=_e .ReadFull (_ebe .Reader ,_cbe [:]);_gbd !=nil {return _gbd ;};_dfd :=_cbe [0:8];_cec :=_cbe [8:16];
_agf :=_dcfa .U [:48];_baa :=make ([]byte ,len (_fbc )+len (_dfd )+len (_agf ));_dfe :=copy (_baa ,_fbc );_dfe +=copy (_baa [_dfe :],_dfd );_dfe +=copy (_baa [_dfe :],_agf );_bgdb ,_eged :=_fee .alg2b (_dcfa .R ,_baa ,_fbc ,_agf );if _eged !=nil {return _eged ;
};O :=make ([]byte ,len (_bgdb )+len (_dfd )+len (_cec ));_dfe =copy (O ,_bgdb [:32]);_dfe +=copy (O [_dfe :],_dfd );_dfe +=copy (O [_dfe :],_cec );_dcfa .O =O ;_dfe =len (_fbc );_dfe +=copy (_baa [_dfe :],_cec );_bgdb ,_eged =_fee .alg2b (_dcfa .R ,_baa ,_fbc ,_agf );
if _eged !=nil {return _eged ;};_aea ,_eged :=_deab (_bgdb [:32]);if _eged !=nil {return _eged ;};_bab :=make ([]byte ,_eb .BlockSize );_dfaf :=_gf .NewCBCEncrypter (_aea ,_bab );OE :=make ([]byte ,32);_dfaf .CryptBlocks (OE ,_eae [:32]);_dcfa .OE =OE ;
return nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_efa stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_afc :=make ([]byte ,32);if _ ,_aec :=_e .ReadFull (_ebe .Reader ,_afc );_aec !=nil {return nil ,_aec ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _abg :=_efa .alg8 (d ,_afc ,upass );_abg !=nil {return nil ,_abg ;};if _fdb :=_efa .alg9 (d ,_afc ,opass );_fdb !=nil {return nil ,_fdb ;};if d .R ==5{return _afc ,nil ;
};if _ebg :=_efa .alg10 (d ,_afc );_ebg !=nil {return nil ,_ebg ;};return _afc ,nil ;};

// Allowed checks if a set of permissions can be granted.
func (_fc Permissions )Allowed (p2 Permissions )bool {return _fc &p2 ==p2 };

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_fbbc stdHandlerR6 )alg12 (_ddc *StdEncryptDict ,_afe []byte )([]byte ,error ){if _acg :=_ac ("\u0061\u006c\u00671\u0032","\u0055",48,_ddc .U );
_acg !=nil {return nil ,_acg ;};if _geaf :=_ac ("\u0061\u006c\u00671\u0032","\u004f",48,_ddc .O );_geaf !=nil {return nil ,_geaf ;};_aeea :=make ([]byte ,len (_afe )+8+48);_aggg :=copy (_aeea ,_afe );_aggg +=copy (_aeea [_aggg :],_ddc .O [32:40]);_aggg +=copy (_aeea [_aggg :],_ddc .U [0:48]);
_agfc ,_ecd :=_fbbc .alg2b (_ddc .R ,_aeea ,_afe ,_ddc .U [0:48]);if _ecd !=nil {return nil ,_ecd ;};_agfc =_agfc [:32];if !_db .Equal (_agfc ,_ddc .O [:32]){return nil ,nil ;};return _agfc ,nil ;};func _afd (_gfbg ,_egee ,_ff []byte )([]byte ,error ){var (_cee ,_eca ,_ggb _d .Hash ;
);_cee =_ad .New ();_bgg :=make ([]byte ,64);_gbgg :=_cee ;_gbgg .Write (_gfbg );K :=_gbgg .Sum (_bgg [:0]);_fgb :=make ([]byte ,64*(127+64+48));_gcg :=func (_cab int )([]byte ,error ){_bca :=len (_egee )+len (K )+len (_ff );_ccd :=_fgb [:_bca ];_cacd :=copy (_ccd ,_egee );
_cacd +=copy (_ccd [_cacd :],K [:]);_cacd +=copy (_ccd [_cacd :],_ff );if _cacd !=_bca {_ee .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_eg .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_fgb [:_bca *64];_agb (K1 ,_bca );_adb ,_aad :=_deab (K [0:16]);if _aad !=nil {return nil ,_aad ;};_ecbc :=_gf .NewCBCEncrypter (_adb ,K [16:32]);_ecbc .CryptBlocks (K1 ,K1 );
E :=K1 ;_ddga :=0;for _fefa :=0;_fefa < 16;_fefa ++{_ddga +=int (E [_fefa ]%3);};var _aeee _d .Hash ;switch _ddga %3{case 0:_aeee =_cee ;case 1:if _eca ==nil {_eca =_a .New384 ();};_aeee =_eca ;case 2:if _ggb ==nil {_ggb =_a .New ();};_aeee =_ggb ;};_aeee .Reset ();
_aeee .Write (E );K =_aeee .Sum (_bgg [:0]);return E ,nil ;};for _gecb :=0;;{E ,_dad :=_gcg (_gecb );if _dad !=nil {return nil ,_dad ;};_ef :=E [len (E )-1];_gecb ++;if _gecb >=64&&_ef <=uint8 (_gecb -32){break ;};};return K [:32],nil ;};func _gd (_aa _gf .Block )_gf .BlockMode {return (*ecbDecrypter )(_af (_aa ))};
func _bgd (_dgc []byte )([]byte ,error ){_bagg :=_ad .New ();_bagg .Write (_dgc );return _bagg .Sum (nil ),nil ;};func (_cg *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cg ._eda !=0{_ee .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ee .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cg ._ga .Encrypt (dst ,src [:_cg ._eda ]);src =src [_cg ._eda :];dst =dst [_cg ._eda :];};};const _cd ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";
func (_c *ecbEncrypter )BlockSize ()int {return _c ._eda };

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func _dc (_fg _gf .Block )_gf .BlockMode {return (*ecbEncrypter )(_af (_fg ))};var _ StdHandler =stdHandlerR6 {};func (_gfc stdHandlerR4 )alg2 (_dge *StdEncryptDict ,_ecb []byte )[]byte {_ee .Log .Trace ("\u0061\u006c\u0067\u0032");
_fb :=_gfc .paddedPass (_ecb );_fdc :=_fd .New ();_fdc .Write (_fb );_fdc .Write (_dge .O );var _afg [4]byte ;_f .LittleEndian .PutUint32 (_afg [:],uint32 (_dge .P ));_fdc .Write (_afg [:]);_ee .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_afg );
_fdc .Write ([]byte (_gfc .ID0 ));_ee .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_dge .R ,_dge .EncryptMetadata );
if (_dge .R >=4)&&!_dge .EncryptMetadata {_fdc .Write ([]byte {0xff,0xff,0xff,0xff});};_gag :=_fdc .Sum (nil );if _dge .R >=3{_fdc =_fd .New ();for _fag :=0;_fag < 50;_fag ++{_fdc .Reset ();_fdc .Write (_gag [0:_gfc .Length /8]);_gag =_fdc .Sum (nil );
};};if _dge .R >=3{return _gag [0:_gfc .Length /8];};return _gag [0:5];};func _ac (_ba ,_gc string ,_ade int ,_edb []byte )error {if len (_edb )< _ade {return errInvalidField {Func :_ba ,Field :_gc ,Exp :_ade ,Got :len (_edb )};};return nil ;};func (_cf stdHandlerR6 )alg2a (_edd *StdEncryptDict ,_cga []byte )([]byte ,Permissions ,error ){if _cb :=_ac ("\u0061\u006c\u00672\u0061","\u004f",48,_edd .O );
_cb !=nil {return nil ,0,_cb ;};if _bbf :=_ac ("\u0061\u006c\u00672\u0061","\u0055",48,_edd .U );_bbf !=nil {return nil ,0,_bbf ;};if len (_cga )> 127{_cga =_cga [:127];};_bgf ,_cgge :=_cf .alg12 (_edd ,_cga );if _cgge !=nil {return nil ,0,_cgge ;};var (_bdde []byte ;
_fdg []byte ;_cff []byte ;);var _gfb Permissions ;if len (_bgf )!=0{_gfb =PermOwner ;_bea :=make ([]byte ,len (_cga )+8+48);_bag :=copy (_bea ,_cga );_bag +=copy (_bea [_bag :],_edd .O [40:48]);copy (_bea [_bag :],_edd .U [0:48]);_bdde =_bea ;_fdg =_edd .OE ;
_cff =_edd .U [0:48];}else {_bgf ,_cgge =_cf .alg11 (_edd ,_cga );if _cgge ==nil &&len (_bgf )==0{_bgf ,_cgge =_cf .alg11 (_edd ,[]byte (""));};if _cgge !=nil {return nil ,0,_cgge ;}else if len (_bgf )==0{return nil ,0,nil ;};_gfb =_edd .P ;_geab :=make ([]byte ,len (_cga )+8);
_bgad :=copy (_geab ,_cga );copy (_geab [_bgad :],_edd .U [40:48]);_bdde =_geab ;_fdg =_edd .UE ;_cff =nil ;};if _ege :=_ac ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_fdg );_ege !=nil {return nil ,0,_ege ;};_fdg =_fdg [:32];_abb ,_cgge :=_cf .alg2b (_edd .R ,_bdde ,_cga ,_cff );
if _cgge !=nil {return nil ,0,_cgge ;};_ecbd ,_cgge :=_eb .NewCipher (_abb [:32]);if _cgge !=nil {return nil ,0,_cgge ;};_dbg :=make ([]byte ,_eb .BlockSize );_bc :=_gf .NewCBCDecrypter (_ecbd ,_dbg );_gef :=make ([]byte ,32);_bc .CryptBlocks (_gef ,_fdg );
if _edd .R ==5{return _gef ,_gfb ,nil ;};_cgge =_cf .alg13 (_edd ,_gef );if _cgge !=nil {return nil ,0,_cgge ;};return _gef ,_gfb ,nil ;};func (_ebf stdHandlerR6 )alg8 (_geb *StdEncryptDict ,_bfg []byte ,_bfe []byte )error {if _eac :=_ac ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_bfg );
_eac !=nil {return _eac ;};var _bgda [16]byte ;if _ ,_bgb :=_e .ReadFull (_ebe .Reader ,_bgda [:]);_bgb !=nil {return _bgb ;};_fed :=_bgda [0:8];_gfd :=_bgda [8:16];_eef :=make ([]byte ,len (_bfe )+len (_fed ));_cbd :=copy (_eef ,_bfe );copy (_eef [_cbd :],_fed );
_gdb ,_cbb :=_ebf .alg2b (_geb .R ,_eef ,_bfe ,nil );if _cbb !=nil {return _cbb ;};U :=make ([]byte ,len (_gdb )+len (_fed )+len (_gfd ));_cbd =copy (U ,_gdb [:32]);_cbd +=copy (U [_cbd :],_fed );copy (U [_cbd :],_gfd );_geb .U =U ;_cbd =len (_bfe );copy (_eef [_cbd :],_gfd );
_gdb ,_cbb =_ebf .alg2b (_geb .R ,_eef ,_bfe ,nil );if _cbb !=nil {return _cbb ;};_cdb ,_cbb :=_deab (_gdb [:32]);if _cbb !=nil {return _cbb ;};_eff :=make ([]byte ,_eb .BlockSize );_cba :=_gf .NewCBCEncrypter (_cdb ,_eff );UE :=make ([]byte ,32);_cba .CryptBlocks (UE ,_bfg [:32]);
_geb .UE =UE ;return nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_dec *StdEncryptDict ,_fa ,_dg []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_fae *StdEncryptDict ,_ge []byte )([]byte ,Permissions ,error );};func (_acc errInvalidField )Error ()string {return _ed .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_acc .Func ,_acc .Field ,_acc .Exp ,_acc .Got );
};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_dba stdHandlerR4 )alg6 (_ag *StdEncryptDict ,_fgd []byte )([]byte ,error ){var (_abc []byte ;_bge error ;);_fab :=_dba .alg2 (_ag ,_fgd );if _ag .R ==2{_abc ,_bge =_dba .alg4 (_fab ,_fgd );}else if _ag .R >=3{_abc ,_bge =_dba .alg5 (_fab ,_fgd );
}else {return nil ,_eg .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _bge !=nil {return nil ,_bge ;};_ee .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_abc ),string (_ag .U ));
_geaa :=_abc ;_def :=_ag .U ;if _ag .R >=3{if len (_geaa )> 16{_geaa =_geaa [0:16];};if len (_def )> 16{_def =_def [0:16];};};if !_db .Equal (_geaa ,_def ){return nil ,nil ;};return _fab ,nil ;};