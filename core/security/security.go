//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_dd "bytes";_be "crypto/aes";_g "crypto/cipher";_da "crypto/md5";_ed "crypto/rand";_ec "crypto/rc4";_eg "crypto/sha256";_e "crypto/sha512";_ef "encoding/binary";_db "errors";_fe "fmt";_ff "github.com/unidoc/unipdf/v3/common";_d "hash";
_b "io";_bed "math";);func (_bedb stdHandlerR6 )alg10 (_cfb *StdEncryptDict ,_bgc []byte )error {if _fbg :=_efd ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_bgc );_fbg !=nil {return _fbg ;};_ebd :=uint64 (uint32 (_cfb .P ))|(_bed .MaxUint32 <<32);
Perms :=make ([]byte ,16);_ef .LittleEndian .PutUint64 (Perms [:8],_ebd );if _cfb .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_dbdb :=_b .ReadFull (_ed .Reader ,Perms [12:16]);_dbdb !=nil {return _dbdb ;
};_begf ,_abf :=_fdae (_bgc [:32]);if _abf !=nil {return _abf ;};_fcg :=_c (_begf );_fcg .CryptBlocks (Perms ,Perms );_cfb .Perms =Perms [:16];return nil ;};func (_bea *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_bea ._beb !=0{_ff .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ff .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_bea ._dad .Encrypt (dst ,src [:_bea ._beb ]);src =src [_bea ._beb :];dst =dst [_bea ._beb :];};};func (_aacg stdHandlerR6 )alg13 (_cgc *StdEncryptDict ,_eead []byte )error {if _bcd :=_efd ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_eead );
_bcd !=nil {return _bcd ;};if _fddc :=_efd ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_cgc .Perms );_fddc !=nil {return _fddc ;};_bacg :=make ([]byte ,16);copy (_bacg ,_cgc .Perms [:16]);_bgbe ,_cec :=_be .NewCipher (_eead [:32]);if _cec !=nil {return _cec ;
};_ggg :=_fb (_bgbe );_ggg .CryptBlocks (_bacg ,_bacg );if !_dd .Equal (_bacg [9:12],[]byte ("\u0061\u0064\u0062")){return _db .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_bdff :=Permissions (_ef .LittleEndian .Uint32 (_bacg [0:4]));if _bdff !=_cgc .P {return _db .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _ebg bool ;if _bacg [8]=='T'{_ebg =true ;}else if _bacg [8]=='F'{_ebg =false ;}else {return _db .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _ebg !=_cgc .EncryptMetadata {return _db .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};var _ StdHandler =stdHandlerR4 {};func (_gae stdHandlerR6 )alg2a (_dbca *StdEncryptDict ,_gdgg []byte )([]byte ,Permissions ,error ){if _dfb :=_efd ("\u0061\u006c\u00672\u0061","\u004f",48,_dbca .O );_dfb !=nil {return nil ,0,_dfb ;};if _bc :=_efd ("\u0061\u006c\u00672\u0061","\u0055",48,_dbca .U );
_bc !=nil {return nil ,0,_bc ;};if len (_gdgg )> 127{_gdgg =_gdgg [:127];};_eaa ,_eb :=_gae .alg12 (_dbca ,_gdgg );if _eb !=nil {return nil ,0,_eb ;};var (_gbgb []byte ;_abb []byte ;_cga []byte ;);var _eag Permissions ;if len (_eaa )!=0{_eag =PermOwner ;
_faf :=make ([]byte ,len (_gdgg )+8+48);_bfd :=copy (_faf ,_gdgg );_bfd +=copy (_faf [_bfd :],_dbca .O [40:48]);copy (_faf [_bfd :],_dbca .U [0:48]);_gbgb =_faf ;_abb =_dbca .OE ;_cga =_dbca .U [0:48];}else {_eaa ,_eb =_gae .alg11 (_dbca ,_gdgg );if _eb ==nil &&len (_eaa )==0{_eaa ,_eb =_gae .alg11 (_dbca ,[]byte (""));
};if _eb !=nil {return nil ,0,_eb ;}else if len (_eaa )==0{return nil ,0,nil ;};_eag =_dbca .P ;_effb :=make ([]byte ,len (_gdgg )+8);_cac :=copy (_effb ,_gdgg );copy (_effb [_cac :],_dbca .U [40:48]);_gbgb =_effb ;_abb =_dbca .UE ;_cga =nil ;};if _dfd :=_efd ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_abb );
_dfd !=nil {return nil ,0,_dfd ;};_abb =_abb [:32];_bff ,_eb :=_gae .alg2b (_dbca .R ,_gbgb ,_gdgg ,_cga );if _eb !=nil {return nil ,0,_eb ;};_bgf ,_eb :=_be .NewCipher (_bff [:32]);if _eb !=nil {return nil ,0,_eb ;};_geb :=make ([]byte ,_be .BlockSize );
_gcc :=_g .NewCBCDecrypter (_bgf ,_geb );_fgf :=make ([]byte ,32);_gcc .CryptBlocks (_fgf ,_abb );if _dbca .R ==5{return _fgf ,_eag ,nil ;};_eb =_gae .alg13 (_dbca ,_fgf );if _eb !=nil {return nil ,0,_eb ;};return _fgf ,_eag ,nil ;};func (_ged stdHandlerR4 )alg3Key (R int ,_fc []byte )[]byte {_eda :=_da .New ();
_fa :=_ged .paddedPass (_fc );_eda .Write (_fa );if R >=3{for _ggb :=0;_ggb < 50;_ggb ++{_cd :=_eda .Sum (nil );_eda =_da .New ();_eda .Write (_cd );};};_ecg :=_eda .Sum (nil );if R ==2{_ecg =_ecg [0:5];}else {_ecg =_ecg [0:_ged .Length /8];};return _ecg ;
};func _dde (_agbg ,_ggc ,_bfdg []byte )([]byte ,error ){var (_gbc ,_bac ,_gdgge _d .Hash ;);_gbc =_eg .New ();_gafb :=make ([]byte ,64);_abec :=_gbc ;_abec .Write (_agbg );K :=_abec .Sum (_gafb [:0]);_cde :=make ([]byte ,64*(127+64+48));_bdc :=func (_cae int )([]byte ,error ){_ace :=len (_ggc )+len (K )+len (_bfdg );
_ecb :=_cde [:_ace ];_bgb :=copy (_ecb ,_ggc );_bgb +=copy (_ecb [_bgb :],K [:]);_bgb +=copy (_ecb [_bgb :],_bfdg );if _bgb !=_ace {_ff .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_db .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_cde [:_ace *64];_dbd (K1 ,_ace );_egb ,_abc :=_fdae (K [0:16]);if _abc !=nil {return nil ,_abc ;};_fea :=_g .NewCBCEncrypter (_egb ,K [16:32]);_fea .CryptBlocks (K1 ,K1 );
E :=K1 ;_fbf :=0;for _abef :=0;_abef < 16;_abef ++{_fbf +=int (E [_abef ]%3);};var _bbd _d .Hash ;switch _fbf %3{case 0:_bbd =_gbc ;case 1:if _bac ==nil {_bac =_e .New384 ();};_bbd =_bac ;case 2:if _gdgge ==nil {_gdgge =_e .New ();};_bbd =_gdgge ;};_bbd .Reset ();
_bbd .Write (E );K =_bbd .Sum (_gafb [:0]);return E ,nil ;};for _cfef :=0;;{E ,_dab :=_bdc (_cfef );if _dab !=nil {return nil ,_dab ;};_edf :=E [len (E )-1];_cfef ++;if _cfef >=64&&_edf <=uint8 (_cfef -32){break ;};};return K [:32],nil ;};func (_af stdHandlerR4 )alg5 (_ab []byte ,_de []byte )([]byte ,error ){_abg :=_da .New ();
_abg .Write ([]byte (_gd ));_abg .Write ([]byte (_af .ID0 ));_eec :=_abg .Sum (nil );_ff .Log .Trace ("\u0061\u006c\u0067\u0035");_ff .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_ab );_ff .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_af .ID0 );
if len (_eec )!=16{return nil ,_db .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_ag ,_dgb :=_ec .NewCipher (_ab );if _dgb !=nil {return nil ,_db .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bdf :=make ([]byte ,16);_ag .XORKeyStream (_bdf ,_eec );_cdbd :=make ([]byte ,len (_ab ));for _ca :=0;_ca < 19;_ca ++{for _cge :=0;_cge < len (_ab );_cge ++{_cdbd [_cge ]=_ab [_cge ]^byte (_ca +1);};_ag ,_dgb =_ec .NewCipher (_cdbd );if _dgb !=nil {return nil ,_db .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ag .XORKeyStream (_bdf ,_bdf );_ff .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ca ,_cdbd );_ff .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ca ,_bdf );
};_ega :=make ([]byte ,32);for _abd :=0;_abd < 16;_abd ++{_ega [_abd ]=_bdf [_abd ];};_ ,_dgb =_ed .Read (_ega [16:32]);if _dgb !=nil {return nil ,_db .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _ega ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func _c (_bf _g .Block )_g .BlockMode {return (*ecbEncrypter )(_ge (_bf ))};
const _gd ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_cag stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_bbdd :=make ([]byte ,32);if _ ,_geg :=_b .ReadFull (_ed .Reader ,_bbdd );_geg !=nil {return nil ,_geg ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _eage :=_cag .alg8 (d ,_bbdd ,upass );_eage !=nil {return nil ,_eage ;};if _abcbe :=_cag .alg9 (d ,_bbdd ,opass );_abcbe !=nil {return nil ,_abcbe ;};if d .R ==5{return _bbdd ,nil ;
};if _fgd :=_cag .alg10 (d ,_bbdd );_fgd !=nil {return nil ,_fgd ;};return _bbdd ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_aec stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_aeb :=_aec .alg3 (d .R ,upass ,opass );if _aeb !=nil {_ff .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aeb );
return nil ,_aeb ;};d .O =O ;_ff .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_fdd :=_aec .alg2 (d ,upass );U ,_aeb :=_aec .alg5 (_fdd ,upass );if _aeb !=nil {_ff .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aeb );
return nil ,_aeb ;};d .U =U ;_ff .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _fdd ,nil ;};func (_deg stdHandlerR4 )alg6 (_bge *StdEncryptDict ,_bdd []byte )([]byte ,error ){var (_cbb []byte ;_aeg error ;);_cbf :=_deg .alg2 (_bge ,_bdd );
if _bge .R ==2{_cbb ,_aeg =_deg .alg4 (_cbf ,_bdd );}else if _bge .R >=3{_cbb ,_aeg =_deg .alg5 (_cbf ,_bdd );}else {return nil ,_db .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _aeg !=nil {return nil ,_aeg ;};_ff .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_cbb ),string (_bge .U ));
_ce :=_cbb ;_gbg :=_bge .U ;if _bge .R >=3{if len (_ce )> 16{_ce =_ce [0:16];};if len (_gbg )> 16{_gbg =_gbg [0:16];};};if !_dd .Equal (_ce ,_gbg ){return nil ,nil ;};return _cbf ,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func _fb (_bb _g .Block )_g .BlockMode {return (*ecbDecrypter )(_ge (_bb ))};func _agb (_fgc []byte )([]byte ,error ){_fff :=_eg .New ();_fff .Write (_fgc );return _fff .Sum (nil ),nil ;};type ecbDecrypter ecb ;


// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;type stdHandlerR4 struct{Length int ;ID0 string ;};func (_fec stdHandlerR6 )alg2b (R int ,_cbc ,_gca ,_gbb []byte )([]byte ,error ){if R ==5{return _agb (_cbc );};return _dde (_cbc ,_gca ,_gbb );};func (_beg stdHandlerR6 )alg9 (_gafe *StdEncryptDict ,_egc []byte ,_ebb []byte )error {if _ecde :=_efd ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_egc );
_ecde !=nil {return _ecde ;};if _cdd :=_efd ("\u0061\u006c\u0067\u0039","\u0055",48,_gafe .U );_cdd !=nil {return _cdd ;};var _dbg [16]byte ;if _ ,_cbe :=_b .ReadFull (_ed .Reader ,_dbg [:]);_cbe !=nil {return _cbe ;};_eca :=_dbg [0:8];_dga :=_dbg [8:16];
_aacf :=_gafe .U [:48];_bce :=make ([]byte ,len (_ebb )+len (_eca )+len (_aacf ));_bgd :=copy (_bce ,_ebb );_bgd +=copy (_bce [_bgd :],_eca );_bgd +=copy (_bce [_bgd :],_aacf );_gab ,_daf :=_beg .alg2b (_gafe .R ,_bce ,_ebb ,_aacf );if _daf !=nil {return _daf ;
};O :=make ([]byte ,len (_gab )+len (_eca )+len (_dga ));_bgd =copy (O ,_gab [:32]);_bgd +=copy (O [_bgd :],_eca );_bgd +=copy (O [_bgd :],_dga );_gafe .O =O ;_bgd =len (_ebb );_bgd +=copy (_bce [_bgd :],_dga );_gab ,_daf =_beg .alg2b (_gafe .R ,_bce ,_ebb ,_aacf );
if _daf !=nil {return _daf ;};_afb ,_daf :=_fdae (_gab [:32]);if _daf !=nil {return _daf ;};_dafc :=make ([]byte ,_be .BlockSize );_cafc :=_g .NewCBCEncrypter (_afb ,_dafc );OE :=make ([]byte ,32);_cafc .CryptBlocks (OE ,_egc [:32]);_gafe .OE =OE ;return nil ;
};

// Authenticate implements StdHandler interface.
func (_ede stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ff .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_agc ,_gfb :=_ede .alg7 (d ,pass );if _gfb !=nil {return nil ,0,_gfb ;};if _agc !=nil {_ff .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _agc ,PermOwner ,nil ;
};_ff .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_agc ,_gfb =_ede .alg6 (d ,pass );if _gfb !=nil {return nil ,0,_gfb ;
};if _agc !=nil {_ff .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _agc ,d .P ,nil ;};return nil ,0,nil ;};type ecb struct{_dad _g .Block ;_beb int ;};type ecbEncrypter ecb ;
func _fdae (_ecd []byte )(_g .Block ,error ){_abea ,_gaa :=_be .NewCipher (_ecd );if _gaa !=nil {_ff .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_gaa );
return nil ,_gaa ;};return _abea ,nil ;};func (_egad stdHandlerR6 )alg8 (_ebe *StdEncryptDict ,_abcb []byte ,_fafb []byte )error {if _dfeg :=_efd ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_abcb );_dfeg !=nil {return _dfeg ;};var _bec [16]byte ;
if _ ,_becf :=_b .ReadFull (_ed .Reader ,_bec [:]);_becf !=nil {return _becf ;};_bef :=_bec [0:8];_bdb :=_bec [8:16];_dded :=make ([]byte ,len (_fafb )+len (_bef ));_adb :=copy (_dded ,_fafb );copy (_dded [_adb :],_bef );_gbcb ,_fddf :=_egad .alg2b (_ebe .R ,_dded ,_fafb ,nil );
if _fddf !=nil {return _fddf ;};U :=make ([]byte ,len (_gbcb )+len (_bef )+len (_bdb ));_adb =copy (U ,_gbcb [:32]);_adb +=copy (U [_adb :],_bef );copy (U [_adb :],_bdb );_ebe .U =U ;_adb =len (_fafb );copy (_dded [_adb :],_bdb );_gbcb ,_fddf =_egad .alg2b (_ebe .R ,_dded ,_fafb ,nil );
if _fddf !=nil {return _fddf ;};_bga ,_fddf :=_fdae (_gbcb [:32]);if _fddf !=nil {return _fddf ;};_acc :=make ([]byte ,_be .BlockSize );_ecf :=_g .NewCBCEncrypter (_bga ,_acc );UE :=make ([]byte ,32);_ecf .CryptBlocks (UE ,_abcb [:32]);_ebe .UE =UE ;return nil ;
};func (_gg stdHandlerR4 )alg2 (_aca *StdEncryptDict ,_bag []byte )[]byte {_ff .Log .Trace ("\u0061\u006c\u0067\u0032");_cfe :=_gg .paddedPass (_bag );_dag :=_da .New ();_dag .Write (_cfe );_dag .Write (_aca .O );var _fg [4]byte ;_ef .LittleEndian .PutUint32 (_fg [:],uint32 (_aca .P ));
_dag .Write (_fg [:]);_ff .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_fg );_dag .Write ([]byte (_gg .ID0 ));_ff .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_aca .R ,_aca .EncryptMetadata );
if (_aca .R >=4)&&!_aca .EncryptMetadata {_dag .Write ([]byte {0xff,0xff,0xff,0xff});};_ea :=_dag .Sum (nil );if _aca .R >=3{_dag =_da .New ();for _cff :=0;_cff < 50;_cff ++{_dag .Reset ();_dag .Write (_ea [0:_gg .Length /8]);_ea =_dag .Sum (nil );};};
if _aca .R >=3{return _ea [0:_gg .Length /8];};return _ea [0:5];};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func _ge (_bee _g .Block )*ecb {return &ecb {_dad :_bee ,_beb :_bee .BlockSize ()}};

// Allowed checks if a set of permissions can be granted.
func (_cg Permissions )Allowed (p2 Permissions )bool {return _cg &p2 ==p2 };func (_acd errInvalidField )Error ()string {return _fe .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_acd .Func ,_acd .Field ,_acd .Exp ,_acd .Got );
};

// Authenticate implements StdHandler interface.
func (_gdga stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _gdga .alg2a (d ,pass );};func (_fag stdHandlerR4 )alg4 (_gc []byte ,_fd []byte )([]byte ,error ){_edb ,_bbe :=_ec .NewCipher (_gc );if _bbe !=nil {return nil ,_db .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_gad :=[]byte (_gd );_gdd :=make ([]byte ,len (_gad ));_edb .XORKeyStream (_gdd ,_gad );return _gdd ,nil ;};func (_a *ecbEncrypter )BlockSize ()int {return _a ._beb };func (_abda stdHandlerR4 )alg7 (_cc *StdEncryptDict ,_aac []byte )([]byte ,error ){_caf :=_abda .alg3Key (_cc .R ,_aac );
_dgf :=make ([]byte ,len (_cc .O ));if _cc .R ==2{_dbc ,_gba :=_ec .NewCipher (_caf );if _gba !=nil {return nil ,_db .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_dbc .XORKeyStream (_dgf ,_cc .O );}else if _cc .R >=3{_abe :=append ([]byte {},_cc .O ...);
for _gac :=0;_gac < 20;_gac ++{_dea :=append ([]byte {},_caf ...);for _cfa :=0;_cfa < len (_caf );_cfa ++{_dea [_cfa ]^=byte (19-_gac );};_efe ,_dec :=_ec .NewCipher (_dea );if _dec !=nil {return nil ,_db .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_efe .XORKeyStream (_dgf ,_abe );_abe =append ([]byte {},_dgf ...);};}else {return nil ,_db .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_fda ,_ccc :=_abda .alg6 (_cc ,_dgf );if _ccc !=nil {return nil ,nil ;};return _fda ,nil ;};func (_dgaa stdHandlerR6 )alg12 (_fafc *StdEncryptDict ,_cba []byte )([]byte ,error ){if _eecf :=_efd ("\u0061\u006c\u00671\u0032","\u0055",48,_fafc .U );
_eecf !=nil {return nil ,_eecf ;};if _cgaf :=_efd ("\u0061\u006c\u00671\u0032","\u004f",48,_fafc .O );_cgaf !=nil {return nil ,_cgaf ;};_gddb :=make ([]byte ,len (_cba )+8+48);_fge :=copy (_gddb ,_cba );_fge +=copy (_gddb [_fge :],_fafc .O [32:40]);_fge +=copy (_gddb [_fge :],_fafc .U [0:48]);
_bfg ,_efg :=_dgaa .alg2b (_fafc .R ,_gddb ,_cba ,_fafc .U [0:48]);if _efg !=nil {return nil ,_efg ;};_bfg =_bfg [:32];if !_dd .Equal (_bfg ,_fafc .O [:32]){return nil ,nil ;};return _bfg ,nil ;};type stdHandlerR6 struct{};func (_df stdHandlerR4 )alg3 (R int ,_eff ,_ad []byte )([]byte ,error ){var _fed []byte ;
if len (_ad )> 0{_fed =_df .alg3Key (R ,_ad );}else {_fed =_df .alg3Key (R ,_eff );};_egg ,_ee :=_ec .NewCipher (_fed );if _ee !=nil {return nil ,_db .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cdb :=_df .paddedPass (_eff );
_bfb :=make ([]byte ,len (_cdb ));_egg .XORKeyStream (_bfb ,_cdb );if R >=3{_eea :=make ([]byte ,len (_fed ));for _gf :=0;_gf < 19;_gf ++{for _aef :=0;_aef < len (_fed );_aef ++{_eea [_aef ]=_fed [_aef ]^byte (_gf +1);};_gaf ,_dfe :=_ec .NewCipher (_eea );
if _dfe !=nil {return nil ,_db .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gaf .XORKeyStream (_bfb ,_bfb );};};return _bfb ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");
EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (stdHandlerR4 )paddedPass (_aaa []byte )[]byte {_ba :=make ([]byte ,32);_cfd :=copy (_ba ,_aaa );for ;_cfd < 32;_cfd ++{_ba [_cfd ]=_gd [_cfd -len (_aaa )];};return _ba ;};const (PermOwner =Permissions (_bed .MaxUint32 );
PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11);
);var _ StdHandler =stdHandlerR6 {};func _dbd (_edc []byte ,_gcca int ){_adc :=_gcca ;for _adc < len (_edc ){copy (_edc [_adc :],_edc [:_adc ]);_adc *=2;};};func (_fef stdHandlerR6 )alg11 (_gbbf *StdEncryptDict ,_fgb []byte )([]byte ,error ){if _dcc :=_efd ("\u0061\u006c\u00671\u0031","\u0055",48,_gbbf .U );
_dcc !=nil {return nil ,_dcc ;};_dbcb :=make ([]byte ,len (_fgb )+8);_cgeg :=copy (_dbcb ,_fgb );_cgeg +=copy (_dbcb [_cgeg :],_gbbf .U [32:40]);_ffb ,_edbc :=_fef .alg2b (_gbbf .R ,_dbcb ,_fgb ,nil );if _edbc !=nil {return nil ,_edbc ;};_ffb =_ffb [:32];
if !_dd .Equal (_ffb ,_gbbf .U [:32]){return nil ,nil ;};return _ffb ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_cb *StdEncryptDict ,_ga ,_dc []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_dg *StdEncryptDict ,_gb []byte )([]byte ,Permissions ,error );};func (_ae *ecbDecrypter )BlockSize ()int {return _ae ._beb };

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_cf *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cf ._beb !=0{_ff .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ff .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cf ._dad .Decrypt (dst ,src [:_cf ._beb ]);src =src [_cf ._beb :];dst =dst [_cf ._beb :];};};func _efd (_ac ,_bd string ,_bg int ,_aee []byte )error {if len (_aee )< _bg {return errInvalidField {Func :_ac ,Field :_bd ,Exp :_bg ,Got :len (_aee )};
};return nil ;};