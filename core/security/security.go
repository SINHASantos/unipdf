//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_bb "bytes";_g "crypto/aes";_a "crypto/cipher";_dg "crypto/md5";_eb "crypto/rand";_ae "crypto/rc4";_b "crypto/sha256";_af "crypto/sha512";_d "encoding/binary";_gf "errors";_ce "fmt";_be "github.com/unidoc/unipdf/v3/common";_cf "hash";
_c "io";_aa "math";);

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_bag stdHandlerR6 )alg10 (_abd *StdEncryptDict ,_geae []byte )error {if _bef :=_aee ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_geae );
_bef !=nil {return _bef ;};_dfg :=uint64 (uint32 (_abd .P ))|(_aa .MaxUint32 <<32);Perms :=make ([]byte ,16);_d .LittleEndian .PutUint64 (Perms [:8],_dfg );if _abd .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_daf :=_c .ReadFull (_eb .Reader ,Perms [12:16]);_daf !=nil {return _daf ;};_cfag ,_fceg :=_ccg (_geae [:32]);if _fceg !=nil {return _fceg ;};_cbc :=_dd (_cfag );_cbc .CryptBlocks (Perms ,Perms );_abd .Perms =Perms [:16];return nil ;};func _adfd (_bed ,_dff ,_adb []byte )([]byte ,error ){var (_fbc ,_fced ,_fad _cf .Hash ;
);_fbc =_b .New ();_gea :=make ([]byte ,64);_dddc :=_fbc ;_dddc .Write (_bed );K :=_dddc .Sum (_gea [:0]);_ecg :=make ([]byte ,64*(127+64+48));_cbdg :=func (_aff int )([]byte ,error ){_cae :=len (_dff )+len (K )+len (_adb );_ag :=_ecg [:_cae ];_gff :=copy (_ag ,_dff );
_gff +=copy (_ag [_gff :],K [:]);_gff +=copy (_ag [_gff :],_adb );if _gff !=_cae {_be .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_gf .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_ecg [:_cae *64];_fba (K1 ,_cae );_aad ,_dfc :=_ccg (K [0:16]);if _dfc !=nil {return nil ,_dfc ;};_ced :=_a .NewCBCEncrypter (_aad ,K [16:32]);_ced .CryptBlocks (K1 ,K1 );
E :=K1 ;_eaa :=0;for _gfe :=0;_gfe < 16;_gfe ++{_eaa +=int (E [_gfe ]%3);};var _dcgf _cf .Hash ;switch _eaa %3{case 0:_dcgf =_fbc ;case 1:if _fced ==nil {_fced =_af .New384 ();};_dcgf =_fced ;case 2:if _fad ==nil {_fad =_af .New ();};_dcgf =_fad ;};_dcgf .Reset ();
_dcgf .Write (E );K =_dcgf .Sum (_gea [:0]);return E ,nil ;};for _ega :=0;;{E ,_cbe :=_cbdg (_ega );if _cbe !=nil {return nil ,_cbe ;};_bece :=E [len (E )-1];_ega ++;if _ega >=64&&_bece <=uint8 (_ega -32){break ;};};return K [:32],nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_aaf stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_egd :=make ([]byte ,32);if _ ,_ebcb :=_c .ReadFull (_eb .Reader ,_egd );_ebcb !=nil {return nil ,_ebcb ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _bee :=_aaf .alg8 (d ,_egd ,upass );_bee !=nil {return nil ,_bee ;};if _cff :=_aaf .alg9 (d ,_egd ,opass );_cff !=nil {return nil ,_cff ;};if d .R ==5{return _egd ,nil ;
};if _acgf :=_aaf .alg10 (d ,_egd );_acgf !=nil {return nil ,_acgf ;};return _egd ,nil ;};type ecbEncrypter ecb ;

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_dfa stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_egg :=_dfa .alg3 (d .R ,upass ,opass );if _egg !=nil {_be .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_egg );
return nil ,_egg ;};d .O =O ;_be .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_bgfa :=_dfa .alg2 (d ,upass );U ,_egg :=_dfa .alg5 (_bgfa ,upass );if _egg !=nil {_be .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_egg );
return nil ,_egg ;};d .U =U ;_be .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _bgfa ,nil ;};func (_cce stdHandlerR6 )alg12 (_aab *StdEncryptDict ,_acg []byte )([]byte ,error ){if _cgb :=_aee ("\u0061\u006c\u00671\u0032","\u0055",48,_aab .U );
_cgb !=nil {return nil ,_cgb ;};if _cgf :=_aee ("\u0061\u006c\u00671\u0032","\u004f",48,_aab .O );_cgf !=nil {return nil ,_cgf ;};_ecgb :=make ([]byte ,len (_acg )+8+48);_fbcb :=copy (_ecgb ,_acg );_fbcb +=copy (_ecgb [_fbcb :],_aab .O [32:40]);_fbcb +=copy (_ecgb [_fbcb :],_aab .U [0:48]);
_bbfc ,_bfd :=_cce .alg2b (_aab .R ,_ecgb ,_acg ,_aab .U [0:48]);if _bfd !=nil {return nil ,_bfd ;};_bbfc =_bbfc [:32];if !_bb .Equal (_bbfc ,_aab .O [:32]){return nil ,nil ;};return _bbfc ,nil ;};func (_fdf stdHandlerR4 )alg6 (_eeeb *StdEncryptDict ,_dgg []byte )([]byte ,error ){var (_acf []byte ;
_cfgc error ;);_afa :=_fdf .alg2 (_eeeb ,_dgg );if _eeeb .R ==2{_acf ,_cfgc =_fdf .alg4 (_afa ,_dgg );}else if _eeeb .R >=3{_acf ,_cfgc =_fdf .alg5 (_afa ,_dgg );}else {return nil ,_gf .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _cfgc !=nil {return nil ,_cfgc ;
};_be .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_acf ),string (_eeeb .U ));_bc :=_acf ;_cda :=_eeeb .U ;if _eeeb .R >=3{if len (_bc )> 16{_bc =_bc [0:16];};if len (_cda )> 16{_cda =_cda [0:16];
};};if !_bb .Equal (_bc ,_cda ){return nil ,nil ;};return _afa ,nil ;};var _ StdHandler =stdHandlerR6 {};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_bbd stdHandlerR4 )alg2 (_dgfd *StdEncryptDict ,_cfg []byte )[]byte {_be .Log .Trace ("\u0061\u006c\u0067\u0032");
_ac :=_bbd .paddedPass (_cfg );_gga :=_dg .New ();_gga .Write (_ac );_gga .Write (_dgfd .O );var _ec [4]byte ;_d .LittleEndian .PutUint32 (_ec [:],uint32 (_dgfd .P ));_gga .Write (_ec [:]);_be .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_ec );
_gga .Write ([]byte (_bbd .ID0 ));_be .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_dgfd .R ,_dgfd .EncryptMetadata );
if (_dgfd .R >=4)&&!_dgfd .EncryptMetadata {_gga .Write ([]byte {0xff,0xff,0xff,0xff});};_dc :=_gga .Sum (nil );if _dgfd .R >=3{_gga =_dg .New ();for _gfcd :=0;_gfcd < 50;_gfcd ++{_gga .Reset ();_gga .Write (_dc [0:_bbd .Length /8]);_dc =_gga .Sum (nil );
};};if _dgfd .R >=3{return _dc [0:_bbd .Length /8];};return _dc [0:5];};func (_ef errInvalidField )Error ()string {return _ce .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ef .Func ,_ef .Field ,_ef .Exp ,_ef .Got );
};const (PermOwner =Permissions (_aa .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);
PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););var _ StdHandler =stdHandlerR4 {};func _ccg (_ge []byte )(_a .Block ,error ){_bca ,_bfc :=_g .NewCipher (_ge );if _bfc !=nil {_be .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bfc );
return nil ,_bfc ;};return _bca ,nil ;};type ecb struct{_beg _a .Block ;_cee int ;};type stdHandlerR4 struct{Length int ;ID0 string ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};type stdHandlerR6 struct{};func (_da *ecbEncrypter )BlockSize ()int {return _da ._cee };func _dd (_cc _a .Block )_a .BlockMode {return (*ecbEncrypter )(_f (_cc ))};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};

// Authenticate implements StdHandler interface.
func (_gfd stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_be .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_edd ,_ggd :=_gfd .alg7 (d ,pass );if _ggd !=nil {return nil ,0,_ggd ;};if _edd !=nil {_be .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _edd ,PermOwner ,nil ;
};_be .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_edd ,_ggd =_gfd .alg6 (d ,pass );if _ggd !=nil {return nil ,0,_ggd ;
};if _edd !=nil {_be .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _edd ,d .P ,nil ;};return nil ,0,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func _gg (_ee _a .Block )_a .BlockMode {return (*ecbDecrypter )(_f (_ee ))};func (_edb stdHandlerR4 )alg7 (_bec *StdEncryptDict ,_bgf []byte )([]byte ,error ){_cfge :=_edb .alg3Key (_bec .R ,_bgf );_ecc :=make ([]byte ,len (_bec .O ));
if _bec .R ==2{_abb ,_bae :=_ae .NewCipher (_cfge );if _bae !=nil {return nil ,_gf .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_abb .XORKeyStream (_ecc ,_bec .O );}else if _bec .R >=3{_adf :=append ([]byte {},_bec .O ...);
for _eec :=0;_eec < 20;_eec ++{_dbc :=append ([]byte {},_cfge ...);for _bafg :=0;_bafg < len (_cfge );_bafg ++{_dbc [_bafg ]^=byte (19-_eec );};_eba ,_dfbg :=_ae .NewCipher (_dbc );if _dfbg !=nil {return nil ,_gf .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_eba .XORKeyStream (_ecc ,_adf );_adf =append ([]byte {},_ecc ...);};}else {return nil ,_gf .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_cdd ,_bdc :=_edb .alg6 (_bec ,_ecc );if _bdc !=nil {return nil ,nil ;};return _cdd ,nil ;};func (_dca stdHandlerR6 )alg2b (R int ,_beb ,_ead ,_dec []byte )([]byte ,error ){if R ==5{return _gfcb (_beb );
};return _adfd (_beb ,_ead ,_dec );};func (_ded stdHandlerR4 )alg4 (_gb []byte ,_bea []byte )([]byte ,error ){_fg ,_cef :=_ae .NewCipher (_gb );if _cef !=nil {return nil ,_gf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ab :=[]byte (_ed );_ede :=make ([]byte ,len (_ab ));_fg .XORKeyStream (_ede ,_ab );return _ede ,nil ;};func (_dae stdHandlerR4 )alg5 (_egc []byte ,_bfb []byte )([]byte ,error ){_eea :=_dg .New ();_eea .Write ([]byte (_ed ));_eea .Write ([]byte (_dae .ID0 ));
_ebd :=_eea .Sum (nil );_be .Log .Trace ("\u0061\u006c\u0067\u0035");_be .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_egc );_be .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_dae .ID0 );if len (_ebd )!=16{return nil ,_gf .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_efa ,_fgb :=_ae .NewCipher (_egc );if _fgb !=nil {return nil ,_gf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cd :=make ([]byte ,16);_efa .XORKeyStream (_cd ,_ebd );_fa :=make ([]byte ,len (_egc ));for _dcg :=0;
_dcg < 19;_dcg ++{for _eag :=0;_eag < len (_egc );_eag ++{_fa [_eag ]=_egc [_eag ]^byte (_dcg +1);};_efa ,_fgb =_ae .NewCipher (_fa );if _fgb !=nil {return nil ,_gf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_efa .XORKeyStream (_cd ,_cd );_be .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_dcg ,_fa );_be .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_dcg ,_cd );
};_aeg :=make ([]byte ,32);for _ece :=0;_ece < 16;_ece ++{_aeg [_ece ]=_cd [_ece ];};_ ,_fgb =_eb .Read (_aeg [16:32]);if _fgb !=nil {return nil ,_gf .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _aeg ,nil ;};func (_bdba stdHandlerR6 )alg9 (_bcf *StdEncryptDict ,_caa []byte ,_aae []byte )error {if _eabd :=_aee ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_caa );_eabd !=nil {return _eabd ;};if _aegc :=_aee ("\u0061\u006c\u0067\u0039","\u0055",48,_bcf .U );
_aegc !=nil {return _aegc ;};var _ace [16]byte ;if _ ,_ggf :=_c .ReadFull (_eb .Reader ,_ace [:]);_ggf !=nil {return _ggf ;};_abf :=_ace [0:8];_def :=_ace [8:16];_bgc :=_bcf .U [:48];_bbe :=make ([]byte ,len (_aae )+len (_abf )+len (_bgc ));_gbf :=copy (_bbe ,_aae );
_gbf +=copy (_bbe [_gbf :],_abf );_gbf +=copy (_bbe [_gbf :],_bgc );_gaa ,_eeea :=_bdba .alg2b (_bcf .R ,_bbe ,_aae ,_bgc );if _eeea !=nil {return _eeea ;};O :=make ([]byte ,len (_gaa )+len (_abf )+len (_def ));_gbf =copy (O ,_gaa [:32]);_gbf +=copy (O [_gbf :],_abf );
_gbf +=copy (O [_gbf :],_def );_bcf .O =O ;_gbf =len (_aae );_gbf +=copy (_bbe [_gbf :],_def );_gaa ,_eeea =_bdba .alg2b (_bcf .R ,_bbe ,_aae ,_bgc );if _eeea !=nil {return _eeea ;};_dede ,_eeea :=_ccg (_gaa [:32]);if _eeea !=nil {return _eeea ;};_cbec :=make ([]byte ,_g .BlockSize );
_cgg :=_a .NewCBCEncrypter (_dede ,_cbec );OE :=make ([]byte ,32);_cgg .CryptBlocks (OE ,_caa [:32]);_bcf .OE =OE ;return nil ;};const _ed ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";


// Allowed checks if a set of permissions can be granted.
func (_ea Permissions )Allowed (p2 Permissions )bool {return _ea &p2 ==p2 };func _aee (_cec ,_eg string ,_ad int ,_ca []byte )error {if len (_ca )< _ad {return errInvalidField {Func :_cec ,Field :_eg ,Exp :_ad ,Got :len (_ca )};};return nil ;};func (_bf *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_bf ._cee !=0{_be .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_be .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_bf ._beg .Decrypt (dst ,src [:_bf ._cee ]);src =src [_bf ._cee :];dst =dst [_bf ._cee :];};};func (_fde *ecbDecrypter )BlockSize ()int {return _fde ._cee };

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (stdHandlerR4 )paddedPass (_dfb []byte )[]byte {_baf :=make ([]byte ,32);_cfa :=copy (_baf ,_dfb );for ;_cfa < 32;_cfa ++{_baf [_cfa ]=_ed [_cfa -len (_dfb )];
};return _baf ;};func _gfcb (_ga []byte )([]byte ,error ){_eef :=_b .New ();_eef .Write (_ga );return _eef .Sum (nil ),nil };func (_ccd stdHandlerR4 )alg3Key (R int ,_baa []byte )[]byte {_de :=_dg .New ();_ebcg :=_ccd .paddedPass (_baa );_de .Write (_ebcg );
if R >=3{for _fe :=0;_fe < 50;_fe ++{_ggc :=_de .Sum (nil );_de =_dg .New ();_de .Write (_ggc );};};_bg :=_de .Sum (nil );if R ==2{_bg =_bg [0:5];}else {_bg =_bg [0:_ccd .Length /8];};return _bg ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_df *StdEncryptDict ,_fc ,_ebc []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ff *StdEncryptDict ,_gfc []byte )([]byte ,Permissions ,error );};func (_fd *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_fd ._cee !=0{_be .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_be .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_fd ._beg .Encrypt (dst ,src [:_fd ._cee ]);src =src [_fd ._cee :];dst =dst [_fd ._cee :];};};func (_adc stdHandlerR6 )alg11 (_fcg *StdEncryptDict ,_aca []byte )([]byte ,error ){if _eeb :=_aee ("\u0061\u006c\u00671\u0031","\u0055",48,_fcg .U );
_eeb !=nil {return nil ,_eeb ;};_geaa :=make ([]byte ,len (_aca )+8);_gfdf :=copy (_geaa ,_aca );_gfdf +=copy (_geaa [_gfdf :],_fcg .U [32:40]);_cdag ,_dbb :=_adc .alg2b (_fcg .R ,_geaa ,_aca ,nil );if _dbb !=nil {return nil ,_dbb ;};_cdag =_cdag [:32];
if !_bb .Equal (_cdag ,_fcg .U [:32]){return nil ,nil ;};return _cdag ,nil ;};func _fba (_cdaa []byte ,_dge int ){_ffcf :=_dge ;for _ffcf < len (_cdaa ){copy (_cdaa [_ffcf :],_cdaa [:_ffcf ]);_ffcf *=2;};};func (_edc stdHandlerR6 )alg13 (_aef *StdEncryptDict ,_bcb []byte )error {if _cbf :=_aee ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_bcb );
_cbf !=nil {return _cbf ;};if _fff :=_aee ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_aef .Perms );_fff !=nil {return _fff ;};_dea :=make ([]byte ,16);copy (_dea ,_aef .Perms [:16]);_fedc ,_eaba :=_g .NewCipher (_bcb [:32]);if _eaba !=nil {return _eaba ;
};_dddg :=_gg (_fedc );_dddg .CryptBlocks (_dea ,_dea );if !_bb .Equal (_dea [9:12],[]byte ("\u0061\u0064\u0062")){return _gf .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_bge :=Permissions (_d .LittleEndian .Uint32 (_dea [0:4]));if _bge !=_aef .P {return _gf .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _cgc bool ;if _dea [8]=='T'{_cgc =true ;}else if _dea [8]=='F'{_cgc =false ;}else {return _gf .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _cgc !=_aef .EncryptMetadata {return _gf .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};

// Authenticate implements StdHandler interface.
func (_abc stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _abc .alg2a (d ,pass );};func _f (_ba _a .Block )*ecb {return &ecb {_beg :_ba ,_cee :_ba .BlockSize ()}};func (_bdb stdHandlerR6 )alg2a (_eab *StdEncryptDict ,_add []byte )([]byte ,Permissions ,error ){if _cb :=_aee ("\u0061\u006c\u00672\u0061","\u004f",48,_eab .O );
_cb !=nil {return nil ,0,_cb ;};if _eae :=_aee ("\u0061\u006c\u00672\u0061","\u0055",48,_eab .U );_eae !=nil {return nil ,0,_eae ;};if len (_add )> 127{_add =_add [:127];};_dce ,_dab :=_bdb .alg12 (_eab ,_add );if _dab !=nil {return nil ,0,_dab ;};var (_afg []byte ;
_cab []byte ;_fb []byte ;);var _bbf Permissions ;if len (_dce )!=0{_bbf =PermOwner ;_ebe :=make ([]byte ,len (_add )+8+48);_begb :=copy (_ebe ,_add );_begb +=copy (_ebe [_begb :],_eab .O [40:48]);copy (_ebe [_begb :],_eab .U [0:48]);_afg =_ebe ;_cab =_eab .OE ;
_fb =_eab .U [0:48];}else {_dce ,_dab =_bdb .alg11 (_eab ,_add );if _dab ==nil &&len (_dce )==0{_dce ,_dab =_bdb .alg11 (_eab ,[]byte (""));};if _dab !=nil {return nil ,0,_dab ;}else if len (_dce )==0{return nil ,0,nil ;};_bbf =_eab .P ;_cg :=make ([]byte ,len (_add )+8);
_cfc :=copy (_cg ,_add );copy (_cg [_cfc :],_eab .U [40:48]);_afg =_cg ;_cab =_eab .UE ;_fb =nil ;};if _cbd :=_aee ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_cab );_cbd !=nil {return nil ,0,_cbd ;};_cab =_cab [:32];_fcb ,_dab :=_bdb .alg2b (_eab .R ,_afg ,_add ,_fb );
if _dab !=nil {return nil ,0,_dab ;};_ffd ,_dab :=_g .NewCipher (_fcb [:32]);if _dab !=nil {return nil ,0,_dab ;};_fab :=make ([]byte ,_g .BlockSize );_dfd :=_a .NewCBCDecrypter (_ffd ,_fab );_abgc :=make ([]byte ,32);_dfd .CryptBlocks (_abgc ,_cab );if _eab .R ==5{return _abgc ,_bbf ,nil ;
};_dab =_bdb .alg13 (_eab ,_abgc );if _dab !=nil {return nil ,0,_dab ;};return _abgc ,_bbf ,nil ;};func (_ceg stdHandlerR6 )alg8 (_edf *StdEncryptDict ,_gc []byte ,_eca []byte )error {if _bab :=_aee ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_gc );
_bab !=nil {return _bab ;};var _eaef [16]byte ;if _ ,_caf :=_c .ReadFull (_eb .Reader ,_eaef [:]);_caf !=nil {return _caf ;};_agc :=_eaef [0:8];_bfcf :=_eaef [8:16];_dfdc :=make ([]byte ,len (_eca )+len (_agc ));_aed :=copy (_dfdc ,_eca );copy (_dfdc [_aed :],_agc );
_eff ,_cedc :=_ceg .alg2b (_edf .R ,_dfdc ,_eca ,nil );if _cedc !=nil {return _cedc ;};U :=make ([]byte ,len (_eff )+len (_agc )+len (_bfcf ));_aed =copy (U ,_eff [:32]);_aed +=copy (U [_aed :],_agc );copy (U [_aed :],_bfcf );_edf .U =U ;_aed =len (_eca );
copy (_dfdc [_aed :],_bfcf );_eff ,_cedc =_ceg .alg2b (_edf .R ,_dfdc ,_eca ,nil );if _cedc !=nil {return _cedc ;};_cgd ,_cedc :=_ccg (_eff [:32]);if _cedc !=nil {return _cedc ;};_ggcf :=make ([]byte ,_g .BlockSize );_ada :=_a .NewCBCEncrypter (_cgd ,_ggcf );
UE :=make ([]byte ,32);_ada .CryptBlocks (UE ,_gc [:32]);_edf .UE =UE ;return nil ;};type ecbDecrypter ecb ;func (_gd stdHandlerR4 )alg3 (R int ,_dde ,_daa []byte )([]byte ,error ){var _gde []byte ;if len (_daa )> 0{_gde =_gd .alg3Key (R ,_daa );}else {_gde =_gd .alg3Key (R ,_dde );
};_bd ,_db :=_ae .NewCipher (_gde );if _db !=nil {return nil ,_gf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eee :=_gd .paddedPass (_dde );_ffc :=make ([]byte ,len (_eee ));_bd .XORKeyStream (_ffc ,_eee );
if R >=3{_fdeb :=make ([]byte ,len (_gde ));for _fed :=0;_fed < 19;_fed ++{for _gda :=0;_gda < len (_gde );_gda ++{_fdeb [_gda ]=_gde [_gda ]^byte (_fed +1);};_ceca ,_ddd :=_ae .NewCipher (_fdeb );if _ddd !=nil {return nil ,_gf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ceca .XORKeyStream (_ffc ,_ffc );};};return _ffc ,nil ;};