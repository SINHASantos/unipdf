//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_gd "bytes";_dd "crypto/aes";_d "crypto/cipher";_f "crypto/md5";_ea "crypto/rand";_cg "crypto/rc4";_a "crypto/sha256";_df "crypto/sha512";_ce "encoding/binary";_ed "errors";_b "fmt";_dab "github.com/unidoc/unipdf/v3/common";_e "hash";
_g "io";_da "math";);func _ggb (_eee []byte ,_cbec int ){_cebc :=_cbec ;for _cebc < len (_eee ){copy (_eee [_cebc :],_eee [:_cebc ]);_cebc *=2;};};func _ff (_cec _d .Block )*ecb {return &ecb {_ag :_cec ,_cd :_cec .BlockSize ()}};func (_gc *ecbDecrypter )BlockSize ()int {return _gc ._cd };
func (_gfd stdHandlerR6 )alg8 (_acec *StdEncryptDict ,_eeef []byte ,_fec []byte )error {if _gdf :=_fc ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_eeef );_gdf !=nil {return _gdf ;};var _de [16]byte ;if _ ,_cdga :=_g .ReadFull (_ea .Reader ,_de [:]);
_cdga !=nil {return _cdga ;};_fgfe :=_de [0:8];_efe :=_de [8:16];_agca :=make ([]byte ,len (_fec )+len (_fgfe ));_cdgb :=copy (_agca ,_fec );copy (_agca [_cdgb :],_fgfe );_bde ,_bbc :=_gfd .alg2b (_acec .R ,_agca ,_fec ,nil );if _bbc !=nil {return _bbc ;
};U :=make ([]byte ,len (_bde )+len (_fgfe )+len (_efe ));_cdgb =copy (U ,_bde [:32]);_cdgb +=copy (U [_cdgb :],_fgfe );copy (U [_cdgb :],_efe );_acec .U =U ;_cdgb =len (_fec );copy (_agca [_cdgb :],_efe );_bde ,_bbc =_gfd .alg2b (_acec .R ,_agca ,_fec ,nil );
if _bbc !=nil {return _bbc ;};_afg ,_bbc :=_fgda (_bde [:32]);if _bbc !=nil {return _bbc ;};_bcgd :=make ([]byte ,_dd .BlockSize );_aba :=_d .NewCBCEncrypter (_afg ,_bcgd );UE :=make ([]byte ,32);_aba .CryptBlocks (UE ,_eeef [:32]);_acec .UE =UE ;return nil ;
};func (_fg stdHandlerR4 )alg3 (R int ,_ac ,_fgd []byte )([]byte ,error ){var _ad []byte ;if len (_fgd )> 0{_ad =_fg .alg3Key (R ,_fgd );}else {_ad =_fg .alg3Key (R ,_ac );};_cgg ,_beca :=_cg .NewCipher (_ad );if _beca !=nil {return nil ,_ed .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_gag :=_fg .paddedPass (_ac );_bgb :=make ([]byte ,len (_gag ));_cgg .XORKeyStream (_bgb ,_gag );if R >=3{_dg :=make ([]byte ,len (_ad ));for _cb :=0;_cb < 19;_cb ++{for _cee :=0;_cee < len (_ad );_cee ++{_dg [_cee ]=_ad [_cee ]^byte (_cb +1);};_bcg ,_add :=_cg .NewCipher (_dg );
if _add !=nil {return nil ,_ed .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bcg .XORKeyStream (_bgb ,_bgb );};};return _bgb ,nil ;};func (_fb *ecbEncrypter )BlockSize ()int {return _fb ._cd };

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_gcg *StdEncryptDict ,_bc ,_gg []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_bd *StdEncryptDict ,_ga []byte )([]byte ,Permissions ,error );};type ecbDecrypter ecb ;const _dc ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_baa stdHandlerR4 )alg3Key (R int ,_befc []byte )[]byte {_af :=_f .New ();
_dbc :=_baa .paddedPass (_befc );_af .Write (_dbc );if R >=3{for _dbd :=0;_dbd < 50;_dbd ++{_bb :=_af .Sum (nil );_af =_f .New ();_af .Write (_bb );};};_eb :=_af .Sum (nil );if R ==2{_eb =_eb [0:5];}else {_eb =_eb [0:_baa .Length /8];};return _eb ;};func (_fff stdHandlerR4 )alg6 (_dac *StdEncryptDict ,_fed []byte )([]byte ,error ){var (_gab []byte ;
_dgd error ;);_bbf :=_fff .alg2 (_dac ,_fed );if _dac .R ==2{_gab ,_dgd =_fff .alg4 (_bbf ,_fed );}else if _dac .R >=3{_gab ,_dgd =_fff .alg5 (_bbf ,_fed );}else {return nil ,_ed .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _dgd !=nil {return nil ,_dgd ;
};_dab .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_gab ),string (_dac .U ));_fd :=_gab ;_agec :=_dac .U ;if _dac .R >=3{if len (_fd )> 16{_fd =_fd [0:16];};if len (_agec )> 16{_agec =_agec [0:16];
};};if !_gd .Equal (_fd ,_agec ){return nil ,nil ;};return _bbf ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););type errInvalidField struct{Func string ;
Field string ;Exp int ;Got int ;};func (_beb stdHandlerR6 )alg2b (R int ,_ged ,_bcgg ,_gfcg []byte )([]byte ,error ){if R ==5{return _feg (_ged );};return _ebc (_ged ,_bcgg ,_gfcg );};func (_dcc stdHandlerR6 )alg9 (_fca *StdEncryptDict ,_bbca []byte ,_fgfd []byte )error {if _eega :=_fc ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_bbca );
_eega !=nil {return _eega ;};if _dcb :=_fc ("\u0061\u006c\u0067\u0039","\u0055",48,_fca .U );_dcb !=nil {return _dcb ;};var _cde [16]byte ;if _ ,_ede :=_g .ReadFull (_ea .Reader ,_cde [:]);_ede !=nil {return _ede ;};_dgb :=_cde [0:8];_abac :=_cde [8:16];
_cded :=_fca .U [:48];_bae :=make ([]byte ,len (_fgfd )+len (_dgb )+len (_cded ));_afd :=copy (_bae ,_fgfd );_afd +=copy (_bae [_afd :],_dgb );_afd +=copy (_bae [_afd :],_cded );_cafc ,_dde :=_dcc .alg2b (_fca .R ,_bae ,_fgfd ,_cded );if _dde !=nil {return _dde ;
};O :=make ([]byte ,len (_cafc )+len (_dgb )+len (_abac ));_afd =copy (O ,_cafc [:32]);_afd +=copy (O [_afd :],_dgb );_afd +=copy (O [_afd :],_abac );_fca .O =O ;_afd =len (_fgfd );_afd +=copy (_bae [_afd :],_abac );_cafc ,_dde =_dcc .alg2b (_fca .R ,_bae ,_fgfd ,_cded );
if _dde !=nil {return _dde ;};_efg ,_dde :=_fgda (_cafc [:32]);if _dde !=nil {return _dde ;};_fgg :=make ([]byte ,_dd .BlockSize );_fcc :=_d .NewCBCEncrypter (_efg ,_fgg );OE :=make ([]byte ,32);_fcc .CryptBlocks (OE ,_bbca [:32]);_fca .OE =OE ;return nil ;
};func (_gdc stdHandlerR4 )alg4 (_ffg []byte ,_bca []byte )([]byte ,error ){_ced ,_fcd :=_cg .NewCipher (_ffg );if _fcd !=nil {return nil ,_ed .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bba :=[]byte (_dc );
_eac :=make ([]byte ,len (_bba ));_ced .XORKeyStream (_eac ,_bba );return _eac ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};type ecb struct{_ag _d .Block ;_cd int ;};func (_cbf stdHandlerR6 )alg10 (_bcaf *StdEncryptDict ,_cdc []byte )error {if _efc :=_fc ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_cdc );
_efc !=nil {return _efc ;};_gbc :=uint64 (uint32 (_bcaf .P ))|(_da .MaxUint32 <<32);Perms :=make ([]byte ,16);_ce .LittleEndian .PutUint64 (Perms [:8],_gbc );if _bcaf .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_fcdf :=_g .ReadFull (_ea .Reader ,Perms [12:16]);_fcdf !=nil {return _fcdf ;};_dgg ,_bgf :=_fgda (_cdc [:32]);if _bgf !=nil {return _bgf ;};_gccg :=_ddg (_dgg );_gccg .CryptBlocks (Perms ,Perms );_bcaf .Perms =Perms [:16];return nil ;};func _feg (_ccd []byte )([]byte ,error ){_eca :=_a .New ();
_eca .Write (_ccd );return _eca .Sum (nil ),nil };

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_bcgge stdHandlerR6 )alg12 (_gafb *StdEncryptDict ,_gge []byte )([]byte ,error ){if _aec :=_fc ("\u0061\u006c\u00671\u0032","\u0055",48,_gafb .U );_aec !=nil {return nil ,_aec ;};if _cad :=_fc ("\u0061\u006c\u00671\u0032","\u004f",48,_gafb .O );
_cad !=nil {return nil ,_cad ;};_ead :=make ([]byte ,len (_gge )+8+48);_agcf :=copy (_ead ,_gge );_agcf +=copy (_ead [_agcf :],_gafb .O [32:40]);_agcf +=copy (_ead [_agcf :],_gafb .U [0:48]);_cafe ,_adb :=_bcgge .alg2b (_gafb .R ,_ead ,_gge ,_gafb .U [0:48]);
if _adb !=nil {return nil ,_adb ;};_cafe =_cafe [:32];if !_gd .Equal (_cafe ,_gafb .O [:32]){return nil ,nil ;};return _cafe ,nil ;};func _fc (_bg ,_be string ,_fe int ,_bef []byte )error {if len (_bef )< _fe {return errInvalidField {Func :_bg ,Field :_be ,Exp :_fe ,Got :len (_bef )};
};return nil ;};func (_abd stdHandlerR6 )alg13 (_deg *StdEncryptDict ,_dcce []byte )error {if _dag :=_fc ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_dcce );_dag !=nil {return _dag ;};if _acbe :=_fc ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_deg .Perms );
_acbe !=nil {return _acbe ;};_bbac :=make ([]byte ,16);copy (_bbac ,_deg .Perms [:16]);_cgc ,_bdga :=_dd .NewCipher (_dcce [:32]);if _bdga !=nil {return _bdga ;};_bfg :=_dfd (_cgc );_bfg .CryptBlocks (_bbac ,_bbac );if !_gd .Equal (_bbac [9:12],[]byte ("\u0061\u0064\u0062")){return _ed .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_dggb :=Permissions (_ce .LittleEndian .Uint32 (_bbac [0:4]));if _dggb !=_deg .P {return _ed .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _bcec bool ;if _bbac [8]=='T'{_bcec =true ;}else if _bbac [8]=='F'{_bcec =false ;}else {return _ed .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _bcec !=_deg .EncryptMetadata {return _ed .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func _dfd (_ae _d .Block )_d .BlockMode {return (*ecbDecrypter )(_ff (_ae ))};func (_gde *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gde ._cd !=0{_dab .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_dab .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_gde ._ag .Encrypt (dst ,src [:_gde ._cd ]);src =src [_gde ._cd :];dst =dst [_gde ._cd :];};};const (PermOwner =Permissions (_da .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);
PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_ba stdHandlerR4 )alg2 (_gaf *StdEncryptDict ,_ceb []byte )[]byte {_dab .Log .Trace ("\u0061\u006c\u0067\u0032");
_bdf :=_ba .paddedPass (_ceb );_gdg :=_f .New ();_gdg .Write (_bdf );_gdg .Write (_gaf .O );var _gbf [4]byte ;_ce .LittleEndian .PutUint32 (_gbf [:],uint32 (_gaf .P ));_gdg .Write (_gbf [:]);_dab .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_gbf );
_gdg .Write ([]byte (_ba .ID0 ));_dab .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_gaf .R ,_gaf .EncryptMetadata );
if (_gaf .R >=4)&&!_gaf .EncryptMetadata {_gdg .Write ([]byte {0xff,0xff,0xff,0xff});};_gbff :=_gdg .Sum (nil );if _gaf .R >=3{_gdg =_f .New ();for _cce :=0;_cce < 50;_cce ++{_gdg .Reset ();_gdg .Write (_gbff [0:_ba .Length /8]);_gbff =_gdg .Sum (nil );
};};if _gaf .R >=3{return _gbff [0:_ba .Length /8];};return _gbff [0:5];};var _ StdHandler =stdHandlerR4 {};func (_gb errInvalidField )Error ()string {return _b .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_gb .Func ,_gb .Field ,_gb .Exp ,_gb .Got );
};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_cbgc stdHandlerR6 )alg11 (_bgee *StdEncryptDict ,_aea []byte )([]byte ,error ){if _bdeg :=_fc ("\u0061\u006c\u00671\u0031","\u0055",48,_bgee .U );
_bdeg !=nil {return nil ,_bdeg ;};_bed :=make ([]byte ,len (_aea )+8);_eec :=copy (_bed ,_aea );_eec +=copy (_bed [_eec :],_bgee .U [32:40]);_aca ,_adc :=_cbgc .alg2b (_bgee .R ,_bed ,_aea ,nil );if _adc !=nil {return nil ,_adc ;};_aca =_aca [:32];if !_gd .Equal (_aca ,_bgee .U [:32]){return nil ,nil ;
};return _aca ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// Authenticate implements StdHandler interface.
func (_fcba stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _fcba .alg2a (d ,pass );};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_dee stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_abc :=make ([]byte ,32);if _ ,_ecc :=_g .ReadFull (_ea .Reader ,_abc );_ecc !=nil {return nil ,_ecc ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _dba :=_dee .alg8 (d ,_abc ,upass );_dba !=nil {return nil ,_dba ;};if _gac :=_dee .alg9 (d ,_abc ,opass );_gac !=nil {return nil ,_gac ;};if d .R ==5{return _abc ,nil ;
};if _fdc :=_dee .alg10 (d ,_abc );_fdc !=nil {return nil ,_fdc ;};return _abc ,nil ;};func (_agc *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_agc ._cd !=0{_dab .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_dab .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_agc ._ag .Decrypt (dst ,src [:_agc ._cd ]);src =src [_agc ._cd :];dst =dst [_agc ._cd :];};};func (_ef stdHandlerR4 )alg5 (_gf []byte ,_age []byte )([]byte ,error ){_bbd :=_f .New ();_bbd .Write ([]byte (_dc ));_bbd .Write ([]byte (_ef .ID0 ));
_aef :=_bbd .Sum (nil );_dab .Log .Trace ("\u0061\u006c\u0067\u0035");_dab .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_gf );_dab .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_ef .ID0 );if len (_aef )!=16{return nil ,_ed .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_aeb ,_ggc :=_cg .NewCipher (_gf );if _ggc !=nil {return nil ,_ed .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bf :=make ([]byte ,16);_aeb .XORKeyStream (_bf ,_aef );_bcc :=make ([]byte ,len (_gf ));for _ggf :=0;
_ggf < 19;_ggf ++{for _eg :=0;_eg < len (_gf );_eg ++{_bcc [_eg ]=_gf [_eg ]^byte (_ggf +1);};_aeb ,_ggc =_cg .NewCipher (_bcc );if _ggc !=nil {return nil ,_ed .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};
_aeb .XORKeyStream (_bf ,_bf );_dab .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ggf ,_bcc );_dab .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ggf ,_bf );
};_bag :=make ([]byte ,32);for _fcg :=0;_fcg < 16;_fcg ++{_bag [_fcg ]=_bf [_fcg ];};_ ,_ggc =_ea .Read (_bag [16:32]);if _ggc !=nil {return nil ,_ed .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _bag ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_ffc stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_cbg :=_ffc .alg3 (d .R ,upass ,opass );if _cbg !=nil {_dab .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_cbg );
return nil ,_cbg ;};d .O =O ;_dab .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_gfg :=_ffc .alg2 (d ,upass );U ,_cbg :=_ffc .alg5 (_gfg ,upass );if _cbg !=nil {_dab .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_cbg );
return nil ,_cbg ;};d .U =U ;_dab .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _gfg ,nil ;};func (_aee stdHandlerR6 )alg2a (_dbg *StdEncryptDict ,_ab []byte )([]byte ,Permissions ,error ){if _fbg :=_fc ("\u0061\u006c\u00672\u0061","\u004f",48,_dbg .O );
_fbg !=nil {return nil ,0,_fbg ;};if _abe :=_fc ("\u0061\u006c\u00672\u0061","\u0055",48,_dbg .U );_abe !=nil {return nil ,0,_abe ;};if len (_ab )> 127{_ab =_ab [:127];};_bfa ,_bdc :=_aee .alg12 (_dbg ,_ab );if _bdc !=nil {return nil ,0,_bdc ;};var (_faf []byte ;
_dbe []byte ;_ccf []byte ;);var _becg Permissions ;if len (_bfa )!=0{_becg =PermOwner ;_bbfg :=make ([]byte ,len (_ab )+8+48);_eeb :=copy (_bbfg ,_ab );_eeb +=copy (_bbfg [_eeb :],_dbg .O [40:48]);copy (_bbfg [_eeb :],_dbg .U [0:48]);_faf =_bbfg ;_dbe =_dbg .OE ;
_ccf =_dbg .U [0:48];}else {_bfa ,_bdc =_aee .alg11 (_dbg ,_ab );if _bdc ==nil &&len (_bfa )==0{_bfa ,_bdc =_aee .alg11 (_dbg ,[]byte (""));};if _bdc !=nil {return nil ,0,_bdc ;}else if len (_bfa )==0{return nil ,0,nil ;};_becg =_dbg .P ;_fce :=make ([]byte ,len (_ab )+8);
_ec :=copy (_fce ,_ab );copy (_fce [_ec :],_dbg .U [40:48]);_faf =_fce ;_dbe =_dbg .UE ;_ccf =nil ;};if _ca :=_fc ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_dbe );_ca !=nil {return nil ,0,_ca ;};_dbe =_dbe [:32];_acb ,_bdc :=_aee .alg2b (_dbg .R ,_faf ,_ab ,_ccf );
if _bdc !=nil {return nil ,0,_bdc ;};_bbg ,_bdc :=_dd .NewCipher (_acb [:32]);if _bdc !=nil {return nil ,0,_bdc ;};_edd :=make ([]byte ,_dd .BlockSize );_eaa :=_d .NewCBCDecrypter (_bbg ,_edd );_cbga :=make ([]byte ,32);_eaa .CryptBlocks (_cbga ,_dbe );
if _dbg .R ==5{return _cbga ,_becg ,nil ;};_bdc =_aee .alg13 (_dbg ,_cbga );if _bdc !=nil {return nil ,0,_bdc ;};return _cbga ,_becg ,nil ;};func _fgda (_eeg []byte )(_d .Block ,error ){_gdgg ,_bad :=_dd .NewCipher (_eeg );if _bad !=nil {_dab .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bad );
return nil ,_bad ;};return _gdgg ,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func _ebc (_ddgg ,_bdb ,_dcd []byte )([]byte ,error ){var (_cdg ,_bdg ,_dfc _e .Hash ;);_cdg =_a .New ();_caf :=make ([]byte ,64);_bce :=_cdg ;_bce .Write (_ddgg );K :=_bce .Sum (_caf [:0]);_ddb :=make ([]byte ,64*(127+64+48));
_bge :=func (_gfc int )([]byte ,error ){_fgbc :=len (_bdb )+len (K )+len (_dcd );_afc :=_ddb [:_fgbc ];_acg :=copy (_afc ,_bdb );_acg +=copy (_afc [_acg :],K [:]);_acg +=copy (_afc [_acg :],_dcd );if _acg !=_fgbc {_dab .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_ed .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_ddb [:_fgbc *64];_ggb (K1 ,_fgbc );_agd ,_eafb :=_fgda (K [0:16]);if _eafb !=nil {return nil ,_eafb ;};_eddd :=_d .NewCBCEncrypter (_agd ,K [16:32]);_eddd .CryptBlocks (K1 ,K1 );
E :=K1 ;_dabg :=0;for _cbb :=0;_cbb < 16;_cbb ++{_dabg +=int (E [_cbb ]%3);};var _ge _e .Hash ;switch _dabg %3{case 0:_ge =_cdg ;case 1:if _bdg ==nil {_bdg =_df .New384 ();};_ge =_bdg ;case 2:if _dfc ==nil {_dfc =_df .New ();};_ge =_dfc ;};_ge .Reset ();
_ge .Write (E );K =_ge .Sum (_caf [:0]);return E ,nil ;};for _dfg :=0;;{E ,_gbd :=_bge (_dfg );if _gbd !=nil {return nil ,_gbd ;};_aed :=E [len (E )-1];_dfg ++;if _dfg >=64&&_aed <=uint8 (_dfg -32){break ;};};return K [:32],nil ;};type ecbEncrypter ecb ;
func (_gbe stdHandlerR4 )alg7 (_ggg *StdEncryptDict ,_fa []byte )([]byte ,error ){_ace :=_gbe .alg3Key (_ggg .R ,_fa );_eab :=make ([]byte ,len (_ggg .O ));if _ggg .R ==2{_ega ,_feb :=_cg .NewCipher (_ace );if _feb !=nil {return nil ,_ed .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_ega .XORKeyStream (_eab ,_ggg .O );}else if _ggg .R >=3{_cbe :=append ([]byte {},_ggg .O ...);for _gcc :=0;_gcc < 20;_gcc ++{_fcb :=append ([]byte {},_ace ...);for _fef :=0;_fef < len (_ace );_fef ++{_fcb [_fef ]^=byte (19-_gcc );};_ffga ,_cf :=_cg .NewCipher (_fcb );
if _cf !=nil {return nil ,_ed .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_ffga .XORKeyStream (_eab ,_cbe );_cbe =append ([]byte {},_eab ...);};}else {return nil ,_ed .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");
};_eaf ,_eae :=_gbe .alg6 (_ggg ,_eab );if _eae !=nil {return nil ,nil ;};return _eaf ,nil ;};var _ StdHandler =stdHandlerR6 {};func _ddg (_dabb _d .Block )_d .BlockMode {return (*ecbEncrypter )(_ff (_dabb ))};type stdHandlerR6 struct{};func (stdHandlerR4 )paddedPass (_fee []byte )[]byte {_db :=make ([]byte ,32);
_bgd :=copy (_db ,_fee );for ;_bgd < 32;_bgd ++{_db [_bgd ]=_dc [_bgd -len (_fee )];};return _db ;};

// Allowed checks if a set of permissions can be granted.
func (_cc Permissions )Allowed (p2 Permissions )bool {return _cc &p2 ==p2 };

// Authenticate implements StdHandler interface.
func (_ee stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_dab .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_daf ,_gda :=_ee .alg7 (d ,pass );if _gda !=nil {return nil ,0,_gda ;};if _daf !=nil {_dab .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _daf ,PermOwner ,nil ;
};_dab .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_daf ,_gda =_ee .alg6 (d ,pass );if _gda !=nil {return nil ,0,_gda ;
};if _daf !=nil {_dab .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _daf ,d .P ,nil ;};return nil ,0,nil ;};