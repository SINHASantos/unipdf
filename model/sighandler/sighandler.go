//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_a "bytes";_gg "crypto";_d "crypto/rand";_ce "crypto/rsa";_ed "crypto/x509";_cfc "crypto/x509/pkix";_g "encoding/asn1";_cg "encoding/hex";_fg "errors";_cf "fmt";_da "github.com/unidoc/pkcs7";_ba "github.com/unidoc/timestamp";
_fc "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/core";_gbg "github.com/unidoc/unipdf/v3/model";_bag "github.com/unidoc/unipdf/v3/model/mdp";_gb "github.com/unidoc/unipdf/v3/model/sigutil";_ea "hash";_e "math/big";_fa "strings";
_c "time";);

// NewEtsiPAdESLevelLT creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
func NewEtsiPAdESLevelLT (privateKey *_ce .PrivateKey ,certificate *_ed .Certificate ,caCert *_ed .Certificate ,certificateTimestampServerURL string ,appender *_gbg .PdfAppender )(_gbg .SignatureHandler ,error ){_fe :=appender .Reader .DSS ;if _fe ==nil {_fe =_gbg .NewDSS ();
};if _fce :=_fe .GenerateHashMaps ();_fce !=nil {return nil ,_fce ;};return &etsiPAdES {_edg :certificate ,_gbf :privateKey ,_fdf :caCert ,_fcb :certificateTimestampServerURL ,CertClient :_gb .NewCertClient (),OCSPClient :_gb .NewOCSPClient (),CRLClient :_gb .NewCRLClient (),_cfcc :appender ,_bd :_fe },nil ;
};func (_efc *etsiPAdES )getOCSPs (_fde []*_ed .Certificate ,_daf map[string ]*_ed .Certificate )([][]byte ,error ){_gfc :=make ([][]byte ,0,len (_fde ));for _ ,_abb :=range _fde {for _ ,_cdb :=range _abb .OCSPServer {if _efc .CertClient .IsCA (_abb ){continue ;
};_efa ,_cffb :=_daf [_abb .Issuer .CommonName ];if !_cffb {_fc .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
continue ;};_ ,_bec ,_bece :=_efc .OCSPClient .MakeRequest (_cdb ,_abb ,_efa );if _bece !=nil {_fc .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076",_bece );
continue ;};_gfc =append (_gfc ,_bec );};};return _gfc ,nil ;};

// RevocationInfoArchival is OIDAttributeAdobeRevocation attribute.
type RevocationInfoArchival struct{Crl []_g .RawValue `asn1:"explicit,tag:0,optional"`;Ocsp []_g .RawValue `asn1:"explicit,tag:1,optional"`;OtherRevInfo []_g .RawValue `asn1:"explicit,tag:2,optional"`;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_ce .PrivateKey ,certificate *_ed .Certificate )(_gbg .SignatureHandler ,error ){return &adobePKCS7Detached {_acgc :certificate ,_dafe :privateKey },nil ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_gbg .SignatureHandler ,error ){return &adobePKCS7Detached {_aeg :true ,_cab :signatureLen },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_bff *etsiPAdES )Sign (sig *_gbg .PdfSignature ,digest _gbg .Hasher )error {_fdaf ,_dcd :=digest .(*_a .Buffer );if !_dcd {return _cf .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_afd ,_gff :=_da .NewSignedData (_fdaf .Bytes ());
if _gff !=nil {return _gff ;};_afd .SetDigestAlgorithm (_da .OIDDigestAlgorithmSHA256 );_faa :=_da .SignerInfoConfig {};_aee :=_gg .SHA256 .New ();_aee .Write (_bff ._edg .Raw );var _dcfa struct{Seq struct{Seq struct{Value []byte ;};};};_dcfa .Seq .Seq .Value =_aee .Sum (nil );
var _ff []*_ed .Certificate ;var _gc []*_ed .Certificate ;if _bff ._fdf !=nil {_gc =[]*_ed .Certificate {_bff ._fdf };};_fdec :=RevocationInfoArchival {Crl :[]_g .RawValue {},Ocsp :[]_g .RawValue {},OtherRevInfo :[]_g .RawValue {}};_bgb :=0;if _bff ._cfcc !=nil &&len (_bff ._fcb )> 0{_baa ,_de :=_bff .makeTimestampRequest (_bff ._fcb ,([]byte )(""));
if _de !=nil {return _de ;};_ecfg ,_de :=_ba .Parse (_baa .FullBytes );if _de !=nil {return _de ;};_ff =append (_ff ,_ecfg .Certificates ...);};if _bff ._cfcc !=nil {_eee ,_fgd :=_bff .addDss ([]*_ed .Certificate {_bff ._edg },_gc ,&_fdec );if _fgd !=nil {return _fgd ;
};_bgb +=_eee ;if len (_ff )> 0{_eee ,_fgd =_bff .addDss (_ff ,nil ,&_fdec );if _fgd !=nil {return _fgd ;};_bgb +=_eee ;};if !_bff ._cfd {_bff ._cfcc .SetDSS (_bff ._bd );};};_faa .ExtraSignedAttributes =append (_faa .ExtraSignedAttributes ,_da .Attribute {Type :_da .OIDAttributeSigningCertificateV2 ,Value :_dcfa },_da .Attribute {Type :_da .OIDAttributeAdobeRevocation ,Value :_fdec });
if _ccf :=_afd .AddSignerChainPAdES (_bff ._edg ,_bff ._gbf ,_gc ,_faa );_ccf !=nil {return _ccf ;};_afd .Detach ();if len (_bff ._fcb )> 0{_bdcb :=_afd .GetSignedData ().SignerInfos [0].EncryptedDigest ;_agc ,_abg :=_bff .makeTimestampRequest (_bff ._fcb ,_bdcb );
if _abg !=nil {return _abg ;};_abg =_afd .AddTimestampTokenToSigner (0,_agc .FullBytes );if _abg !=nil {return _abg ;};};_ggb ,_gff :=_afd .Finish ();if _gff !=nil {return _gff ;};_cdag :=make ([]byte ,len (_ggb )+1024*2+_bgb );copy (_cdag ,_ggb );sig .Contents =_b .MakeHexString (string (_cdag ));
if !_bff ._cfd &&_bff ._bd !=nil {_aee =_gg .SHA1 .New ();_aee .Write (_cdag );_ad :=_fa .ToUpper (_cg .EncodeToString (_aee .Sum (nil )));if _ad !=""{_bff ._bd .VRI [_ad ]=&_gbg .VRI {Cert :_bff ._bd .Certs ,OCSP :_bff ._bd .OCSPs ,CRL :_bff ._bd .CRLs };
};_bff ._cfcc .SetDSS (_bff ._bd );};return nil ;};

// NewDigest creates a new digest.
func (_ggc *adobeX509RSASHA1 )NewDigest (sig *_gbg .PdfSignature )(_gbg .Hasher ,error ){if _cgc ,_fgc :=_ggc .getHashAlgorithm (sig );_cgc !=0&&_fgc ==nil {return _cgc .New (),nil ;};return _aeb .New (),nil ;};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _gbg .SignatureHandler ,permission _bag .DocMDPPermission )(_gbg .SignatureHandler ,error ){return &DocMDPHandler {_ceg :handler ,Permission :permission },nil ;};func _agec (_eefe []byte ,_cbed int )(_cacc []byte ){_efbea :=len (_eefe );
if _efbea > _cbed {_efbea =_cbed ;};_cacc =make ([]byte ,_cbed );copy (_cacc [len (_cacc )-_efbea :],_eefe );return ;};

// InitSignature initialises the PdfSignature.
func (_cbe *adobeX509RSASHA1 )InitSignature (sig *_gbg .PdfSignature )error {if _cbe ._gcd ==nil {return _fg .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _cbe ._cef ==nil &&_cbe ._ebd ==nil {return _fg .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_cgg :=*_cbe ;sig .Handler =&_cgg ;sig .Filter =_b .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_b .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_b .MakeString (string (_cgg ._gcd .Raw ));sig .Reference =nil ;_cbca ,_eef :=_cgg .NewDigest (sig );if _eef !=nil {return _eef ;};_cbca .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _cgg .sign (sig ,_cbca ,_cbe ._gdf );};

// Validate validates PdfSignature.
func (_dga *docTimeStamp )Validate (sig *_gbg .PdfSignature ,digest _gbg .Hasher )(_gbg .SignatureValidationResult ,error ){_gdea :=sig .Contents .Bytes ();_dcfc ,_fgdd :=_da .Parse (_gdea );if _fgdd !=nil {return _gbg .SignatureValidationResult {},_fgdd ;
};if _fgdd =_dcfc .Verify ();_fgdd !=nil {return _gbg .SignatureValidationResult {},_fgdd ;};var _ffec timestampInfo ;_ ,_fgdd =_g .Unmarshal (_dcfc .Content ,&_ffec );if _fgdd !=nil {return _gbg .SignatureValidationResult {},_fgdd ;};_ffad ,_fgdd :=_bgaa (_ffec .MessageImprint .HashAlgorithm .Algorithm );
if _fgdd !=nil {return _gbg .SignatureValidationResult {},_fgdd ;};_dd :=_ffad .New ();_ade ,_dbb :=digest .(*_a .Buffer );if !_dbb {return _gbg .SignatureValidationResult {},_cf .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");
};_dd .Write (_ade .Bytes ());_ead :=_dd .Sum (nil );_fdbc :=_gbg .SignatureValidationResult {IsSigned :true ,IsVerified :_a .Equal (_ead ,_ffec .MessageImprint .HashedMessage ),GeneralizedTime :_ffec .GeneralizedTime };return _fdbc ,nil ;};

// InitSignature initialises the PdfSignature.
func (_agb *adobePKCS7Detached )InitSignature (sig *_gbg .PdfSignature )error {if !_agb ._aeg {if _agb ._acgc ==nil {return _fg .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _agb ._dafe ==nil {return _fg .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_gcg :=*_agb ;sig .Handler =&_gcg ;sig .Filter =_b .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_b .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_afag ,_babd :=_gcg .NewDigest (sig );if _babd !=nil {return _babd ;};_afag .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _gcg .Sign (sig ,_afag );};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_abgd *_gbg .PdfSignature ,_gabd _gbg .Hasher )([]byte ,error );

// Validate validates PdfSignature.
func (_abda *adobeX509RSASHA1 )Validate (sig *_gbg .PdfSignature ,digest _gbg .Hasher )(_gbg .SignatureValidationResult ,error ){_fagf ,_edga :=_abda .getCertificate (sig );if _edga !=nil {return _gbg .SignatureValidationResult {},_edga ;};_agg :=sig .Contents .Bytes ();
var _gffb []byte ;if _ ,_fad :=_g .Unmarshal (_agg ,&_gffb );_fad !=nil {return _gbg .SignatureValidationResult {},_fad ;};_bfc ,_dgg :=digest .(_ea .Hash );if !_dgg {return _gbg .SignatureValidationResult {},_fg .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_cbgb ,_ :=_abda .getHashAlgorithm (sig );if _cbgb ==0{_cbgb =_aeb ;};if _dec :=_ce .VerifyPKCS1v15 (_fagf .PublicKey .(*_ce .PublicKey ),_cbgb ,_bfc .Sum (nil ),_gffb );_dec !=nil {return _gbg .SignatureValidationResult {},_dec ;};return _gbg .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};func (_bffd *adobePKCS7Detached )getCertificate (_fbc *_gbg .PdfSignature )(*_ed .Certificate ,error ){if _bffd ._acgc !=nil {return _bffd ._acgc ,nil ;};_acdb ,_fcdg :=_fbc .GetCerts ();if _fcdg !=nil {return nil ,_fcdg ;};return _acdb [0],nil ;};func (_abe *etsiPAdES )buildCertChain (_cga ,_af []*_ed .Certificate )([]*_ed .Certificate ,map[string ]*_ed .Certificate ,error ){_gfa :=map[string ]*_ed .Certificate {};
for _ ,_dcf :=range _cga {_gfa [_dcf .Subject .CommonName ]=_dcf ;};_fdb :=_cga ;for _ ,_bdd :=range _af {_aae :=_bdd .Subject .CommonName ;if _ ,_bf :=_gfa [_aae ];_bf {continue ;};_gfa [_aae ]=_bdd ;_fdb =append (_fdb ,_bdd );};if len (_fdb )==0{return nil ,nil ,_gbg .ErrSignNoCertificates ;
};var _dfc error ;for _efb :=_fdb [0];_efb !=nil &&!_abe .CertClient .IsCA (_efb );{var _efg *_ed .Certificate ;_ ,_bfg :=_gfa [_efb .Issuer .CommonName ];if !_bfg {if _efg ,_dfc =_abe .CertClient .GetIssuer (_efb );_dfc !=nil {_fc .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076",_dfc );
break ;};_gfa [_efb .Issuer .CommonName ]=_efg ;_fdb =append (_fdb ,_efg );}else {break ;};_efb =_efg ;};return _fdb ,_gfa ,nil ;};func (_aaea *etsiPAdES )addDss (_dcdg ,_fag []*_ed .Certificate ,_aba *RevocationInfoArchival )(int ,error ){_geb ,_eaa ,_fdfe :=_aaea .buildCertChain (_dcdg ,_fag );
if _fdfe !=nil {return 0,_fdfe ;};_bfd ,_fdfe :=_aaea .getCerts (_geb );if _fdfe !=nil {return 0,_fdfe ;};var _afa ,_bac [][]byte ;if _aaea .OCSPClient !=nil {_afa ,_fdfe =_aaea .getOCSPs (_geb ,_eaa );if _fdfe !=nil {return 0,_fdfe ;};};if _aaea .CRLClient !=nil {_bac ,_fdfe =_aaea .getCRLs (_geb );
if _fdfe !=nil {return 0,_fdfe ;};};if !_aaea ._cfd {_ ,_fdfe =_aaea ._bd .AddCerts (_bfd );if _fdfe !=nil {return 0,_fdfe ;};_ ,_fdfe =_aaea ._bd .AddOCSPs (_afa );if _fdfe !=nil {return 0,_fdfe ;};_ ,_fdfe =_aaea ._bd .AddCRLs (_bac );if _fdfe !=nil {return 0,_fdfe ;
};};_efeg :=0;for _ ,_cbg :=range _bac {_efeg +=len (_cbg );_aba .Crl =append (_aba .Crl ,_g .RawValue {FullBytes :_cbg });};for _ ,_gab :=range _afa {_efeg +=len (_gab );_aba .Ocsp =append (_aba .Ocsp ,_g .RawValue {FullBytes :_gab });};return _efeg ,nil ;
};

// Sign adds a new reference to signature's references array.
func (_fd *DocMDPHandler )Sign (sig *_gbg .PdfSignature ,digest _gbg .Hasher )error {return _fd ._ceg .Sign (sig ,digest );};type docTimeStamp struct{_bacf string ;_gac _gg .Hash ;_bffc int ;_dba *_gb .TimestampClient ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_bea *etsiPAdES )IsApplicable (sig *_gbg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _gg .Hash )(_gbg .SignatureHandler ,error ){return &docTimeStamp {_bacf :timestampServerURL ,_gac :hashAlgorithm },nil ;};

// NewEtsiPAdESLevelT creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
func NewEtsiPAdESLevelT (privateKey *_ce .PrivateKey ,certificate *_ed .Certificate ,caCert *_ed .Certificate ,certificateTimestampServerURL string )(_gbg .SignatureHandler ,error ){return &etsiPAdES {_edg :certificate ,_gbf :privateKey ,_fdf :caCert ,_fcb :certificateTimestampServerURL },nil ;
};type adobeX509RSASHA1 struct{_cef *_ce .PrivateKey ;_gcd *_ed .Certificate ;_ebd SignFunc ;_gdf bool ;_bbd _gg .Hash ;};func _bgaa (_bgge _g .ObjectIdentifier )(_gg .Hash ,error ){switch {case _bgge .Equal (_da .OIDDigestAlgorithmSHA1 ),_bgge .Equal (_da .OIDDigestAlgorithmECDSASHA1 ),_bgge .Equal (_da .OIDDigestAlgorithmDSA ),_bgge .Equal (_da .OIDDigestAlgorithmDSASHA1 ),_bgge .Equal (_da .OIDEncryptionAlgorithmRSA ):return _gg .SHA1 ,nil ;
case _bgge .Equal (_da .OIDDigestAlgorithmSHA256 ),_bgge .Equal (_da .OIDDigestAlgorithmECDSASHA256 ):return _gg .SHA256 ,nil ;case _bgge .Equal (_da .OIDDigestAlgorithmSHA384 ),_bgge .Equal (_da .OIDDigestAlgorithmECDSASHA384 ):return _gg .SHA384 ,nil ;
case _bgge .Equal (_da .OIDDigestAlgorithmSHA512 ),_bgge .Equal (_da .OIDDigestAlgorithmECDSASHA512 ):return _gg .SHA512 ,nil ;};return _gg .Hash (0),_da .ErrUnsupportedAlgorithm ;};func (_bgd *etsiPAdES )getCerts (_agdf []*_ed .Certificate )([][]byte ,error ){_efe :=make ([][]byte ,0,len (_agdf ));
for _ ,_eeb :=range _agdf {_efe =append (_efe ,_eeb .Raw );};return _efe ,nil ;};

// NewDigest creates a new digest.
func (_fdg *docTimeStamp )NewDigest (sig *_gbg .PdfSignature )(_gbg .Hasher ,error ){return _a .NewBuffer (nil ),nil ;};func (_bfea *docTimeStamp )getCertificate (_bge *_gbg .PdfSignature )(*_ed .Certificate ,error ){_bcgd ,_afce :=_bge .GetCerts ();if _afce !=nil {return nil ,_afce ;
};return _bcgd [0],nil ;};func (_gec *adobeX509RSASHA1 )sign (_caf *_gbg .PdfSignature ,_ebb _gbg .Hasher ,_efbe bool )error {if !_efbe {return _gec .Sign (_caf ,_ebb );};_cfbf ,_cae :=_gec ._gcd .PublicKey .(*_ce .PublicKey );if !_cae {return _cf .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_cfbf );
};_gceg ,_bga :=_g .Marshal (make ([]byte ,_cfbf .Size ()));if _bga !=nil {return _bga ;};_caf .Contents =_b .MakeHexString (string (_gceg ));return nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_ed .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_gbg .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_gcd :certificate ,_ebd :signFunc ,_gdf :opts .EstimateSize ,_bbd :opts .Algorithm },nil ;
};

// Sign sets the Contents fields.
func (_bagg *adobePKCS7Detached )Sign (sig *_gbg .PdfSignature ,digest _gbg .Hasher )error {if _bagg ._aeg {_bfe :=_bagg ._cab ;if _bfe <=0{_bfe =8192;};sig .Contents =_b .MakeHexString (string (make ([]byte ,_bfe )));return nil ;};_bcg ,_afac :=digest .(*_a .Buffer );
if !_afac {return _cf .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_ffe ,_eaad :=_da .NewSignedData (_bcg .Bytes ());if _eaad !=nil {return _eaad ;};if _aagc :=_ffe .AddSigner (_bagg ._acgc ,_bagg ._dafe ,_da .SignerInfoConfig {});
_aagc !=nil {return _aagc ;};_ffe .Detach ();_gfb ,_eaad :=_ffe .Finish ();if _eaad !=nil {return _eaad ;};_dfb :=make ([]byte ,8192);copy (_dfb ,_gfb );sig .Contents =_b .MakeHexString (string (_dfb ));return nil ;};

// NewDigest creates a new digest.
func (_afc *etsiPAdES )NewDigest (_ *_gbg .PdfSignature )(_gbg .Hasher ,error ){return _a .NewBuffer (nil ),nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_ce .PrivateKey ,certificate *_ed .Certificate )(_gbg .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gcd :certificate ,_cef :privateKey },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_egg *docTimeStamp )IsApplicable (sig *_gbg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};func _gbfg (_gfg *_ce .PublicKey ,_eefc []byte )_gg .Hash {_gdg :=_gfg .Size ();if _gdg !=len (_eefc ){return 0;};_cbgf :=func (_cbd *_e .Int ,_bcef *_ce .PublicKey ,_cffcg *_e .Int )*_e .Int {_bfda :=_e .NewInt (int64 (_bcef .E ));_cbd .Exp (_cffcg ,_bfda ,_bcef .N );
return _cbd ;};_aagd :=new (_e .Int ).SetBytes (_eefc );_aec :=_cbgf (new (_e .Int ),_gfg ,_aagd );_cfcce :=_agec (_aec .Bytes (),_gdg );if _cfcce [0]!=0||_cfcce [1]!=1{return 0;};_afb :=[]struct{Hash _gg .Hash ;Prefix []byte ;}{{Hash :_gg .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_gg .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_gg .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_gg .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_gg .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_gcf :=range _afb {_agbd :=_gcf .Hash .Size ();_daff :=len (_gcf .Prefix )+_agbd ;if _a .Equal (_cfcce [_gdg -_daff :_gdg -_agbd ],_gcf .Prefix ){return _gcf .Hash ;};};return 0;};

// Sign sets the Contents fields for the PdfSignature.
func (_adb *adobeX509RSASHA1 )Sign (sig *_gbg .PdfSignature ,digest _gbg .Hasher )error {var _gbc []byte ;var _efaf error ;if _adb ._ebd !=nil {_gbc ,_efaf =_adb ._ebd (sig ,digest );if _efaf !=nil {return _efaf ;};}else {_fgf ,_bda :=digest .(_ea .Hash );
if !_bda {return _fg .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_eac :=_aeb ;if _adb ._bbd !=0{_eac =_adb ._bbd ;};_gbc ,_efaf =_ce .SignPKCS1v15 (_d .Reader ,_adb ._cef ,_eac ,_fgf .Sum (nil ));if _efaf !=nil {return _efaf ;
};};_gbc ,_efaf =_g .Marshal (_gbc );if _efaf !=nil {return _efaf ;};sig .Contents =_b .MakeHexString (string (_gbc ));return nil ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_gb .TimestampClient ;};

// NewDigest creates a new digest.
func (_ae *DocMDPHandler )NewDigest (sig *_gbg .PdfSignature )(_gbg .Hasher ,error ){return _ae ._ceg .NewDigest (sig );};

// Sign sets the Contents fields for the PdfSignature.
func (_fgca *docTimeStamp )Sign (sig *_gbg .PdfSignature ,digest _gbg .Hasher )error {_gbgd ,_fbe :=_gb .NewTimestampRequest (digest .(*_a .Buffer ),&_ba .RequestOptions {Hash :_fgca ._gac ,Certificates :true });if _fbe !=nil {return _fbe ;};_cfba :=_fgca ._dba ;
if _cfba ==nil {_cfba =_gb .NewTimestampClient ();};_beea ,_fbe :=_cfba .GetEncodedToken (_fgca ._bacf ,_gbgd );if _fbe !=nil {return _fbe ;};_aaa :=len (_beea );if _fgca ._bffc > 0&&_aaa > _fgca ._bffc {return _gbg .ErrSignNotEnoughSpace ;};if _aaa > 0{_fgca ._bffc =_aaa +128;
};if sig .Contents !=nil {_adf :=sig .Contents .Bytes ();copy (_adf ,_beea );_beea =_adf ;};sig .Contents =_b .MakeHexString (string (_beea ));return nil ;};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_ac *DocMDPHandler )ValidateWithOpts (sig *_gbg .PdfSignature ,digest _gbg .Hasher ,params _gbg .SignatureHandlerDocMDPParams )(_gbg .SignatureValidationResult ,error ){_eg ,_gd :=_ac ._ceg .Validate (sig ,digest );if _gd !=nil {return _eg ,_gd ;
};_dc :=params .Parser ;if _dc ==nil {return _gbg .SignatureValidationResult {},_fg .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_eg .IsVerified {return _eg ,nil ;};_dca :=params .DiffPolicy ;
if _dca ==nil {_dca =_bag .NewDefaultDiffPolicy ();};for _acg :=0;_acg <=_dc .GetRevisionNumber ();_acg ++{_fb ,_aa :=_dc .GetRevision (_acg );if _aa !=nil {return _gbg .SignatureValidationResult {},_aa ;};_fcd :=_fb .GetTrailer ();if _fcd ==nil {return _gbg .SignatureValidationResult {},_fg .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_acb ,_dcac :=_b .GetDict (_fcd .Get ("\u0052\u006f\u006f\u0074"));if !_dcac {return _gbg .SignatureValidationResult {},_fg .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");
};_ec ,_dcac :=_b .GetDict (_acb .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_dcac {continue ;};_egc ,_dcac :=_b .GetArray (_ec .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_dcac {continue ;};for _ ,_fge :=range _egc .Elements (){_ef ,_bee :=_b .GetDict (_fge );
if !_bee {continue ;};_gf ,_bee :=_b .GetDict (_ef .Get ("\u0056"));if !_bee {continue ;};if _b .EqualObjects (_gf .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_eg .DiffResults ,_aa =_dca .ReviewFile (_fb ,_dc ,&_bag .MDPParameters {DocMDPLevel :_ac .Permission });
if _aa !=nil {return _gbg .SignatureValidationResult {},_aa ;};_eg .IsVerified =_eg .DiffResults .IsPermitted ();return _eg ,nil ;};};};return _gbg .SignatureValidationResult {},_fg .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};func (_ace *etsiPAdES )getCRLs (_fab []*_ed .Certificate )([][]byte ,error ){_gge :=make ([][]byte ,0,len (_fab ));for _ ,_eaf :=range _fab {for _ ,_acc :=range _eaf .CRLDistributionPoints {if _ace .CertClient .IsCA (_eaf ){continue ;};_bdcg ,_eb :=_ace .CRLClient .MakeRequest (_acc ,_eaf );
if _eb !=nil {_fc .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076",_eb );continue ;};_gge =append (_gge ,_bdcg );};};return _gge ,nil ;};

// Validate validates PdfSignature.
func (_fcbf *adobePKCS7Detached )Validate (sig *_gbg .PdfSignature ,digest _gbg .Hasher )(_gbg .SignatureValidationResult ,error ){_cac :=sig .Contents .Bytes ();_cfb ,_bef :=_da .Parse (_cac );if _bef !=nil {return _gbg .SignatureValidationResult {},_bef ;
};_bgg ,_cag :=digest .(*_a .Buffer );if !_cag {return _gbg .SignatureValidationResult {},_cf .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_cfb .Content =_bgg .Bytes ();if _bef =_cfb .Verify ();
_bef !=nil {return _gbg .SignatureValidationResult {},_bef ;};return _gbg .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};type timestampInfo struct{Version int ;Policy _g .RawValue ;MessageImprint struct{HashAlgorithm _cfc .AlgorithmIdentifier ;
HashedMessage []byte ;};SerialNumber _g .RawValue ;GeneralizedTime _c .Time ;};const _aeb =_gg .SHA1 ;

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _gg .Hash ,opts *DocTimeStampOpts )(_gbg .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_bacf :timestampServerURL ,_gac :hashAlgorithm ,_bffc :opts .SignatureSize ,_dba :opts .Client },nil ;
};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_bad *DocMDPHandler )Validate (sig *_gbg .PdfSignature ,digest _gbg .Hasher )(_gbg .SignatureValidationResult ,error ){return _gbg .SignatureValidationResult {},_fg .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};

// InitSignature initialises the PdfSignature.
func (_dag *docTimeStamp )InitSignature (sig *_gbg .PdfSignature )error {_ffa :=*_dag ;sig .Type =_b .MakeName ("\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070");sig .Handler =&_ffa ;sig .Filter =_b .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_b .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _dag ._bffc > 0{sig .Contents =_b .MakeHexString (string (make ([]byte ,_dag ._bffc )));}else {_eefed ,_cde :=_dag .NewDigest (sig );
if _cde !=nil {return _cde ;};_eefed .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _cde =_ffa .Sign (sig ,_eefed );
_cde !=nil {return _cde ;};_dag ._bffc =_ffa ._bffc ;};return nil ;};type adobePKCS7Detached struct{_dafe *_ce .PrivateKey ;_acgc *_ed .Certificate ;_aeg bool ;_cab int ;};

// NewEtsiPAdESLevelB creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
func NewEtsiPAdESLevelB (privateKey *_ce .PrivateKey ,certificate *_ed .Certificate ,caCert *_ed .Certificate )(_gbg .SignatureHandler ,error ){return &etsiPAdES {_edg :certificate ,_gbf :privateKey ,_fdf :caCert },nil ;};

// NewDigest creates a new digest.
func (_cffc *adobePKCS7Detached )NewDigest (sig *_gbg .PdfSignature )(_gbg .Hasher ,error ){return _a .NewBuffer (nil ),nil ;};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_ceg _gbg .SignatureHandler ;Permission _bag .DocMDPPermission ;};func (_bfdc *adobeX509RSASHA1 )getCertificate (_dbc *_gbg .PdfSignature )(*_ed .Certificate ,error ){if _bfdc ._gcd !=nil {return _bfdc ._gcd ,nil ;};_dcb ,_bbb :=_dbc .GetCerts ();
if _bbb !=nil {return nil ,_bbb ;};return _dcb [0],nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_age *adobeX509RSASHA1 )IsApplicable (sig *_gbg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};func (_gbge *adobeX509RSASHA1 )getHashAlgorithm (_ggg *_gbg .PdfSignature )(_gg .Hash ,error ){_acf ,_bdb :=_gbge .getCertificate (_ggg );if _bdb !=nil {if _gbge ._bbd !=0{return _gbge ._bbd ,nil ;};return _aeb ,_bdb ;};if _ggg .Contents !=nil {_gabg :=_ggg .Contents .Bytes ();
var _beae []byte ;if _ ,_ffgg :=_g .Unmarshal (_gabg ,&_beae );_ffgg ==nil {_cgb :=_gbfg (_acf .PublicKey .(*_ce .PublicKey ),_beae );if _cgb > 0{return _cgb ,nil ;};};};if _gbge ._bbd !=0{return _gbge ._bbd ,nil ;};return _aeb ,nil ;};

// InitSignature initialization of the DocMDP signature.
func (_cda *DocMDPHandler )InitSignature (sig *_gbg .PdfSignature )error {_aaf :=_cda ._ceg .InitSignature (sig );if _aaf !=nil {return _aaf ;};sig .Handler =_cda ;if sig .Reference ==nil {sig .Reference =_b .MakeArray ();};sig .Reference .Append (_gbg .NewPdfSignatureReferenceDocMDP (_gbg .NewPdfTransformParamsDocMDP (_cda .Permission )).ToPdfObject ());
return nil ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _gg .Hash ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_ed .Certificate ,signFunc SignFunc )(_gbg .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gcd :certificate ,_ebd :signFunc },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_cd *DocMDPHandler )IsApplicable (sig *_gbg .PdfSignature )bool {_ge :=false ;for _ ,_be :=range sig .Reference .Elements (){if _cc ,_dg :=_b .GetDict (_be );_dg {if _ga ,_ggf :=_b .GetNameVal (_cc .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_ggf {if _ga !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _bg ,_ede :=_b .GetDict (_cc .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_ede {_ ,_ee :=_b .GetNumberAsInt64 (_bg .Get ("\u0050"));if _ee !=nil {return false ;
};_ge =true ;break ;};};};};return _ge &&_cd ._ceg .IsApplicable (sig );};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_fbab *adobePKCS7Detached )IsApplicable (sig *_gbg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};type etsiPAdES struct{_gbf *_ce .PrivateKey ;_edg *_ed .Certificate ;_feg bool ;_cfd bool ;_fdf *_ed .Certificate ;_fcb string ;

// CertClient is the client used to retrieve certificates.
CertClient *_gb .CertClient ;

// OCSPClient is the client used to retrieve OCSP validation information.
OCSPClient *_gb .OCSPClient ;

// CRLClient is the client used to retrieve CRL validation information.
CRLClient *_gb .CRLClient ;_cfcc *_gbg .PdfAppender ;_bd *_gbg .DSS ;};func (_bab *etsiPAdES )makeTimestampRequest (_cce string ,_ecf []byte )(_g .RawValue ,error ){_cegb :=_gg .SHA512 .New ();_cegb .Write (_ecf );_gde :=_cegb .Sum (nil );_dae :=_ba .Request {HashAlgorithm :_gg .SHA512 ,HashedMessage :_gde ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };
_agd :=_gb .NewTimestampClient ();_fda ,_bdf :=_agd .GetEncodedToken (_cce ,&_dae );if _bdf !=nil {return _g .NullRawValue ,_bdf ;};return _g .RawValue {FullBytes :_fda },nil ;};

// Validate validates PdfSignature.
func (_ecc *etsiPAdES )Validate (sig *_gbg .PdfSignature ,digest _gbg .Hasher )(_gbg .SignatureValidationResult ,error ){_fdd :=sig .Contents .Bytes ();_bce ,_gbgg :=_da .Parse (_fdd );if _gbgg !=nil {return _gbg .SignatureValidationResult {},_gbgg ;};
_efac ,_gded :=digest .(*_a .Buffer );if !_gded {return _gbg .SignatureValidationResult {},_cf .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_bce .Content =_efac .Bytes ();if _gbgg =_bce .Verify ();
_gbgg !=nil {return _gbg .SignatureValidationResult {},_gbgg ;};_ffg :=false ;_bgfc :=false ;var _eebd _c .Time ;for _ ,_bdg :=range _bce .Signers {_acd :=_bdg .EncryptedDigest ;var _cgfg RevocationInfoArchival ;_gbgg =_bce .UnmarshalSignedAttribute (_da .OIDAttributeAdobeRevocation ,&_cgfg );
if _gbgg ==nil {if len (_cgfg .Crl )> 0{_bgfc =true ;};if len (_cgfg .Ocsp )> 0{_ffg =true ;};};for _ ,_ccd :=range _bdg .UnauthenticatedAttributes {if _ccd .Type .Equal (_da .OIDAttributeTimeStampToken ){_eea ,_ggfg :=_ba .Parse (_ccd .Value .Bytes );
if _ggfg !=nil {return _gbg .SignatureValidationResult {},_ggfg ;};_eebd =_eea .Time ;_cba :=_eea .HashAlgorithm .New ();_cba .Write (_acd );if !_a .Equal (_cba .Sum (nil ),_eea .HashedMessage ){return _gbg .SignatureValidationResult {},_cf .Errorf ("\u0048\u0061\u0073\u0068\u0020i\u006e\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0069s\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020\u0070\u006b\u0063\u0073\u0037");
};break ;};};};_aagb :=_gbg .SignatureValidationResult {IsSigned :true ,IsVerified :true ,IsCrlFound :_bgfc ,IsOcspFound :_ffg ,GeneralizedTime :_eebd };return _aagb ,nil ;};

// InitSignature initialises the PdfSignature.
func (_cff *etsiPAdES )InitSignature (sig *_gbg .PdfSignature )error {if !_cff ._feg {if _cff ._edg ==nil {return _fg .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _cff ._gbf ==nil {return _fg .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_ecd :=*_cff ;sig .Handler =&_ecd ;sig .Filter =_b .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_b .MakeName ("\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_ab ,_gbd :=_ecd .NewDigest (sig );if _gbd !=nil {return _gbd ;};_ ,_gbd =_ab .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _gbd !=nil {return _gbd ;};_ecd ._cfd =true ;_gbd =_ecd .Sign (sig ,_ab );_ecd ._cfd =false ;return _gbd ;};