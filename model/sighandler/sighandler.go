//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_fd "bytes";_dgd "crypto";_bg "crypto/rand";_c "crypto/rsa";_bd "crypto/x509";_gg "crypto/x509/pkix";_be "encoding/asn1";_g "encoding/hex";_b "errors";_f "fmt";_bc "github.com/unidoc/pkcs7";_ef "github.com/unidoc/timestamp";
_fde "github.com/unidoc/unipdf/v4/common";_ge "github.com/unidoc/unipdf/v4/core";_df "github.com/unidoc/unipdf/v4/model";_cb "github.com/unidoc/unipdf/v4/model/mdp";_fb "github.com/unidoc/unipdf/v4/model/sigutil";_dg "hash";_d "math/big";_e "strings";_af "time";
);

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_bae *etsiPAdES )IsApplicable (sig *_df .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_eee *docTimeStamp )IsApplicable (sig *_df .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};

// InitSignature initialization of the DocMDP signature.
func (_gce *DocMDPHandler )InitSignature (sig *_df .PdfSignature )error {_dfg :=_gce ._cc .InitSignature (sig );if _dfg !=nil {return _dfg ;};sig .Handler =_gce ;if sig .Reference ==nil {sig .Reference =_ge .MakeArray ();};sig .Reference .Append (_df .NewPdfSignatureReferenceDocMDP (_df .NewPdfTransformParamsDocMDP (_gce .Permission )).ToPdfObject ());
return nil ;};func (_fda *etsiPAdES )makeTimestampRequest (_gcb string ,_ga []byte )(_be .RawValue ,error ){_age :=_dgd .SHA512 .New ();_age .Write (_ga );_fe :=_age .Sum (nil );_dcf :=_ef .Request {HashAlgorithm :_dgd .SHA512 ,HashedMessage :_fe ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };
_eea :=_fb .NewTimestampClient ();_fgd ,_cce :=_eea .GetEncodedToken (_gcb ,&_dcf );if _cce !=nil {return _be .NullRawValue ,_cce ;};return _be .RawValue {FullBytes :_fgd },nil ;};func (_dd *etsiPAdES )getOCSPs (_bcc []*_bd .Certificate ,_cbge map[string ]*_bd .Certificate )([][]byte ,error ){_cee :=make ([][]byte ,0,len (_bcc ));
for _ ,_eb :=range _bcc {for _ ,_cfb :=range _eb .OCSPServer {if _dd .CertClient .IsCA (_eb ){continue ;};_cg ,_faf :=_cbge [_eb .Issuer .CommonName ];if !_faf {_fde .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
continue ;};_ ,_ff ,_cfd :=_dd .OCSPClient .MakeRequest (_cfb ,_eb ,_cg );if _cfd !=nil {_fde .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076",_cfd );
continue ;};_cee =append (_cee ,_ff );};};return _cee ,nil ;};type docTimeStamp struct{_baa string ;_gab _dgd .Hash ;_ageb int ;_bca *_fb .TimestampClient ;};

// NewEtsiPAdESLevelT creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
func NewEtsiPAdESLevelT (privateKey *_c .PrivateKey ,certificate *_bd .Certificate ,caCert *_bd .Certificate ,certificateTimestampServerURL string )(_df .SignatureHandler ,error ){return &etsiPAdES {_ee :certificate ,_gec :privateKey ,_gf :caCert ,_aae :certificateTimestampServerURL },nil ;
};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_bd .Certificate ,signFunc SignFunc )(_df .SignatureHandler ,error ){return &adobeX509RSASHA1 {_def :certificate ,_efa :signFunc },nil ;};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_cc _df .SignatureHandler ;Permission _cb .DocMDPPermission ;};

// Validate validates PdfSignature.
func (_gdbe *adobePKCS7Detached )Validate (sig *_df .PdfSignature ,digest _df .Hasher )(_df .SignatureValidationResult ,error ){_afbd :=sig .Contents .Bytes ();_dfec ,_cab :=_bc .Parse (_afbd );if _cab !=nil {return _df .SignatureValidationResult {},_cab ;
};_fgcc ,_dda :=digest .(*_fd .Buffer );if !_dda {return _df .SignatureValidationResult {},_f .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_dfec .Content =_fgcc .Bytes ();if _cab =_dfec .Verify ();
_cab !=nil {return _df .SignatureValidationResult {},_cab ;};return _df .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// NewEtsiPAdESLevelB creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
func NewEtsiPAdESLevelB (privateKey *_c .PrivateKey ,certificate *_bd .Certificate ,caCert *_bd .Certificate )(_df .SignatureHandler ,error ){return &etsiPAdES {_ee :certificate ,_gec :privateKey ,_gf :caCert },nil ;};func (_cae *adobeX509RSASHA1 )sign (_daa *_df .PdfSignature ,_ggbd _df .Hasher ,_ggc bool )error {if !_ggc {return _cae .Sign (_daa ,_ggbd );
};_ebe ,_ddd :=_cae ._def .PublicKey .(*_c .PublicKey );if !_ddd {return _f .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_ebe );};_dbg ,_eadb :=_be .Marshal (make ([]byte ,_ebe .Size ()));
if _eadb !=nil {return _eadb ;};_daa .Contents =_ge .MakeHexString (string (_dbg ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ccdc *adobeX509RSASHA1 )IsApplicable (sig *_df .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};type adobeX509RSASHA1 struct{_daf *_c .PrivateKey ;_def *_bd .Certificate ;_efa SignFunc ;_cdge bool ;_dgg _dgd .Hash ;};func (_gddc *adobePKCS7Detached )getCertificate (_fbg *_df .PdfSignature )(*_bd .Certificate ,error ){if _gddc ._eba !=nil {return _gddc ._eba ,nil ;
};_edc ,_dbdeb :=_fbg .GetCerts ();if _dbdeb !=nil {return nil ,_dbdeb ;};return _edc [0],nil ;};func (_bbaee *adobeX509RSASHA1 )getCertificate (_dfgc *_df .PdfSignature )(*_bd .Certificate ,error ){if _bbaee ._def !=nil {return _bbaee ._def ,nil ;};_bbe ,_cfe :=_dfgc .GetCerts ();
if _cfe !=nil {return nil ,_cfe ;};return _bbe [0],nil ;};

// InitSignature initialises the PdfSignature.
func (_gfg *etsiPAdES )InitSignature (sig *_df .PdfSignature )error {if !_gfg ._bbg {if _gfg ._ee ==nil {return _b .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _gfg ._gec ==nil {return _b .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_gga :=*_gfg ;sig .Handler =&_gga ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_ge .MakeName ("\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_cbb ,_aea :=_gga .NewDigest (sig );if _aea !=nil {return _aea ;};_ ,_aea =_cbb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _aea !=nil {return _aea ;};_gga ._afc =true ;_aea =_gga .Sign (sig ,_cbb );_gga ._afc =false ;return _aea ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_bd .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_df .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_def :certificate ,_efa :signFunc ,_cdge :opts .EstimateSize ,_dgg :opts .Algorithm },nil ;
};func (_ffc *etsiPAdES )addDss (_eed ,_bgb []*_bd .Certificate ,_ebd *RevocationInfoArchival )(int ,error ){_dff ,_dcb ,_dfbe :=_ffc .buildCertChain (_eed ,_bgb );if _dfbe !=nil {return 0,_dfbe ;};_bdf ,_dfbe :=_ffc .getCerts (_dff );if _dfbe !=nil {return 0,_dfbe ;
};var _fag ,_afd [][]byte ;if _ffc .OCSPClient !=nil {_fag ,_dfbe =_ffc .getOCSPs (_dff ,_dcb );if _dfbe !=nil {return 0,_dfbe ;};};if _ffc .CRLClient !=nil {_afd ,_dfbe =_ffc .getCRLs (_dff );if _dfbe !=nil {return 0,_dfbe ;};};if !_ffc ._afc {_ ,_dfbe =_ffc ._cd .AddCerts (_bdf );
if _dfbe !=nil {return 0,_dfbe ;};_ ,_dfbe =_ffc ._cd .AddOCSPs (_fag );if _dfbe !=nil {return 0,_dfbe ;};_ ,_dfbe =_ffc ._cd .AddCRLs (_afd );if _dfbe !=nil {return 0,_dfbe ;};};_bbae :=0;for _ ,_bfa :=range _afd {_bbae +=len (_bfa );_ebd .Crl =append (_ebd .Crl ,_be .RawValue {FullBytes :_bfa });
};for _ ,_ace :=range _fag {_bbae +=len (_ace );_ebd .Ocsp =append (_ebd .Ocsp ,_be .RawValue {FullBytes :_ace });};return _bbae ,nil ;};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_cba *DocMDPHandler )ValidateWithOpts (sig *_df .PdfSignature ,digest _df .Hasher ,params _df .SignatureHandlerDocMDPParams )(_df .SignatureValidationResult ,error ){_gd ,_cbg :=_cba ._cc .Validate (sig ,digest );if _cbg !=nil {return _gd ,_cbg ;
};_db :=params .Parser ;if _db ==nil {return _df .SignatureValidationResult {},_b .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_gd .IsVerified {return _gd ,nil ;};_dbd :=params .DiffPolicy ;
if _dbd ==nil {_dbd =_cb .NewDefaultDiffPolicy ();};for _gc :=0;_gc <=_db .GetRevisionNumber ();_gc ++{_bdg ,_dbda :=_db .GetRevision (_gc );if _dbda !=nil {return _df .SignatureValidationResult {},_dbda ;};_gbc :=_bdg .GetTrailer ();if _gbc ==nil {return _df .SignatureValidationResult {},_b .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_ea ,_beb :=_ge .GetDict (_gbc .Get ("\u0052\u006f\u006f\u0074"));if !_beb {return _df .SignatureValidationResult {},_b .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");
};_fg ,_beb :=_ge .GetDict (_ea .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_beb {continue ;};_bge ,_beb :=_ge .GetArray (_fg .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_beb {continue ;};for _ ,_ggb :=range _bge .Elements (){_bcd ,_gbg :=_ge .GetDict (_ggb );
if !_gbg {continue ;};_dcd ,_gbg :=_ge .GetDict (_bcd .Get ("\u0056"));if !_gbg {continue ;};if _ge .EqualObjects (_dcd .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_gd .DiffResults ,_dbda =_dbd .ReviewFile (_bdg ,_db ,&_cb .MDPParameters {DocMDPLevel :_cba .Permission });
if _dbda !=nil {return _df .SignatureValidationResult {},_dbda ;};_gd .IsVerified =_gd .DiffResults .IsPermitted ();return _gd ,nil ;};};};return _df .SignatureValidationResult {},_b .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _dgd .Hash )(_df .SignatureHandler ,error ){return &docTimeStamp {_baa :timestampServerURL ,_gab :hashAlgorithm },nil ;};

// InitSignature initialises the PdfSignature.
func (_dfed *adobePKCS7Detached )InitSignature (sig *_df .PdfSignature )error {if !_dfed ._bggc {if _dfed ._eba ==nil {return _b .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _dfed ._agf ==nil {return _b .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_fge :=*_dfed ;sig .Handler =&_fge ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_ge .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_ccgf ,_fac :=_fge .NewDigest (sig );if _fac !=nil {return _fac ;};_ccgf .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _fge .Sign (sig ,_ccgf );};func (_ceb *etsiPAdES )getCRLs (_ebf []*_bd .Certificate )([][]byte ,error ){_bcg :=make ([][]byte ,0,len (_ebf ));for _ ,_gdd :=range _ebf {for _ ,_dgdc :=range _gdd .CRLDistributionPoints {if _ceb .CertClient .IsCA (_gdd ){continue ;
};_ebc ,_bbac :=_ceb .CRLClient .MakeRequest (_dgdc ,_gdd );if _bbac !=nil {_fde .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076",_bbac );continue ;
};_bcg =append (_bcg ,_ebc );};};return _bcg ,nil ;};

// Validate validates PdfSignature.
func (_bde *adobeX509RSASHA1 )Validate (sig *_df .PdfSignature ,digest _df .Hasher )(_df .SignatureValidationResult ,error ){_ggag ,_dde :=_bde .getCertificate (sig );if _dde !=nil {return _df .SignatureValidationResult {},_dde ;};_eaee :=sig .Contents .Bytes ();
var _gfc []byte ;if _ ,_fcc :=_be .Unmarshal (_eaee ,&_gfc );_fcc !=nil {return _df .SignatureValidationResult {},_fcc ;};_cca ,_ddag :=digest .(_dg .Hash );if !_ddag {return _df .SignatureValidationResult {},_b .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_aab ,_ :=_bde .getHashAlgorithm (sig );if _aab ==0{_aab =_ab ;};if _bbbc :=_c .VerifyPKCS1v15 (_ggag .PublicKey .(*_c .PublicKey ),_aab ,_cca .Sum (nil ),_gfc );_bbbc !=nil {return _df .SignatureValidationResult {},_bbbc ;};return _df .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// Validate validates PdfSignature.
func (_bda *docTimeStamp )Validate (sig *_df .PdfSignature ,digest _df .Hasher )(_df .SignatureValidationResult ,error ){_bbgb :=sig .Contents .Bytes ();_cgb ,_ccgd :=_bc .Parse (_bbgb );if _ccgd !=nil {return _df .SignatureValidationResult {},_ccgd ;};
if _ccgd =_cgb .Verify ();_ccgd !=nil {return _df .SignatureValidationResult {},_ccgd ;};var _gacb timestampInfo ;_ ,_ccgd =_be .Unmarshal (_cgb .Content ,&_gacb );if _ccgd !=nil {return _df .SignatureValidationResult {},_ccgd ;};_dec ,_ccgd :=_egad (_gacb .MessageImprint .HashAlgorithm .Algorithm );
if _ccgd !=nil {return _df .SignatureValidationResult {},_ccgd ;};_dcgd :=_dec .New ();_cdbd ,_aeaa :=digest .(*_fd .Buffer );if !_aeaa {return _df .SignatureValidationResult {},_f .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");
};_dcgd .Write (_cdbd .Bytes ());_cac :=_dcgd .Sum (nil );_adc :=_df .SignatureValidationResult {IsSigned :true ,IsVerified :_fd .Equal (_cac ,_gacb .MessageImprint .HashedMessage ),GeneralizedTime :_gacb .GeneralizedTime };return _adc ,nil ;};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _df .SignatureHandler ,permission _cb .DocMDPPermission )(_df .SignatureHandler ,error ){return &DocMDPHandler {_cc :handler ,Permission :permission },nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_ecgc *_df .PdfSignature ,_dfa _df .Hasher )([]byte ,error );

// NewDigest creates a new digest.
func (_cfa *docTimeStamp )NewDigest (sig *_df .PdfSignature )(_df .Hasher ,error ){return _fd .NewBuffer (nil ),nil ;};func _egad (_dggb _be .ObjectIdentifier )(_dgd .Hash ,error ){switch {case _dggb .Equal (_bc .OIDDigestAlgorithmSHA1 ),_dggb .Equal (_bc .OIDDigestAlgorithmECDSASHA1 ),_dggb .Equal (_bc .OIDDigestAlgorithmDSA ),_dggb .Equal (_bc .OIDDigestAlgorithmDSASHA1 ),_dggb .Equal (_bc .OIDEncryptionAlgorithmRSA ):return _dgd .SHA1 ,nil ;
case _dggb .Equal (_bc .OIDDigestAlgorithmSHA256 ),_dggb .Equal (_bc .OIDDigestAlgorithmECDSASHA256 ):return _dgd .SHA256 ,nil ;case _dggb .Equal (_bc .OIDDigestAlgorithmSHA384 ),_dggb .Equal (_bc .OIDDigestAlgorithmECDSASHA384 ):return _dgd .SHA384 ,nil ;
case _dggb .Equal (_bc .OIDDigestAlgorithmSHA512 ),_dggb .Equal (_bc .OIDDigestAlgorithmECDSASHA512 ):return _dgd .SHA512 ,nil ;};return _dgd .Hash (0),_bc .ErrUnsupportedAlgorithm ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_c .PrivateKey ,certificate *_bd .Certificate )(_df .SignatureHandler ,error ){return &adobePKCS7Detached {_eba :certificate ,_agf :privateKey },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_eag *docTimeStamp )Sign (sig *_df .PdfSignature ,digest _df .Hasher )error {_ccee ,_fcgb :=_fb .NewTimestampRequest (digest .(*_fd .Buffer ),&_ef .RequestOptions {Hash :_eag ._gab ,Certificates :true });if _fcgb !=nil {return _fcgb ;};_gdfa :=_eag ._bca ;
if _gdfa ==nil {_gdfa =_fb .NewTimestampClient ();};_ggcg ,_fcgb :=_gdfa .GetEncodedToken (_eag ._baa ,_ccee );if _fcgb !=nil {return _fcgb ;};_ddab :=len (_ggcg );if _eag ._ageb > 0&&_ddab > _eag ._ageb {return _df .ErrSignNotEnoughSpace ;};if _ddab > 0{_eag ._ageb =_ddab +128;
};if sig .Contents !=nil {_ceeg :=sig .Contents .Bytes ();copy (_ceeg ,_ggcg );_ggcg =_ceeg ;};sig .Contents =_ge .MakeHexString (string (_ggcg ));return nil ;};

// Validate validates PdfSignature.
func (_gdb *etsiPAdES )Validate (sig *_df .PdfSignature ,digest _df .Hasher )(_df .SignatureValidationResult ,error ){_bed :=sig .Contents .Bytes ();_cag ,_agb :=_bc .Parse (_bed );if _agb !=nil {return _df .SignatureValidationResult {},_agb ;};_dcg ,_ebb :=digest .(*_fd .Buffer );
if !_ebb {return _df .SignatureValidationResult {},_f .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_cag .Content =_dcg .Bytes ();if _agb =_cag .Verify ();_agb !=nil {return _df .SignatureValidationResult {},_agb ;
};_dbc :=false ;_dgfb :=false ;var _gbcf _af .Time ;for _ ,_dgb :=range _cag .Signers {_edd :=_dgb .EncryptedDigest ;var _ebfc RevocationInfoArchival ;_agb =_cag .UnmarshalSignedAttribute (_bc .OIDAttributeAdobeRevocation ,&_ebfc );if _agb ==nil {if len (_ebfc .Crl )> 0{_dgfb =true ;
};if len (_ebfc .Ocsp )> 0{_dbc =true ;};};for _ ,_ccd :=range _dgb .UnauthenticatedAttributes {if _ccd .Type .Equal (_bc .OIDAttributeTimeStampToken ){_cdbbf ,_fcbg :=_ef .Parse (_ccd .Value .Bytes );if _fcbg !=nil {return _df .SignatureValidationResult {},_fcbg ;
};_gbcf =_cdbbf .Time ;_fcba :=_cdbbf .HashAlgorithm .New ();_fcba .Write (_edd );if !_fd .Equal (_fcba .Sum (nil ),_cdbbf .HashedMessage ){return _df .SignatureValidationResult {},_f .Errorf ("\u0048\u0061\u0073\u0068\u0020i\u006e\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0069s\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020\u0070\u006b\u0063\u0073\u0037");
};break ;};};};_dba :=_df .SignatureValidationResult {IsSigned :true ,IsVerified :true ,IsCrlFound :_dgfb ,IsOcspFound :_dbc ,GeneralizedTime :_gbcf };return _dba ,nil ;};

// NewDigest creates a new digest.
func (_bgee *adobePKCS7Detached )NewDigest (sig *_df .PdfSignature )(_df .Hasher ,error ){return _fd .NewBuffer (nil ),nil ;};func (_gdg *etsiPAdES )buildCertChain (_dfba ,_afa []*_bd .Certificate )([]*_bd .Certificate ,map[string ]*_bd .Certificate ,error ){_ec :=map[string ]*_bd .Certificate {};
for _ ,_ecb :=range _dfba {_ec [_ecb .Subject .CommonName ]=_ecb ;};_bgg :=_dfba ;for _ ,_fca :=range _afa {_eef :=_fca .Subject .CommonName ;if _ ,_ffb :=_ec [_eef ];_ffb {continue ;};_ec [_eef ]=_fca ;_bgg =append (_bgg ,_fca );};if len (_bgg )==0{return nil ,nil ,_df .ErrSignNoCertificates ;
};var _dfe error ;for _cdg :=_bgg [0];_cdg !=nil &&!_gdg .CertClient .IsCA (_cdg );{var _ffg *_bd .Certificate ;_ ,_bdb :=_ec [_cdg .Issuer .CommonName ];if !_bdb {if _ffg ,_dfe =_gdg .CertClient .GetIssuer (_cdg );_dfe !=nil {_fde .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076",_dfe );
break ;};_ec [_cdg .Issuer .CommonName ]=_ffg ;_bgg =append (_bgg ,_ffg );}else {break ;};_cdg =_ffg ;};return _bgg ,_ec ,nil ;};

// NewDigest creates a new digest.
func (_ag *DocMDPHandler )NewDigest (sig *_df .PdfSignature )(_df .Hasher ,error ){return _ag ._cc .NewDigest (sig );};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_aaf *DocMDPHandler )Validate (sig *_df .PdfSignature ,digest _df .Hasher )(_df .SignatureValidationResult ,error ){return _df .SignatureValidationResult {},_b .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};

// NewDigest creates a new digest.
func (_bgea *etsiPAdES )NewDigest (_ *_df .PdfSignature )(_df .Hasher ,error ){return _fd .NewBuffer (nil ),nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_bbf *adobeX509RSASHA1 )Sign (sig *_df .PdfSignature ,digest _df .Hasher )error {var _gfcd []byte ;var _acd error ;if _bbf ._efa !=nil {_gfcd ,_acd =_bbf ._efa (sig ,digest );if _acd !=nil {return _acd ;};}else {_eedg ,_gbd :=digest .(_dg .Hash );
if !_gbd {return _b .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_abb :=_ab ;if _bbf ._dgg !=0{_abb =_bbf ._dgg ;};_gfcd ,_acd =_c .SignPKCS1v15 (_bg .Reader ,_bbf ._daf ,_abb ,_eedg .Sum (nil ));if _acd !=nil {return _acd ;
};};_gfcd ,_acd =_be .Marshal (_gfcd );if _acd !=nil {return _acd ;};sig .Contents =_ge .MakeHexString (string (_gfcd ));return nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_c .PrivateKey ,certificate *_bd .Certificate )(_df .SignatureHandler ,error ){return &adobeX509RSASHA1 {_def :certificate ,_daf :privateKey },nil ;};

// Sign sets the Contents fields.
func (_ega *adobePKCS7Detached )Sign (sig *_df .PdfSignature ,digest _df .Hasher )error {if _ega ._bggc {_ffd :=_ega ._da ;if _ffd <=0{_ffd =8192;};sig .Contents =_ge .MakeHexString (string (make ([]byte ,_ffd )));return nil ;};_dbfe ,_fgca :=digest .(*_fd .Buffer );
if !_fgca {return _f .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_afcf ,_fbc :=_bc .NewSignedData (_dbfe .Bytes ());if _fbc !=nil {return _fbc ;};if _de :=_afcf .AddSigner (_ega ._eba ,_ega ._agf ,_bc .SignerInfoConfig {});
_de !=nil {return _de ;};_afcf .Detach ();_eae ,_fbc :=_afcf .Finish ();if _fbc !=nil {return _fbc ;};_ddaf :=make ([]byte ,8192);copy (_ddaf ,_eae );sig .Contents =_ge .MakeHexString (string (_ddaf ));return nil ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _dgd .Hash ,opts *DocTimeStampOpts )(_df .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_baa :timestampServerURL ,_gab :hashAlgorithm ,_ageb :opts .SignatureSize ,_bca :opts .Client },nil ;
};

// Sign adds a new reference to signature's references array.
func (_bba *DocMDPHandler )Sign (sig *_df .PdfSignature ,digest _df .Hasher )error {return _bba ._cc .Sign (sig ,digest );};

// Sign sets the Contents fields for the PdfSignature.
func (_bfda *etsiPAdES )Sign (sig *_df .PdfSignature ,digest _df .Hasher )error {_cdb ,_gac :=digest .(*_fd .Buffer );if !_gac {return _f .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_ebcb ,_ed :=_bc .NewSignedData (_cdb .Bytes ());
if _ed !=nil {return _ed ;};_ebcb .SetDigestAlgorithm (_bc .OIDDigestAlgorithmSHA256 );_eaa :=_bc .SignerInfoConfig {};_aga :=_dgd .SHA256 .New ();_aga .Write (_bfda ._ee .Raw );var _egdg struct{Seq struct{Seq struct{Value []byte ;};};};_egdg .Seq .Seq .Value =_aga .Sum (nil );
var _aac []*_bd .Certificate ;var _ddb []*_bd .Certificate ;if _bfda ._gf !=nil {_ddb =[]*_bd .Certificate {_bfda ._gf };};_geg :=RevocationInfoArchival {Crl :[]_be .RawValue {},Ocsp :[]_be .RawValue {},OtherRevInfo :[]_be .RawValue {}};_bbc :=0;if _bfda ._eg !=nil &&len (_bfda ._aae )> 0{_afg ,_fdg :=_bfda .makeTimestampRequest (_bfda ._aae ,([]byte )(""));
if _fdg !=nil {return _fdg ;};_cbd ,_fdg :=_ef .Parse (_afg .FullBytes );if _fdg !=nil {return _fdg ;};_aac =append (_aac ,_cbd .Certificates ...);};if _bfda ._eg !=nil {_bbcf ,_ecg :=_bfda .addDss ([]*_bd .Certificate {_bfda ._ee },_ddb ,&_geg );if _ecg !=nil {return _ecg ;
};_bbc +=_bbcf ;if len (_aac )> 0{_bbcf ,_ecg =_bfda .addDss (_aac ,nil ,&_geg );if _ecg !=nil {return _ecg ;};_bbc +=_bbcf ;};if !_bfda ._afc {_bfda ._eg .SetDSS (_bfda ._cd );};};_eaa .ExtraSignedAttributes =append (_eaa .ExtraSignedAttributes ,_bc .Attribute {Type :_bc .OIDAttributeSigningCertificateV2 ,Value :_egdg },_bc .Attribute {Type :_bc .OIDAttributeAdobeRevocation ,Value :_geg });
if _dgf :=_ebcb .AddSignerChainPAdES (_bfda ._ee ,_bfda ._gec ,_ddb ,_eaa );_dgf !=nil {return _dgf ;};_ebcb .Detach ();if len (_bfda ._aae )> 0{_aaca :=_ebcb .GetSignedData ().SignerInfos [0].EncryptedDigest ;_cfg ,_ccg :=_bfda .makeTimestampRequest (_bfda ._aae ,_aaca );
if _ccg !=nil {return _ccg ;};_ccg =_ebcb .AddTimestampTokenToSigner (0,_cfg .FullBytes );if _ccg !=nil {return _ccg ;};};_dfgg ,_ed :=_ebcb .Finish ();if _ed !=nil {return _ed ;};_fgc :=make ([]byte ,len (_dfgg )+1024*2+_bbc );copy (_fgc ,_dfgg );sig .Contents =_ge .MakeHexString (string (_fgc ));
if !_bfda ._afc &&_bfda ._cd !=nil {_aga =_dgd .SHA1 .New ();_aga .Write (_fgc );_cced :=_e .ToUpper (_g .EncodeToString (_aga .Sum (nil )));if _cced !=""{_bfda ._cd .VRI [_cced ]=&_df .VRI {Cert :_bfda ._cd .Certs ,OCSP :_bfda ._cd .OCSPs ,CRL :_bfda ._cd .CRLs };
};_bfda ._eg .SetDSS (_bfda ._cd );};return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_bf *DocMDPHandler )IsApplicable (sig *_df .PdfSignature )bool {_dc :=false ;for _ ,_ba :=range sig .Reference .Elements (){if _bec ,_aa :=_ge .GetDict (_ba );_aa {if _dfb ,_ce :=_ge .GetNameVal (_bec .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_ce {if _dfb !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _bb ,_gb :=_ge .GetDict (_bec .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_gb {_ ,_bbb :=_ge .GetNumberAsInt64 (_bb .Get ("\u0050"));
if _bbb !=nil {return false ;};_dc =true ;break ;};};};};return _dc &&_bf ._cc .IsApplicable (sig );};func (_aed *docTimeStamp )getCertificate (_gfed *_df .PdfSignature )(*_bd .Certificate ,error ){_cdbe ,_ebda :=_gfed .GetCerts ();if _ebda !=nil {return nil ,_ebda ;
};return _cdbe [0],nil ;};

// NewEtsiPAdESLevelLT creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
func NewEtsiPAdESLevelLT (privateKey *_c .PrivateKey ,certificate *_bd .Certificate ,caCert *_bd .Certificate ,certificateTimestampServerURL string ,appender *_df .PdfAppender )(_df .SignatureHandler ,error ){_cf :=appender .Reader .DSS ;if _cf ==nil {_cf =_df .NewDSS ();
};if _efb :=_cf .GenerateHashMaps ();_efb !=nil {return nil ,_efb ;};return &etsiPAdES {_ee :certificate ,_gec :privateKey ,_gf :caCert ,_aae :certificateTimestampServerURL ,CertClient :_fb .NewCertClient (),OCSPClient :_fb .NewOCSPClient (),CRLClient :_fb .NewCRLClient (),_eg :appender ,_cd :_cf },nil ;
};type timestampInfo struct{Version int ;Policy _be .RawValue ;MessageImprint struct{HashAlgorithm _gg .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _be .RawValue ;GeneralizedTime _af .Time ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_fb .TimestampClient ;};func _cdd (_gdf *_c .PublicKey ,_ddc []byte )_dgd .Hash {_ccede :=_gdf .Size ();if _ccede !=len (_ddc ){return 0;};_ffa :=func (_gced *_d .Int ,_gad *_c .PublicKey ,_ffac *_d .Int )*_d .Int {_efbc :=_d .NewInt (int64 (_gad .E ));
_gced .Exp (_ffac ,_efbc ,_gad .N );return _gced ;};_bbbe :=new (_d .Int ).SetBytes (_ddc );_dgfbf :=_ffa (new (_d .Int ),_gdf ,_bbbe );_aeb :=_cda (_dgfbf .Bytes (),_ccede );if _aeb [0]!=0||_aeb [1]!=1{return 0;};_ffeg :=[]struct{Hash _dgd .Hash ;Prefix []byte ;
}{{Hash :_dgd .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_dgd .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_dgd .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_dgd .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_dgd .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_ecgca :=range _ffeg {_ege :=_ecgca .Hash .Size ();_dcfc :=len (_ecgca .Prefix )+_ege ;if _fd .Equal (_aeb [_ccede -_dcfc :_ccede -_ege ],_ecgca .Prefix ){return _ecgca .Hash ;};};return 0;};func _cda (_fgce []byte ,_fdf int )(_bga []byte ){_gbcg :=len (_fgce );
if _gbcg > _fdf {_gbcg =_fdf ;};_bga =make ([]byte ,_fdf );copy (_bga [len (_bga )-_gbcg :],_fgce );return ;};func (_dcfa *adobeX509RSASHA1 )getHashAlgorithm (_dac *_df .PdfSignature )(_dgd .Hash ,error ){_dgga ,_feb :=_dcfa .getCertificate (_dac );if _feb !=nil {if _dcfa ._dgg !=0{return _dcfa ._dgg ,nil ;
};return _ab ,_feb ;};if _dac .Contents !=nil {_fab :=_dac .Contents .Bytes ();var _abc []byte ;if _ ,_ffe :=_be .Unmarshal (_fab ,&_abc );_ffe ==nil {_fgccd :=_cdd (_dgga .PublicKey .(*_c .PublicKey ),_abc );if _fgccd > 0{return _fgccd ,nil ;};};};if _dcfa ._dgg !=0{return _dcfa ._dgg ,nil ;
};return _ab ,nil ;};

// RevocationInfoArchival is OIDAttributeAdobeRevocation attribute.
type RevocationInfoArchival struct{Crl []_be .RawValue `asn1:"explicit,tag:0,optional"`;Ocsp []_be .RawValue `asn1:"explicit,tag:1,optional"`;OtherRevInfo []_be .RawValue `asn1:"explicit,tag:2,optional"`;};func (_bfd *etsiPAdES )getCerts (_ceg []*_bd .Certificate )([][]byte ,error ){_add :=make ([][]byte ,0,len (_ceg ));
for _ ,_dbf :=range _ceg {_add =append (_add ,_dbf .Raw );};return _add ,nil ;};

// NewDigest creates a new digest.
func (_cea *adobeX509RSASHA1 )NewDigest (sig *_df .PdfSignature )(_df .Hasher ,error ){if _ged ,_ebg :=_cea .getHashAlgorithm (sig );_ged !=0&&_ebg ==nil {return _ged .New (),nil ;};return _ab .New (),nil ;};

// InitSignature initialises the PdfSignature.
func (_fcg *adobeX509RSASHA1 )InitSignature (sig *_df .PdfSignature )error {if _fcg ._def ==nil {return _b .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _fcg ._daf ==nil &&_fcg ._efa ==nil {return _b .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_ada :=*_fcg ;sig .Handler =&_ada ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_ge .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_ge .MakeString (string (_ada ._def .Raw ));sig .Reference =nil ;_fdc ,_fgf :=_ada .NewDigest (sig );if _fgf !=nil {return _fgf ;};_fdc .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _ada .sign (sig ,_fdc ,_fcg ._cdge );};const _ab =_dgd .SHA1 ;

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_dcc *adobePKCS7Detached )IsApplicable (sig *_df .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _dgd .Hash ;};type etsiPAdES struct{_gec *_c .PrivateKey ;_ee *_bd .Certificate ;_bbg bool ;_afc bool ;_gf *_bd .Certificate ;_aae string ;

// CertClient is the client used to retrieve certificates.
CertClient *_fb .CertClient ;

// OCSPClient is the client used to retrieve OCSP validation information.
OCSPClient *_fb .OCSPClient ;

// CRLClient is the client used to retrieve CRL validation information.
CRLClient *_fb .CRLClient ;_eg *_df .PdfAppender ;_cd *_df .DSS ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_df .SignatureHandler ,error ){return &adobePKCS7Detached {_bggc :true ,_da :signatureLen },nil ;};

// InitSignature initialises the PdfSignature.
func (_adf *docTimeStamp )InitSignature (sig *_df .PdfSignature )error {_cbc :=*_adf ;sig .Type =_ge .MakeName ("\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070");sig .Handler =&_cbc ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_ge .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _adf ._ageb > 0{sig .Contents =_ge .MakeHexString (string (make ([]byte ,_adf ._ageb )));}else {_dfd ,_gfe :=_adf .NewDigest (sig );
if _gfe !=nil {return _gfe ;};_dfd .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _gfe =_cbc .Sign (sig ,_dfd );
_gfe !=nil {return _gfe ;};_adf ._ageb =_cbc ._ageb ;};return nil ;};type adobePKCS7Detached struct{_agf *_c .PrivateKey ;_eba *_bd .Certificate ;_bggc bool ;_da int ;};