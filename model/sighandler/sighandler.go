//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_fe "bytes";_d "crypto";_ggc "crypto/rand";_adf "crypto/rsa";_ed "crypto/x509";_gg "crypto/x509/pkix";_ad "encoding/asn1";_bec "encoding/hex";_b "errors";_a "fmt";_ba "github.com/unidoc/pkcs7";_bd "github.com/unidoc/timestamp";
_fc "github.com/unidoc/unipdf/v3/common";_cd "github.com/unidoc/unipdf/v3/core";_gb "github.com/unidoc/unipdf/v3/model";_gc "github.com/unidoc/unipdf/v3/model/mdp";_db "github.com/unidoc/unipdf/v3/model/sigutil";_be "hash";_g "math/big";_e "strings";_c "time";
);const _fccc =_d .SHA1 ;

// Validate validates PdfSignature.
func (_eca *etsiPAdES )Validate (sig *_gb .PdfSignature ,digest _gb .Hasher )(_gb .SignatureValidationResult ,error ){_bgdb :=sig .Contents .Bytes ();_bfbf ,_age :=_ba .Parse (_bgdb );if _age !=nil {return _gb .SignatureValidationResult {},_age ;};_efc ,_dbe :=digest .(*_fe .Buffer );
if !_dbe {return _gb .SignatureValidationResult {},_a .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_bfbf .Content =_efc .Bytes ();if _age =_bfbf .Verify ();_age !=nil {return _gb .SignatureValidationResult {},_age ;
};_beb :=false ;_fbgc :=false ;var _fgf _c .Time ;for _ ,_eee :=range _bfbf .Signers {_gca :=_eee .EncryptedDigest ;var _acc RevocationInfoArchival ;_age =_bfbf .UnmarshalSignedAttribute (_ba .OIDAttributeAdobeRevocation ,&_acc );if _age ==nil {if len (_acc .Crl )> 0{_fbgc =true ;
};if len (_acc .Ocsp )> 0{_beb =true ;};};for _ ,_bfg :=range _eee .UnauthenticatedAttributes {if _bfg .Type .Equal (_ba .OIDAttributeTimeStampToken ){_afc ,_daa :=_bd .Parse (_bfg .Value .Bytes );if _daa !=nil {return _gb .SignatureValidationResult {},_daa ;
};_fgf =_afc .Time ;_bef :=_afc .HashAlgorithm .New ();_bef .Write (_gca );if !_fe .Equal (_bef .Sum (nil ),_afc .HashedMessage ){return _gb .SignatureValidationResult {},_a .Errorf ("\u0048\u0061\u0073\u0068\u0020i\u006e\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0069s\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020\u0070\u006b\u0063\u0073\u0037");
};break ;};};};_feaa :=_gb .SignatureValidationResult {IsSigned :true ,IsVerified :true ,IsCrlFound :_fbgc ,IsOcspFound :_beb ,GeneralizedTime :_fgf };return _feaa ,nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_adf .PrivateKey ,certificate *_ed .Certificate )(_gb .SignatureHandler ,error ){return &adobeX509RSASHA1 {_caa :certificate ,_dfe :privateKey },nil ;};

// NewEtsiPAdESLevelB creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
func NewEtsiPAdESLevelB (privateKey *_adf .PrivateKey ,certificate *_ed .Certificate ,caCert *_ed .Certificate )(_gb .SignatureHandler ,error ){return &etsiPAdES {_ec :certificate ,_ga :privateKey ,_cca :caCert },nil ;};

// RevocationInfoArchival is OIDAttributeAdobeRevocation attribute.
type RevocationInfoArchival struct{Crl []_ad .RawValue `asn1:"explicit,tag:0,optional"`;Ocsp []_ad .RawValue `asn1:"explicit,tag:1,optional"`;OtherRevInfo []_ad .RawValue `asn1:"explicit,tag:2,optional"`;};

// Sign sets the Contents fields for the PdfSignature.
func (_cbe *etsiPAdES )Sign (sig *_gb .PdfSignature ,digest _gb .Hasher )error {_agg ,_ffe :=digest .(*_fe .Buffer );if !_ffe {return _a .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_ae ,_ebc :=_ba .NewSignedData (_agg .Bytes ());
if _ebc !=nil {return _ebc ;};_ae .SetDigestAlgorithm (_ba .OIDDigestAlgorithmSHA256 );_abbg :=_ba .SignerInfoConfig {};_fdg :=_d .SHA256 .New ();_fdg .Write (_cbe ._ec .Raw );var _afbe struct{Seq struct{Seq struct{Value []byte ;};};};_afbe .Seq .Seq .Value =_fdg .Sum (nil );
var _cgg []*_ed .Certificate ;var _egd []*_ed .Certificate ;if _cbe ._cca !=nil {_egd =[]*_ed .Certificate {_cbe ._cca };};_ecg :=RevocationInfoArchival {Crl :[]_ad .RawValue {},Ocsp :[]_ad .RawValue {},OtherRevInfo :[]_ad .RawValue {}};_gea :=0;if _cbe ._bg !=nil &&len (_cbe ._dbae )> 0{_eggc ,_ccf :=_cbe .makeTimestampRequest (_cbe ._dbae ,([]byte )(""));
if _ccf !=nil {return _ccf ;};_gbcc ,_ccf :=_bd .Parse (_eggc .FullBytes );if _ccf !=nil {return _ccf ;};_cgg =append (_cgg ,_gbcc .Certificates ...);};if _cbe ._bg !=nil {_edc ,_aee :=_cbe .addDss ([]*_ed .Certificate {_cbe ._ec },_egd ,&_ecg );if _aee !=nil {return _aee ;
};_gea +=_edc ;if len (_cgg )> 0{_edc ,_aee =_cbe .addDss (_cgg ,nil ,&_ecg );if _aee !=nil {return _aee ;};_gea +=_edc ;};if !_cbe ._fegd {_cbe ._bg .SetDSS (_cbe ._bfa );};};_abbg .ExtraSignedAttributes =append (_abbg .ExtraSignedAttributes ,_ba .Attribute {Type :_ba .OIDAttributeSigningCertificateV2 ,Value :_afbe },_ba .Attribute {Type :_ba .OIDAttributeAdobeRevocation ,Value :_ecg });
if _gbd :=_ae .AddSignerChainPAdES (_cbe ._ec ,_cbe ._ga ,_egd ,_abbg );_gbd !=nil {return _gbd ;};_ae .Detach ();if len (_cbe ._dbae )> 0{_ceg :=_ae .GetSignedData ().SignerInfos [0].EncryptedDigest ;_dbg ,_bgd :=_cbe .makeTimestampRequest (_cbe ._dbae ,_ceg );
if _bgd !=nil {return _bgd ;};_bgd =_ae .AddTimestampTokenToSigner (0,_dbg .FullBytes );if _bgd !=nil {return _bgd ;};};_fge ,_ebc :=_ae .Finish ();if _ebc !=nil {return _ebc ;};_deb :=make ([]byte ,len (_fge )+1024*2+_gea );copy (_deb ,_fge );sig .Contents =_cd .MakeHexString (string (_deb ));
if !_cbe ._fegd &&_cbe ._bfa !=nil {_fdg =_d .SHA1 .New ();_fdg .Write (_deb );_bfbe :=_e .ToUpper (_bec .EncodeToString (_fdg .Sum (nil )));if _bfbe !=""{_cbe ._bfa .VRI [_bfbe ]=&_gb .VRI {Cert :_cbe ._bfa .Certs ,OCSP :_cbe ._bfa .OCSPs ,CRL :_cbe ._bfa .CRLs };
};_cbe ._bg .SetDSS (_cbe ._bfa );};return nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_ed .Certificate ,signFunc SignFunc )(_gb .SignatureHandler ,error ){return &adobeX509RSASHA1 {_caa :certificate ,_geb :signFunc },nil ;};func (_bbg *adobePKCS7Detached )getCertificate (_eff *_gb .PdfSignature )(*_ed .Certificate ,error ){if _bbg ._bdg !=nil {return _bbg ._bdg ,nil ;
};_ggd ,_fga :=_eff .GetCerts ();if _fga !=nil {return nil ,_fga ;};return _ggd [0],nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gcab *etsiPAdES )IsApplicable (sig *_gb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// InitSignature initialises the PdfSignature.
func (_ee *etsiPAdES )InitSignature (sig *_gb .PdfSignature )error {if !_ee ._cee {if _ee ._ec ==nil {return _b .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _ee ._ga ==nil {return _b .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_cf :=*_ee ;sig .Handler =&_cf ;sig .Filter =_cd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_cd .MakeName ("\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_fa ,_ece :=_cf .NewDigest (sig );if _ece !=nil {return _ece ;};_ ,_ece =_fa .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _ece !=nil {return _ece ;};_cf ._fegd =true ;_ece =_cf .Sign (sig ,_fa );_cf ._fegd =false ;return _ece ;};func (_aegg *docTimeStamp )getCertificate (_eef *_gb .PdfSignature )(*_ed .Certificate ,error ){_afca ,_edgg :=_eef .GetCerts ();if _edgg !=nil {return nil ,_edgg ;
};return _afca [0],nil ;};func (_fecg *adobeX509RSASHA1 )getCertificate (_gbe *_gb .PdfSignature )(*_ed .Certificate ,error ){if _fecg ._caa !=nil {return _fecg ._caa ,nil ;};_ffff ,_aeg :=_gbe .GetCerts ();if _aeg !=nil {return nil ,_aeg ;};return _ffff [0],nil ;
};func (_fea *etsiPAdES )getOCSPs (_df []*_ed .Certificate ,_dfg map[string ]*_ed .Certificate )([][]byte ,error ){_cdg :=make ([][]byte ,0,len (_df ));for _ ,_caee :=range _df {for _ ,_ceb :=range _caee .OCSPServer {if _fea .CertClient .IsCA (_caee ){continue ;
};_fbf ,_cdd :=_dfg [_caee .Issuer .CommonName ];if !_cdd {_fc .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
continue ;};_ ,_dc ,_dgd :=_fea .OCSPClient .MakeRequest (_ceb ,_caee ,_fbf );if _dgd !=nil {_fc .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076",_dgd );
continue ;};_cdg =append (_cdg ,_dc );};};return _cdg ,nil ;};

// NewDigest creates a new digest.
func (_fec *etsiPAdES )NewDigest (_ *_gb .PdfSignature )(_gb .Hasher ,error ){return _fe .NewBuffer (nil ),nil ;};func _cff (_bbda []byte ,_dcg int )(_ddg []byte ){_feb :=len (_bbda );if _feb > _dcg {_feb =_dcg ;};_ddg =make ([]byte ,_dcg );copy (_ddg [len (_ddg )-_feb :],_bbda );
return ;};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _gb .SignatureHandler ,permission _gc .DocMDPPermission )(_gb .SignatureHandler ,error ){return &DocMDPHandler {_eg :handler ,Permission :permission },nil ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_adf .PrivateKey ,certificate *_ed .Certificate )(_gb .SignatureHandler ,error ){return &adobePKCS7Detached {_bdg :certificate ,_ded :privateKey },nil ;};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_fcg *DocMDPHandler )Validate (sig *_gb .PdfSignature ,digest _gb .Hasher )(_gb .SignatureValidationResult ,error ){return _gb .SignatureValidationResult {},_b .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _d .Hash )(_gb .SignatureHandler ,error ){return &docTimeStamp {_fed :timestampServerURL ,_aded :hashAlgorithm },nil ;};

// NewEtsiPAdESLevelLT creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
func NewEtsiPAdESLevelLT (privateKey *_adf .PrivateKey ,certificate *_ed .Certificate ,caCert *_ed .Certificate ,certificateTimestampServerURL string ,appender *_gb .PdfAppender )(_gb .SignatureHandler ,error ){_ggcd :=appender .Reader .DSS ;if _ggcd ==nil {_ggcd =_gb .NewDSS ();
};if _bad :=_ggcd .GenerateHashMaps ();_bad !=nil {return nil ,_bad ;};return &etsiPAdES {_ec :certificate ,_ga :privateKey ,_cca :caCert ,_dbae :certificateTimestampServerURL ,CertClient :_db .NewCertClient (),OCSPClient :_db .NewOCSPClient (),CRLClient :_db .NewCRLClient (),_bg :appender ,_bfa :_ggcd },nil ;
};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_gb .SignatureHandler ,error ){return &adobePKCS7Detached {_efcg :true ,_bbd :signatureLen },nil ;};func (_eeb *etsiPAdES )getCerts (_fege []*_ed .Certificate )([][]byte ,error ){_ead :=make ([][]byte ,0,len (_fege ));
for _ ,_fde :=range _fege {_ead =append (_ead ,_fde .Raw );};return _ead ,nil ;};

// NewDigest creates a new digest.
func (_eggg *adobePKCS7Detached )NewDigest (sig *_gb .PdfSignature )(_gb .Hasher ,error ){return _fe .NewBuffer (nil ),nil ;};func _ccc (_fbb _ad .ObjectIdentifier )(_d .Hash ,error ){switch {case _fbb .Equal (_ba .OIDDigestAlgorithmSHA1 ),_fbb .Equal (_ba .OIDDigestAlgorithmECDSASHA1 ),_fbb .Equal (_ba .OIDDigestAlgorithmDSA ),_fbb .Equal (_ba .OIDDigestAlgorithmDSASHA1 ),_fbb .Equal (_ba .OIDEncryptionAlgorithmRSA ):return _d .SHA1 ,nil ;
case _fbb .Equal (_ba .OIDDigestAlgorithmSHA256 ),_fbb .Equal (_ba .OIDDigestAlgorithmECDSASHA256 ):return _d .SHA256 ,nil ;case _fbb .Equal (_ba .OIDDigestAlgorithmSHA384 ),_fbb .Equal (_ba .OIDDigestAlgorithmECDSASHA384 ):return _d .SHA384 ,nil ;case _fbb .Equal (_ba .OIDDigestAlgorithmSHA512 ),_fbb .Equal (_ba .OIDDigestAlgorithmECDSASHA512 ):return _d .SHA512 ,nil ;
};return _d .Hash (0),_ba .ErrUnsupportedAlgorithm ;};type adobeX509RSASHA1 struct{_dfe *_adf .PrivateKey ;_caa *_ed .Certificate ;_geb SignFunc ;_egc bool ;_bbf _d .Hash ;};

// NewDigest creates a new digest.
func (_bgdbc *adobeX509RSASHA1 )NewDigest (sig *_gb .PdfSignature )(_gb .Hasher ,error ){if _aga ,_bda :=_bgdbc .getHashAlgorithm (sig );_aga !=0&&_bda ==nil {return _aga .New (),nil ;};return _fccc .New (),nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_bf *DocMDPHandler )IsApplicable (sig *_gb .PdfSignature )bool {_ge :=false ;for _ ,_bea :=range sig .Reference .Elements (){if _da ,_ea :=_cd .GetDict (_bea );_ea {if _eb ,_af :=_cd .GetNameVal (_da .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_af {if _eb !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _aa ,_de :=_cd .GetDict (_da .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_de {_ ,_cda :=_cd .GetNumberAsInt64 (_aa .Get ("\u0050"));if _cda !=nil {return false ;
};_ge =true ;break ;};};};};return _ge &&_bf ._eg .IsApplicable (sig );};

// InitSignature initialises the PdfSignature.
func (_ebdf *adobeX509RSASHA1 )InitSignature (sig *_gb .PdfSignature )error {if _ebdf ._caa ==nil {return _b .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _ebdf ._dfe ==nil &&_ebdf ._geb ==nil {return _b .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_bbgf :=*_ebdf ;sig .Handler =&_bbgf ;sig .Filter =_cd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_cd .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_cd .MakeString (string (_bbgf ._caa .Raw ));sig .Reference =nil ;_aba ,_bff :=_bbgf .NewDigest (sig );if _bff !=nil {return _bff ;};_aba .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _bbgf .sign (sig ,_aba ,_ebdf ._egc );};func (_cbc *etsiPAdES )getCRLs (_fdf []*_ed .Certificate )([][]byte ,error ){_fbfe :=make ([][]byte ,0,len (_fdf ));for _ ,_cde :=range _fdf {for _ ,_afb :=range _cde .CRLDistributionPoints {if _cbc .CertClient .IsCA (_cde ){continue ;
};_gaf ,_bfd :=_cbc .CRLClient .MakeRequest (_afb ,_cde );if _bfd !=nil {_fc .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076",_bfd );continue ;};_fbfe =append (_fbfe ,_gaf );
};};return _fbfe ,nil ;};func (_ef *etsiPAdES )addDss (_fbc ,_gdd []*_ed .Certificate ,_cbg *RevocationInfoArchival )(int ,error ){_gfg ,_dece ,_fgg :=_ef .buildCertChain (_fbc ,_gdd );if _fgg !=nil {return 0,_fgg ;};_fgee ,_fgg :=_ef .getCerts (_gfg );
if _fgg !=nil {return 0,_fgg ;};var _dbga ,_fff [][]byte ;if _ef .OCSPClient !=nil {_dbga ,_fgg =_ef .getOCSPs (_gfg ,_dece );if _fgg !=nil {return 0,_fgg ;};};if _ef .CRLClient !=nil {_fff ,_fgg =_ef .getCRLs (_gfg );if _fgg !=nil {return 0,_fgg ;};};
if !_ef ._fegd {_ ,_fgg =_ef ._bfa .AddCerts (_fgee );if _fgg !=nil {return 0,_fgg ;};_ ,_fgg =_ef ._bfa .AddOCSPs (_dbga );if _fgg !=nil {return 0,_fgg ;};_ ,_fgg =_ef ._bfa .AddCRLs (_fff );if _fgg !=nil {return 0,_fgg ;};};_ebcd :=0;for _ ,_dcf :=range _fff {_ebcd +=len (_dcf );
_cbg .Crl =append (_cbg .Crl ,_ad .RawValue {FullBytes :_dcf });};for _ ,_fffg :=range _dbga {_ebcd +=len (_fffg );_cbg .Ocsp =append (_cbg .Ocsp ,_ad .RawValue {FullBytes :_fffg });};return _ebcd ,nil ;};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_ce *DocMDPHandler )ValidateWithOpts (sig *_gb .PdfSignature ,digest _gb .Hasher ,params _gb .SignatureHandlerDocMDPParams )(_gb .SignatureValidationResult ,error ){_eaa ,_ab :=_ce ._eg .Validate (sig ,digest );if _ab !=nil {return _eaa ,_ab ;};_cg :=params .Parser ;
if _cg ==nil {return _gb .SignatureValidationResult {},_b .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_eaa .IsVerified {return _eaa ,nil ;};_ac :=params .DiffPolicy ;if _ac ==nil {_ac =_gc .NewDefaultDiffPolicy ();
};for _dg :=0;_dg <=_cg .GetRevisionNumber ();_dg ++{_fd ,_bae :=_cg .GetRevision (_dg );if _bae !=nil {return _gb .SignatureValidationResult {},_bae ;};_feg :=_fd .GetTrailer ();if _feg ==nil {return _gb .SignatureValidationResult {},_b .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_bfb ,_fdd :=_cd .GetDict (_feg .Get ("\u0052\u006f\u006f\u0074"));if !_fdd {return _gb .SignatureValidationResult {},_b .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");
};_aad ,_fdd :=_cd .GetDict (_bfb .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_fdd {continue ;};_fg ,_fdd :=_cd .GetArray (_aad .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_fdd {continue ;};for _ ,_fb :=range _fg .Elements (){_gef ,_dba :=_cd .GetDict (_fb );
if !_dba {continue ;};_cc ,_dba :=_cd .GetDict (_gef .Get ("\u0056"));if !_dba {continue ;};if _cd .EqualObjects (_cc .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_eaa .DiffResults ,_bae =_ac .ReviewFile (_fd ,_cg ,&_gc .MDPParameters {DocMDPLevel :_ce .Permission });
if _bae !=nil {return _gb .SignatureValidationResult {},_bae ;};_eaa .IsVerified =_eaa .DiffResults .IsPermitted ();return _eaa ,nil ;};};};return _gb .SignatureValidationResult {},_b .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};func (_ag *etsiPAdES )buildCertChain (_cfg ,_adc []*_ed .Certificate )([]*_ed .Certificate ,map[string ]*_ed .Certificate ,error ){_fegb :=map[string ]*_ed .Certificate {};for _ ,_dd :=range _cfg {_fegb [_dd .Subject .CommonName ]=_dd ;};_eab :=_cfg ;
for _ ,_bba :=range _adc {_egf :=_bba .Subject .CommonName ;if _ ,_gdg :=_fegb [_egf ];_gdg {continue ;};_fegb [_egf ]=_bba ;_eab =append (_eab ,_bba );};if len (_eab )==0{return nil ,nil ,_gb .ErrSignNoCertificates ;};var _gcg error ;for _ecd :=_eab [0];
_ecd !=nil &&!_ag .CertClient .IsCA (_ecd );{var _cbd *_ed .Certificate ;_ ,_gab :=_fegb [_ecd .Issuer .CommonName ];if !_gab {if _cbd ,_gcg =_ag .CertClient .GetIssuer (_ecd );_gcg !=nil {_fc .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076",_gcg );
break ;};_fegb [_ecd .Issuer .CommonName ]=_cbd ;_eab =append (_eab ,_cbd );}else {break ;};_ecd =_cbd ;};return _eab ,_fegb ,nil ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _d .Hash ,opts *DocTimeStampOpts )(_gb .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_fed :timestampServerURL ,_aded :hashAlgorithm ,_ecaf :opts .SignatureSize ,_fdgd :opts .Client },nil ;
};type adobePKCS7Detached struct{_ded *_adf .PrivateKey ;_bdg *_ed .Certificate ;_efcg bool ;_bbd int ;};func _cgb (_dad *_adf .PublicKey ,_cfc []byte )_d .Hash {_gbdc :=_dad .Size ();if _gbdc !=len (_cfc ){return 0;};_ddf :=func (_gfeb *_g .Int ,_gdcg *_adf .PublicKey ,_eed *_g .Int )*_g .Int {_becf :=_g .NewInt (int64 (_gdcg .E ));
_gfeb .Exp (_eed ,_becf ,_gdcg .N );return _gfeb ;};_cggae :=new (_g .Int ).SetBytes (_cfc );_dbff :=_ddf (new (_g .Int ),_dad ,_cggae );_dda :=_cff (_dbff .Bytes (),_gbdc );if _dda [0]!=0||_dda [1]!=1{return 0;};_fac :=[]struct{Hash _d .Hash ;Prefix []byte ;
}{{Hash :_d .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_d .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_d .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_d .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_d .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_fdeb :=range _fac {_gfb :=_fdeb .Hash .Size ();_efea :=len (_fdeb .Prefix )+_gfb ;if _fe .Equal (_dda [_gbdc -_efea :_gbdc -_gfb ],_fdeb .Prefix ){return _fdeb .Hash ;};};return 0;};func (_gdc *adobeX509RSASHA1 )getHashAlgorithm (_dbf *_gb .PdfSignature )(_d .Hash ,error ){_eaac ,_cegf :=_gdc .getCertificate (_dbf );
if _cegf !=nil {if _gdc ._bbf !=0{return _gdc ._bbf ,nil ;};return _fccc ,_cegf ;};if _dbf .Contents !=nil {_cfb :=_dbf .Contents .Bytes ();var _fddf []byte ;if _ ,_fad :=_ad .Unmarshal (_cfb ,&_fddf );_fad ==nil {_bca :=_cgb (_eaac .PublicKey .(*_adf .PublicKey ),_fddf );
if _bca > 0{return _bca ,nil ;};};};if _gdc ._bbf !=0{return _gdc ._bbf ,nil ;};return _fccc ,nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_aef *adobePKCS7Detached )IsApplicable (sig *_gb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};func (_dff *adobeX509RSASHA1 )sign (_cdf *_gb .PdfSignature ,_ddd _gb .Hasher ,_caf bool )error {if !_caf {return _dff .Sign (_cdf ,_ddd );};_edg ,_ade :=_dff ._caa .PublicKey .(*_adf .PublicKey );if !_ade {return _a .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_edg );
};_aea ,_caab :=_ad .Marshal (make ([]byte ,_edg .Size ()));if _caab !=nil {return _caab ;};_cdf .Contents =_cd .MakeHexString (string (_aea ));return nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_dgb *_gb .PdfSignature ,_bgc _gb .Hasher )([]byte ,error );

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_db .TimestampClient ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _d .Hash ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fdb *docTimeStamp )IsApplicable (sig *_gb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};

// Validate validates PdfSignature.
func (_gec *docTimeStamp )Validate (sig *_gb .PdfSignature ,digest _gb .Hasher )(_gb .SignatureValidationResult ,error ){_edgd :=sig .Contents .Bytes ();_ggf ,_dae :=_ba .Parse (_edgd );if _dae !=nil {return _gb .SignatureValidationResult {},_dae ;};if _dae =_ggf .Verify ();
_dae !=nil {return _gb .SignatureValidationResult {},_dae ;};var _eadd timestampInfo ;_ ,_dae =_ad .Unmarshal (_ggf .Content ,&_eadd );if _dae !=nil {return _gb .SignatureValidationResult {},_dae ;};_gdb ,_dae :=_ccc (_eadd .MessageImprint .HashAlgorithm .Algorithm );
if _dae !=nil {return _gb .SignatureValidationResult {},_dae ;};_bdc :=_gdb .New ();_bcbd ,_cgbd :=digest .(*_fe .Buffer );if !_cgbd {return _gb .SignatureValidationResult {},_a .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");
};_bdc .Write (_bcbd .Bytes ());_adea :=_bdc .Sum (nil );_ffg :=_gb .SignatureValidationResult {IsSigned :true ,IsVerified :_fe .Equal (_adea ,_eadd .MessageImprint .HashedMessage ),GeneralizedTime :_eadd .GeneralizedTime };return _ffg ,nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_cgbg *docTimeStamp )Sign (sig *_gb .PdfSignature ,digest _gb .Hasher )error {_gdcge ,_aega :=_db .NewTimestampRequest (digest .(*_fe .Buffer ),&_bd .RequestOptions {Hash :_cgbg ._aded ,Certificates :true });if _aega !=nil {return _aega ;};_afbc :=_cgbg ._fdgd ;
if _afbc ==nil {_afbc =_db .NewTimestampClient ();};_dbb ,_aega :=_afbc .GetEncodedToken (_cgbg ._fed ,_gdcge );if _aega !=nil {return _aega ;};_befb :=len (_dbb );if _cgbg ._ecaf > 0&&_befb > _cgbg ._ecaf {return _gb .ErrSignNotEnoughSpace ;};if _befb > 0{_cgbg ._ecaf =_befb +128;
};if sig .Contents !=nil {_efd :=sig .Contents .Bytes ();copy (_efd ,_dbb );_dbb =_efd ;};sig .Contents =_cd .MakeHexString (string (_dbb ));return nil ;};

// Sign sets the Contents fields.
func (_fcc *adobePKCS7Detached )Sign (sig *_gb .PdfSignature ,digest _gb .Hasher )error {if _fcc ._efcg {_ace :=_fcc ._bbd ;if _ace <=0{_ace =8192;};sig .Contents =_cd .MakeHexString (string (make ([]byte ,_ace )));return nil ;};_bed ,_cgga :=digest .(*_fe .Buffer );
if !_cgga {return _a .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_cded ,_baea :=_ba .NewSignedData (_bed .Bytes ());if _baea !=nil {return _baea ;};if _dbgc :=_cded .AddSigner (_fcc ._bdg ,_fcc ._ded ,_ba .SignerInfoConfig {});
_dbgc !=nil {return _dbgc ;};_cded .Detach ();_ebd ,_baea :=_cded .Finish ();if _baea !=nil {return _baea ;};_eda :=make ([]byte ,8192);copy (_eda ,_ebd );sig .Contents =_cd .MakeHexString (string (_eda ));return nil ;};type docTimeStamp struct{_fed string ;
_aded _d .Hash ;_ecaf int ;_fdgd *_db .TimestampClient ;};func (_cba *etsiPAdES )makeTimestampRequest (_eeg string ,_gbc []byte )(_ad .RawValue ,error ){_ebb :=_d .SHA512 .New ();_ebb .Write (_gbc );_bfba :=_ebb .Sum (nil );_cag :=_bd .Request {HashAlgorithm :_d .SHA512 ,HashedMessage :_bfba ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };
_cce :=_db .NewTimestampClient ();_fee ,_bb :=_cce .GetEncodedToken (_eeg ,&_cag );if _bb !=nil {return _ad .NullRawValue ,_bb ;};return _ad .RawValue {FullBytes :_fee },nil ;};

// InitSignature initialises the PdfSignature.
func (_dea *adobePKCS7Detached )InitSignature (sig *_gb .PdfSignature )error {if !_dea ._efcg {if _dea ._bdg ==nil {return _b .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _dea ._ded ==nil {return _b .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_fegeb :=*_dea ;sig .Handler =&_fegeb ;sig .Filter =_cd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_cd .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_dee ,_ffc :=_fegeb .NewDigest (sig );if _ffc !=nil {return _ffc ;};_dee .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _fegeb .Sign (sig ,_dee );};type timestampInfo struct{Version int ;Policy _ad .RawValue ;MessageImprint struct{HashAlgorithm _gg .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _ad .RawValue ;GeneralizedTime _c .Time ;};

// NewEtsiPAdESLevelT creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
func NewEtsiPAdESLevelT (privateKey *_adf .PrivateKey ,certificate *_ed .Certificate ,caCert *_ed .Certificate ,certificateTimestampServerURL string )(_gb .SignatureHandler ,error ){return &etsiPAdES {_ec :certificate ,_ga :privateKey ,_cca :caCert ,_dbae :certificateTimestampServerURL },nil ;
};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_eg _gb .SignatureHandler ;Permission _gc .DocMDPPermission ;};

// Sign sets the Contents fields for the PdfSignature.
func (_afcc *adobeX509RSASHA1 )Sign (sig *_gb .PdfSignature ,digest _gb .Hasher )error {var _faa []byte ;var _cge error ;if _afcc ._geb !=nil {_faa ,_cge =_afcc ._geb (sig ,digest );if _cge !=nil {return _cge ;};}else {_abc ,_dcc :=digest .(_be .Hash );
if !_dcc {return _b .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bcc :=_fccc ;if _afcc ._bbf !=0{_bcc =_afcc ._bbf ;};_faa ,_cge =_adf .SignPKCS1v15 (_ggc .Reader ,_afcc ._dfe ,_bcc ,_abc .Sum (nil ));if _cge !=nil {return _cge ;
};};_faa ,_cge =_ad .Marshal (_faa );if _cge !=nil {return _cge ;};sig .Contents =_cd .MakeHexString (string (_faa ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fef *adobeX509RSASHA1 )IsApplicable (sig *_gb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};

// Validate validates PdfSignature.
func (_gfgg *adobePKCS7Detached )Validate (sig *_gb .PdfSignature ,digest _gb .Hasher )(_gb .SignatureValidationResult ,error ){_gad :=sig .Contents .Bytes ();_bga ,_cagd :=_ba .Parse (_gad );if _cagd !=nil {return _gb .SignatureValidationResult {},_cagd ;
};_ega ,_cgd :=digest .(*_fe .Buffer );if !_cgd {return _gb .SignatureValidationResult {},_a .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_bga .Content =_ega .Bytes ();if _cagd =_bga .Verify ();
_cagd !=nil {return _gb .SignatureValidationResult {},_cagd ;};return _gb .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// Sign adds a new reference to signature's references array.
func (_gf *DocMDPHandler )Sign (sig *_gb .PdfSignature ,digest _gb .Hasher )error {return _gf ._eg .Sign (sig ,digest );};

// InitSignature initialization of the DocMDP signature.
func (_acd *DocMDPHandler )InitSignature (sig *_gb .PdfSignature )error {_egg :=_acd ._eg .InitSignature (sig );if _egg !=nil {return _egg ;};sig .Handler =_acd ;if sig .Reference ==nil {sig .Reference =_cd .MakeArray ();};sig .Reference .Append (_gb .NewPdfSignatureReferenceDocMDP (_gb .NewPdfTransformParamsDocMDP (_acd .Permission )).ToPdfObject ());
return nil ;};

// Validate validates PdfSignature.
func (_bbag *adobeX509RSASHA1 )Validate (sig *_gb .PdfSignature ,digest _gb .Hasher )(_gb .SignatureValidationResult ,error ){_ede ,_gfe :=_bbag .getCertificate (sig );if _gfe !=nil {return _gb .SignatureValidationResult {},_gfe ;};_eceb :=sig .Contents .Bytes ();
var _baf []byte ;if _ ,_abg :=_ad .Unmarshal (_eceb ,&_baf );_abg !=nil {return _gb .SignatureValidationResult {},_abg ;};_gcdf ,_ege :=digest .(_be .Hash );if !_ege {return _gb .SignatureValidationResult {},_b .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_ccea ,_ :=_bbag .getHashAlgorithm (sig );if _ccea ==0{_ccea =_fccc ;};if _eabf :=_adf .VerifyPKCS1v15 (_ede .PublicKey .(*_adf .PublicKey ),_ccea ,_gcdf .Sum (nil ),_baf );_eabf !=nil {return _gb .SignatureValidationResult {},_eabf ;};return _gb .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// NewDigest creates a new digest.
func (_badc *docTimeStamp )NewDigest (sig *_gb .PdfSignature )(_gb .Hasher ,error ){return _fe .NewBuffer (nil ),nil ;};type etsiPAdES struct{_ga *_adf .PrivateKey ;_ec *_ed .Certificate ;_cee bool ;_fegd bool ;_cca *_ed .Certificate ;_dbae string ;

// CertClient is the client used to retrieve certificates.
CertClient *_db .CertClient ;

// OCSPClient is the client used to retrieve OCSP validation information.
OCSPClient *_db .OCSPClient ;

// CRLClient is the client used to retrieve CRL validation information.
CRLClient *_db .CRLClient ;_bg *_gb .PdfAppender ;_bfa *_gb .DSS ;};

// InitSignature initialises the PdfSignature.
func (_dffg *docTimeStamp )InitSignature (sig *_gb .PdfSignature )error {_cfff :=*_dffg ;sig .Type =_cd .MakeName ("\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070");sig .Handler =&_cfff ;sig .Filter =_cd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_cd .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _dffg ._ecaf > 0{sig .Contents =_cd .MakeHexString (string (make ([]byte ,_dffg ._ecaf )));}else {_cbdd ,_gfc :=_dffg .NewDigest (sig );
if _gfc !=nil {return _gfc ;};_cbdd .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _gfc =_cfff .Sign (sig ,_cbdd );
_gfc !=nil {return _gfc ;};_dffg ._ecaf =_cfff ._ecaf ;};return nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_ed .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_gb .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_caa :certificate ,_geb :signFunc ,_egc :opts .EstimateSize ,_bbf :opts .Algorithm },nil ;
};

// NewDigest creates a new digest.
func (_ca *DocMDPHandler )NewDigest (sig *_gb .PdfSignature )(_gb .Hasher ,error ){return _ca ._eg .NewDigest (sig );};