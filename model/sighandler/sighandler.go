//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_be "bytes";_a "crypto";_da "crypto/rand";_cb "crypto/rsa";_bd "crypto/x509";_e "crypto/x509/pkix";_g "encoding/asn1";_db "encoding/hex";_c "errors";_bb "fmt";_bbf "github.com/unidoc/pkcs7";_ef "github.com/unidoc/timestamp";
_ee "github.com/unidoc/unipdf/v3/common";_gb "github.com/unidoc/unipdf/v3/core";_eee "github.com/unidoc/unipdf/v3/model";_cd "github.com/unidoc/unipdf/v3/model/mdp";_eg "github.com/unidoc/unipdf/v3/model/sigutil";_de "hash";_d "math/big";_b "strings";_dg "time";
);

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_adfc *docTimeStamp )IsApplicable (sig *_eee .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};

// NewEtsiPAdESLevelT creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
func NewEtsiPAdESLevelT (privateKey *_cb .PrivateKey ,certificate *_bd .Certificate ,caCert *_bd .Certificate ,certificateTimestampServerURL string )(_eee .SignatureHandler ,error ){return &etsiPAdES {_cf :certificate ,_ae :privateKey ,_cga :caCert ,_cef :certificateTimestampServerURL },nil ;
};

// NewEtsiPAdESLevelLT creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
func NewEtsiPAdESLevelLT (privateKey *_cb .PrivateKey ,certificate *_bd .Certificate ,caCert *_bd .Certificate ,certificateTimestampServerURL string ,appender *_eee .PdfAppender )(_eee .SignatureHandler ,error ){_ecb :=appender .Reader .DSS ;if _ecb ==nil {_ecb =_eee .NewDSS ();
};if _aabe :=_ecb .GenerateHashMaps ();_aabe !=nil {return nil ,_aabe ;};return &etsiPAdES {_cf :certificate ,_ae :privateKey ,_cga :caCert ,_cef :certificateTimestampServerURL ,CertClient :_eg .NewCertClient (),OCSPClient :_eg .NewOCSPClient (),CRLClient :_eg .NewCRLClient (),_dga :appender ,_egd :_ecb },nil ;
};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _a .Hash )(_eee .SignatureHandler ,error ){return &docTimeStamp {_ffg :timestampServerURL ,_gbb :hashAlgorithm },nil ;};func (_bfe *adobePKCS7Detached )getCertificate (_bcf *_eee .PdfSignature )(*_bd .Certificate ,error ){if _bfe ._adgb !=nil {return _bfe ._adgb ,nil ;
};_gad ,_ddd :=_bcf .GetCerts ();if _ddd !=nil {return nil ,_ddd ;};return _gad [0],nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_bd .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_eee .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_dbcg :certificate ,_faaf :signFunc ,_fce :opts .EstimateSize ,_gga :opts .Algorithm },nil ;
};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_fcfb *_eee .PdfSignature ,_cbga _eee .Hasher )([]byte ,error );func (_fad *etsiPAdES )buildCertChain (_ecbg ,_cddb []*_bd .Certificate )([]*_bd .Certificate ,map[string ]*_bd .Certificate ,error ){_fgf :=map[string ]*_bd .Certificate {};
for _ ,_ddf :=range _ecbg {_fgf [_ddf .Subject .CommonName ]=_ddf ;};_aaab :=_ecbg ;for _ ,_bgc :=range _cddb {_bda :=_bgc .Subject .CommonName ;if _ ,_ddcf :=_fgf [_bda ];_ddcf {continue ;};_fgf [_bda ]=_bgc ;_aaab =append (_aaab ,_bgc );};if len (_aaab )==0{return nil ,nil ,_eee .ErrSignNoCertificates ;
};var _bfa error ;for _ecg :=_aaab [0];_ecg !=nil &&!_fad .CertClient .IsCA (_ecg );{var _ge *_bd .Certificate ;_ ,_df :=_fgf [_ecg .Issuer .CommonName ];if !_df {if _ge ,_bfa =_fad .CertClient .GetIssuer (_ecg );_bfa !=nil {_ee .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076",_bfa );
break ;};_fgf [_ecg .Issuer .CommonName ]=_ge ;_aaab =append (_aaab ,_ge );}else {break ;};_ecg =_ge ;};return _aaab ,_fgf ,nil ;};type docTimeStamp struct{_ffg string ;_gbb _a .Hash ;_aeg int ;_ced *_eg .TimestampClient ;};func (_cgg *etsiPAdES )getCerts (_gbe []*_bd .Certificate )([][]byte ,error ){_bfb :=make ([][]byte ,0,len (_gbe ));
for _ ,_gg :=range _gbe {_bfb =append (_bfb ,_gg .Raw );};return _bfb ,nil ;};

// Validate validates PdfSignature.
func (_abd *adobePKCS7Detached )Validate (sig *_eee .PdfSignature ,digest _eee .Hasher )(_eee .SignatureValidationResult ,error ){_feg :=sig .Contents .Bytes ();_fdb ,_aaba :=_bbf .Parse (_feg );if _aaba !=nil {return _eee .SignatureValidationResult {},_aaba ;
};_fae ,_dfgc :=digest .(*_be .Buffer );if !_dfgc {return _eee .SignatureValidationResult {},_bb .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_fdb .Content =_fae .Bytes ();if _aaba =_fdb .Verify ();
_aaba !=nil {return _eee .SignatureValidationResult {},_aaba ;};return _eee .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_gdeg *docTimeStamp )Sign (sig *_eee .PdfSignature ,digest _eee .Hasher )error {_gega ,_eeaae :=_eg .NewTimestampRequest (digest .(*_be .Buffer ),&_ef .RequestOptions {Hash :_gdeg ._gbb ,Certificates :true });if _eeaae !=nil {return _eeaae ;};_cfed :=_gdeg ._ced ;
if _cfed ==nil {_cfed =_eg .NewTimestampClient ();};_ceec ,_eeaae :=_cfed .GetEncodedToken (_gdeg ._ffg ,_gega );if _eeaae !=nil {return _eeaae ;};_cbc :=len (_ceec );if _gdeg ._aeg > 0&&_cbc > _gdeg ._aeg {return _eee .ErrSignNotEnoughSpace ;};if _cbc > 0{_gdeg ._aeg =_cbc +128;
};if sig .Contents !=nil {_eefc :=sig .Contents .Bytes ();copy (_eefc ,_ceec );_ceec =_eefc ;};sig .Contents =_gb .MakeHexString (string (_ceec ));return nil ;};

// InitSignature initialises the PdfSignature.
func (_feac *docTimeStamp )InitSignature (sig *_eee .PdfSignature )error {_fadf :=*_feac ;sig .Type =_gb .MakeName ("\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070");sig .Handler =&_fadf ;sig .Filter =_gb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_gb .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _feac ._aeg > 0{sig .Contents =_gb .MakeHexString (string (make ([]byte ,_feac ._aeg )));}else {_cfec ,_acc :=_feac .NewDigest (sig );
if _acc !=nil {return _acc ;};_cfec .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _acc =_fadf .Sign (sig ,_cfec );
_acc !=nil {return _acc ;};_feac ._aeg =_fadf ._aeg ;};return nil ;};func (_ggd *adobeX509RSASHA1 )getHashAlgorithm (_dff *_eee .PdfSignature )(_a .Hash ,error ){_age ,_ebdf :=_ggd .getCertificate (_dff );if _ebdf !=nil {if _ggd ._gga !=0{return _ggd ._gga ,nil ;
};return _aae ,_ebdf ;};if _dff .Contents !=nil {_cfd :=_dff .Contents .Bytes ();var _dca []byte ;if _ ,_faef :=_g .Unmarshal (_cfd ,&_dca );_faef ==nil {_bfee :=_fefe (_age .PublicKey .(*_cb .PublicKey ),_dca );if _bfee > 0{return _bfee ,nil ;};};};if _ggd ._gga !=0{return _ggd ._gga ,nil ;
};return _aae ,nil ;};

// RevocationInfoArchival is OIDAttributeAdobeRevocation attribute.
type RevocationInfoArchival struct{Crl []_g .RawValue `asn1:"explicit,tag:0,optional"`;Ocsp []_g .RawValue `asn1:"explicit,tag:1,optional"`;OtherRevInfo []_g .RawValue `asn1:"explicit,tag:2,optional"`;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_bd .Certificate ,signFunc SignFunc )(_eee .SignatureHandler ,error ){return &adobeX509RSASHA1 {_dbcg :certificate ,_faaf :signFunc },nil ;};type adobeX509RSASHA1 struct{_ebd *_cb .PrivateKey ;_dbcg *_bd .Certificate ;
_faaf SignFunc ;_fce bool ;_gga _a .Hash ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _a .Hash ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_eee .SignatureHandler ,error ){return &adobePKCS7Detached {_cbf :true ,_aaf :signatureLen },nil ;};func (_bceb *docTimeStamp )getCertificate (_adab *_eee .PdfSignature )(*_bd .Certificate ,error ){_bad ,_afee :=_adab .GetCerts ();
if _afee !=nil {return nil ,_afee ;};return _bad [0],nil ;};func (_dbg *etsiPAdES )makeTimestampRequest (_eb string ,_cbg []byte )(_g .RawValue ,error ){_ccb :=_a .SHA512 .New ();_ccb .Write (_cbg );_gbf :=_ccb .Sum (nil );_gba :=_ef .Request {HashAlgorithm :_a .SHA512 ,HashedMessage :_gbf ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };
_dc :=_eg .NewTimestampClient ();_cea ,_cff :=_dc .GetEncodedToken (_eb ,&_gba );if _cff !=nil {return _g .NullRawValue ,_cff ;};return _g .RawValue {FullBytes :_cea },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fbd *etsiPAdES )IsApplicable (sig *_eee .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// Sign sets the Contents fields.
func (_gdd *adobePKCS7Detached )Sign (sig *_eee .PdfSignature ,digest _eee .Hasher )error {if _gdd ._cbf {_edc :=_gdd ._aaf ;if _edc <=0{_edc =8192;};sig .Contents =_gb .MakeHexString (string (make ([]byte ,_edc )));return nil ;};_baf ,_dace :=digest .(*_be .Buffer );
if !_dace {return _bb .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_fdc ,_ade :=_bbf .NewSignedData (_baf .Bytes ());if _ade !=nil {return _ade ;};if _aafe :=_fdc .AddSigner (_gdd ._adgb ,_gdd ._fgc ,_bbf .SignerInfoConfig {});
_aafe !=nil {return _aafe ;};_fdc .Detach ();_eba ,_ade :=_fdc .Finish ();if _ade !=nil {return _ade ;};_dcf :=make ([]byte ,8192);copy (_dcf ,_eba );sig .Contents =_gb .MakeHexString (string (_dcf ));return nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_fab *adobeX509RSASHA1 )Sign (sig *_eee .PdfSignature ,digest _eee .Hasher )error {var _gdg []byte ;var _gbeb error ;if _fab ._faaf !=nil {_gdg ,_gbeb =_fab ._faaf (sig ,digest );if _gbeb !=nil {return _gbeb ;};}else {_ffe ,_begg :=digest .(_de .Hash );
if !_begg {return _c .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_efb :=_aae ;if _fab ._gga !=0{_efb =_fab ._gga ;};_gdg ,_gbeb =_cb .SignPKCS1v15 (_da .Reader ,_fab ._ebd ,_efb ,_ffe .Sum (nil ));if _gbeb !=nil {return _gbeb ;
};};_gdg ,_gbeb =_g .Marshal (_gdg );if _gbeb !=nil {return _gbeb ;};sig .Contents =_gb .MakeHexString (string (_gdg ));return nil ;};func _bege (_gcgb []byte ,_eeaa int )(_acd []byte ){_bbff :=len (_gcgb );if _bbff > _eeaa {_bbff =_eeaa ;};_acd =make ([]byte ,_eeaa );
copy (_acd [len (_acd )-_bbff :],_gcgb );return ;};

// Validate validates PdfSignature.
func (_gaca *adobeX509RSASHA1 )Validate (sig *_eee .PdfSignature ,digest _eee .Hasher )(_eee .SignatureValidationResult ,error ){_fea ,_fca :=_gaca .getCertificate (sig );if _fca !=nil {return _eee .SignatureValidationResult {},_fca ;};_fff :=sig .Contents .Bytes ();
var _eeed []byte ;if _ ,_gag :=_g .Unmarshal (_fff ,&_eeed );_gag !=nil {return _eee .SignatureValidationResult {},_gag ;};_cbfc ,_ecf :=digest .(_de .Hash );if !_ecf {return _eee .SignatureValidationResult {},_c .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_geg ,_ :=_gaca .getHashAlgorithm (sig );if _geg ==0{_geg =_aae ;};if _cce :=_cb .VerifyPKCS1v15 (_fea .PublicKey .(*_cb .PublicKey ),_geg ,_cbfc .Sum (nil ),_eeed );_cce !=nil {return _eee .SignatureValidationResult {},_cce ;};return _eee .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// InitSignature initialises the PdfSignature.
func (_ffd *etsiPAdES )InitSignature (sig *_eee .PdfSignature )error {if !_ffd ._cdf {if _ffd ._cf ==nil {return _c .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _ffd ._ae ==nil {return _c .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_bef :=*_ffd ;sig .Handler =&_bef ;sig .Filter =_gb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_gb .MakeName ("\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_dd ,_bbe :=_bef .NewDigest (sig );if _bbe !=nil {return _bbe ;};_ ,_bbe =_dd .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _bbe !=nil {return _bbe ;};_bef ._dae =true ;_bbe =_bef .Sign (sig ,_dd );_bef ._dae =false ;return _bbe ;};const _aae =_a .SHA1 ;func _fefe (_fagg *_cb .PublicKey ,_eded []byte )_a .Hash {_dcfa :=_fagg .Size ();if _dcfa !=len (_eded ){return 0;};_bfbd :=func (_feaf *_d .Int ,_aabd *_cb .PublicKey ,_efab *_d .Int )*_d .Int {_bdc :=_d .NewInt (int64 (_aabd .E ));
_feaf .Exp (_efab ,_bdc ,_aabd .N );return _feaf ;};_ebda :=new (_d .Int ).SetBytes (_eded );_dfbe :=_bfbd (new (_d .Int ),_fagg ,_ebda );_cbbc :=_bege (_dfbe .Bytes (),_dcfa );if _cbbc [0]!=0||_cbbc [1]!=1{return 0;};_cda :=[]struct{Hash _a .Hash ;Prefix []byte ;
}{{Hash :_a .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_a .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_a .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_a .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_a .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_bac :=range _cda {_egfa :=_bac .Hash .Size ();_gfd :=len (_bac .Prefix )+_egfa ;if _be .Equal (_cbbc [_dcfa -_gfd :_dcfa -_egfa ],_bac .Prefix ){return _bac .Hash ;};};return 0;};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_ad *DocMDPHandler )ValidateWithOpts (sig *_eee .PdfSignature ,digest _eee .Hasher ,params _eee .SignatureHandlerDocMDPParams )(_eee .SignatureValidationResult ,error ){_cc ,_bcd :=_ad ._eeb .Validate (sig ,digest );if _bcd !=nil {return _cc ,_bcd ;
};_fd :=params .Parser ;if _fd ==nil {return _eee .SignatureValidationResult {},_c .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_cc .IsVerified {return _cc ,nil ;};_fc :=params .DiffPolicy ;
if _fc ==nil {_fc =_cd .NewDefaultDiffPolicy ();};for _fb :=0;_fb <=_fd .GetRevisionNumber ();_fb ++{_ege ,_eea :=_fd .GetRevision (_fb );if _eea !=nil {return _eee .SignatureValidationResult {},_eea ;};_eca :=_ege .GetTrailer ();if _eca ==nil {return _eee .SignatureValidationResult {},_c .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_fa ,_beg :=_gb .GetDict (_eca .Get ("\u0052\u006f\u006f\u0074"));if !_beg {return _eee .SignatureValidationResult {},_c .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");
};_fg ,_beg :=_gb .GetDict (_fa .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_beg {continue ;};_cg ,_beg :=_gb .GetArray (_fg .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_beg {continue ;};for _ ,_cdd :=range _cg .Elements (){_adg ,_ff :=_gb .GetDict (_cdd );
if !_ff {continue ;};_fdg ,_ff :=_gb .GetDict (_adg .Get ("\u0056"));if !_ff {continue ;};if _gb .EqualObjects (_fdg .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_cc .DiffResults ,_eea =_fc .ReviewFile (_ege ,_fd ,&_cd .MDPParameters {DocMDPLevel :_ad .Permission });
if _eea !=nil {return _eee .SignatureValidationResult {},_eea ;};_cc .IsVerified =_cc .DiffResults .IsPermitted ();return _cc ,nil ;};};};return _eee .SignatureValidationResult {},_c .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};type adobePKCS7Detached struct{_fgc *_cb .PrivateKey ;_adgb *_bd .Certificate ;_cbf bool ;_aaf int ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_eg .TimestampClient ;};func (_dec *etsiPAdES )getOCSPs (_eff []*_bd .Certificate ,_bg map[string ]*_bd .Certificate )([][]byte ,error ){_fe :=make ([][]byte ,0,len (_eff ));for _ ,_fag :=range _eff {for _ ,_dbf :=range _fag .OCSPServer {if _dec .CertClient .IsCA (_fag ){continue ;
};_ga ,_ddg :=_bg [_fag .Issuer .CommonName ];if !_ddg {_ee .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
continue ;};_ ,_ebb ,_beb :=_dec .OCSPClient .MakeRequest (_dbf ,_fag ,_ga );if _beb !=nil {_ee .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076",_beb );
continue ;};_fe =append (_fe ,_ebb );};};return _fe ,nil ;};

// NewDigest creates a new digest.
func (_eag *adobeX509RSASHA1 )NewDigest (sig *_eee .PdfSignature )(_eee .Hasher ,error ){if _gcg ,_bccb :=_eag .getHashAlgorithm (sig );_gcg !=0&&_bccb ==nil {return _gcg .New (),nil ;};return _aae .New (),nil ;};func (_bbd *adobeX509RSASHA1 )sign (_aebe *_eee .PdfSignature ,_dacb _eee .Hasher ,_ddcfg bool )error {if !_ddcfg {return _bbd .Sign (_aebe ,_dacb );
};_gbc ,_dbe :=_bbd ._dbcg .PublicKey .(*_cb .PublicKey );if !_dbe {return _bb .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_gbc );};_fdd ,_gef :=_g .Marshal (make ([]byte ,_gbc .Size ()));
if _gef !=nil {return _gef ;};_aebe .Contents =_gb .MakeHexString (string (_fdd ));return nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_cb .PrivateKey ,certificate *_bd .Certificate )(_eee .SignatureHandler ,error ){return &adobeX509RSASHA1 {_dbcg :certificate ,_ebd :privateKey },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_fdad *adobePKCS7Detached )IsApplicable (sig *_eee .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_eeb _eee .SignatureHandler ;Permission _cd .DocMDPPermission ;};

// Sign sets the Contents fields for the PdfSignature.
func (_bdae *etsiPAdES )Sign (sig *_eee .PdfSignature ,digest _eee .Hasher )error {_afe ,_bca :=digest .(*_be .Buffer );if !_bca {return _bb .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_dfb ,_dbc :=_bbf .NewSignedData (_afe .Bytes ());
if _dbc !=nil {return _dbc ;};_dfb .SetDigestAlgorithm (_bbf .OIDDigestAlgorithmSHA256 );_dac :=_bbf .SignerInfoConfig {};_ca :=_a .SHA256 .New ();_ca .Write (_bdae ._cf .Raw );var _ag struct{Seq struct{Seq struct{Value []byte ;};};};_ag .Seq .Seq .Value =_ca .Sum (nil );
var _gaf []*_bd .Certificate ;var _dgaa []*_bd .Certificate ;if _bdae ._cga !=nil {_dgaa =[]*_bd .Certificate {_bdae ._cga };};_befe :=RevocationInfoArchival {Crl :[]_g .RawValue {},Ocsp :[]_g .RawValue {},OtherRevInfo :[]_g .RawValue {}};_gbee :=0;if _bdae ._dga !=nil &&len (_bdae ._cef )> 0{_cfa ,_cbe :=_bdae .makeTimestampRequest (_bdae ._cef ,([]byte )(""));
if _cbe !=nil {return _cbe ;};_fbcb ,_cbe :=_ef .Parse (_cfa .FullBytes );if _cbe !=nil {return _cbe ;};_gaf =append (_gaf ,_fbcb .Certificates ...);};if _bdae ._dga !=nil {_fgfe ,_gca :=_bdae .addDss ([]*_bd .Certificate {_bdae ._cf },_dgaa ,&_befe );
if _gca !=nil {return _gca ;};_gbee +=_fgfe ;if len (_gaf )> 0{_fgfe ,_gca =_bdae .addDss (_gaf ,nil ,&_befe );if _gca !=nil {return _gca ;};_gbee +=_fgfe ;};if !_bdae ._dae {_bdae ._dga .SetDSS (_bdae ._egd );};};_dac .ExtraSignedAttributes =append (_dac .ExtraSignedAttributes ,_bbf .Attribute {Type :_bbf .OIDAttributeSigningCertificateV2 ,Value :_ag },_bbf .Attribute {Type :_bbf .OIDAttributeAdobeRevocation ,Value :_befe });
if _cee :=_dfb .AddSignerChainPAdES (_bdae ._cf ,_bdae ._ae ,_dgaa ,_dac );_cee !=nil {return _cee ;};_dfb .Detach ();if len (_bdae ._cef )> 0{_dfg :=_dfb .GetSignedData ().SignerInfos [0].EncryptedDigest ;_fcf ,_aeb :=_bdae .makeTimestampRequest (_bdae ._cef ,_dfg );
if _aeb !=nil {return _aeb ;};_aeb =_dfb .AddTimestampTokenToSigner (0,_fcf .FullBytes );if _aeb !=nil {return _aeb ;};};_cfea ,_dbc :=_dfb .Finish ();if _dbc !=nil {return _dbc ;};_gd :=make ([]byte ,len (_cfea )+1024*2+_gbee );copy (_gd ,_cfea );sig .Contents =_gb .MakeHexString (string (_gd ));
if !_bdae ._dae &&_bdae ._egd !=nil {_ca =_a .SHA1 .New ();_ca .Write (_gd );_dgc :=_b .ToUpper (_db .EncodeToString (_ca .Sum (nil )));if _dgc !=""{_bdae ._egd .VRI [_dgc ]=&_eee .VRI {Cert :_bdae ._egd .Certs ,OCSP :_bdae ._egd .OCSPs ,CRL :_bdae ._egd .CRLs };
};_bdae ._dga .SetDSS (_bdae ._egd );};return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ba *DocMDPHandler )IsApplicable (sig *_eee .PdfSignature )bool {_gf :=false ;for _ ,_dbb :=range sig .Reference .Elements (){if _dad ,_ce :=_gb .GetDict (_dbb );_ce {if _bf ,_ec :=_gb .GetNameVal (_dad .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_ec {if _bf !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _egf ,_bbb :=_gb .GetDict (_dad .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_bbb {_ ,_bc :=_gb .GetNumberAsInt64 (_egf .Get ("\u0050"));
if _bc !=nil {return false ;};_gf =true ;break ;};};};};return _gf &&_ba ._eeb .IsApplicable (sig );};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_dbgd *adobeX509RSASHA1 )IsApplicable (sig *_eee .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};

// Validate validates PdfSignature.
func (_dabd *etsiPAdES )Validate (sig *_eee .PdfSignature ,digest _eee .Hasher )(_eee .SignatureValidationResult ,error ){_gac :=sig .Contents .Bytes ();_cggd ,_bcc :=_bbf .Parse (_gac );if _bcc !=nil {return _eee .SignatureValidationResult {},_bcc ;};
_bgb ,_fed :=digest .(*_be .Buffer );if !_fed {return _eee .SignatureValidationResult {},_bb .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_cggd .Content =_bgb .Bytes ();if _bcc =_cggd .Verify ();
_bcc !=nil {return _eee .SignatureValidationResult {},_bcc ;};_fcc :=false ;_egc :=false ;var _ede _dg .Time ;for _ ,_bec :=range _cggd .Signers {_dee :=_bec .EncryptedDigest ;var _ab RevocationInfoArchival ;_bcc =_cggd .UnmarshalSignedAttribute (_bbf .OIDAttributeAdobeRevocation ,&_ab );
if _bcc ==nil {if len (_ab .Crl )> 0{_egc =true ;};if len (_ab .Ocsp )> 0{_fcc =true ;};};for _ ,_adgd :=range _bec .UnauthenticatedAttributes {if _adgd .Type .Equal (_bbf .OIDAttributeTimeStampToken ){_ea ,_cdg :=_ef .Parse (_adgd .Value .Bytes );if _cdg !=nil {return _eee .SignatureValidationResult {},_cdg ;
};_ede =_ea .Time ;_abb :=_ea .HashAlgorithm .New ();_abb .Write (_dee );if !_be .Equal (_abb .Sum (nil ),_ea .HashedMessage ){return _eee .SignatureValidationResult {},_bb .Errorf ("\u0048\u0061\u0073\u0068\u0020i\u006e\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0069s\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020\u0070\u006b\u0063\u0073\u0037");
};break ;};};};_cfad :=_eee .SignatureValidationResult {IsSigned :true ,IsVerified :true ,IsCrlFound :_egc ,IsOcspFound :_fcc ,GeneralizedTime :_ede };return _cfad ,nil ;};

// NewDigest creates a new digest.
func (_fafg *docTimeStamp )NewDigest (sig *_eee .PdfSignature )(_eee .Hasher ,error ){return _be .NewBuffer (nil ),nil ;};

// Sign adds a new reference to signature's references array.
func (_aab *DocMDPHandler )Sign (sig *_eee .PdfSignature ,digest _eee .Hasher )error {return _aab ._eeb .Sign (sig ,digest );};type etsiPAdES struct{_ae *_cb .PrivateKey ;_cf *_bd .Certificate ;_cdf bool ;_dae bool ;_cga *_bd .Certificate ;_cef string ;


// CertClient is the client used to retrieve certificates.
CertClient *_eg .CertClient ;

// OCSPClient is the client used to retrieve OCSP validation information.
OCSPClient *_eg .OCSPClient ;

// CRLClient is the client used to retrieve CRL validation information.
CRLClient *_eg .CRLClient ;_dga *_eee .PdfAppender ;_egd *_eee .DSS ;};func (_cag *etsiPAdES )addDss (_efd ,_dab []*_bd .Certificate ,_gfe *RevocationInfoArchival )(int ,error ){_faa ,_fcg ,_dbgg :=_cag .buildCertChain (_efd ,_dab );if _dbgg !=nil {return 0,_dbgg ;
};_aaac ,_dbgg :=_cag .getCerts (_faa );if _dbgg !=nil {return 0,_dbgg ;};var _fda ,_gde [][]byte ;if _cag .OCSPClient !=nil {_fda ,_dbgg =_cag .getOCSPs (_faa ,_fcg );if _dbgg !=nil {return 0,_dbgg ;};};if _cag .CRLClient !=nil {_gde ,_dbgg =_cag .getCRLs (_faa );
if _dbgg !=nil {return 0,_dbgg ;};};if !_cag ._dae {_ ,_dbgg =_cag ._egd .AddCerts (_aaac );if _dbgg !=nil {return 0,_dbgg ;};_ ,_dbgg =_cag ._egd .AddOCSPs (_fda );if _dbgg !=nil {return 0,_dbgg ;};_ ,_dbgg =_cag ._egd .AddCRLs (_gde );if _dbgg !=nil {return 0,_dbgg ;
};};_bgg :=0;for _ ,_fagb :=range _gde {_bgg +=len (_fagb );_gfe .Crl =append (_gfe .Crl ,_g .RawValue {FullBytes :_fagb });};for _ ,_egb :=range _fda {_bgg +=len (_egb );_gfe .Ocsp =append (_gfe .Ocsp ,_g .RawValue {FullBytes :_egb });};return _bgg ,nil ;
};

// NewEtsiPAdESLevelB creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
func NewEtsiPAdESLevelB (privateKey *_cb .PrivateKey ,certificate *_bd .Certificate ,caCert *_bd .Certificate )(_eee .SignatureHandler ,error ){return &etsiPAdES {_cf :certificate ,_ae :privateKey ,_cga :caCert },nil ;};

// NewDigest creates a new digest.
func (_cbb *adobePKCS7Detached )NewDigest (sig *_eee .PdfSignature )(_eee .Hasher ,error ){return _be .NewBuffer (nil ),nil ;};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _eee .SignatureHandler ,permission _cd .DocMDPPermission )(_eee .SignatureHandler ,error ){return &DocMDPHandler {_eeb :handler ,Permission :permission },nil ;};func (_egg *adobeX509RSASHA1 )getCertificate (_eef *_eee .PdfSignature )(*_bd .Certificate ,error ){if _egg ._dbcg !=nil {return _egg ._dbcg ,nil ;
};_bgga ,_gcd :=_eef .GetCerts ();if _gcd !=nil {return nil ,_gcd ;};return _bgga [0],nil ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_cb .PrivateKey ,certificate *_bd .Certificate )(_eee .SignatureHandler ,error ){return &adobePKCS7Detached {_adgb :certificate ,_fgc :privateKey },nil ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _a .Hash ,opts *DocTimeStampOpts )(_eee .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_ffg :timestampServerURL ,_gbb :hashAlgorithm ,_aeg :opts .SignatureSize ,_ced :opts .Client },nil ;
};func _baa (_dcg _g .ObjectIdentifier )(_a .Hash ,error ){switch {case _dcg .Equal (_bbf .OIDDigestAlgorithmSHA1 ),_dcg .Equal (_bbf .OIDDigestAlgorithmECDSASHA1 ),_dcg .Equal (_bbf .OIDDigestAlgorithmDSA ),_dcg .Equal (_bbf .OIDDigestAlgorithmDSASHA1 ),_dcg .Equal (_bbf .OIDEncryptionAlgorithmRSA ):return _a .SHA1 ,nil ;
case _dcg .Equal (_bbf .OIDDigestAlgorithmSHA256 ),_dcg .Equal (_bbf .OIDDigestAlgorithmECDSASHA256 ):return _a .SHA256 ,nil ;case _dcg .Equal (_bbf .OIDDigestAlgorithmSHA384 ),_dcg .Equal (_bbf .OIDDigestAlgorithmECDSASHA384 ):return _a .SHA384 ,nil ;
case _dcg .Equal (_bbf .OIDDigestAlgorithmSHA512 ),_dcg .Equal (_bbf .OIDDigestAlgorithmECDSASHA512 ):return _a .SHA512 ,nil ;};return _a .Hash (0),_bbf .ErrUnsupportedAlgorithm ;};type timestampInfo struct{Version int ;Policy _g .RawValue ;MessageImprint struct{HashAlgorithm _e .AlgorithmIdentifier ;
HashedMessage []byte ;};SerialNumber _g .RawValue ;GeneralizedTime _dg .Time ;};

// NewDigest creates a new digest.
func (_eed *DocMDPHandler )NewDigest (sig *_eee .PdfSignature )(_eee .Hasher ,error ){return _eed ._eeb .NewDigest (sig );};

// InitSignature initialises the PdfSignature.
func (_add *adobeX509RSASHA1 )InitSignature (sig *_eee .PdfSignature )error {if _add ._dbcg ==nil {return _c .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _add ._ebd ==nil &&_add ._faaf ==nil {return _c .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_egcd :=*_add ;sig .Handler =&_egcd ;sig .Filter =_gb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_gb .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_gb .MakeString (string (_egcd ._dbcg .Raw ));sig .Reference =nil ;_bdd ,_bfag :=_egcd .NewDigest (sig );if _bfag !=nil {return _bfag ;};_bdd .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _egcd .sign (sig ,_bdd ,_add ._fce );};

// InitSignature initialization of the DocMDP signature.
func (_fga *DocMDPHandler )InitSignature (sig *_eee .PdfSignature )error {_bbg :=_fga ._eeb .InitSignature (sig );if _bbg !=nil {return _bbg ;};sig .Handler =_fga ;if sig .Reference ==nil {sig .Reference =_gb .MakeArray ();};sig .Reference .Append (_eee .NewPdfSignatureReferenceDocMDP (_eee .NewPdfTransformParamsDocMDP (_fga .Permission )).ToPdfObject ());
return nil ;};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_gc *DocMDPHandler )Validate (sig *_eee .PdfSignature ,digest _eee .Hasher )(_eee .SignatureValidationResult ,error ){return _eee .SignatureValidationResult {},_c .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};func (_ccc *etsiPAdES )getCRLs (_acf []*_bd .Certificate )([][]byte ,error ){_deca :=make ([][]byte ,0,len (_acf ));for _ ,_cfe :=range _acf {for _ ,_bbc :=range _cfe .CRLDistributionPoints {if _ccc .CertClient .IsCA (_cfe ){continue ;};_ada ,_af :=_ccc .CRLClient .MakeRequest (_bbc ,_cfe );
if _af !=nil {_ee .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076",_af );continue ;};_deca =append (_deca ,_ada );};};return _deca ,nil ;};

// InitSignature initialises the PdfSignature.
func (_bce *adobePKCS7Detached )InitSignature (sig *_eee .PdfSignature )error {if !_bce ._cbf {if _bce ._adgb ==nil {return _c .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _bce ._fgc ==nil {return _c .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_fef :=*_bce ;sig .Handler =&_fef ;sig .Filter =_gb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_gb .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_dba ,_gaa :=_fef .NewDigest (sig );if _gaa !=nil {return _gaa ;};_dba .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _fef .Sign (sig ,_dba );};

// Validate validates PdfSignature.
func (_bgbb *docTimeStamp )Validate (sig *_eee .PdfSignature ,digest _eee .Hasher )(_eee .SignatureValidationResult ,error ){_bea :=sig .Contents .Bytes ();_adf ,_eaa :=_bbf .Parse (_bea );if _eaa !=nil {return _eee .SignatureValidationResult {},_eaa ;
};if _eaa =_adf .Verify ();_eaa !=nil {return _eee .SignatureValidationResult {},_eaa ;};var _aed timestampInfo ;_ ,_eaa =_g .Unmarshal (_adf .Content ,&_aed );if _eaa !=nil {return _eee .SignatureValidationResult {},_eaa ;};_dddc ,_eaa :=_baa (_aed .MessageImprint .HashAlgorithm .Algorithm );
if _eaa !=nil {return _eee .SignatureValidationResult {},_eaa ;};_bead :=_dddc .New ();_ffc ,_egdg :=digest .(*_be .Buffer );if !_egdg {return _eee .SignatureValidationResult {},_bb .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");
};_bead .Write (_ffc .Bytes ());_fgca :=_bead .Sum (nil );_ccg :=_eee .SignatureValidationResult {IsSigned :true ,IsVerified :_be .Equal (_fgca ,_aed .MessageImprint .HashedMessage ),GeneralizedTime :_aed .GeneralizedTime };return _ccg ,nil ;};

// NewDigest creates a new digest.
func (_faf *etsiPAdES )NewDigest (_ *_eee .PdfSignature )(_eee .Hasher ,error ){return _be .NewBuffer (nil ),nil ;};