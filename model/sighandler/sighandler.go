//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_dg "bytes";_eb "crypto";_fg "crypto/rand";_be "crypto/rsa";_ec "crypto/x509";_dae "crypto/x509/pkix";_a "encoding/asn1";_bg "encoding/hex";_g "errors";_da "fmt";_c "github.com/unidoc/pkcs7";_af "github.com/unidoc/timestamp";
_ed "github.com/unidoc/unipdf/v3/common";_bgd "github.com/unidoc/unipdf/v3/core";_fc "github.com/unidoc/unipdf/v3/model";_dga "github.com/unidoc/unipdf/v3/model/mdp";_bgf "github.com/unidoc/unipdf/v3/model/sigutil";_fb "hash";_f "math/big";_d "strings";
_e "time";);type etsiPAdES struct{_gce *_be .PrivateKey ;_dbc *_ec .Certificate ;_ge bool ;_gcf bool ;_cfe *_ec .Certificate ;_bgbg string ;

// CertClient is the client used to retrieve certificates.
CertClient *_bgf .CertClient ;

// OCSPClient is the client used to retrieve OCSP validation information.
OCSPClient *_bgf .OCSPClient ;

// CRLClient is the client used to retrieve CRL validation information.
CRLClient *_bgf .CRLClient ;_dd *_fc .PdfAppender ;_bba *_fc .DSS ;};type docTimeStamp struct{_abd string ;_fae _eb .Hash ;_fbgg int ;_cde *_bgf .TimestampClient ;};

// RevocationInfoArchival is OIDAttributeAdobeRevocation attribute.
type RevocationInfoArchival struct{Crl []_a .RawValue `asn1:"explicit,tag:0,optional"`;Ocsp []_a .RawValue `asn1:"explicit,tag:1,optional"`;OtherRevInfo []_a .RawValue `asn1:"explicit,tag:2,optional"`;};

// NewDigest creates a new digest.
func (_aag *adobePKCS7Detached )NewDigest (sig *_fc .PdfSignature )(_fc .Hasher ,error ){return _dg .NewBuffer (nil ),nil ;};

// NewEtsiPAdESLevelLT creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
func NewEtsiPAdESLevelLT (privateKey *_be .PrivateKey ,certificate *_ec .Certificate ,caCert *_ec .Certificate ,certificateTimestampServerURL string ,appender *_fc .PdfAppender )(_fc .SignatureHandler ,error ){_fbf :=appender .Reader .DSS ;if _fbf ==nil {_fbf =_fc .NewDSS ();
};if _bgb :=_fbf .GenerateHashMaps ();_bgb !=nil {return nil ,_bgb ;};return &etsiPAdES {_dbc :certificate ,_gce :privateKey ,_cfe :caCert ,_bgbg :certificateTimestampServerURL ,CertClient :_bgf .NewCertClient (),OCSPClient :_bgf .NewOCSPClient (),CRLClient :_bgf .NewCRLClient (),_dd :appender ,_bba :_fbf },nil ;
};func (_aaba *docTimeStamp )getCertificate (_bcdd *_fc .PdfSignature )(*_ec .Certificate ,error ){_fdcf ,_cbcf :=_bcdd .GetCerts ();if _cbcf !=nil {return nil ,_cbcf ;};return _fdcf [0],nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_ec .Certificate ,signFunc SignFunc )(_fc .SignatureHandler ,error ){return &adobeX509RSASHA1 {_acf :certificate ,_acd :signFunc },nil ;};func (_ade *adobeX509RSASHA1 )sign (_dbag *_fc .PdfSignature ,_egbe _fc .Hasher ,_dee bool )error {if !_dee {return _ade .Sign (_dbag ,_egbe );
};_afeb ,_gcaf :=_ade ._acf .PublicKey .(*_be .PublicKey );if !_gcaf {return _da .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_afeb );};_aedb ,_aab :=_a .Marshal (make ([]byte ,_afeb .Size ()));
if _aab !=nil {return _aab ;};_dbag .Contents =_bgd .MakeHexString (string (_aedb ));return nil ;};

// InitSignature initialises the PdfSignature.
func (_bfg *etsiPAdES )InitSignature (sig *_fc .PdfSignature )error {if !_bfg ._ge {if _bfg ._dbc ==nil {return _g .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _bfg ._gce ==nil {return _g .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_cb :=*_bfg ;sig .Handler =&_cb ;sig .Filter =_bgd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_bgd .MakeName ("\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_dcc ,_gaaf :=_cb .NewDigest (sig );if _gaaf !=nil {return _gaaf ;};_ ,_gaaf =_dcc .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _gaaf !=nil {return _gaaf ;};_cb ._gcf =true ;_gaaf =_cb .Sign (sig ,_dcc );_cb ._gcf =false ;return _gaaf ;};

// InitSignature initialises the PdfSignature.
func (_gdg *adobePKCS7Detached )InitSignature (sig *_fc .PdfSignature )error {if !_gdg ._ebg {if _gdg ._ddb ==nil {return _g .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _gdg ._eed ==nil {return _g .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_fbg :=*_gdg ;sig .Handler =&_fbg ;sig .Filter =_bgd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_bgd .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_egb ,_geed :=_fbg .NewDigest (sig );if _geed !=nil {return _geed ;};_egb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _fbg .Sign (sig ,_egb );};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_efcf *_fc .PdfSignature ,_aedd _fc .Hasher )([]byte ,error );func _bcef (_fdg []byte ,_cad int )(_bcad []byte ){_abeg :=len (_fdg );if _abeg > _cad {_abeg =_cad ;};_bcad =make ([]byte ,_cad );copy (_bcad [len (_bcad )-_abeg :],_fdg );
return ;};

// Validate validates PdfSignature.
func (_gba *etsiPAdES )Validate (sig *_fc .PdfSignature ,digest _fc .Hasher )(_fc .SignatureValidationResult ,error ){_gbb :=sig .Contents .Bytes ();_feg ,_eda :=_c .Parse (_gbb );if _eda !=nil {return _fc .SignatureValidationResult {},_eda ;};_aea ,_aba :=digest .(*_dg .Buffer );
if !_aba {return _fc .SignatureValidationResult {},_da .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_feg .Content =_aea .Bytes ();if _eda =_feg .Verify ();_eda !=nil {return _fc .SignatureValidationResult {},_eda ;
};_gaea :=false ;_bgcg :=false ;var _gcdf _e .Time ;for _ ,_efc :=range _feg .Signers {_gfda :=_efc .EncryptedDigest ;var _faf RevocationInfoArchival ;_eda =_feg .UnmarshalSignedAttribute (_c .OIDAttributeAdobeRevocation ,&_faf );if _eda ==nil {if len (_faf .Crl )> 0{_bgcg =true ;
};if len (_faf .Ocsp )> 0{_gaea =true ;};};for _ ,_ggb :=range _efc .UnauthenticatedAttributes {if _ggb .Type .Equal (_c .OIDAttributeTimeStampToken ){_aebc ,_ega :=_af .Parse (_ggb .Value .Bytes );if _ega !=nil {return _fc .SignatureValidationResult {},_ega ;
};_gcdf =_aebc .Time ;_ddc :=_aebc .HashAlgorithm .New ();_ddc .Write (_gfda );if !_dg .Equal (_ddc .Sum (nil ),_aebc .HashedMessage ){return _fc .SignatureValidationResult {},_da .Errorf ("\u0048\u0061\u0073\u0068\u0020i\u006e\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0069s\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020\u0070\u006b\u0063\u0073\u0037");
};break ;};};};_dgf :=_fc .SignatureValidationResult {IsSigned :true ,IsVerified :true ,IsCrlFound :_bgcg ,IsOcspFound :_gaea ,GeneralizedTime :_gcdf };return _dgf ,nil ;};func (_ceag *etsiPAdES )getCerts (_egf []*_ec .Certificate )([][]byte ,error ){_ada :=make ([][]byte ,0,len (_egf ));
for _ ,_adf :=range _egf {_ada =append (_ada ,_adf .Raw );};return _ada ,nil ;};

// Validate validates PdfSignature.
func (_bff *adobePKCS7Detached )Validate (sig *_fc .PdfSignature ,digest _fc .Hasher )(_fc .SignatureValidationResult ,error ){_ccd :=sig .Contents .Bytes ();_fef ,_ded :=_c .Parse (_ccd );if _ded !=nil {return _fc .SignatureValidationResult {},_ded ;};
_fed ,_fbgc :=digest .(*_dg .Buffer );if !_fbgc {return _fc .SignatureValidationResult {},_da .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_fef .Content =_fed .Bytes ();if _ded =_fef .Verify ();
_ded !=nil {return _fc .SignatureValidationResult {},_ded ;};return _fc .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_be .PrivateKey ,certificate *_ec .Certificate )(_fc .SignatureHandler ,error ){return &adobePKCS7Detached {_ddb :certificate ,_eed :privateKey },nil ;};func _ffdf (_aae _a .ObjectIdentifier )(_eb .Hash ,error ){switch {case _aae .Equal (_c .OIDDigestAlgorithmSHA1 ),_aae .Equal (_c .OIDDigestAlgorithmECDSASHA1 ),_aae .Equal (_c .OIDDigestAlgorithmDSA ),_aae .Equal (_c .OIDDigestAlgorithmDSASHA1 ),_aae .Equal (_c .OIDEncryptionAlgorithmRSA ):return _eb .SHA1 ,nil ;
case _aae .Equal (_c .OIDDigestAlgorithmSHA256 ),_aae .Equal (_c .OIDDigestAlgorithmECDSASHA256 ):return _eb .SHA256 ,nil ;case _aae .Equal (_c .OIDDigestAlgorithmSHA384 ),_aae .Equal (_c .OIDDigestAlgorithmECDSASHA384 ):return _eb .SHA384 ,nil ;case _aae .Equal (_c .OIDDigestAlgorithmSHA512 ),_aae .Equal (_c .OIDDigestAlgorithmECDSASHA512 ):return _eb .SHA512 ,nil ;
};return _eb .Hash (0),_c .ErrUnsupportedAlgorithm ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_bab *docTimeStamp )IsApplicable (sig *_fc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};

// Sign adds a new reference to signature's references array.
func (_dfd *DocMDPHandler )Sign (sig *_fc .PdfSignature ,digest _fc .Hasher )error {return _dfd ._fa .Sign (sig ,digest );};func (_gcfc *etsiPAdES )buildCertChain (_dgag ,_abe []*_ec .Certificate )([]*_ec .Certificate ,map[string ]*_ec .Certificate ,error ){_bfgd :=map[string ]*_ec .Certificate {};
for _ ,_gee :=range _dgag {_bfgd [_gee .Subject .CommonName ]=_gee ;};_fgca :=_dgag ;for _ ,_ag :=range _abe {_cbc :=_ag .Subject .CommonName ;if _ ,_ddff :=_bfgd [_cbc ];_ddff {continue ;};_bfgd [_cbc ]=_ag ;_fgca =append (_fgca ,_ag );};if len (_fgca )==0{return nil ,nil ,_fc .ErrSignNoCertificates ;
};var _edd error ;for _bbf :=_fgca [0];_bbf !=nil &&!_gcfc .CertClient .IsCA (_bbf );{var _aff *_ec .Certificate ;_ ,_bgc :=_bfgd [_bbf .Issuer .CommonName ];if !_bgc {if _aff ,_edd =_gcfc .CertClient .GetIssuer (_bbf );_edd !=nil {_ed .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076",_edd );
break ;};_bfgd [_bbf .Issuer .CommonName ]=_aff ;_fgca =append (_fgca ,_aff );}else {break ;};_bbf =_aff ;};return _fgca ,_bfgd ,nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_affg *adobePKCS7Detached )IsApplicable (sig *_fc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_bgf .TimestampClient ;};

// Sign sets the Contents fields for the PdfSignature.
func (_faa *etsiPAdES )Sign (sig *_fc .PdfSignature ,digest _fc .Hasher )error {_dbcc ,_dcf :=digest .(*_dg .Buffer );if !_dcf {return _da .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_bbe ,_deg :=_c .NewSignedData (_dbcc .Bytes ());
if _deg !=nil {return _deg ;};_bbe .SetDigestAlgorithm (_c .OIDDigestAlgorithmSHA256 );_aec :=_c .SignerInfoConfig {};_gb :=_eb .SHA256 .New ();_gb .Write (_faa ._dbc .Raw );var _fcd struct{Seq struct{Seq struct{Value []byte ;};};};_fcd .Seq .Seq .Value =_gb .Sum (nil );
var _bfbe []*_ec .Certificate ;var _dcd []*_ec .Certificate ;if _faa ._cfe !=nil {_dcd =[]*_ec .Certificate {_faa ._cfe };};_cag :=RevocationInfoArchival {Crl :[]_a .RawValue {},Ocsp :[]_a .RawValue {},OtherRevInfo :[]_a .RawValue {}};_aaf :=0;if _faa ._dd !=nil &&len (_faa ._bgbg )> 0{_ebc ,_dgc :=_faa .makeTimestampRequest (_faa ._bgbg ,([]byte )(""));
if _dgc !=nil {return _dgc ;};_fe ,_dgc :=_af .Parse (_ebc .FullBytes );if _dgc !=nil {return _dgc ;};_bfbe =append (_bfbe ,_fe .Certificates ...);};if _faa ._dd !=nil {_bee ,_adg :=_faa .addDss ([]*_ec .Certificate {_faa ._dbc },_dcd ,&_cag );if _adg !=nil {return _adg ;
};_aaf +=_bee ;if len (_bfbe )> 0{_bee ,_adg =_faa .addDss (_bfbe ,nil ,&_cag );if _adg !=nil {return _adg ;};_aaf +=_bee ;};if !_faa ._gcf {_faa ._dd .SetDSS (_faa ._bba );};};_aec .ExtraSignedAttributes =append (_aec .ExtraSignedAttributes ,_c .Attribute {Type :_c .OIDAttributeSigningCertificateV2 ,Value :_fcd },_c .Attribute {Type :_c .OIDAttributeAdobeRevocation ,Value :_cag });
if _gd :=_bbe .AddSignerChainPAdES (_faa ._dbc ,_faa ._gce ,_dcd ,_aec );_gd !=nil {return _gd ;};_bbe .Detach ();if len (_faa ._bgbg )> 0{_ege :=_bbe .GetSignedData ().SignerInfos [0].EncryptedDigest ;_dba ,_gca :=_faa .makeTimestampRequest (_faa ._bgbg ,_ege );
if _gca !=nil {return _gca ;};_gca =_bbe .AddTimestampTokenToSigner (0,_dba .FullBytes );if _gca !=nil {return _gca ;};};_dea ,_deg :=_bbe .Finish ();if _deg !=nil {return _deg ;};_gde :=make ([]byte ,len (_dea )+1024*2+_aaf );copy (_gde ,_dea );sig .Contents =_bgd .MakeHexString (string (_gde ));
if !_faa ._gcf &&_faa ._bba !=nil {_gb =_eb .SHA1 .New ();_gb .Write (_gde );_bea :=_d .ToUpper (_bg .EncodeToString (_gb .Sum (nil )));if _bea !=""{_faa ._bba .VRI [_bea ]=&_fc .VRI {Cert :_faa ._bba .Certs ,OCSP :_faa ._bba .OCSPs ,CRL :_faa ._bba .CRLs };
};_faa ._dd .SetDSS (_faa ._bba );};return nil ;};func (_bbd *etsiPAdES )getOCSPs (_ecg []*_ec .Certificate ,_bgg map[string ]*_ec .Certificate )([][]byte ,error ){_ecbe :=make ([][]byte ,0,len (_ecg ));for _ ,_ff :=range _ecg {for _ ,_gae :=range _ff .OCSPServer {if _bbd .CertClient .IsCA (_ff ){continue ;
};_de ,_aa :=_bgg [_ff .Issuer .CommonName ];if !_aa {_ed .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
continue ;};_ ,_eg ,_dcb :=_bbd .OCSPClient .MakeRequest (_gae ,_ff ,_de );if _dcb !=nil {_ed .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076",_dcb );
continue ;};_ecbe =append (_ecbe ,_eg );};};return _ecbe ,nil ;};const _adag =_eb .SHA1 ;

// Validate validates PdfSignature.
func (_fcc *docTimeStamp )Validate (sig *_fc .PdfSignature ,digest _fc .Hasher )(_fc .SignatureValidationResult ,error ){_fge :=sig .Contents .Bytes ();_cfc ,_feb :=_c .Parse (_fge );if _feb !=nil {return _fc .SignatureValidationResult {},_feb ;};if _feb =_cfc .Verify ();
_feb !=nil {return _fc .SignatureValidationResult {},_feb ;};var _dbg timestampInfo ;_ ,_feb =_a .Unmarshal (_cfc .Content ,&_dbg );if _feb !=nil {return _fc .SignatureValidationResult {},_feb ;};_cge ,_feb :=_ffdf (_dbg .MessageImprint .HashAlgorithm .Algorithm );
if _feb !=nil {return _fc .SignatureValidationResult {},_feb ;};_dec :=_cge .New ();_ffdg ,_bfbd :=digest .(*_dg .Buffer );if !_bfbd {return _fc .SignatureValidationResult {},_da .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");
};_dec .Write (_ffdg .Bytes ());_bdbg :=_dec .Sum (nil );_ecda :=_fc .SignatureValidationResult {IsSigned :true ,IsVerified :_dg .Equal (_bdbg ,_dbg .MessageImprint .HashedMessage ),GeneralizedTime :_dbg .GeneralizedTime };return _ecda ,nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ecf *adobeX509RSASHA1 )IsApplicable (sig *_fc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};type adobeX509RSASHA1 struct{_abaf *_be .PrivateKey ;_acf *_ec .Certificate ;_acd SignFunc ;_dde bool ;_ggc _eb .Hash ;};func (_abac *adobeX509RSASHA1 )getCertificate (_ccc *_fc .PdfSignature )(*_ec .Certificate ,error ){if _abac ._acf !=nil {return _abac ._acf ,nil ;
};_bcb ,_gac :=_ccc .GetCerts ();if _gac !=nil {return nil ,_gac ;};return _bcb [0],nil ;};type adobePKCS7Detached struct{_eed *_be .PrivateKey ;_ddb *_ec .Certificate ;_ebg bool ;_dac int ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _eb .Hash )(_fc .SignatureHandler ,error ){return &docTimeStamp {_abd :timestampServerURL ,_fae :hashAlgorithm },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gc *DocMDPHandler )IsApplicable (sig *_fc .PdfSignature )bool {_ecc :=false ;for _ ,_ecb :=range sig .Reference .Elements (){if _ga ,_bf :=_bgd .GetDict (_ecb );_bf {if _bc ,_gg :=_bgd .GetNameVal (_ga .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_gg {if _bc !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _bed ,_ebd :=_bgd .GetDict (_ga .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_ebd {_ ,_fga :=_bgd .GetNumberAsInt64 (_bed .Get ("\u0050"));
if _fga !=nil {return false ;};_ecc =true ;break ;};};};};return _ecc &&_gc ._fa .IsApplicable (sig );};

// Sign sets the Contents fields for the PdfSignature.
func (_gcc *adobeX509RSASHA1 )Sign (sig *_fc .PdfSignature ,digest _fc .Hasher )error {var _fca []byte ;var _dded error ;if _gcc ._acd !=nil {_fca ,_dded =_gcc ._acd (sig ,digest );if _dded !=nil {return _dded ;};}else {_eccg ,_aeag :=digest .(_fb .Hash );
if !_aeag {return _g .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fdca :=_adag ;if _gcc ._ggc !=0{_fdca =_gcc ._ggc ;};_fca ,_dded =_be .SignPKCS1v15 (_fg .Reader ,_gcc ._abaf ,_fdca ,_eccg .Sum (nil ));if _dded !=nil {return _dded ;
};};_fca ,_dded =_a .Marshal (_fca );if _dded !=nil {return _dded ;};sig .Contents =_bgd .MakeHexString (string (_fca ));return nil ;};func (_ee *etsiPAdES )getCRLs (_ffd []*_ec .Certificate )([][]byte ,error ){_fbd :=make ([][]byte ,0,len (_ffd ));for _ ,_bcd :=range _ffd {for _ ,_ecd :=range _bcd .CRLDistributionPoints {if _ee .CertClient .IsCA (_bcd ){continue ;
};_fgg ,_ac :=_ee .CRLClient .MakeRequest (_ecd ,_bcd );if _ac !=nil {_ed .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076",_ac );continue ;};_fbd =append (_fbd ,_fgg );
};};return _fbd ,nil ;};

// NewDigest creates a new digest.
func (_bdfg *docTimeStamp )NewDigest (sig *_fc .PdfSignature )(_fc .Hasher ,error ){return _dg .NewBuffer (nil ),nil ;};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_gaa *DocMDPHandler )Validate (sig *_fc .PdfSignature ,digest _fc .Hasher )(_fc .SignatureValidationResult ,error ){return _fc .SignatureValidationResult {},_g .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_bd *DocMDPHandler )ValidateWithOpts (sig *_fc .PdfSignature ,digest _fc .Hasher ,params _fc .SignatureHandlerDocMDPParams )(_fc .SignatureValidationResult ,error ){_bdc ,_ede :=_bd ._fa .Validate (sig ,digest );if _ede !=nil {return _bdc ,_ede ;
};_bb :=params .Parser ;if _bb ==nil {return _fc .SignatureValidationResult {},_g .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_bdc .IsVerified {return _bdc ,nil ;};_cf :=params .DiffPolicy ;
if _cf ==nil {_cf =_dga .NewDefaultDiffPolicy ();};for _cd :=0;_cd <=_bb .GetRevisionNumber ();_cd ++{_dc ,_fd :=_bb .GetRevision (_cd );if _fd !=nil {return _fc .SignatureValidationResult {},_fd ;};_df :=_dc .GetTrailer ();if _df ==nil {return _fc .SignatureValidationResult {},_g .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_cda ,_gcd :=_bgd .GetDict (_df .Get ("\u0052\u006f\u006f\u0074"));if !_gcd {return _fc .SignatureValidationResult {},_g .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");
};_fgc ,_gcd :=_bgd .GetDict (_cda .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_gcd {continue ;};_ae ,_gcd :=_bgd .GetArray (_fgc .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_gcd {continue ;};for _ ,_cef :=range _ae .Elements (){_ca ,_cea :=_bgd .GetDict (_cef );
if !_cea {continue ;};_beb ,_cea :=_bgd .GetDict (_ca .Get ("\u0056"));if !_cea {continue ;};if _bgd .EqualObjects (_beb .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_bdc .DiffResults ,_fd =_cf .ReviewFile (_dc ,_bb ,&_dga .MDPParameters {DocMDPLevel :_bd .Permission });
if _fd !=nil {return _fc .SignatureValidationResult {},_fd ;};_bdc .IsVerified =_bdc .DiffResults .IsPermitted ();return _bdc ,nil ;};};};return _fc .SignatureValidationResult {},_g .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};

// InitSignature initialization of the DocMDP signature.
func (_bdb *DocMDPHandler )InitSignature (sig *_fc .PdfSignature )error {_aed :=_bdb ._fa .InitSignature (sig );if _aed !=nil {return _aed ;};sig .Handler =_bdb ;if sig .Reference ==nil {sig .Reference =_bgd .MakeArray ();};sig .Reference .Append (_fc .NewPdfSignatureReferenceDocMDP (_fc .NewPdfTransformParamsDocMDP (_bdb .Permission )).ToPdfObject ());
return nil ;};

// NewDigest creates a new digest.
func (_egff *adobeX509RSASHA1 )NewDigest (sig *_fc .PdfSignature )(_fc .Hasher ,error ){if _dfb ,_cbed :=_egff .getHashAlgorithm (sig );_dfb !=0&&_cbed ==nil {return _dfb .New (),nil ;};return _adag .New (),nil ;};

// Validate validates PdfSignature.
func (_ecbee *adobeX509RSASHA1 )Validate (sig *_fc .PdfSignature ,digest _fc .Hasher )(_fc .SignatureValidationResult ,error ){_edeg ,_cfbe :=_ecbee .getCertificate (sig );if _cfbe !=nil {return _fc .SignatureValidationResult {},_cfbe ;};_fac :=sig .Contents .Bytes ();
var _fgb []byte ;if _ ,_faac :=_a .Unmarshal (_fac ,&_fgb );_faac !=nil {return _fc .SignatureValidationResult {},_faac ;};_fbe ,_egad :=digest .(_fb .Hash );if !_egad {return _fc .SignatureValidationResult {},_g .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_fdb ,_ :=_ecbee .getHashAlgorithm (sig );if _fdb ==0{_fdb =_adag ;};if _fggd :=_be .VerifyPKCS1v15 (_edeg .PublicKey .(*_be .PublicKey ),_fdb ,_fbe .Sum (nil ),_fgb );_fggd !=nil {return _fc .SignatureValidationResult {},_fggd ;};return _fc .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _fc .SignatureHandler ,permission _dga .DocMDPPermission )(_fc .SignatureHandler ,error ){return &DocMDPHandler {_fa :handler ,Permission :permission },nil ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _eb .Hash ;};

// InitSignature initialises the PdfSignature.
func (_cae *docTimeStamp )InitSignature (sig *_fc .PdfSignature )error {_aedc :=*_cae ;sig .Type =_bgd .MakeName ("\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070");sig .Handler =&_aedc ;sig .Filter =_bgd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_bgd .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _cae ._fbgg > 0{sig .Contents =_bgd .MakeHexString (string (make ([]byte ,_cae ._fbgg )));}else {_adgg ,_gga :=_cae .NewDigest (sig );
if _gga !=nil {return _gga ;};_adgg .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _gga =_aedc .Sign (sig ,_adgg );
_gga !=nil {return _gga ;};_cae ._fbgg =_aedc ._fbgg ;};return nil ;};

// NewDigest creates a new digest.
func (_gf *DocMDPHandler )NewDigest (sig *_fc .PdfSignature )(_fc .Hasher ,error ){return _gf ._fa .NewDigest (sig );};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_be .PrivateKey ,certificate *_ec .Certificate )(_fc .SignatureHandler ,error ){return &adobeX509RSASHA1 {_acf :certificate ,_abaf :privateKey },nil ;};func (_gefg *adobePKCS7Detached )getCertificate (_cbee *_fc .PdfSignature )(*_ec .Certificate ,error ){if _gefg ._ddb !=nil {return _gefg ._ddb ,nil ;
};_cc ,_ffc :=_cbee .GetCerts ();if _ffc !=nil {return nil ,_ffc ;};return _cc [0],nil ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _eb .Hash ,opts *DocTimeStampOpts )(_fc .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_abd :timestampServerURL ,_fae :hashAlgorithm ,_fbgg :opts .SignatureSize ,_cde :opts .Client },nil ;
};

// InitSignature initialises the PdfSignature.
func (_gfc *adobeX509RSASHA1 )InitSignature (sig *_fc .PdfSignature )error {if _gfc ._acf ==nil {return _g .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _gfc ._abaf ==nil &&_gfc ._acd ==nil {return _g .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_afeg :=*_gfc ;sig .Handler =&_afeg ;sig .Filter =_bgd .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_bgd .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_bgd .MakeString (string (_afeg ._acf .Raw ));sig .Reference =nil ;_cga ,_ddce :=_afeg .NewDigest (sig );if _ddce !=nil {return _ddce ;};_cga .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _afeg .sign (sig ,_cga ,_gfc ._dde );};

// NewEtsiPAdESLevelT creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
func NewEtsiPAdESLevelT (privateKey *_be .PrivateKey ,certificate *_ec .Certificate ,caCert *_ec .Certificate ,certificateTimestampServerURL string )(_fc .SignatureHandler ,error ){return &etsiPAdES {_dbc :certificate ,_gce :privateKey ,_cfe :caCert ,_bgbg :certificateTimestampServerURL },nil ;
};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_ec .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_fc .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_acf :certificate ,_acd :signFunc ,_dde :opts .EstimateSize ,_ggc :opts .Algorithm },nil ;
};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_baf *etsiPAdES )IsApplicable (sig *_fc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};func (_cg *etsiPAdES )makeTimestampRequest (_cgc string ,_cbe []byte )(_a .RawValue ,error ){_ece :=_eb .SHA512 .New ();_ece .Write (_cbe );_ab :=_ece .Sum (nil );_ad :=_af .Request {HashAlgorithm :_eb .SHA512 ,HashedMessage :_ab ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };
_aeb :=_bgf .NewTimestampClient ();_dcg ,_fbb :=_aeb .GetEncodedToken (_cgc ,&_ad );if _fbb !=nil {return _a .NullRawValue ,_fbb ;};return _a .RawValue {FullBytes :_dcg },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_dge *docTimeStamp )Sign (sig *_fc .PdfSignature ,digest _fc .Hasher )error {_beef ,_aeagc :=_bgf .NewTimestampRequest (digest .(*_dg .Buffer ),&_af .RequestOptions {Hash :_dge ._fae ,Certificates :true });if _aeagc !=nil {return _aeagc ;};_gbc :=_dge ._cde ;
if _gbc ==nil {_gbc =_bgf .NewTimestampClient ();};_ffg ,_aeagc :=_gbc .GetEncodedToken (_dge ._abd ,_beef );if _aeagc !=nil {return _aeagc ;};_eff :=len (_ffg );if _dge ._fbgg > 0&&_eff > _dge ._fbgg {return _fc .ErrSignNotEnoughSpace ;};if _eff > 0{_dge ._fbgg =_eff +128;
};if sig .Contents !=nil {_fdf :=sig .Contents .Bytes ();copy (_fdf ,_ffg );_ffg =_fdf ;};sig .Contents =_bgd .MakeHexString (string (_ffg ));return nil ;};func (_caa *adobeX509RSASHA1 )getHashAlgorithm (_ebca *_fc .PdfSignature )(_eb .Hash ,error ){_dgcc ,_bedf :=_caa .getCertificate (_ebca );
if _bedf !=nil {if _caa ._ggc !=0{return _caa ._ggc ,nil ;};return _adag ,_bedf ;};if _ebca .Contents !=nil {_bddc :=_ebca .Contents .Bytes ();var _gaeab []byte ;if _ ,_fde :=_a .Unmarshal (_bddc ,&_gaeab );_fde ==nil {_agg :=_bfbb (_dgcc .PublicKey .(*_be .PublicKey ),_gaeab );
if _agg > 0{return _agg ,nil ;};};};if _caa ._ggc !=0{return _caa ._ggc ,nil ;};return _adag ,nil ;};

// NewEtsiPAdESLevelB creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
func NewEtsiPAdESLevelB (privateKey *_be .PrivateKey ,certificate *_ec .Certificate ,caCert *_ec .Certificate )(_fc .SignatureHandler ,error ){return &etsiPAdES {_dbc :certificate ,_gce :privateKey ,_cfe :caCert },nil ;};func (_fbfg *etsiPAdES )addDss (_dbba ,_adc []*_ec .Certificate ,_afe *RevocationInfoArchival )(int ,error ){_cbcd ,_bdf ,_beab :=_fbfg .buildCertChain (_dbba ,_adc );
if _beab !=nil {return 0,_beab ;};_cgb ,_beab :=_fbfg .getCerts (_cbcd );if _beab !=nil {return 0,_beab ;};var _cefd ,_gag [][]byte ;if _fbfg .OCSPClient !=nil {_cefd ,_beab =_fbfg .getOCSPs (_cbcd ,_bdf );if _beab !=nil {return 0,_beab ;};};if _fbfg .CRLClient !=nil {_gag ,_beab =_fbfg .getCRLs (_cbcd );
if _beab !=nil {return 0,_beab ;};};if !_fbfg ._gcf {_ ,_beab =_fbfg ._bba .AddCerts (_cgb );if _beab !=nil {return 0,_beab ;};_ ,_beab =_fbfg ._bba .AddOCSPs (_cefd );if _beab !=nil {return 0,_beab ;};_ ,_beab =_fbfg ._bba .AddCRLs (_gag );if _beab !=nil {return 0,_beab ;
};};_aee :=0;for _ ,_efb :=range _gag {_aee +=len (_efb );_afe .Crl =append (_afe .Crl ,_a .RawValue {FullBytes :_efb });};for _ ,_bac :=range _cefd {_aee +=len (_bac );_afe .Ocsp =append (_afe .Ocsp ,_a .RawValue {FullBytes :_bac });};return _aee ,nil ;
};

// NewDigest creates a new digest.
func (_gfd *etsiPAdES )NewDigest (_ *_fc .PdfSignature )(_fc .Hasher ,error ){return _dg .NewBuffer (nil ),nil ;};func _bfbb (_aeagb *_be .PublicKey ,_gagf []byte )_eb .Hash {_gfa :=_aeagb .Size ();if _gfa !=len (_gagf ){return 0;};_fdce :=func (_ea *_f .Int ,_gbg *_be .PublicKey ,_ggf *_f .Int )*_f .Int {_gdga :=_f .NewInt (int64 (_gbg .E ));
_ea .Exp (_ggf ,_gdga ,_gbg .N );return _ea ;};_cdb :=new (_f .Int ).SetBytes (_gagf );_adce :=_fdce (new (_f .Int ),_aeagb ,_cdb );_add :=_bcef (_adce .Bytes (),_gfa );if _add [0]!=0||_add [1]!=1{return 0;};_aad :=[]struct{Hash _eb .Hash ;Prefix []byte ;
}{{Hash :_eb .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_eb .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_eb .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_eb .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_eb .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_bggb :=range _aad {_fgd :=_bggb .Hash .Size ();_bcee :=len (_bggb .Prefix )+_fgd ;if _dg .Equal (_add [_gfa -_bcee :_gfa -_fgd ],_bggb .Prefix ){return _bggb .Hash ;};};return 0;};

// Sign sets the Contents fields.
func (_dgfc *adobePKCS7Detached )Sign (sig *_fc .PdfSignature ,digest _fc .Hasher )error {if _dgfc ._ebg {_cagc :=_dgfc ._dac ;if _cagc <=0{_cagc =8192;};sig .Contents =_bgd .MakeHexString (string (make ([]byte ,_cagc )));return nil ;};_bgdf ,_dbac :=digest .(*_dg .Buffer );
if !_dbac {return _da .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_cabf ,_edef :=_c .NewSignedData (_bgdf .Bytes ());if _edef !=nil {return _edef ;};if _bdfa :=_cabf .AddSigner (_dgfc ._ddb ,_dgfc ._eed ,_c .SignerInfoConfig {});
_bdfa !=nil {return _bdfa ;};_cabf .Detach ();_efd ,_edef :=_cabf .Finish ();if _edef !=nil {return _edef ;};_baa :=make ([]byte ,8192);copy (_baa ,_efd );sig .Contents =_bgd .MakeHexString (string (_baa ));return nil ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_fc .SignatureHandler ,error ){return &adobePKCS7Detached {_ebg :true ,_dac :signatureLen },nil ;};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_fa _fc .SignatureHandler ;Permission _dga .DocMDPPermission ;};type timestampInfo struct{Version int ;Policy _a .RawValue ;MessageImprint struct{HashAlgorithm _dae .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _a .RawValue ;
GeneralizedTime _e .Time ;};