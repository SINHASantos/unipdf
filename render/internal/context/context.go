//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package context ;import (_c "errors";_gf "github.com/unidoc/freetype/truetype";_da "github.com/unidoc/unipdf/v3/core";_af "github.com/unidoc/unipdf/v3/internal/cmap";_d "github.com/unidoc/unipdf/v3/internal/textencoding";_ff "github.com/unidoc/unipdf/v3/internal/transform";
_e "github.com/unidoc/unipdf/v3/model";_b "golang.org/x/image/font";_f "image";_a "image/color";_gd "strconv";_ag "strings";);func (_dbb *TextFont )NewFace (size float64 )_b .Face {return _gf .NewFace (_dbb ._ged ,&_gf .Options {Size :size });};func (_ecb *TextState )ProcTD (tx ,ty float64 ){_ecb .Tl =-ty ;
_ecb .ProcTd (tx ,ty )};func (_dae *TextState )ProcQ (data []byte ,ctx Context ){_dae .ProcTStar ();_dae .ProcTj (data ,ctx )};func (_eea *TextState )ProcTf (font *TextFont ){_eea .Tf =font };func (_gaff *TextFont )charcodeToRunesSimple (_bfc _d .CharCode )(_d .CharCode ,[]rune ){_bgb :=[]_d .CharCode {_bfc };
if _gaff .Font .IsSimple ()&&_gaff ._ged !=nil {if _abf :=_gaff ._ged .Index (rune (_bfc ));_abf > 0{return _bfc ,[]rune {rune (_bfc )};};};if _gaff ._ged !=nil &&!_gaff ._ged .HasCmap ()&&_ag .Contains (_gaff .Font .Encoder ().String (),"\u0049d\u0065\u006e\u0074\u0069\u0074\u0079-"){if _aea :=_gaff ._ged .Index (rune (_bfc ));
_aea > 0{return _bfc ,[]rune {rune (_bfc )};};};return _bfc ,_gaff .Font .CharcodesToUnicode (_bgb );};func NewTextFont (font *_e .PdfFont ,size float64 )(*TextFont ,error ){_aec :=font .FontDescriptor ();if _aec ==nil {return nil ,_c .New ("\u0063\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069pt\u006f\u0072");
};_acb ,_bad :=_da .GetStream (_aec .FontFile2 );if !_bad {return nil ,_c .New ("\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020f\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_caf ,_caad :=_da .DecodeStream (_acb );
if _caad !=nil {return nil ,_caad ;};_ceg ,_caad :=_gf .Parse (_caf );if _caad !=nil {return nil ,_caad ;};_bb :=font .FontDescriptor ().FontName .String ();_dbc :=len (_bb )> 7&&_bb [6]=='+';if _aec .Flags !=nil {_geg ,_bgd :=_gd .Atoi (_aec .Flags .String ());
if _bgd ==nil &&_geg ==32{_dbc =false ;};};if !_ceg .HasCmap ()&&(!_ag .Contains (font .Encoder ().String (),"\u0049d\u0065\u006e\u0074\u0069\u0074\u0079-")||!_dbc ){return nil ,_c .New ("\u006e\u006f c\u006d\u0061\u0070 \u0061\u006e\u0064\u0020enc\u006fdi\u006e\u0067\u0020\u0069\u0073\u0020\u006eot\u0020\u0069\u0064\u0065\u006e\u0074\u0069t\u0079");
};return &TextFont {Font :font ,Size :size ,_ged :_ceg },nil ;};func (_geda *TextFont )WithSize (size float64 ,originalFont *_e .PdfFont )*TextFont {return &TextFont {Font :_geda .Font ,Size :size ,_ged :_geda ._ged ,_ffd :originalFont };};type LineCap int ;
func (_cb *TextState )ProcTm (a ,b ,c ,d ,e ,f float64 ){_cb .Tm =_ff .NewMatrix (a ,b ,c ,d ,e ,f );_cb .Tlm =_cb .Tm .Clone ();};func (_dbcf *TextFont )GetCharMetrics (code _d .CharCode )(float64 ,float64 ,bool ){if _abe ,_afe :=_dbcf .Font .GetCharMetrics (code );
_afe &&_abe .Wx !=0{return _abe .Wx ,_abe .Wy ,_afe ;};if _dbcf ._ffd ==nil {return 0,0,false ;};_cab ,_acf :=_dbcf ._ffd .GetCharMetrics (code );return _cab .Wx ,_cab .Wy ,_acf &&_cab .Wx !=0;};func (_gbe *TextState )ProcTStar (){_gbe .ProcTd (0,-_gbe .Tl )};
type Gradient interface{Pattern ;AddColorStop (_ga float64 ,_fc _a .Color );};func (_gb *TextFont )BytesToCharcodes (data []byte )[]_d .CharCode {if _gb ._ffd !=nil {return _gb ._ffd .BytesToCharcodes (data );};return _gb .Font .BytesToCharcodes (data );
};func NewTextFontFromPath (filePath string ,size float64 )(*TextFont ,error ){_bbg ,_feb :=_e .NewPdfFontFromTTFFile (filePath );if _feb !=nil {return nil ,_feb ;};return NewTextFont (_bbg ,size );};const (LineJoinRound LineJoin =iota ;LineJoinBevel ;
);type TextRenderingMode int ;func (_eeb *TextState )Translate (tx ,ty float64 ){_eeb .Tm =_eeb .Tm .Mult (_ff .TranslationMatrix (tx ,ty ));};func (_afg *TextFont )CharcodeToRunes (charcode _d .CharCode )(_d .CharCode ,[]rune ){_gaf :=[]_d .CharCode {charcode };
if _afg ._ffd ==nil ||_afg ._ffd ==_afg .Font {return _afg .charcodeToRunesSimple (charcode );};_cg :=_afg ._ffd .CharcodesToUnicode (_gaf );_afc ,_ :=_afg .Font .RunesToCharcodeBytes (_cg );_bbb :=_afg .Font .BytesToCharcodes (_afc );_gee :=charcode ;
if len (_bbb )> 0&&_bbb [0]!=0{_gee =_bbb [0];};if string (_cg )==string (_af .MissingCodeRune )&&_afg ._ffd .BaseFont ()==_afg .Font .BaseFont (){return _afg .charcodeToRunesSimple (charcode );};return _gee ,_cg ;};func (_fad *TextState )ProcDQ (data []byte ,aw ,ac float64 ,ctx Context ){_fad .Tw =aw ;
_fad .Tc =ac ;_fad .ProcQ (data ,ctx );};type TextState struct{Tc float64 ;Tw float64 ;Th float64 ;Tl float64 ;Tf *TextFont ;Ts float64 ;Tm _ff .Matrix ;Tlm _ff .Matrix ;Tr TextRenderingMode ;GlobalScale float64 ;};type Pattern interface{ColorAt (_ffg ,_cf int )_a .Color ;
};func (_efc *TextState )ProcTj (data []byte ,ctx Context ){_aab :=_efc .Tf .Size ;_daf :=_efc .Th /100.0;_cfgf :=_efc .GlobalScale ;_aebe :=_ff .NewMatrix (_aab *_daf ,0,0,_aab ,0,_efc .Ts );_cbdc :=ctx .Matrix ();_bcb :=_cbdc .Clone ().Mult (_efc .Tm .Clone ().Mult (_aebe )).ScalingFactorY ();
_ffe :=_efc .Tf .NewFace (_bcb );_ffb :=_efc .Tf .BytesToCharcodes (data );for _ ,_ebb :=range _ffb {_fced ,_bbd :=_efc .Tf .CharcodeToRunes (_ebb );_cc :=string (_bbd );if _cc =="\u0000"{continue ;};_caaf :=_cbdc .Clone ().Mult (_efc .Tm .Clone ().Mult (_aebe ));
_ege :=_caaf .ScalingFactorY ();_caaf =_caaf .Scale (1/_ege ,-1/_ege );if _efc .Tr !=TextRenderingModeInvisible {ctx .SetMatrix (_caaf );ctx .DrawString (_cc ,_ffe ,0,0);ctx .SetMatrix (_cbdc );};_cdf :=0.0;if _cc =="\u0020"{_cdf =_efc .Tw ;};_fge ,_ ,_eba :=_efc .Tf .GetCharMetrics (_fced );
if _eba {_fge =_fge *0.001*_aab ;}else {_fge ,_ =ctx .MeasureString (_cc ,_ffe );_fge =_fge /_cfgf ;};_dbf :=(_fge +_efc .Tc +_cdf )*_daf ;_efc .Tm =_efc .Tm .Mult (_ff .TranslationMatrix (_dbf ,0));};};func (_cbd *TextState )ProcTd (tx ,ty float64 ){_cbd .Tlm .Concat (_ff .TranslationMatrix (tx ,ty ));
_cbd .Tm =_cbd .Tlm .Clone ();};type FillRule int ;type Context interface{Push ();Pop ();Matrix ()_ff .Matrix ;SetMatrix (_dg _ff .Matrix );Translate (_gdc ,_gda float64 );Scale (_ef ,_fd float64 );Rotate (_ba float64 );MoveTo (_gfa ,_ed float64 );LineTo (_ac ,_dad float64 );
CubicTo (_eb ,_gfg ,_bg ,_fe ,_cfg ,_gdb float64 );QuadraticTo (_gff ,_daa ,_bab ,_fa float64 );NewSubPath ();ClosePath ();ClearPath ();Clip ();ClipPreserve ();ResetClip ();LineWidth ()float64 ;SetLineWidth (_ec float64 );SetLineCap (_ae LineCap );SetLineJoin (_cd LineJoin );
SetDash (_fcg ...float64 );SetDashOffset (_ace float64 );Fill ();FillPreserve ();Stroke ();StrokePreserve ();SetRGBA (_agc ,_ge ,_db ,_aa float64 );SetFillRGBA (_gdd ,_ca ,_baf ,_de float64 );SetFillStyle (_cdb Pattern );SetFillRule (_be FillRule );SetStrokeRGBA (_gg ,_gaa ,_fg ,_gdg float64 );
SetStrokeStyle (_aeb Pattern );FillPattern ()Pattern ;StrokePattern ()Pattern ;TextState ()*TextState ;DrawString (_cdg string ,_geb _b .Face ,_gc ,_bc float64 );MeasureString (_eg string ,_def _b .Face )(_gge ,_fda float64 );DrawRectangle (_cfe ,_ad ,_cfc ,_bf float64 );
DrawImage (_caa _f .Image ,_ea ,_aef int );DrawImageAnchored (_gcc _f .Image ,_fce ,_dd int ,_ce ,_ab float64 );Height ()int ;Width ()int ;};type TextFont struct{Font *_e .PdfFont ;Size float64 ;_ged *_gf .Font ;_ffd *_e .PdfFont ;};func (_ggee *TextState )Reset (){_ggee .Tm =_ff .IdentityMatrix ();
_ggee .Tlm =_ff .IdentityMatrix ()};const (LineCapRound LineCap =iota ;LineCapButt ;LineCapSquare ;);const (FillRuleWinding FillRule =iota ;FillRuleEvenOdd ;);const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;
TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);type LineJoin int ;func NewTextState ()TextState {return TextState {Th :100,Tm :_ff .IdentityMatrix (),Tlm :_ff .IdentityMatrix ()};
};