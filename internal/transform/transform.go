//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_gc "fmt";_d "github.com/unidoc/unipdf/v3/common";_gg "math";);func (_deb Matrix )Translation ()(float64 ,float64 ){return _deb [6],_deb [7]};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_dbg Matrix )Unrealistic ()bool {_ba ,_da ,_caf ,_dca :=_gg .Abs (_dbg [0]),_gg .Abs (_dbg [1]),_gg .Abs (_dbg [3]),_gg .Abs (_dbg [4]);
_gb :=_ba > _cg &&_dca > _cg ;_dbdf :=_da > _cg &&_caf > _cg ;return !(_gb ||_dbdf );};type Matrix [9]float64 ;func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_c :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_c .clampRange ();return _c ;};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};
func (_bab *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ge :=NewMatrix (a ,b ,c ,d ,tx ,ty );_bab .transformByMatrix (_ge );};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_df Matrix )Scale (xScale ,yScale float64 )Matrix {return _df .Mult (ScaleMatrix (xScale ,yScale ))};
func (_ac Matrix )ScalingFactorX ()float64 {return _gg .Hypot (_ac [0],_ac [1])};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func RotationMatrix (angle float64 )Matrix {_db :=_gg .Cos (angle );_ga :=_gg .Sin (angle );return NewMatrix (_db ,_ga ,-_ga ,_db ,0,0);
};func (_de *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_de [0],_de [1]=a ,b ;_de [3],_de [4]=c ,d ;_de [6],_de [7]=tx ,ty ;_de .clampRange ();};func (_dbd Matrix )String ()string {_a ,_fa ,_af ,_fe ,_afc ,_cb :=_dbd [0],_dbd [1],_dbd [3],_dbd [4],_dbd [6],_dbd [7];
return _gc .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_a ,_fa ,_af ,_fe ,_afc ,_cb );
};func (_faa Matrix )Singular ()bool {return _gg .Abs (_faa [0]*_faa [4]-_faa [1]*_faa [3])< _ab };const _fac =1.0e-6;func (_ff Matrix )ScalingFactorY ()float64 {return _gg .Hypot (_ff [3],_ff [4])};func (_ad *Matrix )clampRange (){for _dfb ,_dfe :=range _ad {if _dfe > _gbb {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dfe ,_gbb );
_ad [_dfb ]=_gbb ;}else if _dfe < -_gbb {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dfe ,-_gbb );_ad [_dfb ]=-_gbb ;};};};const _ab =1e-10;const _gbb =1e9;func (_bac Point )Rotate (theta float64 )Point {_fdg :=_gg .Hypot (_bac .X ,_bac .Y );
_dee :=_gg .Atan2 (_bac .Y ,_bac .X );_ade ,_bc :=_gg .Sincos (_dee +theta /180.0*_gg .Pi );return Point {_fdg *_bc ,_fdg *_ade };};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_cba Point )Distance (b Point )float64 {return _gg .Hypot (_cba .X -b .X ,_cba .Y -b .Y )};func (_ee Matrix )Inverse ()(Matrix ,bool ){_dg ,_gfc :=_ee [0],_ee [1];_fg ,_abg :=_ee [3],_ee [4];_dfc ,_ag :=_ee [6],_ee [7];_dgd :=_dg *_abg -_gfc *_fg ;
if _gg .Abs (_dgd )< _fac {return Matrix {},false ;};_ec ,_fb :=_abg /_dgd ,-_gfc /_dgd ;_cd ,_gde :=-_fg /_dgd ,_dg /_dgd ;_eb :=-(_ec *_dfc +_cd *_ag );_fc :=-(_fb *_dfc +_gde *_ag );return NewMatrix (_ec ,_fb ,_cd ,_gde ,_eb ,_fc ),true ;};func (_ae Matrix )Translate (tx ,ty float64 )Matrix {return _ae .Mult (TranslationMatrix (tx ,ty ))};
func (_gac Matrix )Rotate (theta float64 )Matrix {return _gac .Mult (RotationMatrix (theta ))};func (_dc *Matrix )Concat (b Matrix ){*_dc =Matrix {b [0]*_dc [0]+b [1]*_dc [3],b [0]*_dc [1]+b [1]*_dc [4],0,b [3]*_dc [0]+b [4]*_dc [3],b [3]*_dc [1]+b [4]*_dc [4],0,b [6]*_dc [0]+b [7]*_dc [3]+_dc [6],b [6]*_dc [1]+b [7]*_dc [4]+_dc [7],1};
_dc .clampRange ();};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_gee *Point )transformByMatrix (_gdc Matrix ){_gee .X ,_gee .Y =_gdc .Transform (_gee .X ,_gee .Y )};func (_afe *Matrix )Clone ()Matrix {return NewMatrix (_afe [0],_afe [1],_afe [3],_afe [4],_afe [6],_afe [7]);
};const _cg =1e-6;func (_aee *Point )Set (x ,y float64 ){_aee .X ,_aee .Y =x ,y };func (_gf Matrix )Round (precision float64 )Matrix {for _f :=range _gf {_gf [_f ]=_gg .Round (_gf [_f ]/precision )*precision ;};return _gf ;};func (_gcb Matrix )Transform (x ,y float64 )(float64 ,float64 ){_e :=x *_gcb [0]+y *_gcb [3]+_gcb [6];
_b :=x *_gcb [1]+y *_gcb [4]+_gcb [7];return _e ,_b ;};func (_ca Matrix )Mult (b Matrix )Matrix {_ca .Concat (b );return _ca };func (_ffe Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ffe .X +t *b .X ,Y :(1-t )*_ffe .Y +t *b .Y };
};func (_gd Matrix )Identity ()bool {return _gd [0]==1&&_gd [1]==0&&_gd [2]==0&&_gd [3]==0&&_gd [4]==1&&_gd [5]==0&&_gd [6]==0&&_gd [7]==0&&_gd [8]==1;};func (_abd Point )Displace (delta Point )Point {return Point {_abd .X +delta .X ,_abd .Y +delta .Y }};
func (_fd *Matrix )Shear (x ,y float64 ){_fd .Concat (ShearMatrix (x ,y ))};func (_abc Matrix )Angle ()float64 {_acf :=_gg .Atan2 (-_abc [1],_abc [0]);if _acf < 0.0{_acf +=2*_gg .Pi ;};return _acf /_gg .Pi *180.0;};type Point struct{X float64 ;Y float64 ;
};func (_dff Point )String ()string {return _gc .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_dff .X ,_dff .Y );};