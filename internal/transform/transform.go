//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_g "fmt";_bc "github.com/unidoc/unipdf/v4/common";_d "math";);func (_db *Matrix )Shear (x ,y float64 ){_db .Concat (ShearMatrix (x ,y ))};func (_dd *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_dc :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_dd .transformByMatrix (_dc );};const _cgf =1e-10;func (_ge Matrix )String ()string {_gb ,_e ,_df ,_eg ,_ae ,_cgg :=_ge [0],_ge [1],_ge [3],_ge [4],_ge [6],_ge [7];return _g .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_gb ,_e ,_df ,_eg ,_ae ,_cgg );
};type Point struct{X float64 ;Y float64 ;};func (_gbc Matrix )Mult (b Matrix )Matrix {_gbc .Concat (b );return _gbc };func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_ed *Matrix )clampRange (){for _ce ,_gg :=range _ed {if _gg > _gba {_bc .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gg ,_gba );
_ed [_ce ]=_gba ;}else if _gg < -_gba {_bc .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gg ,-_gba );_ed [_ce ]=-_gba ;};};};func (_gf Matrix )Scale (xScale ,yScale float64 )Matrix {return _gf .Mult (ScaleMatrix (xScale ,yScale ))};
func (_a Matrix )Identity ()bool {return _a [0]==1&&_a [1]==0&&_a [2]==0&&_a [3]==0&&_a [4]==1&&_a [5]==0&&_a [6]==0&&_a [7]==0&&_a [8]==1;};func (_ga Matrix )Translate (tx ,ty float64 )Matrix {return _ga .Mult (TranslationMatrix (tx ,ty ))};func (_bf *Matrix )Concat (b Matrix ){*_bf =Matrix {b [0]*_bf [0]+b [1]*_bf [3],b [0]*_bf [1]+b [1]*_bf [4],0,b [3]*_bf [0]+b [4]*_bf [3],b [3]*_bf [1]+b [4]*_bf [4],0,b [6]*_bf [0]+b [7]*_bf [3]+_bf [6],b [6]*_bf [1]+b [7]*_bf [4]+_bf [7],1};
_bf .clampRange ();};func (_gaf Matrix )Angle ()float64 {_cc :=_d .Atan2 (-_gaf [1],_gaf [0]);if _cc < 0.0{_cc +=2*_d .Pi ;};return _cc /_d .Pi *180.0;};const _gba =1e9;func (_bg *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_bg [0],_bg [1]=a ,b ;_bg [3],_bg [4]=c ,d ;
_bg [6],_bg [7]=tx ,ty ;_bg .clampRange ();};type Matrix [9]float64 ;func (_ecg Matrix )ScalingFactorY ()float64 {return _d .Hypot (_ecg [3],_ecg [4])};func (_gag Matrix )Inverse ()(Matrix ,bool ){_ea ,_f :=_gag [0],_gag [1];_da ,_ecb :=_gag [3],_gag [4];
_aa ,_gfc :=_gag [6],_gag [7];_bcg :=_ea *_ecb -_f *_da ;if _d .Abs (_bcg )< _gdf {return Matrix {},false ;};_gea ,_fb :=_ecb /_bcg ,-_f /_bcg ;_dbe ,_cd :=-_da /_bcg ,_ea /_bcg ;_bfe :=-(_gea *_aa +_dbe *_gfc );_bac :=-(_fb *_aa +_cd *_gfc );return NewMatrix (_gea ,_fb ,_dbe ,_cd ,_bfe ,_bac ),true ;
};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_geab *Point )transformByMatrix (_fc Matrix ){_geab .X ,_geab .Y =_fc .Transform (_geab .X ,_geab .Y )};
func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ca Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ca .X +t *b .X ,Y :(1-t )*_ca .Y +t *b .Y };};func (_cf *Matrix )Clone ()Matrix {return NewMatrix (_cf [0],_cf [1],_cf [3],_cf [4],_cf [6],_cf [7])};
func (_c Matrix )Round (precision float64 )Matrix {for _be :=range _c {_c [_be ]=_d .Round (_c [_be ]/precision )*precision ;};return _c ;};func (_ege Point )Displace (delta Point )Point {return Point {_ege .X +delta .X ,_ege .Y +delta .Y }};func (_ba Matrix )Singular ()bool {return _d .Abs (_ba [0]*_ba [4]-_ba [1]*_ba [3])< _cgf };
const _gdf =1.0e-6;const _ebd =1e-6;func (_aea Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_aea .X ,_aea .Y );};func (_dbeg Matrix )Unrealistic ()bool {_bb ,_de ,_eb ,_deb :=_d .Abs (_dbeg [0]),_d .Abs (_dbeg [1]),_d .Abs (_dbeg [3]),_d .Abs (_dbeg [4]);
_bed :=_bb > _ebd &&_deb > _ebd ;_gdd :=_de > _ebd &&_eb > _ebd ;return !(_bed ||_gdd );};func RotationMatrix (angle float64 )Matrix {_gd :=_d .Cos (angle );_beb :=_d .Sin (angle );return NewMatrix (_gd ,_beb ,-_beb ,_gd ,0,0);};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_cg :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_cg .clampRange ();return _cg ;};func (_cgc Matrix )Rotate (theta float64 )Matrix {return _cgc .Mult (RotationMatrix (theta ))};func (_gec Point )Distance (b Point )float64 {return _d .Hypot (_gec .X -b .X ,_gec .Y -b .Y )};
func (_bfd Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bd :=x *_bfd [0]+y *_bfd [3]+_bfd [6];_bcf :=x *_bfd [1]+y *_bfd [4]+_bfd [7];return _bd ,_bcf ;};func (_aef Matrix )Translation ()(float64 ,float64 ){return _aef [6],_aef [7]};func (_ad Point )Rotate (theta float64 )Point {_ede :=_d .Hypot (_ad .X ,_ad .Y );
_dba :=_d .Atan2 (_ad .Y ,_ad .X );_egb ,_ecgc :=_d .Sincos (_dba +theta /180.0*_d .Pi );return Point {_ede *_ecgc ,_ede *_egb };};func (_ec Matrix )ScalingFactorX ()float64 {return _d .Hypot (_ec [0],_ec [1])};func (_dbg *Point )Set (x ,y float64 ){_dbg .X ,_dbg .Y =x ,y };
