//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_e "fmt";_da "github.com/unidoc/unipdf/v3/common";_g "math";);func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ecd Point )Displace (delta Point )Point {return Point {_ecd .X +delta .X ,_ecd .Y +delta .Y }};
func (_edb *Point )Set (x ,y float64 ){_edb .X ,_edb .Y =x ,y };func (_dgg *Matrix )clampRange (){for _ag ,_ab :=range _dgg {if _ab > _fed {_da .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ab ,_fed );
_dgg [_ag ]=_fed ;}else if _ab < -_fed {_da .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ab ,-_fed );_dgg [_ag ]=-_fed ;};};};type Point struct{X float64 ;Y float64 ;};func (_gbg Point )Distance (b Point )float64 {return _g .Hypot (_gbg .X -b .X ,_gbg .Y -b .Y )};
func (_ebf Point )Rotate (theta float64 )Point {_cg :=_g .Hypot (_ebf .X ,_ebf .Y );_aa :=_g .Atan2 (_ebf .Y ,_ebf .X );_de ,_ebfg :=_g .Sincos (_aa +theta /180.0*_g .Pi );return Point {_cg *_ebfg ,_cg *_de };};func (_baa *Matrix )Shear (x ,y float64 ){_baa .Concat (ShearMatrix (x ,y ))};
func (_bg Matrix )Inverse ()(Matrix ,bool ){_befd ,_ef :=_bg [0],_bg [1];_gf ,_ccd :=_bg [3],_bg [4];_cea ,_fdc :=_bg [6],_bg [7];_ad :=_befd *_ccd -_ef *_gf ;if _g .Abs (_ad )< _gaf {return Matrix {},false ;};_ed ,_eb :=_ccd /_ad ,-_ef /_ad ;_bbe ,_fc :=-_gf /_ad ,_befd /_ad ;
_bd :=-(_ed *_cea +_bbe *_fdc );_beb :=-(_eb *_cea +_fc *_fdc );return NewMatrix (_ed ,_eb ,_bbe ,_fc ,_bd ,_beb ),true ;};func (_fg Matrix )Singular ()bool {return _g .Abs (_fg [0]*_fg [4]-_fg [1]*_fg [3])< _dfc };func (_gdg *Point )transformByMatrix (_ffg Matrix ){_gdg .X ,_gdg .Y =_ffg .Transform (_gdg .X ,_gdg .Y )};
func (_cbg Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_cbg .X +t *b .X ,Y :(1-t )*_cbg .Y +t *b .Y };};func (_cee Matrix )Mult (b Matrix )Matrix {_cee .Concat (b );return _cee };func (_df Matrix )Round (precision float64 )Matrix {for _c :=range _df {_df [_c ]=_g .Round (_df [_c ]/precision )*precision ;
};return _df ;};func (_ca Matrix )ScalingFactorY ()float64 {return _g .Hypot (_ca [3],_ca [4])};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};const _dfc =1e-10;func (_gb Matrix )ScalingFactorX ()float64 {return _g .Hypot (_gb [0],_gb [1])};
func (_ba *Matrix )Concat (b Matrix ){*_ba =Matrix {b [0]*_ba [0]+b [1]*_ba [3],b [0]*_ba [1]+b [1]*_ba [4],0,b [3]*_ba [0]+b [4]*_ba [3],b [3]*_ba [1]+b [4]*_ba [4],0,b [6]*_ba [0]+b [7]*_ba [3]+_ba [6],b [6]*_ba [1]+b [7]*_ba [4]+_ba [7],1};_ba .clampRange ();
};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_ac Point )String ()string {return _e .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ac .X ,_ac .Y );};func (_ff Matrix )Rotate (theta float64 )Matrix {return _ff .Mult (RotationMatrix (theta ))};
func (_ga Matrix )String ()string {_f ,_dg ,_dgf ,_cc ,_ce ,_gd :=_ga [0],_ga [1],_ga [3],_ga [4],_ga [6],_ga [7];return _e .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_f ,_dg ,_dgf ,_cc ,_ce ,_gd );
};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};type Matrix [9]float64 ;func (_feg *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_baf :=NewMatrix (a ,b ,c ,d ,tx ,ty );_feg .transformByMatrix (_baf );};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};
const _fed =1e9;func (_a Matrix )Scale (xScale ,yScale float64 )Matrix {return _a .Mult (ScaleMatrix (xScale ,yScale ))};func (_fe *Matrix )Clone ()Matrix {return NewMatrix (_fe [0],_fe [1],_fe [3],_fe [4],_fe [6],_fe [7])};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_dc Matrix )Identity ()bool {return _dc [0]==1&&_dc [1]==0&&_dc [2]==0&&_dc [3]==0&&_dc [4]==1&&_dc [5]==0&&_dc [6]==0&&_dc [7]==0&&_dc [8]==1;};func (_dab Matrix )Translation ()(float64 ,float64 ){return _dab [6],_dab [7]};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_be :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_be .clampRange ();return _be ;};func RotationMatrix (angle float64 )Matrix {_b :=_g .Cos (angle );_dca :=_g .Sin (angle );return NewMatrix (_b ,_dca ,-_dca ,_b ,0,0);};func (_ec Matrix )Unrealistic ()bool {_dgfe ,_dd ,_bgf ,_bgff :=_g .Abs (_ec [0]),_g .Abs (_ec [1]),_g .Abs (_ec [3]),_g .Abs (_ec [4]);
_abd :=_dgfe > _ffe &&_bgff > _ffe ;_afg :=_dd > _ffe &&_bgf > _ffe ;return !(_abd ||_afg );};func (_ae *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ae [0],_ae [1]=a ,b ;_ae [3],_ae [4]=c ,d ;_ae [6],_ae [7]=tx ,ty ;_ae .clampRange ();};func (_fd Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bb :=x *_fd [0]+y *_fd [3]+_fd [6];
_af :=x *_fd [1]+y *_fd [4]+_fd [7];return _bb ,_af ;};func (_cb Matrix )Angle ()float64 {_ea :=_g .Atan2 (-_cb [1],_cb [0]);if _ea < 0.0{_ea +=2*_g .Pi ;};return _ea /_g .Pi *180.0;};const _gaf =1.0e-6;const _ffe =1e-6;func (_bef Matrix )Translate (tx ,ty float64 )Matrix {return _bef .Mult (TranslationMatrix (tx ,ty ))};
