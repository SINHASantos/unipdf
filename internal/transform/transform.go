//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_c "fmt";_d "github.com/unidoc/unipdf/v3/common";_a "math";);const _eba =1e-10;func (_bd *Matrix )Concat (b Matrix ){*_bd =Matrix {b [0]*_bd [0]+b [1]*_bd [3],b [0]*_bd [1]+b [1]*_bd [4],0,b [3]*_bd [0]+b [4]*_bd [3],b [3]*_bd [1]+b [4]*_bd [4],0,b [6]*_bd [0]+b [7]*_bd [3]+_bd [6],b [6]*_bd [1]+b [7]*_bd [4]+_bd [7],1};
_bd .clampRange ();};func (_dee Matrix )Rotate (theta float64 )Matrix {return _dee .Mult (RotationMatrix (theta ))};func (_adcg *Point )transformByMatrix (_gcgb Matrix ){_adcg .X ,_adcg .Y =_gcgb .Transform (_adcg .X ,_adcg .Y );};const _ee =1e9;func (_fea Point )Distance (b Point )float64 {return _a .Hypot (_fea .X -b .X ,_fea .Y -b .Y )};
func (_cdd Matrix )ScalingFactorY ()float64 {return _a .Hypot (_cdd [3],_cdd [4])};type Matrix [9]float64 ;func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_fgd Matrix )Translation ()(float64 ,float64 ){return _fgd [6],_fgd [7]};func (_fdg Point )Displace (delta Point )Point {return Point {_fdg .X +delta .X ,_fdg .Y +delta .Y }};func (_gc Matrix )Mult (b Matrix )Matrix {_gc .Concat (b );return _gc };
func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ga Matrix )ScalingFactorX ()float64 {return _a .Hypot (_ga [0],_ga [1])};func (_add Matrix )Angle ()float64 {_gcg :=_a .Atan2 (-_add [1],_add [0]);if _gcg < 0.0{_gcg +=2*_a .Pi ;
};return _gcg /_a .Pi *180.0;};func (_e Matrix )Round (precision float64 )Matrix {for _b :=range _e {_e [_b ]=_a .Round (_e [_b ]/precision )*precision ;};return _e ;};func (_de Matrix )Identity ()bool {return _de [0]==1&&_de [1]==0&&_de [2]==0&&_de [3]==0&&_de [4]==1&&_de [5]==0&&_de [6]==0&&_de [7]==0&&_de [8]==1;
};func (_fg Matrix )String ()string {_cc ,_bf ,_eb ,_ad ,_bb ,_ef :=_fg [0],_fg [1],_fg [3],_fg [4],_fg [6],_fg [7];return _c .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_cc ,_bf ,_eb ,_ad ,_bb ,_ef );
};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_bbf *Point )Set (x ,y float64 ){_bbf .X ,_bbf .Y =x ,y };func (_ccc Matrix )Singular ()bool {return _a .Abs (_ccc [0]*_ccc [4]-_ccc [1]*_ccc [3])< _eba };func (_agd *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ed :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_agd .transformByMatrix (_ed );};func RotationMatrix (angle float64 )Matrix {_fd :=_a .Cos (angle );_dd :=_a .Sin (angle );return NewMatrix (_fd ,_dd ,-_dd ,_fd ,0,0);};func (_feb Point )Rotate (theta float64 )Point {_db :=_a .Hypot (_feb .X ,_feb .Y );
_ce :=_a .Atan2 (_feb .Y ,_feb .X );_ba ,_da :=_a .Sincos (_ce +theta /180.0*_a .Pi );return Point {_db *_da ,_db *_ba };};func (_adc *Matrix )clampRange (){for _abf ,_bcg :=range _adc {if _bcg > _ee {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_bcg ,_ee );
_adc [_abf ]=_ee ;}else if _bcg < -_ee {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_bcg ,-_ee );_adc [_abf ]=-_ee ;};};};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};const _bed =1e-6;
type Point struct{X float64 ;Y float64 ;};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};const _ag =1.0e-6;func (_g *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_g [0],_g [1]=a ,b ;_g [3],_g [4]=c ,d ;_g [6],_g [7]=tx ,ty ;_g .clampRange ();
};func (_fe *Matrix )Clone ()Matrix {return NewMatrix (_fe [0],_fe [1],_fe [3],_fe [4],_fe [6],_fe [7])};func (_dg Matrix )Translate (tx ,ty float64 )Matrix {return _dg .Mult (TranslationMatrix (tx ,ty ))};func (_fge Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ea :=x *_fge [0]+y *_fge [3]+_fge [6];
_cd :=x *_fge [1]+y *_fge [4]+_fge [7];return _ea ,_cd ;};func (_bc Matrix )Inverse ()(Matrix ,bool ){_gd ,_gab :=_bc [0],_bc [1];_gda ,_bg :=_bc [3],_bc [4];_be ,_gf :=_bc [6],_bc [7];_cb :=_gd *_bg -_gab *_gda ;if _a .Abs (_cb )< _ag {return Matrix {},false ;
};_ab ,_gag :=_bg /_cb ,-_gab /_cb ;_gdac ,_dge :=-_gda /_cb ,_gd /_cb ;_fde :=-(_ab *_be +_gdac *_gf );_bgg :=-(_gag *_be +_dge *_gf );return NewMatrix (_ab ,_gag ,_gdac ,_dge ,_fde ,_bgg ),true ;};func (_cg Point )String ()string {return _c .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_cg .X ,_cg .Y );
};func (_ebd Matrix )Scale (xScale ,yScale float64 )Matrix {return _ebd .Mult (ScaleMatrix (xScale ,yScale ));};func (_eg *Matrix )Shear (x ,y float64 ){_eg .Concat (ShearMatrix (x ,y ))};func (_bee Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_bee .X +t *b .X ,Y :(1-t )*_bee .Y +t *b .Y };
};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_cf :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_cf .clampRange ();return _cf ;};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_ebdf Matrix )Unrealistic ()bool {_cbd ,_fb ,_gaf ,_bcf :=_a .Abs (_ebdf [0]),_a .Abs (_ebdf [1]),_a .Abs (_ebdf [3]),_a .Abs (_ebdf [4]);
_gcc :=_cbd > _bed &&_bcf > _bed ;_aa :=_fb > _bed &&_gaf > _bed ;return !(_gcc ||_aa );};