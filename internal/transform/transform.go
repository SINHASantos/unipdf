//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_g "fmt";_c "github.com/unidoc/unipdf/v3/common";_f "math";);func (_ebg Matrix )Singular ()bool {return _f .Abs (_ebg [0]*_ebg [4]-_ebg [1]*_ebg [3])< _ef };type Matrix [9]float64 ;func (_ec *Point )transformByMatrix (_cdd Matrix ){_ec .X ,_ec .Y =_cdd .Transform (_ec .X ,_ec .Y )};
func (_cc Matrix )Identity ()bool {return _cc [0]==1&&_cc [1]==0&&_cc [2]==0&&_cc [3]==0&&_cc [4]==1&&_cc [5]==0&&_cc [6]==0&&_cc [7]==0&&_cc [8]==1;};func (_cf Matrix )Angle ()float64 {_bb :=_f .Atan2 (-_cf [1],_cf [0]);if _bb < 0.0{_bb +=2*_f .Pi ;};
return _bb /_f .Pi *180.0;};func (_dc Matrix )Translate (tx ,ty float64 )Matrix {return _dc .Mult (TranslationMatrix (tx ,ty ))};func RotationMatrix (angle float64 )Matrix {_e :=_f .Cos (angle );_dg :=_f .Sin (angle );return NewMatrix (_e ,_dg ,-_dg ,_e ,0,0);
};func (_b Matrix )Round (precision float64 )Matrix {for _gc :=range _b {_b [_gc ]=_f .Round (_b [_gc ]/precision )*precision ;};return _b ;};func (_gcf Point )Distance (b Point )float64 {return _f .Hypot (_gcf .X -b .X ,_gcf .Y -b .Y )};func (_de *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_de [0],_de [1]=a ,b ;
_de [3],_de [4]=c ,d ;_de [6],_de [7]=tx ,ty ;_de .clampRange ();};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_be Matrix )Translation ()(float64 ,float64 ){return _be [6],_be [7]};type Point struct{X float64 ;Y float64 ;};const _db =1.0e-6;
func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_eb *Matrix )Shear (x ,y float64 ){_eb .Concat (ShearMatrix (x ,y ))};func (_fbg Matrix )ScalingFactorX ()float64 {return _f .Hypot (_fbg [0],_fbg [1])};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_agc Point )Rotate (theta float64 )Point {_aga :=_f .Hypot (_agc .X ,_agc .Y );_fda :=_f .Atan2 (_agc .Y ,_agc .X );_cfd ,_ffe :=_f .Sincos (_fda +theta /180.0*_f .Pi );return Point {_aga *_ffe ,_aga *_cfd };
};func (_dcg Matrix )Unrealistic ()bool {_bbg ,_deg ,_fbge ,_cbb :=_f .Abs (_dcg [0]),_f .Abs (_dcg [1]),_f .Abs (_dcg [3]),_f .Abs (_dcg [4]);_bff :=_bbg > _cbf &&_cbb > _cbf ;_gce :=_deg > _cbf &&_fbge > _cbf ;return !(_bff ||_gce );};func (_daa Matrix )Scale (xScale ,yScale float64 )Matrix {return _daa .Mult (ScaleMatrix (xScale ,yScale ));
};func (_bgg Matrix )Rotate (theta float64 )Matrix {return _bgg .Mult (RotationMatrix (theta ))};func (_gge *Point )Set (x ,y float64 ){_gge .X ,_gge .Y =x ,y };func (_bae Point )Displace (delta Point )Point {return Point {_bae .X +delta .X ,_bae .Y +delta .Y }};
func (_gf Matrix )Mult (b Matrix )Matrix {_gf .Concat (b );return _gf };func (_fbd *Matrix )clampRange (){for _bdb ,_ba :=range _fbd {if _ba > _ge {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ba ,_ge );
_fbd [_bdb ]=_ge ;}else if _ba < -_ge {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ba ,-_ge );_fbd [_bdb ]=-_ge ;};};};func (_ed Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bgb :=x *_ed [0]+y *_ed [3]+_ed [6];
_fb :=x *_ed [1]+y *_ed [4]+_ed [7];return _bgb ,_fb ;};func (_cg *Matrix )Concat (b Matrix ){*_cg =Matrix {b [0]*_cg [0]+b [1]*_cg [3],b [0]*_cg [1]+b [1]*_cg [4],0,b [3]*_cg [0]+b [4]*_cg [3],b [3]*_cg [1]+b [4]*_cg [4],0,b [6]*_cg [0]+b [7]*_cg [3]+_cg [6],b [6]*_cg [1]+b [7]*_cg [4]+_cg [7],1};
_cg .clampRange ();};const _ge =1e9;func (_ag *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_dd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_ag .transformByMatrix (_dd );};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_bag Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_bag .X +t *b .X ,Y :(1-t )*_bag .Y +t *b .Y };
};func (_fd *Matrix )Clone ()Matrix {return NewMatrix (_fd [0],_fd [1],_fd [3],_fd [4],_fd [6],_fd [7])};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_a :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_a .clampRange ();return _a ;};const _ef =1e-10;func (_fde Matrix )Inverse ()(Matrix ,bool ){_cb ,_fc :=_fde [0],_fde [1];
_eg ,_ce :=_fde [3],_fde [4];_ccd ,_gb :=_fde [6],_fde [7];_fe :=_cb *_ce -_fc *_eg ;if _f .Abs (_fe )< _db {return Matrix {},false ;};_adb ,_fdee :=_ce /_fe ,-_fc /_fe ;_cd ,_ac :=-_eg /_fe ,_cb /_fe ;_ff :=-(_adb *_ccd +_cd *_gb );_gg :=-(_fdee *_ccd +_ac *_gb );
return NewMatrix (_adb ,_fdee ,_cd ,_ac ,_ff ,_gg ),true ;};func (_ad Matrix )String ()string {_ga ,_da ,_ea ,_aa ,_bg ,_bd :=_ad [0],_ad [1],_ad [3],_ad [4],_ad [6],_ad [7];return _g .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ga ,_da ,_ea ,_aa ,_bg ,_bd );
};const _cbf =1e-6;func (_bf Matrix )ScalingFactorY ()float64 {return _f .Hypot (_bf [3],_bf [4])};func (_fcg Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_fcg .X ,_fcg .Y );};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
