//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_g "fmt";_b "github.com/unidoc/unipdf/v3/common";_fe "math";);func (_fef Matrix )Angle ()float64 {_d :=_fe .Atan2 (-_fef [1],_fef [0]);if _d < 0.0{_d +=2*_fe .Pi ;};return _d /_fe .Pi *180.0;};func (_cc Matrix )Mult (b Matrix )Matrix {_cc .Concat (b );
return _cc };func (_ba Matrix )Rotate (theta float64 )Matrix {return _ba .Mult (RotationMatrix (theta ))};func (_ff Matrix )ScalingFactorX ()float64 {return _fe .Hypot (_ff [0],_ff [1])};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_e Matrix )Round (precision float64 )Matrix {for _c :=range _e {_e [_c ]=_fe .Round (_e [_c ]/precision )*precision ;
};return _e ;};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};type Point struct{X float64 ;Y float64 ;};func (_af Matrix )Singular ()bool {return _fe .Abs (_af [0]*_af [4]-_af [1]*_af [3])< _aa };
func (_gg Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_gg .X ,_gg .Y );};func (_ab *Matrix )Clone ()Matrix {return NewMatrix (_ab [0],_ab [1],_ab [3],_ab [4],_ab [6],_ab [7])};func (_eb Matrix )Translation ()(float64 ,float64 ){return _eb [6],_eb [7]};
func (_ed Matrix )Translate (tx ,ty float64 )Matrix {return _ed .Mult (TranslationMatrix (tx ,ty ))};func (_ag *Matrix )clampRange (){for _fea ,_fde :=range _ag {if _fde > _bdd {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_fde ,_bdd );
_ag [_fea ]=_bdd ;}else if _fde < -_bdd {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_fde ,-_bdd );_ag [_fea ]=-_bdd ;};};};func (_ec *Point )Set (x ,y float64 ){_ec .X ,_ec .Y =x ,y };func (_gd Matrix )Scale (xScale ,yScale float64 )Matrix {return _gd .Mult (ScaleMatrix (xScale ,yScale ))};
func (_aaf Matrix )Unrealistic ()bool {_baf ,_bbc ,_bde ,_ead :=_fe .Abs (_aaf [0]),_fe .Abs (_aaf [1]),_fe .Abs (_aaf [3]),_fe .Abs (_aaf [4]);_df :=_baf > _ede &&_ead > _ede ;_agf :=_bbc > _ede &&_bde > _ede ;return !(_df ||_agf );};func (_fdd *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_dd :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_fdd .transformByMatrix (_dd );};func (_fbc *Matrix )Concat (b Matrix ){*_fbc =Matrix {b [0]*_fbc [0]+b [1]*_fbc [3],b [0]*_fbc [1]+b [1]*_fbc [4],0,b [3]*_fbc [0]+b [4]*_fbc [3],b [3]*_fbc [1]+b [4]*_fbc [4],0,b [6]*_fbc [0]+b [7]*_fbc [3]+_fbc [6],b [6]*_fbc [1]+b [7]*_fbc [4]+_fbc [7],1};
_fbc .clampRange ();};func (_bee Point )Distance (b Point )float64 {return _fe .Hypot (_bee .X -b .X ,_bee .Y -b .Y )};func (_cca Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_cca .X +t *b .X ,Y :(1-t )*_cca .Y +t *b .Y };};const _bdd =1e9;
func (_ca Matrix )Identity ()bool {return _ca [0]==1&&_ca [1]==0&&_ca [2]==0&&_ca [3]==0&&_ca [4]==1&&_ca [5]==0&&_ca [6]==0&&_ca [7]==0&&_ca [8]==1;};func (_eg Matrix )String ()string {_a ,_gb ,_fb ,_fc ,_be ,_cg :=_eg [0],_eg [1],_eg [3],_eg [4],_eg [6],_eg [7];
return _g .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_a ,_gb ,_fb ,_fc ,_be ,_cg );};
func (_cee Point )Rotate (theta float64 )Point {_bdg :=_fe .Hypot (_cee .X ,_cee .Y );_fcf :=_fe .Atan2 (_cee .Y ,_cee .X );_feag ,_eda :=_fe .Sincos (_fcf +theta /180.0*_fe .Pi );return Point {_bdg *_eda ,_bdg *_feag };};func (_ce *Matrix )Shear (x ,y float64 ){_ce .Concat (ShearMatrix (x ,y ))};
func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ef Matrix )Inverse ()(Matrix ,bool ){_bef ,_gde :=_ef [0],_ef [1];_cgg ,_ffg :=_ef [3],_ef [4];_ad ,_dc :=_ef [6],_ef [7];_ea :=_bef *_ffg -_gde *_cgg ;if _fe .Abs (_ea )< _cb {return Matrix {},false ;
};_fg ,_bb :=_ffg /_ea ,-_gde /_ea ;_abd ,_bcd :=-_cgg /_ea ,_bef /_ea ;_bf :=-(_fg *_ad +_abd *_dc );_gc :=-(_bb *_ad +_bcd *_dc );return NewMatrix (_fg ,_bb ,_abd ,_bcd ,_bf ,_gc ),true ;};const _cb =1.0e-6;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};
func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};const _ede =1e-6;func RotationMatrix (angle float64 )Matrix {_fd :=_fe .Cos (angle );_bd :=_fe .Sin (angle );return NewMatrix (_fd ,_bd ,-_bd ,_fd ,0,0);};func (_da *Point )transformByMatrix (_ffgc Matrix ){_da .X ,_da .Y =_ffgc .Transform (_da .X ,_da .Y )};
func (_fbg Point )Displace (delta Point )Point {return Point {_fbg .X +delta .X ,_fbg .Y +delta .Y }};const _aa =1e-10;func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ge :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ge .clampRange ();return _ge ;};func (_caf Matrix )ScalingFactorY ()float64 {return _fe .Hypot (_caf [3],_caf [4])};
func (_bag *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_bag [0],_bag [1]=a ,b ;_bag [3],_bag [4]=c ,d ;_bag [6],_bag [7]=tx ,ty ;_bag .clampRange ();};type Matrix [9]float64 ;func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_bc Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bg :=x *_bc [0]+y *_bc [3]+_bc [6];
_baa :=x *_bc [1]+y *_bc [4]+_bc [7];return _bg ,_baa ;};