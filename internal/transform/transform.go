//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_f "fmt";_ac "github.com/unidoc/unipdf/v3/common";_fa "math";);func (_gc *Matrix )Concat (b Matrix ){*_gc =Matrix {b [0]*_gc [0]+b [1]*_gc [3],b [0]*_gc [1]+b [1]*_gc [4],0,b [3]*_gc [0]+b [4]*_gc [3],b [3]*_gc [1]+b [4]*_gc [4],0,b [6]*_gc [0]+b [7]*_gc [3]+_gc [6],b [6]*_gc [1]+b [7]*_gc [4]+_gc [7],1};
_gc .clampRange ();};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_da Matrix )Mult (b Matrix )Matrix {_da .Concat (b );return _da };func (_eb Matrix )Translation ()(float64 ,float64 ){return _eb [6],_eb [7]};
func (_ba Matrix )ScalingFactorY ()float64 {return _fa .Hypot (_ba [3],_ba [4])};func (_acf *Matrix )clampRange (){for _fef ,_age :=range _acf {if _age > _ad {_ac .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_age ,_ad );
_acf [_fef ]=_ad ;}else if _age < -_ad {_ac .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_age ,-_ad );_acf [_fef ]=-_ad ;};};};func RotationMatrix (angle float64 )Matrix {_d :=_fa .Cos (angle );_b :=_fa .Sin (angle );
return NewMatrix (_d ,_b ,-_b ,_d ,0,0);};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_fd :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_fd .clampRange ();return _fd ;};func (_cga Matrix )Angle ()float64 {_bd :=_fa .Atan2 (-_cga [1],_cga [0]);if _bd < 0.0{_bd +=2*_fa .Pi ;
};return _bd /_fa .Pi *180.0;};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_gae Matrix )Unrealistic ()bool {_ca ,_beb ,_cde ,_ceg :=_fa .Abs (_gae [0]),_fa .Abs (_gae [1]),_fa .Abs (_gae [3]),_fa .Abs (_gae [4]);_abaa :=_ca > _ece &&_ceg > _ece ;
_ef :=_beb > _ece &&_cde > _ece ;return !(_abaa ||_ef );};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_aba *Matrix )Clone ()Matrix {return NewMatrix (_aba [0],_aba [1],_aba [3],_aba [4],_aba [6],_aba [7]);};func (_fdb Matrix )Singular ()bool {return _fa .Abs (_fdb [0]*_fdb [4]-_fdb [1]*_fdb [3])< _bed };
func (_g Matrix )Round (precision float64 )Matrix {for _gg :=range _g {_g [_gg ]=_fa .Round (_g [_gg ]/precision )*precision ;};return _g ;};func (_be Matrix )Rotate (theta float64 )Matrix {return _be .Mult (RotationMatrix (theta ))};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};
func (_eda Point )Distance (b Point )float64 {return _fa .Hypot (_eda .X -b .X ,_eda .Y -b .Y )};func (_fc *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_fc [0],_fc [1]=a ,b ;_fc [3],_fc [4]=c ,d ;_fc [6],_fc [7]=tx ,ty ;_fc .clampRange ();};func (_fgb Point )Displace (delta Point )Point {return Point {_fgb .X +delta .X ,_fgb .Y +delta .Y }};
type Matrix [9]float64 ;func (_dd Point )Rotate (theta float64 )Point {_gcg :=_fa .Hypot (_dd .X ,_dd .Y );_db :=_fa .Atan2 (_dd .Y ,_dd .X );_cce ,_add :=_fa .Sincos (_db +theta /180.0*_fa .Pi );return Point {_gcg *_add ,_gcg *_cce };};const _bed =1e-10;
func (_caa *Point )Set (x ,y float64 ){_caa .X ,_caa .Y =x ,y };func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_ce Matrix )String ()string {_cg ,_e ,_aa ,_fg ,_ab ,_ga :=_ce [0],_ce [1],_ce [3],_ce [4],_ce [6],_ce [7];
return _f .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_cg ,_e ,_aa ,_fg ,_ab ,_ga );};
func (_bc Matrix )Inverse ()(Matrix ,bool ){_fea ,_cd :=_bc [0],_bc [1];_ae ,_cgab :=_bc [3],_bc [4];_ea ,_gd :=_bc [6],_bc [7];_cc :=_fea *_cgab -_cd *_ae ;if _fa .Abs (_cc )< _bdb {return Matrix {},false ;};_bdg ,_ec :=_cgab /_cc ,-_cd /_cc ;_dfe ,_cb :=-_ae /_cc ,_fea /_cc ;
_dg :=-(_bdg *_ea +_dfe *_gd );_fce :=-(_ec *_ea +_cb *_gd );return NewMatrix (_bdg ,_ec ,_dfe ,_cb ,_dg ,_fce ),true ;};func (_fb Matrix )Scale (xScale ,yScale float64 )Matrix {return _fb .Mult (ScaleMatrix (xScale ,yScale ))};func (_bf *Point )transformByMatrix (_efg Matrix ){_bf .X ,_bf .Y =_efg .Transform (_bf .X ,_bf .Y )};
const _bdb =1.0e-6;func (_gac Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gac .X +t *b .X ,Y :(1-t )*_gac .Y +t *b .Y };};type Point struct{X float64 ;Y float64 ;};func (_c Matrix )Identity ()bool {return _c [0]==1&&_c [1]==0&&_c [2]==0&&_c [3]==0&&_c [4]==1&&_c [5]==0&&_c [6]==0&&_c [7]==0&&_c [8]==1;
};func (_fe *Matrix )Shear (x ,y float64 ){_fe .Concat (ShearMatrix (x ,y ))};func (_ed *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fefg :=NewMatrix (a ,b ,c ,d ,tx ,ty );_ed .transformByMatrix (_fefg );};func (_ag Matrix )ScalingFactorX ()float64 {return _fa .Hypot (_ag [0],_ag [1])};
func (_dc Matrix )Translate (tx ,ty float64 )Matrix {return _dc .Mult (TranslationMatrix (tx ,ty ))};const _ad =1e9;func (_faa Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_faa .X ,_faa .Y );
};const _ece =1e-6;func (_acg Matrix )Transform (x ,y float64 )(float64 ,float64 ){_df :=x *_acg [0]+y *_acg [3]+_acg [6];_eg :=x *_acg [1]+y *_acg [4]+_acg [7];return _df ,_eg ;};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};
