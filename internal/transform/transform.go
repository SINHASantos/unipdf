//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_c "fmt";_gb "github.com/unidoc/unipdf/v3/common";_ce "math";);func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_a :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_a .clampRange ();return _a ;};func (_dcd Matrix )Singular ()bool {return _ce .Abs (_dcd [0]*_dcd [4]-_dcd [1]*_dcd [3])< _bcf };
func (_gbd *Matrix )clampRange (){for _ead ,_cce :=range _gbd {if _cce > _ac {_gb .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cce ,_ac );_gbd [_ead ]=_ac ;}else if _cce < -_ac {_gb .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cce ,-_ac );
_gbd [_ead ]=-_ac ;};};};func (_eg Matrix )ScalingFactorX ()float64 {return _ce .Hypot (_eg [0],_eg [1])};func (_fee *Matrix )Clone ()Matrix {return NewMatrix (_fee [0],_fee [1],_fee [3],_fee [4],_fee [6],_fee [7]);};const _bcf =1e-10;func (_cbd Matrix )Translation ()(float64 ,float64 ){return _cbd [6],_cbd [7]};
func (_eae Matrix )Unrealistic ()bool {_fa ,_bg ,_fc ,_gcf :=_ce .Abs (_eae [0]),_ce .Abs (_eae [1]),_ce .Abs (_eae [3]),_ce .Abs (_eae [4]);_bgg :=_fa > _eb &&_gcf > _eb ;_df :=_bg > _eb &&_fc > _eb ;return !(_bgg ||_df );};func (_bag Matrix )Rotate (theta float64 )Matrix {return _bag .Mult (RotationMatrix (theta ))};
func (_f Matrix )Identity ()bool {return _f [0]==1&&_f [1]==0&&_f [2]==0&&_f [3]==0&&_f [4]==1&&_f [5]==0&&_f [6]==0&&_f [7]==0&&_f [8]==1;};func (_af *Matrix )Shear (x ,y float64 ){_af .Concat (ShearMatrix (x ,y ))};func (_dae *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_dae [0],_dae [1]=a ,b ;
_dae [3],_dae [4]=c ,d ;_dae [6],_dae [7]=tx ,ty ;_dae .clampRange ();};func (_eba *Point )Set (x ,y float64 ){_eba .X ,_eba .Y =x ,y };func (_ed Matrix )Angle ()float64 {_ccd :=_ce .Atan2 (-_ed [1],_ed [0]);if _ccd < 0.0{_ccd +=2*_ce .Pi ;};return _ccd /_ce .Pi *180.0;
};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_fe Matrix )Scale (xScale ,yScale float64 )Matrix {return _fe .Mult (ScaleMatrix (xScale ,yScale ))};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};type Matrix [9]float64 ;
func (_eaa *Point )transformByMatrix (_bf Matrix ){_eaa .X ,_eaa .Y =_bf .Transform (_eaa .X ,_eaa .Y )};func (_bc Matrix )Mult (b Matrix )Matrix {_bc .Concat (b );return _bc };func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_agg Point )Rotate (theta float64 )Point {_fac :=_ce .Hypot (_agg .X ,_agg .Y );_eaed :=_ce .Atan2 (_agg .Y ,_agg .X );_gg ,_adf :=_ce .Sincos (_eaed +theta /180.0*_ce .Pi );return Point {_fac *_adf ,_fac *_gg };};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_ad Matrix )Inverse ()(Matrix ,bool ){_ea ,_bd :=_ad [0],_ad [1];_aea ,_egf :=_ad [3],_ad [4];_bdb ,_ag :=_ad [6],_ad [7];_ef :=_ea *_egf -_bd *_aea ;if _ce .Abs (_ef )< _bcb {return Matrix {},false ;
};_efd ,_cbdd :=_egf /_ef ,-_bd /_ef ;_bdg ,_bcd :=-_aea /_ef ,_ea /_ef ;_dbg :=-(_efd *_bdb +_bdg *_ag );_gc :=-(_cbdd *_bdb +_bcd *_ag );return NewMatrix (_efd ,_cbdd ,_bdg ,_bcd ,_dbg ,_gc ),true ;};func (_aga Point )String ()string {return _c .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_aga .X ,_aga .Y );
};func (_e Matrix )Round (precision float64 )Matrix {for _ec :=range _e {_e [_ec ]=_ce .Round (_e [_ec ]/precision )*precision ;};return _e ;};const _eb =1e-6;func RotationMatrix (angle float64 )Matrix {_b :=_ce .Cos (angle );_ba :=_ce .Sin (angle );return NewMatrix (_b ,_ba ,-_ba ,_b ,0,0);
};const _bcb =1.0e-6;func (_bab *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ab :=NewMatrix (a ,b ,c ,d ,tx ,ty );_bab .transformByMatrix (_ab );};func (_de Point )Displace (delta Point )Point {return Point {_de .X +delta .X ,_de .Y +delta .Y }};func (_ge Matrix )ScalingFactorY ()float64 {return _ce .Hypot (_ge [3],_ge [4])};
func (_cd Point )Distance (b Point )float64 {return _ce .Hypot (_cd .X -b .X ,_cd .Y -b .Y )};const _ac =1e9;func (_aee Matrix )Transform (x ,y float64 )(float64 ,float64 ){_daf :=x *_aee [0]+y *_aee [3]+_aee [6];_fd :=x *_aee [1]+y *_aee [4]+_aee [7];
return _daf ,_fd ;};func (_ee Matrix )Translate (tx ,ty float64 )Matrix {return _ee .Mult (TranslationMatrix (tx ,ty ))};func (_ced Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ced .X +t *b .X ,Y :(1-t )*_ced .Y +t *b .Y };};
type Point struct{X float64 ;Y float64 ;};func (_cb Matrix )String ()string {_d ,_ae ,_cc ,_da ,_bac ,_db :=_cb [0],_cb [1],_cb [3],_cb [4],_cb [6],_cb [7];return _c .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_d ,_ae ,_cc ,_da ,_bac ,_db );
};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_dc *Matrix )Concat (b Matrix ){*_dc =Matrix {b [0]*_dc [0]+b [1]*_dc [3],b [0]*_dc [1]+b [1]*_dc [4],0,b [3]*_dc [0]+b [4]*_dc [3],b [3]*_dc [1]+b [4]*_dc [4],0,b [6]*_dc [0]+b [7]*_dc [3]+_dc [6],b [6]*_dc [1]+b [7]*_dc [4]+_dc [7],1};
_dc .clampRange ();};