//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_c "fmt";_fe "github.com/unidoc/unipdf/v4/common";_a "math";);func (_bf Matrix )Scale (xScale ,yScale float64 )Matrix {return _bf .Mult (ScaleMatrix (xScale ,yScale ))};func (_bdef Point )Distance (b Point )float64 {return _a .Hypot (_bdef .X -b .X ,_bdef .Y -b .Y )};
func (_bbe Point )Displace (delta Point )Point {return Point {_bbe .X +delta .X ,_bbe .Y +delta .Y }};func (_gg Matrix )Mult (b Matrix )Matrix {_gg .Concat (b );return _gg };func (_fgd Matrix )Unrealistic ()bool {_af ,_da ,_cae ,_eaa :=_a .Abs (_fgd [0]),_a .Abs (_fgd [1]),_a .Abs (_fgd [3]),_a .Abs (_fgd [4]);
_bbb :=_af > _cea &&_eaa > _cea ;_ee :=_da > _cea &&_cae > _cea ;return !(_bbb ||_ee );};type Point struct{X float64 ;Y float64 ;};func (_dg Matrix )ScalingFactorX ()float64 {return _a .Hypot (_dg [0],_dg [1])};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};const _ef =1e-10;func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ga :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ga .clampRange ();return _ga ;};func (_b Matrix )Identity ()bool {return _b [0]==1&&_b [1]==0&&_b [2]==0&&_b [3]==0&&_b [4]==1&&_b [5]==0&&_b [6]==0&&_b [7]==0&&_b [8]==1;
};func (_cee *Point )transformByMatrix (_ccf Matrix ){_cee .X ,_cee .Y =_ccf .Transform (_cee .X ,_cee .Y )};func (_cfc *Matrix )Shear (x ,y float64 ){_cfc .Concat (ShearMatrix (x ,y ))};func (_db Matrix )Singular ()bool {return _a .Abs (_db [0]*_db [4]-_db [1]*_db [3])< _ef };
func (_ad Matrix )Inverse ()(Matrix ,bool ){_cgc ,_be :=_ad [0],_ad [1];_ab ,_bfa :=_ad [3],_ad [4];_ge ,_fd :=_ad [6],_ad [7];_ce :=_cgc *_bfa -_be *_ab ;if _a .Abs (_ce )< _ffc {return Matrix {},false ;};_bde ,_dce :=_bfa /_ce ,-_be /_ce ;_dd ,_gce :=-_ab /_ce ,_cgc /_ce ;
_fde :=-(_bde *_ge +_dd *_fd );_gea :=-(_dce *_ge +_gce *_fd );return NewMatrix (_bde ,_dce ,_dd ,_gce ,_fde ,_gea ),true ;};func (_fa Matrix )ScalingFactorY ()float64 {return _a .Hypot (_fa [3],_fa [4])};func (_eb *Matrix )Concat (b Matrix ){*_eb =Matrix {b [0]*_eb [0]+b [1]*_eb [3],b [0]*_eb [1]+b [1]*_eb [4],0,b [3]*_eb [0]+b [4]*_eb [3],b [3]*_eb [1]+b [4]*_eb [4],0,b [6]*_eb [0]+b [7]*_eb [3]+_eb [6],b [6]*_eb [1]+b [7]*_eb [4]+_eb [7],1};
_eb .clampRange ();};const _cea =1e-6;func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_cf Matrix )Round (precision float64 )Matrix {for _cg :=range _cf {_cf [_cg ]=_a .Round (_cf [_cg ]/precision )*precision ;};return _cf ;
};func (_ac Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ac .X +t *b .X ,Y :(1-t )*_ac .Y +t *b .Y };};func (_fb Matrix )String ()string {_gf ,_d ,_ff ,_de ,_dc ,_cc :=_fb [0],_fb [1],_fb [3],_fb [4],_fb [6],_fb [7];return _c .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_gf ,_d ,_ff ,_de ,_dc ,_cc );
};const _ffc =1.0e-6;func (_bdg *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ag :=NewMatrix (a ,b ,c ,d ,tx ,ty );_bdg .transformByMatrix (_ag );};func RotationMatrix (angle float64 )Matrix {_cfa :=_a .Cos (angle );_g :=_a .Sin (angle );return NewMatrix (_cfa ,_g ,-_g ,_cfa ,0,0);
};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_dgb Point )Rotate (theta float64 )Point {_dea :=_a .Hypot (_dgb .X ,_dgb .Y );_gfc :=_a .Atan2 (_dgb .Y ,_dgb .X );_eab ,_dda :=_a .Sincos (_gfc +theta /180.0*_a .Pi );return Point {_dea *_dda ,_dea *_eab };
};const _gb =1e9;func (_ggc *Point )Set (x ,y float64 ){_ggc .X ,_ggc .Y =x ,y };func (_cdg *Matrix )clampRange (){for _gd ,_ca :=range _cdg {if _ca > _gb {_fe .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ca ,_gb );
_cdg [_gd ]=_gb ;}else if _ca < -_gb {_fe .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ca ,-_gb );_cdg [_gd ]=-_gb ;};};};func (_dbf Point )String ()string {return _c .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_dbf .X ,_dbf .Y );
};type Matrix [9]float64 ;func (_eg *Matrix )Clone ()Matrix {return NewMatrix (_eg [0],_eg [1],_eg [3],_eg [4],_eg [6],_eg [7])};func (_ea Matrix )Transform (x ,y float64 )(float64 ,float64 ){_cd :=x *_ea [0]+y *_ea [3]+_ea [6];_ec :=x *_ea [1]+y *_ea [4]+_ea [7];
return _cd ,_ec ;};func (_cfb Matrix )Translate (tx ,ty float64 )Matrix {return _cfb .Mult (TranslationMatrix (tx ,ty ))};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func (_fg Matrix )Rotate (theta float64 )Matrix {return _fg .Mult (RotationMatrix (theta ))};func (_gc Matrix )Translation ()(float64 ,float64 ){return _gc [6],_gc [7]};func (_bb Matrix )Angle ()float64 {_bd :=_a .Atan2 (-_bb [1],_bb [0]);if _bd < 0.0{_bd +=2*_a .Pi ;
};return _bd /_a .Pi *180.0;};func (_e *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_e [0],_e [1]=a ,b ;_e [3],_e [4]=c ,d ;_e [6],_e [7]=tx ,ty ;_e .clampRange ();};