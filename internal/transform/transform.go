//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_ad "fmt";_f "github.com/unidoc/unipdf/v3/common";_g "math";);const _dbe =1e-6;func (_bd Matrix )Translate (tx ,ty float64 )Matrix {return _bd .Mult (TranslationMatrix (tx ,ty ))};func (_b Matrix )Identity ()bool {return _b [0]==1&&_b [1]==0&&_b [2]==0&&_b [3]==0&&_b [4]==1&&_b [5]==0&&_b [6]==0&&_b [7]==0&&_b [8]==1;
};func (_aacc *Point )Set (x ,y float64 ){_aacc .X ,_aacc .Y =x ,y };func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_bdg Matrix )Singular ()bool {return _g .Abs (_bdg [0]*_bdg [4]-_bdg [1]*_bdg [3])< _bdb };func (_fa Matrix )String ()string {_bb ,_gd ,_ff ,_ce ,_dg ,_gdg :=_fa [0],_fa [1],_fa [3],_fa [4],_fa [6],_fa [7];
return _ad .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_bb ,_gd ,_ff ,_ce ,_dg ,_gdg );
};func (_ga *Matrix )Shear (x ,y float64 ){_ga .Concat (ShearMatrix (x ,y ))};func (_cf Matrix )ScalingFactorY ()float64 {return _g .Hypot (_cf [3],_cf [4])};func (_ee Matrix )Translation ()(float64 ,float64 ){return _ee [6],_ee [7]};func (_fcd *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_dde :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_fcd .transformByMatrix (_dde );};func (_bf Matrix )Rotate (theta float64 )Matrix {return _bf .Mult (RotationMatrix (theta ))};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};
func (_gaa *Point )transformByMatrix (_ebc Matrix ){_gaa .X ,_gaa .Y =_ebc .Transform (_gaa .X ,_gaa .Y )};func (_gc Point )Displace (delta Point )Point {return Point {_gc .X +delta .X ,_gc .Y +delta .Y }};func RotationMatrix (angle float64 )Matrix {_c :=_g .Cos (angle );
_e :=_g .Sin (angle );return NewMatrix (_c ,_e ,-_e ,_c ,0,0);};func (_fb *Matrix )clampRange (){for _db ,_cec :=range _fb {if _cec > _fee {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cec ,_fee );
_fb [_db ]=_fee ;}else if _cec < -_fee {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cec ,-_fee );_fb [_db ]=-_fee ;};};};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func (_ef *Matrix )Clone ()Matrix {return NewMatrix (_ef [0],_ef [1],_ef [3],_ef [4],_ef [6],_ef [7])};const _bdb =1e-10;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_gbf Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gbf .X +t *b .X ,Y :(1-t )*_gbf .Y +t *b .Y };
};func (_bgb Matrix )ScalingFactorX ()float64 {return _g .Hypot (_bgb [0],_bgb [1])};func (_aa Matrix )Round (precision float64 )Matrix {for _d :=range _aa {_aa [_d ]=_g .Round (_aa [_d ]/precision )*precision ;};return _aa ;};func (_bg *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_bg [0],_bg [1]=a ,b ;
_bg [3],_bg [4]=c ,d ;_bg [6],_bg [7]=tx ,ty ;_bg .clampRange ();};const _fee =1e9;func (_fe Matrix )Scale (xScale ,yScale float64 )Matrix {return _fe .Mult (ScaleMatrix (xScale ,yScale ))};type Point struct{X float64 ;Y float64 ;};func (_eed Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ab :=x *_eed [0]+y *_eed [3]+_eed [6];
_ge :=x *_eed [1]+y *_eed [4]+_eed [7];return _ab ,_ge ;};func (_ae Matrix )Inverse ()(Matrix ,bool ){_ba ,_fc :=_ae [0],_ae [1];_gdf ,_de :=_ae [3],_ae [4];_ec ,_eg :=_ae [6],_ae [7];_abd :=_ba *_de -_fc *_gdf ;if _g .Abs (_abd )< _age {return Matrix {},false ;
};_gb ,_eede :=_de /_abd ,-_fc /_abd ;_aacg ,_egg :=-_gdf /_abd ,_ba /_abd ;_dd :=-(_gb *_ec +_aacg *_eg );_eb :=-(_eede *_ec +_egg *_eg );return NewMatrix (_gb ,_eede ,_aacg ,_egg ,_dd ,_eb ),true ;};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_aac :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_aac .clampRange ();return _aac ;};func (_bgf Point )Distance (b Point )float64 {return _g .Hypot (_bgf .X -b .X ,_bgf .Y -b .Y )};func (_feb Point )Rotate (theta float64 )Point {_geg :=_g .Hypot (_feb .X ,_feb .Y );_ggf :=_g .Atan2 (_feb .Y ,_feb .X );
_bba ,_abc :=_g .Sincos (_ggf +theta /180.0*_g .Pi );return Point {_geg *_abc ,_geg *_bba };};const _age =1.0e-6;func (_dgf Matrix )Mult (b Matrix )Matrix {_dgf .Concat (b );return _dgf };func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_ag Matrix )Unrealistic ()bool {_fff ,_cd ,_cc ,_abb :=_g .Abs (_ag [0]),_g .Abs (_ag [1]),_g .Abs (_ag [3]),_g .Abs (_ag [4]);_fg :=_fff > _dbe &&_abb > _dbe ;_cfb :=_cd > _dbe &&_cc > _dbe ;return !(_fg ||_cfb );};type Matrix [9]float64 ;func (_aee Point )String ()string {return _ad .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_aee .X ,_aee .Y );
};func (_gg *Matrix )Concat (b Matrix ){*_gg =Matrix {b [0]*_gg [0]+b [1]*_gg [3],b [0]*_gg [1]+b [1]*_gg [4],0,b [3]*_gg [0]+b [4]*_gg [3],b [3]*_gg [1]+b [4]*_gg [4],0,b [6]*_gg [0]+b [7]*_gg [3]+_gg [6],b [6]*_gg [1]+b [7]*_gg [4]+_gg [7],1};_gg .clampRange ();
};func (_ed Matrix )Angle ()float64 {_ac :=_g .Atan2 (-_ed [1],_ed [0]);if _ac < 0.0{_ac +=2*_g .Pi ;};return _ac /_g .Pi *180.0;};