//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_a "fmt";_f "github.com/unidoc/unipdf/v3/common";_b "math";);func (_adg Matrix )Angle ()float64 {_cc :=_b .Atan2 (-_adg [1],_adg [0]);if _cc < 0.0{_cc +=2*_b .Pi ;};return _cc /_b .Pi *180.0;};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_fgb *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fa :=NewMatrix (a ,b ,c ,d ,tx ,ty );_fgb .transformByMatrix (_fa );
};func (_e *Matrix )Shear (x ,y float64 ){_e .Concat (ShearMatrix (x ,y ))};func (_bg Matrix )Translation ()(float64 ,float64 ){return _bg [6],_bg [7]};type Point struct{X float64 ;Y float64 ;};func (_c Matrix )Identity ()bool {return _c [0]==1&&_c [1]==0&&_c [2]==0&&_c [3]==0&&_c [4]==1&&_c [5]==0&&_c [6]==0&&_c [7]==0&&_c [8]==1;
};func (_cg Matrix )Inverse ()(Matrix ,bool ){_bfd ,_eed :=_cg [0],_cg [1];_ef ,_ab :=_cg [3],_cg [4];_gb ,_ffc :=_cg [6],_cg [7];_bcb :=_bfd *_ab -_eed *_ef ;if _b .Abs (_bcb )< _df {return Matrix {},false ;};_bb ,_efb :=_ab /_bcb ,-_eed /_bcb ;_af ,_ga :=-_ef /_bcb ,_bfd /_bcb ;
_ae :=-(_bb *_gb +_af *_ffc );_bfa :=-(_efb *_gb +_ga *_ffc );return NewMatrix (_bb ,_efb ,_af ,_ga ,_ae ,_bfa ),true ;};func (_dg Matrix )Scale (xScale ,yScale float64 )Matrix {return _dg .Mult (ScaleMatrix (xScale ,yScale ))};func (_da *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_da [0],_da [1]=a ,b ;
_da [3],_da [4]=c ,d ;_da [6],_da [7]=tx ,ty ;_da .clampRange ();};func (_fgg Point )Rotate (theta float64 )Point {_ccb :=_b .Hypot (_fgg .X ,_fgg .Y );_dc :=_b .Atan2 (_fgg .Y ,_fgg .X );_gf ,_db :=_b .Sincos (_dc +theta /180.0*_b .Pi );return Point {_ccb *_db ,_ccb *_gf };
};func (_gg Matrix )Rotate (theta float64 )Matrix {return _gg .Mult (RotationMatrix (theta ))};func (_bec Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_bec .X +t *b .X ,Y :(1-t )*_bec .Y +t *b .Y };};func (_ff Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bf :=x *_ff [0]+y *_ff [3]+_ff [6];
_cab :=x *_ff [1]+y *_ff [4]+_ff [7];return _bf ,_cab ;};const _bga =1e-6;const _cef =1e-10;func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_cfg *Point )Set (x ,y float64 ){_cfg .X ,_cfg .Y =x ,y };const _df =1.0e-6;
func (_ec Point )String ()string {return _a .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ec .X ,_ec .Y );};func (_cd Matrix )Translate (tx ,ty float64 )Matrix {return _cd .Mult (TranslationMatrix (tx ,ty ))};func (_bfc Matrix )Singular ()bool {return _b .Abs (_bfc [0]*_bfc [4]-_bfc [1]*_bfc [3])< _cef };
func (_bda *Point )transformByMatrix (_ecb Matrix ){_bda .X ,_bda .Y =_ecb .Transform (_bda .X ,_bda .Y )};func (_fdb *Matrix )clampRange (){for _ffd ,_bfb :=range _fdb {if _bfb > _bbb {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_bfb ,_bbb );
_fdb [_ffd ]=_bbb ;}else if _bfb < -_bbb {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_bfb ,-_bbb );_fdb [_ffd ]=-_bbb ;};};};func (_bbf Point )Distance (b Point )float64 {return _b .Hypot (_bbf .X -b .X ,_bbf .Y -b .Y )};
func (_bd Matrix )Mult (b Matrix )Matrix {_bd .Concat (b );return _bd };func (_bce Point )Displace (delta Point )Point {return Point {_bce .X +delta .X ,_bce .Y +delta .Y }};func (_be Matrix )Round (precision float64 )Matrix {for _fd :=range _be {_be [_fd ]=_b .Round (_be [_fd ]/precision )*precision ;
};return _be ;};func (_ad *Matrix )Clone ()Matrix {return NewMatrix (_ad [0],_ad [1],_ad [3],_ad [4],_ad [6],_ad [7])};func (_daf Matrix )Unrealistic ()bool {_ea ,_eb ,_fc ,_fge :=_b .Abs (_daf [0]),_b .Abs (_daf [1]),_b .Abs (_daf [3]),_b .Abs (_daf [4]);
_aba :=_ea > _bga &&_fge > _bga ;_cge :=_eb > _bga &&_fc > _bga ;return !(_aba ||_cge );};func (_ee Matrix )ScalingFactorY ()float64 {return _b .Hypot (_ee [3],_ee [4])};type Matrix [9]float64 ;func (_gd Matrix )ScalingFactorX ()float64 {return _b .Hypot (_gd [0],_gd [1])};
func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_cb Matrix )String ()string {_ca ,_cf ,_beb ,_gc ,_ce ,_cbe :=_cb [0],_cb [1],_cb [3],_cb [4],_cb [6],_cb [7];
return _a .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ca ,_cf ,_beb ,_gc ,_ce ,_cbe );
};func (_fg *Matrix )Concat (b Matrix ){*_fg =Matrix {b [0]*_fg [0]+b [1]*_fg [3],b [0]*_fg [1]+b [1]*_fg [4],0,b [3]*_fg [0]+b [4]*_fg [3],b [3]*_fg [1]+b [4]*_fg [4],0,b [6]*_fg [0]+b [7]*_fg [3]+_fg [6],b [6]*_fg [1]+b [7]*_fg [4]+_fg [7],1};_fg .clampRange ();
};func RotationMatrix (angle float64 )Matrix {_d :=_b .Cos (angle );_aa :=_b .Sin (angle );return NewMatrix (_d ,_aa ,-_aa ,_d ,0,0);};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_bc :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_bc .clampRange ();return _bc ;
};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};const _bbb =1e9;