//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _af "sync";func (_aa *ByteRuneMap )Read (b byte )(rune ,bool ){_aa ._g .RLock ();defer _aa ._g .RUnlock ();_c ,_f :=_aa ._ac [b ];return _c ,_f ;};type RuneByteMap struct{_ff map[rune ]byte ;_ca _af .RWMutex ;};func (_fb *RuneStringMap )Read (r rune )(string ,bool ){_fb ._cfc .RLock ();
defer _fb ._cfc .RUnlock ();_ffce ,_ffe :=_fb ._aeb [r ];return _ffce ,_ffe ;};func (_fc *RuneSet )Length ()int {_fc ._gbg .RLock ();defer _fc ._gbg .RUnlock ();return len (_fc ._cf )};type RuneStringMap struct{_aeb map[rune ]string ;_cfc _af .RWMutex ;
};func (_gag *RuneByteMap )Write (r rune ,b byte ){_gag ._ca .Lock ();defer _gag ._ca .Unlock ();_gag ._ff [r ]=b ;};type StringsMap struct{_fdg map[string ]string ;_ebb _af .RWMutex ;};func (_gad *RuneSet )Range (f func (_bea rune )(_cb bool )){_gad ._gbg .RLock ();
defer _gad ._gbg .RUnlock ();for _aec :=range _gad ._cf {if f (_aec ){break ;};};};func (_gba *RuneByteMap )Length ()int {_gba ._ca .RLock ();defer _gba ._ca .RUnlock ();return len (_gba ._ff );};func (_eba *RuneUint16Map )Write (r rune ,g uint16 ){_eba ._bgd .Lock ();
defer _eba ._bgd .Unlock ();_eba ._fad [r ]=g ;};func MakeRuneByteMap (length int )*RuneByteMap {_acf :=make (map[rune ]byte ,length );return &RuneByteMap {_ff :_acf };};func (_caa *RuneStringMap )Range (f func (_edf rune ,_afe string )(_ffcc bool )){_caa ._cfc .RLock ();
defer _caa ._cfc .RUnlock ();for _ggf ,_bd :=range _caa ._aeb {if f (_ggf ,_bd ){break ;};};};type ByteRuneMap struct{_ac map[byte ]rune ;_g _af .RWMutex ;};func (_dc *RuneUint16Map )Length ()int {_dc ._bgd .RLock ();defer _dc ._bgd .RUnlock ();return len (_dc ._fad );
};func (_aea *RuneUint16Map )Range (f func (_abd rune ,_gga uint16 )(_da bool )){_aea ._bgd .RLock ();defer _aea ._bgd .RUnlock ();for _ag ,_fce :=range _aea ._fad {if f (_ag ,_fce ){break ;};};};func (_fg *StringRuneMap )Range (f func (_dcc string ,_fea rune )(_ffa bool )){_fg ._fddg .RLock ();
defer _fg ._fddg .RUnlock ();for _dccb ,_dd :=range _fg ._dgc {if f (_dccb ,_dd ){break ;};};};func (_ga *RuneByteMap )Read (r rune )(byte ,bool ){_ga ._ca .RLock ();defer _ga ._ca .RUnlock ();_dgb ,_eb :=_ga ._ff [r ];return _dgb ,_eb ;};func (_b *ByteRuneMap )Length ()int {_b ._g .RLock ();
defer _b ._g .RUnlock ();return len (_b ._ac )};type StringRuneMap struct{_dgc map[string ]rune ;_fddg _af .RWMutex ;};func (_beaf *StringRuneMap )Write (g string ,r rune ){_beaf ._fddg .Lock ();defer _beaf ._fddg .Unlock ();_beaf ._dgc [g ]=r ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_fad :make (map[rune ]uint16 ,length )};
};func (_dgd *StringRuneMap )Length ()int {_dgd ._fddg .RLock ();defer _dgd ._fddg .RUnlock ();return len (_dgd ._dgc );};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_cf :make (map[rune ]struct{},length )}};func (_e *ByteRuneMap )Range (f func (_d byte ,_df rune )(_ed bool )){_e ._g .RLock ();
defer _e ._g .RUnlock ();for _fa ,_dg :=range _e ._ac {if f (_fa ,_dg ){break ;};};};func (_dfg *RuneByteMap )Range (f func (_ae rune ,_ab byte )(_be bool )){_dfg ._ca .RLock ();defer _dfg ._ca .RUnlock ();for _gb ,_db :=range _dfg ._ff {if f (_gb ,_db ){break ;
};};};type RuneSet struct{_cf map[rune ]struct{};_gbg _af .RWMutex ;};func (_de *StringRuneMap )Read (g string )(rune ,bool ){_de ._fddg .RLock ();defer _de ._fddg .RUnlock ();_ee ,_ce :=_de ._dgc [g ];return _ee ,_ce ;};func (_gg *ByteRuneMap )Write (b byte ,r rune ){_gg ._g .Lock ();
defer _gg ._g .Unlock ();_gg ._ac [b ]=r };func (_bac *StringsMap )Write (g1 ,g2 string ){_bac ._ebb .Lock ();defer _bac ._ebb .Unlock ();_bac ._fdg [g1 ]=g2 ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_aeb :m }};
func (_fe *RuneSet )Exists (r rune )bool {_fe ._gbg .RLock ();defer _fe ._gbg .RUnlock ();_ ,_dba :=_fe ._cf [r ];return _dba ;};func (_bg *RuneSet )Write (r rune ){_bg ._gbg .Lock ();defer _bg ._gbg .Unlock ();_bg ._cf [r ]=struct{}{}};func (_aed *RuneUint16Map )Delete (r rune ){_aed ._bgd .Lock ();
defer _aed ._bgd .Unlock ();delete (_aed ._fad ,r );};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_ac :m }};func (_eec *StringsMap )Read (g string )(string ,bool ){_eec ._ebb .RLock ();defer _eec ._ebb .RUnlock ();_egc ,_ba :=_eec ._fdg [g ];
return _egc ,_ba ;};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_ac :make (map[byte ]rune ,length )}};func (_dbd *RuneStringMap )Length ()int {_dbd ._cfc .RLock ();defer _dbd ._cfc .RUnlock ();return len (_dbd ._aeb );};func (_fd *RuneUint16Map )Read (r rune )(uint16 ,bool ){_fd ._bgd .RLock ();
defer _fd ._bgd .RUnlock ();_fdd ,_cba :=_fd ._fad [r ];return _fdd ,_cba ;};func (_efe *StringsMap )Range (f func (_gf ,_fba string )(_cbd bool )){_efe ._ebb .RLock ();defer _efe ._ebb .RUnlock ();for _ffg ,_gaf :=range _efe ._fdg {if f (_ffg ,_gaf ){break ;
};};};func NewStringsMap (tuples []StringsTuple )*StringsMap {_gbga :=map[string ]string {};for _ ,_eg :=range tuples {_gbga [_eg .Key ]=_eg .Value ;};return &StringsMap {_fdg :_gbga };};func (_cc *RuneStringMap )Write (r rune ,s string ){_cc ._cfc .Lock ();
defer _cc ._cfc .Unlock ();_cc ._aeb [r ]=s ;};func (_dbg *RuneUint16Map )RangeDelete (f func (_ef rune ,_bb uint16 )(_fff bool ,_aee bool )){_dbg ._bgd .Lock ();defer _dbg ._bgd .Unlock ();for _aef ,_acd :=range _dbg ._fad {_fdf ,_agb :=f (_aef ,_acd );
if _fdf {delete (_dbg ._fad ,_aef );};if _agb {break ;};};};type StringsTuple struct{Key ,Value string ;};func (_gfc *StringsMap )Copy ()*StringsMap {_gfc ._ebb .RLock ();defer _gfc ._ebb .RUnlock ();_fcef :=map[string ]string {};for _dca ,_cfg :=range _gfc ._fdg {_fcef [_dca ]=_cfg ;
};return &StringsMap {_fdg :_fcef };};type RuneUint16Map struct{_fad map[rune ]uint16 ;_bgd _af .RWMutex ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_dgc :m }};