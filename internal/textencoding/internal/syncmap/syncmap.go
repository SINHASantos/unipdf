//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _c "sync";func (_eg *StringsMap )Write (g1 ,g2 string ){_eg ._cagf .Lock ();defer _eg ._cagf .Unlock ();_eg ._cag [g1 ]=g2 ;};func (_fd *RuneSet )Exists (r rune )bool {_fd ._gc .RLock ();defer _fd ._gc .RUnlock ();_ ,_gfb :=_fd ._gbb [r ];
return _gfb ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_gbb :make (map[rune ]struct{},length )}};func (_gb *ByteRuneMap )Read (b byte )(rune ,bool ){_gb ._a .RLock ();defer _gb ._a .RUnlock ();_f ,_cf :=_gb ._b [b ];return _f ,_cf ;};func (_ba *RuneByteMap )Read (r rune )(byte ,bool ){_ba ._dgb .RLock ();
defer _ba ._dgb .RUnlock ();_ff ,_ac :=_ba ._ae [r ];return _ff ,_ac ;};func (_gd *RuneStringMap )Range (f func (_ed rune ,_aac string )(_cea bool )){_gd ._cc .RLock ();defer _gd ._cc .RUnlock ();for _ffg ,_fcd :=range _gd ._gg {if f (_ffg ,_fcd ){break ;
};};};func (_cd *RuneUint16Map )Read (r rune )(uint16 ,bool ){_cd ._aee .RLock ();defer _cd ._aee .RUnlock ();_ggb ,_bb :=_cd ._ef [r ];return _ggb ,_bb ;};type RuneByteMap struct{_ae map[rune ]byte ;_dgb _c .RWMutex ;};func (_baa *RuneByteMap )Write (r rune ,b byte ){_baa ._dgb .Lock ();
defer _baa ._dgb .Unlock ();_baa ._ae [r ]=b ;};func (_cae *RuneSet )Write (r rune ){_cae ._gc .Lock ();defer _cae ._gc .Unlock ();_cae ._gbb [r ]=struct{}{};};func (_dde *RuneUint16Map )Delete (r rune ){_dde ._aee .Lock ();defer _dde ._aee .Unlock ();
delete (_dde ._ef ,r );};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_fce :m }};func MakeRuneByteMap (length int )*RuneByteMap {_dd :=make (map[rune ]byte ,length );return &RuneByteMap {_ae :_dd };};func (_bac *StringRuneMap )Read (g string )(rune ,bool ){_bac ._bad .RLock ();
defer _bac ._bad .RUnlock ();_gge ,_eda :=_bac ._fce [g ];return _gge ,_eda ;};func (_cg *RuneStringMap )Write (r rune ,s string ){_cg ._cc .Lock ();defer _cg ._cc .Unlock ();_cg ._gg [r ]=s ;};type ByteRuneMap struct{_b map[byte ]rune ;_a _c .RWMutex ;
};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_b :make (map[byte ]rune ,length )}};type RuneStringMap struct{_gg map[rune ]string ;_cc _c .RWMutex ;};func (_ca *ByteRuneMap )Write (b byte ,r rune ){_ca ._a .Lock ();defer _ca ._a .Unlock ();
_ca ._b [b ]=r };func (_efa *StringRuneMap )Write (g string ,r rune ){_efa ._bad .Lock ();defer _efa ._bad .Unlock ();_efa ._fce [g ]=r ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_de :=map[string ]string {};for _ ,_agf :=range tuples {_de [_agf .Key ]=_agf .Value ;
};return &StringsMap {_cag :_de };};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ef :make (map[rune ]uint16 ,length )};};func (_dcg *StringsMap )Read (g string )(string ,bool ){_dcg ._cagf .RLock ();defer _dcg ._cagf .RUnlock ();
_cbc ,_bcf :=_dcg ._cag [g ];return _cbc ,_bcf ;};func (_fde *RuneStringMap )Read (r rune )(string ,bool ){_fde ._cc .RLock ();defer _fde ._cc .RUnlock ();_gbf ,_ga :=_fde ._gg [r ];return _gbf ,_ga ;};func (_gba *StringsMap )Range (f func (_cgg ,_cgc string )(_aaeg bool )){_gba ._cagf .RLock ();
defer _gba ._cagf .RUnlock ();for _cec ,_bcb :=range _gba ._cag {if f (_cec ,_bcb ){break ;};};};func (_ccf *StringsMap )Copy ()*StringsMap {_ccf ._cagf .RLock ();defer _ccf ._cagf .RUnlock ();_caef :=map[string ]string {};for _dbd ,_eaf :=range _ccf ._cag {_caef [_dbd ]=_eaf ;
};return &StringsMap {_cag :_caef };};func (_cef *RuneUint16Map )RangeDelete (f func (_ddd rune ,_gca uint16 )(_ge bool ,_bcc bool )){_cef ._aee .Lock ();defer _cef ._aee .Unlock ();for _gbbb ,_da :=range _cef ._ef {_dc ,_fb :=f (_gbbb ,_da );if _dc {delete (_cef ._ef ,_gbbb );
};if _fb {break ;};};};func (_cbb *RuneSet )Length ()int {_cbb ._gc .RLock ();defer _cbb ._gc .RUnlock ();return len (_cbb ._gbb )};func (_bgf *RuneByteMap )Length ()int {_bgf ._dgb .RLock ();defer _bgf ._dgb .RUnlock ();return len (_bgf ._ae );};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_gg :m }};
type RuneUint16Map struct{_ef map[rune ]uint16 ;_aee _c .RWMutex ;};type StringRuneMap struct{_fce map[string ]rune ;_bad _c .RWMutex ;};func (_df *StringRuneMap )Range (f func (_cdd string ,_baf rune )(_cgd bool )){_df ._bad .RLock ();defer _df ._bad .RUnlock ();
for _ad ,_fbd :=range _df ._fce {if f (_ad ,_fbd ){break ;};};};func (_db *RuneStringMap )Length ()int {_db ._cc .RLock ();defer _db ._cc .RUnlock ();return len (_db ._gg )};type StringsMap struct{_cag map[string ]string ;_cagf _c .RWMutex ;};func (_ea *RuneUint16Map )Write (r rune ,g uint16 ){_ea ._aee .Lock ();
defer _ea ._aee .Unlock ();_ea ._ef [r ]=g ;};func (_gdd *RuneUint16Map )Range (f func (_aae rune ,_fe uint16 )(_abg bool )){_gdd ._aee .RLock ();defer _gdd ._aee .RUnlock ();for _ag ,_bbb :=range _gdd ._ef {if f (_ag ,_bbb ){break ;};};};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_b :m }};
func (_be *RuneByteMap )Range (f func (_ab rune ,_aa byte )(_cb bool )){_be ._dgb .RLock ();defer _be ._dgb .RUnlock ();for _beg ,_cad :=range _be ._ae {if f (_beg ,_cad ){break ;};};};type RuneSet struct{_gbb map[rune ]struct{};_gc _c .RWMutex ;};func (_dg *ByteRuneMap )Length ()int {_dg ._a .RLock ();
defer _dg ._a .RUnlock ();return len (_dg ._b )};type StringsTuple struct{Key ,Value string ;};func (_gf *ByteRuneMap )Range (f func (_bd byte ,_d rune )(_fc bool )){_gf ._a .RLock ();defer _gf ._a .RUnlock ();for _bg ,_bc :=range _gf ._b {if f (_bg ,_bc ){break ;
};};};func (_bf *RuneSet )Range (f func (_fff rune )(_bce bool )){_bf ._gc .RLock ();defer _bf ._gc .RUnlock ();for _ce :=range _bf ._gbb {if f (_ce ){break ;};};};func (_cce *StringRuneMap )Length ()int {_cce ._bad .RLock ();defer _cce ._bad .RUnlock ();
return len (_cce ._fce );};func (_cbe *RuneUint16Map )Length ()int {_cbe ._aee .RLock ();defer _cbe ._aee .RUnlock ();return len (_cbe ._ef );};