//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _e "sync";func (_dg *StringRuneMap )Write (g string ,r rune ){_dg ._ga .Lock ();defer _dg ._ga .Unlock ();_dg ._cec [g ]=r ;};func (_ab *RuneSet )Write (r rune ){_ab ._df .Lock ();defer _ab ._df .Unlock ();_ab ._cf [r ]=struct{}{}};
type StringRuneMap struct{_cec map[string ]rune ;_ga _e .RWMutex ;};func (_cebg *StringsMap )Read (g string )(string ,bool ){_cebg ._deg .RLock ();defer _cebg ._deg .RUnlock ();_fca ,_agb :=_cebg ._cce [g ];return _fca ,_agb ;};func (_bg *RuneStringMap )Read (r rune )(string ,bool ){_bg ._de .RLock ();
defer _bg ._de .RUnlock ();_ccd ,_ad :=_bg ._ae [r ];return _ccd ,_ad ;};type ByteRuneMap struct{_f map[byte ]rune ;_g _e .RWMutex ;};type StringsTuple struct{Key ,Value string ;};func (_gfg *RuneUint16Map )Length ()int {_gfg ._fag .RLock ();defer _gfg ._fag .RUnlock ();
return len (_gfg ._aa );};func (_adg *RuneStringMap )Write (r rune ,s string ){_adg ._de .Lock ();defer _adg ._de .Unlock ();_adg ._ae [r ]=s ;};type StringsMap struct{_cce map[string ]string ;_deg _e .RWMutex ;};func (_eb *ByteRuneMap )Write (b byte ,r rune ){_eb ._g .Lock ();
defer _eb ._g .Unlock ();_eb ._f [b ]=r };type RuneStringMap struct{_ae map[rune ]string ;_de _e .RWMutex ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_cec :m }};func (_fg *ByteRuneMap )Length ()int {_fg ._g .RLock ();
defer _fg ._g .RUnlock ();return len (_fg ._f )};func (_fc *RuneByteMap )Read (r rune )(byte ,bool ){_fc ._af .RLock ();defer _fc ._af .RUnlock ();_gd ,_fd :=_fc ._gg [r ];return _gd ,_fd ;};type RuneByteMap struct{_gg map[rune ]byte ;_af _e .RWMutex ;
};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_aa :make (map[rune ]uint16 ,length )};};func (_ede *RuneUint16Map )Write (r rune ,g uint16 ){_ede ._fag .Lock ();defer _ede ._fag .Unlock ();_ede ._aa [r ]=g ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_bed :=map[string ]string {};
for _ ,_dgf :=range tuples {_bed [_dgf .Key ]=_dgf .Value ;};return &StringsMap {_cce :_bed };};func (_dda *RuneStringMap )Range (f func (_cgc rune ,_cdc string )(_ce bool )){_dda ._de .RLock ();defer _dda ._de .RUnlock ();for _fcd ,_cgd :=range _dda ._ae {if f (_fcd ,_cgd ){break ;
};};};func (_bfd *RuneStringMap )Length ()int {_bfd ._de .RLock ();defer _bfd ._de .RUnlock ();return len (_bfd ._ae );};func (_bdg *RuneUint16Map )RangeDelete (f func (_add rune ,_fab uint16 )(_dbe bool ,_ceb bool )){_bdg ._fag .Lock ();defer _bdg ._fag .Unlock ();
for _ag ,_dec :=range _bdg ._aa {_dc ,_dcd :=f (_ag ,_dec );if _dc {delete (_bdg ._aa ,_ag );};if _dcd {break ;};};};func (_fda *RuneByteMap )Write (r rune ,b byte ){_fda ._af .Lock ();defer _fda ._af .Unlock ();_fda ._gg [r ]=b ;};func (_ebab *StringRuneMap )Range (f func (_geb string ,_edc rune )(_ddeg bool )){_ebab ._ga .RLock ();
defer _ebab ._ga .RUnlock ();for _ffb ,_ffe :=range _ebab ._cec {if f (_ffb ,_ffe ){break ;};};};func (_ge *RuneUint16Map )Delete (r rune ){_ge ._fag .Lock ();defer _ge ._fag .Unlock ();delete (_ge ._aa ,r );};func (_gf *RuneSet )Length ()int {_gf ._df .RLock ();
defer _gf ._df .RUnlock ();return len (_gf ._cf )};func (_gab *StringsMap )Write (g1 ,g2 string ){_gab ._deg .Lock ();defer _gab ._deg .Unlock ();_gab ._cce [g1 ]=g2 ;};type RuneSet struct{_cf map[rune ]struct{};_df _e .RWMutex ;};func (_ffbe *StringRuneMap )Length ()int {_ffbe ._ga .RLock ();
defer _ffbe ._ga .RUnlock ();return len (_ffbe ._cec );};func (_be *RuneSet )Range (f func (_efa rune )(_db bool )){_be ._df .RLock ();defer _be ._df .RUnlock ();for _fge :=range _be ._cf {if f (_fge ){break ;};};};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_cf :make (map[rune ]struct{},length )}};
func (_cc *RuneByteMap )Length ()int {_cc ._af .RLock ();defer _cc ._af .RUnlock ();return len (_cc ._gg )};func (_fe *ByteRuneMap )Read (b byte )(rune ,bool ){_fe ._g .RLock ();defer _fe ._g .RUnlock ();_bb ,_ba :=_fe ._f [b ];return _bb ,_ba ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ae :m }};
func (_cbb *StringRuneMap )Read (g string )(rune ,bool ){_cbb ._ga .RLock ();defer _cbb ._ga .RUnlock ();_ac ,_eba :=_cbb ._cec [g ];return _ac ,_eba ;};func (_c *ByteRuneMap )Range (f func (_d byte ,_cb rune )(_a bool )){_c ._g .RLock ();defer _c ._g .RUnlock ();
for _bf ,_cd :=range _c ._f {if f (_bf ,_cd ){break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_f :make (map[byte ]rune ,length )}};func (_bac *RuneSet )Exists (r rune )bool {_bac ._df .RLock ();defer _bac ._df .RUnlock ();
_ ,_dde :=_bac ._cf [r ];return _dde ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_f :m }};type RuneUint16Map struct{_aa map[rune ]uint16 ;_fag _e .RWMutex ;};func MakeRuneByteMap (length int )*RuneByteMap {_cg :=make (map[rune ]byte ,length );
return &RuneByteMap {_gg :_cg };};func (_gdd *StringsMap )Range (f func (_ea ,_gec string )(_ddg bool )){_gdd ._deg .RLock ();defer _gdd ._deg .RUnlock ();for _fagd ,_ebd :=range _gdd ._cce {if f (_fagd ,_ebd ){break ;};};};func (_abe *RuneUint16Map )Range (f func (_ff rune ,_gb uint16 )(_cea bool )){_abe ._fag .RLock ();
defer _abe ._fag .RUnlock ();for _bfda ,_bae :=range _abe ._aa {if f (_bfda ,_bae ){break ;};};};func (_ade *StringsMap )Copy ()*StringsMap {_ade ._deg .RLock ();defer _ade ._deg .RUnlock ();_fb :=map[string ]string {};for _dcdb ,_bc :=range _ade ._cce {_fb [_dcdb ]=_bc ;
};return &StringsMap {_cce :_fb };};func (_ed *RuneByteMap )Range (f func (_dd rune ,_fa byte )(_ef bool )){_ed ._af .RLock ();defer _ed ._af .RUnlock ();for _fgg ,_bd :=range _ed ._gg {if f (_fgg ,_bd ){break ;};};};func (_gde *RuneUint16Map )Read (r rune )(uint16 ,bool ){_gde ._fag .RLock ();
defer _gde ._fag .RUnlock ();_fee ,_fdc :=_gde ._aa [r ];return _fee ,_fdc ;};