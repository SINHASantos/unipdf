//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _b "sync";func (_ffa *RuneUint16Map )Write (r rune ,g uint16 ){_ffa ._aed .Lock ();defer _ffa ._aed .Unlock ();_ffa ._cgf [r ]=g ;};func (_fcb *StringsMap )Read (g string )(string ,bool ){_fcb ._dfa .RLock ();defer _fcb ._dfa .RUnlock ();
_ea ,_ag :=_fcb ._edg [g ];return _ea ,_ag ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_gfa :m }};func (_bf *ByteRuneMap )Length ()int {_bf ._f .RLock ();defer _bf ._f .RUnlock ();return len (_bf ._bd )};func (_ef *RuneStringMap )Read (r rune )(string ,bool ){_ef ._aa .RLock ();
defer _ef ._aa .RUnlock ();_bc ,_gff :=_ef ._bfa [r ];return _bc ,_gff ;};func (_bfg *RuneStringMap )Length ()int {_bfg ._aa .RLock ();defer _bfg ._aa .RUnlock ();return len (_bfg ._bfa );};func (_fda *RuneByteMap )Length ()int {_fda ._db .RLock ();defer _fda ._db .RUnlock ();
return len (_fda ._gf );};type StringRuneMap struct{_gfa map[string ]rune ;_bfab _b .RWMutex ;};func (_ae *RuneByteMap )Range (f func (_e rune ,_ceb byte )(_bb bool )){_ae ._db .RLock ();defer _ae ._db .RUnlock ();for _bbf ,_ff :=range _ae ._gf {if f (_bbf ,_ff ){break ;
};};};func (_bag *RuneUint16Map )Length ()int {_bag ._aed .RLock ();defer _bag ._aed .RUnlock ();return len (_bag ._cgf );};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_bfa :m }};func (_df *ByteRuneMap )Range (f func (_dg byte ,_fd rune )(_gc bool )){_df ._f .RLock ();
defer _df ._f .RUnlock ();for _cg ,_fe :=range _df ._bd {if f (_cg ,_fe ){break ;};};};func (_fdd *RuneSet )Length ()int {_fdd ._ace .RLock ();defer _fdd ._ace .RUnlock ();return len (_fdd ._ac )};type RuneSet struct{_ac map[rune ]struct{};_ace _b .RWMutex ;
};func (_faf *StringsMap )Copy ()*StringsMap {_faf ._dfa .RLock ();defer _faf ._dfa .RUnlock ();_fcd :=map[string ]string {};for _bgd ,_bca :=range _faf ._edg {_fcd [_bgd ]=_bca ;};return &StringsMap {_edg :_fcd };};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ac :make (map[rune ]struct{},length )}};
func (_cebc *RuneUint16Map )Read (r rune )(uint16 ,bool ){_cebc ._aed .RLock ();defer _cebc ._aed .RUnlock ();_bcc ,_dge :=_cebc ._cgf [r ];return _bcc ,_dge ;};func (_fba *RuneUint16Map )Delete (r rune ){_fba ._aed .Lock ();defer _fba ._aed .Unlock ();
delete (_fba ._cgf ,r );};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_bd :m }};func (_ba *ByteRuneMap )Read (b byte )(rune ,bool ){_ba ._f .RLock ();defer _ba ._f .RUnlock ();_c ,_g :=_ba ._bd [b ];return _c ,_g ;};type StringsTuple struct{Key ,Value string ;
};func (_gag *StringRuneMap )Write (g string ,r rune ){_gag ._bfab .Lock ();defer _gag ._bfab .Unlock ();_gag ._gfa [g ]=r ;};func (_bbd *StringsMap )Range (f func (_bfb ,_cgb string )(_bdg bool )){_bbd ._dfa .RLock ();defer _bbd ._dfa .RUnlock ();for _ece ,_bg :=range _bbd ._edg {if f (_ece ,_bg ){break ;
};};};func (_da *RuneUint16Map )RangeDelete (f func (_ee rune ,_egc uint16 )(_dgd bool ,_gfc bool )){_da ._aed .Lock ();defer _da ._aed .Unlock ();for _fge ,_ed :=range _da ._cgf {_acc ,_gb :=f (_fge ,_ed );if _acc {delete (_da ._cgf ,_fge );};if _gb {break ;
};};};func (_cgc *RuneSet )Write (r rune ){_cgc ._ace .Lock ();defer _cgc ._ace .Unlock ();_cgc ._ac [r ]=struct{}{};};func (_dd *RuneStringMap )Range (f func (_cdc rune ,_fad string )(_gfe bool )){_dd ._aa .RLock ();defer _dd ._aa .RUnlock ();for _af ,_fdc :=range _dd ._bfa {if f (_af ,_fdc ){break ;
};};};func (_gaf *RuneSet )Range (f func (_cef rune )(_ec bool )){_gaf ._ace .RLock ();defer _gaf ._ace .RUnlock ();for _gcf :=range _gaf ._ac {if f (_gcf ){break ;};};};func (_cb *StringRuneMap )Length ()int {_cb ._bfab .RLock ();defer _cb ._bfab .RUnlock ();
return len (_cb ._gfa );};func (_cdd *StringRuneMap )Read (g string )(rune ,bool ){_cdd ._bfab .RLock ();defer _cdd ._bfab .RUnlock ();_gca ,_gbe :=_cdd ._gfa [g ];return _gca ,_gbe ;};type RuneStringMap struct{_bfa map[rune ]string ;_aa _b .RWMutex ;};
func (_cd *RuneSet )Exists (r rune )bool {_cd ._ace .RLock ();defer _cd ._ace .RUnlock ();_ ,_de :=_cd ._ac [r ];return _de ;};type RuneUint16Map struct{_cgf map[rune ]uint16 ;_aed _b .RWMutex ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_cgf :make (map[rune ]uint16 ,length )};
};func NewStringsMap (tuples []StringsTuple )*StringsMap {_abb :=map[string ]string {};for _ ,_gbef :=range tuples {_abb [_gbef .Key ]=_gbef .Value ;};return &StringsMap {_edg :_abb };};type RuneByteMap struct{_gf map[rune ]byte ;_db _b .RWMutex ;};type ByteRuneMap struct{_bd map[byte ]rune ;
_f _b .RWMutex ;};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_bd :make (map[byte ]rune ,length )}};func (_fa *RuneByteMap )Read (r rune )(byte ,bool ){_fa ._db .RLock ();defer _fa ._db .RUnlock ();_be ,_ga :=_fa ._gf [r ];return _be ,_ga ;
};type StringsMap struct{_edg map[string ]string ;_dfa _b .RWMutex ;};func (_ecg *RuneStringMap )Write (r rune ,s string ){_ecg ._aa .Lock ();defer _ecg ._aa .Unlock ();_ecg ._bfa [r ]=s ;};func (_ce *ByteRuneMap )Write (b byte ,r rune ){_ce ._f .Lock ();
defer _ce ._f .Unlock ();_ce ._bd [b ]=r };func (_aab *RuneUint16Map )Range (f func (_fdb rune ,_eg uint16 )(_fb bool )){_aab ._aed .RLock ();defer _aab ._aed .RUnlock ();for _gg ,_ab :=range _aab ._cgf {if f (_gg ,_ab ){break ;};};};func (_a *RuneByteMap )Write (r rune ,b byte ){_a ._db .Lock ();
defer _a ._db .Unlock ();_a ._gf [r ]=b };func (_ad *StringRuneMap )Range (f func (_bcf string ,_bbc rune )(_gbf bool )){_ad ._bfab .RLock ();defer _ad ._bfab .RUnlock ();for _cc ,_ecc :=range _ad ._gfa {if f (_cc ,_ecc ){break ;};};};func MakeRuneByteMap (length int )*RuneByteMap {_fg :=make (map[rune ]byte ,length );
return &RuneByteMap {_gf :_fg };};func (_bbcd *StringsMap )Write (g1 ,g2 string ){_bbcd ._dfa .Lock ();defer _bbcd ._dfa .Unlock ();_bbcd ._edg [g1 ]=g2 ;};