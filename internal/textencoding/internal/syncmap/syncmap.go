//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _d "sync";func (_feb *StringRuneMap )Read (g string )(rune ,bool ){_feb ._dde .RLock ();defer _feb ._dde .RUnlock ();_agf ,_cae :=_feb ._cag [g ];return _agf ,_cae ;};func (_ef *RuneRuneMap )Range (f func (_gg rune ,_cg rune )(_df bool )){_ef ._db .RLock ();
defer _ef ._db .RUnlock ();for _ge ,_cf :=range _ef ._dd {if f (_ge ,_cf ){break ;};};};func (_de *RuneRuneMap )Length ()int {_de ._db .RLock ();defer _de ._db .RUnlock ();return len (_de ._dd )};func (_fcb *StringRuneMap )Length ()int {_fcb ._dde .RLock ();
defer _fcb ._dde .RUnlock ();return len (_fcb ._cag );};func (_ad *RuneStringMap )Length ()int {_ad ._fad .RLock ();defer _ad ._fad .RUnlock ();return len (_ad ._fb );};func (_ac *RuneByteMap )Write (r rune ,b byte ){_ac ._gd .Lock ();defer _ac ._gd .Unlock ();
_ac ._bf [r ]=b };func MakeRuneSet (length int )*RuneSet {return &RuneSet {_fge :make (map[rune ]struct{},length )}};type StringsMap struct{_dcb map[string ]string ;_gbg _d .RWMutex ;};func (_ee *RuneRuneMap )Read (g rune )(rune ,bool ){_ee ._db .RLock ();
defer _ee ._db .RUnlock ();_fg ,_eeb :=_ee ._dd [g ];return _fg ,_eeb ;};func (_ede *RuneUint16Map )Length ()int {_ede ._ceg .RLock ();defer _ede ._ceg .RUnlock ();return len (_ede ._gbb );};func (_fd *ByteRuneMap )Write (b byte ,r rune ){_fd ._g .Lock ();
defer _fd ._g .Unlock ();_fd ._b [b ]=r };func (_a *ByteRuneMap )Range (f func (_gb byte ,_ed rune )(_ag bool )){_a ._g .RLock ();defer _a ._g .RUnlock ();for _ga ,_ce :=range _a ._b {if f (_ga ,_ce ){break ;};};};type StringRuneMap struct{_cag map[string ]rune ;
_dde _d .RWMutex ;};func (_fcg *StringsMap )Write (g1 ,g2 string ){_fcg ._gbg .Lock ();defer _fcg ._gbg .Unlock ();_fcg ._dcb [g1 ]=g2 ;};func (_cce *RuneStringMap )Range (f func (_ddb rune ,_be string )(_dgf bool )){_cce ._fad .RLock ();defer _cce ._fad .RUnlock ();
for _ec ,_gc :=range _cce ._fb {if f (_ec ,_gc ){break ;};};};func (_abg *StringRuneMap )Range (f func (_daa string ,_fccd rune )(_aae bool )){_abg ._dde .RLock ();defer _abg ._dde .RUnlock ();for _gbba ,_egb :=range _abg ._cag {if f (_gbba ,_egb ){break ;
};};};type RuneRuneMap struct{_dd map[rune ]rune ;_db _d .RWMutex ;};func (_fa *RuneByteMap )Range (f func (_acg rune ,_gf byte )(_fc bool )){_fa ._gd .RLock ();defer _fa ._gd .RUnlock ();for _cc ,_ceb :=range _fa ._bf {if f (_cc ,_ceb ){break ;};};};func (_af *RuneSet )Write (r rune ){_af ._cd .Lock ();
defer _af ._cd .Unlock ();_af ._fge [r ]=struct{}{}};func (_aa *RuneByteMap )Read (r rune )(byte ,bool ){_aa ._gd .RLock ();defer _aa ._gd .RUnlock ();_gdd ,_ff :=_aa ._bf [r ];return _gdd ,_ff ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_cag :m }};
func (_agb *RuneSet )Length ()int {_agb ._cd .RLock ();defer _agb ._cd .RUnlock ();return len (_agb ._fge )};func (_bg *RuneSet )Range (f func (_ddf rune )(_edb bool )){_bg ._cd .RLock ();defer _bg ._cd .RUnlock ();for _egd :=range _bg ._fge {if f (_egd ){break ;
};};};func (_aaa *StringRuneMap )Write (g string ,r rune ){_aaa ._dde .Lock ();defer _aaa ._dde .Unlock ();_aaa ._cag [g ]=r ;};func (_gddd *RuneUint16Map )RangeDelete (f func (_adc rune ,_ae uint16 )(_gec bool ,_cef bool )){_gddd ._ceg .Lock ();defer _gddd ._ceg .Unlock ();
for _ceba ,_dfg :=range _gddd ._gbb {_eee ,_dcd :=f (_ceba ,_dfg );if _eee {delete (_gddd ._gbb ,_ceba );};if _dcd {break ;};};};func (_ddd *RuneRuneMap )Write (g rune ,r rune ){_ddd ._db .Lock ();defer _ddd ._db .Unlock ();_ddd ._dd [g ]=r ;};func (_dg *RuneStringMap )Write (r rune ,s string ){_dg ._fad .Lock ();
defer _dg ._fad .Unlock ();_dg ._fb [r ]=s ;};type RuneUint16Map struct{_gbb map[rune ]uint16 ;_ceg _d .RWMutex ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_b :m }};func (_cdc *RuneUint16Map )Range (f func (_bc rune ,_ece uint16 )(_fe bool )){_cdc ._ceg .RLock ();
defer _cdc ._ceg .RUnlock ();for _ab ,_agbb :=range _cdc ._gbb {if f (_ab ,_agbb ){break ;};};};func NewRuneRuneMap (m map[rune ]rune )*RuneRuneMap {return &RuneRuneMap {_dd :m }};type RuneSet struct{_fge map[rune ]struct{};_cd _d .RWMutex ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_gbb :make (map[rune ]uint16 ,length )};
};func (_fgef *RuneUint16Map )Read (r rune )(uint16 ,bool ){_fgef ._ceg .RLock ();defer _fgef ._ceg .RUnlock ();_edf ,_fcd :=_fgef ._gbb [r ];return _edf ,_fcd ;};func MakeRuneByteMap (length int )*RuneByteMap {_eg :=make (map[rune ]byte ,length );return &RuneByteMap {_bf :_eg };
};func NewStringsMap (tuples []StringsTuple )*StringsMap {_acc :=map[string ]string {};for _ ,_cge :=range tuples {_acc [_cge .Key ]=_cge .Value ;};return &StringsMap {_dcb :_acc };};func (_cdd *RuneStringMap )Read (r rune )(string ,bool ){_cdd ._fad .RLock ();
defer _cdd ._fad .RUnlock ();_bb ,_ea :=_cdd ._fb [r ];return _bb ,_ea ;};func (_da *ByteRuneMap )Length ()int {_da ._g .RLock ();defer _da ._g .RUnlock ();return len (_da ._b )};func (_cb *StringsMap )Copy ()*StringsMap {_cb ._gbg .RLock ();defer _cb ._gbg .RUnlock ();
_bbf :=map[string ]string {};for _dbf ,_bcg :=range _cb ._dcb {_bbf [_dbf ]=_bcg ;};return &StringsMap {_dcb :_bbf };};type StringsTuple struct{Key ,Value string ;};func (_fbc *StringsMap )Read (g string )(string ,bool ){_fbc ._gbg .RLock ();defer _fbc ._gbg .RUnlock ();
_bfa ,_ace :=_fbc ._dcb [g ];return _bfa ,_ace ;};func (_f *ByteRuneMap )Read (b byte )(rune ,bool ){_f ._g .RLock ();defer _f ._g .RUnlock ();_c ,_ca :=_f ._b [b ];return _c ,_ca ;};func (_ded *StringsMap )Range (f func (_efe ,_gda string )(_gea bool )){_ded ._gbg .RLock ();
defer _ded ._gbg .RUnlock ();for _gfb ,_eb :=range _ded ._dcb {if f (_gfb ,_eb ){break ;};};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_fb :m }};func (_faa *RuneUint16Map )Delete (r rune ){_faa ._ceg .Lock ();defer _faa ._ceg .Unlock ();
delete (_faa ._gbb ,r );};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_b :make (map[byte ]rune ,length )}};type RuneStringMap struct{_fb map[rune ]string ;_fad _d .RWMutex ;};func (_fcc *RuneSet )Exists (r rune )bool {_fcc ._cd .RLock ();
defer _fcc ._cd .RUnlock ();_ ,_ba :=_fcc ._fge [r ];return _ba ;};func (_bd *RuneUint16Map )Write (r rune ,g uint16 ){_bd ._ceg .Lock ();defer _bd ._ceg .Unlock ();_bd ._gbb [r ]=g ;};type ByteRuneMap struct{_b map[byte ]rune ;_g _d .RWMutex ;};type RuneByteMap struct{_bf map[rune ]byte ;
_gd _d .RWMutex ;};func (_agd *RuneByteMap )Length ()int {_agd ._gd .RLock ();defer _agd ._gd .RUnlock ();return len (_agd ._bf );};