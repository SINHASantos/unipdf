//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _gd "sync";func (_edbg *StringsMap )Read (g string )(string ,bool ){_edbg ._edb .RLock ();defer _edbg ._edb .RUnlock ();_acc ,_da :=_edbg ._eae [g ];return _acc ,_da ;};func (_ec *RuneSet )Range (f func (_cf rune )(_de bool )){_ec ._gad .RLock ();
defer _ec ._gad .RUnlock ();for _df :=range _ec ._a {if f (_df ){break ;};};};func (_db *ByteRuneMap )Range (f func (_cb byte ,_ga rune )(_dg bool )){_db ._d .RLock ();defer _db ._d .RUnlock ();for _gb ,_cd :=range _db ._b {if f (_gb ,_cd ){break ;};};
};func (_aa *RuneStringMap )Range (f func (_ded rune ,_ffa string )(_ge bool )){_aa ._cfe .RLock ();defer _aa ._cfe .RUnlock ();for _ae ,_dce :=range _aa ._dbe {if f (_ae ,_dce ){break ;};};};func (_fcf *RuneUint16Map )Length ()int {_fcf ._bg .RLock ();
defer _fcf ._bg .RUnlock ();return len (_fcf ._ef );};func (_gg *RuneStringMap )Length ()int {_gg ._cfe .RLock ();defer _gg ._cfe .RUnlock ();return len (_gg ._dbe );};func (_ff *RuneStringMap )Read (r rune )(string ,bool ){_ff ._cfe .RLock ();defer _ff ._cfe .RUnlock ();
_ddag ,_cga :=_ff ._dbe [r ];return _ddag ,_cga ;};func MakeRuneByteMap (length int )*RuneByteMap {_dbc :=make (map[rune ]byte ,length );return &RuneByteMap {_f :_dbc };};type RuneByteMap struct{_f map[rune ]byte ;_fg _gd .RWMutex ;};func (_bb *RuneSet )Length ()int {_bb ._gad .RLock ();
defer _bb ._gad .RUnlock ();return len (_bb ._a )};func (_fgc *RuneSet )Write (r rune ){_fgc ._gad .Lock ();defer _fgc ._gad .Unlock ();_fgc ._a [r ]=struct{}{};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_dbe :m }};
func (_ee *ByteRuneMap )Length ()int {_ee ._d .RLock ();defer _ee ._d .RUnlock ();return len (_ee ._b )};func (_e *ByteRuneMap )Read (b byte )(rune ,bool ){_e ._d .RLock ();defer _e ._d .RUnlock ();_bd ,_dc :=_e ._b [b ];return _bd ,_dc ;};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_b :make (map[byte ]rune ,length )}};
type RuneStringMap struct{_dbe map[rune ]string ;_cfe _gd .RWMutex ;};func (_bc *StringRuneMap )Write (g string ,r rune ){_bc ._fggb .Lock ();defer _bc ._fggb .Unlock ();_bc ._gge [g ]=r ;};type StringsTuple struct{Key ,Value string ;};func (_ca *RuneUint16Map )Range (f func (_gda rune ,_fcc uint16 )(_ad bool )){_ca ._bg .RLock ();
defer _ca ._bg .RUnlock ();for _af ,_gee :=range _ca ._ef {if f (_af ,_gee ){break ;};};};func (_fb *RuneByteMap )Range (f func (_ea rune ,_ed byte )(_gaa bool )){_fb ._fg .RLock ();defer _fb ._fg .RUnlock ();for _fgg ,_ce :=range _fb ._f {if f (_fgg ,_ce ){break ;
};};};func (_bf *RuneSet )Exists (r rune )bool {_bf ._gad .RLock ();defer _bf ._gad .RUnlock ();_ ,_ccg :=_bf ._a [r ];return _ccg ;};func (_ddfd *StringsMap )Copy ()*StringsMap {_ddfd ._edb .RLock ();defer _ddfd ._edb .RUnlock ();_cca :=map[string ]string {};
for _ba ,_cff :=range _ddfd ._eae {_cca [_ba ]=_cff ;};return &StringsMap {_eae :_cca };};type StringRuneMap struct{_gge map[string ]rune ;_fggb _gd .RWMutex ;};func (_cfg *RuneStringMap )Write (r rune ,s string ){_cfg ._cfe .Lock ();defer _cfg ._cfe .Unlock ();
_cfg ._dbe [r ]=s ;};func (_eg *RuneUint16Map )Write (r rune ,g uint16 ){_eg ._bg .Lock ();defer _eg ._bg .Unlock ();_eg ._ef [r ]=g ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ef :make (map[rune ]uint16 ,length )};};
func (_bga *RuneUint16Map )RangeDelete (f func (_ddb rune ,_adf uint16 )(_ada bool ,_ega bool )){_bga ._bg .Lock ();defer _bga ._bg .Unlock ();for _bbc ,_gdd :=range _bga ._ef {_ggd ,_ab :=f (_bbc ,_gdd );if _ggd {delete (_bga ._ef ,_bbc );};if _ab {break ;
};};};type ByteRuneMap struct{_b map[byte ]rune ;_d _gd .RWMutex ;};func (_cgb *RuneByteMap )Write (r rune ,b byte ){_cgb ._fg .Lock ();defer _cgb ._fg .Unlock ();_cgb ._f [r ]=b ;};func (_gbb *RuneUint16Map )Delete (r rune ){_gbb ._bg .Lock ();defer _gbb ._bg .Unlock ();
delete (_gbb ._ef ,r );};func (_gc *StringsMap )Range (f func (_be ,_aaa string )(_fe bool )){_gc ._edb .RLock ();defer _gc ._edb .RUnlock ();for _ddf ,_abb :=range _gc ._eae {if f (_ddf ,_abb ){break ;};};};func (_dbea *StringRuneMap )Read (g string )(rune ,bool ){_dbea ._fggb .RLock ();
defer _dbea ._fggb .RUnlock ();_ac ,_aca :=_dbea ._gge [g ];return _ac ,_aca ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_a :make (map[rune ]struct{},length )}};type StringsMap struct{_eae map[string ]string ;_edb _gd .RWMutex ;};func (_bdd *StringRuneMap )Range (f func (_dbd string ,_dgd rune )(_bcf bool )){_bdd ._fggb .RLock ();
defer _bdd ._fggb .RUnlock ();for _ccga ,_fgd :=range _bdd ._gge {if f (_ccga ,_fgd ){break ;};};};func (_ged *StringRuneMap )Length ()int {_ged ._fggb .RLock ();defer _ged ._fggb .RUnlock ();return len (_ged ._gge );};func (_fc *RuneUint16Map )Read (r rune )(uint16 ,bool ){_fc ._bg .RLock ();
defer _fc ._bg .RUnlock ();_ccb ,_efc :=_fc ._ef [r ];return _ccb ,_efc ;};func (_c *ByteRuneMap )Write (b byte ,r rune ){_c ._d .Lock ();defer _c ._d .Unlock ();_c ._b [b ]=r };func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_gge :m }};
func (_cg *RuneByteMap )Read (r rune )(byte ,bool ){_cg ._fg .RLock ();defer _cg ._fg .RUnlock ();_cc ,_eb :=_cg ._f [r ];return _cc ,_eb ;};type RuneUint16Map struct{_ef map[rune ]uint16 ;_bg _gd .RWMutex ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_gddd :=map[string ]string {};
for _ ,_cdc :=range tuples {_gddd [_cdc .Key ]=_cdc .Value ;};return &StringsMap {_eae :_gddd };};func (_afe *StringsMap )Write (g1 ,g2 string ){_afe ._edb .Lock ();defer _afe ._edb .Unlock ();_afe ._eae [g1 ]=g2 ;};type RuneSet struct{_a map[rune ]struct{};
_gad _gd .RWMutex ;};func (_dd *RuneByteMap )Length ()int {_dd ._fg .RLock ();defer _dd ._fg .RUnlock ();return len (_dd ._f )};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_b :m }};