//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _f "sync";func (_eg *RuneByteMap )Read (r rune )(byte ,bool ){_eg ._bc .RLock ();defer _eg ._bc .RUnlock ();_cef ,_dg :=_eg ._d [r ];return _cef ,_dg ;};func (_dfb *RuneUint16Map )Write (r rune ,g uint16 ){_dfb ._gab .Lock ();defer _dfb ._gab .Unlock ();
_dfb ._ddc [r ]=g ;};func (_fb *ByteRuneMap )Read (b byte )(rune ,bool ){_fb ._cb .RLock ();defer _fb ._cb .RUnlock ();_fg ,_fe :=_fb ._ca [b ];return _fg ,_fe ;};func (_efc *StringsMap )Range (f func (_bgc ,_aab string )(_bbe bool )){_efc ._ge .RLock ();
defer _efc ._ge .RUnlock ();for _dga ,_dcf :=range _efc ._cgd {if f (_dga ,_dcf ){break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_ca :make (map[byte ]rune ,length )}};func (_ad *StringRuneMap )Length ()int {_ad ._aeb .RLock ();
defer _ad ._aeb .RUnlock ();return len (_ad ._ddf );};func (_bae *RuneStringMap )Write (r rune ,s string ){_bae ._dgc .Lock ();defer _bae ._dgc .Unlock ();_bae ._ba [r ]=s ;};type RuneUint16Map struct{_ddc map[rune ]uint16 ;_gab _f .RWMutex ;};func (_dfg *StringsMap )Read (g string )(string ,bool ){_dfg ._ge .RLock ();
defer _dfg ._ge .RUnlock ();_ade ,_dfae :=_dfg ._cgd [g ];return _ade ,_dfae ;};func (_fbe *StringsMap )Write (g1 ,g2 string ){_fbe ._ge .Lock ();defer _fbe ._ge .Unlock ();_fbe ._cgd [g1 ]=g2 ;};func (_cc *RuneSet )Range (f func (_af rune )(_afa bool )){_cc ._ac .RLock ();
defer _cc ._ac .RUnlock ();for _cee :=range _cc ._fa {if f (_cee ){break ;};};};type ByteRuneMap struct{_ca map[byte ]rune ;_cb _f .RWMutex ;};func (_dd *RuneSet )Exists (r rune )bool {_dd ._ac .RLock ();defer _dd ._ac .RUnlock ();_ ,_df :=_dd ._fa [r ];
return _df ;};func MakeRuneByteMap (length int )*RuneByteMap {_bg :=make (map[rune ]byte ,length );return &RuneByteMap {_d :_bg };};func (_gc *RuneSet )Write (r rune ){_gc ._ac .Lock ();defer _gc ._ac .Unlock ();_gc ._fa [r ]=struct{}{}};func (_cdc *RuneByteMap )Write (r rune ,b byte ){_cdc ._bc .Lock ();
defer _cdc ._bc .Unlock ();_cdc ._d [r ]=b ;};func (_be *RuneUint16Map )Length ()int {_be ._gab .RLock ();defer _be ._gab .RUnlock ();return len (_be ._ddc );};func (_ea *RuneByteMap )Length ()int {_ea ._bc .RLock ();defer _ea ._bc .RUnlock ();return len (_ea ._d )};
func (_b *ByteRuneMap )Write (b byte ,r rune ){_b ._cb .Lock ();defer _b ._cb .Unlock ();_b ._ca [b ]=r };func (_bf *ByteRuneMap )Range (f func (_bfa byte ,_e rune )(_g bool )){_bf ._cb .RLock ();defer _bf ._cb .RUnlock ();for _ce ,_cd :=range _bf ._ca {if f (_ce ,_cd ){break ;
};};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ba :m }};func (_fcd *RuneUint16Map )RangeDelete (f func (_bcb rune ,_ee uint16 )(_da bool ,_cfg bool )){_fcd ._gab .Lock ();defer _fcd ._gab .Unlock ();for _dbb ,_ae :=range _fcd ._ddc {_fcef ,_aa :=f (_dbb ,_ae );
if _fcef {delete (_fcd ._ddc ,_dbb );};if _aa {break ;};};};type RuneSet struct{_fa map[rune ]struct{};_ac _f .RWMutex ;};func (_fc *ByteRuneMap )Length ()int {_fc ._cb .RLock ();defer _fc ._cb .RUnlock ();return len (_fc ._ca )};type RuneStringMap struct{_ba map[rune ]string ;
_dgc _f .RWMutex ;};func (_agf *RuneUint16Map )Delete (r rune ){_agf ._gab .Lock ();defer _agf ._gab .Unlock ();delete (_agf ._ddc ,r );};func (_cdg *RuneUint16Map )Read (r rune )(uint16 ,bool ){_cdg ._gab .RLock ();defer _cdg ._gab .RUnlock ();_fd ,_egc :=_cdg ._ddc [r ];
return _fd ,_egc ;};func (_dfa *RuneUint16Map )Range (f func (_ec rune ,_bd uint16 )(_fef bool )){_dfa ._gab .RLock ();defer _dfa ._gab .RUnlock ();for _cda ,_fcf :=range _dfa ._ddc {if f (_cda ,_fcf ){break ;};};};func (_ab *RuneSet )Length ()int {_ab ._ac .RLock ();
defer _ab ._ac .RUnlock ();return len (_ab ._fa )};func (_caa *StringRuneMap )Read (g string )(rune ,bool ){_caa ._aeb .RLock ();defer _caa ._aeb .RUnlock ();_cfgb ,_aba :=_caa ._ddf [g ];return _cfgb ,_aba ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ddc :make (map[rune ]uint16 ,length )};
};type StringRuneMap struct{_ddf map[string ]rune ;_aeb _f .RWMutex ;};type StringsTuple struct{Key ,Value string ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_ddf :m }};func (_bgdf *StringsMap )Copy ()*StringsMap {_bgdf ._ge .RLock ();
defer _bgdf ._ge .RUnlock ();_adb :=map[string ]string {};for _gcd ,_cfed :=range _bgdf ._cgd {_adb [_gcd ]=_cfed ;};return &StringsMap {_cgd :_adb };};func (_cad *RuneStringMap )Length ()int {_cad ._dgc .RLock ();defer _cad ._dgc .RUnlock ();return len (_cad ._ba );
};func (_ga *RuneByteMap )Range (f func (_cf rune ,_de byte )(_bb bool )){_ga ._bc .RLock ();defer _ga ._bc .RUnlock ();for _a ,_ef :=range _ga ._d {if f (_a ,_ef ){break ;};};};type RuneByteMap struct{_d map[rune ]byte ;_bc _f .RWMutex ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_agd :=map[string ]string {};
for _ ,_eff :=range tuples {_agd [_eff .Key ]=_eff .Value ;};return &StringsMap {_cgd :_agd };};func (_db *RuneStringMap )Read (r rune )(string ,bool ){_db ._dgc .RLock ();defer _db ._dgc .RUnlock ();_bcc ,_cg :=_db ._ba [r ];return _bcc ,_cg ;};type StringsMap struct{_cgd map[string ]string ;
_ge _f .RWMutex ;};func (_cfe *StringRuneMap )Range (f func (_ed string ,_bec rune )(_bgd bool )){_cfe ._aeb .RLock ();defer _cfe ._aeb .RUnlock ();for _bfad ,_eaa :=range _cfe ._ddf {if f (_bfad ,_eaa ){break ;};};};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_ca :m }};
func (_acd *StringRuneMap )Write (g string ,r rune ){_acd ._aeb .Lock ();defer _acd ._aeb .Unlock ();_acd ._ddf [g ]=r ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_fa :make (map[rune ]struct{},length )}};func (_fbf *RuneStringMap )Range (f func (_baeg rune ,_fce string )(_fca bool )){_fbf ._dgc .RLock ();
defer _fbf ._dgc .RUnlock ();for _dc ,_bfae :=range _fbf ._ba {if f (_dc ,_bfae ){break ;};};};