//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _a "sync";func (_cga *RuneUint16Map )Delete (r rune ){_cga ._ecd .Lock ();defer _cga ._ecd .Unlock ();delete (_cga ._ada ,r );};func (_cg *RuneUint16Map )Read (r rune )(uint16 ,bool ){_cg ._ecd .RLock ();defer _cg ._ecd .RUnlock ();
_ea ,_efg :=_cg ._ada [r ];return _ea ,_efg ;};func (_bca *StringRuneMap )Length ()int {_bca ._cde .RLock ();defer _bca ._cde .RUnlock ();return len (_bca ._fdg );};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_f :make (map[rune ]struct{},length )}};
func (_bda *StringsMap )Range (f func (_bde ,_bbd string )(_gcc bool )){_bda ._abd .RLock ();defer _bda ._abd .RUnlock ();for _fdb ,_cbc :=range _bda ._ebe {if f (_fdb ,_cbc ){break ;};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_fdg :m }};
func (_egc *RuneSet )Write (r rune ){_egc ._bg .Lock ();defer _egc ._bg .Unlock ();_egc ._f [r ]=struct{}{}};type RuneStringMap struct{_ae map[rune ]string ;_ce _a .RWMutex ;};func (_bgf *StringsMap )Copy ()*StringsMap {_bgf ._abd .RLock ();defer _bgf ._abd .RUnlock ();
_gde :=map[string ]string {};for _gebd ,_acf :=range _bgf ._ebe {_gde [_gebd ]=_acf ;};return &StringsMap {_ebe :_gde };};type StringsTuple struct{Key ,Value string ;};func (_dee *RuneUint16Map )Length ()int {_dee ._ecd .RLock ();defer _dee ._ecd .RUnlock ();
return len (_dee ._ada );};func (_fe *RuneUint16Map )RangeDelete (f func (_cbg rune ,_ege uint16 )(_gg bool ,_eb bool )){_fe ._ecd .Lock ();defer _fe ._ecd .Unlock ();for _ebf ,_ag :=range _fe ._ada {_geb ,_gfe :=f (_ebf ,_ag );if _geb {delete (_fe ._ada ,_ebf );
};if _gfe {break ;};};};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_e :m }};func (_af *RuneStringMap )Read (r rune )(string ,bool ){_af ._ce .RLock ();defer _af ._ce .RUnlock ();_be ,_bf :=_af ._ae [r ];return _be ,_bf ;};
func (_dg *RuneByteMap )Range (f func (_ab rune ,_ddd byte )(_gb bool )){_dg ._bc .RLock ();defer _dg ._bc .RUnlock ();for _eg ,_abf :=range _dg ._ad {if f (_eg ,_abf ){break ;};};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ae :m }};
func (_gad *ByteRuneMap )Range (f func (_d byte ,_de rune )(_ba bool )){_gad ._g .RLock ();defer _gad ._g .RUnlock ();for _db ,_dc :=range _gad ._e {if f (_db ,_dc ){break ;};};};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ada :make (map[rune ]uint16 ,length )};
};type StringRuneMap struct{_fdg map[string ]rune ;_cde _a .RWMutex ;};func (_ac *StringRuneMap )Write (g string ,r rune ){_ac ._cde .Lock ();defer _ac ._cde .Unlock ();_ac ._fdg [g ]=r ;};func (_cb *ByteRuneMap )Length ()int {_cb ._g .RLock ();defer _cb ._g .RUnlock ();
return len (_cb ._e )};func (_ga *ByteRuneMap )Read (b byte )(rune ,bool ){_ga ._g .RLock ();defer _ga ._g .RUnlock ();_cd ,_b :=_ga ._e [b ];return _cd ,_b ;};func (_dce *RuneSet )Exists (r rune )bool {_dce ._bg .RLock ();defer _dce ._bg .RUnlock ();_ ,_dbe :=_dce ._f [r ];
return _dbe ;};type ByteRuneMap struct{_e map[byte ]rune ;_g _a .RWMutex ;};type RuneUint16Map struct{_ada map[rune ]uint16 ;_ecd _a .RWMutex ;};func MakeRuneByteMap (length int )*RuneByteMap {_dd :=make (map[rune ]byte ,length );return &RuneByteMap {_ad :_dd };
};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_e :make (map[byte ]rune ,length )}};func (_aa *ByteRuneMap )Write (b byte ,r rune ){_aa ._g .Lock ();defer _aa ._g .Unlock ();_aa ._e [b ]=r };func (_gf *RuneByteMap )Length ()int {_gf ._bc .RLock ();
defer _gf ._bc .RUnlock ();return len (_gf ._ad )};func (_efc *StringsMap )Read (g string )(string ,bool ){_efc ._abd .RLock ();defer _efc ._abd .RUnlock ();_bba ,_eae :=_efc ._ebe [g ];return _bba ,_eae ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_dcf :=map[string ]string {};
for _ ,_egb :=range tuples {_dcf [_egb .Key ]=_egb .Value ;};return &StringsMap {_ebe :_dcf };};func (_eac *StringRuneMap )Read (g string )(rune ,bool ){_eac ._cde .RLock ();defer _eac ._cde .RUnlock ();_edc ,_ade :=_eac ._fdg [g ];return _edc ,_ade ;};
func (_ef *RuneByteMap )Write (r rune ,b byte ){_ef ._bc .Lock ();defer _ef ._bc .Unlock ();_ef ._ad [r ]=b };func (_ed *RuneUint16Map )Range (f func (_cee rune ,_ccd uint16 )(_gba bool )){_ed ._ecd .RLock ();defer _ed ._ecd .RUnlock ();for _ede ,_bgd :=range _ed ._ada {if f (_ede ,_bgd ){break ;
};};};func (_bd *RuneByteMap )Read (r rune )(byte ,bool ){_bd ._bc .RLock ();defer _bd ._bc .RUnlock ();_ge ,_ddb :=_bd ._ad [r ];return _ge ,_ddb ;};type RuneSet struct{_f map[rune ]struct{};_bg _a .RWMutex ;};func (_ccg *RuneStringMap )Write (r rune ,s string ){_ccg ._ce .Lock ();
defer _ccg ._ce .Unlock ();_ccg ._ae [r ]=s ;};type RuneByteMap struct{_ad map[rune ]byte ;_bc _a .RWMutex ;};func (_dgb *StringRuneMap )Range (f func (_gdc string ,_cbgd rune )(_abff bool )){_dgb ._cde .RLock ();defer _dgb ._cde .RUnlock ();for _bbf ,_gbe :=range _dgb ._fdg {if f (_bbf ,_gbe ){break ;
};};};func (_gc *RuneUint16Map )Write (r rune ,g uint16 ){_gc ._ecd .Lock ();defer _gc ._ecd .Unlock ();_gc ._ada [r ]=g ;};type StringsMap struct{_ebe map[string ]string ;_abd _a .RWMutex ;};func (_eff *RuneStringMap )Length ()int {_eff ._ce .RLock ();
defer _eff ._ce .RUnlock ();return len (_eff ._ae );};func (_df *RuneSet )Length ()int {_df ._bg .RLock ();defer _df ._bg .RUnlock ();return len (_df ._f )};func (_cc *RuneSet )Range (f func (_bcc rune )(_aab bool )){_cc ._bg .RLock ();defer _cc ._bg .RUnlock ();
for _bb :=range _cc ._f {if f (_bb ){break ;};};};func (_gd *RuneStringMap )Range (f func (_egg rune ,_gbc string )(_afc bool )){_gd ._ce .RLock ();defer _gd ._ce .RUnlock ();for _dbd ,_fd :=range _gd ._ae {if f (_dbd ,_fd ){break ;};};};func (_ca *StringsMap )Write (g1 ,g2 string ){_ca ._abd .Lock ();
defer _ca ._abd .Unlock ();_ca ._ebe [g1 ]=g2 ;};