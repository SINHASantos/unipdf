//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _c "sync";func (_eg *RuneStringMap )Length ()int {_eg ._dd .RLock ();defer _eg ._dd .RUnlock ();return len (_eg ._aee );};func MakeRuneByteMap (length int )*RuneByteMap {_be :=make (map[rune ]byte ,length );return &RuneByteMap {_fe :_be };
};func (_gd *RuneSet )Length ()int {_gd ._beb .RLock ();defer _gd ._beb .RUnlock ();return len (_gd ._adb )};func (_aca *RuneUint16Map )RangeDelete (f func (_deb rune ,_ged uint16 )(_ccb bool ,_fac bool )){_aca ._ce .Lock ();defer _aca ._ce .Unlock ();
for _gea ,_af :=range _aca ._aa {_ba ,_deg :=f (_gea ,_af );if _ba {delete (_aca ._aa ,_gea );};if _deg {break ;};};};func (_eee *RuneUint16Map )Range (f func (_beac rune ,_gae uint16 )(_cdb bool )){_eee ._ce .RLock ();defer _eee ._ce .RUnlock ();for _cad ,_ef :=range _eee ._aa {if f (_cad ,_ef ){break ;
};};};func (_cba *RuneByteMap )Range (f func (_da rune ,_ge byte )(_ga bool )){_cba ._bc .RLock ();defer _cba ._bc .RUnlock ();for _cab ,_fb :=range _cba ._fe {if f (_cab ,_fb ){break ;};};};type RuneSet struct{_adb map[rune ]struct{};_beb _c .RWMutex ;
};func (_df *StringRuneMap )Write (g string ,r rune ){_df ._bdf .Lock ();defer _df ._bdf .Unlock ();_df ._gede [g ]=r ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_adb :make (map[rune ]struct{},length )}};func (_gcb *RuneByteMap )Length ()int {_gcb ._bc .RLock ();
defer _gcb ._bc .RUnlock ();return len (_gcb ._fe );};func (_bdb *RuneByteMap )Read (r rune )(byte ,bool ){_bdb ._bc .RLock ();defer _bdb ._bc .RUnlock ();_faa ,_cb :=_bdb ._fe [r ];return _faa ,_cb ;};func (_ccc *StringsMap )Range (f func (_fgf ,_edc string )(_dad bool )){_ccc ._gb .RLock ();
defer _ccc ._gb .RUnlock ();for _ceg ,_bg :=range _ccc ._aeea {if f (_ceg ,_bg ){break ;};};};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_aa :make (map[rune ]uint16 ,length )};};func (_gcg *RuneUint16Map )Write (r rune ,g uint16 ){_gcg ._ce .Lock ();
defer _gcg ._ce .Unlock ();_gcg ._aa [r ]=g ;};type RuneUint16Map struct{_aa map[rune ]uint16 ;_ce _c .RWMutex ;};func (_ab *RuneStringMap )Range (f func (_ea rune ,_abe string )(_fad bool )){_ab ._dd .RLock ();defer _ab ._dd .RUnlock ();for _fg ,_cd :=range _ab ._aee {if f (_fg ,_cd ){break ;
};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_gede :m }};type StringsTuple struct{Key ,Value string ;};func (_aaf *StringsMap )Copy ()*StringsMap {_aaf ._gb .RLock ();defer _aaf ._gb .RUnlock ();_ead :=map[string ]string {};
for _bbg ,_bcge :=range _aaf ._aeea {_ead [_bbg ]=_bcge ;};return &StringsMap {_aeea :_ead };};func (_cc *RuneStringMap )Write (r rune ,s string ){_cc ._dd .Lock ();defer _cc ._dd .Unlock ();_cc ._aee [r ]=s ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_g :m }};
func (_ae *RuneByteMap )Write (r rune ,b byte ){_ae ._bc .Lock ();defer _ae ._bc .Unlock ();_ae ._fe [r ]=b };type StringRuneMap struct{_gede map[string ]rune ;_bdf _c .RWMutex ;};func (_dde *RuneUint16Map )Length ()int {_dde ._ce .RLock ();defer _dde ._ce .RUnlock ();
return len (_dde ._aa );};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_g :make (map[byte ]rune ,length )}};type StringsMap struct{_aeea map[string ]string ;_gb _c .RWMutex ;};func (_bf *RuneUint16Map )Read (r rune )(uint16 ,bool ){_bf ._ce .RLock ();
defer _bf ._ce .RUnlock ();_ac ,_egd :=_bf ._aa [r ];return _ac ,_egd ;};func (_cbc *StringRuneMap )Range (f func (_bbb string ,_degc rune )(_aef bool )){_cbc ._bdf .RLock ();defer _cbc ._bdf .RUnlock ();for _gcbd ,_abc :=range _cbc ._gede {if f (_gcbd ,_abc ){break ;
};};};func (_ee *RuneStringMap )Read (r rune )(string ,bool ){_ee ._dd .RLock ();defer _ee ._dd .RUnlock ();_fef ,_bce :=_ee ._aee [r ];return _fef ,_bce ;};func (_a *ByteRuneMap )Range (f func (_b byte ,_ed rune )(_ad bool )){_a ._f .RLock ();defer _a ._f .RUnlock ();
for _ca ,_fa :=range _a ._g {if f (_ca ,_fa ){break ;};};};func (_fba *RuneSet )Range (f func (_eb rune )(_de bool )){_fba ._beb .RLock ();defer _fba ._beb .RUnlock ();for _def :=range _fba ._adb {if f (_def ){break ;};};};func (_gc *ByteRuneMap )Write (b byte ,r rune ){_gc ._f .Lock ();
defer _gc ._f .Unlock ();_gc ._g [b ]=r };func (_aae *StringRuneMap )Read (g string )(rune ,bool ){_aae ._bdf .RLock ();defer _aae ._bdf .RUnlock ();_ddd ,_dg :=_aae ._gede [g ];return _ddd ,_dg ;};type ByteRuneMap struct{_g map[byte ]rune ;_f _c .RWMutex ;
};func (_fbg *StringRuneMap )Length ()int {_fbg ._bdf .RLock ();defer _fbg ._bdf .RUnlock ();return len (_fbg ._gede );};func (_edd *RuneSet )Write (r rune ){_edd ._beb .Lock ();defer _edd ._beb .Unlock ();_edd ._adb [r ]=struct{}{};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_aee :m }};
func NewStringsMap (tuples []StringsTuple )*StringsMap {_gfd :=map[string ]string {};for _ ,_db :=range tuples {_gfd [_db .Key ]=_db .Value ;};return &StringsMap {_aeea :_gfd };};type RuneByteMap struct{_fe map[rune ]byte ;_bc _c .RWMutex ;};type RuneStringMap struct{_aee map[rune ]string ;
_dd _c .RWMutex ;};func (_fd *RuneUint16Map )Delete (r rune ){_fd ._ce .Lock ();defer _fd ._ce .Unlock ();delete (_fd ._aa ,r )};func (_adg *StringsMap )Write (g1 ,g2 string ){_adg ._gb .Lock ();defer _adg ._gb .Unlock ();_adg ._aeea [g1 ]=g2 ;};func (_bd *ByteRuneMap )Length ()int {_bd ._f .RLock ();
defer _bd ._f .RUnlock ();return len (_bd ._g )};func (_gf *ByteRuneMap )Read (b byte )(rune ,bool ){_gf ._f .RLock ();defer _gf ._f .RUnlock ();_d ,_ff :=_gf ._g [b ];return _d ,_ff ;};func (_bb *RuneSet )Exists (r rune )bool {_bb ._beb .RLock ();defer _bb ._beb .RUnlock ();
_ ,_bcg :=_bb ._adb [r ];return _bcg ;};func (_abf *StringsMap )Read (g string )(string ,bool ){_abf ._gb .RLock ();defer _abf ._gb .RUnlock ();_cdg ,_ccg :=_abf ._aeea [g ];return _cdg ,_ccg ;};