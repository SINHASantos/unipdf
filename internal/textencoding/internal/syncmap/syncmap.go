//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _g "sync";func (_ga *RuneSet )Exists (r rune )bool {_ga ._df .RLock ();defer _ga ._df .RUnlock ();_ ,_fda :=_ga ._fg [r ];return _fda ;};func (_egf *RuneSet )Write (r rune ){_egf ._df .Lock ();defer _egf ._df .Unlock ();_egf ._fg [r ]=struct{}{};
};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_fb :make (map[rune ]uint16 ,length )};};func (_gcg *RuneStringMap )Range (f func (_bcf rune ,_cdf string )(_af bool )){_gcg ._gad .RLock ();defer _gcg ._gad .RUnlock ();for _bca ,_bgf :=range _gcg ._fddf {if f (_bca ,_bgf ){break ;
};};};func MakeRuneByteMap (length int )*RuneByteMap {_cg :=make (map[rune ]byte ,length );return &RuneByteMap {_gc :_cg };};func (_f *ByteRuneMap )Write (b byte ,r rune ){_f ._gg .Lock ();defer _f ._gg .Unlock ();_f ._c [b ]=r };func (_bc *RuneByteMap )Write (r rune ,b byte ){_bc ._ceg .Lock ();
defer _bc ._ceg .Unlock ();_bc ._gc [r ]=b ;};func (_gec *RuneUint16Map )RangeDelete (f func (_da rune ,_fce uint16 )(_ddc bool ,_de bool )){_gec ._fgc .Lock ();defer _gec ._fgc .Unlock ();for _eb ,_cge :=range _gec ._fb {_fgb ,_cfd :=f (_eb ,_cge );if _fgb {delete (_gec ._fb ,_eb );
};if _cfd {break ;};};};type RuneByteMap struct{_gc map[rune ]byte ;_ceg _g .RWMutex ;};func (_ef *RuneUint16Map )Delete (r rune ){_ef ._fgc .Lock ();defer _ef ._fgc .Unlock ();delete (_ef ._fb ,r );};func (_aac *StringRuneMap )Length ()int {_aac ._gd .RLock ();
defer _aac ._gd .RUnlock ();return len (_aac ._gcc );};type RuneSet struct{_fg map[rune ]struct{};_df _g .RWMutex ;};func (_gcd *RuneByteMap )Range (f func (_fd rune ,_cc byte )(_be bool )){_gcd ._ceg .RLock ();defer _gcd ._ceg .RUnlock ();for _dc ,_dcc :=range _gcd ._gc {if f (_dc ,_dcc ){break ;
};};};func (_dcf *StringsMap )Read (g string )(string ,bool ){_dcf ._ged .RLock ();defer _dcf ._ged .RUnlock ();_ee ,_bea :=_dcf ._dcd [g ];return _ee ,_bea ;};func (_acc *RuneUint16Map )Length ()int {_acc ._fgc .RLock ();defer _acc ._fgc .RUnlock ();return len (_acc ._fb );
};func (_ge *RuneStringMap )Write (r rune ,s string ){_ge ._gad .Lock ();defer _ge ._gad .Unlock ();_ge ._fddf [r ]=s ;};func (_a *RuneByteMap )Read (r rune )(byte ,bool ){_a ._ceg .RLock ();defer _a ._ceg .RUnlock ();_cea ,_ab :=_a ._gc [r ];return _cea ,_ab ;
};func (_eg *ByteRuneMap )Read (b byte )(rune ,bool ){_eg ._gg .RLock ();defer _eg ._gg .RUnlock ();_ce ,_b :=_eg ._c [b ];return _ce ,_b ;};func (_ac *RuneByteMap )Length ()int {_ac ._ceg .RLock ();defer _ac ._ceg .RUnlock ();return len (_ac ._gc )};type RuneStringMap struct{_fddf map[rune ]string ;
_gad _g .RWMutex ;};func (_dbg *StringRuneMap )Read (g string )(rune ,bool ){_dbg ._gd .RLock ();defer _dbg ._gd .RUnlock ();_dbc ,_age :=_dbg ._gcc [g ];return _dbc ,_age ;};func (_ec *StringsMap )Range (f func (_gca ,_cca string )(_afd bool )){_ec ._ged .RLock ();
defer _ec ._ged .RUnlock ();for _ede ,_dfb :=range _ec ._dcd {if f (_ede ,_dfb ){break ;};};};func (_bbg *StringRuneMap )Write (g string ,r rune ){_bbg ._gd .Lock ();defer _bbg ._gd .Unlock ();_bbg ._gcc [g ]=r ;};func (_gce *RuneStringMap )Read (r rune )(string ,bool ){_gce ._gad .RLock ();
defer _gce ._gad .RUnlock ();_ggg ,_cf :=_gce ._fddf [r ];return _ggg ,_cf ;};func (_cef *RuneUint16Map )Range (f func (_fac rune ,_aca uint16 )(_fc bool )){_cef ._fgc .RLock ();defer _cef ._fgc .RUnlock ();for _ae ,_fca :=range _cef ._fb {if f (_ae ,_fca ){break ;
};};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_fddf :m }};func (_ace *StringsMap )Write (g1 ,g2 string ){_ace ._ged .Lock ();defer _ace ._ged .Unlock ();_ace ._dcd [g1 ]=g2 ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_fg :make (map[rune ]struct{},length )}};
func (_geg *StringRuneMap )Range (f func (_cgee string ,_gf rune )(_ff bool )){_geg ._gd .RLock ();defer _geg ._gd .RUnlock ();for _add ,_fe :=range _geg ._gcc {if f (_add ,_fe ){break ;};};};func (_ggfe *RuneSet )Length ()int {_ggfe ._df .RLock ();defer _ggfe ._df .RUnlock ();
return len (_ggfe ._fg );};func (_d *ByteRuneMap )Range (f func (_db byte ,_cd rune )(_bg bool )){_d ._gg .RLock ();defer _d ._gg .RUnlock ();for _ba ,_ggf :=range _d ._c {if f (_ba ,_ggf ){break ;};};};func (_fa *ByteRuneMap )Length ()int {_fa ._gg .RLock ();
defer _fa ._gg .RUnlock ();return len (_fa ._c )};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ebb :=map[string ]string {};for _ ,_efa :=range tuples {_ebb [_efa .Key ]=_efa .Value ;};return &StringsMap {_dcd :_ebb };};type StringsTuple struct{Key ,Value string ;
};type ByteRuneMap struct{_c map[byte ]rune ;_gg _g .RWMutex ;};type StringsMap struct{_dcd map[string ]string ;_ged _g .RWMutex ;};func (_ag *RuneSet )Range (f func (_fdd rune )(_bb bool )){_ag ._df .RLock ();defer _ag ._df .RUnlock ();for _bcg :=range _ag ._fg {if f (_bcg ){break ;
};};};func (_ed *RuneStringMap )Length ()int {_ed ._gad .RLock ();defer _ed ._gad .RUnlock ();return len (_ed ._fddf );};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_gcc :m }};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_c :m }};
type StringRuneMap struct{_gcc map[string ]rune ;_gd _g .RWMutex ;};type RuneUint16Map struct{_fb map[rune ]uint16 ;_fgc _g .RWMutex ;};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_c :make (map[byte ]rune ,length )}};func (_aa *RuneUint16Map )Read (r rune )(uint16 ,bool ){_aa ._fgc .RLock ();
defer _aa ._fgc .RUnlock ();_ad ,_agg :=_aa ._fb [r ];return _ad ,_agg ;};func (_afc *StringsMap )Copy ()*StringsMap {_afc ._ged .RLock ();defer _afc ._ged .RUnlock ();_aff :=map[string ]string {};for _fbd ,_bee :=range _afc ._dcd {_aff [_fbd ]=_bee ;};
return &StringsMap {_dcd :_aff };};func (_abb *RuneUint16Map )Write (r rune ,g uint16 ){_abb ._fgc .Lock ();defer _abb ._fgc .Unlock ();_abb ._fb [r ]=g ;};