//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _b "sync";func (_fga *RuneUint16Map )Range (f func (_def rune ,_ffg uint16 )(_cdg bool )){_fga ._ccb .RLock ();defer _fga ._ccb .RUnlock ();for _fgd ,_db :=range _fga ._dge {if f (_fgd ,_db ){break ;};};};func (_ed *RuneSet )Range (f func (_bb rune )(_dd bool )){_ed ._ba .RLock ();
defer _ed ._ba .RUnlock ();for _de :=range _ed ._gb {if f (_de ){break ;};};};func (_af *RuneByteMap )Range (f func (_bde rune ,_bc byte )(_g bool )){_af ._fc .RLock ();defer _af ._fc .RUnlock ();for _cd ,_gc :=range _af ._abe {if f (_cd ,_gc ){break ;
};};};func (_df *ByteRuneMap )Range (f func (_cc byte ,_f rune )(_ae bool )){_df ._a .RLock ();defer _df ._a .RUnlock ();for _ab ,_fb :=range _df ._eb {if f (_ab ,_fb ){break ;};};};type RuneUint16Map struct{_dge map[rune ]uint16 ;_ccb _b .RWMutex ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ddg :m }};
func (_afd *RuneUint16Map )Write (r rune ,g uint16 ){_afd ._ccb .Lock ();defer _afd ._ccb .Unlock ();_afd ._dge [r ]=g ;};func (_bad *RuneSet )Write (r rune ){_bad ._ba .Lock ();defer _bad ._ba .Unlock ();_bad ._gb [r ]=struct{}{};};func (_eg *RuneByteMap )Read (r rune )(byte ,bool ){_eg ._fc .RLock ();
defer _eg ._fc .RUnlock ();_fg ,_bd :=_eg ._abe [r ];return _fg ,_bd ;};func (_cg *RuneStringMap )Range (f func (_ege rune ,_baf string )(_dgc bool )){_cg ._cb .RLock ();defer _cg ._cb .RUnlock ();for _aad ,_bcb :=range _cg ._ddg {if f (_aad ,_bcb ){break ;
};};};func (_ea *StringRuneMap )Read (g string )(rune ,bool ){_ea ._gca .RLock ();defer _ea ._gca .RUnlock ();_gce ,_ga :=_ea ._dbfd [g ];return _gce ,_ga ;};func (_caa *StringRuneMap )Write (g string ,r rune ){_caa ._gca .Lock ();defer _caa ._gca .Unlock ();
_caa ._dbfd [g ]=r ;};type RuneSet struct{_gb map[rune ]struct{};_ba _b .RWMutex ;};func (_bg *RuneByteMap )Write (r rune ,b byte ){_bg ._fc .Lock ();defer _bg ._fc .Unlock ();_bg ._abe [r ]=b ;};func (_gbe *StringsMap )Copy ()*StringsMap {_gbe ._fd .RLock ();
defer _gbe ._fd .RUnlock ();_daa :=map[string ]string {};for _gbb ,_gf :=range _gbe ._gbg {_daa [_gbb ]=_gf ;};return &StringsMap {_gbg :_daa };};func (_ag *RuneUint16Map )RangeDelete (f func (_beb rune ,_dbf uint16 )(_fgdc bool ,_gd bool )){_ag ._ccb .Lock ();
defer _ag ._ccb .Unlock ();for _eed ,_ac :=range _ag ._dge {_ddc ,_ccd :=f (_eed ,_ac );if _ddc {delete (_ag ._dge ,_eed );};if _ccd {break ;};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_dbfd :m }};type StringsTuple struct{Key ,Value string ;
};func (_ee *RuneStringMap )Length ()int {_ee ._cb .RLock ();defer _ee ._cb .RUnlock ();return len (_ee ._ddg );};func (_efb *StringsMap )Read (g string )(string ,bool ){_efb ._fd .RLock ();defer _efb ._fd .RUnlock ();_agf ,_bdf :=_efb ._gbg [g ];return _agf ,_bdf ;
};func (_fbb *RuneSet )Exists (r rune )bool {_fbb ._ba .RLock ();defer _fbb ._ba .RUnlock ();_ ,_ccf :=_fbb ._gb [r ];return _ccf ;};func (_fgg *RuneUint16Map )Delete (r rune ){_fgg ._ccb .Lock ();defer _fgg ._ccb .Unlock ();delete (_fgg ._dge ,r );};type StringsMap struct{_gbg map[string ]string ;
_fd _b .RWMutex ;};func (_fe *RuneStringMap )Write (r rune ,s string ){_fe ._cb .Lock ();defer _fe ._cb .Unlock ();_fe ._ddg [r ]=s ;};func (_ef *StringRuneMap )Length ()int {_ef ._gca .RLock ();defer _ef ._gca .RUnlock ();return len (_ef ._dbfd );};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_dge :make (map[rune ]uint16 ,length )};
};type StringRuneMap struct{_dbfd map[string ]rune ;_gca _b .RWMutex ;};func (_afe *StringsMap )Range (f func (_egc ,_eae string )(_fa bool )){_afe ._fd .RLock ();defer _afe ._fd .RUnlock ();for _gcg ,_gcf :=range _afe ._gbg {if f (_gcg ,_gcf ){break ;
};};};type RuneStringMap struct{_ddg map[rune ]string ;_cb _b .RWMutex ;};func (_agc *RuneUint16Map )Length ()int {_agc ._ccb .RLock ();defer _agc ._ccb .RUnlock ();return len (_agc ._dge );};func (_dc *RuneByteMap )Length ()int {_dc ._fc .RLock ();defer _dc ._fc .RUnlock ();
return len (_dc ._abe )};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_eb :make (map[byte ]rune ,length )}};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_eb :m }};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_gb :make (map[rune ]struct{},length )}};
type RuneByteMap struct{_abe map[rune ]byte ;_fc _b .RWMutex ;};func (_aa *RuneSet )Length ()int {_aa ._ba .RLock ();defer _aa ._ba .RUnlock ();return len (_aa ._gb )};func (_ce *ByteRuneMap )Length ()int {_ce ._a .RLock ();defer _ce ._a .RUnlock ();return len (_ce ._eb )};
func (_d *ByteRuneMap )Read (b byte )(rune ,bool ){_d ._a .RLock ();defer _d ._a .RUnlock ();_ad ,_dg :=_d ._eb [b ];return _ad ,_dg ;};func (_dea *RuneStringMap )Read (r rune )(string ,bool ){_dea ._cb .RLock ();defer _dea ._cb .RUnlock ();_be ,_cf :=_dea ._ddg [r ];
return _be ,_cf ;};func (_cfd *StringsMap )Write (g1 ,g2 string ){_cfd ._fd .Lock ();defer _cfd ._fd .Unlock ();_cfd ._gbg [g1 ]=g2 ;};type ByteRuneMap struct{_eb map[byte ]rune ;_a _b .RWMutex ;};func (_da *StringRuneMap )Range (f func (_ge string ,_bdd rune )(_ebf bool )){_da ._gca .RLock ();
defer _da ._gca .RUnlock ();for _cdd ,_bea :=range _da ._dbfd {if f (_cdd ,_bea ){break ;};};};func (_c *ByteRuneMap )Write (b byte ,r rune ){_c ._a .Lock ();defer _c ._a .Unlock ();_c ._eb [b ]=r };func NewStringsMap (tuples []StringsTuple )*StringsMap {_gee :=map[string ]string {};
for _ ,_fcb :=range tuples {_gee [_fcb .Key ]=_fcb .Value ;};return &StringsMap {_gbg :_gee };};func MakeRuneByteMap (length int )*RuneByteMap {_fbf :=make (map[rune ]byte ,length );return &RuneByteMap {_abe :_fbf };};func (_ca *RuneUint16Map )Read (r rune )(uint16 ,bool ){_ca ._ccb .RLock ();
defer _ca ._ccb .RUnlock ();_ff ,_gbf :=_ca ._dge [r ];return _ff ,_gbf ;};