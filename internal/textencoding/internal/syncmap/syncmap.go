//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _c "sync";func (_b *ByteRuneMap )Read (b byte )(rune ,bool ){_b ._a .RLock ();defer _b ._a .RUnlock ();_d ,_be :=_b ._g [b ];return _d ,_be ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_cd :make (map[rune ]struct{},length )}};
func (_baf *RuneUint16Map )Length ()int {_baf ._gae .RLock ();defer _baf ._gae .RUnlock ();return len (_baf ._ded );};func (_cb *RuneByteMap )Range (f func (_eb rune ,_bg byte )(_ag bool )){_cb ._gc .RLock ();defer _cb ._gc .RUnlock ();for _eg ,_ba :=range _cb ._ge {if f (_eg ,_ba ){break ;
};};};type RuneSet struct{_cd map[rune ]struct{};_cba _c .RWMutex ;};func (_deb *RuneByteMap )Read (r rune )(byte ,bool ){_deb ._gc .RLock ();defer _deb ._gc .RUnlock ();_ac ,_af :=_deb ._ge [r ];return _ac ,_af ;};func (_ec *RuneStringMap )Write (r rune ,s string ){_ec ._egb .Lock ();
defer _ec ._egb .Unlock ();_ec ._bd [r ]=s ;};func (_bae *RuneByteMap )Length ()int {_bae ._gc .RLock ();defer _bae ._gc .RUnlock ();return len (_bae ._ge );};type StringsTuple struct{Key ,Value string ;};func (_de *ByteRuneMap )Write (b byte ,r rune ){_de ._a .Lock ();
defer _de ._a .Unlock ();_de ._g [b ]=r };func (_ggg *RuneByteMap )Write (r rune ,b byte ){_ggg ._gc .Lock ();defer _ggg ._gc .Unlock ();_ggg ._ge [r ]=b ;};func (_ebf *StringRuneMap )Write (g string ,r rune ){_ebf ._feb .Lock ();defer _ebf ._feb .Unlock ();
_ebf ._dda [g ]=r ;};func (_bfd *StringsMap )Range (f func (_dbb ,_cdd string )(_ffae bool )){_bfd ._ffa .RLock ();defer _bfd ._ffa .RUnlock ();for _bfde ,_ebdf :=range _bfd ._cdc {if f (_bfde ,_ebdf ){break ;};};};func (_ab *ByteRuneMap )Length ()int {_ab ._a .RLock ();
defer _ab ._a .RUnlock ();return len (_ab ._g )};func (_fd *RuneUint16Map )Write (r rune ,g uint16 ){_fd ._gae .Lock ();defer _fd ._gae .Unlock ();_fd ._ded [r ]=g ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ca :=map[string ]string {};for _ ,_fbg :=range tuples {_ca [_fbg .Key ]=_fbg .Value ;
};return &StringsMap {_cdc :_ca };};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_g :m }};func (_gaa *RuneStringMap )Read (r rune )(string ,bool ){_gaa ._egb .RLock ();defer _gaa ._egb .RUnlock ();_fbe ,_ad :=_gaa ._bd [r ];
return _fbe ,_ad ;};type StringsMap struct{_cdc map[string ]string ;_ffa _c .RWMutex ;};func (_fdb *RuneUint16Map )Range (f func (_gfd rune ,_dd uint16 )(_bea bool )){_fdb ._gae .RLock ();defer _fdb ._gae .RUnlock ();for _ega ,_edb :=range _fdb ._ded {if f (_ega ,_edb ){break ;
};};};type RuneUint16Map struct{_ded map[rune ]uint16 ;_gae _c .RWMutex ;};func (_dba *StringRuneMap )Length ()int {_dba ._feb .RLock ();defer _dba ._feb .RUnlock ();return len (_dba ._dda );};type StringRuneMap struct{_dda map[string ]rune ;_feb _c .RWMutex ;
};func (_fff *StringRuneMap )Range (f func (_adf string ,_db rune )(_gac bool )){_fff ._feb .RLock ();defer _fff ._feb .RUnlock ();for _fegg ,_baaa :=range _fff ._dda {if f (_fegg ,_baaa ){break ;};};};func (_edg *StringRuneMap )Read (g string )(rune ,bool ){_edg ._feb .RLock ();
defer _edg ._feb .RUnlock ();_cg ,_bcb :=_edg ._dda [g ];return _cg ,_bcb ;};type ByteRuneMap struct{_g map[byte ]rune ;_a _c .RWMutex ;};func MakeRuneByteMap (length int )*RuneByteMap {_gf :=make (map[rune ]byte ,length );return &RuneByteMap {_ge :_gf };
};type RuneByteMap struct{_ge map[rune ]byte ;_gc _c .RWMutex ;};func (_gec *RuneSet )Length ()int {_gec ._cba .RLock ();defer _gec ._cba .RUnlock ();return len (_gec ._cd )};func (_ede *RuneUint16Map )Read (r rune )(uint16 ,bool ){_ede ._gae .RLock ();
defer _ede ._gae .RUnlock ();_ae ,_bf :=_ede ._ded [r ];return _ae ,_bf ;};func (_fg *RuneStringMap )Length ()int {_fg ._egb .RLock ();defer _fg ._egb .RUnlock ();return len (_fg ._bd );};func (_cde *StringsMap )Copy ()*StringsMap {_cde ._ffa .RLock ();
defer _cde ._ffa .RUnlock ();_bag :=map[string ]string {};for _fc ,_bga :=range _cde ._cdc {_bag [_fc ]=_bga ;};return &StringsMap {_cdc :_bag };};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_g :make (map[byte ]rune ,length )}};
type RuneStringMap struct{_bd map[rune ]string ;_egb _c .RWMutex ;};func (_fbf *StringsMap )Write (g1 ,g2 string ){_fbf ._ffa .Lock ();defer _fbf ._ffa .Unlock ();_fbf ._cdc [g1 ]=g2 ;};func (_aa *RuneSet )Exists (r rune )bool {_aa ._cba .RLock ();defer _aa ._cba .RUnlock ();
_ ,_fe :=_aa ._cd [r ];return _fe ;};func (_cc *RuneUint16Map )Delete (r rune ){_cc ._gae .Lock ();defer _cc ._gae .Unlock ();delete (_cc ._ded ,r );};func (_dcd *StringsMap )Read (g string )(string ,bool ){_dcd ._ffa .RLock ();defer _dcd ._ffa .RUnlock ();
_dgf ,_adg :=_dcd ._cdc [g ];return _dgf ,_adg ;};func (_geb *RuneUint16Map )RangeDelete (f func (_edbe rune ,_baaf uint16 )(_dc bool ,_abg bool )){_geb ._gae .Lock ();defer _geb ._gae .Unlock ();for _ace ,_bca :=range _geb ._ded {_ebd ,_gee :=f (_ace ,_bca );
if _ebd {delete (_geb ._ded ,_ace );};if _gee {break ;};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_dda :m }};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_bd :m }};func (_feg *RuneSet )Write (r rune ){_feg ._cba .Lock ();
defer _feg ._cba .Unlock ();_feg ._cd [r ]=struct{}{};};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ded :make (map[rune ]uint16 ,length )};};func (_gg *ByteRuneMap )Range (f func (_e byte ,_fb rune )(_ed bool )){_gg ._a .RLock ();
defer _gg ._a .RUnlock ();for _ga ,_ef :=range _gg ._g {if f (_ga ,_ef ){break ;};};};func (_baa *RuneSet )Range (f func (_bc rune )(_gad bool )){_baa ._cba .RLock ();defer _baa ._cba .RUnlock ();for _dg :=range _baa ._cd {if f (_dg ){break ;};};};func (_efa *RuneStringMap )Range (f func (_ff rune ,_eac string )(_fbeg bool )){_efa ._egb .RLock ();
defer _efa ._egb .RUnlock ();for _acc ,_efe :=range _efa ._bd {if f (_acc ,_efe ){break ;};};};