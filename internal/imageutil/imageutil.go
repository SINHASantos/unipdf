//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_f "encoding/binary";_d "errors";_e "fmt";_b "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/bitwise";_a "image";_ce "image/color";_da "image/draw";_cf "math";);var _ _a .Image =&NRGBA32 {};func (_abbe *CMYK32 )ColorAt (x ,y int )(_ce .Color ,error ){return ColorAtCMYK (x ,y ,_abbe .Width ,_abbe .Data ,_abbe .Decode );
};func _gedc (_bggbc Gray ,_fbfa CMYK ,_afcd _a .Rectangle ){for _eadg :=0;_eadg < _afcd .Max .X ;_eadg ++{for _gff :=0;_gff < _afcd .Max .Y ;_gff ++{_ffcc :=_bggbc .GrayAt (_eadg ,_gff );_fbfa .SetCMYK (_eadg ,_gff ,_gfee (_ffcc ));};};};func (_dddf *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_dddf .copy ()}};
func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_ce .NRGBA ,error ){_egag :=y *bytesPerLine +x *3/2;if _egag +1>=len (data ){return _ce .NRGBA {},_cdad (x ,y );};const (_bfbc =0xf;_eegd =uint8 (0xff););_afbb :=_eegd ;
if alpha !=nil {_adefb :=y *BytesPerLine (width ,4,1);if _adefb < len (alpha ){if x %2==0{_afbb =(alpha [_adefb ]>>uint (4))&_bfbc ;}else {_afbb =alpha [_adefb ]&_bfbc ;};_afbb |=_afbb <<4;};};var _gdabd ,_cbcf ,_ddcd uint8 ;if x *3%2==0{_gdabd =(data [_egag ]>>uint (4))&_bfbc ;
_cbcf =data [_egag ]&_bfbc ;_ddcd =(data [_egag +1]>>uint (4))&_bfbc ;}else {_gdabd =data [_egag ]&_bfbc ;_cbcf =(data [_egag +1]>>uint (4))&_bfbc ;_ddcd =data [_egag +1]&_bfbc ;};if len (decode )==6{_gdabd =uint8 (uint32 (LinearInterpolate (float64 (_gdabd ),0,15,decode [0],decode [1]))&0xf);
_cbcf =uint8 (uint32 (LinearInterpolate (float64 (_cbcf ),0,15,decode [2],decode [3]))&0xf);_ddcd =uint8 (uint32 (LinearInterpolate (float64 (_ddcd ),0,15,decode [4],decode [5]))&0xf);};return _ce .NRGBA {R :(_gdabd <<4)|(_gdabd &0xf),G :(_cbcf <<4)|(_cbcf &0xf),B :(_ddcd <<4)|(_ddcd &0xf),A :_afbb },nil ;
};func (_afcb *Gray4 )Histogram ()(_eba [256]int ){for _fdba :=0;_fdba < _afcb .Width ;_fdba ++{for _gef :=0;_gef < _afcb .Height ;_gef ++{_eba [_afcb .GrayAt (_fdba ,_gef ).Y ]++;};};return _eba ;};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _cf .Abs (xmax -xmin )< 0.000001{return ymin ;
};_efe :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _efe ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ce .Gray ,error ){_eeg :=y *bytesPerLine +x ;if _eeg >=len (data ){return _ce .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_defc :=data [_eeg ];if len (decode )==2{_defc =uint8 (uint32 (LinearInterpolate (float64 (_defc ),0,255,decode [0],decode [1]))&0xff);};return _ce .Gray {Y :_defc },nil ;};type Gray16 struct{ImageBase };func _age (_afdf ,_ca *Monochrome )(_gc error ){_fd :=_ca .BytesPerLine ;
_cg :=_afdf .BytesPerLine ;var _df ,_dgg ,_fce ,_cae ,_fcg int ;for _fce =0;_fce < _ca .Height ;_fce ++{_df =_fce *_fd ;_dgg =8*_fce *_cg ;for _cae =0;_cae < _fd ;_cae ++{if _gc =_afdf .setEightBytes (_dgg +_cae *8,_abe [_ca .Data [_df +_cae ]]);_gc !=nil {return _gc ;
};};for _fcg =1;_fcg < 8;_fcg ++{for _cae =0;_cae < _cg ;_cae ++{if _gc =_afdf .setByte (_dgg +_fcg *_cg +_cae ,_afdf .Data [_dgg +_cae ]);_gc !=nil {return _gc ;};};};};return nil ;};func (_bafd *NRGBA64 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_bafd .Width ,Y :_bafd .Height }};
};type Gray4 struct{ImageBase };func (_ccc *Gray4 )Validate ()error {if len (_ccc .Data )!=_ccc .Height *_ccc .BytesPerLine {return ErrInvalidImage ;};return nil ;};type shift int ;var _ Image =&Gray8 {};func (_acdb *Gray8 )Histogram ()(_adfd [256]int ){for _ffe :=0;
_ffe < len (_acdb .Data );_ffe ++{_adfd [_acdb .Data [_ffe ]]++;};return _adfd ;};func _fff (_aeef ,_cfe CMYK ,_adb _a .Rectangle ){for _gca :=0;_gca < _adb .Max .X ;_gca ++{for _afb :=0;_afb < _adb .Max .Y ;_afb ++{_cfe .SetCMYK (_gca ,_afb ,_aeef .CMYKAt (_gca ,_afb ));
};};};func (_gfgc *Monochrome )setGray (_aebbd int ,_fcd _ce .Gray ,_dacba int ){if _fcd .Y ==0{_gfgc .clearBit (_dacba ,_aebbd );}else {_gfgc .setGrayBit (_dacba ,_aebbd );};};func _bcfb (_cegf Gray ,_ffb NRGBA ,_dacc _a .Rectangle ){for _bgf :=0;_bgf < _dacc .Max .X ;
_bgf ++{for _efcbf :=0;_efcbf < _dacc .Max .Y ;_efcbf ++{_dfga :=_cfga (_ffb .NRGBAAt (_bgf ,_efcbf ));_cegf .SetGray (_bgf ,_efcbf ,_dfga );};};};var _ _a .Image =&Gray2 {};func _gcf (_cbca *Monochrome ,_fccc ,_agcb ,_cede ,_adbe int ,_eaga RasterOperator ){if _fccc < 0{_cede +=_fccc ;
_fccc =0;};_bfbf :=_fccc +_cede -_cbca .Width ;if _bfbf > 0{_cede -=_bfbf ;};if _agcb < 0{_adbe +=_agcb ;_agcb =0;};_gfcdb :=_agcb +_adbe -_cbca .Height ;if _gfcdb > 0{_adbe -=_gfcdb ;};if _cede <=0||_adbe <=0{return ;};if (_fccc &7)==0{_ecag (_cbca ,_fccc ,_agcb ,_cede ,_adbe ,_eaga );
}else {_fagg (_cbca ,_fccc ,_agcb ,_cede ,_adbe ,_eaga );};};func _bfb ()(_eea [256]uint64 ){for _bbc :=0;_bbc < 256;_bbc ++{if _bbc &0x01!=0{_eea [_bbc ]|=0xff;};if _bbc &0x02!=0{_eea [_bbc ]|=0xff00;};if _bbc &0x04!=0{_eea [_bbc ]|=0xff0000;};if _bbc &0x08!=0{_eea [_bbc ]|=0xff000000;
};if _bbc &0x10!=0{_eea [_bbc ]|=0xff00000000;};if _bbc &0x20!=0{_eea [_bbc ]|=0xff0000000000;};if _bbc &0x40!=0{_eea [_bbc ]|=0xff000000000000;};if _bbc &0x80!=0{_eea [_bbc ]|=0xff00000000000000;};};return _eea ;};func _fdaff (_fdeg RGBA ,_ecca NRGBA ,_bgeb _a .Rectangle ){for _beac :=0;
_beac < _bgeb .Max .X ;_beac ++{for _ccbb :=0;_ccbb < _bgeb .Max .Y ;_ccbb ++{_gefga :=_fdeg .RGBAAt (_beac ,_ccbb );_ecca .SetNRGBA (_beac ,_ccbb ,_acg (_gefga ));};};};var (Gray2Model =_ce .ModelFunc (_bbdf );Gray4Model =_ce .ModelFunc (_bagd );NRGBA16Model =_ce .ModelFunc (_aaede );
);func _adggg (_bcefa nrgba64 ,_bcea RGBA ,_fefa _a .Rectangle ){for _bagc :=0;_bagc < _fefa .Max .X ;_bagc ++{for _cbgg :=0;_cbgg < _fefa .Max .Y ;_cbgg ++{_fddc :=_bcefa .NRGBA64At (_bagc ,_cbgg );_bcea .SetRGBA (_bagc ,_cbgg ,_dfafg (_fddc ));};};};
func (_baae *ImageBase )GetAlpha ()[]byte {return _baae .Alpha };func (_bfcg *Gray16 )Base ()*ImageBase {return &_bfcg .ImageBase };func (_agcf *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_agcf .copy ()}};func (_edec *ImageBase )MakeAlpha (){_edec .newAlpha ()};
func _cbea (_fecg _ce .RGBA )_ce .Gray {_bbb :=(19595*uint32 (_fecg .R )+38470*uint32 (_fecg .G )+7471*uint32 (_fecg .B )+1<<7)>>16;return _ce .Gray {Y :uint8 (_bbb )};};func _gge (_fgfa _a .Image )(Image ,error ){if _gbgf ,_dba :=_fgfa .(*Gray16 );_dba {return _gbgf .Copy (),nil ;
};_geega :=_fgfa .Bounds ();_acgb ,_dgbd :=NewImage (_geega .Max .X ,_geega .Max .Y ,16,1,nil ,nil ,nil );if _dgbd !=nil {return nil ,_dgbd ;};_efaa (_fgfa ,_acgb ,_geega );return _acgb ,nil ;};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;
MakeAlpha ();};func _cbb (_ecgb _ce .CMYK )_ce .Gray {_bfgg ,_bbaf ,_cfa :=_ce .CMYKToRGB (_ecgb .C ,_ecgb .M ,_ecgb .Y ,_ecgb .K );_dfae :=(19595*uint32 (_bfgg )+38470*uint32 (_bbaf )+7471*uint32 (_cfa )+1<<7)>>16;return _ce .Gray {Y :uint8 (_dfae )};
};func (_egf *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _dde bool ;_ggc :=scale ;if scale < 1{_ggc =1/scale ;_dde =true ;};_gfa :=NextPowerOf2 (uint (_ggc ));if InDelta (float64 (_gfa ),_ggc ,0.001){if _dde {return _egf .ReduceBinary (_ggc );
};return _egf .ExpandBinary (int (_gfa ));};_aacd :=int (_cf .RoundToEven (float64 (_egf .Width )*scale ));_dgcd :=int (_cf .RoundToEven (float64 (_egf .Height )*scale ));return _egf .ScaleLow (_aacd ,_dgcd );};func (_bbce *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _dc (_bbce ,factor );};func (_cfdf *NRGBA16 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_cfdf .Width ,Y :_cfdf .Height }};};var _ Image =&CMYK32 {};func _gegb (_bfd NRGBA ,_dabg CMYK ,_ggge _a .Rectangle ){for _dda :=0;_dda < _ggge .Max .X ;
_dda ++{for _gaca :=0;_gaca < _ggge .Max .Y ;_gaca ++{_abc :=_bfd .NRGBAAt (_dda ,_gaca );_dabg .SetCMYK (_dda ,_gaca ,_cdge (_abc ));};};};const (_aggf shift =iota ;_faec ;);func (_bdcg *NRGBA64 )SetNRGBA64 (x ,y int ,c _ce .NRGBA64 ){_egacf :=(y *_bdcg .Width +x )*2;
_caddgb :=_egacf *3;if _caddgb +5>=len (_bdcg .Data ){return ;};_bdcg .setNRGBA64 (_caddgb ,c ,_egacf );};func (_dge *CMYK32 )Validate ()error {if len (_dge .Data )!=4*_dge .Width *_dge .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _fdafa (_geef _ce .RGBA )_ce .CMYK {_bbbg ,_ggff ,_egdb ,_fea :=_ce .RGBToCMYK (_geef .R ,_geef .G ,_geef .B );return _ce .CMYK {C :_bbbg ,M :_ggff ,Y :_egdb ,K :_fea };};func (_afa *Monochrome )setIndexedBit (_egfg int ){_afa .Data [(_egfg >>3)]|=0x80>>uint (_egfg &7)};
func _dbg (_ff ,_ggb *Monochrome ,_eebc []byte ,_eeab int )(_aega error ){var (_deg ,_ffc ,_edad ,_dfgc ,_dea ,_dga ,_dgd ,_gad int ;_ebe ,_fcef ,_bcc ,_cbfa uint32 ;_aff ,_cec byte ;_cca uint16 ;);_bba :=make ([]byte ,4);_bdba :=make ([]byte ,4);for _edad =0;
_edad < _ff .Height -1;_edad ,_dfgc =_edad +2,_dfgc +1{_deg =_edad *_ff .BytesPerLine ;_ffc =_dfgc *_ggb .BytesPerLine ;for _dea ,_dga =0,0;_dea < _eeab ;_dea ,_dga =_dea +4,_dga +1{for _dgd =0;_dgd < 4;_dgd ++{_gad =_deg +_dea +_dgd ;if _gad <=len (_ff .Data )-1&&_gad < _deg +_ff .BytesPerLine {_bba [_dgd ]=_ff .Data [_gad ];
}else {_bba [_dgd ]=0x00;};_gad =_deg +_ff .BytesPerLine +_dea +_dgd ;if _gad <=len (_ff .Data )-1&&_gad < _deg +(2*_ff .BytesPerLine ){_bdba [_dgd ]=_ff .Data [_gad ];}else {_bdba [_dgd ]=0x00;};};_ebe =_f .BigEndian .Uint32 (_bba );_fcef =_f .BigEndian .Uint32 (_bdba );
_bcc =_ebe &_fcef ;_bcc |=_bcc <<1;_cbfa =_ebe |_fcef ;_cbfa &=_cbfa <<1;_fcef =_bcc &_cbfa ;_fcef &=0xaaaaaaaa;_ebe =_fcef |(_fcef <<7);_aff =byte (_ebe >>24);_cec =byte ((_ebe >>8)&0xff);_gad =_ffc +_dga ;if _gad +1==len (_ggb .Data )-1||_gad +1>=_ffc +_ggb .BytesPerLine {if _aega =_ggb .setByte (_gad ,_eebc [_aff ]);
_aega !=nil {return _e .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gad );};}else {_cca =(uint16 (_eebc [_aff ])<<8)|uint16 (_eebc [_cec ]);if _aega =_ggb .setTwoBytes (_gad ,_cca );_aega !=nil {return _e .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gad );
};_dga ++;};};};return nil ;};func _ffagf (_faf _a .Image ,_efea Image ,_ccde _a .Rectangle ){if _aacdc ,_egfb :=_faf .(SMasker );_egfb &&_aacdc .HasAlpha (){_efea .(SMasker ).MakeAlpha ();};switch _facd :=_faf .(type ){case Gray :_bfab (_facd ,_efea .(NRGBA ),_ccde );
case NRGBA :_bbafc (_facd ,_efea .(NRGBA ),_ccde );case *_a .NYCbCrA :_cgcc (_facd ,_efea .(NRGBA ),_ccde );case CMYK :_edf (_facd ,_efea .(NRGBA ),_ccde );case RGBA :_fdaff (_facd ,_efea .(NRGBA ),_ccde );case nrgba64 :_ddgaa (_facd ,_efea .(NRGBA ),_ccde );
default:_cff (_faf ,_efea ,_ccde );};};func (_acbf *ImageBase )setEightPartlyBytes (_feea ,_facf int ,_bbfg uint64 )(_fgbf error ){var (_feac byte ;_gfea int ;);for _fdc :=1;_fdc <=_facf ;_fdc ++{_gfea =64-_fdc *8;_feac =byte (_bbfg >>uint (_gfea )&0xff);
if _fgbf =_acbf .setByte (_feea +_fdc -1,_feac );_fgbf !=nil {return _fgbf ;};};_bafe :=_acbf .BytesPerLine *8-_acbf .Width ;if _bafe ==0{return nil ;};_gfea -=8;_feac =byte (_bbfg >>uint (_gfea )&0xff)<<uint (_bafe );if _fgbf =_acbf .setByte (_feea +_facf ,_feac );
_fgbf !=nil {return _fgbf ;};return nil ;};type CMYK interface{CMYKAt (_ecga ,_dgc int )_ce .CMYK ;SetCMYK (_ceg ,_ebde int ,_bfg _ce .CMYK );};func _ccbf (_cbdf int ,_deaf int )int {if _cbdf < _deaf {return _cbdf ;};return _deaf ;};var _ Image =&Gray2 {};
func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _ffcb (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_bcaa *NRGBA16 )Base ()*ImageBase {return &_bcaa .ImageBase };func (_bfdc *Monochrome )Set (x ,y int ,c _ce .Color ){_aecc :=y *_bfdc .BytesPerLine +x >>3;
if _aecc > len (_bfdc .Data )-1{return ;};_bbdd :=_bfdc .ColorModel ().Convert (c ).(_ce .Gray );_bfdc .setGray (x ,_bbdd ,_aecc );};func _bbafc (_gfdg ,_degf NRGBA ,_bebda _a .Rectangle ){for _feba :=0;_feba < _bebda .Max .X ;_feba ++{for _dfff :=0;_dfff < _bebda .Max .Y ;
_dfff ++{_degf .SetNRGBA (_feba ,_dfff ,_gfdg .NRGBAAt (_feba ,_dfff ));};};};func _cff (_bggd _a .Image ,_aad Image ,_dgcb _a .Rectangle ){for _dee :=0;_dee < _dgcb .Max .X ;_dee ++{for _fba :=0;_fba < _dgcb .Max .Y ;_fba ++{_eac :=_bggd .At (_dee ,_fba );
_aad .Set (_dee ,_fba ,_eac );};};};func _gdac (_ccdbf *_a .NYCbCrA ,_edd RGBA ,_bbgb _a .Rectangle ){for _ebee :=0;_ebee < _bbgb .Max .X ;_ebee ++{for _aaee :=0;_aaee < _bbgb .Max .Y ;_aaee ++{_gcge :=_ccdbf .NYCbCrAAt (_ebee ,_aaee );_edd .SetRGBA (_ebee ,_aaee ,_bbdg (_gcge ));
};};};func (_cffc *Gray16 )Validate ()error {if len (_cffc .Data )!=_cffc .Height *_cffc .BytesPerLine {return ErrInvalidImage ;};return nil ;};var _ Image =&NRGBA32 {};func _cbgc (_cfb _a .Image )(Image ,error ){if _aab ,_gbeg :=_cfb .(*Gray4 );_gbeg {return _aab .Copy (),nil ;
};_fdgd :=_cfb .Bounds ();_fbec ,_ccgc :=NewImage (_fdgd .Max .X ,_fdgd .Max .Y ,4,1,nil ,nil ,nil );if _ccgc !=nil {return nil ,_ccgc ;};_efaa (_cfb ,_fbec ,_fdgd );return _fbec ,nil ;};func (_gedg *RGBA32 )Set (x ,y int ,c _ce .Color ){_dgea :=y *_gedg .Width +x ;
_dccfa :=3*_dgea ;if _dccfa +2>=len (_gedg .Data ){return ;};_gcfa :=_ce .RGBAModel .Convert (c ).(_ce .RGBA );_gedg .setRGBA (_dgea ,_gcfa );};func (_bae *Monochrome )getBit (_dgb ,_edeb int )uint8 {return _bae .Data [_dgb +(_edeb >>3)]>>uint (7-(_edeb &7))&1;
};func (_affb *CMYK32 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_affb .Width ,Y :_affb .Height }};};func (_agbb *Monochrome )IsUnpadded ()bool {return (_agbb .Width *_agbb .Height )==len (_agbb .Data )};func (_ccag *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_ccag .copy ()}};
func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;
case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_e .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_bdag *NRGBA64 )setNRGBA64 (_eggb int ,_caaa _ce .NRGBA64 ,_caec int ){_bdag .Data [_eggb ]=uint8 (_caaa .R >>8);_bdag .Data [_eggb +1]=uint8 (_caaa .R &0xff);_bdag .Data [_eggb +2]=uint8 (_caaa .G >>8);_bdag .Data [_eggb +3]=uint8 (_caaa .G &0xff);
_bdag .Data [_eggb +4]=uint8 (_caaa .B >>8);_bdag .Data [_eggb +5]=uint8 (_caaa .B &0xff);if _caec +1< len (_bdag .Alpha ){_bdag .Alpha [_caec ]=uint8 (_caaa .A >>8);_bdag .Alpha [_caec +1]=uint8 (_caaa .A &0xff);};};func (_egc *Monochrome )GrayAt (x ,y int )_ce .Gray {_efb ,_ :=ColorAtGray1BPC (x ,y ,_egc .BytesPerLine ,_egc .Data ,_egc .Decode );
return _efb ;};func _acg (_aafe _ce .RGBA )_ce .NRGBA {switch _aafe .A {case 0xff:return _ce .NRGBA {R :_aafe .R ,G :_aafe .G ,B :_aafe .B ,A :0xff};case 0x00:return _ce .NRGBA {};default:_ggda ,_adcf ,_adfg ,_cfc :=_aafe .RGBA ();_ggda =(_ggda *0xffff)/_cfc ;
_adcf =(_adcf *0xffff)/_cfc ;_adfg =(_adfg *0xffff)/_cfc ;return _ce .NRGBA {R :uint8 (_ggda >>8),G :uint8 (_adcf >>8),B :uint8 (_adfg >>8),A :uint8 (_cfc >>8)};};};func (_cea *Gray16 )GrayAt (x ,y int )_ce .Gray {_agcc ,_ :=_cea .ColorAt (x ,y );return _ce .Gray {Y :uint8 (_agcc .(_ce .Gray16 ).Y >>8)};
};var (_adc =_dcgc ();_ab =_bac ();_abe =_bfb (););func init (){_geff ()};func (_dceae *Gray16 )Set (x ,y int ,c _ce .Color ){_eged :=(y *_dceae .BytesPerLine /2+x )*2;if _eged +1>=len (_dceae .Data ){return ;};_bffg :=_ce .Gray16Model .Convert (c ).(_ce .Gray16 );
_dceae .Data [_eged ],_dceae .Data [_eged +1]=uint8 (_bffg .Y >>8),uint8 (_bffg .Y &0xff);};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_fggd :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_fggd .Data =make ([]byte ,height *_fggd .BytesPerLine );};return _fggd ;};func (_gddbf *RGBA32 )SetRGBA (x ,y int ,c _ce .RGBA ){_dagd :=y *_gddbf .Width +x ;_fagc :=3*_dagd ;if _fagc +2>=len (_gddbf .Data ){return ;};_gddbf .setRGBA (_dagd ,c );
};func (_bfag *ImageBase )setFourBytes (_ccgf int ,_dffg uint32 )error {if _ccgf +3> len (_bfag .Data )-1{return _e .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_ccgf );
};_bfag .Data [_ccgf ]=byte ((_dffg &0xff000000)>>24);_bfag .Data [_ccgf +1]=byte ((_dffg &0xff0000)>>16);_bfag .Data [_ccgf +2]=byte ((_dffg &0xff00)>>8);_bfag .Data [_ccgf +3]=byte (_dffg &0xff);return nil ;};func _afde (_ccd _ce .NRGBA )_ce .RGBA {_abed ,_fcgd ,_ggbg ,_agfd :=_ccd .RGBA ();
return _ce .RGBA {R :uint8 (_abed >>8),G :uint8 (_fcgd >>8),B :uint8 (_ggbg >>8),A :uint8 (_agfd >>8)};};func _eeef (_dgcdf CMYK ,_ebba Gray ,_aggc _a .Rectangle ){for _afdef :=0;_afdef < _aggc .Max .X ;_afdef ++{for _gegg :=0;_gegg < _aggc .Max .Y ;_gegg ++{_cba :=_cbb (_dgcdf .CMYKAt (_afdef ,_gegg ));
_ebba .SetGray (_afdef ,_gegg ,_cba );};};};func (_beed *NRGBA16 )At (x ,y int )_ce .Color {_eecc ,_ :=_beed .ColorAt (x ,y );return _eecc };func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ce .Gray ,error ){_baef :=y *bytesPerLine +x >>2;
if _baef >=len (data ){return _ce .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ecad :=data [_baef ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_ecad =uint8 (uint32 (LinearInterpolate (float64 (_ecad ),0,3.0,decode [0],decode [1]))&3);};return _ce .Gray {Y :_ecad *85},nil ;};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;
};return 1<<(_agdd (n )+1);};var _ NRGBA =&NRGBA32 {};type Gray interface{GrayAt (_fad ,_eabd int )_ce .Gray ;SetGray (_dgf ,_ebf int ,_acfg _ce .Gray );};func (_gcce monochromeModel )Convert (c _ce .Color )_ce .Color {_fadc :=_ce .GrayModel .Convert (c ).(_ce .Gray );
return _adeg (_fadc ,_gcce );};func _efa (_bbd ,_eca *Monochrome ,_edb []byte ,_bdg int )(_bff error ){var (_fa ,_ggg ,_dab ,_egd ,_eec ,_beb ,_ecg ,_ede int ;_bdfg ,_aaad ,_ccg ,_dcd uint32 ;_ggf ,_ecf byte ;_dcdd uint16 ;);_ddga :=make ([]byte ,4);_abb :=make ([]byte ,4);
for _dab =0;_dab < _bbd .Height -1;_dab ,_egd =_dab +2,_egd +1{_fa =_dab *_bbd .BytesPerLine ;_ggg =_egd *_eca .BytesPerLine ;for _eec ,_beb =0,0;_eec < _bdg ;_eec ,_beb =_eec +4,_beb +1{for _ecg =0;_ecg < 4;_ecg ++{_ede =_fa +_eec +_ecg ;if _ede <=len (_bbd .Data )-1&&_ede < _fa +_bbd .BytesPerLine {_ddga [_ecg ]=_bbd .Data [_ede ];
}else {_ddga [_ecg ]=0x00;};_ede =_fa +_bbd .BytesPerLine +_eec +_ecg ;if _ede <=len (_bbd .Data )-1&&_ede < _fa +(2*_bbd .BytesPerLine ){_abb [_ecg ]=_bbd .Data [_ede ];}else {_abb [_ecg ]=0x00;};};_bdfg =_f .BigEndian .Uint32 (_ddga );_aaad =_f .BigEndian .Uint32 (_abb );
_ccg =_bdfg &_aaad ;_ccg |=_ccg <<1;_dcd =_bdfg |_aaad ;_dcd &=_dcd <<1;_aaad =_ccg |_dcd ;_aaad &=0xaaaaaaaa;_bdfg =_aaad |(_aaad <<7);_ggf =byte (_bdfg >>24);_ecf =byte ((_bdfg >>8)&0xff);_ede =_ggg +_beb ;if _ede +1==len (_eca .Data )-1||_ede +1>=_ggg +_eca .BytesPerLine {if _bff =_eca .setByte (_ede ,_edb [_ggf ]);
_bff !=nil {return _e .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ede );};}else {_dcdd =(uint16 (_edb [_ggf ])<<8)|uint16 (_edb [_ecf ]);if _bff =_eca .setTwoBytes (_ede ,_dcdd );_bff !=nil {return _e .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ede );
};_beb ++;};};};return nil ;};var _ Gray =&Gray4 {};func (_aagg *NRGBA32 )ColorAt (x ,y int )(_ce .Color ,error ){return ColorAtNRGBA32 (x ,y ,_aagg .Width ,_aagg .Data ,_aagg .Alpha ,_aagg .Decode );};func (_ecbf *Gray2 )Set (x ,y int ,c _ce .Color ){if x >=_ecbf .Width ||y >=_ecbf .Height {return ;
};_fegbe :=Gray2Model .Convert (c ).(_ce .Gray );_efgc :=y *_ecbf .BytesPerLine ;_fca :=_efgc +(x >>2);_fadca :=_fegbe .Y >>6;_ecbf .Data [_fca ]=(_ecbf .Data [_fca ]&(^(0xc0>>uint (2*((x )&3)))))|(_fadca <<uint (6-2*(x &3)));};func (_bdeb *Gray4 )ColorAt (x ,y int )(_ce .Color ,error ){return ColorAtGray4BPC (x ,y ,_bdeb .BytesPerLine ,_bdeb .Data ,_bdeb .Decode );
};func (_dffc *CMYK32 )SetCMYK (x ,y int ,c _ce .CMYK ){_dfc :=4*(y *_dffc .Width +x );if _dfc +3>=len (_dffc .Data ){return ;};_dffc .Data [_dfc ]=c .C ;_dffc .Data [_dfc +1]=c .M ;_dffc .Data [_dfc +2]=c .Y ;_dffc .Data [_dfc +3]=c .K ;};func _bbdg (_caae _ce .NYCbCrA )_ce .RGBA {_gacad ,_cag ,_gcdd ,_eeeg :=_gebc (_caae ).RGBA ();
return _ce .RGBA {R :uint8 (_gacad >>8),G :uint8 (_cag >>8),B :uint8 (_gcdd >>8),A :uint8 (_eeeg >>8)};};func (_dged *Gray4 )SetGray (x ,y int ,g _ce .Gray ){if x >=_dged .Width ||y >=_dged .Height {return ;};g =_abcf (g );_dged .setGray (x ,y ,g );};func (_eabb *Monochrome )AddPadding ()(_febd error ){if _eefc :=((_eabb .Width *_eabb .Height )+7)>>3;
len (_eabb .Data )< _eefc {return _e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_eabb .Data ),_eefc );
};_cda :=_eabb .Width %8;if _cda ==0{return nil ;};_dcddg :=_eabb .Width /8;_bdcb :=_g .NewReader (_eabb .Data );_bee :=make ([]byte ,_eabb .Height *_eabb .BytesPerLine );_gedf :=_g .NewWriterMSB (_bee );_afdd :=make ([]byte ,_dcddg );var (_cgc int ;_acgg uint64 ;
);for _cgc =0;_cgc < _eabb .Height ;_cgc ++{if _ ,_febd =_bdcb .Read (_afdd );_febd !=nil {return _febd ;};if _ ,_febd =_gedf .Write (_afdd );_febd !=nil {return _febd ;};if _acgg ,_febd =_bdcb .ReadBits (byte (_cda ));_febd !=nil {return _febd ;};if _febd =_gedf .WriteByte (byte (_acgg )<<uint (8-_cda ));
_febd !=nil {return _febd ;};};_eabb .Data =_gedf .Data ();return nil ;};func (_cbbc *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_fcc :=_agdd (uint (factor ));if !IsPowerOf2 (uint (factor )){_fcc ++;};_fdd :=make ([]int ,_fcc );for _fdg :=range _fdd {_fdd [_fdg ]=4;
};_cdac ,_egaa :=_fegb (_cbbc ,_fdd ...);if _egaa !=nil {return nil ,_egaa ;};return _cdac ,nil ;};func (_deaa *NRGBA16 )SetNRGBA (x ,y int ,c _ce .NRGBA ){_cggf :=y *_deaa .BytesPerLine +x *3/2;if _cggf +1>=len (_deaa .Data ){return ;};c =_ecgcg (c );
_deaa .setNRGBA (x ,y ,_cggf ,c );};var _ Gray =&Gray8 {};func (_fdgb *RGBA32 )ColorModel ()_ce .Model {return _ce .NRGBAModel };func ImgToBinary (i _a .Image ,threshold uint8 )*_a .Gray {switch _becf :=i .(type ){case *_a .Gray :if _cgda (_becf ){return _becf ;
};return _dcac (_becf ,threshold );case *_a .Gray16 :return _abdd (_becf ,threshold );default:return _cgad (_becf ,threshold );};};func (_gcb *Monochrome )At (x ,y int )_ce .Color {_faba ,_ :=_gcb .ColorAt (x ,y );return _faba };func ImgToGray (i _a .Image )*_a .Gray {if _bagff ,_bfbd :=i .(*_a .Gray );
_bfbd {return _bagff ;};_bbeag :=i .Bounds ();_bcff :=_a .NewGray (_bbeag );for _gcac :=0;_gcac < _bbeag .Max .X ;_gcac ++{for _dgfd :=0;_dgfd < _bbeag .Max .Y ;_dgfd ++{_daff :=i .At (_gcac ,_dgfd );_bcff .Set (_gcac ,_dgfd ,_daff );};};return _bcff ;
};func _eedcb (_fdcg CMYK ,_ccbba RGBA ,_dcbd _a .Rectangle ){for _edcb :=0;_edcb < _dcbd .Max .X ;_edcb ++{for _defa :=0;_defa < _dcbd .Max .Y ;_defa ++{_abdf :=_fdcg .CMYKAt (_edcb ,_defa );_ccbba .SetRGBA (_edcb ,_defa ,_bggg (_abdf ));};};};func _edada (_dege _a .Image )(Image ,error ){if _acdc ,_ebfg :=_dege .(*Monochrome );
_ebfg {return _acdc ,nil ;};_dce :=_dege .Bounds ();var _eed Gray ;switch _edef :=_dege .(type ){case Gray :_eed =_edef ;case NRGBA :_eed =&Gray8 {ImageBase :NewImageBase (_dce .Max .X ,_dce .Max .Y ,8,1,nil ,nil ,nil )};_bcfb (_eed ,_edef ,_dce );case nrgba64 :_eed =&Gray8 {ImageBase :NewImageBase (_dce .Max .X ,_dce .Max .Y ,8,1,nil ,nil ,nil )};
_ade (_eed ,_edef ,_dce );default:_agd ,_edg :=GrayConverter .Convert (_dege );if _edg !=nil {return nil ,_edg ;};_eed =_agd .(Gray );};_bbeb ,_fdbc :=NewImage (_dce .Max .X ,_dce .Max .Y ,1,1,nil ,nil ,nil );if _fdbc !=nil {return nil ,_fdbc ;};_ggdc :=_bbeb .(*Monochrome );
_gce :=AutoThresholdTriangle (GrayHistogram (_eed ));for _ded :=0;_ded < _dce .Max .X ;_ded ++{for _ecab :=0;_ecab < _dce .Max .Y ;_ecab ++{_adba :=_adeg (_eed .GrayAt (_ded ,_ecab ),monochromeModel (_gce ));_ggdc .SetGray (_ded ,_ecab ,_adba );};};return _bbeb ,nil ;
};func _gebc (_gcaa _ce .NYCbCrA )_ce .NRGBA {_ece :=int32 (_gcaa .Y )*0x10101;_dgaa :=int32 (_gcaa .Cb )-128;_ebc :=int32 (_gcaa .Cr )-128;_dfaf :=_ece +91881*_ebc ;if uint32 (_dfaf )&0xff000000==0{_dfaf >>=8;}else {_dfaf =^(_dfaf >>31)&0xffff;};_ggdg :=_ece -22554*_dgaa -46802*_ebc ;
if uint32 (_ggdg )&0xff000000==0{_ggdg >>=8;}else {_ggdg =^(_ggdg >>31)&0xffff;};_acf :=_ece +116130*_dgaa ;if uint32 (_acf )&0xff000000==0{_acf >>=8;}else {_acf =^(_acf >>31)&0xffff;};return _ce .NRGBA {R :uint8 (_dfaf >>8),G :uint8 (_ggdg >>8),B :uint8 (_acf >>8),A :_gcaa .A };
};func _ge (_gaf ,_eb *Monochrome )(_aeg error ){_afd :=_eb .BytesPerLine ;_dd :=_gaf .BytesPerLine ;var (_cb byte ;_cfd uint16 ;_gdd ,_gbb ,_dcg ,_gbee ,_ee int ;);for _dcg =0;_dcg < _eb .Height ;_dcg ++{_gdd =_dcg *_afd ;_gbb =2*_dcg *_dd ;for _gbee =0;
_gbee < _afd ;_gbee ++{_cb =_eb .Data [_gdd +_gbee ];_cfd =_adc [_cb ];_ee =_gbb +_gbee *2;if _gaf .BytesPerLine !=_eb .BytesPerLine *2&&(_gbee +1)*2> _gaf .BytesPerLine {_aeg =_gaf .setByte (_ee ,byte (_cfd >>8));}else {_aeg =_gaf .setTwoBytes (_ee ,_cfd );
};if _aeg !=nil {return _aeg ;};};for _gbee =0;_gbee < _dd ;_gbee ++{_ee =_gbb +_dd +_gbee ;_cb =_gaf .Data [_gbb +_gbee ];if _aeg =_gaf .setByte (_ee ,_cb );_aeg !=nil {return _aeg ;};};};return nil ;};func (_fdda *NRGBA64 )NRGBA64At (x ,y int )_ce .NRGBA64 {_geecd ,_ :=ColorAtNRGBA64 (x ,y ,_fdda .Width ,_fdda .Data ,_fdda .Alpha ,_fdda .Decode );
return _geecd ;};type NRGBA16 struct{ImageBase };func (_gaea *Gray2 )Validate ()error {if len (_gaea .Data )!=_gaea .Height *_gaea .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_gadb *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_gadb .ImageBase .copy (),ModelThreshold :_gadb .ModelThreshold };
};func (_gafa *Gray2 )Histogram ()(_dgca [256]int ){for _baee :=0;_baee < _gafa .Width ;_baee ++{for _gdcg :=0;_gdcg < _gafa .Height ;_gdcg ++{_dgca [_gafa .GrayAt (_baee ,_gdcg ).Y ]++;};};return _dgca ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};
func (_efbg *Monochrome )setBit (_fac ,_bgd int ){_efbg .Data [_fac +(_bgd >>3)]|=0x80>>uint (_bgd &7)};func _bagd (_gddd _ce .Color )_ce .Color {_egdg :=_ce .GrayModel .Convert (_gddd ).(_ce .Gray );return _abcf (_egdg );};var _ Image =&Monochrome {};
func (_geec *Gray8 )ColorModel ()_ce .Model {return _ce .GrayModel };func _ecgcg (_caba _ce .NRGBA )_ce .NRGBA {_caba .R =_caba .R >>4|(_caba .R >>4)<<4;_caba .G =_caba .G >>4|(_caba .G >>4)<<4;_caba .B =_caba .B >>4|(_caba .B >>4)<<4;return _caba ;};const (PixSrc RasterOperator =0xc;
PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;
PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;
PixMask =PixSrcAndDst ;);func (_eedb *Gray4 )Set (x ,y int ,c _ce .Color ){if x >=_eedb .Width ||y >=_eedb .Height {return ;};_cbeb :=Gray4Model .Convert (c ).(_ce .Gray );_eedb .setGray (x ,y ,_cbeb );};func _bac ()(_aafb [256]uint32 ){for _de :=0;_de < 256;
_de ++{if _de &0x01!=0{_aafb [_de ]|=0xf;};if _de &0x02!=0{_aafb [_de ]|=0xf0;};if _de &0x04!=0{_aafb [_de ]|=0xf00;};if _de &0x08!=0{_aafb [_de ]|=0xf000;};if _de &0x10!=0{_aafb [_de ]|=0xf0000;};if _de &0x20!=0{_aafb [_de ]|=0xf00000;};if _de &0x40!=0{_aafb [_de ]|=0xf000000;
};if _de &0x80!=0{_aafb [_de ]|=0xf0000000;};};return _aafb ;};func _cgfe (_abgg *Monochrome ,_eadgc ,_bbfb ,_fecc ,_abec int ,_gdad RasterOperator ,_dfca *Monochrome ,_fdfg ,_bbag int )error {var (_cbc bool ;_daca bool ;_edgg byte ;_afbf int ;_bbae int ;
_bacga int ;_cbgb int ;_adcc bool ;_fga int ;_dggdb int ;_bbbd int ;_gafd bool ;_fadcf byte ;_efafe int ;_cceb int ;_cgcg int ;_cfab byte ;_dded int ;_cfgd int ;_dcba uint ;_dbae uint ;_cbfag byte ;_cfgg shift ;_baddb bool ;_dcda bool ;_ebed ,_bcbf int ;
);if _fdfg &7!=0{_cfgd =8-(_fdfg &7);};if _eadgc &7!=0{_bbae =8-(_eadgc &7);};if _cfgd ==0&&_bbae ==0{_cbfag =_dadf [0];}else {if _bbae > _cfgd {_dcba =uint (_bbae -_cfgd );}else {_dcba =uint (8-(_cfgd -_bbae ));};_dbae =8-_dcba ;_cbfag =_dadf [_dcba ];
};if (_eadgc &7)!=0{_cbc =true ;_afbf =8-(_eadgc &7);_edgg =_dadf [_afbf ];_bacga =_abgg .BytesPerLine *_bbfb +(_eadgc >>3);_cbgb =_dfca .BytesPerLine *_bbag +(_fdfg >>3);_dded =8-(_fdfg &7);if _afbf > _dded {_cfgg =_aggf ;if _fecc >=_cfgd {_baddb =true ;
};}else {_cfgg =_faec ;};};if _fecc < _afbf {_daca =true ;_edgg &=_cgcb [8-_afbf +_fecc ];};if !_daca {_fga =(_fecc -_afbf )>>3;if _fga !=0{_adcc =true ;_dggdb =_abgg .BytesPerLine *_bbfb +((_eadgc +_bbae )>>3);_bbbd =_dfca .BytesPerLine *_bbag +((_fdfg +_bbae )>>3);
};};_efafe =(_eadgc +_fecc )&7;if !(_daca ||_efafe ==0){_gafd =true ;_fadcf =_cgcb [_efafe ];_cceb =_abgg .BytesPerLine *_bbfb +((_eadgc +_bbae )>>3)+_fga ;_cgcg =_dfca .BytesPerLine *_bbag +((_fdfg +_bbae )>>3)+_fga ;if _efafe > int (_dbae ){_dcda =true ;
};};switch _gdad {case PixSrc :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );};}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],_cfab ,_edgg );
_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );_abgg .Data [_dggdb +_bcbf ]=_cfab ;
};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};if _gafd {for _ebed =0;_ebed < _abec ;_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],_cfab ,_fadcf );
_cceb +=_abgg .BytesPerLine ;_cgcg +=_dfca .BytesPerLine ;};};case PixNotSrc :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );};
}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],^_cfab ,_edgg );_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );
_abgg .Data [_dggdb +_bcbf ]=^_cfab ;};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};if _gafd {for _ebed =0;_ebed < _abec ;_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );
};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],^_cfab ,_fadcf );_cceb +=_abgg .BytesPerLine ;_cgcg +=_dfca .BytesPerLine ;};};case PixSrcOrDst :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );
};}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],_cfab |_abgg .Data [_bacga ],_edgg );_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;
_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );_abgg .Data [_dggdb +_bcbf ]|=_cfab ;};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};if _gafd {for _ebed =0;_ebed < _abec ;
_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],_cfab |_abgg .Data [_cceb ],_fadcf );_cceb +=_abgg .BytesPerLine ;_cgcg +=_dfca .BytesPerLine ;
};};case PixSrcAndDst :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );};}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],_cfab &_abgg .Data [_bacga ],_edgg );
_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );_abgg .Data [_dggdb +_bcbf ]&=_cfab ;
};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};if _gafd {for _ebed =0;_ebed < _abec ;_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],_cfab &_abgg .Data [_cceb ],_fadcf );
_cceb +=_abgg .BytesPerLine ;_cgcg +=_dfca .BytesPerLine ;};};case PixSrcXorDst :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );
};}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],_cfab ^_abgg .Data [_bacga ],_edgg );_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;
_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );_abgg .Data [_dggdb +_bcbf ]^=_cfab ;};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};if _gafd {for _ebed =0;_ebed < _abec ;
_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],_cfab ^_abgg .Data [_cceb ],_fadcf );_cceb +=_abgg .BytesPerLine ;_cgcg +=_dfca .BytesPerLine ;
};};case PixNotSrcOrDst :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );};}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],^_cfab |_abgg .Data [_bacga ],_edgg );
_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );_abgg .Data [_dggdb +_bcbf ]|=^_cfab ;
};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};if _gafd {for _ebed =0;_ebed < _abec ;_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],^_cfab |_abgg .Data [_cceb ],_fadcf );
_cceb +=_abgg .BytesPerLine ;_cgcg +=_dfca .BytesPerLine ;};};case PixNotSrcAndDst :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );
};}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],^_cfab &_abgg .Data [_bacga ],_edgg );_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;
_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );_abgg .Data [_dggdb +_bcbf ]&=^_cfab ;};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};if _gafd {for _ebed =0;_ebed < _abec ;
_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],^_cfab &_abgg .Data [_cceb ],_fadcf );_cceb +=_abgg .BytesPerLine ;_cgcg +=_dfca .BytesPerLine ;
};};case PixSrcOrNotDst :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );};}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],_cfab |^_abgg .Data [_bacga ],_edgg );
_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );_abgg .Data [_dggdb +_bcbf ]=_cfab |^_abgg .Data [_dggdb +_bcbf ];
};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};if _gafd {for _ebed =0;_ebed < _abec ;_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],_cfab |^_abgg .Data [_cceb ],_fadcf );
_cceb +=_abgg .BytesPerLine ;_cgcg +=_dfca .BytesPerLine ;};};case PixSrcAndNotDst :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );
};}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],_cfab &^_abgg .Data [_bacga ],_edgg );_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;
_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );_abgg .Data [_dggdb +_bcbf ]=_cfab &^_abgg .Data [_dggdb +_bcbf ];};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};if _gafd {for _ebed =0;
_ebed < _abec ;_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],_cfab &^_abgg .Data [_cceb ],_fadcf );_cceb +=_abgg .BytesPerLine ;_cgcg +=_dfca .BytesPerLine ;
};};case PixNotPixSrcOrDst :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );};}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],^(_cfab |_abgg .Data [_bacga ]),_edgg );
_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );_abgg .Data [_dggdb +_bcbf ]=^(_cfab |_abgg .Data [_dggdb +_bcbf ]);
};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};if _gafd {for _ebed =0;_ebed < _abec ;_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],^(_cfab |_abgg .Data [_cceb ]),_fadcf );
_cceb +=_abgg .BytesPerLine ;_cgcg +=_dfca .BytesPerLine ;};};case PixNotPixSrcAndDst :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );
};}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],^(_cfab &_abgg .Data [_bacga ]),_edgg );_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;
_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );_abgg .Data [_dggdb +_bcbf ]=^(_cfab &_abgg .Data [_dggdb +_bcbf ]);};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};
if _gafd {for _ebed =0;_ebed < _abec ;_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],^(_cfab &_abgg .Data [_cceb ]),_fadcf );_cceb +=_abgg .BytesPerLine ;
_cgcg +=_dfca .BytesPerLine ;};};case PixNotPixSrcXorDst :if _cbc {for _ebed =0;_ebed < _abec ;_ebed ++{if _cfgg ==_aggf {_cfab =_dfca .Data [_cbgb ]<<_dcba ;if _baddb {_cfab =_ddeb (_cfab ,_dfca .Data [_cbgb +1]>>_dbae ,_cbfag );};}else {_cfab =_dfca .Data [_cbgb ]>>_dbae ;
};_abgg .Data [_bacga ]=_ddeb (_abgg .Data [_bacga ],^(_cfab ^_abgg .Data [_bacga ]),_edgg );_bacga +=_abgg .BytesPerLine ;_cbgb +=_dfca .BytesPerLine ;};};if _adcc {for _ebed =0;_ebed < _abec ;_ebed ++{for _bcbf =0;_bcbf < _fga ;_bcbf ++{_cfab =_ddeb (_dfca .Data [_bbbd +_bcbf ]<<_dcba ,_dfca .Data [_bbbd +_bcbf +1]>>_dbae ,_cbfag );
_abgg .Data [_dggdb +_bcbf ]=^(_cfab ^_abgg .Data [_dggdb +_bcbf ]);};_dggdb +=_abgg .BytesPerLine ;_bbbd +=_dfca .BytesPerLine ;};};if _gafd {for _ebed =0;_ebed < _abec ;_ebed ++{_cfab =_dfca .Data [_cgcg ]<<_dcba ;if _dcda {_cfab =_ddeb (_cfab ,_dfca .Data [_cgcg +1]>>_dbae ,_cbfag );
};_abgg .Data [_cceb ]=_ddeb (_abgg .Data [_cceb ],^(_cfab ^_abgg .Data [_cceb ]),_fadcf );_cceb +=_abgg .BytesPerLine ;_cgcg +=_dfca .BytesPerLine ;};};default:_b .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_gdad );
return _d .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _egff (_cbeg NRGBA ,_cdcc RGBA ,_affbb _a .Rectangle ){for _fgdg :=0;
_fgdg < _affbb .Max .X ;_fgdg ++{for _gcbg :=0;_gcbg < _affbb .Max .Y ;_gcbg ++{_gfac :=_cbeg .NRGBAAt (_fgdg ,_gcbg );_cdcc .SetRGBA (_fgdg ,_gcbg ,_afde (_gfac ));};};};var _ Image =&Gray16 {};func (_fae *CMYK32 )Base ()*ImageBase {return &_fae .ImageBase };
func _cgda (_eefd *_a .Gray )bool {for _fdgea :=0;_fdgea < len (_eefd .Pix );_fdgea ++{if !_efff (_eefd .Pix [_fdgea ]){return false ;};};return true ;};func (_aegb *ImageBase )getByte (_egda int )(byte ,error ){if _egda > len (_aegb .Data )-1||_egda < 0{return 0,_e .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_egda );
};return _aegb .Data [_egda ],nil ;};func (_agcg *ImageBase )copy ()ImageBase {_eedc :=*_agcg ;_eedc .Data =make ([]byte ,len (_agcg .Data ));copy (_eedc .Data ,_agcg .Data );return _eedc ;};func (_bcgg *monochromeThresholdConverter )Convert (img _a .Image )(Image ,error ){if _gdb ,_adef :=img .(*Monochrome );
_adef {return _gdb .Copy (),nil ;};_beab :=img .Bounds ();_acbd ,_fcb :=NewImage (_beab .Max .X ,_beab .Max .Y ,1,1,nil ,nil ,nil );if _fcb !=nil {return nil ,_fcb ;};_acbd .(*Monochrome ).ModelThreshold =_bcgg .Threshold ;for _dad :=0;_dad < _beab .Max .X ;
_dad ++{for _cfgf :=0;_cfgf < _beab .Max .Y ;_cfgf ++{_ega :=img .At (_dad ,_cfgf );_acbd .Set (_dad ,_cfgf ,_ega );};};return _acbd ,nil ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_ce .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_e .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func _bcg (_cdb _ce .NRGBA64 )_ce .NRGBA {return _ce .NRGBA {R :uint8 (_cdb .R >>8),G :uint8 (_cdb .G >>8),B :uint8 (_cdb .B >>8),A :uint8 (_cdb .A >>8)};};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_ce .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_e .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};var _ Image =&Gray4 {};func (_aeac *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_aeac .copy ()}};func (_aaaf *NRGBA16 )Set (x ,y int ,c _ce .Color ){_aeaf :=y *_aaaf .BytesPerLine +x *3/2;if _aeaf +1>=len (_aaaf .Data ){return ;};_gaeb :=NRGBA16Model .Convert (c ).(_ce .NRGBA );
_aaaf .setNRGBA (x ,y ,_aeaf ,_gaeb );};func _efff (_fbff uint8 )bool {if _fbff ==0||_fbff ==255{return true ;};return false ;};func (_edc *Gray4 )setGray (_ccec int ,_aadf int ,_dbf _ce .Gray ){_cfac :=_aadf *_edc .BytesPerLine ;_bdbb :=_cfac +(_ccec >>1);
if _bdbb >=len (_edc .Data ){return ;};_baf :=_dbf .Y >>4;_edc .Data [_bdbb ]=(_edc .Data [_bdbb ]&(^(0xf0>>uint (4*(_ccec &1)))))|(_baf <<uint (4-4*(_ccec &1)));};func (_fef *Gray4 )Base ()*ImageBase {return &_fef .ImageBase };func (_dfad *RGBA32 )Base ()*ImageBase {return &_dfad .ImageBase };
func _gf (_ddd *Monochrome ,_cab ,_dfg int )(*Monochrome ,error ){if _ddd ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _cab <=0||_dfg <=0{return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _cab ==_dfg {if _cab ==1{return _ddd .copy (),nil ;};if _cab ==2||_cab ==4||_cab ==8{_bf ,_ebg :=_dc (_ddd ,_cab );if _ebg !=nil {return nil ,_ebg ;};return _bf ,nil ;};};_ead :=_cab *_ddd .Width ;_fcf :=_dfg *_ddd .Height ;_bb :=_bbe (_ead ,_fcf );
_gbba :=_bb .BytesPerLine ;var (_ad ,_cd ,_dbd ,_cga ,_bd int ;_ddb byte ;_feg error ;);for _cd =0;_cd < _ddd .Height ;_cd ++{_ad =_dfg *_cd *_gbba ;for _dbd =0;_dbd < _ddd .Width ;_dbd ++{if _fcfa :=_ddd .getBitAt (_dbd ,_cd );_fcfa {_bd =_cab *_dbd ;
for _cga =0;_cga < _cab ;_cga ++{_bb .setIndexedBit (_ad *8+_bd +_cga );};};};for _cga =1;_cga < _dfg ;_cga ++{_ebb :=_ad +_cga *_gbba ;for _dca :=0;_dca < _gbba ;_dca ++{if _ddb ,_feg =_bb .getByte (_ad +_dca );_feg !=nil {return nil ,_feg ;};if _feg =_bb .setByte (_ebb +_dca ,_ddb );
_feg !=nil {return nil ,_feg ;};};};};return _bb ,nil ;};var _ _a .Image =&Gray4 {};func (_aecfb *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_aecfb .copy ()}};func (_gefg *Gray16 )SetGray (x ,y int ,g _ce .Gray ){_fabc :=(y *_gefg .BytesPerLine /2+x )*2;
if _fabc +1>=len (_gefg .Data ){return ;};_gefg .Data [_fabc ]=g .Y ;_gefg .Data [_fabc +1]=g .Y ;};func (_deedg *Gray4 )ColorModel ()_ce .Model {return Gray4Model };func _gfddg (_cccb _a .Image ,_gegfa Image ,_cecc _a .Rectangle ){if _gagg ,_bdbdb :=_cccb .(SMasker );
_bdbdb &&_gagg .HasAlpha (){_gegfa .(SMasker ).MakeAlpha ();};_cff (_cccb ,_gegfa ,_cecc );};func _ebdf (_dffd RGBA ,_bbf CMYK ,_gba _a .Rectangle ){for _ffd :=0;_ffd < _gba .Max .X ;_ffd ++{for _fbd :=0;_fbd < _gba .Max .Y ;_fbd ++{_ffa :=_dffd .RGBAAt (_ffd ,_fbd );
_bbf .SetCMYK (_ffd ,_fbd ,_fdafa (_ffa ));};};};func (_fbdec *Gray8 )Base ()*ImageBase {return &_fbdec .ImageBase };type RasterOperator int ;func _ddeb (_gfgd ,_fdfa ,_dccf byte )byte {return (_gfgd &^(_dccf ))|(_fdfa &_dccf )};func _gedcf (_dfeg Gray ,_fbce RGBA ,_egdd _a .Rectangle ){for _bfgf :=0;
_bfgf < _egdd .Max .X ;_bfgf ++{for _baea :=0;_baea < _egdd .Max .Y ;_baea ++{_dadcd :=_dfeg .GrayAt (_bfgf ,_baea );_fbce .SetRGBA (_bfgf ,_baea ,_egdf (_dadcd ));};};};func _bggg (_adbb _ce .CMYK )_ce .RGBA {_eeed ,_dafb ,_cgf :=_ce .CMYKToRGB (_adbb .C ,_adbb .M ,_adbb .Y ,_adbb .K );
return _ce .RGBA {R :_eeed ,G :_dafb ,B :_cgf ,A :0xff};};func _efae (_fdaf _ce .Gray )_ce .NRGBA {return _ce .NRGBA {R :_fdaf .Y ,G :_fdaf .Y ,B :_fdaf .Y ,A :0xff}};var _ _a .Image =&Monochrome {};func (_gdcf *Gray8 )ColorAt (x ,y int )(_ce .Color ,error ){return ColorAtGray8BPC (x ,y ,_gdcf .BytesPerLine ,_gdcf .Data ,_gdcf .Decode );
};func (_facfa *NRGBA32 )NRGBAAt (x ,y int )_ce .NRGBA {_bbcea ,_ :=ColorAtNRGBA32 (x ,y ,_facfa .Width ,_facfa .Data ,_facfa .Alpha ,_facfa .Decode );return _bbcea ;};func _fee ()(_afc []byte ){_afc =make ([]byte ,256);for _bdc :=0;_bdc < 256;_bdc ++{_eaf :=byte (_bdc );
_afc [_eaf ]=(_eaf &0x01)|((_eaf &0x04)>>1)|((_eaf &0x10)>>2)|((_eaf &0x40)>>3)|((_eaf &0x02)<<3)|((_eaf &0x08)<<2)|((_eaf &0x20)<<1)|(_eaf &0x80);};return _afc ;};func (_ggcg *Gray2 )ColorModel ()_ce .Model {return Gray2Model };func _edf (_acgfg CMYK ,_aeeg NRGBA ,_bgba _a .Rectangle ){for _dcagc :=0;
_dcagc < _bgba .Max .X ;_dcagc ++{for _bbfcd :=0;_bbfcd < _bgba .Max .Y ;_bbfcd ++{_ggce :=_acgfg .CMYKAt (_dcagc ,_bbfcd );_aeeg .SetNRGBA (_dcagc ,_bbfcd ,_agbe (_ggce ));};};};func (_ccadf *RGBA32 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_ccadf .Width ,Y :_ccadf .Height }};
};func _eaccg (_dgba NRGBA ,_gebf Gray ,_cddc _a .Rectangle ){for _ebdb :=0;_ebdb < _cddc .Max .X ;_ebdb ++{for _cfag :=0;_cfag < _cddc .Max .Y ;_cfag ++{_aed :=_dfcg (_dgba .NRGBAAt (_ebdb ,_cfag ));_gebf .SetGray (_ebdb ,_cfag ,_aed );};};};func (_dddaf *Monochrome )ResolveDecode ()error {if len (_dddaf .Decode )!=2{return nil ;
};if _dddaf .Decode [0]==1&&_dddaf .Decode [1]==0{if _bfc :=_dddaf .InverseData ();_bfc !=nil {return _bfc ;};_dddaf .Decode =nil ;};return nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ce .Gray ,error ){_ddgd :=y *bytesPerLine +x >>1;
if _ddgd >=len (data ){return _ce .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ffcg :=data [_ddgd ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_ffcg =uint8 (uint32 (LinearInterpolate (float64 (_ffcg ),0,15,decode [0],decode [1]))&0xf);};return _ce .Gray {Y :_ffcg *17&0xff},nil ;};func _adeg (_aca _ce .Gray ,_bed monochromeModel )_ce .Gray {if _aca .Y > uint8 (_bed ){return _ce .Gray {Y :_cf .MaxUint8 };
};return _ce .Gray {};};func _efg (_fe *Monochrome ,_fb int ,_bg []uint )(*Monochrome ,error ){_gb :=_fb *_fe .Width ;_ae :=_fb *_fe .Height ;_ec :=_bbe (_gb ,_ae );for _gbe ,_ba :=range _bg {var _af error ;switch _ba {case 2:_af =_ge (_ec ,_fe );case 4:_af =_gac (_ec ,_fe );
case 8:_af =_age (_ec ,_fe );};if _af !=nil {return nil ,_af ;};if _gbe !=len (_bg )-1{_fe =_ec .copy ();};};return _ec ,nil ;};func (_gacb *NRGBA16 )ColorModel ()_ce .Model {return NRGBA16Model };func _ffcb (_gadc *Monochrome ,_bgc ,_dfgce ,_cee ,_feec int ,_dae RasterOperator ,_ddgf *Monochrome ,_badg ,_bcga int )error {if _gadc ==nil {return _d .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _dae ==PixDst {return nil ;};switch _dae {case PixClr ,PixSet ,PixNotDst :_gcf (_gadc ,_bgc ,_dfgce ,_cee ,_feec ,_dae );return nil ;};if _ddgf ==nil {_b .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _d .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _afdda :=_gdab (_gadc ,_bgc ,_dfgce ,_cee ,_feec ,_dae ,_ddgf ,_badg ,_bcga );_afdda !=nil {return _afdda ;};return nil ;};func _egdf (_bfbb _ce .Gray )_ce .RGBA {return _ce .RGBA {R :_bfbb .Y ,G :_bfbb .Y ,B :_bfbb .Y ,A :0xff}};
func _cgad (_fffe _a .Image ,_fbfe uint8 )*_a .Gray {_caaf :=_fffe .Bounds ();_gfeeg :=_a .NewGray (_caaf );var (_cdgd _ce .Color ;_gecd _ce .Gray ;);for _eagc :=0;_eagc < _caaf .Max .X ;_eagc ++{for _dfcf :=0;_dfcf < _caaf .Max .Y ;_dfcf ++{_cdgd =_fffe .At (_eagc ,_dfcf );
_gfeeg .Set (_eagc ,_dfcf ,_cdgd );_gecd =_gfeeg .GrayAt (_eagc ,_dfcf );_gfeeg .SetGray (_eagc ,_dfcf ,_ce .Gray {Y :_cbef (_gecd .Y ,_fbfe )});};};return _gfeeg ;};func _ade (_bce Gray ,_agef nrgba64 ,_aaed _a .Rectangle ){for _eafc :=0;_eafc < _aaed .Max .X ;
_eafc ++{for _gab :=0;_gab < _aaed .Max .Y ;_gab ++{_adgd :=_bbcb (_agef .NRGBA64At (_eafc ,_gab ));_bce .SetGray (_eafc ,_gab ,_adgd );};};};func _fbe (_dcab ,_ggd *Monochrome ,_cc []byte ,_efcc int )(_cdf error ){var (_fda ,_gec ,_bdb ,_ddg ,_ddf ,_bda ,_bfa ,_eda int ;
_bfe ,_aee uint32 ;_bfad ,_fdbb byte ;_gcd uint16 ;);_fdee :=make ([]byte ,4);_aaa :=make ([]byte ,4);for _bdb =0;_bdb < _dcab .Height -1;_bdb ,_ddg =_bdb +2,_ddg +1{_fda =_bdb *_dcab .BytesPerLine ;_gec =_ddg *_ggd .BytesPerLine ;for _ddf ,_bda =0,0;_ddf < _efcc ;
_ddf ,_bda =_ddf +4,_bda +1{for _bfa =0;_bfa < 4;_bfa ++{_eda =_fda +_ddf +_bfa ;if _eda <=len (_dcab .Data )-1&&_eda < _fda +_dcab .BytesPerLine {_fdee [_bfa ]=_dcab .Data [_eda ];}else {_fdee [_bfa ]=0x00;};_eda =_fda +_dcab .BytesPerLine +_ddf +_bfa ;
if _eda <=len (_dcab .Data )-1&&_eda < _fda +(2*_dcab .BytesPerLine ){_aaa [_bfa ]=_dcab .Data [_eda ];}else {_aaa [_bfa ]=0x00;};};_bfe =_f .BigEndian .Uint32 (_fdee );_aee =_f .BigEndian .Uint32 (_aaa );_aee |=_bfe ;_aee |=_aee <<1;_aee &=0xaaaaaaaa;
_bfe =_aee |(_aee <<7);_bfad =byte (_bfe >>24);_fdbb =byte ((_bfe >>8)&0xff);_eda =_gec +_bda ;if _eda +1==len (_ggd .Data )-1||_eda +1>=_gec +_ggd .BytesPerLine {_ggd .Data [_eda ]=_cc [_bfad ];}else {_gcd =(uint16 (_cc [_bfad ])<<8)|uint16 (_cc [_fdbb ]);
if _cdf =_ggd .setTwoBytes (_eda ,_gcd );_cdf !=nil {return _e .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_eda );
};_bda ++;};};};return nil ;};func (_bcb *Monochrome )setGrayBit (_abeb ,_dfe int ){_bcb .Data [_abeb ]|=0x80>>uint (_dfe &7)};func (_cce *Gray2 )SetGray (x ,y int ,gray _ce .Gray ){_abeg :=_fgg (gray );_fcec :=y *_cce .BytesPerLine ;_cac :=_fcec +(x >>2);
if _cac >=len (_cce .Data ){return ;};_dggb :=_abeg .Y >>6;_cce .Data [_cac ]=(_cce .Data [_cac ]&(^(0xc0>>uint (2*((x )&3)))))|(_dggb <<uint (6-2*(x &3)));};func (_ecgc *Gray16 )At (x ,y int )_ce .Color {_dgbg ,_ :=_ecgc .ColorAt (x ,y );return _dgbg };
func _fagg (_ebdc *Monochrome ,_ecbb ,_gfcf int ,_dcbc ,_cgaed int ,_adcd RasterOperator ){var (_baca bool ;_bbea bool ;_fgab int ;_ebgd int ;_dfef int ;_bacd int ;_egfee bool ;_cgef byte ;);_ffag :=8-(_ecbb &7);_gbf :=_dadf [_ffag ];_abece :=_ebdc .BytesPerLine *_gfcf +(_ecbb >>3);
if _dcbc < _ffag {_baca =true ;_gbf &=_cgcb [8-_ffag +_dcbc ];};if !_baca {_fgab =(_dcbc -_ffag )>>3;if _fgab !=0{_bbea =true ;_ebgd =_abece +1;};};_dfef =(_ecbb +_dcbc )&7;if !(_baca ||_dfef ==0){_egfee =true ;_cgef =_cgcb [_dfef ];_bacd =_abece +1+_fgab ;
};var _aga ,_aefb int ;switch _adcd {case PixClr :for _aga =0;_aga < _cgaed ;_aga ++{_ebdc .Data [_abece ]=_ddeb (_ebdc .Data [_abece ],0x0,_gbf );_abece +=_ebdc .BytesPerLine ;};if _bbea {for _aga =0;_aga < _cgaed ;_aga ++{for _aefb =0;_aefb < _fgab ;
_aefb ++{_ebdc .Data [_ebgd +_aefb ]=0x0;};_ebgd +=_ebdc .BytesPerLine ;};};if _egfee {for _aga =0;_aga < _cgaed ;_aga ++{_ebdc .Data [_bacd ]=_ddeb (_ebdc .Data [_bacd ],0x0,_cgef );_bacd +=_ebdc .BytesPerLine ;};};case PixSet :for _aga =0;_aga < _cgaed ;
_aga ++{_ebdc .Data [_abece ]=_ddeb (_ebdc .Data [_abece ],0xff,_gbf );_abece +=_ebdc .BytesPerLine ;};if _bbea {for _aga =0;_aga < _cgaed ;_aga ++{for _aefb =0;_aefb < _fgab ;_aefb ++{_ebdc .Data [_ebgd +_aefb ]=0xff;};_ebgd +=_ebdc .BytesPerLine ;};};
if _egfee {for _aga =0;_aga < _cgaed ;_aga ++{_ebdc .Data [_bacd ]=_ddeb (_ebdc .Data [_bacd ],0xff,_cgef );_bacd +=_ebdc .BytesPerLine ;};};case PixNotDst :for _aga =0;_aga < _cgaed ;_aga ++{_ebdc .Data [_abece ]=_ddeb (_ebdc .Data [_abece ],^_ebdc .Data [_abece ],_gbf );
_abece +=_ebdc .BytesPerLine ;};if _bbea {for _aga =0;_aga < _cgaed ;_aga ++{for _aefb =0;_aefb < _fgab ;_aefb ++{_ebdc .Data [_ebgd +_aefb ]=^(_ebdc .Data [_ebgd +_aefb ]);};_ebgd +=_ebdc .BytesPerLine ;};};if _egfee {for _aga =0;_aga < _cgaed ;_aga ++{_ebdc .Data [_bacd ]=_ddeb (_ebdc .Data [_bacd ],^_ebdc .Data [_bacd ],_cgef );
_bacd +=_ebdc .BytesPerLine ;};};};};func _gfee (_geeg _ce .Gray )_ce .CMYK {return _ce .CMYK {K :0xff-_geeg .Y }};func _baa (_gcea _a .Image )(Image ,error ){if _ecde ,_gdcgd :=_gcea .(*Gray2 );_gdcgd {return _ecde .Copy (),nil ;};_cdbf :=_gcea .Bounds ();
_egea ,_acgf :=NewImage (_cdbf .Max .X ,_cdbf .Max .Y ,2,1,nil ,nil ,nil );if _acgf !=nil {return nil ,_acgf ;};_efaa (_gcea ,_egea ,_cdbf );return _egea ,nil ;};func (_egde *NRGBA32 )Base ()*ImageBase {return &_egde .ImageBase };func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func _fgf (_gg *Monochrome ,_gae int ,_abg []byte )(_cfg *Monochrome ,_ada error ){const _cbe ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _gg ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _gae < 1||_gae > 4{return nil ,_d .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _gg .Height <=1{return nil ,_d .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_cfg =_bbe (_gg .Width /2,_gg .Height /2);if _abg ==nil {_abg =_fee ();};_cbed :=_ccbf (_gg .BytesPerLine ,2*_cfg .BytesPerLine );switch _gae {case 1:_ada =_fbe (_gg ,_cfg ,_abg ,_cbed );case 2:_ada =_efa (_gg ,_cfg ,_abg ,_cbed );case 3:_ada =_dbg (_gg ,_cfg ,_abg ,_cbed );
case 4:_ada =_dag (_gg ,_cfg ,_abg ,_cbed );};if _ada !=nil {return nil ,_ada ;};return _cfg ,nil ;};func _geff (){for _ebaa :=0;_ebaa < 256;_ebaa ++{_ddfa [_ebaa ]=uint8 (_ebaa &0x1)+(uint8 (_ebaa >>1)&0x1)+(uint8 (_ebaa >>2)&0x1)+(uint8 (_ebaa >>3)&0x1)+(uint8 (_ebaa >>4)&0x1)+(uint8 (_ebaa >>5)&0x1)+(uint8 (_ebaa >>6)&0x1)+(uint8 (_ebaa >>7)&0x1);
};};func _gac (_ed ,_fc *Monochrome )(_fg error ){_bge :=_fc .BytesPerLine ;_aeb :=_ed .BytesPerLine ;_feb :=_fc .BytesPerLine *4-_ed .BytesPerLine ;var (_aa ,_gag byte ;_fec uint32 ;_gee ,_be ,_ea ,_aaf ,_bad ,_dg ,_gbbb int ;);for _ea =0;_ea < _fc .Height ;
_ea ++{_gee =_ea *_bge ;_be =4*_ea *_aeb ;for _aaf =0;_aaf < _bge ;_aaf ++{_aa =_fc .Data [_gee +_aaf ];_fec =_ab [_aa ];_dg =_be +_aaf *4;if _feb !=0&&(_aaf +1)*4> _ed .BytesPerLine {for _bad =_feb ;_bad > 0;_bad --{_gag =byte ((_fec >>uint (_bad *8))&0xff);
_gbbb =_dg +(_feb -_bad );if _fg =_ed .setByte (_gbbb ,_gag );_fg !=nil {return _fg ;};};}else if _fg =_ed .setFourBytes (_dg ,_fec );_fg !=nil {return _fg ;};if _fg =_ed .setFourBytes (_be +_aaf *4,_ab [_fc .Data [_gee +_aaf ]]);_fg !=nil {return _fg ;
};};for _bad =1;_bad < 4;_bad ++{for _aaf =0;_aaf < _aeb ;_aaf ++{if _fg =_ed .setByte (_be +_bad *_aeb +_aaf ,_ed .Data [_be +_aaf ]);_fg !=nil {return _fg ;};};};};return nil ;};func _cfage (_aba RGBA ,_adee Gray ,_aegaa _a .Rectangle ){for _cef :=0;
_cef < _aegaa .Max .X ;_cef ++{for _ffgf :=0;_ffgf < _aegaa .Max .Y ;_ffgf ++{_ggga :=_cbea (_aba .RGBAAt (_cef ,_ffgf ));_adee .SetGray (_cef ,_ffgf ,_ggga );};};};var _ddfa [256]uint8 ;func _abdd (_feca *_a .Gray16 ,_egedb uint8 )*_a .Gray {_dedc :=_feca .Bounds ();
_gcbc :=_a .NewGray (_dedc );for _cdebc :=0;_cdebc < _dedc .Dx ();_cdebc ++{for _gefef :=0;_gefef < _dedc .Dy ();_gefef ++{_dccfb :=_feca .Gray16At (_cdebc ,_gefef );_gcbc .SetGray (_cdebc ,_gefef ,_ce .Gray {Y :_cbef (uint8 (_dccfb .Y /256),_egedb )});
};};return _gcbc ;};func (_gdde *Gray8 )Set (x ,y int ,c _ce .Color ){_cfef :=y *_gdde .BytesPerLine +x ;if _cfef > len (_gdde .Data )-1{return ;};_ebcf :=_ce .GrayModel .Convert (c );_gdde .Data [_cfef ]=_ebcf .(_ce .Gray ).Y ;};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_ce .RGBA ,error ){_ageg :=y *width +x ;
_caecb :=3*_ageg ;if _caecb +2>=len (data ){return _ce .RGBA {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fgbd :=uint8 (0xff);if alpha !=nil &&len (alpha )> _ageg {_fgbd =alpha [_ageg ];};_gade ,_bfaf ,_bfafa :=data [_caecb ],data [_caecb +1],data [_caecb +2];if len (decode )==6{_gade =uint8 (uint32 (LinearInterpolate (float64 (_gade ),0,255,decode [0],decode [1]))&0xff);
_bfaf =uint8 (uint32 (LinearInterpolate (float64 (_bfaf ),0,255,decode [2],decode [3]))&0xff);_bfafa =uint8 (uint32 (LinearInterpolate (float64 (_bfafa ),0,255,decode [4],decode [5]))&0xff);};return _ce .RGBA {R :_gade ,G :_bfaf ,B :_bfafa ,A :_fgbd },nil ;
};func (_dfcd *ImageBase )newAlpha (){_egdgc :=BytesPerLine (_dfcd .Width ,_dfcd .BitsPerComponent ,1);_dfcd .Alpha =make ([]byte ,_dfcd .Height *_egdgc );};type RGBA interface{RGBAAt (_acgfc ,_ecabb int )_ce .RGBA ;SetRGBA (_ccdg ,_fcba int ,_fecgc _ce .RGBA );
};var _ Gray =&Gray16 {};func (_dagg *NRGBA16 )NRGBAAt (x ,y int )_ce .NRGBA {_aedb ,_ :=ColorAtNRGBA16 (x ,y ,_dagg .Width ,_dagg .BytesPerLine ,_dagg .Data ,_dagg .Alpha ,_dagg .Decode );return _aedb ;};func _ddgaa (_degg nrgba64 ,_bbadd NRGBA ,_egce _a .Rectangle ){for _ebbf :=0;
_ebbf < _egce .Max .X ;_ebbf ++{for _fcde :=0;_fcde < _egce .Max .Y ;_fcde ++{_edab :=_degg .NRGBA64At (_ebbf ,_fcde );_bbadd .SetNRGBA (_ebbf ,_fcde ,_bcg (_edab ));};};};func (_bdfd *Monochrome )clearBit (_bde ,_dbc int ){_bdfd .Data [_bde ]&=^(0x80>>uint (_dbc &7))};
func (_gdbd *ImageBase )HasAlpha ()bool {if _gdbd .Alpha ==nil {return false ;};for _ddfe :=range _gdbd .Alpha {if _gdbd .Alpha [_ddfe ]!=0xff{return true ;};};return false ;};var _ RGBA =&RGBA32 {};func (_ccf *NRGBA16 )ColorAt (x ,y int )(_ce .Color ,error ){return ColorAtNRGBA16 (x ,y ,_ccf .Width ,_ccf .BytesPerLine ,_ccf .Data ,_ccf .Alpha ,_ccf .Decode );
};func _agdd (_ecfb uint )uint {var _bga uint ;for _ecfb !=0{_ecfb >>=1;_bga ++;};return _bga -1;};func FromGoImage (i _a .Image )(Image ,error ){switch _ebbd :=i .(type ){case Image :return _ebbd .Copy (),nil ;case Gray :return GrayConverter .Convert (i );
case *_a .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_a .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func _cdge (_gdc _ce .NRGBA )_ce .CMYK {_ccad ,_ggaf ,_acb ,_ :=_gdc .RGBA ();
_ceb ,_dbb ,_fab ,_adae :=_ce .RGBToCMYK (uint8 (_ccad >>8),uint8 (_ggaf >>8),uint8 (_acb >>8));return _ce .CMYK {C :_ceb ,M :_dbb ,Y :_fab ,K :_adae };};func (_add *Gray8 )SetGray (x ,y int ,g _ce .Gray ){_dggc :=y *_add .BytesPerLine +x ;if _dggc > len (_add .Data )-1{return ;
};_add .Data [_dggc ]=g .Y ;};func GrayHistogram (g Gray )(_afdfb [256]int ){switch _gcga :=g .(type ){case Histogramer :return _gcga .Histogram ();case _a .Image :_dffcd :=_gcga .Bounds ();for _bdef :=0;_bdef < _dffcd .Max .X ;_bdef ++{for _gabg :=0;_gabg < _dffcd .Max .Y ;
_gabg ++{_afdfb [g .GrayAt (_bdef ,_gabg ).Y ]++;};};return _afdfb ;default:return [256]int {};};};var _ _a .Image =&NRGBA16 {};func (_geffa *RGBA32 )At (x ,y int )_ce .Color {_gdfec ,_ :=_geffa .ColorAt (x ,y );return _gdfec };func (_ebce *NRGBA32 )Validate ()error {if len (_ebce .Data )!=3*_ebce .Width *_ebce .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ce .Gray ,error ){_ecb :=y *bytesPerLine +x >>3;if _ecb >=len (data ){return _ce .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bacg :=data [_ecb ]>>uint (7-(x &7))&1;if len (decode )==2{_bacg =uint8 (LinearInterpolate (float64 (_bacg ),0.0,1.0,decode [0],decode [1]))&1;};return _ce .Gray {Y :_bacg *255},nil ;};func IsGrayImgBlackAndWhite (i *_a .Gray )bool {return _cgda (i )};
func (_caa *CMYK32 )ColorModel ()_ce .Model {return _ce .CMYKModel };var _ NRGBA =&NRGBA16 {};func _bdaf (_ffac _a .Image )(Image ,error ){if _eaec ,_agag :=_ffac .(*NRGBA16 );_agag {return _eaec .Copy (),nil ;};_bccd :=_ffac .Bounds ();_cagf ,_cafa :=NewImage (_bccd .Max .X ,_bccd .Max .Y ,4,3,nil ,nil ,nil );
if _cafa !=nil {return nil ,_cafa ;};_ffagf (_ffac ,_cagf ,_bccd );return _cagf ,nil ;};func _efaa (_efgb _a .Image ,_addd Image ,_cacf _a .Rectangle ){switch _fddd :=_efgb .(type ){case Gray :_cabfg (_fddd ,_addd .(Gray ),_cacf );case NRGBA :_eaccg (_fddd ,_addd .(Gray ),_cacf );
case CMYK :_eeef (_fddd ,_addd .(Gray ),_cacf );case RGBA :_cfage (_fddd ,_addd .(Gray ),_cacf );default:_cff (_efgb ,_addd ,_cacf );};};func (_gfcd *Gray2 )At (x ,y int )_ce .Color {_bdaa ,_ :=_gfcd .ColorAt (x ,y );return _bdaa };func _bcdg (_cdfa *Monochrome ,_dbad ,_bab ,_gage ,_bfga int ,_fgce RasterOperator ,_acdf *Monochrome ,_adbbf ,_eafcf int )error {var (_ecc byte ;
_cdc int ;_eefa int ;_aeda ,_gdbe int ;_cfeg ,_fcag int ;);_dedd :=_gage >>3;_ccef :=_gage &7;if _ccef > 0{_ecc =_cgcb [_ccef ];};_cdc =_acdf .BytesPerLine *_eafcf +(_adbbf >>3);_eefa =_cdfa .BytesPerLine *_bab +(_dbad >>3);switch _fgce {case PixSrc :for _cfeg =0;
_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]=_acdf .Data [_aeda ];_gdbe ++;_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],_acdf .Data [_aeda ],_ecc );
};};case PixNotSrc :for _cfeg =0;_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]=^(_acdf .Data [_aeda ]);_gdbe ++;_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],^_acdf .Data [_aeda ],_ecc );
};};case PixSrcOrDst :for _cfeg =0;_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]|=_acdf .Data [_aeda ];_gdbe ++;_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],_acdf .Data [_aeda ]|_cdfa .Data [_gdbe ],_ecc );
};};case PixSrcAndDst :for _cfeg =0;_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]&=_acdf .Data [_aeda ];_gdbe ++;_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],_acdf .Data [_aeda ]&_cdfa .Data [_gdbe ],_ecc );
};};case PixSrcXorDst :for _cfeg =0;_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]^=_acdf .Data [_aeda ];_gdbe ++;_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],_acdf .Data [_aeda ]^_cdfa .Data [_gdbe ],_ecc );
};};case PixNotSrcOrDst :for _cfeg =0;_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]|=^(_acdf .Data [_aeda ]);_gdbe ++;_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],^(_acdf .Data [_aeda ])|_cdfa .Data [_gdbe ],_ecc );
};};case PixNotSrcAndDst :for _cfeg =0;_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]&=^(_acdf .Data [_aeda ]);_gdbe ++;_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],^(_acdf .Data [_aeda ])&_cdfa .Data [_gdbe ],_ecc );
};};case PixSrcOrNotDst :for _cfeg =0;_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]=_acdf .Data [_aeda ]|^(_cdfa .Data [_gdbe ]);_gdbe ++;
_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],_acdf .Data [_aeda ]|^(_cdfa .Data [_gdbe ]),_ecc );};};case PixSrcAndNotDst :for _cfeg =0;_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;
for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]=_acdf .Data [_aeda ]&^(_cdfa .Data [_gdbe ]);_gdbe ++;_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],_acdf .Data [_aeda ]&^(_cdfa .Data [_gdbe ]),_ecc );};};case PixNotPixSrcOrDst :for _cfeg =0;
_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]=^(_acdf .Data [_aeda ]|_cdfa .Data [_gdbe ]);_gdbe ++;_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],^(_acdf .Data [_aeda ]|_cdfa .Data [_gdbe ]),_ecc );
};};case PixNotPixSrcAndDst :for _cfeg =0;_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]=^(_acdf .Data [_aeda ]&_cdfa .Data [_gdbe ]);
_gdbe ++;_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],^(_acdf .Data [_aeda ]&_cdfa .Data [_gdbe ]),_ecc );};};case PixNotPixSrcXorDst :for _cfeg =0;_cfeg < _bfga ;_cfeg ++{_aeda =_cdc +_cfeg *_acdf .BytesPerLine ;_gdbe =_eefa +_cfeg *_cdfa .BytesPerLine ;
for _fcag =0;_fcag < _dedd ;_fcag ++{_cdfa .Data [_gdbe ]=^(_acdf .Data [_aeda ]^_cdfa .Data [_gdbe ]);_gdbe ++;_aeda ++;};if _ccef > 0{_cdfa .Data [_gdbe ]=_ddeb (_cdfa .Data [_gdbe ],^(_acdf .Data [_aeda ]^_cdfa .Data [_gdbe ]),_ecc );};};default:_b .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_fgce );
return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_cecfd *Gray4 )At (x ,y int )_ce .Color {_bfdd ,_ :=_cecfd .ColorAt (x ,y );return _bfdd };
type NRGBA64 struct{ImageBase };var (_cgcb =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_dadf =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_ce .NRGBA ,error ){_cdee :=y *width +x ;
_bcgfb :=3*_cdee ;if _bcgfb +2>=len (data ){return _ce .NRGBA {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ccebg :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cdee {_ccebg =alpha [_cdee ];};_dbca ,_ccfe ,_abgc :=data [_bcgfb ],data [_bcgfb +1],data [_bcgfb +2];if len (decode )==6{_afae :=LinearInterpolate (float64 (_dbca ),0,255.0,decode [0],decode [1]);
_bdbac :=LinearInterpolate (float64 (_ccfe ),0,255.0,decode [2],decode [3]);_fgbc :=LinearInterpolate (float64 (_abgc ),0,255.0,decode [4],decode [5]);if _afae <=1.0&&_bdbac <=1.0&&_fgbc <=1.0{_afae *=255.0;_bdbac *=255.0;_fgbc *=255.0;};_dbca =uint8 (_afae )&0xff;
_ccfe =uint8 (_bdbac )&0xff;_abgc =uint8 (_fgbc )&0xff;};return _ce .NRGBA {R :_dbca ,G :_ccfe ,B :_abgc ,A :_ccebg },nil ;};type Image interface{_da .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_dgbac ,_egg int )(_ce .Color ,error );
Validate ()error ;};func (_fagf *RGBA32 )Validate ()error {if len (_fagf .Data )!=3*_fagf .Width *_fagf .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fbde *Gray2 )GrayAt (x ,y int )_ce .Gray {_gda ,_ :=ColorAtGray2BPC (x ,y ,_fbde .BytesPerLine ,_fbde .Data ,_fbde .Decode );return _gda ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_cfad :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _cfad ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_agcd :=width *colorComponents *bitsPerComponent ;_caaea :=_cfad *8;_ccggc :=8-(_caaea -_agcd );_egef :=_g .NewReader (data );_daa :=_cfad -1;_fcbc :=make ([]byte ,_daa );_gddc :=make ([]byte ,height *_cfad );
_cgece :=_g .NewWriterMSB (_gddc );var _facc uint64 ;var _fdf error ;for _cbad :=0;_cbad < height ;_cbad ++{_ ,_fdf =_egef .Read (_fcbc );if _fdf !=nil {return nil ,_fdf ;};_ ,_fdf =_cgece .Write (_fcbc );if _fdf !=nil {return nil ,_fdf ;};_facc ,_fdf =_egef .ReadBits (byte (_ccggc ));
if _fdf !=nil {return nil ,_fdf ;};_ ,_fdf =_cgece .WriteBits (_facc ,_ccggc );if _fdf !=nil {return nil ,_fdf ;};_cgece .FinishByte ();};return _gddc ,nil ;};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_ce .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_e .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};var _ _a .Image =&Gray8 {};func (_bef *Monochrome )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_bef .Width ,Y :_bef .Height }};};func _cfff (_dbcae []byte ,_fdge Image )error {_dacg :=true ;for _dfgb :=0;_dfgb < len (_dbcae );_dfgb ++{if _dbcae [_dfgb ]!=0xff{_dacg =false ;
break ;};};if _dacg {switch _ffbd :=_fdge .(type ){case *NRGBA32 :_ffbd .Alpha =nil ;case *NRGBA64 :_ffbd .Alpha =nil ;default:return _e .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_fdge );
};};return nil ;};func _bbdf (_cgd _ce .Color )_ce .Color {_gbea :=_ce .GrayModel .Convert (_cgd ).(_ce .Gray );return _fgg (_gbea );};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ce .Gray16 ,error ){_bdfa :=(y *bytesPerLine /2+x )*2;
if _bdfa +1>=len (data ){return _ce .Gray16 {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_beg :=uint16 (data [_bdfa ])<<8|uint16 (data [_bdfa +1]);if len (decode )==2{_beg =uint16 (uint64 (LinearInterpolate (float64 (_beg ),0,65535,decode [0],decode [1])));};return _ce .Gray16 {Y :_beg },nil ;};func _badd (_dbdb _a .Image )(Image ,error ){if _aae ,_bggb :=_dbdb .(*CMYK32 );
_bggb {return _aae .Copy (),nil ;};_ecd :=_dbdb .Bounds ();_faeb ,_bcf :=NewImage (_ecd .Max .X ,_ecd .Max .Y ,8,4,nil ,nil ,nil );if _bcf !=nil {return nil ,_bcf ;};switch _affe :=_dbdb .(type ){case CMYK :_fff (_affe ,_faeb .(CMYK ),_ecd );case Gray :_gedc (_affe ,_faeb .(CMYK ),_ecd );
case NRGBA :_gegb (_affe ,_faeb .(CMYK ),_ecd );case RGBA :_ebdf (_affe ,_faeb .(CMYK ),_ecd );default:_cff (_dbdb ,_faeb ,_ecd );};return _faeb ,nil ;};func _cdad (_bgag int ,_dgfb int )error {return _e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_bgag ,_dgfb );
};func (_efaaf *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _ffcb (_efaaf ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};type colorConverter struct{_cggg func (_fbdf _a .Image )(Image ,error );};
func (_edba *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_edba .copy ()}};func _def (_dggd int )[]uint {var _eab []uint ;_eee :=_dggd ;_dff :=_eee /8;if _dff !=0{for _efc :=0;_efc < _dff ;_efc ++{_eab =append (_eab ,8);};_eeb :=_eee %8;_eee =0;if _eeb !=0{_eee =_eeb ;
};};_dac :=_eee /4;if _dac !=0{for _agb :=0;_agb < _dac ;_agb ++{_eab =append (_eab ,4);};_aec :=_eee %4;_eee =0;if _aec !=0{_eee =_aec ;};};_bdf :=_eee /2;if _bdf !=0{for _bca :=0;_bca < _bdf ;_bca ++{_eab =append (_eab ,2);};};return _eab ;};func (_dgbb *NRGBA64 )Set (x ,y int ,c _ce .Color ){_eaea :=(y *_dgbb .Width +x )*2;
_dacgg :=_eaea *3;if _dacgg +5>=len (_dgbb .Data ){return ;};_fgdd :=_ce .NRGBA64Model .Convert (c ).(_ce .NRGBA64 );_dgbb .setNRGBA64 (_dacgg ,_fgdd ,_eaea );};var (MonochromeConverter =ConverterFunc (_edada );Gray2Converter =ConverterFunc (_baa );Gray4Converter =ConverterFunc (_cbgc );
GrayConverter =ConverterFunc (_gafe );Gray16Converter =ConverterFunc (_gge );NRGBA16Converter =ConverterFunc (_bdaf );NRGBAConverter =ConverterFunc (_dece );NRGBA64Converter =ConverterFunc (_gcgd );RGBAConverter =ConverterFunc (_dfbbd );CMYKConverter =ConverterFunc (_badd );
);func AutoThresholdTriangle (histogram [256]int )uint8 {var _eacce ,_bebf ,_eabf ,_fgba int ;for _fdfgf :=0;_fdfgf < len (histogram );_fdfgf ++{if histogram [_fdfgf ]> 0{_eacce =_fdfgf ;break ;};};if _eacce > 0{_eacce --;};for _edee :=255;_edee > 0;_edee --{if histogram [_edee ]> 0{_fgba =_edee ;
break ;};};if _fgba < 255{_fgba ++;};for _cdfaf :=0;_cdfaf < 256;_cdfaf ++{if histogram [_cdfaf ]> _bebf {_eabf =_cdfaf ;_bebf =histogram [_cdfaf ];};};var _dbgd bool ;if (_eabf -_eacce )< (_fgba -_eabf ){_dbgd =true ;var _cfdfc int ;_dgfbg :=255;for _cfdfc < _dgfbg {_gfbc :=histogram [_cfdfc ];
histogram [_cfdfc ]=histogram [_dgfbg ];histogram [_dgfbg ]=_gfbc ;_cfdfc ++;_dgfbg --;};_eacce =255-_fgba ;_eabf =255-_eabf ;};if _eacce ==_eabf {return uint8 (_eacce );};_fcbcf :=float64 (histogram [_eabf ]);_dgga :=float64 (_eacce -_eabf );_defaa :=_cf .Sqrt (_fcbcf *_fcbcf +_dgga *_dgga );
_fcbcf /=_defaa ;_dgga /=_defaa ;_defaa =_fcbcf *float64 (_eacce )+_dgga *float64 (histogram [_eacce ]);_ffgd :=_eacce ;var _fffd float64 ;for _dagc :=_eacce +1;_dagc <=_eabf ;_dagc ++{_fdddf :=_fcbcf *float64 (_dagc )+_dgga *float64 (histogram [_dagc ])-_defaa ;
if _fdddf > _fffd {_ffgd =_dagc ;_fffd =_fdddf ;};};_ffgd --;if _dbgd {var _fbb int ;_afea :=255;for _fbb < _afea {_ffbe :=histogram [_fbb ];histogram [_fbb ]=histogram [_afea ];histogram [_afea ]=_ffbe ;_fbb ++;_afea --;};return uint8 (255-_ffgd );};return uint8 (_ffgd );
};func ConverterFunc (converterFunc func (_cggc _a .Image )(Image ,error ))ColorConverter {return colorConverter {_cggg :converterFunc };};func _cfga (_cdg _ce .NRGBA )_ce .Gray {var _fcfe _ce .NRGBA ;if _cdg ==_fcfe {return _ce .Gray {Y :0xff};};_gfe ,_aef ,_gga ,_ :=_cdg .RGBA ();
_gfc :=(19595*_gfe +38470*_aef +7471*_gga +1<<15)>>24;return _ce .Gray {Y :uint8 (_gfc )};};func (_aafef *Gray4 )GrayAt (x ,y int )_ce .Gray {_cbd ,_ :=ColorAtGray4BPC (x ,y ,_aafef .BytesPerLine ,_aafef .Data ,_aafef .Decode );return _cbd ;};func (_fffb *NRGBA16 )Validate ()error {if len (_fffb .Data )!=3*_fffb .Width *_fffb .Height /2{return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ Image =&NRGBA16 {};func _cbef (_gcda ,_bffe uint8 )uint8 {if _gcda < _bffe {return 255;};return 0;};type NRGBA interface{NRGBAAt (_ecdc ,_fadd int )_ce .NRGBA ;SetNRGBA (_egga ,_face int ,_acgd _ce .NRGBA );};func (_ddc *CMYK32 )Set (x ,y int ,c _ce .Color ){_eef :=4*(y *_ddc .Width +x );
if _eef +3>=len (_ddc .Data ){return ;};_aac :=_ce .CMYKModel .Convert (c ).(_ce .CMYK );_ddc .Data [_eef ]=_aac .C ;_ddc .Data [_eef +1]=_aac .M ;_ddc .Data [_eef +2]=_aac .Y ;_ddc .Data [_eef +3]=_aac .K ;};type ColorConverter interface{Convert (_dfa _a .Image )(Image ,error );
};func (_bbff *Gray16 )ColorModel ()_ce .Model {return _ce .Gray16Model };var _ _a .Image =&Gray16 {};var _ _a .Image =&RGBA32 {};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_ce .NRGBA64 ,error ){_abebc :=(y *width +x )*2;_aeca :=_abebc *3;if _aeca +5>=len (data ){return _ce .NRGBA64 {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _dedb =0xffff;_eefbd :=uint16 (_dedb );if alpha !=nil &&len (alpha )> _abebc +1{_eefbd =uint16 (alpha [_abebc ])<<8|uint16 (alpha [_abebc +1]);};_eedf :=uint16 (data [_aeca ])<<8|uint16 (data [_aeca +1]);_fcbae :=uint16 (data [_aeca +2])<<8|uint16 (data [_aeca +3]);
_dfgaf :=uint16 (data [_aeca +4])<<8|uint16 (data [_aeca +5]);if len (decode )==6{_eedf =uint16 (uint64 (LinearInterpolate (float64 (_eedf ),0,65535,decode [0],decode [1]))&_dedb );_fcbae =uint16 (uint64 (LinearInterpolate (float64 (_fcbae ),0,65535,decode [2],decode [3]))&_dedb );
_dfgaf =uint16 (uint64 (LinearInterpolate (float64 (_dfgaf ),0,65535,decode [4],decode [5]))&_dedb );};return _ce .NRGBA64 {R :_eedf ,G :_fcbae ,B :_dfgaf ,A :_eefbd },nil ;};func (_dggg *ImageBase )setEightBytes (_ebgf int ,_fdaa uint64 )error {_ffce :=_dggg .BytesPerLine -(_ebgf %_dggg .BytesPerLine );
if _dggg .BytesPerLine !=_dggg .Width >>3{_ffce --;};if _ffce >=8{return _dggg .setEightFullBytes (_ebgf ,_fdaa );};return _dggg .setEightPartlyBytes (_ebgf ,_ffce ,_fdaa );};func (_cdfb *Monochrome )Histogram ()(_cbg [256]int ){for _ ,_eacc :=range _cdfb .Data {_cbg [0xff]+=int (_ddfa [_cdfb .Data [_eacc ]]);
};return _cbg ;};func (_ddee *NRGBA64 )At (x ,y int )_ce .Color {_bcef ,_ :=_ddee .ColorAt (x ,y );return _bcef };func (_ddce *NRGBA64 )Base ()*ImageBase {return &_ddce .ImageBase };var _ Image =&NRGBA64 {};func _abcf (_aded _ce .Gray )_ce .Gray {_aded .Y >>=4;
_aded .Y |=_aded .Y <<4;return _aded };func _aaede (_dbac _ce .Color )_ce .Color {_caf :=_ce .NRGBAModel .Convert (_dbac ).(_ce .NRGBA );return _ecgcg (_caf );};func (_dfbb *Monochrome )ColorAt (x ,y int )(_ce .Color ,error ){return ColorAtGray1BPC (x ,y ,_dfbb .BytesPerLine ,_dfbb .Data ,_dfbb .Decode );
};func _cabfg (_faea ,_cddb Gray ,_bbga _a .Rectangle ){for _fbaab :=0;_fbaab < _bbga .Max .X ;_fbaab ++{for _edcc :=0;_edcc < _bbga .Max .Y ;_edcc ++{_cddb .SetGray (_fbaab ,_edcc ,_faea .GrayAt (_fbaab ,_edcc ));};};};func (_aecf *Gray8 )GrayAt (x ,y int )_ce .Gray {_agfa ,_ :=ColorAtGray8BPC (x ,y ,_aecf .BytesPerLine ,_aecf .Data ,_aecf .Decode );
return _agfa ;};func _abdc (_cfcg _a .Image ,_fcae int )(_a .Rectangle ,bool ,[]byte ){_eceg :=_cfcg .Bounds ();var (_cagg bool ;_cabd []byte ;);switch _geefa :=_cfcg .(type ){case SMasker :_cagg =_geefa .HasAlpha ();case NRGBA ,RGBA ,*_a .RGBA64 ,nrgba64 ,*_a .NYCbCrA :_cabd =make ([]byte ,_eceg .Max .X *_eceg .Max .Y *_fcae );
case *_a .Paletted :if !_geefa .Opaque (){_cabd =make ([]byte ,_eceg .Max .X *_eceg .Max .Y *_fcae );};};return _eceg ,_cagg ,_cabd ;};func (_adgf colorConverter )Convert (src _a .Image )(Image ,error ){return _adgf ._cggg (src )};func (_eff *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_eff .copy ()}};
func (_fccd *Monochrome )getBitAt (_dcea ,_fgc int )bool {_aaef :=_fgc *_fccd .BytesPerLine +(_dcea >>3);_gdfa :=_dcea &0x07;_cgbg :=uint (7-_gdfa );if _aaef > len (_fccd .Data )-1{return false ;};if (_fccd .Data [_aaef ]>>_cgbg )&0x01>=1{return true ;
};return false ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_fbed :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _ggcga Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_ggcga =&Monochrome {ImageBase :_fbed ,ModelThreshold :0x0f};case 2:_ggcga =&Gray2 {ImageBase :_fbed };case 4:_ggcga =&Gray4 {ImageBase :_fbed };case 8:_ggcga =&Gray8 {ImageBase :_fbed };
case 16:_ggcga =&Gray16 {ImageBase :_fbed };};case 3:switch bitsPerComponent {case 4:_ggcga =&NRGBA16 {ImageBase :_fbed };case 8:_ggcga =&NRGBA32 {ImageBase :_fbed };case 16:_ggcga =&NRGBA64 {ImageBase :_fbed };};case 4:_ggcga =&CMYK32 {ImageBase :_fbed };
};if _ggcga ==nil {return nil ,ErrInvalidImage ;};return _ggcga ,nil ;};func _ecag (_deag *Monochrome ,_bfeeb ,_acc int ,_feff ,_fadb int ,_bbdfe RasterOperator ){var (_faab int ;_cgae byte ;_beea ,_bgb int ;_abea int ;);_gbeaa :=_feff >>3;_dec :=_feff &7;
if _dec > 0{_cgae =_cgcb [_dec ];};_faab =_deag .BytesPerLine *_acc +(_bfeeb >>3);switch _bbdfe {case PixClr :for _beea =0;_beea < _fadb ;_beea ++{_abea =_faab +_beea *_deag .BytesPerLine ;for _bgb =0;_bgb < _gbeaa ;_bgb ++{_deag .Data [_abea ]=0x0;_abea ++;
};if _dec > 0{_deag .Data [_abea ]=_ddeb (_deag .Data [_abea ],0x0,_cgae );};};case PixSet :for _beea =0;_beea < _fadb ;_beea ++{_abea =_faab +_beea *_deag .BytesPerLine ;for _bgb =0;_bgb < _gbeaa ;_bgb ++{_deag .Data [_abea ]=0xff;_abea ++;};if _dec > 0{_deag .Data [_abea ]=_ddeb (_deag .Data [_abea ],0xff,_cgae );
};};case PixNotDst :for _beea =0;_beea < _fadb ;_beea ++{_abea =_faab +_beea *_deag .BytesPerLine ;for _bgb =0;_bgb < _gbeaa ;_bgb ++{_deag .Data [_abea ]=^_deag .Data [_abea ];_abea ++;};if _dec > 0{_deag .Data [_abea ]=_ddeb (_deag .Data [_abea ],^_deag .Data [_abea ],_cgae );
};};};};func _dc (_db *Monochrome ,_ag int )(*Monochrome ,error ){if _db ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _ag ==1{return _db .copy (),nil ;};if !IsPowerOf2 (uint (_ag )){return nil ,_e .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ag );
};_ef :=_def (_ag );return _efg (_db ,_ag ,_ef );};func _agbe (_dgeb _ce .CMYK )_ce .NRGBA {_dcb ,_eacg ,_bbdb :=_ce .CMYKToRGB (_dgeb .C ,_dgeb .M ,_dgeb .Y ,_dgeb .K );return _ce .NRGBA {R :_dcb ,G :_eacg ,B :_bbdb ,A :0xff};};func _dag (_efcb ,_cgg *Monochrome ,_geb []byte ,_agf int )(_bag error ){var (_bbg ,_daf ,_aea ,_dagf ,_fcfd ,_bfee ,_gfb ,_gfg int ;
_geg ,_cde uint32 ;_fgd ,_ged byte ;_bea uint16 ;);_fbf :=make ([]byte ,4);_bggf :=make ([]byte ,4);for _aea =0;_aea < _efcb .Height -1;_aea ,_dagf =_aea +2,_dagf +1{_bbg =_aea *_efcb .BytesPerLine ;_daf =_dagf *_cgg .BytesPerLine ;for _fcfd ,_bfee =0,0;
_fcfd < _agf ;_fcfd ,_bfee =_fcfd +4,_bfee +1{for _gfb =0;_gfb < 4;_gfb ++{_gfg =_bbg +_fcfd +_gfb ;if _gfg <=len (_efcb .Data )-1&&_gfg < _bbg +_efcb .BytesPerLine {_fbf [_gfb ]=_efcb .Data [_gfg ];}else {_fbf [_gfb ]=0x00;};_gfg =_bbg +_efcb .BytesPerLine +_fcfd +_gfb ;
if _gfg <=len (_efcb .Data )-1&&_gfg < _bbg +(2*_efcb .BytesPerLine ){_bggf [_gfb ]=_efcb .Data [_gfg ];}else {_bggf [_gfb ]=0x00;};};_geg =_f .BigEndian .Uint32 (_fbf );_cde =_f .BigEndian .Uint32 (_bggf );_cde &=_geg ;_cde &=_cde <<1;_cde &=0xaaaaaaaa;
_geg =_cde |(_cde <<7);_fgd =byte (_geg >>24);_ged =byte ((_geg >>8)&0xff);_gfg =_daf +_bfee ;if _gfg +1==len (_cgg .Data )-1||_gfg +1>=_daf +_cgg .BytesPerLine {_cgg .Data [_gfg ]=_geb [_fgd ];if _bag =_cgg .setByte (_gfg ,_geb [_fgd ]);_bag !=nil {return _e .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gfg );
};}else {_bea =(uint16 (_geb [_fgd ])<<8)|uint16 (_geb [_ged ]);if _bag =_cgg .setTwoBytes (_gfg ,_bea );_bag !=nil {return _e .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gfg );
};_bfee ++;};};};return nil ;};func (_efca *Gray2 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_efca .Width ,Y :_efca .Height }};};type CMYK32 struct{ImageBase };func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_ce .CMYK ,error ){_gedd :=4*(y *width +x );
if _gedd +3>=len (data ){return _ce .CMYK {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_gedd ]&0xff;M :=data [_gedd +1]&0xff;Y :=data [_gedd +2]&0xff;K :=data [_gedd +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _ce .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_abd *CMYK32 )CMYKAt (x ,y int )_ce .CMYK {_afg ,_ :=ColorAtCMYK (x ,y ,_abd .Width ,_abd .Data ,_abd .Decode );
return _afg ;};func (_degc *Monochrome )InverseData ()error {return _degc .RasterOperation (0,0,_degc .Width ,_degc .Height ,PixNotDst ,nil ,0,0);};func (_fdae *ImageBase )setEightFullBytes (_gdfe int ,_cedc uint64 )error {if _gdfe +7> len (_fdae .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fdae .Data [_gdfe ]=byte ((_cedc &0xff00000000000000)>>56);_fdae .Data [_gdfe +1]=byte ((_cedc &0xff000000000000)>>48);_fdae .Data [_gdfe +2]=byte ((_cedc &0xff0000000000)>>40);_fdae .Data [_gdfe +3]=byte ((_cedc &0xff00000000)>>32);_fdae .Data [_gdfe +4]=byte ((_cedc &0xff000000)>>24);
_fdae .Data [_gdfe +5]=byte ((_cedc &0xff0000)>>16);_fdae .Data [_gdfe +6]=byte ((_cedc &0xff00)>>8);_fdae .Data [_gdfe +7]=byte (_cedc &0xff);return nil ;};func (_dgcc *NRGBA32 )ColorModel ()_ce .Model {return _ce .NRGBAModel };func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_eg :=BytesPerLine (width ,8,1);
if len (data )< _eg *height {return nil ,nil ;};_ga :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_bc ,_gd :=MonochromeConverter .Convert (_ga );if _gd !=nil {return nil ,_gd ;};return _bc .Base ().Data ,nil ;};func _bbcb (_bec _ce .NRGBA64 )_ce .Gray {var _acd _ce .NRGBA64 ;
if _bec ==_acd {return _ce .Gray {Y :0xff};};_bagf ,_cad ,_cabf ,_ :=_bec .RGBA ();_bgga :=(19595*_bagf +38470*_cad +7471*_cabf +1<<15)>>24;return _ce .Gray {Y :uint8 (_bgga )};};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;
Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func (_acfa *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_d .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_abf :=_bbe (width ,height );_gfaa :=make ([]int ,height );_ccgg :=make ([]int ,width );_ebeb :=float64 (_acfa .Width )/float64 (width );_bfca :=float64 (_acfa .Height )/float64 (height );for _dacb :=0;_dacb < height ;_dacb ++{_gfaa [_dacb ]=int (_cf .Min (_bfca *float64 (_dacb )+0.5,float64 (_acfa .Height -1)));
};for _bbfc :=0;_bbfc < width ;_bbfc ++{_ccgg [_bbfc ]=int (_cf .Min (_ebeb *float64 (_bbfc )+0.5,float64 (_acfa .Width -1)));};_feef :=-1;_fbdg :=byte (0);for _ebga :=0;_ebga < height ;_ebga ++{_bcgf :=_gfaa [_ebga ]*_acfa .BytesPerLine ;_bbbe :=_ebga *_abf .BytesPerLine ;
for _agfc :=0;_agfc < width ;_agfc ++{_cadd :=_ccgg [_agfc ];if _cadd !=_feef {_fbdg =_acfa .getBit (_bcgf ,_cadd );if _fbdg !=0{_abf .setBit (_bbbe ,_agfc );};_feef =_cadd ;}else {if _fbdg !=0{_abf .setBit (_bbbe ,_agfc );};};};};return _abf ,nil ;};func _dece (_dafa _a .Image )(Image ,error ){if _dade ,_gegf :=_dafa .(*NRGBA32 );
_gegf {return _dade .Copy (),nil ;};_adgb ,_fbae ,_gcfg :=_abdc (_dafa ,1);_gbaf ,_faad :=NewImage (_adgb .Max .X ,_adgb .Max .Y ,8,3,nil ,_gcfg ,nil );if _faad !=nil {return nil ,_faad ;};_ffagf (_dafa ,_gbaf ,_adgb );if len (_gcfg )!=0&&!_fbae {if _bbge :=_cfff (_gcfg ,_gbaf );
_bbge !=nil {return nil ,_bbge ;};};return _gbaf ,nil ;};func (_cecf *Gray2 )Base ()*ImageBase {return &_cecf .ImageBase };func (_gbac *Gray8 )Validate ()error {if len (_gbac .Data )!=_gbac .Height *_gbac .BytesPerLine {return ErrInvalidImage ;};return nil ;
};func (_bfdf *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_bfdf .copy ()}};func (_gbae *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_gbae .copy ()}};func (_fbc *Monochrome )ColorModel ()_ce .Model {return MonochromeModel (_fbc .ModelThreshold )};
func (_cbdc *NRGBA64 )Validate ()error {if len (_cbdc .Data )!=3*2*_cbdc .Width *_cbdc .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_cegd *NRGBA32 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_cegd .Width ,Y :_cegd .Height }};};func _bbec (_bcae ,_adf int ,_fde []byte )*Monochrome {_cbf :=_bbe (_bcae ,_adf );_cbf .Data =_fde ;return _cbf ;
};var _ Gray =&Gray2 {};func _dfcg (_bbad _ce .NRGBA )_ce .Gray {_ac ,_aadg ,_gfd ,_ :=_bbad .RGBA ();_defd :=(19595*_ac +38470*_aadg +7471*_gfd +1<<15)>>24;return _ce .Gray {Y :uint8 (_defd )};};func _bbe (_fdb ,_eag int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_fdb ,_eag ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};type Gray8 struct{ImageBase };func (_gafac *RGBA32 )RGBAAt (x ,y int )_ce .RGBA {_fcefd ,_ :=ColorAtRGBA32 (x ,y ,_gafac .Width ,_gafac .Data ,_gafac .Alpha ,_gafac .Decode );return _fcefd ;};func (_cgbe *Monochrome )SetGray (x ,y int ,g _ce .Gray ){_aebb :=y *_cgbe .BytesPerLine +x >>3;
if _aebb > len (_cgbe .Data )-1{return ;};g =_adeg (g ,monochromeModel (_cgbe .ModelThreshold ));_cgbe .setGray (x ,g ,_aebb );};func _fgg (_cgec _ce .Gray )_ce .Gray {_eaa :=_cgec .Y >>6;_eaa |=_eaa <<2;_cgec .Y =_eaa |_eaa <<4;return _cgec ;};func (_deed *Monochrome )copy ()*Monochrome {_cfec :=_bbe (_deed .Width ,_deed .Height );
_cfec .ModelThreshold =_deed .ModelThreshold ;_cfec .Data =make ([]byte ,len (_deed .Data ));copy (_cfec .Data ,_deed .Data );if len (_deed .Decode )!=0{_cfec .Decode =make ([]float64 ,len (_deed .Decode ));copy (_cfec .Decode ,_deed .Decode );};if len (_deed .Alpha )!=0{_cfec .Alpha =make ([]byte ,len (_deed .Alpha ));
copy (_cfec .Alpha ,_deed .Alpha );};return _cfec ;};var _ Image =&RGBA32 {};func _gcgd (_gbbg _a .Image )(Image ,error ){if _eeec ,_dacf :=_gbbg .(*NRGBA64 );_dacf {return _eeec .Copy (),nil ;};_agbd ,_egcb ,_bdfaa :=_abdc (_gbbg ,2);_ccea ,_bccf :=NewImage (_agbd .Max .X ,_agbd .Max .Y ,16,3,nil ,_bdfaa ,nil );
if _bccf !=nil {return nil ,_bccf ;};_gfddg (_gbbg ,_ccea ,_agbd );if len (_bdfaa )!=0&&!_egcb {if _daef :=_cfff (_bdfaa ,_ccea );_daef !=nil {return nil ,_daef ;};};return _ccea ,nil ;};type Gray2 struct{ImageBase };func (_aabe *Gray16 )Histogram ()(_egfe [256]int ){for _becg :=0;
_becg < _aabe .Width ;_becg ++{for _affbd :=0;_affbd < _aabe .Height ;_affbd ++{_egfe [_aabe .GrayAt (_becg ,_affbd ).Y ]++;};};return _egfe ;};func (_cdfg *Monochrome )Base ()*ImageBase {return &_cdfg .ImageBase };func (_ebfe *NRGBA32 )Set (x ,y int ,c _ce .Color ){_deeg :=y *_ebfe .Width +x ;
_fcff :=3*_deeg ;if _fcff +2>=len (_ebfe .Data ){return ;};_bgagb :=_ce .NRGBAModel .Convert (c ).(_ce .NRGBA );_ebfe .setRGBA (_deeg ,_bgagb );};var _ _a .Image =&NRGBA64 {};func (_gddb *NRGBA32 )At (x ,y int )_ce .Color {_cefg ,_ :=_gddb .ColorAt (x ,y );
return _cefg };func (_ebdd *NRGBA16 )setNRGBA (_faga ,_ceaa ,_decc int ,_bfae _ce .NRGBA ){if _faga *3%2==0{_ebdd .Data [_decc ]=(_bfae .R >>4)<<4|(_bfae .G >>4);_ebdd .Data [_decc +1]=(_bfae .B >>4)<<4|(_ebdd .Data [_decc +1]&0xf);}else {_ebdd .Data [_decc ]=(_ebdd .Data [_decc ]&0xf0)|(_bfae .R >>4);
_ebdd .Data [_decc +1]=(_bfae .G >>4)<<4|(_bfae .B >>4);};if _ebdd .Alpha !=nil {_eae :=_ceaa *BytesPerLine (_ebdd .Width ,4,1);if _eae < len (_ebdd .Alpha ){if _faga %2==0{_ebdd .Alpha [_eae ]=(_bfae .A >>uint (4))<<uint (4)|(_ebdd .Alpha [_decc ]&0xf);
}else {_ebdd .Alpha [_eae ]=(_ebdd .Alpha [_eae ]&0xf0)|(_bfae .A >>uint (4));};};};};func (_egac *NRGBA32 )SetNRGBA (x ,y int ,c _ce .NRGBA ){_gefe :=y *_egac .Width +x ;_bfbg :=3*_gefe ;if _bfbg +2>=len (_egac .Data ){return ;};_egac .setRGBA (_gefe ,c );
};func (_dfb *CMYK32 )At (x ,y int )_ce .Color {_febe ,_ :=_dfb .ColorAt (x ,y );return _febe };type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};type RGBA32 struct{ImageBase };func (_abcd *Monochrome )Validate ()error {if len (_abcd .Data )!=_abcd .Height *_abcd .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_fgcd *Gray4 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_fgcd .Width ,Y :_fgcd .Height }};};type Histogramer interface{Histogram ()[256]int ;};func _cgcc (_abebg *_a .NYCbCrA ,_dggbe NRGBA ,_bafc _a .Rectangle ){for _ggdab :=0;
_ggdab < _bafc .Max .X ;_ggdab ++{for _bfgaa :=0;_bfgaa < _bafc .Max .Y ;_bfgaa ++{_gadca :=_abebg .NYCbCrAAt (_ggdab ,_bfgaa );_dggbe .SetNRGBA (_ggdab ,_bfgaa ,_gebc (_gadca ));};};};func _gdab (_dbe *Monochrome ,_dgde ,_bcd int ,_adgg ,_agfcb int ,_abgb RasterOperator ,_cdda *Monochrome ,_ggdga ,_dadc int )error {var _beca ,_fddg ,_dfd ,_aacg int ;
if _dgde < 0{_ggdga -=_dgde ;_adgg +=_dgde ;_dgde =0;};if _ggdga < 0{_dgde -=_ggdga ;_adgg +=_ggdga ;_ggdga =0;};_beca =_dgde +_adgg -_dbe .Width ;if _beca > 0{_adgg -=_beca ;};_fddg =_ggdga +_adgg -_cdda .Width ;if _fddg > 0{_adgg -=_fddg ;};if _bcd < 0{_dadc -=_bcd ;
_agfcb +=_bcd ;_bcd =0;};if _dadc < 0{_bcd -=_dadc ;_agfcb +=_dadc ;_dadc =0;};_dfd =_bcd +_agfcb -_dbe .Height ;if _dfd > 0{_agfcb -=_dfd ;};_aacg =_dadc +_agfcb -_cdda .Height ;if _aacg > 0{_agfcb -=_aacg ;};if _adgg <=0||_agfcb <=0{return nil ;};var _bgfa error ;
switch {case _dgde &7==0&&_ggdga &7==0:_bgfa =_bcdg (_dbe ,_dgde ,_bcd ,_adgg ,_agfcb ,_abgb ,_cdda ,_ggdga ,_dadc );case _dgde &7==_ggdga &7:_bgfa =_adge (_dbe ,_dgde ,_bcd ,_adgg ,_agfcb ,_abgb ,_cdda ,_ggdga ,_dadc );default:_bgfa =_cgfe (_dbe ,_dgde ,_bcd ,_adgg ,_agfcb ,_abgb ,_cdda ,_ggdga ,_dadc );
};if _bgfa !=nil {return _bgfa ;};return nil ;};func (_aaba *ImageBase )setTwoBytes (_cefb int ,_fcbb uint16 )error {if _cefb +1> len (_aaba .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_aaba .Data [_cefb ]=byte ((_fcbb &0xff00)>>8);_aaba .Data [_cefb +1]=byte (_fcbb &0xff);return nil ;};func _gaeg (_egcg _a .Image ,_egfc Image ,_edcf _a .Rectangle ){if _gabc ,_feeg :=_egcg .(SMasker );_feeg &&_gabc .HasAlpha (){_egfc .(SMasker ).MakeAlpha ();
};switch _bgae :=_egcg .(type ){case Gray :_gedcf (_bgae ,_egfc .(RGBA ),_edcf );case NRGBA :_egff (_bgae ,_egfc .(RGBA ),_edcf );case *_a .NYCbCrA :_gdac (_bgae ,_egfc .(RGBA ),_edcf );case CMYK :_eedcb (_bgae ,_egfc .(RGBA ),_edcf );case RGBA :_cdea (_bgae ,_egfc .(RGBA ),_edcf );
case nrgba64 :_adggg (_bgae ,_egfc .(RGBA ),_edcf );default:_cff (_egcg ,_egfc ,_edcf );};};func _dcgc ()(_gdf [256]uint16 ){for _gcc :=0;_gcc < 256;_gcc ++{if _gcc &0x01!=0{_gdf [_gcc ]|=0x3;};if _gcc &0x02!=0{_gdf [_gcc ]|=0xc;};if _gcc &0x04!=0{_gdf [_gcc ]|=0x30;
};if _gcc &0x08!=0{_gdf [_gcc ]|=0xc0;};if _gcc &0x10!=0{_gdf [_gcc ]|=0x300;};if _gcc &0x20!=0{_gdf [_gcc ]|=0xc00;};if _gcc &0x40!=0{_gdf [_gcc ]|=0x3000;};if _gcc &0x80!=0{_gdf [_gcc ]|=0xc000;};};return _gdf ;};var _ Gray =&Monochrome {};type monochromeModel uint8 ;
func _dfbbd (_ccaa _a .Image )(Image ,error ){if _abcc ,_daec :=_ccaa .(*RGBA32 );_daec {return _abcc .Copy (),nil ;};_babe ,_edade ,_ebea :=_abdc (_ccaa ,1);_eade :=&RGBA32 {ImageBase :NewImageBase (_babe .Max .X ,_babe .Max .Y ,8,3,nil ,_ebea ,nil )};
_gaeg (_ccaa ,_eade ,_babe );if len (_ebea )!=0&&!_edade {if _egb :=_cfff (_ebea ,_eade );_egb !=nil {return nil ,_egb ;};};return _eade ,nil ;};func _dfafg (_abde _ce .NRGBA64 )_ce .RGBA {_ccb ,_dcgf ,_ace ,_cgb :=_abde .RGBA ();return _ce .RGBA {R :uint8 (_ccb >>8),G :uint8 (_dcgf >>8),B :uint8 (_ace >>8),A :uint8 (_cgb >>8)};
};func (_bedb *NRGBA64 )ColorAt (x ,y int )(_ce .Color ,error ){return ColorAtNRGBA64 (x ,y ,_bedb .Width ,_bedb .Data ,_bedb .Alpha ,_bedb .Decode );};func _cdea (_abcg ,_gdda RGBA ,_dccc _a .Rectangle ){for _bgaa :=0;_bgaa < _dccc .Max .X ;_bgaa ++{for _aaac :=0;
_aaac < _dccc .Max .Y ;_aaac ++{_gdda .SetRGBA (_bgaa ,_aaac ,_abcg .RGBAAt (_bgaa ,_aaac ));};};};func (_eagf *ImageBase )Pix ()[]byte {return _eagf .Data };func (_agg *Gray16 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_agg .Width ,Y :_agg .Height }};
};type nrgba64 interface{NRGBA64At (_faggf ,_fed int )_ce .NRGBA64 ;SetNRGBA64 (_cffa ,_abbeg int ,_ecge _ce .NRGBA64 );};var ErrInvalidImage =_d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_fdbd *Gray2 )ColorAt (x ,y int )(_ce .Color ,error ){return ColorAtGray2BPC (x ,y ,_fdbd .BytesPerLine ,_fdbd .Data ,_fdbd .Decode );};func _fegb (_bgg *Monochrome ,_cge ...int )(_ddda *Monochrome ,_cdd error ){if _bgg ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_cge )==0{return nil ,_d .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_gccc :=_fee ();_ddda =_bgg ;for _ ,_ebd :=range _cge {if _ebd <=0{break ;};_ddda ,_cdd =_fgf (_ddda ,_ebd ,_gccc );if _cdd !=nil {return nil ,_cdd ;};};return _ddda ,nil ;};func _gafe (_acda _a .Image )(Image ,error ){if _ggdge ,_ddbe :=_acda .(*Gray8 );
_ddbe {return _ggdge .Copy (),nil ;};_fge :=_acda .Bounds ();_dafg ,_eagb :=NewImage (_fge .Max .X ,_fge .Max .Y ,8,1,nil ,nil ,nil );if _eagb !=nil {return nil ,_eagb ;};_efaa (_acda ,_dafg ,_fge );return _dafg ,nil ;};func _dcac (_egbe *_a .Gray ,_ffgb uint8 )*_a .Gray {_cgfc :=_egbe .Bounds ();
_egcgd :=_a .NewGray (_cgfc );for _gbbc :=0;_gbbc < _cgfc .Dx ();_gbbc ++{for _acfc :=0;_acfc < _cgfc .Dy ();_acfc ++{_cddg :=_egbe .GrayAt (_gbbc ,_acfc );_egcgd .SetGray (_gbbc ,_acfc ,_ce .Gray {Y :_cbef (_cddg .Y ,_ffgb )});};};return _egcgd ;};func (_ffdb *Gray16 )ColorAt (x ,y int )(_ce .Color ,error ){return ColorAtGray16BPC (x ,y ,_ffdb .BytesPerLine ,_ffdb .Data ,_ffdb .Decode );
};func InDelta (expected ,current ,delta float64 )bool {_gcg :=expected -current ;if _gcg <=-delta ||_gcg >=delta {return false ;};return true ;};func (_eefb *NRGBA32 )setRGBA (_ebab int ,_afbfc _ce .NRGBA ){_ccdb :=3*_ebab ;_eefb .Data [_ccdb ]=_afbfc .R ;
_eefb .Data [_ccdb +1]=_afbfc .G ;_eefb .Data [_ccdb +2]=_afbfc .B ;if _ebab < len (_eefb .Alpha ){_eefb .Alpha [_ebab ]=_afbfc .A ;};};func (_eadge *Gray8 )At (x ,y int )_ce .Color {_aeccd ,_ :=_eadge .ColorAt (x ,y );return _aeccd };func (_bebc *ImageBase )setByte (_edbc int ,_cgcd byte )error {if _edbc > len (_bebc .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bebc .Data [_edbc ]=_cgcd ;return nil ;};type NRGBA32 struct{ImageBase };func _adge (_dcgb *Monochrome ,_dada ,_fbg ,_gddce ,_dcc int ,_faa RasterOperator ,_bcbg *Monochrome ,_cdeg ,_cbbf int )error {var (_ggdb bool ;_eecf bool ;_faaf int ;_agge int ;
_eebb int ;_aabd bool ;_dbfc byte ;_eefe int ;_bdfda int ;_gdfb int ;_cagb ,_bdgb int ;);_faafb :=8-(_dada &7);_fagd :=_dadf [_faafb ];_cgbc :=_dcgb .BytesPerLine *_fbg +(_dada >>3);_gde :=_bcbg .BytesPerLine *_cbbf +(_cdeg >>3);if _gddce < _faafb {_ggdb =true ;
_fagd &=_cgcb [8-_faafb +_gddce ];};if !_ggdb {_faaf =(_gddce -_faafb )>>3;if _faaf > 0{_eecf =true ;_agge =_cgbc +1;_eebb =_gde +1;};};_eefe =(_dada +_gddce )&7;if !(_ggdb ||_eefe ==0){_aabd =true ;_dbfc =_cgcb [_eefe ];_bdfda =_cgbc +1+_faaf ;_gdfb =_gde +1+_faaf ;
};switch _faa {case PixSrc :for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],_bcbg .Data [_gde ],_fagd );_cgbc +=_dcgb .BytesPerLine ;_gde +=_bcbg .BytesPerLine ;};if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;
_bdgb < _faaf ;_bdgb ++{_dcgb .Data [_agge +_bdgb ]=_bcbg .Data [_eebb +_bdgb ];};_agge +=_dcgb .BytesPerLine ;_eebb +=_bcbg .BytesPerLine ;};};if _aabd {for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],_bcbg .Data [_gdfb ],_dbfc );
_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};case PixNotSrc :for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],^_bcbg .Data [_gde ],_fagd );_cgbc +=_dcgb .BytesPerLine ;_gde +=_bcbg .BytesPerLine ;};
if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;_bdgb < _faaf ;_bdgb ++{_dcgb .Data [_agge +_bdgb ]=^_bcbg .Data [_eebb +_bdgb ];};_agge +=_dcgb .BytesPerLine ;_eebb +=_bcbg .BytesPerLine ;};};if _aabd {for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],^_bcbg .Data [_gdfb ],_dbfc );
_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};case PixSrcOrDst :for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],_bcbg .Data [_gde ]|_dcgb .Data [_cgbc ],_fagd );_cgbc +=_dcgb .BytesPerLine ;_gde +=_bcbg .BytesPerLine ;
};if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;_bdgb < _faaf ;_bdgb ++{_dcgb .Data [_agge +_bdgb ]|=_bcbg .Data [_eebb +_bdgb ];};_agge +=_dcgb .BytesPerLine ;_eebb +=_bcbg .BytesPerLine ;};};if _aabd {for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],_bcbg .Data [_gdfb ]|_dcgb .Data [_bdfda ],_dbfc );
_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};case PixSrcAndDst :for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],_bcbg .Data [_gde ]&_dcgb .Data [_cgbc ],_fagd );_cgbc +=_dcgb .BytesPerLine ;_gde +=_bcbg .BytesPerLine ;
};if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;_bdgb < _faaf ;_bdgb ++{_dcgb .Data [_agge +_bdgb ]&=_bcbg .Data [_eebb +_bdgb ];};_agge +=_dcgb .BytesPerLine ;_eebb +=_bcbg .BytesPerLine ;};};if _aabd {for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],_bcbg .Data [_gdfb ]&_dcgb .Data [_bdfda ],_dbfc );
_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};case PixSrcXorDst :for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],_bcbg .Data [_gde ]^_dcgb .Data [_cgbc ],_fagd );_cgbc +=_dcgb .BytesPerLine ;_gde +=_bcbg .BytesPerLine ;
};if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;_bdgb < _faaf ;_bdgb ++{_dcgb .Data [_agge +_bdgb ]^=_bcbg .Data [_eebb +_bdgb ];};_agge +=_dcgb .BytesPerLine ;_eebb +=_bcbg .BytesPerLine ;};};if _aabd {for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],_bcbg .Data [_gdfb ]^_dcgb .Data [_bdfda ],_dbfc );
_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};case PixNotSrcOrDst :for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],^(_bcbg .Data [_gde ])|_dcgb .Data [_cgbc ],_fagd );_cgbc +=_dcgb .BytesPerLine ;_gde +=_bcbg .BytesPerLine ;
};if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;_bdgb < _faaf ;_bdgb ++{_dcgb .Data [_agge +_bdgb ]|=^(_bcbg .Data [_eebb +_bdgb ]);};_agge +=_dcgb .BytesPerLine ;_eebb +=_bcbg .BytesPerLine ;};};if _aabd {for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],^(_bcbg .Data [_gdfb ])|_dcgb .Data [_bdfda ],_dbfc );
_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};case PixNotSrcAndDst :for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],^(_bcbg .Data [_gde ])&_dcgb .Data [_cgbc ],_fagd );_cgbc +=_dcgb .BytesPerLine ;_gde +=_bcbg .BytesPerLine ;
};if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;_bdgb < _faaf ;_bdgb ++{_dcgb .Data [_agge +_bdgb ]&=^_bcbg .Data [_eebb +_bdgb ];};_agge +=_dcgb .BytesPerLine ;_eebb +=_bcbg .BytesPerLine ;};};if _aabd {for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],^(_bcbg .Data [_gdfb ])&_dcgb .Data [_bdfda ],_dbfc );
_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};case PixSrcOrNotDst :for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],_bcbg .Data [_gde ]|^(_dcgb .Data [_cgbc ]),_fagd );_cgbc +=_dcgb .BytesPerLine ;_gde +=_bcbg .BytesPerLine ;
};if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;_bdgb < _faaf ;_bdgb ++{_dcgb .Data [_agge +_bdgb ]=_bcbg .Data [_eebb +_bdgb ]|^(_dcgb .Data [_agge +_bdgb ]);};_agge +=_dcgb .BytesPerLine ;_eebb +=_bcbg .BytesPerLine ;};};if _aabd {for _cagb =0;
_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],_bcbg .Data [_gdfb ]|^(_dcgb .Data [_bdfda ]),_dbfc );_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};case PixSrcAndNotDst :for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],_bcbg .Data [_gde ]&^(_dcgb .Data [_cgbc ]),_fagd );
_cgbc +=_dcgb .BytesPerLine ;_gde +=_bcbg .BytesPerLine ;};if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;_bdgb < _faaf ;_bdgb ++{_dcgb .Data [_agge +_bdgb ]=_bcbg .Data [_eebb +_bdgb ]&^(_dcgb .Data [_agge +_bdgb ]);};_agge +=_dcgb .BytesPerLine ;
_eebb +=_bcbg .BytesPerLine ;};};if _aabd {for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],_bcbg .Data [_gdfb ]&^(_dcgb .Data [_bdfda ]),_dbfc );_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};case PixNotPixSrcOrDst :for _cagb =0;
_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],^(_bcbg .Data [_gde ]|_dcgb .Data [_cgbc ]),_fagd );_cgbc +=_dcgb .BytesPerLine ;_gde +=_bcbg .BytesPerLine ;};if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;_bdgb < _faaf ;
_bdgb ++{_dcgb .Data [_agge +_bdgb ]=^(_bcbg .Data [_eebb +_bdgb ]|_dcgb .Data [_agge +_bdgb ]);};_agge +=_dcgb .BytesPerLine ;_eebb +=_bcbg .BytesPerLine ;};};if _aabd {for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],^(_bcbg .Data [_gdfb ]|_dcgb .Data [_bdfda ]),_dbfc );
_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};case PixNotPixSrcAndDst :for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],^(_bcbg .Data [_gde ]&_dcgb .Data [_cgbc ]),_fagd );_cgbc +=_dcgb .BytesPerLine ;
_gde +=_bcbg .BytesPerLine ;};if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;_bdgb < _faaf ;_bdgb ++{_dcgb .Data [_agge +_bdgb ]=^(_bcbg .Data [_eebb +_bdgb ]&_dcgb .Data [_agge +_bdgb ]);};_agge +=_dcgb .BytesPerLine ;_eebb +=_bcbg .BytesPerLine ;
};};if _aabd {for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],^(_bcbg .Data [_gdfb ]&_dcgb .Data [_bdfda ]),_dbfc );_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};case PixNotPixSrcXorDst :for _cagb =0;
_cagb < _dcc ;_cagb ++{_dcgb .Data [_cgbc ]=_ddeb (_dcgb .Data [_cgbc ],^(_bcbg .Data [_gde ]^_dcgb .Data [_cgbc ]),_fagd );_cgbc +=_dcgb .BytesPerLine ;_gde +=_bcbg .BytesPerLine ;};if _eecf {for _cagb =0;_cagb < _dcc ;_cagb ++{for _bdgb =0;_bdgb < _faaf ;
_bdgb ++{_dcgb .Data [_agge +_bdgb ]=^(_bcbg .Data [_eebb +_bdgb ]^_dcgb .Data [_agge +_bdgb ]);};_agge +=_dcgb .BytesPerLine ;_eebb +=_bcbg .BytesPerLine ;};};if _aabd {for _cagb =0;_cagb < _dcc ;_cagb ++{_dcgb .Data [_bdfda ]=_ddeb (_dcgb .Data [_bdfda ],^(_bcbg .Data [_gdfb ]^_dcgb .Data [_bdfda ]),_dbfc );
_bdfda +=_dcgb .BytesPerLine ;_gdfb +=_bcbg .BytesPerLine ;};};default:_b .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_faa );return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func (_cdgea *RGBA32 )ColorAt (x ,y int )(_ce .Color ,error ){return ColorAtRGBA32 (x ,y ,_cdgea .Width ,_cdgea .Data ,_cdgea .Alpha ,_cdgea .Decode );};func (_ecfd *NRGBA64 )ColorModel ()_ce .Model {return _ce .NRGBA64Model };func MonochromeModel (threshold uint8 )_ce .Model {return monochromeModel (threshold )};
func _bfab (_cbeaa Gray ,_efbe NRGBA ,_ffcga _a .Rectangle ){for _afe :=0;_afe < _ffcga .Max .X ;_afe ++{for _daad :=0;_daad < _ffcga .Max .Y ;_daad ++{_bade :=_cbeaa .GrayAt (_afe ,_daad );_efbe .SetNRGBA (_afe ,_daad ,_efae (_bade ));};};};func (_abee *Gray8 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_abee .Width ,Y :_abee .Height }};
};func (_eaac *RGBA32 )setRGBA (_bbedf int ,_bcad _ce .RGBA ){_gbeae :=3*_bbedf ;_eaac .Data [_gbeae ]=_bcad .R ;_eaac .Data [_gbeae +1]=_bcad .G ;_eaac .Data [_gbeae +2]=_bcad .B ;if _bbedf < len (_eaac .Alpha ){_eaac .Alpha [_bbedf ]=_bcad .A ;};};