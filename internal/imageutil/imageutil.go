//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_c "encoding/binary";_f "errors";_cb "fmt";_ag "github.com/unidoc/unipdf/v3/common";_ac "github.com/unidoc/unipdf/v3/internal/bitwise";_gb "image";_a "image/color";_bb "image/draw";_b "math";);func _gf (_ff *Monochrome ,_cba int )(*Monochrome ,error ){if _ff ==nil {return nil ,_f .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _cba ==1{return _ff .copy (),nil ;};if !IsPowerOf2 (uint (_cba )){return nil ,_cb .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cba );
};_dc :=_gg (_cba );return _ad (_ff ,_cba ,_dc );};func _adee (_dba _gb .Image )(Image ,error ){if _adef ,_egca :=_dba .(*Gray8 );_egca {return _adef .Copy (),nil ;};_feca :=_dba .Bounds ();_baf ,_gfac :=NewImage (_feca .Max .X ,_feca .Max .Y ,8,1,nil ,nil ,nil );
if _gfac !=nil {return nil ,_gfac ;};_aba (_dba ,_baf ,_feca );return _baf ,nil ;};func _gbedd (_gbab _gb .Image ,_cdgg Image ,_fcfe _gb .Rectangle ){if _dcba ,_feae :=_gbab .(SMasker );_feae &&_dcba .HasAlpha (){_cdgg .(SMasker ).MakeAlpha ();};switch _ebdde :=_gbab .(type ){case Gray :_fae (_ebdde ,_cdgg .(RGBA ),_fcfe );
case NRGBA :_cbfcf (_ebdde ,_cdgg .(RGBA ),_fcfe );case *_gb .NYCbCrA :_cgga (_ebdde ,_cdgg .(RGBA ),_fcfe );case CMYK :_eaeb (_ebdde ,_cdgg .(RGBA ),_fcfe );case RGBA :_gagf (_ebdde ,_cdgg .(RGBA ),_fcfe );case nrgba64 :_faef (_ebdde ,_cdgg .(RGBA ),_fcfe );
default:_gegg (_gbab ,_cdgg ,_fcfe );};};func _ageb (_dccf _a .RGBA )_a .NRGBA {switch _dccf .A {case 0xff:return _a .NRGBA {R :_dccf .R ,G :_dccf .G ,B :_dccf .B ,A :0xff};case 0x00:return _a .NRGBA {};default:_dea ,_ddc ,_afdd ,_fefe :=_dccf .RGBA ();
_dea =(_dea *0xffff)/_fefe ;_ddc =(_ddc *0xffff)/_fefe ;_afdd =(_afdd *0xffff)/_fefe ;return _a .NRGBA {R :uint8 (_dea >>8),G :uint8 (_ddc >>8),B :uint8 (_afdd >>8),A :uint8 (_fefe >>8)};};};func (_ggbf *Gray8 )At (x ,y int )_a .Color {_ddfec ,_ :=_ggbf .ColorAt (x ,y );
return _ddfec };func (_gebd *Gray16 )At (x ,y int )_a .Color {_acac ,_ :=_gebd .ColorAt (x ,y );return _acac };func _gagf (_gcfb ,_egcdc RGBA ,_bgaac _gb .Rectangle ){for _acde :=0;_acde < _bgaac .Max .X ;_acde ++{for _egcg :=0;_egcg < _bgaac .Max .Y ;
_egcg ++{_egcdc .SetRGBA (_acde ,_egcg ,_gcfb .RGBAAt (_acde ,_egcg ));};};};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_aadc :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _efce Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_efce =&Monochrome {ImageBase :_aadc ,ModelThreshold :0x0f};case 2:_efce =&Gray2 {ImageBase :_aadc };case 4:_efce =&Gray4 {ImageBase :_aadc };case 8:_efce =&Gray8 {ImageBase :_aadc };
case 16:_efce =&Gray16 {ImageBase :_aadc };};case 3:switch bitsPerComponent {case 4:_efce =&NRGBA16 {ImageBase :_aadc };case 8:_efce =&NRGBA32 {ImageBase :_aadc };case 16:_efce =&NRGBA64 {ImageBase :_aadc };};case 4:_efce =&CMYK32 {ImageBase :_aadc };};
if _efce ==nil {return nil ,ErrInvalidImage ;};return _efce ,nil ;};type Image interface{_bb .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_gaeb ,_dfca int )(_a .Color ,error );Validate ()error ;};func _eccc (_daea *Monochrome ,_bac ,_eecf int ,_abaf ,_adeba int ,_cfade RasterOperator ,_bagc *Monochrome ,_gge ,_agcfe int )error {var _aagb ,_ceaaa ,_adaf ,_ggfgg int ;
if _bac < 0{_gge -=_bac ;_abaf +=_bac ;_bac =0;};if _gge < 0{_bac -=_gge ;_abaf +=_gge ;_gge =0;};_aagb =_bac +_abaf -_daea .Width ;if _aagb > 0{_abaf -=_aagb ;};_ceaaa =_gge +_abaf -_bagc .Width ;if _ceaaa > 0{_abaf -=_ceaaa ;};if _eecf < 0{_agcfe -=_eecf ;
_adeba +=_eecf ;_eecf =0;};if _agcfe < 0{_eecf -=_agcfe ;_adeba +=_agcfe ;_agcfe =0;};_adaf =_eecf +_adeba -_daea .Height ;if _adaf > 0{_adeba -=_adaf ;};_ggfgg =_agcfe +_adeba -_bagc .Height ;if _ggfgg > 0{_adeba -=_ggfgg ;};if _abaf <=0||_adeba <=0{return nil ;
};var _bbgb error ;switch {case _bac &7==0&&_gge &7==0:_bbgb =_ggcdc (_daea ,_bac ,_eecf ,_abaf ,_adeba ,_cfade ,_bagc ,_gge ,_agcfe );case _bac &7==_gge &7:_bbgb =_fdc (_daea ,_bac ,_eecf ,_abaf ,_adeba ,_cfade ,_bagc ,_gge ,_agcfe );default:_bbgb =_adcd (_daea ,_bac ,_eecf ,_abaf ,_adeba ,_cfade ,_bagc ,_gge ,_agcfe );
};if _bbgb !=nil {return _bbgb ;};return nil ;};func _aged (_ggg _a .CMYK )_a .Gray {_dbbg ,_agc ,_fdfa :=_a .CMYKToRGB (_ggg .C ,_ggg .M ,_ggg .Y ,_ggg .K );_afgd :=(19595*uint32 (_dbbg )+38470*uint32 (_agc )+7471*uint32 (_fdfa )+1<<7)>>16;return _a .Gray {Y :uint8 (_afgd )};
};func (_edd *Gray2 )At (x ,y int )_a .Color {_cgd ,_ :=_edd .ColorAt (x ,y );return _cgd };func _aeb ()(_cec []byte ){_cec =make ([]byte ,256);for _cab :=0;_cab < 256;_cab ++{_bea :=byte (_cab );_cec [_bea ]=(_bea &0x01)|((_bea &0x04)>>1)|((_bea &0x10)>>2)|((_bea &0x40)>>3)|((_bea &0x02)<<3)|((_bea &0x08)<<2)|((_bea &0x20)<<1)|(_bea &0x80);
};return _cec ;};func _addd (_gdbc *Monochrome ,_ccce ,_ebfg int ,_gbcb ,_ebfab int ,_abbf RasterOperator ){var (_bbcca int ;_aeca byte ;_dbdff ,_beff int ;_gffb int ;);_efgf :=_gbcb >>3;_dfcg :=_gbcb &7;if _dfcg > 0{_aeca =_cgdf [_dfcg ];};_bbcca =_gdbc .BytesPerLine *_ebfg +(_ccce >>3);
switch _abbf {case PixClr :for _dbdff =0;_dbdff < _ebfab ;_dbdff ++{_gffb =_bbcca +_dbdff *_gdbc .BytesPerLine ;for _beff =0;_beff < _efgf ;_beff ++{_gdbc .Data [_gffb ]=0x0;_gffb ++;};if _dfcg > 0{_gdbc .Data [_gffb ]=_dfbf (_gdbc .Data [_gffb ],0x0,_aeca );
};};case PixSet :for _dbdff =0;_dbdff < _ebfab ;_dbdff ++{_gffb =_bbcca +_dbdff *_gdbc .BytesPerLine ;for _beff =0;_beff < _efgf ;_beff ++{_gdbc .Data [_gffb ]=0xff;_gffb ++;};if _dfcg > 0{_gdbc .Data [_gffb ]=_dfbf (_gdbc .Data [_gffb ],0xff,_aeca );};
};case PixNotDst :for _dbdff =0;_dbdff < _ebfab ;_dbdff ++{_gffb =_bbcca +_dbdff *_gdbc .BytesPerLine ;for _beff =0;_beff < _efgf ;_beff ++{_gdbc .Data [_gffb ]=^_gdbc .Data [_gffb ];_gffb ++;};if _dfcg > 0{_gdbc .Data [_gffb ]=_dfbf (_gdbc .Data [_gffb ],^_gdbc .Data [_gffb ],_aeca );
};};};};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_afe *Gray4 )Set (x ,y int ,c _a .Color ){if x >=_afe .Width ||y >=_afe .Height {return ;};_bbag :=Gray4Model .Convert (c ).(_a .Gray );
_afe .setGray (x ,y ,_bbag );};var _ _gb .Image =&Gray8 {};func _cbfc (_fabdc _a .Gray ,_aefa monochromeModel )_a .Gray {if _fabdc .Y > uint8 (_aefa ){return _a .Gray {Y :_b .MaxUint8 };};return _a .Gray {};};func _aba (_gaaa _gb .Image ,_gbd Image ,_fgaa _gb .Rectangle ){switch _adbag :=_gaaa .(type ){case Gray :_ecfe (_adbag ,_gbd .(Gray ),_fgaa );
case NRGBA :_afede (_adbag ,_gbd .(Gray ),_fgaa );case CMYK :_fcde (_adbag ,_gbd .(Gray ),_fgaa );case RGBA :_bccd (_adbag ,_gbd .(Gray ),_fgaa );default:_gegg (_gaaa ,_gbd ,_fgaa );};};type Histogramer interface{Histogram ()[256]int ;};func (_cfede *RGBA32 )Validate ()error {if len (_cfede .Data )!=3*_cfede .Width *_cfede .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _faef (_aafde nrgba64 ,_gagfg RGBA ,_beed _gb .Rectangle ){for _bgcg :=0;_bgcg < _beed .Max .X ;_bgcg ++{for _gccc :=0;_gccc < _beed .Max .Y ;_gccc ++{_bcdff :=_aafde .NRGBA64At (_bgcg ,_gccc );_gagfg .SetRGBA (_bgcg ,_gccc ,_acfe (_bcdff ));
};};};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_dbge :=y *bytesPerLine +x >>1;if _dbge >=len (data ){return _a .Gray {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_aeea :=data [_dbge ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_aeea =uint8 (uint32 (LinearInterpolate (float64 (_aeea ),0,15,decode [0],decode [1]))&0xf);};return _a .Gray {Y :_aeea *17&0xff},nil ;};func (_facb *Gray4 )Validate ()error {if len (_facb .Data )!=_facb .Height *_facb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func GrayHistogram (g Gray )(_egdc [256]int ){switch _facg :=g .(type ){case Histogramer :return _facg .Histogram ();
case _gb .Image :_fcfca :=_facg .Bounds ();for _ggeb :=0;_ggeb < _fcfca .Max .X ;_ggeb ++{for _dcga :=0;_dcga < _fcfca .Max .Y ;_dcga ++{_egdc [g .GrayAt (_ggeb ,_dcga ).Y ]++;};};return _egdc ;default:return [256]int {};};};var (Gray2Model =_a .ModelFunc (_bcaca );
Gray4Model =_a .ModelFunc (_aacg );NRGBA16Model =_a .ModelFunc (_fgde ););var _ _gb .Image =&Monochrome {};func _ffc (_adc _gb .Image )(Image ,error ){if _dde ,_eag :=_adc .(*CMYK32 );_eag {return _dde .Copy (),nil ;};_dbb :=_adc .Bounds ();_beb ,_gee :=NewImage (_dbb .Max .X ,_dbb .Max .Y ,8,4,nil ,nil ,nil );
if _gee !=nil {return nil ,_gee ;};switch _abdb :=_adc .(type ){case CMYK :_ega (_abdb ,_beb .(CMYK ),_dbb );case Gray :_cece (_abdb ,_beb .(CMYK ),_dbb );case NRGBA :_aagdb (_abdb ,_beb .(CMYK ),_dbb );case RGBA :_eebb (_abdb ,_beb .(CMYK ),_dbb );default:_gegg (_adc ,_beb ,_dbb );
};return _beb ,nil ;};func (_cfbca *Monochrome )GrayAt (x ,y int )_a .Gray {_fbef ,_ :=ColorAtGray1BPC (x ,y ,_cfbca .BytesPerLine ,_cfbca .Data ,_cfbca .Decode );return _fbef ;};func (_ecaec *NRGBA32 )At (x ,y int )_a .Color {_adad ,_ :=_ecaec .ColorAt (x ,y );
return _adad };func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_a .RGBA ,error ){_fgeg :=y *width +x ;_agebf :=3*_fgeg ;if _agebf +2>=len (data ){return _a .RGBA {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_afeb :=uint8 (0xff);if alpha !=nil &&len (alpha )> _fgeg {_afeb =alpha [_fgeg ];};_gdgf ,_dbfa ,_aegf :=data [_agebf ],data [_agebf +1],data [_agebf +2];if len (decode )==6{_gdgf =uint8 (uint32 (LinearInterpolate (float64 (_gdgf ),0,255,decode [0],decode [1]))&0xff);
_dbfa =uint8 (uint32 (LinearInterpolate (float64 (_dbfa ),0,255,decode [2],decode [3]))&0xff);_aegf =uint8 (uint32 (LinearInterpolate (float64 (_aegf ),0,255,decode [4],decode [5]))&0xff);};return _a .RGBA {R :_gdgf ,G :_dbfa ,B :_aegf ,A :_afeb },nil ;
};func (_dfbeb *Gray16 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_dfbeb .Width ,Y :_dfbeb .Height }};};func (_adeb *Gray2 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray2BPC (x ,y ,_adeb .BytesPerLine ,_adeb .Data ,_adeb .Decode );
};func _fcde (_cgbf CMYK ,_ceaa Gray ,_acfg _gb .Rectangle ){for _dfcc :=0;_dfcc < _acfg .Max .X ;_dfcc ++{for _cbfb :=0;_cbfb < _acfg .Max .Y ;_cbfb ++{_abba :=_aged (_cgbf .CMYKAt (_dfcc ,_cbfb ));_ceaa .SetGray (_dfcc ,_cbfb ,_abba );};};};func _effb (_ffg ,_ead *Monochrome ,_gfcc []byte ,_eaag int )(_adb error ){var (_bcc ,_afa ,_aaff ,_bg ,_afgb ,_gbed ,_fbgd ,_cff int ;
_ed ,_cfa ,_cgee ,_fcgd uint32 ;_abg ,_ddb byte ;_eaea uint16 ;);_fab :=make ([]byte ,4);_cbge :=make ([]byte ,4);for _aaff =0;_aaff < _ffg .Height -1;_aaff ,_bg =_aaff +2,_bg +1{_bcc =_aaff *_ffg .BytesPerLine ;_afa =_bg *_ead .BytesPerLine ;for _afgb ,_gbed =0,0;
_afgb < _eaag ;_afgb ,_gbed =_afgb +4,_gbed +1{for _fbgd =0;_fbgd < 4;_fbgd ++{_cff =_bcc +_afgb +_fbgd ;if _cff <=len (_ffg .Data )-1&&_cff < _bcc +_ffg .BytesPerLine {_fab [_fbgd ]=_ffg .Data [_cff ];}else {_fab [_fbgd ]=0x00;};_cff =_bcc +_ffg .BytesPerLine +_afgb +_fbgd ;
if _cff <=len (_ffg .Data )-1&&_cff < _bcc +(2*_ffg .BytesPerLine ){_cbge [_fbgd ]=_ffg .Data [_cff ];}else {_cbge [_fbgd ]=0x00;};};_ed =_c .BigEndian .Uint32 (_fab );_cfa =_c .BigEndian .Uint32 (_cbge );_cgee =_ed &_cfa ;_cgee |=_cgee <<1;_fcgd =_ed |_cfa ;
_fcgd &=_fcgd <<1;_cfa =_cgee &_fcgd ;_cfa &=0xaaaaaaaa;_ed =_cfa |(_cfa <<7);_abg =byte (_ed >>24);_ddb =byte ((_ed >>8)&0xff);_cff =_afa +_gbed ;if _cff +1==len (_ead .Data )-1||_cff +1>=_afa +_ead .BytesPerLine {if _adb =_ead .setByte (_cff ,_gfcc [_abg ]);
_adb !=nil {return _cb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_cff );};}else {_eaea =(uint16 (_gfcc [_abg ])<<8)|uint16 (_gfcc [_ddb ]);if _adb =_ead .setTwoBytes (_cff ,_eaea );_adb !=nil {return _cb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_cff );
};_gbed ++;};};};return nil ;};func (_gbge *NRGBA32 )Set (x ,y int ,c _a .Color ){_dagd :=y *_gbge .Width +x ;_acbeb :=3*_dagd ;if _acbeb +2>=len (_gbge .Data ){return ;};_ddebg :=_a .NRGBAModel .Convert (c ).(_a .NRGBA );_gbge .setRGBA (_dagd ,_ddebg );
};func _add (_fea _a .Gray )_a .Gray {_fea .Y >>=4;_fea .Y |=_fea .Y <<4;return _fea };func _gdcbd (_agg _a .NRGBA )_a .Gray {var _gfe _a .NRGBA ;if _agg ==_gfe {return _a .Gray {Y :0xff};};_cbcbg ,_gad ,_bebe ,_ :=_agg .RGBA ();_dgda :=(19595*_cbcbg +38470*_gad +7471*_bebe +1<<15)>>24;
return _a .Gray {Y :uint8 (_dgda )};};func _dafd (_bdd _a .NRGBA )_a .Gray {_fcc ,_eggc ,_ebf ,_ :=_bdd .RGBA ();_ecd :=(19595*_fcc +38470*_eggc +7471*_ebf +1<<15)>>24;return _a .Gray {Y :uint8 (_ecd )};};func (_aafc *Gray16 )Validate ()error {if len (_aafc .Data )!=_aafc .Height *_aafc .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _bagd (_faad int ,_dada int )int {if _faad < _dada {return _faad ;};return _dada ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_a .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_cb .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func _ggcdc (_ecda *Monochrome ,_aeeca ,_ccaga ,_dbf ,_fegg int ,_cbdd RasterOperator ,_caag *Monochrome ,_ecba ,_acfc int )error {var (_ebcf byte ;_bgbgd int ;_gbcg int ;_gbcf ,_dgbg int ;_cfbf ,_agea int ;);_ced :=_dbf >>3;_fgc :=_dbf &7;if _fgc > 0{_ebcf =_cgdf [_fgc ];
};_bgbgd =_caag .BytesPerLine *_acfc +(_ecba >>3);_gbcg =_ecda .BytesPerLine *_ccaga +(_aeeca >>3);switch _cbdd {case PixSrc :for _cfbf =0;_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;for _agea =0;
_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]=_caag .Data [_gbcf ];_dgbg ++;_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],_caag .Data [_gbcf ],_ebcf );};};case PixNotSrc :for _cfbf =0;_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;
_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;for _agea =0;_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]=^(_caag .Data [_gbcf ]);_dgbg ++;_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],^_caag .Data [_gbcf ],_ebcf );};};case PixSrcOrDst :for _cfbf =0;
_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;for _agea =0;_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]|=_caag .Data [_gbcf ];_dgbg ++;_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],_caag .Data [_gbcf ]|_ecda .Data [_dgbg ],_ebcf );
};};case PixSrcAndDst :for _cfbf =0;_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;for _agea =0;_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]&=_caag .Data [_gbcf ];_dgbg ++;_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],_caag .Data [_gbcf ]&_ecda .Data [_dgbg ],_ebcf );
};};case PixSrcXorDst :for _cfbf =0;_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;for _agea =0;_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]^=_caag .Data [_gbcf ];_dgbg ++;_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],_caag .Data [_gbcf ]^_ecda .Data [_dgbg ],_ebcf );
};};case PixNotSrcOrDst :for _cfbf =0;_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;for _agea =0;_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]|=^(_caag .Data [_gbcf ]);_dgbg ++;_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],^(_caag .Data [_gbcf ])|_ecda .Data [_dgbg ],_ebcf );
};};case PixNotSrcAndDst :for _cfbf =0;_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;for _agea =0;_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]&=^(_caag .Data [_gbcf ]);_dgbg ++;_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],^(_caag .Data [_gbcf ])&_ecda .Data [_dgbg ],_ebcf );
};};case PixSrcOrNotDst :for _cfbf =0;_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;for _agea =0;_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]=_caag .Data [_gbcf ]|^(_ecda .Data [_dgbg ]);_dgbg ++;
_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],_caag .Data [_gbcf ]|^(_ecda .Data [_dgbg ]),_ebcf );};};case PixSrcAndNotDst :for _cfbf =0;_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;
for _agea =0;_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]=_caag .Data [_gbcf ]&^(_ecda .Data [_dgbg ]);_dgbg ++;_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],_caag .Data [_gbcf ]&^(_ecda .Data [_dgbg ]),_ebcf );};};case PixNotPixSrcOrDst :for _cfbf =0;
_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;for _agea =0;_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]=^(_caag .Data [_gbcf ]|_ecda .Data [_dgbg ]);_dgbg ++;_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],^(_caag .Data [_gbcf ]|_ecda .Data [_dgbg ]),_ebcf );
};};case PixNotPixSrcAndDst :for _cfbf =0;_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;for _agea =0;_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]=^(_caag .Data [_gbcf ]&_ecda .Data [_dgbg ]);
_dgbg ++;_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],^(_caag .Data [_gbcf ]&_ecda .Data [_dgbg ]),_ebcf );};};case PixNotPixSrcXorDst :for _cfbf =0;_cfbf < _fegg ;_cfbf ++{_gbcf =_bgbgd +_cfbf *_caag .BytesPerLine ;_dgbg =_gbcg +_cfbf *_ecda .BytesPerLine ;
for _agea =0;_agea < _ced ;_agea ++{_ecda .Data [_dgbg ]=^(_caag .Data [_gbcf ]^_ecda .Data [_dgbg ]);_dgbg ++;_gbcf ++;};if _fgc > 0{_ecda .Data [_dgbg ]=_dfbf (_ecda .Data [_dgbg ],^(_caag .Data [_gbcf ]^_ecda .Data [_dgbg ]),_ebcf );};};default:_ag .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_cbdd );
return _f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_ggggc *NRGBA32 )NRGBAAt (x ,y int )_a .NRGBA {_ebfd ,_ :=ColorAtNRGBA32 (x ,y ,_ggggc .Width ,_ggggc .Data ,_ggggc .Alpha ,_ggggc .Decode );
return _ebfd ;};func (_gbba *RGBA32 )RGBAAt (x ,y int )_a .RGBA {_fefb ,_ :=ColorAtRGBA32 (x ,y ,_gbba .Width ,_gbba .Data ,_gbba .Alpha ,_gbba .Decode );return _fefb ;};var _ _gb .Image =&RGBA32 {};func _fddf (_cgbc uint )uint {var _ddbfg uint ;for _cgbc !=0{_cgbc >>=1;
_ddbfg ++;};return _ddbfg -1;};func (_bad *Monochrome )InverseData ()error {return _bad .RasterOperation (0,0,_bad .Width ,_bad .Height ,PixNotDst ,nil ,0,0);};func _cbf (_ggac Gray ,_agcd nrgba64 ,_efad _gb .Rectangle ){for _adfg :=0;_adfg < _efad .Max .X ;
_adfg ++{for _eea :=0;_eea < _efad .Max .Y ;_eea ++{_dee :=_fdbf (_agcd .NRGBA64At (_adfg ,_eea ));_ggac .SetGray (_adfg ,_eea ,_dee );};};};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_fddf (n )+1);};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _b .Abs (xmax -xmin )< 0.000001{return ymin ;
};_fegd :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _fegd ;};type Gray4 struct{ImageBase };func (_ecbg *Monochrome )IsUnpadded ()bool {return (_ecbg .Width *_ecbg .Height )==len (_ecbg .Data )};func (_ebg *Monochrome )SetGray (x ,y int ,g _a .Gray ){_ggcd :=y *_ebg .BytesPerLine +x >>3;
if _ggcd > len (_ebg .Data )-1{return ;};g =_cbfc (g ,monochromeModel (_ebg .ModelThreshold ));_ebg .setGray (x ,g ,_ggcd );};type RGBA interface{RGBAAt (_accde ,_ecbc int )_a .RGBA ;SetRGBA (_gdea ,_cdgf int ,_fcfc _a .RGBA );};var _ _gb .Image =&Gray16 {};
func _dfa (_gac _a .Gray )_a .RGBA {return _a .RGBA {R :_gac .Y ,G :_gac .Y ,B :_gac .Y ,A :0xff}};func _ccbb (_aabcc _gb .Image ,_ecdec Image ,_cgafc _gb .Rectangle ){if _feced ,_dddc :=_aabcc .(SMasker );_dddc &&_feced .HasAlpha (){_ecdec .(SMasker ).MakeAlpha ();
};_gegg (_aabcc ,_ecdec ,_cgafc );};func (_dfcf *RGBA32 )Set (x ,y int ,c _a .Color ){_bcda :=y *_dfcf .Width +x ;_gebad :=3*_bcda ;if _gebad +2>=len (_dfcf .Data ){return ;};_fgfbf :=_a .RGBAModel .Convert (c ).(_a .RGBA );_dfcf .setRGBA (_bcda ,_fgfbf );
};func (_aaggb *Gray2 )Validate ()error {if len (_aaggb .Data )!=_aaggb .Height *_aaggb .BytesPerLine {return ErrInvalidImage ;};return nil ;};type shift int ;func (_fead *NRGBA64 )Validate ()error {if len (_fead .Data )!=3*2*_fead .Width *_fead .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _eebb (_gbf RGBA ,_gdcb CMYK ,_cfbc _gb .Rectangle ){for _bcac :=0;_bcac < _cfbc .Max .X ;_bcac ++{for _degg :=0;_degg < _cfbc .Max .Y ;_degg ++{_cgb :=_gbf .RGBAAt (_bcac ,_degg );_gdcb .SetCMYK (_bcac ,_degg ,_gfeb (_cgb ));};};};
func (_fgdg *Gray4 )Base ()*ImageBase {return &_fgdg .ImageBase };func (_dadf *Monochrome )Histogram ()(_aae [256]int ){for _ ,_ggae :=range _dadf .Data {_aae [0xff]+=int (_gaaga [_dadf .Data [_ggae ]]);};return _aae ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_dadg :=y *bytesPerLine +x ;
if _dadg >=len (data ){return _a .Gray {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dgff :=data [_dadg ];if len (decode )==2{_dgff =uint8 (uint32 (LinearInterpolate (float64 (_dgff ),0,255,decode [0],decode [1]))&0xff);};return _a .Gray {Y :_dgff },nil ;};func (_eebbg *NRGBA16 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA16 (x ,y ,_eebbg .Width ,_eebbg .BytesPerLine ,_eebbg .Data ,_eebbg .Alpha ,_eebbg .Decode );
};func init (){_dcfa ()};func (_gef *monochromeThresholdConverter )Convert (img _gb .Image )(Image ,error ){if _bbfe ,_ccfe :=img .(*Monochrome );_ccfe {return _bbfe .Copy (),nil ;};_bgg :=img .Bounds ();_ffb ,_aagdf :=NewImage (_bgg .Max .X ,_bgg .Max .Y ,1,1,nil ,nil ,nil );
if _aagdf !=nil {return nil ,_aagdf ;};_ffb .(*Monochrome ).ModelThreshold =_gef .Threshold ;for _dcda :=0;_dcda < _bgg .Max .X ;_dcda ++{for _fcca :=0;_fcca < _bgg .Max .Y ;_fcca ++{_caab :=img .At (_dcda ,_fcca );_ffb .Set (_dcda ,_fcca ,_caab );};};
return _ffb ,nil ;};func (_dfd *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_f .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_cagd :=_gdb (width ,height );_dfae :=make ([]int ,height );_agbf :=make ([]int ,width );_bfbg :=float64 (_dfd .Width )/float64 (width );_beef :=float64 (_dfd .Height )/float64 (height );for _edge :=0;_edge < height ;_edge ++{_dfae [_edge ]=int (_b .Min (_beef *float64 (_edge )+0.5,float64 (_dfd .Height -1)));
};for _fbe :=0;_fbe < width ;_fbe ++{_agbf [_fbe ]=int (_b .Min (_bfbg *float64 (_fbe )+0.5,float64 (_dfd .Width -1)));};_gafa :=-1;_abdc :=byte (0);for _dgbbg :=0;_dgbbg < height ;_dgbbg ++{_adba :=_dfae [_dgbbg ]*_dfd .BytesPerLine ;_dfbc :=_dgbbg *_cagd .BytesPerLine ;
for _dgbc :=0;_dgbc < width ;_dgbc ++{_eaeg :=_agbf [_dgbc ];if _eaeg !=_gafa {_abdc =_dfd .getBit (_adba ,_eaeg );if _abdc !=0{_cagd .setBit (_dfbc ,_dgbc );};_gafa =_eaeg ;}else {if _abdc !=0{_cagd .setBit (_dfbc ,_dgbc );};};};};return _cagd ,nil ;};
func (_baeef *Gray4 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_baeef .Width ,Y :_baeef .Height }};};func (_affbf *Monochrome )AddPadding ()(_ccae error ){if _gafd :=((_affbf .Width *_affbf .Height )+7)>>3;len (_affbf .Data )< _gafd {return _cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_affbf .Data ),_gafd );
};_acg :=_affbf .Width %8;if _acg ==0{return nil ;};_accc :=_affbf .Width /8;_edec :=_ac .NewReader (_affbf .Data );_cegf :=make ([]byte ,_affbf .Height *_affbf .BytesPerLine );_bbg :=_ac .NewWriterMSB (_cegf );_fbf :=make ([]byte ,_accc );var (_cce int ;
_cdd uint64 ;);for _cce =0;_cce < _affbf .Height ;_cce ++{if _ ,_ccae =_edec .Read (_fbf );_ccae !=nil {return _ccae ;};if _ ,_ccae =_bbg .Write (_fbf );_ccae !=nil {return _ccae ;};if _cdd ,_ccae =_edec .ReadBits (byte (_acg ));_ccae !=nil {return _ccae ;
};if _ccae =_bbg .WriteByte (byte (_cdd )<<uint (8-_acg ));_ccae !=nil {return _ccae ;};};_affbf .Data =_bbg .Data ();return nil ;};func (_efgd *Gray4 )GrayAt (x ,y int )_a .Gray {_bfa ,_ :=ColorAtGray4BPC (x ,y ,_efgd .BytesPerLine ,_efgd .Data ,_efgd .Decode );
return _bfa ;};func (_defg *RGBA32 )At (x ,y int )_a .Color {_ebaf ,_ :=_defg .ColorAt (x ,y );return _ebaf };func _abfe (_aedd CMYK ,_gefg NRGBA ,_gefe _gb .Rectangle ){for _bbda :=0;_bbda < _gefe .Max .X ;_bbda ++{for _feef :=0;_feef < _gefe .Max .Y ;
_feef ++{_ccbc :=_aedd .CMYKAt (_bbda ,_feef );_gefg .SetNRGBA (_bbda ,_feef ,_ffab (_ccbc ));};};};func (_beeb *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_beeb .ImageBase .copy (),ModelThreshold :_beeb .ModelThreshold };};func (_badd monochromeModel )Convert (c _a .Color )_a .Color {_dabg :=_a .GrayModel .Convert (c ).(_a .Gray );
return _cbfc (_dabg ,_badd );};func ImgToGray (i _gb .Image )*_gb .Gray {if _gecc ,_deef :=i .(*_gb .Gray );_deef {return _gecc ;};_ebfad :=i .Bounds ();_gdec :=_gb .NewGray (_ebfad );for _dbeg :=0;_dbeg < _ebfad .Max .X ;_dbeg ++{for _ccbg :=0;_ccbg < _ebfad .Max .Y ;
_ccbg ++{_dafdf :=i .At (_dbeg ,_ccbg );_gdec .Set (_dbeg ,_ccbg ,_dafdf );};};return _gdec ;};var _ NRGBA =&NRGBA16 {};func (_bga *ImageBase )Pix ()[]byte {return _bga .Data };func _ddbc (_cdcc uint8 )bool {if _cdcc ==0||_cdcc ==255{return true ;};return false ;
};func _gaad (_aed _a .RGBA )_a .Gray {_acfd :=(19595*uint32 (_aed .R )+38470*uint32 (_aed .G )+7471*uint32 (_aed .B )+1<<7)>>16;return _a .Gray {Y :uint8 (_acfd )};};func (_fbab *Monochrome )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_fbab .Width ,Y :_fbab .Height }};
};func (_effc *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_effc .copy ()}};func _cgga (_ggbg *_gb .NYCbCrA ,_dffg RGBA ,_ceaaaf _gb .Rectangle ){for _cagdg :=0;_cagdg < _ceaaaf .Max .X ;_cagdg ++{for _fbdff :=0;_fbdff < _ceaaaf .Max .Y ;_fbdff ++{_cdc :=_ggbg .NYCbCrAAt (_cagdg ,_fbdff );
_dffg .SetRGBA (_cagdg ,_fbdff ,_eaagg (_cdc ));};};};var _ Image =&Gray8 {};func (_eaefa *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_eaefa .copy ()}};func _eec (_adga _a .NRGBA64 )_a .NRGBA {return _a .NRGBA {R :uint8 (_adga .R >>8),G :uint8 (_adga .G >>8),B :uint8 (_adga .B >>8),A :uint8 (_adga .A >>8)};
};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_aaaa *ImageBase )setEightBytes (_edff int ,_fdbce uint64 )error {_aecd :=_aaaa .BytesPerLine -(_edff %_aaaa .BytesPerLine );
if _aaaa .BytesPerLine !=_aaaa .Width >>3{_aecd --;};if _aecd >=8{return _aaaa .setEightFullBytes (_edff ,_fdbce );};return _aaaa .setEightPartlyBytes (_edff ,_aecd ,_fdbce );};func (_gfb *Gray8 )Validate ()error {if len (_gfb .Data )!=_gfb .Height *_gfb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_faf *Gray2 )SetGray (x ,y int ,gray _a .Gray ){_acee :=_gbef (gray );_dbdf :=y *_faf .BytesPerLine ;_fcbaa :=_dbdf +(x >>2);if _fcbaa >=len (_faf .Data ){return ;};_abdf :=_acee .Y >>6;_faf .Data [_fcbaa ]=(_faf .Data [_fcbaa ]&(^(0xc0>>uint (2*((x )&3)))))|(_abdf <<uint (6-2*(x &3)));
};var _ Gray =&Monochrome {};var _ Image =&CMYK32 {};func (_fcgf *NRGBA32 )Base ()*ImageBase {return &_fcgf .ImageBase };func _ebgd (_cgdg _gb .Image )(Image ,error ){if _acae ,_bcb :=_cgdg .(*Gray2 );_bcb {return _acae .Copy (),nil ;};_fce :=_cgdg .Bounds ();
_eagc ,_gggg :=NewImage (_fce .Max .X ,_fce .Max .Y ,2,1,nil ,nil ,nil );if _gggg !=nil {return nil ,_gggg ;};_aba (_cgdg ,_eagc ,_fce );return _eagc ,nil ;};func (_cfgd *CMYK32 )SetCMYK (x ,y int ,c _a .CMYK ){_efd :=4*(y *_cfgd .Width +x );if _efd +3>=len (_cfgd .Data ){return ;
};_cfgd .Data [_efd ]=c .C ;_cfgd .Data [_efd +1]=c .M ;_cfgd .Data [_efd +2]=c .Y ;_cfgd .Data [_efd +3]=c .K ;};func (_gddg *NRGBA16 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_gddg .Width ,Y :_gddg .Height }};};func (_gcfg *Gray8 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray8BPC (x ,y ,_gcfg .BytesPerLine ,_gcfg .Data ,_gcfg .Decode );
};func _eaaga (_bcag _gb .Image )(Image ,error ){if _cgdb ,_bgdb :=_bcag .(*Gray4 );_bgdb {return _cgdb .Copy (),nil ;};_gfgg :=_bcag .Bounds ();_bdf ,_dgcf :=NewImage (_gfgg .Max .X ,_gfgg .Max .Y ,4,1,nil ,nil ,nil );if _dgcf !=nil {return nil ,_dgcf ;
};_aba (_bcag ,_bdf ,_gfgg );return _bdf ,nil ;};func (_accg *NRGBA32 )setRGBA (_edc int ,_fdba _a .NRGBA ){_aaef :=3*_edc ;_accg .Data [_aaef ]=_fdba .R ;_accg .Data [_aaef +1]=_fdba .G ;_accg .Data [_aaef +2]=_fdba .B ;if _edc < len (_accg .Alpha ){_accg .Alpha [_edc ]=_fdba .A ;
};};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_ceaf :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_ceaf .Data =make ([]byte ,height *_ceaf .BytesPerLine );};return _ceaf ;};func (_gcbg *Monochrome )getBitAt (_bgd ,_cfgdg int )bool {_deaa :=_cfgdg *_gcbg .BytesPerLine +(_bgd >>3);_bebd :=_bgd &0x07;_cced :=uint (7-_bebd );if _deaa > len (_gcbg .Data )-1{return false ;
};if (_gcbg .Data [_deaa ]>>_cced )&0x01>=1{return true ;};return false ;};func (_afgbd *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_afgbd .copy ()}};func (_dcdf colorConverter )Convert (src _gb .Image )(Image ,error ){return _dcdf ._efda (src )};
func (_gab *Gray8 )ColorModel ()_a .Model {return _a .GrayModel };func (_ffbgd *ImageBase )setByte (_beaaf int ,_aaa byte )error {if _beaaf > len (_ffbgd .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ffbgd .Data [_beaaf ]=_aaa ;return nil ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_abe :=y *bytesPerLine +x >>2;if _abe >=len (data ){return _a .Gray {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eac :=data [_abe ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_eac =uint8 (uint32 (LinearInterpolate (float64 (_eac ),0,3.0,decode [0],decode [1]))&3);};return _a .Gray {Y :_eac *85},nil ;};func (_bdb *CMYK32 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_bdb .Width ,Y :_bdb .Height }};
};func (_fddd *Gray16 )ColorModel ()_a .Model {return _a .Gray16Model };func (_eaeab *RGBA32 )Base ()*ImageBase {return &_eaeab .ImageBase };func (_gcgd *NRGBA32 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_gcgd .Width ,Y :_gcgd .Height }};
};type RGBA32 struct{ImageBase };func (_ebac *Gray16 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray16BPC (x ,y ,_ebac .BytesPerLine ,_ebac .Data ,_ebac .Decode );};func (_gggb *Gray4 )At (x ,y int )_a .Color {_dbg ,_ :=_gggb .ColorAt (x ,y );
return _dbg };func _aeg (_edag _gb .Image )(Image ,error ){if _ded ,_gacd :=_edag .(*Gray16 );_gacd {return _ded .Copy (),nil ;};_deab :=_edag .Bounds ();_afed ,_eabb :=NewImage (_deab .Max .X ,_deab .Max .Y ,16,1,nil ,nil ,nil );if _eabb !=nil {return nil ,_eabb ;
};_aba (_edag ,_afed ,_deab );return _afed ,nil ;};func _fae (_badg Gray ,_ddca RGBA ,_dabc _gb .Rectangle ){for _eeag :=0;_eeag < _dabc .Max .X ;_eeag ++{for _defe :=0;_defe < _dabc .Max .Y ;_defe ++{_daga :=_badg .GrayAt (_eeag ,_defe );_ddca .SetRGBA (_eeag ,_defe ,_dfa (_daga ));
};};};func _ega (_ccb ,_bda CMYK ,_cbag _gb .Rectangle ){for _aga :=0;_aga < _cbag .Max .X ;_aga ++{for _gdga :=0;_gdga < _cbag .Max .Y ;_gdga ++{_bda .SetCMYK (_aga ,_gdga ,_ccb .CMYKAt (_aga ,_gdga ));};};};var _ _gb .Image =&Gray4 {};func _fgde (_agef _a .Color )_a .Color {_eacd :=_a .NRGBAModel .Convert (_agef ).(_a .NRGBA );
return _bbab (_eacd );};func (_gda *Monochrome )getBit (_cbca ,_fcbc int )uint8 {return _gda .Data [_cbca +(_fcbc >>3)]>>uint (7-(_fcbc &7))&1;};func _baeg (_afabd ,_bcga uint8 )uint8 {if _afabd < _bcga {return 255;};return 0;};func (_febd *NRGBA16 )At (x ,y int )_a .Color {_cfed ,_ :=_febd .ColorAt (x ,y );
return _cfed };func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_a .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );
case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_cb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};var (_dcd =_fef ();_dfb =_aea ();_eaa =_agb (););func (_ege *Monochrome )setGray (_fdbc int ,_dga _a .Gray ,_gdgc int ){if _dga .Y ==0{_ege .clearBit (_gdgc ,_fdbc );}else {_ege .setGrayBit (_gdgc ,_fdbc );};};func _aegg (_dcaa *Monochrome ,_gbbb ,_ccfg ,_eacc ,_bbbd int ,_aeec RasterOperator ,_ffef *Monochrome ,_fdgb ,_ecaef int )error {if _dcaa ==nil {return _f .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _aeec ==PixDst {return nil ;};switch _aeec {case PixClr ,PixSet ,PixNotDst :_dgdg (_dcaa ,_gbbb ,_ccfg ,_eacc ,_bbbd ,_aeec );return nil ;};if _ffef ==nil {_ag .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _f .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _gfcd :=_eccc (_dcaa ,_gbbb ,_ccfg ,_eacc ,_bbbd ,_aeec ,_ffef ,_fdgb ,_ecaef );_gfcd !=nil {return _gfcd ;};return nil ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};
func (_fgb *Monochrome )ResolveDecode ()error {if len (_fgb .Decode )!=2{return nil ;};if _fgb .Decode [0]==1&&_fgb .Decode [1]==0{if _gbee :=_fgb .InverseData ();_gbee !=nil {return _gbee ;};_fgb .Decode =nil ;};return nil ;};func _abaff (_gbfa _gb .Image ,_dbfe int )(_gb .Rectangle ,bool ,[]byte ){_caba :=_gbfa .Bounds ();
var (_bggd bool ;_agec []byte ;);switch _egbe :=_gbfa .(type ){case SMasker :_bggd =_egbe .HasAlpha ();case NRGBA ,RGBA ,*_gb .RGBA64 ,nrgba64 ,*_gb .NYCbCrA :_agec =make ([]byte ,_caba .Max .X *_caba .Max .Y *_dbfe );case *_gb .Paletted :if !_egbe .Opaque (){_agec =make ([]byte ,_caba .Max .X *_caba .Max .Y *_dbfe );
};};return _caba ,_bggd ,_agec ;};func _dcfa (){for _bcdb :=0;_bcdb < 256;_bcdb ++{_gaaga [_bcdb ]=uint8 (_bcdb &0x1)+(uint8 (_bcdb >>1)&0x1)+(uint8 (_bcdb >>2)&0x1)+(uint8 (_bcdb >>3)&0x1)+(uint8 (_bcdb >>4)&0x1)+(uint8 (_bcdb >>5)&0x1)+(uint8 (_bcdb >>6)&0x1)+(uint8 (_bcdb >>7)&0x1);
};};func _ffab (_aead _a .CMYK )_a .NRGBA {_cfabf ,_dgfd ,_adcb :=_a .CMYKToRGB (_aead .C ,_aead .M ,_aead .Y ,_aead .K );return _a .NRGBA {R :_cfabf ,G :_dgfd ,B :_adcb ,A :0xff};};func (_abdg *Gray8 )Histogram ()(_cae [256]int ){for _cgbg :=0;_cgbg < len (_abdg .Data );
_cgbg ++{_cae [_abdg .Data [_cgbg ]]++;};return _cae ;};func _ad (_da *Monochrome ,_aa int ,_fc []uint )(*Monochrome ,error ){_cf :=_aa *_da .Width ;_eb :=_aa *_da .Height ;_acb :=_gdb (_cf ,_eb );for _fb ,_fca :=range _fc {var _ca error ;switch _fca {case 2:_ca =_bef (_acb ,_da );
case 4:_ca =_fg (_acb ,_da );case 8:_ca =_df (_acb ,_da );};if _ca !=nil {return nil ,_ca ;};if _fb !=len (_fc )-1{_da =_acb .copy ();};};return _acb ,nil ;};func (_fbce *Gray4 )ColorModel ()_a .Model {return Gray4Model };func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA ,error ){_gabg :=y *bytesPerLine +x *3/2;
if _gabg +1>=len (data ){return _a .NRGBA {},_dcbc (x ,y );};const (_gcdf =0xf;_fcaa =uint8 (0xff););_bgba :=_fcaa ;if alpha !=nil {_ecacf :=y *BytesPerLine (width ,4,1);if _ecacf < len (alpha ){if x %2==0{_bgba =(alpha [_ecacf ]>>uint (4))&_gcdf ;}else {_bgba =alpha [_ecacf ]&_gcdf ;
};_bgba |=_bgba <<4;};};var _aade ,_afga ,_gdba uint8 ;if x *3%2==0{_aade =(data [_gabg ]>>uint (4))&_gcdf ;_afga =data [_gabg ]&_gcdf ;_gdba =(data [_gabg +1]>>uint (4))&_gcdf ;}else {_aade =data [_gabg ]&_gcdf ;_afga =(data [_gabg +1]>>uint (4))&_gcdf ;
_gdba =data [_gabg +1]&_gcdf ;};if len (decode )==6{_aade =uint8 (uint32 (LinearInterpolate (float64 (_aade ),0,15,decode [0],decode [1]))&0xf);_afga =uint8 (uint32 (LinearInterpolate (float64 (_afga ),0,15,decode [2],decode [3]))&0xf);_gdba =uint8 (uint32 (LinearInterpolate (float64 (_gdba ),0,15,decode [4],decode [5]))&0xf);
};return _a .NRGBA {R :(_aade <<4)|(_aade &0xf),G :(_afga <<4)|(_afga &0xf),B :(_gdba <<4)|(_gdba &0xf),A :_bgba },nil ;};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func _adebf (_deade RGBA ,_defa NRGBA ,_cdbd _gb .Rectangle ){for _fgdcd :=0;
_fgdcd < _cdbd .Max .X ;_fgdcd ++{for _feea :=0;_feea < _cdbd .Max .Y ;_feea ++{_cgac :=_deade .RGBAAt (_fgdcd ,_feea );_defa .SetNRGBA (_fgdcd ,_feea ,_ageb (_cgac ));};};};func _cfab (_gcdc _a .Gray )_a .NRGBA {return _a .NRGBA {R :_gcdc .Y ,G :_gcdc .Y ,B :_gcdc .Y ,A :0xff}};
func (_dgbe *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_dgbe .copy ()}};func (_afcf *Gray4 )SetGray (x ,y int ,g _a .Gray ){if x >=_afcf .Width ||y >=_afcf .Height {return ;};g =_add (g );_afcf .setGray (x ,y ,g );};var _ Image =&NRGBA16 {};func _bccd (_ecac RGBA ,_ccaa Gray ,_faa _gb .Rectangle ){for _fbgef :=0;
_fbgef < _faa .Max .X ;_fbgef ++{for _dbba :=0;_dbba < _faa .Max .Y ;_dbba ++{_egeg :=_gaad (_ecac .RGBAAt (_fbgef ,_dbba ));_ccaa .SetGray (_fbgef ,_dbba ,_egeg );};};};func (_fgfb *ImageBase )HasAlpha ()bool {if _fgfb .Alpha ==nil {return false ;};for _dcea :=range _fgfb .Alpha {if _fgfb .Alpha [_dcea ]!=0xff{return true ;
};};return false ;};type Gray8 struct{ImageBase };func (_cecg *ImageBase )setEightFullBytes (_egad int ,_dca uint64 )error {if _egad +7> len (_cecg .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_cecg .Data [_egad ]=byte ((_dca &0xff00000000000000)>>56);_cecg .Data [_egad +1]=byte ((_dca &0xff000000000000)>>48);_cecg .Data [_egad +2]=byte ((_dca &0xff0000000000)>>40);_cecg .Data [_egad +3]=byte ((_dca &0xff00000000)>>32);_cecg .Data [_egad +4]=byte ((_dca &0xff000000)>>24);
_cecg .Data [_egad +5]=byte ((_dca &0xff0000)>>16);_cecg .Data [_egad +6]=byte ((_dca &0xff00)>>8);_cecg .Data [_egad +7]=byte (_dca &0xff);return nil ;};func (_efdc *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _aegg (_efdc ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};type Gray2 struct{ImageBase };func _dgdg (_fbgb *Monochrome ,_afef ,_ecde ,_abed ,_fbed int ,_eade RasterOperator ){if _afef < 0{_abed +=_afef ;_afef =0;};_bfgbc :=_afef +_abed -_fbgb .Width ;if _bfgbc > 0{_abed -=_bfgbc ;};if _ecde < 0{_fbed +=_ecde ;
_ecde =0;};_ggdg :=_ecde +_fbed -_fbgb .Height ;if _ggdg > 0{_fbed -=_ggdg ;};if _abed <=0||_fbed <=0{return ;};if (_afef &7)==0{_addd (_fbgb ,_afef ,_ecde ,_abed ,_fbed ,_eade );}else {_gfbf (_fbgb ,_afef ,_ecde ,_abed ,_fbed ,_eade );};};func (_feb *Gray4 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray4BPC (x ,y ,_feb .BytesPerLine ,_feb .Data ,_feb .Decode );
};var _ Image =&Gray4 {};var _ Image =&NRGBA32 {};func _fbge (_aad ,_aadb int ,_dcg []byte )*Monochrome {_fefc :=_gdb (_aad ,_aadb );_fefc .Data =_dcg ;return _fefc ;};func (_ace *CMYK32 )At (x ,y int )_a .Color {_dgd ,_ :=_ace .ColorAt (x ,y );return _dgd };
func (_afb *Gray8 )SetGray (x ,y int ,g _a .Gray ){_gfce :=y *_afb .BytesPerLine +x ;if _gfce > len (_afb .Data )-1{return ;};_afb .Data [_gfce ]=g .Y ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_a .CMYK ,error ){_fgd :=4*(y *width +x );
if _fgd +3>=len (data ){return _a .CMYK {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_fgd ]&0xff;M :=data [_fgd +1]&0xff;Y :=data [_fgd +2]&0xff;K :=data [_fgd +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _a .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_aeggd *NRGBA32 )SetNRGBA (x ,y int ,c _a .NRGBA ){_beg :=y *_aeggd .Width +x ;
_cagf :=3*_beg ;if _cagf +2>=len (_aeggd .Data ){return ;};_aeggd .setRGBA (_beg ,c );};var _ Gray =&Gray16 {};func (_cfcc *ImageBase )setEightPartlyBytes (_cabe ,_bfcc int ,_gaab uint64 )(_gbb error ){var (_bcca byte ;_fbecg int ;);for _faga :=1;_faga <=_bfcc ;
_faga ++{_fbecg =64-_faga *8;_bcca =byte (_gaab >>uint (_fbecg )&0xff);if _gbb =_cfcc .setByte (_cabe +_faga -1,_bcca );_gbb !=nil {return _gbb ;};};_cac :=_cfcc .BytesPerLine *8-_cfcc .Width ;if _cac ==0{return nil ;};_fbecg -=8;_bcca =byte (_gaab >>uint (_fbecg )&0xff)<<uint (_cac );
if _gbb =_cfcc .setByte (_cabe +_bfcc ,_bcca );_gbb !=nil {return _gbb ;};return nil ;};func (_cede *NRGBA64 )NRGBA64At (x ,y int )_a .NRGBA64 {_bgeb ,_ :=ColorAtNRGBA64 (x ,y ,_cede .Width ,_cede .Data ,_cede .Alpha ,_cede .Decode );return _bgeb ;};func _fdc (_gbea *Monochrome ,_ccge ,_bebf ,_ebag ,_gggf int ,_bddf RasterOperator ,_fcf *Monochrome ,_bdg ,_dedg int )error {var (_dgfdb bool ;
_fgdc bool ;_cgce int ;_bbgbe int ;_fcbf int ;_gdfa bool ;_dbde byte ;_acgf int ;_ccgf int ;_bcdd int ;_edac ,_gbfc int ;);_cdb :=8-(_ccge &7);_cbbe :=_gdebc [_cdb ];_dcfc :=_gbea .BytesPerLine *_bebf +(_ccge >>3);_agba :=_fcf .BytesPerLine *_dedg +(_bdg >>3);
if _ebag < _cdb {_dgfdb =true ;_cbbe &=_cgdf [8-_cdb +_ebag ];};if !_dgfdb {_cgce =(_ebag -_cdb )>>3;if _cgce > 0{_fgdc =true ;_bbgbe =_dcfc +1;_fcbf =_agba +1;};};_acgf =(_ccge +_ebag )&7;if !(_dgfdb ||_acgf ==0){_gdfa =true ;_dbde =_cgdf [_acgf ];_ccgf =_dcfc +1+_cgce ;
_bcdd =_agba +1+_cgce ;};switch _bddf {case PixSrc :for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],_fcf .Data [_agba ],_cbbe );_dcfc +=_gbea .BytesPerLine ;_agba +=_fcf .BytesPerLine ;};if _fgdc {for _edac =0;_edac < _gggf ;
_edac ++{for _gbfc =0;_gbfc < _cgce ;_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]=_fcf .Data [_fcbf +_gbfc ];};_bbgbe +=_gbea .BytesPerLine ;_fcbf +=_fcf .BytesPerLine ;};};if _gdfa {for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],_fcf .Data [_bcdd ],_dbde );
_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;};};case PixNotSrc :for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],^_fcf .Data [_agba ],_cbbe );_dcfc +=_gbea .BytesPerLine ;_agba +=_fcf .BytesPerLine ;};if _fgdc {for _edac =0;
_edac < _gggf ;_edac ++{for _gbfc =0;_gbfc < _cgce ;_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]=^_fcf .Data [_fcbf +_gbfc ];};_bbgbe +=_gbea .BytesPerLine ;_fcbf +=_fcf .BytesPerLine ;};};if _gdfa {for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],^_fcf .Data [_bcdd ],_dbde );
_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;};};case PixSrcOrDst :for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],_fcf .Data [_agba ]|_gbea .Data [_dcfc ],_cbbe );_dcfc +=_gbea .BytesPerLine ;_agba +=_fcf .BytesPerLine ;
};if _fgdc {for _edac =0;_edac < _gggf ;_edac ++{for _gbfc =0;_gbfc < _cgce ;_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]|=_fcf .Data [_fcbf +_gbfc ];};_bbgbe +=_gbea .BytesPerLine ;_fcbf +=_fcf .BytesPerLine ;};};if _gdfa {for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],_fcf .Data [_bcdd ]|_gbea .Data [_ccgf ],_dbde );
_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;};};case PixSrcAndDst :for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],_fcf .Data [_agba ]&_gbea .Data [_dcfc ],_cbbe );_dcfc +=_gbea .BytesPerLine ;_agba +=_fcf .BytesPerLine ;
};if _fgdc {for _edac =0;_edac < _gggf ;_edac ++{for _gbfc =0;_gbfc < _cgce ;_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]&=_fcf .Data [_fcbf +_gbfc ];};_bbgbe +=_gbea .BytesPerLine ;_fcbf +=_fcf .BytesPerLine ;};};if _gdfa {for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],_fcf .Data [_bcdd ]&_gbea .Data [_ccgf ],_dbde );
_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;};};case PixSrcXorDst :for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],_fcf .Data [_agba ]^_gbea .Data [_dcfc ],_cbbe );_dcfc +=_gbea .BytesPerLine ;_agba +=_fcf .BytesPerLine ;
};if _fgdc {for _edac =0;_edac < _gggf ;_edac ++{for _gbfc =0;_gbfc < _cgce ;_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]^=_fcf .Data [_fcbf +_gbfc ];};_bbgbe +=_gbea .BytesPerLine ;_fcbf +=_fcf .BytesPerLine ;};};if _gdfa {for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],_fcf .Data [_bcdd ]^_gbea .Data [_ccgf ],_dbde );
_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;};};case PixNotSrcOrDst :for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],^(_fcf .Data [_agba ])|_gbea .Data [_dcfc ],_cbbe );_dcfc +=_gbea .BytesPerLine ;_agba +=_fcf .BytesPerLine ;
};if _fgdc {for _edac =0;_edac < _gggf ;_edac ++{for _gbfc =0;_gbfc < _cgce ;_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]|=^(_fcf .Data [_fcbf +_gbfc ]);};_bbgbe +=_gbea .BytesPerLine ;_fcbf +=_fcf .BytesPerLine ;};};if _gdfa {for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],^(_fcf .Data [_bcdd ])|_gbea .Data [_ccgf ],_dbde );
_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;};};case PixNotSrcAndDst :for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],^(_fcf .Data [_agba ])&_gbea .Data [_dcfc ],_cbbe );_dcfc +=_gbea .BytesPerLine ;_agba +=_fcf .BytesPerLine ;
};if _fgdc {for _edac =0;_edac < _gggf ;_edac ++{for _gbfc =0;_gbfc < _cgce ;_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]&=^_fcf .Data [_fcbf +_gbfc ];};_bbgbe +=_gbea .BytesPerLine ;_fcbf +=_fcf .BytesPerLine ;};};if _gdfa {for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],^(_fcf .Data [_bcdd ])&_gbea .Data [_ccgf ],_dbde );
_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;};};case PixSrcOrNotDst :for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],_fcf .Data [_agba ]|^(_gbea .Data [_dcfc ]),_cbbe );_dcfc +=_gbea .BytesPerLine ;_agba +=_fcf .BytesPerLine ;
};if _fgdc {for _edac =0;_edac < _gggf ;_edac ++{for _gbfc =0;_gbfc < _cgce ;_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]=_fcf .Data [_fcbf +_gbfc ]|^(_gbea .Data [_bbgbe +_gbfc ]);};_bbgbe +=_gbea .BytesPerLine ;_fcbf +=_fcf .BytesPerLine ;};};if _gdfa {for _edac =0;
_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],_fcf .Data [_bcdd ]|^(_gbea .Data [_ccgf ]),_dbde );_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;};};case PixSrcAndNotDst :for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],_fcf .Data [_agba ]&^(_gbea .Data [_dcfc ]),_cbbe );
_dcfc +=_gbea .BytesPerLine ;_agba +=_fcf .BytesPerLine ;};if _fgdc {for _edac =0;_edac < _gggf ;_edac ++{for _gbfc =0;_gbfc < _cgce ;_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]=_fcf .Data [_fcbf +_gbfc ]&^(_gbea .Data [_bbgbe +_gbfc ]);};_bbgbe +=_gbea .BytesPerLine ;
_fcbf +=_fcf .BytesPerLine ;};};if _gdfa {for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],_fcf .Data [_bcdd ]&^(_gbea .Data [_ccgf ]),_dbde );_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;};};case PixNotPixSrcOrDst :for _edac =0;
_edac < _gggf ;_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],^(_fcf .Data [_agba ]|_gbea .Data [_dcfc ]),_cbbe );_dcfc +=_gbea .BytesPerLine ;_agba +=_fcf .BytesPerLine ;};if _fgdc {for _edac =0;_edac < _gggf ;_edac ++{for _gbfc =0;_gbfc < _cgce ;
_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]=^(_fcf .Data [_fcbf +_gbfc ]|_gbea .Data [_bbgbe +_gbfc ]);};_bbgbe +=_gbea .BytesPerLine ;_fcbf +=_fcf .BytesPerLine ;};};if _gdfa {for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],^(_fcf .Data [_bcdd ]|_gbea .Data [_ccgf ]),_dbde );
_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;};};case PixNotPixSrcAndDst :for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],^(_fcf .Data [_agba ]&_gbea .Data [_dcfc ]),_cbbe );_dcfc +=_gbea .BytesPerLine ;
_agba +=_fcf .BytesPerLine ;};if _fgdc {for _edac =0;_edac < _gggf ;_edac ++{for _gbfc =0;_gbfc < _cgce ;_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]=^(_fcf .Data [_fcbf +_gbfc ]&_gbea .Data [_bbgbe +_gbfc ]);};_bbgbe +=_gbea .BytesPerLine ;_fcbf +=_fcf .BytesPerLine ;
};};if _gdfa {for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],^(_fcf .Data [_bcdd ]&_gbea .Data [_ccgf ]),_dbde );_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;};};case PixNotPixSrcXorDst :for _edac =0;_edac < _gggf ;
_edac ++{_gbea .Data [_dcfc ]=_dfbf (_gbea .Data [_dcfc ],^(_fcf .Data [_agba ]^_gbea .Data [_dcfc ]),_cbbe );_dcfc +=_gbea .BytesPerLine ;_agba +=_fcf .BytesPerLine ;};if _fgdc {for _edac =0;_edac < _gggf ;_edac ++{for _gbfc =0;_gbfc < _cgce ;_gbfc ++{_gbea .Data [_bbgbe +_gbfc ]=^(_fcf .Data [_fcbf +_gbfc ]^_gbea .Data [_bbgbe +_gbfc ]);
};_bbgbe +=_gbea .BytesPerLine ;_fcbf +=_fcf .BytesPerLine ;};};if _gdfa {for _edac =0;_edac < _gggf ;_edac ++{_gbea .Data [_ccgf ]=_dfbf (_gbea .Data [_ccgf ],^(_fcf .Data [_bcdd ]^_gbea .Data [_ccgf ]),_dbde );_ccgf +=_gbea .BytesPerLine ;_bcdd +=_fcf .BytesPerLine ;
};};default:_ag .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_bddf );return _f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _adcd (_ecccf *Monochrome ,_cfcb ,_fbafc ,_aabg ,_fdff int ,_cecge RasterOperator ,_efef *Monochrome ,_fada ,_becc int )error {var (_ebbb bool ;_gbeag bool ;_ebagg byte ;_ecg int ;_ccfcf int ;_ddad int ;_ccca int ;_ddfga bool ;_fabcc int ;
_egag int ;_bbbe int ;_becf bool ;_ged byte ;_dadfg int ;_cbbf int ;_ecbf int ;_bgca byte ;_egge int ;_aafd int ;_eagg uint ;_bbccb uint ;_cfcg byte ;_bddc shift ;_cdde bool ;_cggd bool ;_egagc ,_ceac int ;);if _fada &7!=0{_aafd =8-(_fada &7);};if _cfcb &7!=0{_ccfcf =8-(_cfcb &7);
};if _aafd ==0&&_ccfcf ==0{_cfcg =_gdebc [0];}else {if _ccfcf > _aafd {_eagg =uint (_ccfcf -_aafd );}else {_eagg =uint (8-(_aafd -_ccfcf ));};_bbccb =8-_eagg ;_cfcg =_gdebc [_eagg ];};if (_cfcb &7)!=0{_ebbb =true ;_ecg =8-(_cfcb &7);_ebagg =_gdebc [_ecg ];
_ddad =_ecccf .BytesPerLine *_fbafc +(_cfcb >>3);_ccca =_efef .BytesPerLine *_becc +(_fada >>3);_egge =8-(_fada &7);if _ecg > _egge {_bddc =_cega ;if _aabg >=_aafd {_cdde =true ;};}else {_bddc =_fdgc ;};};if _aabg < _ecg {_gbeag =true ;_ebagg &=_cgdf [8-_ecg +_aabg ];
};if !_gbeag {_fabcc =(_aabg -_ecg )>>3;if _fabcc !=0{_ddfga =true ;_egag =_ecccf .BytesPerLine *_fbafc +((_cfcb +_ccfcf )>>3);_bbbe =_efef .BytesPerLine *_becc +((_fada +_ccfcf )>>3);};};_dadfg =(_cfcb +_aabg )&7;if !(_gbeag ||_dadfg ==0){_becf =true ;
_ged =_cgdf [_dadfg ];_cbbf =_ecccf .BytesPerLine *_fbafc +((_cfcb +_ccfcf )>>3)+_fabcc ;_ecbf =_efef .BytesPerLine *_becc +((_fada +_ccfcf )>>3)+_fabcc ;if _dadfg > int (_bbccb ){_cggd =true ;};};switch _cecge {case PixSrc :if _ebbb {for _egagc =0;_egagc < _fdff ;
_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],_bgca ,_ebagg );_ddad +=_ecccf .BytesPerLine ;
_ccca +=_efef .BytesPerLine ;};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;_ceac < _fabcc ;_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );_ecccf .Data [_egag +_ceac ]=_bgca ;
};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};};if _becf {for _egagc =0;_egagc < _fdff ;_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],_bgca ,_ged );
_cbbf +=_ecccf .BytesPerLine ;_ecbf +=_efef .BytesPerLine ;};};case PixNotSrc :if _ebbb {for _egagc =0;_egagc < _fdff ;_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );
};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],^_bgca ,_ebagg );_ddad +=_ecccf .BytesPerLine ;_ccca +=_efef .BytesPerLine ;};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;_ceac < _fabcc ;
_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );_ecccf .Data [_egag +_ceac ]=^_bgca ;};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};};if _becf {for _egagc =0;_egagc < _fdff ;_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;
if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],^_bgca ,_ged );_cbbf +=_ecccf .BytesPerLine ;_ecbf +=_efef .BytesPerLine ;};};case PixSrcOrDst :if _ebbb {for _egagc =0;_egagc < _fdff ;
_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],_bgca |_ecccf .Data [_ddad ],_ebagg );
_ddad +=_ecccf .BytesPerLine ;_ccca +=_efef .BytesPerLine ;};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;_ceac < _fabcc ;_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );_ecccf .Data [_egag +_ceac ]|=_bgca ;
};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};};if _becf {for _egagc =0;_egagc < _fdff ;_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],_bgca |_ecccf .Data [_cbbf ],_ged );
_cbbf +=_ecccf .BytesPerLine ;_ecbf +=_efef .BytesPerLine ;};};case PixSrcAndDst :if _ebbb {for _egagc =0;_egagc < _fdff ;_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );
};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],_bgca &_ecccf .Data [_ddad ],_ebagg );_ddad +=_ecccf .BytesPerLine ;_ccca +=_efef .BytesPerLine ;};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;
_ceac < _fabcc ;_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );_ecccf .Data [_egag +_ceac ]&=_bgca ;};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};};if _becf {for _egagc =0;_egagc < _fdff ;
_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],_bgca &_ecccf .Data [_cbbf ],_ged );_cbbf +=_ecccf .BytesPerLine ;_ecbf +=_efef .BytesPerLine ;
};};case PixSrcXorDst :if _ebbb {for _egagc =0;_egagc < _fdff ;_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],_bgca ^_ecccf .Data [_ddad ],_ebagg );
_ddad +=_ecccf .BytesPerLine ;_ccca +=_efef .BytesPerLine ;};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;_ceac < _fabcc ;_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );_ecccf .Data [_egag +_ceac ]^=_bgca ;
};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};};if _becf {for _egagc =0;_egagc < _fdff ;_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],_bgca ^_ecccf .Data [_cbbf ],_ged );
_cbbf +=_ecccf .BytesPerLine ;_ecbf +=_efef .BytesPerLine ;};};case PixNotSrcOrDst :if _ebbb {for _egagc =0;_egagc < _fdff ;_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );
};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],^_bgca |_ecccf .Data [_ddad ],_ebagg );_ddad +=_ecccf .BytesPerLine ;_ccca +=_efef .BytesPerLine ;};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;
_ceac < _fabcc ;_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );_ecccf .Data [_egag +_ceac ]|=^_bgca ;};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};};if _becf {for _egagc =0;_egagc < _fdff ;
_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],^_bgca |_ecccf .Data [_cbbf ],_ged );_cbbf +=_ecccf .BytesPerLine ;_ecbf +=_efef .BytesPerLine ;
};};case PixNotSrcAndDst :if _ebbb {for _egagc =0;_egagc < _fdff ;_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],^_bgca &_ecccf .Data [_ddad ],_ebagg );
_ddad +=_ecccf .BytesPerLine ;_ccca +=_efef .BytesPerLine ;};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;_ceac < _fabcc ;_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );_ecccf .Data [_egag +_ceac ]&=^_bgca ;
};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};};if _becf {for _egagc =0;_egagc < _fdff ;_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],^_bgca &_ecccf .Data [_cbbf ],_ged );
_cbbf +=_ecccf .BytesPerLine ;_ecbf +=_efef .BytesPerLine ;};};case PixSrcOrNotDst :if _ebbb {for _egagc =0;_egagc < _fdff ;_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );
};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],_bgca |^_ecccf .Data [_ddad ],_ebagg );_ddad +=_ecccf .BytesPerLine ;_ccca +=_efef .BytesPerLine ;};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;
_ceac < _fabcc ;_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );_ecccf .Data [_egag +_ceac ]=_bgca |^_ecccf .Data [_egag +_ceac ];};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};};
if _becf {for _egagc =0;_egagc < _fdff ;_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],_bgca |^_ecccf .Data [_cbbf ],_ged );_cbbf +=_ecccf .BytesPerLine ;
_ecbf +=_efef .BytesPerLine ;};};case PixSrcAndNotDst :if _ebbb {for _egagc =0;_egagc < _fdff ;_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;
};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],_bgca &^_ecccf .Data [_ddad ],_ebagg );_ddad +=_ecccf .BytesPerLine ;_ccca +=_efef .BytesPerLine ;};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;_ceac < _fabcc ;_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );
_ecccf .Data [_egag +_ceac ]=_bgca &^_ecccf .Data [_egag +_ceac ];};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};};if _becf {for _egagc =0;_egagc < _fdff ;_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );
};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],_bgca &^_ecccf .Data [_cbbf ],_ged );_cbbf +=_ecccf .BytesPerLine ;_ecbf +=_efef .BytesPerLine ;};};case PixNotPixSrcOrDst :if _ebbb {for _egagc =0;_egagc < _fdff ;_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;
if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],^(_bgca |_ecccf .Data [_ddad ]),_ebagg );_ddad +=_ecccf .BytesPerLine ;_ccca +=_efef .BytesPerLine ;
};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;_ceac < _fabcc ;_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );_ecccf .Data [_egag +_ceac ]=^(_bgca |_ecccf .Data [_egag +_ceac ]);
};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};};if _becf {for _egagc =0;_egagc < _fdff ;_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],^(_bgca |_ecccf .Data [_cbbf ]),_ged );
_cbbf +=_ecccf .BytesPerLine ;_ecbf +=_efef .BytesPerLine ;};};case PixNotPixSrcAndDst :if _ebbb {for _egagc =0;_egagc < _fdff ;_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );
};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],^(_bgca &_ecccf .Data [_ddad ]),_ebagg );_ddad +=_ecccf .BytesPerLine ;_ccca +=_efef .BytesPerLine ;};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;
_ceac < _fabcc ;_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );_ecccf .Data [_egag +_ceac ]=^(_bgca &_ecccf .Data [_egag +_ceac ]);};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};
};if _becf {for _egagc =0;_egagc < _fdff ;_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],^(_bgca &_ecccf .Data [_cbbf ]),_ged );_cbbf +=_ecccf .BytesPerLine ;
_ecbf +=_efef .BytesPerLine ;};};case PixNotPixSrcXorDst :if _ebbb {for _egagc =0;_egagc < _fdff ;_egagc ++{if _bddc ==_cega {_bgca =_efef .Data [_ccca ]<<_eagg ;if _cdde {_bgca =_dfbf (_bgca ,_efef .Data [_ccca +1]>>_bbccb ,_cfcg );};}else {_bgca =_efef .Data [_ccca ]>>_bbccb ;
};_ecccf .Data [_ddad ]=_dfbf (_ecccf .Data [_ddad ],^(_bgca ^_ecccf .Data [_ddad ]),_ebagg );_ddad +=_ecccf .BytesPerLine ;_ccca +=_efef .BytesPerLine ;};};if _ddfga {for _egagc =0;_egagc < _fdff ;_egagc ++{for _ceac =0;_ceac < _fabcc ;_ceac ++{_bgca =_dfbf (_efef .Data [_bbbe +_ceac ]<<_eagg ,_efef .Data [_bbbe +_ceac +1]>>_bbccb ,_cfcg );
_ecccf .Data [_egag +_ceac ]=^(_bgca ^_ecccf .Data [_egag +_ceac ]);};_egag +=_ecccf .BytesPerLine ;_bbbe +=_efef .BytesPerLine ;};};if _becf {for _egagc =0;_egagc < _fdff ;_egagc ++{_bgca =_efef .Data [_ecbf ]<<_eagg ;if _cggd {_bgca =_dfbf (_bgca ,_efef .Data [_ecbf +1]>>_bbccb ,_cfcg );
};_ecccf .Data [_cbbf ]=_dfbf (_ecccf .Data [_cbbf ],^(_bgca ^_ecccf .Data [_cbbf ]),_ged );_cbbf +=_ecccf .BytesPerLine ;_ecbf +=_efef .BytesPerLine ;};};default:_ag .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_cecge );
return _f .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func (_ddg *NRGBA16 )Base ()*ImageBase {return &_ddg .ImageBase };
func (_fddg *NRGBA64 )Set (x ,y int ,c _a .Color ){_aaaf :=(y *_fddg .Width +x )*2;_aeae :=_aaaf *3;if _aeae +5>=len (_fddg .Data ){return ;};_fgg :=_a .NRGBA64Model .Convert (c ).(_a .NRGBA64 );_fddg .setNRGBA64 (_aeae ,_fgg ,_aaaf );};func _dfbf (_bfec ,_dcdda ,_eacg byte )byte {return (_bfec &^(_eacg ))|(_dcdda &_eacg )};
func _bbadd (_eccb Gray ,_fbbf NRGBA ,_gabb _gb .Rectangle ){for _dcgf :=0;_dcgf < _gabb .Max .X ;_dcgf ++{for _gedg :=0;_gedg < _gabb .Max .Y ;_gedg ++{_adafa :=_eccb .GrayAt (_dcgf ,_gedg );_fbbf .SetNRGBA (_dcgf ,_gedg ,_cfab (_adafa ));};};};func (_ebfa *Gray2 )Set (x ,y int ,c _a .Color ){if x >=_ebfa .Width ||y >=_ebfa .Height {return ;
};_aee :=Gray2Model .Convert (c ).(_a .Gray );_ffbf :=y *_ebfa .BytesPerLine ;_adebc :=_ffbf +(x >>2);_fde :=_aee .Y >>6;_ebfa .Data [_adebc ]=(_ebfa .Data [_adebc ]&(^(0xc0>>uint (2*((x )&3)))))|(_fde <<uint (6-2*(x &3)));};func _fdbf (_bfe _a .NRGBA64 )_a .Gray {var _dcb _a .NRGBA64 ;
if _bfe ==_dcb {return _a .Gray {Y :0xff};};_ebae ,_eaf ,_dfgf ,_ :=_bfe .RGBA ();_bec :=(19595*_ebae +38470*_eaf +7471*_dfgf +1<<15)>>24;return _a .Gray {Y :uint8 (_bec )};};func (_ffea *RGBA32 )setRGBA (_ffgb int ,_aecbb _a .RGBA ){_bffe :=3*_ffgb ;_ffea .Data [_bffe ]=_aecbb .R ;
_ffea .Data [_bffe +1]=_aecbb .G ;_ffea .Data [_bffe +2]=_aecbb .B ;if _ffgb < len (_ffea .Alpha ){_ffea .Alpha [_ffgb ]=_aecbb .A ;};};func (_aacd *Gray16 )Histogram ()(_dcdfg [256]int ){for _gaba :=0;_gaba < _aacd .Width ;_gaba ++{for _gafc :=0;_gafc < _aacd .Height ;
_gafc ++{_dcdfg [_aacd .GrayAt (_gaba ,_gafc ).Y ]++;};};return _dcdfg ;};var _ Gray =&Gray8 {};var _gaaga [256]uint8 ;var _ _gb .Image =&Gray2 {};func _affb (_cgg _a .NRGBA )_a .CMYK {_fcgc ,_fdf ,_aeac ,_ :=_cgg .RGBA ();_dgee ,_cbed ,_aec ,_afd :=_a .RGBToCMYK (uint8 (_fcgc >>8),uint8 (_fdf >>8),uint8 (_aeac >>8));
return _a .CMYK {C :_dgee ,M :_cbed ,Y :_aec ,K :_afd };};func InDelta (expected ,current ,delta float64 )bool {_cgaf :=expected -current ;if _cgaf <=-delta ||_cgaf >=delta {return false ;};return true ;};func _gdb (_fff ,_ce int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_fff ,_ce ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};func (_geef *NRGBA16 )setNRGBA (_dcbf ,_dgcfb ,_dege int ,_fbd _a .NRGBA ){if _dcbf *3%2==0{_geef .Data [_dege ]=(_fbd .R >>4)<<4|(_fbd .G >>4);_geef .Data [_dege +1]=(_fbd .B >>4)<<4|(_geef .Data [_dege +1]&0xf);}else {_geef .Data [_dege ]=(_geef .Data [_dege ]&0xf0)|(_fbd .R >>4);
_geef .Data [_dege +1]=(_fbd .G >>4)<<4|(_fbd .B >>4);};if _geef .Alpha !=nil {_fbgcf :=_dgcfb *BytesPerLine (_geef .Width ,4,1);if _fbgcf < len (_geef .Alpha ){if _dcbf %2==0{_geef .Alpha [_fbgcf ]=(_fbd .A >>uint (4))<<uint (4)|(_geef .Alpha [_dege ]&0xf);
}else {_geef .Alpha [_fbgcf ]=(_geef .Alpha [_fbgcf ]&0xf0)|(_fbd .A >>uint (4));};};};};func (_adde *NRGBA64 )SetNRGBA64 (x ,y int ,c _a .NRGBA64 ){_dcgd :=(y *_adde .Width +x )*2;_egga :=_dcgd *3;if _egga +5>=len (_adde .Data ){return ;};_adde .setNRGBA64 (_egga ,c ,_dcgd );
};type monochromeModel uint8 ;func (_bfgb *ImageBase )newAlpha (){_abfb :=BytesPerLine (_bfgb .Width ,_bfgb .BitsPerComponent ,1);_bfgb .Alpha =make ([]byte ,_bfgb .Height *_abfb );};func (_ceee *NRGBA16 )SetNRGBA (x ,y int ,c _a .NRGBA ){_fbgcd :=y *_ceee .BytesPerLine +x *3/2;
if _fbgcd +1>=len (_ceee .Data ){return ;};c =_bbab (c );_ceee .setNRGBA (x ,y ,_fbgcd ,c );};func (_gafae *NRGBA64 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_gafae .Width ,Y :_gafae .Height }};};func (_dgddg *NRGBA16 )NRGBAAt (x ,y int )_a .NRGBA {_bdgf ,_ :=ColorAtNRGBA16 (x ,y ,_dgddg .Width ,_dgddg .BytesPerLine ,_dgddg .Data ,_dgddg .Alpha ,_dgddg .Decode );
return _bdgf ;};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _aegg (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_gbgb *NRGBA32 )ColorModel ()_a .Model {return _a .NRGBAModel };
func _dab (_egb ,_gbe *Monochrome ,_geg []byte ,_cfb int )(_dd error ){var (_dgb ,_bff ,_eeb ,_cbcb ,_daa ,_daed ,_adgg ,_fee int ;_daf ,_bfcd ,_ddf ,_geb uint32 ;_cee ,_ccfc byte ;_bag uint16 ;);_agf :=make ([]byte ,4);_bfg :=make ([]byte ,4);for _eeb =0;
_eeb < _egb .Height -1;_eeb ,_cbcb =_eeb +2,_cbcb +1{_dgb =_eeb *_egb .BytesPerLine ;_bff =_cbcb *_gbe .BytesPerLine ;for _daa ,_daed =0,0;_daa < _cfb ;_daa ,_daed =_daa +4,_daed +1{for _adgg =0;_adgg < 4;_adgg ++{_fee =_dgb +_daa +_adgg ;if _fee <=len (_egb .Data )-1&&_fee < _dgb +_egb .BytesPerLine {_agf [_adgg ]=_egb .Data [_fee ];
}else {_agf [_adgg ]=0x00;};_fee =_dgb +_egb .BytesPerLine +_daa +_adgg ;if _fee <=len (_egb .Data )-1&&_fee < _dgb +(2*_egb .BytesPerLine ){_bfg [_adgg ]=_egb .Data [_fee ];}else {_bfg [_adgg ]=0x00;};};_daf =_c .BigEndian .Uint32 (_agf );_bfcd =_c .BigEndian .Uint32 (_bfg );
_ddf =_daf &_bfcd ;_ddf |=_ddf <<1;_geb =_daf |_bfcd ;_geb &=_geb <<1;_bfcd =_ddf |_geb ;_bfcd &=0xaaaaaaaa;_daf =_bfcd |(_bfcd <<7);_cee =byte (_daf >>24);_ccfc =byte ((_daf >>8)&0xff);_fee =_bff +_daed ;if _fee +1==len (_gbe .Data )-1||_fee +1>=_bff +_gbe .BytesPerLine {if _dd =_gbe .setByte (_fee ,_geg [_cee ]);
_dd !=nil {return _cb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fee );};}else {_bag =(uint16 (_geg [_cee ])<<8)|uint16 (_geg [_ccfc ]);if _dd =_gbe .setTwoBytes (_fee ,_bag );_dd !=nil {return _cb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fee );
};_daed ++;};};};return nil ;};func (_gead *Monochrome )At (x ,y int )_a .Color {_ffgd ,_ :=_gead .ColorAt (x ,y );return _ffgd };func _dfc (_ddeb _a .NYCbCrA )_a .NRGBA {_ccfb :=int32 (_ddeb .Y )*0x10101;_bcf :=int32 (_ddeb .Cb )-128;_dce :=int32 (_ddeb .Cr )-128;
_dbe :=_ccfb +91881*_dce ;if uint32 (_dbe )&0xff000000==0{_dbe >>=8;}else {_dbe =^(_dbe >>31)&0xffff;};_abf :=_ccfb -22554*_bcf -46802*_dce ;if uint32 (_abf )&0xff000000==0{_abf >>=8;}else {_abf =^(_abf >>31)&0xffff;};_cfgf :=_ccfb +116130*_bcf ;if uint32 (_cfgf )&0xff000000==0{_cfgf >>=8;
}else {_cfgf =^(_cfgf >>31)&0xffff;};return _a .NRGBA {R :uint8 (_dbe >>8),G :uint8 (_abf >>8),B :uint8 (_cfgf >>8),A :_ddeb .A };};func _gegg (_cgf _gb .Image ,_aef Image ,_fcb _gb .Rectangle ){for _decc :=0;_decc < _fcb .Max .X ;_decc ++{for _cbcg :=0;
_cbcg < _fcb .Max .Y ;_cbcg ++{_beac :=_cgf .At (_decc ,_cbcg );_aef .Set (_decc ,_cbcg ,_beac );};};};func _bef (_fba ,_cag *Monochrome )(_ee error ){_gd :=_cag .BytesPerLine ;_age :=_fba .BytesPerLine ;var (_ebd byte ;_eg uint16 ;_ebdg ,_eff ,_cg ,_fe ,_gdg int ;
);for _cg =0;_cg < _cag .Height ;_cg ++{_ebdg =_cg *_gd ;_eff =2*_cg *_age ;for _fe =0;_fe < _gd ;_fe ++{_ebd =_cag .Data [_ebdg +_fe ];_eg =_dcd [_ebd ];_gdg =_eff +_fe *2;if _fba .BytesPerLine !=_cag .BytesPerLine *2&&(_fe +1)*2> _fba .BytesPerLine {_ee =_fba .setByte (_gdg ,byte (_eg >>8));
}else {_ee =_fba .setTwoBytes (_gdg ,_eg );};if _ee !=nil {return _ee ;};};for _fe =0;_fe < _age ;_fe ++{_gdg =_eff +_age +_fe ;_ebd =_fba .Data [_eff +_fe ];if _ee =_fba .setByte (_gdg ,_ebd );_ee !=nil {return _ee ;};};};return nil ;};func (_gdef *Monochrome )setBit (_dcdbe ,_cfc int ){_gdef .Data [_dcdbe +(_cfc >>3)]|=0x80>>uint (_cfc &7);
};func (_bbbf *RGBA32 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_bbbf .Width ,Y :_bbbf .Height }};};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_agbg :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _agbg ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_gagg :=width *colorComponents *bitsPerComponent ;_cfadb :=_agbg *8;_fbabf :=8-(_cfadb -_gagg );_aebg :=_ac .NewReader (data );_deccf :=_agbg -1;_gfgc :=make ([]byte ,_deccf );_dag :=make ([]byte ,height *_agbg );
_dbaf :=_ac .NewWriterMSB (_dag );var _fdbb uint64 ;var _eggce error ;for _cecgg :=0;_cecgg < height ;_cecgg ++{_ ,_eggce =_aebg .Read (_gfgc );if _eggce !=nil {return nil ,_eggce ;};_ ,_eggce =_dbaf .Write (_gfgc );if _eggce !=nil {return nil ,_eggce ;
};_fdbb ,_eggce =_aebg .ReadBits (byte (_fbabf ));if _eggce !=nil {return nil ,_eggce ;};_ ,_eggce =_dbaf .WriteBits (_fdbb ,_fbabf );if _eggce !=nil {return nil ,_eggce ;};_dbaf .FinishByte ();};return _dag ,nil ;};func _gfeb (_ggca _a .RGBA )_a .CMYK {_dacc ,_gfccd ,_aab ,_ecb :=_a .RGBToCMYK (_ggca .R ,_ggca .G ,_ggca .B );
return _a .CMYK {C :_dacc ,M :_gfccd ,Y :_aab ,K :_ecb };};func _cgba (_bdc ,_gbeg NRGBA ,_dgdad _gb .Rectangle ){for _bbec :=0;_bbec < _dgdad .Max .X ;_bbec ++{for _cbgg :=0;_cbgg < _dgdad .Max .Y ;_cbgg ++{_gbeg .SetNRGBA (_bbec ,_cbgg ,_bdc .NRGBAAt (_bbec ,_cbgg ));
};};};func _eaeb (_gebab CMYK ,_ddcb RGBA ,_dcdc _gb .Rectangle ){for _fbdf :=0;_fbdf < _dcdc .Max .X ;_fbdf ++{for _bgeda :=0;_bgeda < _dcdc .Max .Y ;_bgeda ++{_eecff :=_gebab .CMYKAt (_fbdf ,_bgeda );_ddcb .SetRGBA (_fbdf ,_bgeda ,_ccab (_eecff ));};
};};func _df (_aaf ,_bbb *Monochrome )(_acd error ){_gc :=_bbb .BytesPerLine ;_gde :=_aaf .BytesPerLine ;var _cc ,_dg ,_adg ,_aagf ,_fbaa int ;for _adg =0;_adg < _bbb .Height ;_adg ++{_cc =_adg *_gc ;_dg =8*_adg *_gde ;for _aagf =0;_aagf < _gc ;_aagf ++{if _acd =_aaf .setEightBytes (_dg +_aagf *8,_eaa [_bbb .Data [_cc +_aagf ]]);
_acd !=nil {return _acd ;};};for _fbaa =1;_fbaa < 8;_fbaa ++{for _aagf =0;_aagf < _gde ;_aagf ++{if _acd =_aaf .setByte (_dg +_fbaa *_gde +_aagf ,_aaf .Data [_dg +_aagf ]);_acd !=nil {return _acd ;};};};};return nil ;};func ImgToBinary (i _gb .Image ,threshold uint8 )*_gb .Gray {switch _degac :=i .(type ){case *_gb .Gray :if _becgc (_degac ){return _degac ;
};return _cedf (_degac ,threshold );case *_gb .Gray16 :return _dbac (_degac ,threshold );default:return _gbcfg (_degac ,threshold );};};func _cedf (_gcef *_gb .Gray ,_adfgb uint8 )*_gb .Gray {_gafe :=_gcef .Bounds ();_cdgga :=_gb .NewGray (_gafe );for _fcef :=0;
_fcef < _gafe .Dx ();_fcef ++{for _dedc :=0;_dedc < _gafe .Dy ();_dedc ++{_ffad :=_gcef .GrayAt (_fcef ,_dedc );_cdgga .SetGray (_fcef ,_dedc ,_a .Gray {Y :_baeg (_ffad .Y ,_adfgb )});};};return _cdgga ;};func _cecf (_ebdd _gb .Image )(Image ,error ){if _dbbe ,_abc :=_ebdd .(*NRGBA16 );
_abc {return _dbbe .Copy (),nil ;};_cdbc :=_ebdd .Bounds ();_gecb ,_bgaa :=NewImage (_cdbc .Max .X ,_cdbc .Max .Y ,4,3,nil ,nil ,nil );if _bgaa !=nil {return nil ,_bgaa ;};_ffdc (_ebdd ,_gecb ,_cdbc );return _gecb ,nil ;};type CMYK interface{CMYKAt (_gcb ,_afc int )_a .CMYK ;
SetCMYK (_beaf ,_gec int ,_bfcg _a .CMYK );};func (_ceeb *Gray16 )Set (x ,y int ,c _a .Color ){_eefd :=(y *_ceeb .BytesPerLine /2+x )*2;if _eefd +1>=len (_ceeb .Data ){return ;};_gdf :=_a .Gray16Model .Convert (c ).(_a .Gray16 );_ceeb .Data [_eefd ],_ceeb .Data [_eefd +1]=uint8 (_gdf .Y >>8),uint8 (_gdf .Y &0xff);
};var _ Image =&Gray2 {};type CMYK32 struct{ImageBase };func (_cdfg *Gray16 )SetGray (x ,y int ,g _a .Gray ){_ffedc :=(y *_cdfg .BytesPerLine /2+x )*2;if _ffedc +1>=len (_cdfg .Data ){return ;};_cdfg .Data [_ffedc ]=g .Y ;_cdfg .Data [_ffedc +1]=g .Y ;
};func _fg (_ae ,_acc *Monochrome )(_cfe error ){_aag :=_acc .BytesPerLine ;_ba :=_ae .BytesPerLine ;_gfd :=_acc .BytesPerLine *4-_ae .BytesPerLine ;var (_ea ,_gfda byte ;_eae uint32 ;_ec ,_cbg ,_ada ,_ga ,_gdd ,_eeg ,_gfc int ;);for _ada =0;_ada < _acc .Height ;
_ada ++{_ec =_ada *_aag ;_cbg =4*_ada *_ba ;for _ga =0;_ga < _aag ;_ga ++{_ea =_acc .Data [_ec +_ga ];_eae =_dfb [_ea ];_eeg =_cbg +_ga *4;if _gfd !=0&&(_ga +1)*4> _ae .BytesPerLine {for _gdd =_gfd ;_gdd > 0;_gdd --{_gfda =byte ((_eae >>uint (_gdd *8))&0xff);
_gfc =_eeg +(_gfd -_gdd );if _cfe =_ae .setByte (_gfc ,_gfda );_cfe !=nil {return _cfe ;};};}else if _cfe =_ae .setFourBytes (_eeg ,_eae );_cfe !=nil {return _cfe ;};if _cfe =_ae .setFourBytes (_cbg +_ga *4,_dfb [_acc .Data [_ec +_ga ]]);_cfe !=nil {return _cfe ;
};};for _gdd =1;_gdd < 4;_gdd ++{for _ga =0;_ga < _ba ;_ga ++{if _cfe =_ae .setByte (_cbg +_gdd *_ba +_ga ,_ae .Data [_cbg +_ga ]);_cfe !=nil {return _cfe ;};};};};return nil ;};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA64 ,error ){_bcfe :=(y *width +x )*2;
_gedc :=_bcfe *3;if _gedc +5>=len (data ){return _a .NRGBA64 {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _dgfa =0xffff;_gade :=uint16 (_dgfa );if alpha !=nil &&len (alpha )> _bcfe +1{_gade =uint16 (alpha [_bcfe ])<<8|uint16 (alpha [_bcfe +1]);};_egaf :=uint16 (data [_gedc ])<<8|uint16 (data [_gedc +1]);_feaa :=uint16 (data [_gedc +2])<<8|uint16 (data [_gedc +3]);
_adff :=uint16 (data [_gedc +4])<<8|uint16 (data [_gedc +5]);if len (decode )==6{_egaf =uint16 (uint64 (LinearInterpolate (float64 (_egaf ),0,65535,decode [0],decode [1]))&_dgfa );_feaa =uint16 (uint64 (LinearInterpolate (float64 (_feaa ),0,65535,decode [2],decode [3]))&_dgfa );
_adff =uint16 (uint64 (LinearInterpolate (float64 (_adff ),0,65535,decode [4],decode [5]))&_dgfa );};return _a .NRGBA64 {R :_egaf ,G :_feaa ,B :_adff ,A :_gade },nil ;};func _dbac (_fccf *_gb .Gray16 ,_baefa uint8 )*_gb .Gray {_aabga :=_fccf .Bounds ();
_gaca :=_gb .NewGray (_aabga );for _abge :=0;_abge < _aabga .Dx ();_abge ++{for _fegf :=0;_fegf < _aabga .Dy ();_fegf ++{_bdae :=_fccf .Gray16At (_abge ,_fegf );_gaca .SetGray (_abge ,_fegf ,_a .Gray {Y :_baeg (uint8 (_bdae .Y /256),_baefa )});};};return _gaca ;
};func (_gbg *CMYK32 )Set (x ,y int ,c _a .Color ){_cbe :=4*(y *_gbg .Width +x );if _cbe +3>=len (_gbg .Data ){return ;};_aca :=_a .CMYKModel .Convert (c ).(_a .CMYK );_gbg .Data [_cbe ]=_aca .C ;_gbg .Data [_cbe +1]=_aca .M ;_gbg .Data [_cbe +2]=_aca .Y ;
_gbg .Data [_cbe +3]=_aca .K ;};var _ _gb .Image =&NRGBA64 {};func _ffdc (_adgac _gb .Image ,_bgcd Image ,_gcge _gb .Rectangle ){if _gcfgg ,_geeg :=_adgac .(SMasker );_geeg &&_gcfgg .HasAlpha (){_bgcd .(SMasker ).MakeAlpha ();};switch _egd :=_adgac .(type ){case Gray :_bbadd (_egd ,_bgcd .(NRGBA ),_gcge );
case NRGBA :_cgba (_egd ,_bgcd .(NRGBA ),_gcge );case *_gb .NYCbCrA :_cecfa (_egd ,_bgcd .(NRGBA ),_gcge );case CMYK :_abfe (_egd ,_bgcd .(NRGBA ),_gcge );case RGBA :_adebf (_egd ,_bgcd .(NRGBA ),_gcge );case nrgba64 :_gdbb (_egd ,_bgcd .(NRGBA ),_gcge );
default:_gegg (_adgac ,_bgcd ,_gcge );};};func (_baaa *NRGBA16 )Validate ()error {if len (_baaa .Data )!=3*_baaa .Width *_baaa .Height /2{return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type RasterOperator int ;func ConverterFunc (converterFunc func (_gaa _gb .Image )(Image ,error ))ColorConverter {return colorConverter {_efda :converterFunc };};func (_bed *Gray4 )Histogram ()(_geec [256]int ){for _fgea :=0;_fgea < _bed .Width ;
_fgea ++{for _gff :=0;_gff < _bed .Height ;_gff ++{_geec [_bed .GrayAt (_fgea ,_gff ).Y ]++;};};return _geec ;};func (_ffaa *Gray16 )Base ()*ImageBase {return &_ffaa .ImageBase };func (_dda *Monochrome )setIndexedBit (_gbfd int ){_dda .Data [(_gbfd >>3)]|=0x80>>uint (_gbfd &7)};
type ColorConverter interface{Convert (_dff _gb .Image )(Image ,error );};func _ccab (_cgff _a .CMYK )_a .RGBA {_cfeg ,_fdd ,_bbe :=_a .CMYKToRGB (_cgff .C ,_cgff .M ,_cgff .Y ,_cgff .K );return _a .RGBA {R :_cfeg ,G :_fdd ,B :_bbe ,A :0xff};};func _fcd (_cbb ,_gga *Monochrome ,_baef []byte ,_fcga int )(_cfbg error ){var (_fec ,_ede ,_aeaf ,_gegf ,_gfa ,_db ,_ddbf ,_dgfc int ;
_ecae ,_gaf uint32 ;_dace ,_ccc byte ;_abd uint16 ;);_dcdb :=make ([]byte ,4);_cfad :=make ([]byte ,4);for _aeaf =0;_aeaf < _cbb .Height -1;_aeaf ,_gegf =_aeaf +2,_gegf +1{_fec =_aeaf *_cbb .BytesPerLine ;_ede =_gegf *_gga .BytesPerLine ;for _gfa ,_db =0,0;
_gfa < _fcga ;_gfa ,_db =_gfa +4,_db +1{for _ddbf =0;_ddbf < 4;_ddbf ++{_dgfc =_fec +_gfa +_ddbf ;if _dgfc <=len (_cbb .Data )-1&&_dgfc < _fec +_cbb .BytesPerLine {_dcdb [_ddbf ]=_cbb .Data [_dgfc ];}else {_dcdb [_ddbf ]=0x00;};_dgfc =_fec +_cbb .BytesPerLine +_gfa +_ddbf ;
if _dgfc <=len (_cbb .Data )-1&&_dgfc < _fec +(2*_cbb .BytesPerLine ){_cfad [_ddbf ]=_cbb .Data [_dgfc ];}else {_cfad [_ddbf ]=0x00;};};_ecae =_c .BigEndian .Uint32 (_dcdb );_gaf =_c .BigEndian .Uint32 (_cfad );_gaf &=_ecae ;_gaf &=_gaf <<1;_gaf &=0xaaaaaaaa;
_ecae =_gaf |(_gaf <<7);_dace =byte (_ecae >>24);_ccc =byte ((_ecae >>8)&0xff);_dgfc =_ede +_db ;if _dgfc +1==len (_gga .Data )-1||_dgfc +1>=_ede +_gga .BytesPerLine {_gga .Data [_dgfc ]=_baef [_dace ];if _cfbg =_gga .setByte (_dgfc ,_baef [_dace ]);_cfbg !=nil {return _cb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_dgfc );
};}else {_abd =(uint16 (_baef [_dace ])<<8)|uint16 (_baef [_ccc ]);if _cfbg =_gga .setTwoBytes (_dgfc ,_abd );_cfbg !=nil {return _cb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_dgfc );
};_db ++;};};};return nil ;};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;
PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;
PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);type colorConverter struct{_efda func (_aff _gb .Image )(Image ,error );};func (_gdbcf *NRGBA32 )Validate ()error {if len (_gdbcf .Data )!=3*_gdbcf .Width *_gdbcf .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_feaf *ImageBase )setFourBytes (_afde int ,_bcg uint32 )error {if _afde +3> len (_feaf .Data )-1{return _cb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_afde );
};_feaf .Data [_afde ]=byte ((_bcg &0xff000000)>>24);_feaf .Data [_afde +1]=byte ((_bcg &0xff0000)>>16);_feaf .Data [_afde +2]=byte ((_bcg &0xff00)>>8);_feaf .Data [_afde +3]=byte (_bcg &0xff);return nil ;};func (_aabe *ImageBase )setTwoBytes (_bbcc int ,_efe uint16 )error {if _bbcc +1> len (_aabe .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_aabe .Data [_bbcc ]=byte ((_efe &0xff00)>>8);_aabe .Data [_bbcc +1]=byte (_efe &0xff);return nil ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA ,error ){_aecb :=y *width +x ;_fdbff :=3*_aecb ;if _fdbff +2>=len (data ){return _a .NRGBA {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bccc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _aecb {_bccc =alpha [_aecb ];};_dbgf ,_addf ,_ccac :=data [_fdbff ],data [_fdbff +1],data [_fdbff +2];if len (decode )==6{_dbgf =uint8 (uint32 (LinearInterpolate (float64 (_dbgf ),0,255,decode [0],decode [1]))&0xff);
_addf =uint8 (uint32 (LinearInterpolate (float64 (_addf ),0,255,decode [2],decode [3]))&0xff);_ccac =uint8 (uint32 (LinearInterpolate (float64 (_ccac ),0,255,decode [4],decode [5]))&0xff);};return _a .NRGBA {R :_dbgf ,G :_addf ,B :_ccac ,A :_bccc },nil ;
};func (_cdeg *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _gf (_cdeg ,factor );};const (_cega shift =iota ;_fdgc ;);var _ Gray =&Gray2 {};var _ _gb .Image =&NRGBA32 {};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_cb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_bece *RGBA32 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtRGBA32 (x ,y ,_bece .Width ,_bece .Data ,_bece .Alpha ,_bece .Decode );};func (_cgfc *Monochrome )copy ()*Monochrome {_dgg :=_gdb (_cgfc .Width ,_cgfc .Height );_dgg .ModelThreshold =_cgfc .ModelThreshold ;
_dgg .Data =make ([]byte ,len (_cgfc .Data ));copy (_dgg .Data ,_cgfc .Data );if len (_cgfc .Decode )!=0{_dgg .Decode =make ([]float64 ,len (_cgfc .Decode ));copy (_dgg .Decode ,_cgfc .Decode );};if len (_cgfc .Alpha )!=0{_dgg .Alpha =make ([]byte ,len (_cgfc .Alpha ));
copy (_dgg .Alpha ,_cgfc .Alpha );};return _dgg ;};func (_ebdae *Monochrome )ColorModel ()_a .Model {return MonochromeModel (_ebdae .ModelThreshold )};func (_cbcd *Gray8 )Set (x ,y int ,c _a .Color ){_daee :=y *_cbcd .BytesPerLine +x ;if _daee > len (_cbcd .Data )-1{return ;
};_fbeb :=_a .GrayModel .Convert (c );_cbcd .Data [_daee ]=_fbeb .(_a .Gray ).Y ;};func (_bca *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_bca .copy ()}};func _gded (_gdc *Monochrome ,_ebda ,_cd int )(*Monochrome ,error ){if _gdc ==nil {return nil ,_f .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _ebda <=0||_cd <=0{return nil ,_f .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _ebda ==_cd {if _ebda ==1{return _gdc .copy (),nil ;
};if _ebda ==2||_ebda ==4||_ebda ==8{_eba ,_ffe :=_gf (_gdc ,_ebda );if _ffe !=nil {return nil ,_ffe ;};return _eba ,nil ;};};_cge :=_ebda *_gdc .Width ;_efb :=_cd *_gdc .Height ;_ge :=_gdb (_cge ,_efb );_dae :=_ge .BytesPerLine ;var (_bae ,_gbc ,_bbc ,_fcad ,_de int ;
_egc byte ;_bf error ;);for _gbc =0;_gbc < _gdc .Height ;_gbc ++{_bae =_cd *_gbc *_dae ;for _bbc =0;_bbc < _gdc .Width ;_bbc ++{if _adf :=_gdc .getBitAt (_bbc ,_gbc );_adf {_de =_ebda *_bbc ;for _fcad =0;_fcad < _ebda ;_fcad ++{_ge .setIndexedBit (_bae *8+_de +_fcad );
};};};for _fcad =1;_fcad < _cd ;_fcad ++{_dfg :=_bae +_fcad *_dae ;for _egg :=0;_egg < _dae ;_egg ++{if _egc ,_bf =_ge .getByte (_bae +_egg );_bf !=nil {return nil ,_bf ;};if _bf =_ge .setByte (_dfg +_egg ,_egc );_bf !=nil {return nil ,_bf ;};};};};return _ge ,nil ;
};func _gg (_dec int )[]uint {var _gfdaa []uint ;_ggb :=_dec ;_fd :=_ggb /8;if _fd !=0{for _bc :=0;_bc < _fd ;_bc ++{_gfdaa =append (_gfdaa ,8);};_ggc :=_ggb %8;_ggb =0;if _ggc !=0{_ggb =_ggc ;};};_gea :=_ggb /4;if _gea !=0{for _fdb :=0;_fdb < _gea ;_fdb ++{_gfdaa =append (_gfdaa ,4);
};_eaef :=_ggb %4;_ggb =0;if _eaef !=0{_ggb =_eaef ;};};_dad :=_ggb /2;if _dad !=0{for _acbe :=0;_acbe < _dad ;_acbe ++{_gfdaa =append (_gfdaa ,2);};};return _gfdaa ;};func (_agbde *Gray8 )GrayAt (x ,y int )_a .Gray {_bfag ,_ :=ColorAtGray8BPC (x ,y ,_agbde .BytesPerLine ,_agbde .Data ,_agbde .Decode );
return _bfag ;};func (_aadd *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _cfff bool ;_daad :=scale ;if scale < 1{_daad =1/scale ;_cfff =true ;};_ebe :=NextPowerOf2 (uint (_daad ));if InDelta (float64 (_ebe ),_daad ,0.001){if _cfff {return _aadd .ReduceBinary (_daad );
};return _aadd .ExpandBinary (int (_ebe ));};_bgb :=int (_b .RoundToEven (float64 (_aadd .Width )*scale ));_gfg :=int (_b .RoundToEven (float64 (_aadd .Height )*scale ));return _aadd .ScaleLow (_bgb ,_gfg );};type NRGBA32 struct{ImageBase };func (_gaea *Monochrome )Validate ()error {if len (_gaea .Data )!=_gaea .Height *_gaea .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_afdg *Gray2 )Base ()*ImageBase {return &_afdg .ImageBase };func (_ccag *ImageBase )copy ()ImageBase {_abac :=*_ccag ;_abac .Data =make ([]byte ,len (_ccag .Data ));copy (_abac .Data ,_ccag .Data );return _abac ;};func (_cdegg *ImageBase )GetAlpha ()[]byte {return _cdegg .Alpha };
func (_bbee *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_bbee .copy ()}};func _bcaca (_eafd _a .Color )_a .Color {_afda :=_a .GrayModel .Convert (_eafd ).(_a .Gray );return _gbef (_afda );};type NRGBA64 struct{ImageBase };func _cfeb (_ebea []byte ,_aecg Image )error {_aaeg :=true ;
for _abfa :=0;_abfa < len (_ebea );_abfa ++{if _ebea [_abfa ]!=0xff{_aaeg =false ;break ;};};if _aaeg {switch _gbgbf :=_aecg .(type ){case *NRGBA32 :_gbgbf .Alpha =nil ;case *NRGBA64 :_gbgbf .Alpha =nil ;default:return _cb .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_aecg );
};};return nil ;};func (_facc *Gray4 )setGray (_afdab int ,_bfbgf int ,_fbec _a .Gray ){_gbgd :=_bfbgf *_facc .BytesPerLine ;_geaee :=_gbgd +(_afdab >>1);if _geaee >=len (_facc .Data ){return ;};_dgcb :=_fbec .Y >>4;_facc .Data [_geaee ]=(_facc .Data [_geaee ]&(^(0xf0>>uint (4*(_afdab &1)))))|(_dgcb <<uint (4-4*(_afdab &1)));
};func (_gbgdc *NRGBA64 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA64 (x ,y ,_gbgdc .Width ,_gbgdc .Data ,_gbgdc .Alpha ,_gbgdc .Decode );};func (_dfaf *Monochrome )Set (x ,y int ,c _a .Color ){_dfce :=y *_dfaf .BytesPerLine +x >>3;if _dfce > len (_dfaf .Data )-1{return ;
};_fccg :=_dfaf .ColorModel ().Convert (c ).(_a .Gray );_dfaf .setGray (x ,_fccg ,_dfce );};func (_agede *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_agede .copy ()}};func (_efbb *NRGBA16 )ColorModel ()_a .Model {return NRGBA16Model };func _cead (_ebc _a .NRGBA )_a .RGBA {_egf ,_ceg ,_ggd ,_fabd :=_ebc .RGBA ();
return _a .RGBA {R :uint8 (_egf >>8),G :uint8 (_ceg >>8),B :uint8 (_ggd >>8),A :uint8 (_fabd >>8)};};func (_afeg *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_afeg .copy ()}};func (_edf *ImageBase )getByte (_agfc int )(byte ,error ){if _agfc > len (_edf .Data )-1||_agfc < 0{return 0,_cb .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_agfc );
};return _edf .Data [_agfc ],nil ;};func _acfe (_bce _a .NRGBA64 )_a .RGBA {_beaa ,_bgc ,_fbgc ,_cgag :=_bce .RGBA ();return _a .RGBA {R :uint8 (_beaa >>8),G :uint8 (_bgc >>8),B :uint8 (_fbgc >>8),A :uint8 (_cgag >>8)};};func _cecfa (_bde *_gb .NYCbCrA ,_acab NRGBA ,_ddcd _gb .Rectangle ){for _bfgbg :=0;
_bfgbg < _ddcd .Max .X ;_bfgbg ++{for _fadf :=0;_fadf < _ddcd .Max .Y ;_fadf ++{_dcee :=_bde .NYCbCrAAt (_bfgbg ,_fadf );_acab .SetNRGBA (_bfgbg ,_fadf ,_dfc (_dcee ));};};};func _gcc (_cfd *Monochrome ,_cca int ,_ggf []byte )(_af *Monochrome ,_def error ){const _dgf ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _cfd ==nil {return nil ,_f .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _cca < 1||_cca > 4{return nil ,_f .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _cfd .Height <=1{return nil ,_f .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_af =_gdb (_cfd .Width /2,_cfd .Height /2);
if _ggf ==nil {_ggf =_aeb ();};_bd :=_bagd (_cfd .BytesPerLine ,2*_af .BytesPerLine );switch _cca {case 1:_def =_efa (_cfd ,_af ,_ggf ,_bd );case 2:_def =_dab (_cfd ,_af ,_ggf ,_bd );case 3:_def =_effb (_cfd ,_af ,_ggf ,_bd );case 4:_def =_fcd (_cfd ,_af ,_ggf ,_bd );
};if _def !=nil {return nil ,_def ;};return _af ,nil ;};var _ Image =&NRGBA64 {};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func MonochromeModel (threshold uint8 )_a .Model {return monochromeModel (threshold )};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_gcba :=y *bytesPerLine +x >>3;
if _gcba >=len (data ){return _a .Gray {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dead :=data [_gcba ]>>uint (7-(x &7))&1;if len (decode )==2{_dead =uint8 (LinearInterpolate (float64 (_dead ),0.0,1.0,decode [0],decode [1]))&1;};return _a .Gray {Y :_dead *255},nil ;};func _gfbf (_bbad *Monochrome ,_bade ,_acgb int ,_dgdb ,_gafg int ,_agab RasterOperator ){var (_dccb bool ;
_acbf bool ;_dabb int ;_dcdd int ;_gce int ;_geee int ;_cacg bool ;_aefg byte ;);_gfde :=8-(_bade &7);_bgcba :=_gdebc [_gfde ];_dega :=_bbad .BytesPerLine *_acgb +(_bade >>3);if _dgdb < _gfde {_dccb =true ;_bgcba &=_cgdf [8-_gfde +_dgdb ];};if !_dccb {_dabb =(_dgdb -_gfde )>>3;
if _dabb !=0{_acbf =true ;_dcdd =_dega +1;};};_gce =(_bade +_dgdb )&7;if !(_dccb ||_gce ==0){_cacg =true ;_aefg =_cgdf [_gce ];_geee =_dega +1+_dabb ;};var _gba ,_efgda int ;switch _agab {case PixClr :for _gba =0;_gba < _gafg ;_gba ++{_bbad .Data [_dega ]=_dfbf (_bbad .Data [_dega ],0x0,_bgcba );
_dega +=_bbad .BytesPerLine ;};if _acbf {for _gba =0;_gba < _gafg ;_gba ++{for _efgda =0;_efgda < _dabb ;_efgda ++{_bbad .Data [_dcdd +_efgda ]=0x0;};_dcdd +=_bbad .BytesPerLine ;};};if _cacg {for _gba =0;_gba < _gafg ;_gba ++{_bbad .Data [_geee ]=_dfbf (_bbad .Data [_geee ],0x0,_aefg );
_geee +=_bbad .BytesPerLine ;};};case PixSet :for _gba =0;_gba < _gafg ;_gba ++{_bbad .Data [_dega ]=_dfbf (_bbad .Data [_dega ],0xff,_bgcba );_dega +=_bbad .BytesPerLine ;};if _acbf {for _gba =0;_gba < _gafg ;_gba ++{for _efgda =0;_efgda < _dabb ;_efgda ++{_bbad .Data [_dcdd +_efgda ]=0xff;
};_dcdd +=_bbad .BytesPerLine ;};};if _cacg {for _gba =0;_gba < _gafg ;_gba ++{_bbad .Data [_geee ]=_dfbf (_bbad .Data [_geee ],0xff,_aefg );_geee +=_bbad .BytesPerLine ;};};case PixNotDst :for _gba =0;_gba < _gafg ;_gba ++{_bbad .Data [_dega ]=_dfbf (_bbad .Data [_dega ],^_bbad .Data [_dega ],_bgcba );
_dega +=_bbad .BytesPerLine ;};if _acbf {for _gba =0;_gba < _gafg ;_gba ++{for _efgda =0;_efgda < _dabb ;_efgda ++{_bbad .Data [_dcdd +_efgda ]=^(_bbad .Data [_dcdd +_efgda ]);};_dcdd +=_bbad .BytesPerLine ;};};if _cacg {for _gba =0;_gba < _gafg ;_gba ++{_bbad .Data [_geee ]=_dfbf (_bbad .Data [_geee ],^_bbad .Data [_geee ],_aefg );
_geee +=_bbad .BytesPerLine ;};};};};func IsGrayImgBlackAndWhite (i *_gb .Gray )bool {return _becgc (i )};func (_fda *Gray8 )Base ()*ImageBase {return &_fda .ImageBase };func (_cgab *RGBA32 )ColorModel ()_a .Model {return _a .NRGBAModel };var _ Image =&Monochrome {};
func (_gecd *NRGBA16 )Set (x ,y int ,c _a .Color ){_cgdgc :=y *_gecd .BytesPerLine +x *3/2;if _cgdgc +1>=len (_gecd .Data ){return ;};_acdd :=NRGBA16Model .Convert (c ).(_a .NRGBA );_gecd .setNRGBA (x ,y ,_cgdgc ,_acdd );};func _dcbc (_gcg int ,_afaf int )error {return _cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_gcg ,_afaf );
};func (_gege *Gray16 )GrayAt (x ,y int )_a .Gray {_baae ,_ :=_gege .ColorAt (x ,y );return _a .Gray {Y :uint8 (_baae .(_a .Gray16 ).Y >>8)};};func _ecfe (_gdeb ,_bbba Gray ,_gbdg _gb .Rectangle ){for _bebb :=0;_bebb < _gbdg .Max .X ;_bebb ++{for _bfbd :=0;
_bfbd < _gbdg .Max .Y ;_bfbd ++{_bbba .SetGray (_bebb ,_bfbd ,_gdeb .GrayAt (_bebb ,_bfbd ));};};};func (_baag *Gray2 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_baag .Width ,Y :_baag .Height }};};func _efeb (_bebbd _gb .Image )(Image ,error ){if _dgce ,_dgceb :=_bebbd .(*RGBA32 );
_dgceb {return _dgce .Copy (),nil ;};_ccdg ,_accb ,_geag :=_abaff (_bebbd ,1);_gdfg :=&RGBA32 {ImageBase :NewImageBase (_ccdg .Max .X ,_ccdg .Max .Y ,8,3,nil ,_geag ,nil )};_gbedd (_bebbd ,_gdfg ,_ccdg );if len (_geag )!=0&&!_accb {if _agff :=_cfeb (_geag ,_gdfg );
_agff !=nil {return nil ,_agff ;};};return _gdfg ,nil ;};func _becgc (_efaa *_gb .Gray )bool {for _gbaf :=0;_gbaf < len (_efaa .Pix );_gbaf ++{if !_ddbc (_efaa .Pix [_gbaf ]){return false ;};};return true ;};func (_deg *CMYK32 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtCMYK (x ,y ,_deg .Width ,_deg .Data ,_deg .Decode );
};func _afede (_fbag NRGBA ,_fag Gray ,_afec _gb .Rectangle ){for _gaag :=0;_gaag < _afec .Max .X ;_gaag ++{for _bgeg :=0;_bgeg < _afec .Max .Y ;_bgeg ++{_beec :=_dafd (_fbag .NRGBAAt (_gaag ,_bgeg ));_fag .SetGray (_gaag ,_bgeg ,_beec );};};};func (_gddd *NRGBA64 )At (x ,y int )_a .Color {_bbaa ,_ :=_gddd .ColorAt (x ,y );
return _bbaa };func _aaec (_efbc _gb .Image )(Image ,error ){if _acgc ,_bbfb :=_efbc .(*NRGBA32 );_bbfb {return _acgc .Copy (),nil ;};_fdcf ,_bbd ,_daccb :=_abaff (_efbc ,1);_bgae ,_dfag :=NewImage (_fdcf .Max .X ,_fdcf .Max .Y ,8,3,nil ,_daccb ,nil );
if _dfag !=nil {return nil ,_dfag ;};_ffdc (_efbc ,_bgae ,_fdcf );if len (_daccb )!=0&&!_bbd {if _eefb :=_cfeb (_daccb ,_bgae );_eefb !=nil {return nil ,_eefb ;};};return _bgae ,nil ;};func _gbcfg (_bceaf _gb .Image ,_aega uint8 )*_gb .Gray {_cddb :=_bceaf .Bounds ();
_eee :=_gb .NewGray (_cddb );var (_feaab _a .Color ;_dbegf _a .Gray ;);for _fbea :=0;_fbea < _cddb .Max .X ;_fbea ++{for _eggcb :=0;_eggcb < _cddb .Max .Y ;_eggcb ++{_feaab =_bceaf .At (_fbea ,_eggcb );_eee .Set (_fbea ,_eggcb ,_feaab );_dbegf =_eee .GrayAt (_fbea ,_eggcb );
_eee .SetGray (_fbea ,_eggcb ,_a .Gray {Y :_baeg (_dbegf .Y ,_aega )});};};return _eee ;};func (_cade *Monochrome )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray1BPC (x ,y ,_cade .BytesPerLine ,_cade .Data ,_cade .Decode );};func _fef ()(_dge [256]uint16 ){for _dcc :=0;
_dcc < 256;_dcc ++{if _dcc &0x01!=0{_dge [_dcc ]|=0x3;};if _dcc &0x02!=0{_dge [_dcc ]|=0xc;};if _dcc &0x04!=0{_dge [_dcc ]|=0x30;};if _dcc &0x08!=0{_dge [_dcc ]|=0xc0;};if _dcc &0x10!=0{_dge [_dcc ]|=0x300;};if _dcc &0x20!=0{_dge [_dcc ]|=0xc00;};if _dcc &0x40!=0{_dge [_dcc ]|=0x3000;
};if _dcc &0x80!=0{_dge [_dcc ]|=0xc000;};};return _dge ;};func FromGoImage (i _gb .Image )(Image ,error ){switch _aacge :=i .(type ){case Image :return _aacge .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_gb .Gray16 :return Gray16Converter .Convert (i );
case CMYK :return CMYKConverter .Convert (i );case *_gb .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func _efa (_cdf ,_cea *Monochrome ,_dac []byte ,_fcg int )(_bcd error ){var (_eega ,_cga ,_cbc ,_bfc ,_ab ,_abb ,_cbd ,_eab int ;
_ceb ,_eegab uint32 ;_bbf ,_afg byte ;_cfg uint16 ;);_gcf :=make ([]byte ,4);_cgc :=make ([]byte ,4);for _cbc =0;_cbc < _cdf .Height -1;_cbc ,_bfc =_cbc +2,_bfc +1{_eega =_cbc *_cdf .BytesPerLine ;_cga =_bfc *_cea .BytesPerLine ;for _ab ,_abb =0,0;_ab < _fcg ;
_ab ,_abb =_ab +4,_abb +1{for _cbd =0;_cbd < 4;_cbd ++{_eab =_eega +_ab +_cbd ;if _eab <=len (_cdf .Data )-1&&_eab < _eega +_cdf .BytesPerLine {_gcf [_cbd ]=_cdf .Data [_eab ];}else {_gcf [_cbd ]=0x00;};_eab =_eega +_cdf .BytesPerLine +_ab +_cbd ;if _eab <=len (_cdf .Data )-1&&_eab < _eega +(2*_cdf .BytesPerLine ){_cgc [_cbd ]=_cdf .Data [_eab ];
}else {_cgc [_cbd ]=0x00;};};_ceb =_c .BigEndian .Uint32 (_gcf );_eegab =_c .BigEndian .Uint32 (_cgc );_eegab |=_ceb ;_eegab |=_eegab <<1;_eegab &=0xaaaaaaaa;_ceb =_eegab |(_eegab <<7);_bbf =byte (_ceb >>24);_afg =byte ((_ceb >>8)&0xff);_eab =_cga +_abb ;
if _eab +1==len (_cea .Data )-1||_eab +1>=_cga +_cea .BytesPerLine {_cea .Data [_eab ]=_dac [_bbf ];}else {_cfg =(uint16 (_dac [_bbf ])<<8)|uint16 (_dac [_afg ]);if _bcd =_cea .setTwoBytes (_eab ,_cfg );_bcd !=nil {return _cb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_eab );
};_abb ++;};};};return nil ;};func (_cbgeg *Gray2 )Histogram ()(_ccg [256]int ){for _ebbf :=0;_ebbf < _cbgeg .Width ;_ebbf ++{for _gaeaf :=0;_gaeaf < _cbgeg .Height ;_gaeaf ++{_ccg [_cbgeg .GrayAt (_ebbf ,_gaeaf ).Y ]++;};};return _ccg ;};func _ebb (_caa *Monochrome ,_fbg ...int )(_ccf *Monochrome ,_feg error ){if _caa ==nil {return nil ,_f .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_fbg )==0{return nil ,_f .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_eca :=_aeb ();_ccf =_caa ;for _ ,_fa :=range _fbg {if _fa <=0{break ;};_ccf ,_feg =_gcc (_ccf ,_fa ,_eca );if _feg !=nil {return nil ,_feg ;};};return _ccf ,nil ;};func (_dcfg *Gray8 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_dcfg .Width ,Y :_dcfg .Height }};
};func _cfgfg (_dbc _gb .Image )(Image ,error ){if _becg ,_gffg :=_dbc .(*NRGBA64 );_gffg {return _becg .Copy (),nil ;};_bcge ,_fgbf ,_gcdg :=_abaff (_dbc ,2);_bebfa ,_ddfgd :=NewImage (_bcge .Max .X ,_bcge .Max .Y ,16,3,nil ,_gcdg ,nil );if _ddfgd !=nil {return nil ,_ddfgd ;
};_ccbb (_dbc ,_bebfa ,_bcge );if len (_gcdg )!=0&&!_fgbf {if _gbfb :=_cfeb (_gcdg ,_bebfa );_gbfb !=nil {return nil ,_gbfb ;};};return _bebfa ,nil ;};var _ NRGBA =&NRGBA32 {};func (_efca *CMYK32 )Base ()*ImageBase {return &_efca .ImageBase };func (_face *NRGBA32 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA32 (x ,y ,_face .Width ,_face .Data ,_face .Alpha ,_face .Decode );
};func (_afcb *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_cccc :=_fddf (uint (factor ));if !IsPowerOf2 (uint (factor )){_cccc ++;};_bced :=make ([]int ,_cccc );for _adag :=range _bced {_bced [_adag ]=4;};_cddd ,_gdbd :=_ebb (_afcb ,_bced ...);
if _gdbd !=nil {return nil ,_gdbd ;};return _cddd ,nil ;};func (_cegc *NRGBA64 )setNRGBA64 (_aabcf int ,_fbdd _a .NRGBA64 ,_gbca int ){_cegc .Data [_aabcf ]=uint8 (_fbdd .R >>8);_cegc .Data [_aabcf +1]=uint8 (_fbdd .R &0xff);_cegc .Data [_aabcf +2]=uint8 (_fbdd .G >>8);
_cegc .Data [_aabcf +3]=uint8 (_fbdd .G &0xff);_cegc .Data [_aabcf +4]=uint8 (_fbdd .B >>8);_cegc .Data [_aabcf +5]=uint8 (_fbdd .B &0xff);if _gbca +1< len (_cegc .Alpha ){_cegc .Alpha [_gbca ]=uint8 (_fbdd .A >>8);_cegc .Alpha [_gbca +1]=uint8 (_fbdd .A &0xff);
};};var _ RGBA =&RGBA32 {};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_e :=BytesPerLine (width ,8,1);if len (data )< _e *height {return nil ,nil ;};_be :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_d ,_ef :=MonochromeConverter .Convert (_be );
if _ef !=nil {return nil ,_ef ;};return _d .Base ().Data ,nil ;};func _faca (_bfb _a .Gray )_a .CMYK {return _a .CMYK {K :0xff-_bfb .Y }};func (_aac *CMYK32 )Validate ()error {if len (_aac .Data )!=4*_aac .Width *_aac .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _gbef (_cecd _a .Gray )_a .Gray {_ecf :=_cecd .Y >>6;_ecf |=_ecf <<2;_cecd .Y =_ecf |_ecf <<4;return _cecd ;};func _aacg (_fgdf _a .Color )_a .Color {_agbd :=_a .GrayModel .Convert (_fgdf ).(_a .Gray );return _add (_agbd );};func _aagdb (_dgdd NRGBA ,_efg CMYK ,_aagg _gb .Rectangle ){for _edg :=0;
_edg < _aagg .Max .X ;_edg ++{for _baee :=0;_baee < _aagg .Max .Y ;_baee ++{_gcd :=_dgdd .NRGBAAt (_edg ,_baee );_efg .SetCMYK (_edg ,_baee ,_affb (_gcd ));};};};func _aea ()(_cgec [256]uint32 ){for _bee :=0;_bee < 256;_bee ++{if _bee &0x01!=0{_cgec [_bee ]|=0xf;
};if _bee &0x02!=0{_cgec [_bee ]|=0xf0;};if _bee &0x04!=0{_cgec [_bee ]|=0xf00;};if _bee &0x08!=0{_cgec [_bee ]|=0xf000;};if _bee &0x10!=0{_cgec [_bee ]|=0xf0000;};if _bee &0x20!=0{_cgec [_bee ]|=0xf00000;};if _bee &0x40!=0{_cgec [_bee ]|=0xf000000;};if _bee &0x80!=0{_cgec [_bee ]|=0xf0000000;
};};return _cgec ;};var _ Image =&Gray16 {};func _agb ()(_aagd [256]uint64 ){for _ffa :=0;_ffa < 256;_ffa ++{if _ffa &0x01!=0{_aagd [_ffa ]|=0xff;};if _ffa &0x02!=0{_aagd [_ffa ]|=0xff00;};if _ffa &0x04!=0{_aagd [_ffa ]|=0xff0000;};if _ffa &0x08!=0{_aagd [_ffa ]|=0xff000000;
};if _ffa &0x10!=0{_aagd [_ffa ]|=0xff00000000;};if _ffa &0x20!=0{_aagd [_ffa ]|=0xff0000000000;};if _ffa &0x40!=0{_aagd [_ffa ]|=0xff000000000000;};if _ffa &0x80!=0{_aagd [_ffa ]|=0xff00000000000000;};};return _aagd ;};type nrgba64 interface{NRGBA64At (_cgdbg ,_gabgg int )_a .NRGBA64 ;
SetNRGBA64 (_dgfdd ,_eddd int ,_ccea _a .NRGBA64 );};func (_ffcf *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_ffcf .copy ()}};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray16 ,error ){_dbgb :=(y *bytesPerLine /2+x )*2;
if _dbgb +1>=len (data ){return _a .Gray16 {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_agd :=uint16 (data [_dbgb ])<<8|uint16 (data [_dbgb +1]);if len (decode )==2{_agd =uint16 (uint64 (LinearInterpolate (float64 (_agd ),0,65535,decode [0],decode [1])));};return _a .Gray16 {Y :_agd },nil ;};func (_fabc *CMYK32 )ColorModel ()_a .Model {return _a .CMYKModel };
func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;
case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_cb .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_edea *RGBA32 )SetRGBA (x ,y int ,c _a .RGBA ){_eacdf :=y *_edea .Width +x ;_dcab :=3*_eacdf ;if _dcab +2>=len (_edea .Data ){return ;};_edea .setRGBA (_eacdf ,c );};var (_cgdf =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_gdebc =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);var _ _gb .Image =&NRGBA16 {};func (_dacce *Monochrome )Base ()*ImageBase {return &_dacce .ImageBase };func (_gbbf *NRGBA64 )Base ()*ImageBase {return &_gbbf .ImageBase };func _cbfcf (_bfef NRGBA ,_egcd RGBA ,_accf _gb .Rectangle ){for _fccaa :=0;_fccaa < _accf .Max .X ;
_fccaa ++{for _aeaff :=0;_aeaff < _accf .Max .Y ;_aeaff ++{_ebba :=_bfef .NRGBAAt (_fccaa ,_aeaff );_egcd .SetRGBA (_fccaa ,_aeaff ,_cead (_ebba ));};};};func _bbab (_befe _a .NRGBA )_a .NRGBA {_befe .R =_befe .R >>4|(_befe .R >>4)<<4;_befe .G =_befe .G >>4|(_befe .G >>4)<<4;
_befe .B =_befe .B >>4|(_befe .B >>4)<<4;return _befe ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _efgg ,_agce ,_badf ,_bcea int ;for _cfdg :=0;_cfdg < len (histogram );_cfdg ++{if histogram [_cfdg ]> 0{_efgg =_cfdg ;break ;};};if _efgg > 0{_efgg --;
};for _fdbcg :=255;_fdbcg > 0;_fdbcg --{if histogram [_fdbcg ]> 0{_bcea =_fdbcg ;break ;};};if _bcea < 255{_bcea ++;};for _cdff :=0;_cdff < 256;_cdff ++{if histogram [_cdff ]> _agce {_badf =_cdff ;_agce =histogram [_cdff ];};};var _geac bool ;if (_badf -_efgg )< (_bcea -_badf ){_geac =true ;
var _eabe int ;_dgcac :=255;for _eabe < _dgcac {_gbcbc :=histogram [_eabe ];histogram [_eabe ]=histogram [_dgcac ];histogram [_dgcac ]=_gbcbc ;_eabe ++;_dgcac --;};_efgg =255-_bcea ;_badf =255-_badf ;};if _efgg ==_badf {return uint8 (_efgg );};_ggfe :=float64 (histogram [_badf ]);
_gdcg :=float64 (_efgg -_badf );_fbbc :=_b .Sqrt (_ggfe *_ggfe +_gdcg *_gdcg );_ggfe /=_fbbc ;_gdcg /=_fbbc ;_fbbc =_ggfe *float64 (_efgg )+_gdcg *float64 (histogram [_efgg ]);_febe :=_efgg ;var _fadc float64 ;for _bbed :=_efgg +1;_bbed <=_badf ;_bbed ++{_dedb :=_ggfe *float64 (_bbed )+_gdcg *float64 (histogram [_bbed ])-_fbbc ;
if _dedb > _fadc {_febe =_bbed ;_fadc =_dedb ;};};_febe --;if _geac {var _ccba int ;_dfba :=255;for _ccba < _dfba {_fdcg :=histogram [_ccba ];histogram [_ccba ]=histogram [_dfba ];histogram [_dfba ]=_fdcg ;_ccba ++;_dfba --;};return uint8 (255-_febe );
};return uint8 (_febe );};func (_ffd *Monochrome )clearBit (_ffbg ,_bbfa int ){_ffd .Data [_ffbg ]&=^(0x80>>uint (_bbfa &7))};type Gray16 struct{ImageBase };func (_ebcd *Gray2 )GrayAt (x ,y int )_a .Gray {_afab ,_ :=ColorAtGray2BPC (x ,y ,_ebcd .BytesPerLine ,_ebcd .Data ,_ebcd .Decode );
return _afab ;};var (MonochromeConverter =ConverterFunc (_agcf );Gray2Converter =ConverterFunc (_ebgd );Gray4Converter =ConverterFunc (_eaaga );GrayConverter =ConverterFunc (_adee );Gray16Converter =ConverterFunc (_aeg );NRGBA16Converter =ConverterFunc (_cecf );
NRGBAConverter =ConverterFunc (_aaec );NRGBA64Converter =ConverterFunc (_cfgfg );RGBAConverter =ConverterFunc (_efeb );CMYKConverter =ConverterFunc (_ffc ););func (_dfe *CMYK32 )CMYKAt (x ,y int )_a .CMYK {_ddfg ,_ :=ColorAtCMYK (x ,y ,_dfe .Width ,_dfe .Data ,_dfe .Decode );
return _ddfg ;};var _ Gray =&Gray4 {};type Gray interface{GrayAt (_bfcf ,_egcc int )_a .Gray ;SetGray (_cde ,_fbb int ,_dfbe _a .Gray );};func (_fga *Monochrome )setGrayBit (_ecc ,_ggfg int ){_fga .Data [_ecc ]|=0x80>>uint (_ggfg &7)};func _agcf (_cgecf _gb .Image )(Image ,error ){if _ffed ,_gacf :=_cgecf .(*Monochrome );
_gacf {return _ffed ,nil ;};_bebg :=_cgecf .Bounds ();var _cad Gray ;switch _dbd :=_cgecf .(type ){case Gray :_cad =_dbd ;case NRGBA :_cad =&Gray8 {ImageBase :NewImageBase (_bebg .Max .X ,_bebg .Max .Y ,8,1,nil ,nil ,nil )};_dcf (_cad ,_dbd ,_bebg );case nrgba64 :_cad =&Gray8 {ImageBase :NewImageBase (_bebg .Max .X ,_bebg .Max .Y ,8,1,nil ,nil ,nil )};
_cbf (_cad ,_dbd ,_bebg );default:_aedb ,_gae :=GrayConverter .Convert (_cgecf );if _gae !=nil {return nil ,_gae ;};_cad =_aedb .(Gray );};_baa ,_ade :=NewImage (_bebg .Max .X ,_bebg .Max .Y ,1,1,nil ,nil ,nil );if _ade !=nil {return nil ,_ade ;};_affe :=_baa .(*Monochrome );
_cbab :=AutoThresholdTriangle (GrayHistogram (_cad ));for _dgbb :=0;_dgbb < _bebg .Max .X ;_dgbb ++{for _gag :=0;_gag < _bebg .Max .Y ;_gag ++{_dgc :=_cbfc (_cad .GrayAt (_dgbb ,_gag ),monochromeModel (_cbab ));_affe .SetGray (_dgbb ,_gag ,_dgc );};};return _baa ,nil ;
};func (_abda *NRGBA64 )ColorModel ()_a .Model {return _a .NRGBA64Model };func _dcf (_ddfe Gray ,_ddfee NRGBA ,_adae _gb .Rectangle ){for _dccd :=0;_dccd < _adae .Max .X ;_dccd ++{for _fcba :=0;_fcba < _adae .Max .Y ;_fcba ++{_bge :=_gdcbd (_ddfee .NRGBAAt (_dccd ,_fcba ));
_ddfe .SetGray (_dccd ,_fcba ,_bge );};};};var _ Image =&RGBA32 {};func (_dfab *ImageBase )MakeAlpha (){_dfab .newAlpha ()};func _gdbb (_bgad nrgba64 ,_cefb NRGBA ,_fddc _gb .Rectangle ){for _dfgff :=0;_dfgff < _fddc .Max .X ;_dfgff ++{for _egbg :=0;_egbg < _fddc .Max .Y ;
_egbg ++{_ffaac :=_bgad .NRGBA64At (_dfgff ,_egbg );_cefb .SetNRGBA (_dfgff ,_egbg ,_eec (_ffaac ));};};};func (_efab *Gray2 )ColorModel ()_a .Model {return Gray2Model };type NRGBA16 struct{ImageBase };var ErrInvalidImage =_f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func _cece (_fge Gray ,_ccd CMYK ,_eadf _gb .Rectangle ){for _decg :=0;_decg < _eadf .Max .X ;_decg ++{for _acbd :=0;_acbd < _eadf .Max .Y ;_acbd ++{_cebg :=_fge .GrayAt (_decg ,_acbd );_ccd .SetCMYK (_decg ,_acbd ,_faca (_cebg ));};};};type NRGBA interface{NRGBAAt (_agbdf ,_gceb int )_a .NRGBA ;
SetNRGBA (_fece ,_cbaba int ,_aaac _a .NRGBA );};func _eaagg (_cef _a .NYCbCrA )_a .RGBA {_bgf ,_ece ,_fgf ,_eef :=_dfc (_cef ).RGBA ();return _a .RGBA {R :uint8 (_bgf >>8),G :uint8 (_ece >>8),B :uint8 (_fgf >>8),A :uint8 (_eef >>8)};};