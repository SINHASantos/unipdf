//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_af "encoding/binary";_g "errors";_gc "fmt";_fc "github.com/unidoc/unipdf/v3/common";_ga "github.com/unidoc/unipdf/v3/internal/bitwise";_f "image";_aa "image/color";_gd "image/draw";_a "math";);func (_dggb *Gray2 )Validate ()error {if len (_dggb .Data )!=_dggb .Height *_dggb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_agdb *NRGBA64 )At (x ,y int )_aa .Color {_eabe ,_ :=_agdb .ColorAt (x ,y );return _eabe };func (_dbgb *Gray8 )ColorModel ()_aa .Model {return _aa .GrayModel };func (_faec *Monochrome )ColorModel ()_aa .Model {return MonochromeModel (_faec .ModelThreshold )};
func (_gbga *Monochrome )SetGray (x ,y int ,g _aa .Gray ){_dbbd :=y *_gbga .BytesPerLine +x >>3;if _dbbd > len (_gbga .Data )-1{return ;};g =_eaga (g ,monochromeModel (_gbga .ModelThreshold ));_gbga .setGray (x ,g ,_dbbd );};func _ebeb (_gec _aa .NYCbCrA )_aa .RGBA {_dgef ,_bced ,_gag ,_dae :=_bbecf (_gec ).RGBA ();
return _aa .RGBA {R :uint8 (_dgef >>8),G :uint8 (_bced >>8),B :uint8 (_gag >>8),A :uint8 (_dae >>8)};};func _dgde (_eefd _aa .CMYK )_aa .NRGBA {_fbbe ,_egaf ,_gdcg :=_aa .CMYKToRGB (_eefd .C ,_eefd .M ,_eefd .Y ,_eefd .K );return _aa .NRGBA {R :_fbbe ,G :_egaf ,B :_gdcg ,A :0xff};
};func _gega (_bdbb _f .Image ,_egdaa int )(_f .Rectangle ,bool ,[]byte ){_ffa :=_bdbb .Bounds ();var (_cfbf bool ;_begae []byte ;);switch _gfdc :=_bdbb .(type ){case SMasker :_cfbf =_gfdc .HasAlpha ();case NRGBA ,RGBA ,*_f .RGBA64 ,nrgba64 ,*_f .NYCbCrA :_begae =make ([]byte ,_ffa .Max .X *_ffa .Max .Y *_egdaa );
case *_f .Paletted :if !_gfdc .Opaque (){_begae =make ([]byte ,_ffa .Max .X *_ffa .Max .Y *_egdaa );};};return _ffa ,_cfbf ,_begae ;};func (_bdca *NRGBA64 )Base ()*ImageBase {return &_bdca .ImageBase };func _fead (_eeeg _aa .NRGBA )_aa .NRGBA {_eeeg .R =_eeeg .R >>4|(_eeeg .R >>4)<<4;
_eeeg .G =_eeeg .G >>4|(_eeeg .G >>4)<<4;_eeeg .B =_eeeg .B >>4|(_eeeg .B >>4)<<4;return _eeeg ;};func _gga (_fdf *Monochrome ,_cfd int ,_dag []byte )(_dde *Monochrome ,_aab error ){const _dec ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _fdf ==nil {return nil ,_g .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _cfd < 1||_cfd > 4{return nil ,_g .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _fdf .Height <=1{return nil ,_g .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_dde =_fgf (_fdf .Width /2,_fdf .Height /2);
if _dag ==nil {_dag =_efe ();};_cabf :=_dfbd (_fdf .BytesPerLine ,2*_dde .BytesPerLine );switch _cfd {case 1:_aab =_eca (_fdf ,_dde ,_dag ,_cabf );case 2:_aab =_beg (_fdf ,_dde ,_dag ,_cabf );case 3:_aab =_gcg (_fdf ,_dde ,_dag ,_cabf );case 4:_aab =_dgd (_fdf ,_dde ,_dag ,_cabf );
};if _aab !=nil {return nil ,_aab ;};return _dde ,nil ;};func _bcec (_gdga ,_cgfg NRGBA ,_eadf _f .Rectangle ){for _ddff :=0;_ddff < _eadf .Max .X ;_ddff ++{for _eccab :=0;_eccab < _eadf .Max .Y ;_eccab ++{_cgfg .SetNRGBA (_ddff ,_eccab ,_gdga .NRGBAAt (_ddff ,_eccab ));
};};};func _gaeb (_aaefg *_f .Gray16 ,_aagc uint8 )*_f .Gray {_gfad :=_aaefg .Bounds ();_gaee :=_f .NewGray (_gfad );for _aabbb :=0;_aabbb < _gfad .Dx ();_aabbb ++{for _ceaf :=0;_ceaf < _gfad .Dy ();_ceaf ++{_cdfa :=_aaefg .Gray16At (_aabbb ,_ceaf );_gaee .SetGray (_aabbb ,_ceaf ,_aa .Gray {Y :_agac (uint8 (_cdfa .Y /256),_aagc )});
};};return _gaee ;};type Gray16 struct{ImageBase };func _bac (_ccbe _aa .CMYK )_aa .Gray {_bae ,_ecc ,_fdda :=_aa .CMYKToRGB (_ccbe .C ,_ccbe .M ,_ccbe .Y ,_ccbe .K );_fcfe :=(19595*uint32 (_bae )+38470*uint32 (_ecc )+7471*uint32 (_fdda )+1<<7)>>16;return _aa .Gray {Y :uint8 (_fcfe )};
};func (_dfff *RGBA32 )setRGBA (_gadab int ,_bcff _aa .RGBA ){_ffca :=3*_gadab ;_dfff .Data [_ffca ]=_bcff .R ;_dfff .Data [_ffca +1]=_bcff .G ;_dfff .Data [_ffca +2]=_bcff .B ;if _gadab < len (_dfff .Alpha ){_dfff .Alpha [_gadab ]=_bcff .A ;};};func _bcgd (_gcdc _aa .RGBA )_aa .NRGBA {switch _gcdc .A {case 0xff:return _aa .NRGBA {R :_gcdc .R ,G :_gcdc .G ,B :_gcdc .B ,A :0xff};
case 0x00:return _aa .NRGBA {};default:_bbf ,_gadb ,_aagg ,_gadd :=_gcdc .RGBA ();_bbf =(_bbf *0xffff)/_gadd ;_gadb =(_gadb *0xffff)/_gadd ;_aagg =(_aagg *0xffff)/_gadd ;return _aa .NRGBA {R :uint8 (_bbf >>8),G :uint8 (_gadb >>8),B :uint8 (_aagg >>8),A :uint8 (_gadd >>8)};
};};func (_cecd *Gray8 )Set (x ,y int ,c _aa .Color ){_afgc :=y *_cecd .BytesPerLine +x ;if _afgc > len (_cecd .Data )-1{return ;};_befd :=_aa .GrayModel .Convert (c );_cecd .Data [_afgc ]=_befd .(_aa .Gray ).Y ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};func (_aegf *NRGBA32 )Base ()*ImageBase {return &_aegf .ImageBase };type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_cdfg *Gray2 )GrayAt (x ,y int )_aa .Gray {_eebc ,_ :=ColorAtGray2BPC (x ,y ,_cdfg .BytesPerLine ,_cdfg .Data ,_cdfg .Decode );
return _eebc ;};func (_aeed *Monochrome )At (x ,y int )_aa .Color {_ddgc ,_ :=_aeed .ColorAt (x ,y );return _ddgc };type NRGBA32 struct{ImageBase };func (_gaff *NRGBA16 )At (x ,y int )_aa .Color {_dede ,_ :=_gaff .ColorAt (x ,y );return _dede };func (_afe *Monochrome )Validate ()error {if len (_afe .Data )!=_afe .Height *_afe .BytesPerLine {return ErrInvalidImage ;
};return nil ;};var _ Image =&Gray2 {};var _ Gray =&Gray16 {};func (_agbf *CMYK32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_agbf .Width ,Y :_agbf .Height }};};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_gca (n )+1);
};var _ Image =&Monochrome {};func _ebcef (_abfd CMYK ,_abbbaa NRGBA ,_agbd _f .Rectangle ){for _egfb :=0;_egfb < _agbd .Max .X ;_egfb ++{for _daac :=0;_daac < _agbd .Max .Y ;_daac ++{_bbcag :=_abfd .CMYKAt (_egfb ,_daac );_abbbaa .SetNRGBA (_egfb ,_daac ,_dgde (_bbcag ));
};};};var _fedg [256]uint8 ;func _gca (_ggcf uint )uint {var _begc uint ;for _ggcf !=0{_ggcf >>=1;_begc ++;};return _begc -1;};func _gabd (_efga ,_ebad Gray ,_bgfb _f .Rectangle ){for _bbfb :=0;_bbfb < _bgfb .Max .X ;_bbfb ++{for _bdcf :=0;_bdcf < _bgfb .Max .Y ;
_bdcf ++{_ebad .SetGray (_bbfb ,_bdcf ,_efga .GrayAt (_bbfb ,_bdcf ));};};};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_cabb :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _daea Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_daea =&Monochrome {ImageBase :_cabb ,ModelThreshold :0x0f};case 2:_daea =&Gray2 {ImageBase :_cabb };case 4:_daea =&Gray4 {ImageBase :_cabb };case 8:_daea =&Gray8 {ImageBase :_cabb };
case 16:_daea =&Gray16 {ImageBase :_cabb };};case 3:switch bitsPerComponent {case 4:_daea =&NRGBA16 {ImageBase :_cabb };case 8:_daea =&NRGBA32 {ImageBase :_cabb };case 16:_daea =&NRGBA64 {ImageBase :_cabb };};case 4:_daea =&CMYK32 {ImageBase :_cabb };};
if _daea ==nil {return nil ,ErrInvalidImage ;};return _daea ,nil ;};func _gad (_ad *Monochrome ,_df int ,_gae []uint )(*Monochrome ,error ){_fe :=_df *_ad .Width ;_dg :=_df *_ad .Height ;_ee :=_fgf (_fe ,_dg );for _eeg ,_eg :=range _gae {var _ce error ;
switch _eg {case 2:_ce =_cea (_ee ,_ad );case 4:_ce =_bg (_ee ,_ad );case 8:_ce =_gb (_ee ,_ad );};if _ce !=nil {return nil ,_ce ;};if _eeg !=len (_gae )-1{_ad =_ee .copy ();};};return _ee ,nil ;};var _ Gray =&Gray8 {};func _agbfg (_efd _aa .Gray )_aa .Gray {_dfa :=_efd .Y >>6;
_dfa |=_dfa <<2;_efd .Y =_dfa |_dfa <<4;return _efd ;};func (_ddeg *CMYK32 )At (x ,y int )_aa .Color {_fae ,_ :=_ddeg .ColorAt (x ,y );return _fae };func _eb ()(_agb [256]uint32 ){for _gcbe :=0;_gcbe < 256;_gcbe ++{if _gcbe &0x01!=0{_agb [_gcbe ]|=0xf;
};if _gcbe &0x02!=0{_agb [_gcbe ]|=0xf0;};if _gcbe &0x04!=0{_agb [_gcbe ]|=0xf00;};if _gcbe &0x08!=0{_agb [_gcbe ]|=0xf000;};if _gcbe &0x10!=0{_agb [_gcbe ]|=0xf0000;};if _gcbe &0x20!=0{_agb [_gcbe ]|=0xf00000;};if _gcbe &0x40!=0{_agb [_gcbe ]|=0xf000000;
};if _gcbe &0x80!=0{_agb [_gcbe ]|=0xf0000000;};};return _agb ;};var _ Image =&NRGBA32 {};func (_effa *Gray4 )Base ()*ImageBase {return &_effa .ImageBase };func _cbbe (_daca *Monochrome ,_abaff ,_eggbc int ,_eagf ,_aaa int ,_ebde RasterOperator ){var (_bffc int ;
_abfb byte ;_fgafb ,_baf int ;_gaa int ;);_cgfa :=_eagf >>3;_fbef :=_eagf &7;if _fbef > 0{_abfb =_dfbb [_fbef ];};_bffc =_daca .BytesPerLine *_eggbc +(_abaff >>3);switch _ebde {case PixClr :for _fgafb =0;_fgafb < _aaa ;_fgafb ++{_gaa =_bffc +_fgafb *_daca .BytesPerLine ;
for _baf =0;_baf < _cgfa ;_baf ++{_daca .Data [_gaa ]=0x0;_gaa ++;};if _fbef > 0{_daca .Data [_gaa ]=_dcbcb (_daca .Data [_gaa ],0x0,_abfb );};};case PixSet :for _fgafb =0;_fgafb < _aaa ;_fgafb ++{_gaa =_bffc +_fgafb *_daca .BytesPerLine ;for _baf =0;_baf < _cgfa ;
_baf ++{_daca .Data [_gaa ]=0xff;_gaa ++;};if _fbef > 0{_daca .Data [_gaa ]=_dcbcb (_daca .Data [_gaa ],0xff,_abfb );};};case PixNotDst :for _fgafb =0;_fgafb < _aaa ;_fgafb ++{_gaa =_bffc +_fgafb *_daca .BytesPerLine ;for _baf =0;_baf < _cgfa ;_baf ++{_daca .Data [_gaa ]=^_daca .Data [_gaa ];
_gaa ++;};if _fbef > 0{_daca .Data [_gaa ]=_dcbcb (_daca .Data [_gaa ],^_daca .Data [_gaa ],_abfb );};};};};func (_ebca *CMYK32 )Base ()*ImageBase {return &_ebca .ImageBase };func ImgToBinary (i _f .Image ,threshold uint8 )*_f .Gray {switch _bfag :=i .(type ){case *_f .Gray :if _fdgc (_bfag ){return _bfag ;
};return _abbc (_bfag ,threshold );case *_f .Gray16 :return _gaeb (_bfag ,threshold );default:return _dfdg (_bfag ,threshold );};};func (_ccba *NRGBA64 )ColorModel ()_aa .Model {return _aa .NRGBA64Model };type Gray4 struct{ImageBase };func (_eedb *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_g .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_cbcd :=_fgf (width ,height );_adb :=make ([]int ,height );_eccf :=make ([]int ,width );_cdg :=float64 (_eedb .Width )/float64 (width );_dfge :=float64 (_eedb .Height )/float64 (height );for _gccb :=0;_gccb < height ;_gccb ++{_adb [_gccb ]=int (_a .Min (_dfge *float64 (_gccb )+0.5,float64 (_eedb .Height -1)));
};for _cfed :=0;_cfed < width ;_cfed ++{_eccf [_cfed ]=int (_a .Min (_cdg *float64 (_cfed )+0.5,float64 (_eedb .Width -1)));};_gfbb :=-1;_fffa :=byte (0);for _abg :=0;_abg < height ;_abg ++{_bade :=_adb [_abg ]*_eedb .BytesPerLine ;_gggd :=_abg *_cbcd .BytesPerLine ;
for _aagf :=0;_aagf < width ;_aagf ++{_dedc :=_eccf [_aagf ];if _dedc !=_gfbb {_fffa =_eedb .getBit (_bade ,_dedc );if _fffa !=0{_cbcd .setBit (_gggd ,_aagf );};_gfbb =_dedc ;}else {if _fffa !=0{_cbcd .setBit (_gggd ,_aagf );};};};};return _cbcd ,nil ;
};func (_ffee *Gray16 )At (x ,y int )_aa .Color {_decf ,_ :=_ffee .ColorAt (x ,y );return _decf };func (_ced *Gray2 )At (x ,y int )_aa .Color {_efeb ,_ :=_ced .ColorAt (x ,y );return _efeb };func _ecf (_cbb _aa .NRGBA )_aa .Gray {_cgf ,_abd ,_gffe ,_ :=_cbb .RGBA ();
_ecfa :=(19595*_cgf +38470*_abd +7471*_gffe +1<<15)>>24;return _aa .Gray {Y :uint8 (_ecfa )};};func (_eaac *NRGBA32 )ColorAt (x ,y int )(_aa .Color ,error ){return ColorAtNRGBA32 (x ,y ,_eaac .Width ,_eaac .Data ,_eaac .Alpha ,_eaac .Decode );};func _dfbd (_aga int ,_ffeb int )int {if _aga < _ffeb {return _aga ;
};return _ffeb ;};func (_eda *Gray8 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_eda .Width ,Y :_eda .Height }};};type RGBA32 struct{ImageBase };func (_ebag *Gray4 )At (x ,y int )_aa .Color {_bbcb ,_ :=_ebag .ColorAt (x ,y );return _bbcb };
func (_ddef *ImageBase )setEightPartlyBytes (_bcdgb ,_cacee int ,_ggba uint64 )(_eded error ){var (_cgffa byte ;_afdac int ;);for _dfgcd :=1;_dfgcd <=_cacee ;_dfgcd ++{_afdac =64-_dfgcd *8;_cgffa =byte (_ggba >>uint (_afdac )&0xff);if _eded =_ddef .setByte (_bcdgb +_dfgcd -1,_cgffa );
_eded !=nil {return _eded ;};};_dfeg :=_ddef .BytesPerLine *8-_ddef .Width ;if _dfeg ==0{return nil ;};_afdac -=8;_cgffa =byte (_ggba >>uint (_afdac )&0xff)<<uint (_dfeg );if _eded =_ddef .setByte (_bcdgb +_cacee ,_cgffa );_eded !=nil {return _eded ;};
return nil ;};func _bcg (_edb Gray ,_aag CMYK ,_cfag _f .Rectangle ){for _cace :=0;_cace < _cfag .Max .X ;_cace ++{for _faeb :=0;_faeb < _cfag .Max .Y ;_faeb ++{_dedg :=_edb .GrayAt (_cace ,_faeb );_aag .SetCMYK (_cace ,_faeb ,_ddc (_dedg ));};};};func (_gbda *NRGBA64 )Set (x ,y int ,c _aa .Color ){_gdbba :=(y *_gbda .Width +x )*2;
_egcab :=_gdbba *3;if _egcab +5>=len (_gbda .Data ){return ;};_defbf :=_aa .NRGBA64Model .Convert (c ).(_aa .NRGBA64 );_gbda .setNRGBA64 (_egcab ,_defbf ,_gdbba );};func (_bega *Gray4 )setGray (_cbf int ,_bbbf int ,_beggd _aa .Gray ){_efb :=_bbbf *_bega .BytesPerLine ;
_fefc :=_efb +(_cbf >>1);if _fefc >=len (_bega .Data ){return ;};_dbg :=_beggd .Y >>4;_bega .Data [_fefc ]=(_bega .Data [_fefc ]&(^(0xf0>>uint (4*(_cbf &1)))))|(_dbg <<uint (4-4*(_cbf &1)));};func (_gdf *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_eggb :=_gca (uint (factor ));
if !IsPowerOf2 (uint (factor )){_eggb ++;};_bfce :=make ([]int ,_eggb );for _ggfa :=range _bfce {_bfce [_ggfa ]=4;};_aaeg ,_cbc :=_dea (_gdf ,_bfce ...);if _cbc !=nil {return nil ,_cbc ;};return _aaeg ,nil ;};var _ _f .Image =&Monochrome {};type CMYK32 struct{ImageBase };
func _cebg (_ddge Gray ,_bagf NRGBA ,_fgbad _f .Rectangle ){for _afbd :=0;_afbd < _fgbad .Max .X ;_afbd ++{for _gda :=0;_gda < _fgbad .Max .Y ;_gda ++{_ffdd :=_ddge .GrayAt (_afbd ,_gda );_bagf .SetNRGBA (_afbd ,_gda ,_dee (_ffdd ));};};};func (_egaa monochromeModel )Convert (c _aa .Color )_aa .Color {_bffd :=_aa .GrayModel .Convert (c ).(_aa .Gray );
return _eaga (_bffd ,_egaa );};var _ _f .Image =&Gray4 {};var _ _f .Image =&Gray8 {};var _ _f .Image =&NRGBA16 {};func init (){_dfce ()};func _dfce (){for _aefb :=0;_aefb < 256;_aefb ++{_fedg [_aefb ]=uint8 (_aefb &0x1)+(uint8 (_aefb >>1)&0x1)+(uint8 (_aefb >>2)&0x1)+(uint8 (_aefb >>3)&0x1)+(uint8 (_aefb >>4)&0x1)+(uint8 (_aefb >>5)&0x1)+(uint8 (_aefb >>6)&0x1)+(uint8 (_aefb >>7)&0x1);
};};func _gg (_gaf *Monochrome ,_ab int )(*Monochrome ,error ){if _gaf ==nil {return nil ,_g .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _ab ==1{return _gaf .copy (),nil ;};if !IsPowerOf2 (uint (_ab )){return nil ,_gc .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ab );
};_dc :=_dad (_ab );return _gad (_gaf ,_ab ,_dc );};var _ NRGBA =&NRGBA32 {};func (_agbc *Monochrome )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_agbc .Width ,Y :_agbc .Height }};};func (_gagg *NRGBA64 )ColorAt (x ,y int )(_aa .Color ,error ){return ColorAtNRGBA64 (x ,y ,_gagg .Width ,_gagg .Data ,_gagg .Alpha ,_gagg .Decode );
};func (_bcbd *NRGBA64 )Validate ()error {if len (_bcbd .Data )!=3*2*_bcbd .Width *_bcbd .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_bfdb *Gray16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_bfdb .Width ,Y :_bfdb .Height }};};func (_fcge *RGBA32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_fcge .Width ,Y :_fcge .Height }};
};func (_deaa *NRGBA16 )Set (x ,y int ,c _aa .Color ){_abbb :=y *_deaa .BytesPerLine +x *3/2;if _abbb +1>=len (_deaa .Data ){return ;};_bcga :=NRGBA16Model .Convert (c ).(_aa .NRGBA );_deaa .setNRGBA (x ,y ,_abbb ,_bcga );};type CMYK interface{CMYKAt (_bca ,_cdf int )_aa .CMYK ;
SetCMYK (_ffbc ,_ggd int ,_bdgc _aa .CMYK );};func (_ecaa *RGBA32 )At (x ,y int )_aa .Color {_feac ,_ :=_ecaa .ColorAt (x ,y );return _feac };func _dfdg (_gcad _f .Image ,_dafd uint8 )*_f .Gray {_afcca :=_gcad .Bounds ();_aebe :=_f .NewGray (_afcca );var (_fabe _aa .Color ;
_defc _aa .Gray ;);for _ddbca :=0;_ddbca < _afcca .Max .X ;_ddbca ++{for _fadbgc :=0;_fadbgc < _afcca .Max .Y ;_fadbgc ++{_fabe =_gcad .At (_ddbca ,_fadbgc );_aebe .Set (_ddbca ,_fadbgc ,_fabe );_defc =_aebe .GrayAt (_ddbca ,_fadbgc );_aebe .SetGray (_ddbca ,_fadbgc ,_aa .Gray {Y :_agac (_defc .Y ,_dafd )});
};};return _aebe ;};type RasterOperator int ;var _ _f .Image =&NRGBA32 {};var ErrInvalidImage =_g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_cdae *Gray16 )Validate ()error {if len (_cdae .Data )!=_cdae .Height *_cdae .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_cgff *Gray8 )Validate ()error {if len (_cgff .Data )!=_cgff .Height *_cgff .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_ebdeb *NRGBA64 )SetNRGBA64 (x ,y int ,c _aa .NRGBA64 ){_ffga :=(y *_ebdeb .Width +x )*2;_dccd :=_ffga *3;if _dccd +5>=len (_ebdeb .Data ){return ;};_ebdeb .setNRGBA64 (_dccd ,c ,_ffga );};func (_dga *NRGBA16 )Base ()*ImageBase {return &_dga .ImageBase };
func (_afda *Gray4 )GrayAt (x ,y int )_aa .Gray {_bgeb ,_ :=ColorAtGray4BPC (x ,y ,_afda .BytesPerLine ,_afda .Data ,_afda .Decode );return _bgeb ;};func _adccd (_adgb _f .Image )(Image ,error ){if _bda ,_ffde :=_adgb .(*Gray2 );_ffde {return _bda .Copy (),nil ;
};_fgaf :=_adgb .Bounds ();_eecd ,_fgfg :=NewImage (_fgaf .Max .X ,_fgaf .Max .Y ,2,1,nil ,nil ,nil );if _fgfg !=nil {return nil ,_fgfg ;};_cfdbf (_adgb ,_eecd ,_fgaf );return _eecd ,nil ;};func (_cefb *Gray2 )Base ()*ImageBase {return &_cefb .ImageBase };
func (_dcfd *ImageBase )newAlpha (){_gcgf :=BytesPerLine (_dcfd .Width ,_dcfd .BitsPerComponent ,1);_dcfd .Alpha =make ([]byte ,_dcfd .Height *_gcgf );};func (_bbaa *Monochrome )setGray (_cddc int ,_beba _aa .Gray ,_fee int ){if _beba .Y ==0{_bbaa .clearBit (_fee ,_cddc );
}else {_bbaa .setGrayBit (_fee ,_cddc );};};func (_gdce *Gray4 )SetGray (x ,y int ,g _aa .Gray ){if x >=_gdce .Width ||y >=_gdce .Height {return ;};g =_ggca (g );_gdce .setGray (x ,y ,g );};func _ddc (_dged _aa .Gray )_aa .CMYK {return _aa .CMYK {K :0xff-_dged .Y }};
func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_feec :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_feec .Data =make ([]byte ,height *_feec .BytesPerLine );};return _feec ;};const (_gcga shift =iota ;_cgag ;);func _dgded (_eccd nrgba64 ,_bbadd NRGBA ,_dada _f .Rectangle ){for _gfecg :=0;_gfecg < _dada .Max .X ;_gfecg ++{for _fbfe :=0;
_fbfe < _dada .Max .Y ;_fbfe ++{_aceg :=_eccd .NRGBA64At (_gfecg ,_fbfe );_bbadd .SetNRGBA (_gfecg ,_fbfe ,_efcg (_aceg ));};};};func (_bdff *Gray4 )Validate ()error {if len (_bdff .Data )!=_bdff .Height *_bdff .BytesPerLine {return ErrInvalidImage ;};
return nil ;};func (_aafg *ImageBase )setTwoBytes (_deeg int ,_aagd uint16 )error {if _deeg +1> len (_aafg .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_aafg .Data [_deeg ]=byte ((_aagd &0xff00)>>8);
_aafg .Data [_deeg +1]=byte (_aagd &0xff);return nil ;};func (_fbae *Monochrome )GrayAt (x ,y int )_aa .Gray {_aea ,_ :=ColorAtGray1BPC (x ,y ,_fbae .BytesPerLine ,_fbae .Data ,_fbae .Decode );return _aea ;};func _bcde (_dcf ,_gceg CMYK ,_cdc _f .Rectangle ){for _efc :=0;
_efc < _cdc .Max .X ;_efc ++{for _ggab :=0;_ggab < _cdc .Max .Y ;_ggab ++{_gceg .SetCMYK (_efc ,_ggab ,_dcf .CMYKAt (_efc ,_ggab ));};};};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func _cacd (_ggc _aa .CMYK )_aa .RGBA {_bef ,_ddf ,_bcge :=_aa .CMYKToRGB (_ggc .C ,_ggc .M ,_ggc .Y ,_ggc .K );return _aa .RGBA {R :_bef ,G :_ddf ,B :_bcge ,A :0xff};};func (_bcae *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _dbc bool ;
_dade :=scale ;if scale < 1{_dade =1/scale ;_dbc =true ;};_aege :=NextPowerOf2 (uint (_dade ));if InDelta (float64 (_aege ),_dade ,0.001){if _dbc {return _bcae .ReduceBinary (_dade );};return _bcae .ExpandBinary (int (_aege ));};_baec :=int (_a .RoundToEven (float64 (_bcae .Width )*scale ));
_bbecfg :=int (_a .RoundToEven (float64 (_bcae .Height )*scale ));return _bcae .ScaleLow (_baec ,_bbecfg );};func _defe (_ceee *Monochrome ,_bgae ,_gdcc int ,_ace ,_gagdc int ,_feba RasterOperator ){var (_dbbb bool ;_gccf bool ;_efcb int ;_dbed int ;_efdbb int ;
_fgfgd int ;_ebea bool ;_geede byte ;);_dgeb :=8-(_bgae &7);_faae :=_bee [_dgeb ];_cbdb :=_ceee .BytesPerLine *_gdcc +(_bgae >>3);if _ace < _dgeb {_dbbb =true ;_faae &=_dfbb [8-_dgeb +_ace ];};if !_dbbb {_efcb =(_ace -_dgeb )>>3;if _efcb !=0{_gccf =true ;
_dbed =_cbdb +1;};};_efdbb =(_bgae +_ace )&7;if !(_dbbb ||_efdbb ==0){_ebea =true ;_geede =_dfbb [_efdbb ];_fgfgd =_cbdb +1+_efcb ;};var _gabf ,_gfff int ;switch _feba {case PixClr :for _gabf =0;_gabf < _gagdc ;_gabf ++{_ceee .Data [_cbdb ]=_dcbcb (_ceee .Data [_cbdb ],0x0,_faae );
_cbdb +=_ceee .BytesPerLine ;};if _gccf {for _gabf =0;_gabf < _gagdc ;_gabf ++{for _gfff =0;_gfff < _efcb ;_gfff ++{_ceee .Data [_dbed +_gfff ]=0x0;};_dbed +=_ceee .BytesPerLine ;};};if _ebea {for _gabf =0;_gabf < _gagdc ;_gabf ++{_ceee .Data [_fgfgd ]=_dcbcb (_ceee .Data [_fgfgd ],0x0,_geede );
_fgfgd +=_ceee .BytesPerLine ;};};case PixSet :for _gabf =0;_gabf < _gagdc ;_gabf ++{_ceee .Data [_cbdb ]=_dcbcb (_ceee .Data [_cbdb ],0xff,_faae );_cbdb +=_ceee .BytesPerLine ;};if _gccf {for _gabf =0;_gabf < _gagdc ;_gabf ++{for _gfff =0;_gfff < _efcb ;
_gfff ++{_ceee .Data [_dbed +_gfff ]=0xff;};_dbed +=_ceee .BytesPerLine ;};};if _ebea {for _gabf =0;_gabf < _gagdc ;_gabf ++{_ceee .Data [_fgfgd ]=_dcbcb (_ceee .Data [_fgfgd ],0xff,_geede );_fgfgd +=_ceee .BytesPerLine ;};};case PixNotDst :for _gabf =0;
_gabf < _gagdc ;_gabf ++{_ceee .Data [_cbdb ]=_dcbcb (_ceee .Data [_cbdb ],^_ceee .Data [_cbdb ],_faae );_cbdb +=_ceee .BytesPerLine ;};if _gccf {for _gabf =0;_gabf < _gagdc ;_gabf ++{for _gfff =0;_gfff < _efcb ;_gfff ++{_ceee .Data [_dbed +_gfff ]=^(_ceee .Data [_dbed +_gfff ]);
};_dbed +=_ceee .BytesPerLine ;};};if _ebea {for _gabf =0;_gabf < _gagdc ;_gabf ++{_ceee .Data [_fgfgd ]=_dcbcb (_ceee .Data [_fgfgd ],^_ceee .Data [_fgfgd ],_geede );_fgfgd +=_ceee .BytesPerLine ;};};};};func _aebf (_bcfa RGBA ,_eabc Gray ,_dgfg _f .Rectangle ){for _fedc :=0;
_fedc < _dgfg .Max .X ;_fedc ++{for _eeag :=0;_eeag < _dgfg .Max .Y ;_eeag ++{_aggd :=_gbb (_bcfa .RGBAAt (_fedc ,_eeag ));_eabc .SetGray (_fedc ,_eeag ,_aggd );};};};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_c :=BytesPerLine (width ,8,1);
if len (data )< _c *height {return nil ,nil ;};_d :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_afg ,_b :=MonochromeConverter .Convert (_d );if _b !=nil {return nil ,_b ;};return _afg .Base ().Data ,nil ;};func (_cbce *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_cbce .copy ()}};
func (_fbde *Monochrome )Histogram ()(_egda [256]int ){for _ ,_fbgf :=range _fbde .Data {_egda [0xff]+=int (_fedg [_fbde .Data [_fbgf ]]);};return _egda ;};var _ _f .Image =&Gray2 {};type NRGBA interface{NRGBAAt (_fdff ,_gef int )_aa .NRGBA ;SetNRGBA (_baff ,_bfbc int ,_gcgb _aa .NRGBA );
};var _ _f .Image =&RGBA32 {};var (MonochromeConverter =ConverterFunc (_gab );Gray2Converter =ConverterFunc (_adccd );Gray4Converter =ConverterFunc (_egba );GrayConverter =ConverterFunc (_afea );Gray16Converter =ConverterFunc (_efgc );NRGBA16Converter =ConverterFunc (_agge );
NRGBAConverter =ConverterFunc (_gcgbb );NRGBA64Converter =ConverterFunc (_dceff );RGBAConverter =ConverterFunc (_dfbdg );CMYKConverter =ConverterFunc (_cfa ););func (_dfcc *RGBA32 )ColorModel ()_aa .Model {return _aa .NRGBAModel };func (_faf *Gray4 )Histogram ()(_bfa [256]int ){for _afee :=0;
_afee < _faf .Width ;_afee ++{for _geag :=0;_geag < _faf .Height ;_geag ++{_bfa [_faf .GrayAt (_afee ,_geag ).Y ]++;};};return _bfa ;};func (_eeea *Gray2 )SetGray (x ,y int ,gray _aa .Gray ){_agd :=_agbfg (gray );_dff :=y *_eeea .BytesPerLine ;_cfeb :=_dff +(x >>2);
if _cfeb >=len (_eeea .Data ){return ;};_bfcg :=_agd .Y >>6;_eeea .Data [_cfeb ]=(_eeea .Data [_cfeb ]&(^(0xc0>>uint (2*((x )&3)))))|(_bfcg <<uint (6-2*(x &3)));};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_aa .Gray ,error ){_egc :=y *bytesPerLine +x >>1;
if _egc >=len (data ){return _aa .Gray {},_gc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_beag :=data [_egc ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_beag =uint8 (uint32 (LinearInterpolate (float64 (_beag ),0,15,decode [0],decode [1]))&0xf);};return _aa .Gray {Y :_beag *17&0xff},nil ;};func (_feae *ImageBase )setByte (_geac int ,_gfdg byte )error {if _geac > len (_feae .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_feae .Data [_geac ]=_gfdg ;return nil ;};func _ggca (_cccc _aa .Gray )_aa .Gray {_cccc .Y >>=4;_cccc .Y |=_cccc .Y <<4;return _cccc };func (_efbg *NRGBA16 )ColorAt (x ,y int )(_aa .Color ,error ){return ColorAtNRGBA16 (x ,y ,_efbg .Width ,_efbg .BytesPerLine ,_efbg .Data ,_efbg .Alpha ,_efbg .Decode );
};func (_bace *Gray16 )Base ()*ImageBase {return &_bace .ImageBase };func _ebfe (_dcgf *Monochrome ,_eae ,_bfee ,_adgg ,_cbad int ,_defg RasterOperator ,_bdba *Monochrome ,_abc ,_defb int )error {var (_eece bool ;_dcc bool ;_agcdg int ;_egac int ;_cfge int ;
_cfaf bool ;_fac byte ;_eggbg int ;_dfgf int ;_efac int ;_aad ,_bdbe int ;);_fgce :=8-(_eae &7);_gac :=_bee [_fgce ];_dgdc :=_dcgf .BytesPerLine *_bfee +(_eae >>3);_ddad :=_bdba .BytesPerLine *_defb +(_abc >>3);if _adgg < _fgce {_eece =true ;_gac &=_dfbb [8-_fgce +_adgg ];
};if !_eece {_agcdg =(_adgg -_fgce )>>3;if _agcdg > 0{_dcc =true ;_egac =_dgdc +1;_cfge =_ddad +1;};};_eggbg =(_eae +_adgg )&7;if !(_eece ||_eggbg ==0){_cfaf =true ;_fac =_dfbb [_eggbg ];_dfgf =_dgdc +1+_agcdg ;_efac =_ddad +1+_agcdg ;};switch _defg {case PixSrc :for _aad =0;
_aad < _cbad ;_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],_bdba .Data [_ddad ],_gac );_dgdc +=_dcgf .BytesPerLine ;_ddad +=_bdba .BytesPerLine ;};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;_bdbe ++{_dcgf .Data [_egac +_bdbe ]=_bdba .Data [_cfge +_bdbe ];
};_egac +=_dcgf .BytesPerLine ;_cfge +=_bdba .BytesPerLine ;};};if _cfaf {for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],_bdba .Data [_efac ],_fac );_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;};};case PixNotSrc :for _aad =0;
_aad < _cbad ;_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],^_bdba .Data [_ddad ],_gac );_dgdc +=_dcgf .BytesPerLine ;_ddad +=_bdba .BytesPerLine ;};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;_bdbe ++{_dcgf .Data [_egac +_bdbe ]=^_bdba .Data [_cfge +_bdbe ];
};_egac +=_dcgf .BytesPerLine ;_cfge +=_bdba .BytesPerLine ;};};if _cfaf {for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],^_bdba .Data [_efac ],_fac );_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;};};case PixSrcOrDst :for _aad =0;
_aad < _cbad ;_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],_bdba .Data [_ddad ]|_dcgf .Data [_dgdc ],_gac );_dgdc +=_dcgf .BytesPerLine ;_ddad +=_bdba .BytesPerLine ;};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;
_bdbe ++{_dcgf .Data [_egac +_bdbe ]|=_bdba .Data [_cfge +_bdbe ];};_egac +=_dcgf .BytesPerLine ;_cfge +=_bdba .BytesPerLine ;};};if _cfaf {for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],_bdba .Data [_efac ]|_dcgf .Data [_dfgf ],_fac );
_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;};};case PixSrcAndDst :for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],_bdba .Data [_ddad ]&_dcgf .Data [_dgdc ],_gac );_dgdc +=_dcgf .BytesPerLine ;_ddad +=_bdba .BytesPerLine ;
};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;_bdbe ++{_dcgf .Data [_egac +_bdbe ]&=_bdba .Data [_cfge +_bdbe ];};_egac +=_dcgf .BytesPerLine ;_cfge +=_bdba .BytesPerLine ;};};if _cfaf {for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],_bdba .Data [_efac ]&_dcgf .Data [_dfgf ],_fac );
_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;};};case PixSrcXorDst :for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],_bdba .Data [_ddad ]^_dcgf .Data [_dgdc ],_gac );_dgdc +=_dcgf .BytesPerLine ;_ddad +=_bdba .BytesPerLine ;
};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;_bdbe ++{_dcgf .Data [_egac +_bdbe ]^=_bdba .Data [_cfge +_bdbe ];};_egac +=_dcgf .BytesPerLine ;_cfge +=_bdba .BytesPerLine ;};};if _cfaf {for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],_bdba .Data [_efac ]^_dcgf .Data [_dfgf ],_fac );
_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;};};case PixNotSrcOrDst :for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],^(_bdba .Data [_ddad ])|_dcgf .Data [_dgdc ],_gac );_dgdc +=_dcgf .BytesPerLine ;_ddad +=_bdba .BytesPerLine ;
};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;_bdbe ++{_dcgf .Data [_egac +_bdbe ]|=^(_bdba .Data [_cfge +_bdbe ]);};_egac +=_dcgf .BytesPerLine ;_cfge +=_bdba .BytesPerLine ;};};if _cfaf {for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],^(_bdba .Data [_efac ])|_dcgf .Data [_dfgf ],_fac );
_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;};};case PixNotSrcAndDst :for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],^(_bdba .Data [_ddad ])&_dcgf .Data [_dgdc ],_gac );_dgdc +=_dcgf .BytesPerLine ;_ddad +=_bdba .BytesPerLine ;
};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;_bdbe ++{_dcgf .Data [_egac +_bdbe ]&=^_bdba .Data [_cfge +_bdbe ];};_egac +=_dcgf .BytesPerLine ;_cfge +=_bdba .BytesPerLine ;};};if _cfaf {for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],^(_bdba .Data [_efac ])&_dcgf .Data [_dfgf ],_fac );
_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;};};case PixSrcOrNotDst :for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],_bdba .Data [_ddad ]|^(_dcgf .Data [_dgdc ]),_gac );_dgdc +=_dcgf .BytesPerLine ;_ddad +=_bdba .BytesPerLine ;
};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;_bdbe ++{_dcgf .Data [_egac +_bdbe ]=_bdba .Data [_cfge +_bdbe ]|^(_dcgf .Data [_egac +_bdbe ]);};_egac +=_dcgf .BytesPerLine ;_cfge +=_bdba .BytesPerLine ;};};if _cfaf {for _aad =0;
_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],_bdba .Data [_efac ]|^(_dcgf .Data [_dfgf ]),_fac );_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;};};case PixSrcAndNotDst :for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],_bdba .Data [_ddad ]&^(_dcgf .Data [_dgdc ]),_gac );
_dgdc +=_dcgf .BytesPerLine ;_ddad +=_bdba .BytesPerLine ;};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;_bdbe ++{_dcgf .Data [_egac +_bdbe ]=_bdba .Data [_cfge +_bdbe ]&^(_dcgf .Data [_egac +_bdbe ]);};_egac +=_dcgf .BytesPerLine ;
_cfge +=_bdba .BytesPerLine ;};};if _cfaf {for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],_bdba .Data [_efac ]&^(_dcgf .Data [_dfgf ]),_fac );_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;};};case PixNotPixSrcOrDst :for _aad =0;
_aad < _cbad ;_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],^(_bdba .Data [_ddad ]|_dcgf .Data [_dgdc ]),_gac );_dgdc +=_dcgf .BytesPerLine ;_ddad +=_bdba .BytesPerLine ;};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;
_bdbe ++{_dcgf .Data [_egac +_bdbe ]=^(_bdba .Data [_cfge +_bdbe ]|_dcgf .Data [_egac +_bdbe ]);};_egac +=_dcgf .BytesPerLine ;_cfge +=_bdba .BytesPerLine ;};};if _cfaf {for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],^(_bdba .Data [_efac ]|_dcgf .Data [_dfgf ]),_fac );
_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;};};case PixNotPixSrcAndDst :for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],^(_bdba .Data [_ddad ]&_dcgf .Data [_dgdc ]),_gac );_dgdc +=_dcgf .BytesPerLine ;
_ddad +=_bdba .BytesPerLine ;};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;_bdbe ++{_dcgf .Data [_egac +_bdbe ]=^(_bdba .Data [_cfge +_bdbe ]&_dcgf .Data [_egac +_bdbe ]);};_egac +=_dcgf .BytesPerLine ;_cfge +=_bdba .BytesPerLine ;
};};if _cfaf {for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],^(_bdba .Data [_efac ]&_dcgf .Data [_dfgf ]),_fac );_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;};};case PixNotPixSrcXorDst :for _aad =0;_aad < _cbad ;
_aad ++{_dcgf .Data [_dgdc ]=_dcbcb (_dcgf .Data [_dgdc ],^(_bdba .Data [_ddad ]^_dcgf .Data [_dgdc ]),_gac );_dgdc +=_dcgf .BytesPerLine ;_ddad +=_bdba .BytesPerLine ;};if _dcc {for _aad =0;_aad < _cbad ;_aad ++{for _bdbe =0;_bdbe < _agcdg ;_bdbe ++{_dcgf .Data [_egac +_bdbe ]=^(_bdba .Data [_cfge +_bdbe ]^_dcgf .Data [_egac +_bdbe ]);
};_egac +=_dcgf .BytesPerLine ;_cfge +=_bdba .BytesPerLine ;};};if _cfaf {for _aad =0;_aad < _cbad ;_aad ++{_dcgf .Data [_dfgf ]=_dcbcb (_dcgf .Data [_dfgf ],^(_bdba .Data [_efac ]^_dcgf .Data [_dfgf ]),_fac );_dfgf +=_dcgf .BytesPerLine ;_efac +=_bdba .BytesPerLine ;
};};default:_fc .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_defg );return _g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _gefe (_gbgab _aa .Color )_aa .Color {_bcee :=_aa .NRGBAModel .Convert (_gbgab ).(_aa .NRGBA );return _fead (_bcee );};func (_bddc *NRGBA16 )setNRGBA (_cacdd ,_dgbd ,_cadc int ,_gaea _aa .NRGBA ){if _cacdd *3%2==0{_bddc .Data [_cadc ]=(_gaea .R >>4)<<4|(_gaea .G >>4);
_bddc .Data [_cadc +1]=(_gaea .B >>4)<<4|(_bddc .Data [_cadc +1]&0xf);}else {_bddc .Data [_cadc ]=(_bddc .Data [_cadc ]&0xf0)|(_gaea .R >>4);_bddc .Data [_cadc +1]=(_gaea .G >>4)<<4|(_gaea .B >>4);};if _bddc .Alpha !=nil {_feef :=_dgbd *BytesPerLine (_bddc .Width ,4,1);
if _feef < len (_bddc .Alpha ){if _cacdd %2==0{_bddc .Alpha [_feef ]=(_gaea .A >>uint (4))<<uint (4)|(_bddc .Alpha [_cadc ]&0xf);}else {_bddc .Alpha [_feef ]=(_bddc .Alpha [_feef ]&0xf0)|(_gaea .A >>uint (4));};};};};var (_gce =_bff ();_dbf =_eb ();_cbg =_ede ();
);func (_gfc *CMYK32 )ColorAt (x ,y int )(_aa .Color ,error ){return ColorAtCMYK (x ,y ,_gfc .Width ,_gfc .Data ,_gfc .Decode );};func _gb (_ef ,_dgf *Monochrome )(_fcd error ){_abfg :=_dgf .BytesPerLine ;_cg :=_ef .BytesPerLine ;var _acg ,_ggf ,_fcg ,_gcb ,_ae int ;
for _fcg =0;_fcg < _dgf .Height ;_fcg ++{_acg =_fcg *_abfg ;_ggf =8*_fcg *_cg ;for _gcb =0;_gcb < _abfg ;_gcb ++{if _fcd =_ef .setEightBytes (_ggf +_gcb *8,_cbg [_dgf .Data [_acg +_gcb ]]);_fcd !=nil {return _fcd ;};};for _ae =1;_ae < 8;_ae ++{for _gcb =0;
_gcb < _cg ;_gcb ++{if _fcd =_ef .setByte (_ggf +_ae *_cg +_gcb ,_ef .Data [_ggf +_gcb ]);_fcd !=nil {return _fcd ;};};};};return nil ;};func (_cgea *NRGBA16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_cgea .Width ,Y :_cgea .Height }};
};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_aa .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );
case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_gc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_cfdfd *RGBA32 )Set (x ,y int ,c _aa .Color ){_acea :=y *_cfdfd .Width +x ;_cade :=3*_acea ;if _cade +2>=len (_cfdfd .Data ){return ;};_acfca :=_aa .RGBAModel .Convert (c ).(_aa .RGBA );_cfdfd .setRGBA (_acea ,_acfca );};func _cfdbf (_eegb _f .Image ,_dbda Image ,_fce _f .Rectangle ){switch _fad :=_eegb .(type ){case Gray :_gabd (_fad ,_dbda .(Gray ),_fce );
case NRGBA :_febf (_fad ,_dbda .(Gray ),_fce );case CMYK :_fegca (_fad ,_dbda .(Gray ),_fce );case RGBA :_aebf (_fad ,_dbda .(Gray ),_fce );default:_gfba (_eegb ,_dbda ,_fce );};};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_aa .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_gc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_ecd *monochromeThresholdConverter )Convert (img _f .Image )(Image ,error ){if _egd ,_efcf :=img .(*Monochrome );_efcf {return _egd .Copy (),nil ;};_gfa :=img .Bounds ();_ecce ,_fbd :=NewImage (_gfa .Max .X ,_gfa .Max .Y ,1,1,nil ,nil ,nil );
if _fbd !=nil {return nil ,_fbd ;};_ecce .(*Monochrome ).ModelThreshold =_ecd .Threshold ;for _aee :=0;_aee < _gfa .Max .X ;_aee ++{for _fed :=0;_fed < _gfa .Max .Y ;_fed ++{_abfc :=img .At (_aee ,_fed );_ecce .Set (_aee ,_fed ,_abfc );};};return _ecce ,nil ;
};func _eebcb (_face int ,_dgdec int )error {return _gc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_face ,_dgdec );
};var _ RGBA =&RGBA32 {};func (_ddfg *Gray16 )Histogram ()(_caa [256]int ){for _cefg :=0;_cefg < _ddfg .Width ;_cefg ++{for _cbed :=0;_cbed < _ddfg .Height ;_cbed ++{_caa [_ddfg .GrayAt (_cefg ,_cbed ).Y ]++;};};return _caa ;};func _baceg (_feddc _f .Image ,_egce Image ,_eefdg _f .Rectangle ){if _acdf ,_gadfe :=_feddc .(SMasker );
_gadfe &&_acdf .HasAlpha (){_egce .(SMasker ).MakeAlpha ();};_gfba (_feddc ,_egce ,_eefdg );};func (_cdb *Monochrome )setBit (_cbe ,_bbb int ){_cdb .Data [_cbe +(_bbb >>3)]|=0x80>>uint (_bbb &7)};func _dad (_eed int )[]uint {var _cgd []uint ;_fd :=_eed ;
_ccd :=_fd /8;if _ccd !=0{for _cae :=0;_cae < _ccd ;_cae ++{_cgd =append (_cgd ,8);};_adcb :=_fd %8;_fd =0;if _adcb !=0{_fd =_adcb ;};};_dfb :=_fd /4;if _dfb !=0{for _de :=0;_de < _dfb ;_de ++{_cgd =append (_cgd ,4);};_abac :=_fd %4;_fd =0;if _abac !=0{_fd =_abac ;
};};_agg :=_fd /2;if _agg !=0{for _dfc :=0;_dfc < _agg ;_dfc ++{_cgd =append (_cgd ,2);};};return _cgd ;};func (_aaea *Gray4 )ColorModel ()_aa .Model {return Gray4Model };func _fedd (_gdcce []byte ,_bfdd Image )error {_aec :=true ;for _bfab :=0;_bfab < len (_gdcce );
_bfab ++{if _gdcce [_bfab ]!=0xff{_aec =false ;break ;};};if _aec {switch _bfec :=_bfdd .(type ){case *NRGBA32 :_bfec .Alpha =nil ;case *NRGBA64 :_bfec .Alpha =nil ;default:return _gc .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_bfdd );
};};return nil ;};func (_cgb *Monochrome )setIndexedBit (_gagf int ){_cgb .Data [(_gagf >>3)]|=0x80>>uint (_gagf &7)};func _gagd (_eab Gray ,_ggff nrgba64 ,_dece _f .Rectangle ){for _ebg :=0;_ebg < _dece .Max .X ;_ebg ++{for _daec :=0;_daec < _dece .Max .Y ;
_daec ++{_afd :=_abdb (_ggff .NRGBA64At (_ebg ,_daec ));_eab .SetGray (_ebg ,_daec ,_afd );};};};func (_cabg *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_cabg .copy ()}};func _abbc (_dagf *_f .Gray ,_dcddb uint8 )*_f .Gray {_cffc :=_dagf .Bounds ();
_ebgb :=_f .NewGray (_cffc );for _bfca :=0;_bfca < _cffc .Dx ();_bfca ++{for _eddg :=0;_eddg < _cffc .Dy ();_eddg ++{_cag :=_dagf .GrayAt (_bfca ,_eddg );_ebgb .SetGray (_bfca ,_eddg ,_aa .Gray {Y :_agac (_cag .Y ,_dcddb )});};};return _ebgb ;};type Gray2 struct{ImageBase };
func _abdb (_abfgg _aa .NRGBA64 )_aa .Gray {var _gddd _aa .NRGBA64 ;if _abfgg ==_gddd {return _aa .Gray {Y :0xff};};_bdd ,_daf ,_fcbb ,_ :=_abfgg .RGBA ();_gcee :=(19595*_bdd +38470*_daf +7471*_fcbb +1<<15)>>24;return _aa .Gray {Y :uint8 (_gcee )};};func (_bbe *CMYK32 )Validate ()error {if len (_bbe .Data )!=4*_bbe .Width *_bbe .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_ceda *NRGBA16 )SetNRGBA (x ,y int ,c _aa .NRGBA ){_gfaf :=y *_ceda .BytesPerLine +x *3/2;if _gfaf +1>=len (_ceda .Data ){return ;};c =_fead (c );_ceda .setNRGBA (x ,y ,_gfaf ,c );};func (_cgcd *Gray4 )Set (x ,y int ,c _aa .Color ){if x >=_cgcd .Width ||y >=_cgcd .Height {return ;
};_dafeb :=Gray4Model .Convert (c ).(_aa .Gray );_cgcd .setGray (x ,y ,_dafeb );};func (_bbad *NRGBA32 )SetNRGBA (x ,y int ,c _aa .NRGBA ){_aeec :=y *_bbad .Width +x ;_bcbg :=3*_aeec ;if _bcbg +2>=len (_bbad .Data ){return ;};_bbad .setRGBA (_aeec ,c );
};type Gray8 struct{ImageBase };func _aed (_ddac CMYK ,_cdge RGBA ,_fbdbf _f .Rectangle ){for _gbgc :=0;_gbgc < _fbdbf .Max .X ;_gbgc ++{for _efdg :=0;_efdg < _fbdbf .Max .Y ;_efdg ++{_dabe :=_ddac .CMYKAt (_gbgc ,_efdg );_cdge .SetRGBA (_gbgc ,_efdg ,_cacd (_dabe ));
};};};func _ddd (_debgf _aa .Color )_aa .Color {_ccca :=_aa .GrayModel .Convert (_debgf ).(_aa .Gray );return _ggca (_ccca );};func _gfe (_fbee _aa .Color )_aa .Color {_eabg :=_aa .GrayModel .Convert (_fbee ).(_aa .Gray );return _agbfg (_eabg );};func (_dbad *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _gg (_dbad ,factor );};func (_cfdb *Gray2 )Histogram ()(_cdca [256]int ){for _fgba :=0;_fgba < _cfdb .Width ;_fgba ++{for _agfcb :=0;_agfcb < _cfdb .Height ;_agfcb ++{_cdca [_cfdb .GrayAt (_fgba ,_agfcb ).Y ]++;};};return _cdca ;};func _bg (_adg ,_gada *Monochrome )(_gdb error ){_fb :=_gada .BytesPerLine ;
_edf :=_adg .BytesPerLine ;_ged :=_gada .BytesPerLine *4-_adg .BytesPerLine ;var (_ag ,_ca byte ;_dgg uint32 ;_aae ,_fbg ,_cc ,_be ,_ffb ,_cf ,_gdd int ;);for _cc =0;_cc < _gada .Height ;_cc ++{_aae =_cc *_fb ;_fbg =4*_cc *_edf ;for _be =0;_be < _fb ;_be ++{_ag =_gada .Data [_aae +_be ];
_dgg =_dbf [_ag ];_cf =_fbg +_be *4;if _ged !=0&&(_be +1)*4> _adg .BytesPerLine {for _ffb =_ged ;_ffb > 0;_ffb --{_ca =byte ((_dgg >>uint (_ffb *8))&0xff);_gdd =_cf +(_ged -_ffb );if _gdb =_adg .setByte (_gdd ,_ca );_gdb !=nil {return _gdb ;};};}else if _gdb =_adg .setFourBytes (_cf ,_dgg );
_gdb !=nil {return _gdb ;};if _gdb =_adg .setFourBytes (_fbg +_be *4,_dbf [_gada .Data [_aae +_be ]]);_gdb !=nil {return _gdb ;};};for _ffb =1;_ffb < 4;_ffb ++{for _be =0;_be < _edf ;_be ++{if _gdb =_adg .setByte (_fbg +_ffb *_edf +_be ,_adg .Data [_fbg +_be ]);
_gdb !=nil {return _gdb ;};};};};return nil ;};func (_ebe *CMYK32 )SetCMYK (x ,y int ,c _aa .CMYK ){_gbf :=4*(y *_ebe .Width +x );if _gbf +3>=len (_ebe .Data ){return ;};_ebe .Data [_gbf ]=c .C ;_ebe .Data [_gbf +1]=c .M ;_ebe .Data [_gbf +2]=c .Y ;_ebe .Data [_gbf +3]=c .K ;
};func _dcbcb (_dgfdg ,_bdaf ,_egf byte )byte {return (_dgfdg &^(_egf ))|(_bdaf &_egf )};func (_bccd *Gray8 )Histogram ()(_gfec [256]int ){for _afccb :=0;_afccb < len (_bccd .Data );_afccb ++{_gfec [_bccd .Data [_afccb ]]++;};return _gfec ;};var _ Gray =&Gray2 {};
type Image interface{_gd .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_cccad ,_gcge int )(_aa .Color ,error );Validate ()error ;};func (_gbfd *NRGBA16 )NRGBAAt (x ,y int )_aa .NRGBA {_fdeb ,_ :=ColorAtNRGBA16 (x ,y ,_gbfd .Width ,_gbfd .BytesPerLine ,_gbfd .Data ,_gbfd .Alpha ,_gbfd .Decode );
return _fdeb ;};func (_cgaad *ImageBase )HasAlpha ()bool {if _cgaad .Alpha ==nil {return false ;};for _ggbb :=range _cgaad .Alpha {if _cgaad .Alpha [_ggbb ]!=0xff{return true ;};};return false ;};func _dgd (_dbdb ,_dgda *Monochrome ,_cdd []byte ,_aff int )(_dbfd error ){var (_bc ,_cde ,_dge ,_gfd ,_fff ,_gadf ,_bcd ,_degd int ;
_dfg ,_ffeg uint32 ;_deb ,_caeg byte ;_fa uint16 ;);_fbe :=make ([]byte ,4);_geg :=make ([]byte ,4);for _dge =0;_dge < _dbdb .Height -1;_dge ,_gfd =_dge +2,_gfd +1{_bc =_dge *_dbdb .BytesPerLine ;_cde =_gfd *_dgda .BytesPerLine ;for _fff ,_gadf =0,0;_fff < _aff ;
_fff ,_gadf =_fff +4,_gadf +1{for _bcd =0;_bcd < 4;_bcd ++{_degd =_bc +_fff +_bcd ;if _degd <=len (_dbdb .Data )-1&&_degd < _bc +_dbdb .BytesPerLine {_fbe [_bcd ]=_dbdb .Data [_degd ];}else {_fbe [_bcd ]=0x00;};_degd =_bc +_dbdb .BytesPerLine +_fff +_bcd ;
if _degd <=len (_dbdb .Data )-1&&_degd < _bc +(2*_dbdb .BytesPerLine ){_geg [_bcd ]=_dbdb .Data [_degd ];}else {_geg [_bcd ]=0x00;};};_dfg =_af .BigEndian .Uint32 (_fbe );_ffeg =_af .BigEndian .Uint32 (_geg );_ffeg &=_dfg ;_ffeg &=_ffeg <<1;_ffeg &=0xaaaaaaaa;
_dfg =_ffeg |(_ffeg <<7);_deb =byte (_dfg >>24);_caeg =byte ((_dfg >>8)&0xff);_degd =_cde +_gadf ;if _degd +1==len (_dgda .Data )-1||_degd +1>=_cde +_dgda .BytesPerLine {_dgda .Data [_degd ]=_cdd [_deb ];if _dbfd =_dgda .setByte (_degd ,_cdd [_deb ]);_dbfd !=nil {return _gc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_degd );
};}else {_fa =(uint16 (_cdd [_deb ])<<8)|uint16 (_cdd [_caeg ]);if _dbfd =_dgda .setTwoBytes (_degd ,_fa );_dbfd !=nil {return _gc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_degd );
};_gadf ++;};};};return nil ;};func _ede ()(_gdbd [256]uint64 ){for _cba :=0;_cba < 256;_cba ++{if _cba &0x01!=0{_gdbd [_cba ]|=0xff;};if _cba &0x02!=0{_gdbd [_cba ]|=0xff00;};if _cba &0x04!=0{_gdbd [_cba ]|=0xff0000;};if _cba &0x08!=0{_gdbd [_cba ]|=0xff000000;
};if _cba &0x10!=0{_gdbd [_cba ]|=0xff00000000;};if _cba &0x20!=0{_gdbd [_cba ]|=0xff0000000000;};if _cba &0x40!=0{_gdbd [_cba ]|=0xff000000000000;};if _cba &0x80!=0{_gdbd [_cba ]|=0xff00000000000000;};};return _gdbd ;};func (_aead *NRGBA32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_aead .Width ,Y :_aead .Height }};
};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_aa .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );
case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_gc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_cgae *Monochrome )Set (x ,y int ,c _aa .Color ){_eage :=y *_cgae .BytesPerLine +x >>3;if _eage > len (_cgae .Data )-1{return ;};_bcbc :=_cgae .ColorModel ().Convert (c ).(_aa .Gray );_cgae .setGray (x ,_bcbc ,_eage );};var _ _f .Image =&Gray16 {};
func _gaed (_bdccg _aa .NRGBA )_aa .CMYK {_bfff ,_ceg ,_gdba ,_ :=_bdccg .RGBA ();_debg ,_dafe ,_fcfa ,_edg :=_aa .RGBToCMYK (uint8 (_bfff >>8),uint8 (_ceg >>8),uint8 (_gdba >>8));return _aa .CMYK {C :_debg ,M :_dafe ,Y :_fcfa ,K :_edg };};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_aa .NRGBA64 ,error ){_fefg :=(y *width +x )*2;
_egea :=_fefg *3;if _egea +5>=len (data ){return _aa .NRGBA64 {},_gc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _cbff =0xffff;_fdgf :=uint16 (_cbff );if alpha !=nil &&len (alpha )> _fefg +1{_fdgf =uint16 (alpha [_fefg ])<<8|uint16 (alpha [_fefg +1]);};_fdffg :=uint16 (data [_egea ])<<8|uint16 (data [_egea +1]);_bcdb :=uint16 (data [_egea +2])<<8|uint16 (data [_egea +3]);
_fbed :=uint16 (data [_egea +4])<<8|uint16 (data [_egea +5]);if len (decode )==6{_fdffg =uint16 (uint64 (LinearInterpolate (float64 (_fdffg ),0,65535,decode [0],decode [1]))&_cbff );_bcdb =uint16 (uint64 (LinearInterpolate (float64 (_bcdb ),0,65535,decode [2],decode [3]))&_cbff );
_fbed =uint16 (uint64 (LinearInterpolate (float64 (_fbed ),0,65535,decode [4],decode [5]))&_cbff );};return _aa .NRGBA64 {R :_fdffg ,G :_bcdb ,B :_fbed ,A :_fdgf },nil ;};type shift int ;type Gray interface{GrayAt (_ccff ,_afaag int )_aa .Gray ;SetGray (_bfc ,_bcf int ,_cga _aa .Gray );
};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_aa .NRGBA ,error ){_gade :=y *bytesPerLine +x *3/2;if _gade +1>=len (data ){return _aa .NRGBA {},_eebcb (x ,y );};const (_adad =0xf;_adabf =uint8 (0xff););_ccfg :=_adabf ;
if alpha !=nil {_fffe :=y *BytesPerLine (width ,4,1);if _fffe < len (alpha ){if x %2==0{_ccfg =(alpha [_fffe ]>>uint (4))&_adad ;}else {_ccfg =alpha [_fffe ]&_adad ;};_ccfg |=_ccfg <<4;};};var _gebe ,_dbced ,_ecfd uint8 ;if x *3%2==0{_gebe =(data [_gade ]>>uint (4))&_adad ;
_dbced =data [_gade ]&_adad ;_ecfd =(data [_gade +1]>>uint (4))&_adad ;}else {_gebe =data [_gade ]&_adad ;_dbced =(data [_gade +1]>>uint (4))&_adad ;_ecfd =data [_gade +1]&_adad ;};if len (decode )==6{_gebe =uint8 (uint32 (LinearInterpolate (float64 (_gebe ),0,15,decode [0],decode [1]))&0xf);
_dbced =uint8 (uint32 (LinearInterpolate (float64 (_dbced ),0,15,decode [2],decode [3]))&0xf);_ecfd =uint8 (uint32 (LinearInterpolate (float64 (_ecfd ),0,15,decode [4],decode [5]))&0xf);};return _aa .NRGBA {R :(_gebe <<4)|(_gebe &0xf),G :(_dbced <<4)|(_dbced &0xf),B :(_ecfd <<4)|(_ecfd &0xf),A :_ccfg },nil ;
};func (_gdbg *Monochrome )clearBit (_ecbc ,_gbaa int ){_gdbg .Data [_ecbc ]&=^(0x80>>uint (_gbaa &7))};func (_dbfb *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_dbfb .copy ()}};func (_aafe *ImageBase )getByte (_afga int )(byte ,error ){if _afga > len (_aafe .Data )-1||_afga < 0{return 0,_gc .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_afga );
};return _aafe .Data [_afga ],nil ;};func (_cfbd *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _dgee (_cfbd ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func _efe ()(_agbe []byte ){_agbe =make ([]byte ,256);
for _eba :=0;_eba < 256;_eba ++{_aeg :=byte (_eba );_agbe [_aeg ]=(_aeg &0x01)|((_aeg &0x04)>>1)|((_aeg &0x10)>>2)|((_aeg &0x40)>>3)|((_aeg &0x02)<<3)|((_aeg &0x08)<<2)|((_aeg &0x20)<<1)|(_aeg &0x80);};return _agbe ;};var (Gray2Model =_aa .ModelFunc (_gfe );
Gray4Model =_aa .ModelFunc (_ddd );NRGBA16Model =_aa .ModelFunc (_gefe ););func (_abbba *NRGBA32 )setRGBA (_bbed int ,_bfffb _aa .NRGBA ){_fgdd :=3*_bbed ;_abbba .Data [_fgdd ]=_bfffb .R ;_abbba .Data [_fgdd +1]=_bfffb .G ;_abbba .Data [_fgdd +2]=_bfffb .B ;
if _bbed < len (_abbba .Alpha ){_abbba .Alpha [_bbed ]=_bfffb .A ;};};var _ NRGBA =&NRGBA16 {};var _ Image =&CMYK32 {};func _defd (_cbd _aa .Gray )_aa .RGBA {return _aa .RGBA {R :_cbd .Y ,G :_cbd .Y ,B :_cbd .Y ,A :0xff}};func ConverterFunc (converterFunc func (_gfcf _f .Image )(Image ,error ))ColorConverter {return colorConverter {_aaba :converterFunc };
};func (_faea *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_faea .copy ()}};func (_gafb *NRGBA16 )Validate ()error {if len (_gafb .Data )!=3*_gafb .Width *_gafb .Height /2{return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fdbf *Gray8 )At (x ,y int )_aa .Color {_aefa ,_ :=_fdbf .ColorAt (x ,y );return _aefa };func _dea (_ege *Monochrome ,_ggg ...int )(_ec *Monochrome ,_eea error ){if _ege ==nil {return nil ,_g .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_ggg )==0{return nil ,_g .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_ded :=_efe ();_ec =_ege ;for _ ,_fcb :=range _ggg {if _fcb <=0{break ;};_ec ,_eea =_gga (_ec ,_fcb ,_ded );if _eea !=nil {return nil ,_eea ;};};return _ec ,nil ;};func _bff ()(_fea [256]uint16 ){for _fcga :=0;_fcga < 256;_fcga ++{if _fcga &0x01!=0{_fea [_fcga ]|=0x3;
};if _fcga &0x02!=0{_fea [_fcga ]|=0xc;};if _fcga &0x04!=0{_fea [_fcga ]|=0x30;};if _fcga &0x08!=0{_fea [_fcga ]|=0xc0;};if _fcga &0x10!=0{_fea [_fcga ]|=0x300;};if _fcga &0x20!=0{_fea [_fcga ]|=0xc00;};if _fcga &0x40!=0{_fea [_fcga ]|=0x3000;};if _fcga &0x80!=0{_fea [_fcga ]|=0xc000;
};};return _fea ;};func (_ecfe *NRGBA32 )ColorModel ()_aa .Model {return _aa .NRGBAModel };type monochromeModel uint8 ;func (_bgdfg *ImageBase )setEightBytes (_fadd int ,_agdd uint64 )error {_cgga :=_bgdfg .BytesPerLine -(_fadd %_bgdfg .BytesPerLine );
if _bgdfg .BytesPerLine !=_bgdfg .Width >>3{_cgga --;};if _cgga >=8{return _bgdfg .setEightFullBytes (_fadd ,_agdd );};return _bgdfg .setEightPartlyBytes (_fadd ,_cgga ,_agdd );};func _dceff (_dgdfb _f .Image )(Image ,error ){if _edec ,_fabc :=_dgdfb .(*NRGBA64 );
_fabc {return _edec .Copy (),nil ;};_dfag ,_abfcc ,_cefef :=_gega (_dgdfb ,2);_bceg ,_ddgba :=NewImage (_dfag .Max .X ,_dfag .Max .Y ,16,3,nil ,_cefef ,nil );if _ddgba !=nil {return nil ,_ddgba ;};_baceg (_dgdfb ,_bceg ,_dfag );if len (_cefef )!=0&&!_abfcc {if _cfdf :=_fedd (_cefef ,_bceg );
_cfdf !=nil {return nil ,_cfdf ;};};return _bceg ,nil ;};func (_cebc *Monochrome )setGrayBit (_gabe ,_fede int ){_cebc .Data [_gabe ]|=0x80>>uint (_fede &7)};func (_cggc *Gray8 )ColorAt (x ,y int )(_aa .Color ,error ){return ColorAtGray8BPC (x ,y ,_cggc .BytesPerLine ,_cggc .Data ,_cggc .Decode );
};func _ccdg (_aeag Gray ,_cefee RGBA ,_cbdc _f .Rectangle ){for _fcc :=0;_fcc < _cbdc .Max .X ;_fcc ++{for _gdbaa :=0;_gdbaa < _cbdc .Max .Y ;_gdbaa ++{_cbcdg :=_aeag .GrayAt (_fcc ,_gdbaa );_cefee .SetRGBA (_fcc ,_gdbaa ,_defd (_cbcdg ));};};};func (_bdfg *ImageBase )MakeAlpha (){_bdfg .newAlpha ()};
func _ggec (_gbab *_f .NYCbCrA ,_abda NRGBA ,_aabb _f .Rectangle ){for _fafg :=0;_fafg < _aabb .Max .X ;_fafg ++{for _ggfc :=0;_ggfc < _aabb .Max .Y ;_ggfc ++{_gaba :=_gbab .NYCbCrAAt (_fafg ,_ggfc );_abda .SetNRGBA (_fafg ,_ggfc ,_bbecf (_gaba ));};};
};func (_dggc *Monochrome )ColorAt (x ,y int )(_aa .Color ,error ){return ColorAtGray1BPC (x ,y ,_dggc .BytesPerLine ,_dggc .Data ,_dggc .Decode );};func (_ada *Gray2 )Set (x ,y int ,c _aa .Color ){if x >=_ada .Width ||y >=_ada .Height {return ;};_eceg :=Gray2Model .Convert (c ).(_aa .Gray );
_gdda :=y *_ada .BytesPerLine ;_ecag :=_gdda +(x >>2);_fggd :=_eceg .Y >>6;_ada .Data [_ecag ]=(_ada .Data [_ecag ]&(^(0xc0>>uint (2*((x )&3)))))|(_fggd <<uint (6-2*(x &3)));};var _ Image =&Gray8 {};func _bfcd (_gaddb *Monochrome ,_eafd ,_faddd ,_egca ,_edba int ,_fgcf RasterOperator ,_febe *Monochrome ,_fcee ,_bgcc int )error {var (_eccec bool ;
_gbdg bool ;_fabd byte ;_fbdc int ;_bgfe int ;_bccf int ;_eebb int ;_ffbe bool ;_bbce int ;_gfeb int ;_cff int ;_abaf bool ;_eccag byte ;_dceg int ;_bfb int ;_effb int ;_acb byte ;_dcea int ;_ebee int ;_afac uint ;_aage uint ;_bdfa byte ;_efcc shift ;_cegf bool ;
_bddbb bool ;_dfeb ,_eeff int ;);if _fcee &7!=0{_ebee =8-(_fcee &7);};if _eafd &7!=0{_bgfe =8-(_eafd &7);};if _ebee ==0&&_bgfe ==0{_bdfa =_bee [0];}else {if _bgfe > _ebee {_afac =uint (_bgfe -_ebee );}else {_afac =uint (8-(_ebee -_bgfe ));};_aage =8-_afac ;
_bdfa =_bee [_afac ];};if (_eafd &7)!=0{_eccec =true ;_fbdc =8-(_eafd &7);_fabd =_bee [_fbdc ];_bccf =_gaddb .BytesPerLine *_faddd +(_eafd >>3);_eebb =_febe .BytesPerLine *_bgcc +(_fcee >>3);_dcea =8-(_fcee &7);if _fbdc > _dcea {_efcc =_gcga ;if _egca >=_ebee {_cegf =true ;
};}else {_efcc =_cgag ;};};if _egca < _fbdc {_gbdg =true ;_fabd &=_dfbb [8-_fbdc +_egca ];};if !_gbdg {_bbce =(_egca -_fbdc )>>3;if _bbce !=0{_ffbe =true ;_gfeb =_gaddb .BytesPerLine *_faddd +((_eafd +_bgfe )>>3);_cff =_febe .BytesPerLine *_bgcc +((_fcee +_bgfe )>>3);
};};_dceg =(_eafd +_egca )&7;if !(_gbdg ||_dceg ==0){_abaf =true ;_eccag =_dfbb [_dceg ];_bfb =_gaddb .BytesPerLine *_faddd +((_eafd +_bgfe )>>3)+_bbce ;_effb =_febe .BytesPerLine *_bgcc +((_fcee +_bgfe )>>3)+_bbce ;if _dceg > int (_aage ){_bddbb =true ;
};};switch _fgcf {case PixSrc :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );};}else {_acb =_febe .Data [_eebb ]>>_aage ;};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],_acb ,_fabd );
_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );_gaddb .Data [_gfeb +_eeff ]=_acb ;
};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;_dfeb < _edba ;_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],_acb ,_eccag );
_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;};};case PixNotSrc :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );};}else {_acb =_febe .Data [_eebb ]>>_aage ;
};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],^_acb ,_fabd );_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );
_gaddb .Data [_gfeb +_eeff ]=^_acb ;};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;_dfeb < _edba ;_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );
};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],^_acb ,_eccag );_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;};};case PixSrcOrDst :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );
};}else {_acb =_febe .Data [_eebb ]>>_aage ;};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],_acb |_gaddb .Data [_bccf ],_fabd );_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;
_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );_gaddb .Data [_gfeb +_eeff ]|=_acb ;};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;_dfeb < _edba ;
_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],_acb |_gaddb .Data [_bfb ],_eccag );_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;
};};case PixSrcAndDst :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );};}else {_acb =_febe .Data [_eebb ]>>_aage ;};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],_acb &_gaddb .Data [_bccf ],_fabd );
_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );_gaddb .Data [_gfeb +_eeff ]&=_acb ;
};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;_dfeb < _edba ;_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],_acb &_gaddb .Data [_bfb ],_eccag );
_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;};};case PixSrcXorDst :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );};
}else {_acb =_febe .Data [_eebb ]>>_aage ;};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],_acb ^_gaddb .Data [_bccf ],_fabd );_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;
_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );_gaddb .Data [_gfeb +_eeff ]^=_acb ;};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;_dfeb < _edba ;
_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],_acb ^_gaddb .Data [_bfb ],_eccag );_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;
};};case PixNotSrcOrDst :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );};}else {_acb =_febe .Data [_eebb ]>>_aage ;};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],^_acb |_gaddb .Data [_bccf ],_fabd );
_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );_gaddb .Data [_gfeb +_eeff ]|=^_acb ;
};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;_dfeb < _edba ;_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],^_acb |_gaddb .Data [_bfb ],_eccag );
_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;};};case PixNotSrcAndDst :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );
};}else {_acb =_febe .Data [_eebb ]>>_aage ;};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],^_acb &_gaddb .Data [_bccf ],_fabd );_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;
_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );_gaddb .Data [_gfeb +_eeff ]&=^_acb ;};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;_dfeb < _edba ;
_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],^_acb &_gaddb .Data [_bfb ],_eccag );_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;
};};case PixSrcOrNotDst :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );};}else {_acb =_febe .Data [_eebb ]>>_aage ;};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],_acb |^_gaddb .Data [_bccf ],_fabd );
_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );_gaddb .Data [_gfeb +_eeff ]=_acb |^_gaddb .Data [_gfeb +_eeff ];
};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;_dfeb < _edba ;_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],_acb |^_gaddb .Data [_bfb ],_eccag );
_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;};};case PixSrcAndNotDst :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );
};}else {_acb =_febe .Data [_eebb ]>>_aage ;};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],_acb &^_gaddb .Data [_bccf ],_fabd );_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;
_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );_gaddb .Data [_gfeb +_eeff ]=_acb &^_gaddb .Data [_gfeb +_eeff ];};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;
_dfeb < _edba ;_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],_acb &^_gaddb .Data [_bfb ],_eccag );_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;
};};case PixNotPixSrcOrDst :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );};}else {_acb =_febe .Data [_eebb ]>>_aage ;};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],^(_acb |_gaddb .Data [_bccf ]),_fabd );
_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );_gaddb .Data [_gfeb +_eeff ]=^(_acb |_gaddb .Data [_gfeb +_eeff ]);
};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;_dfeb < _edba ;_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],^(_acb |_gaddb .Data [_bfb ]),_eccag );
_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;};};case PixNotPixSrcAndDst :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );
};}else {_acb =_febe .Data [_eebb ]>>_aage ;};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],^(_acb &_gaddb .Data [_bccf ]),_fabd );_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;
_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );_gaddb .Data [_gfeb +_eeff ]=^(_acb &_gaddb .Data [_gfeb +_eeff ]);};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;
_dfeb < _edba ;_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],^(_acb &_gaddb .Data [_bfb ]),_eccag );_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;
};};case PixNotPixSrcXorDst :if _eccec {for _dfeb =0;_dfeb < _edba ;_dfeb ++{if _efcc ==_gcga {_acb =_febe .Data [_eebb ]<<_afac ;if _cegf {_acb =_dcbcb (_acb ,_febe .Data [_eebb +1]>>_aage ,_bdfa );};}else {_acb =_febe .Data [_eebb ]>>_aage ;};_gaddb .Data [_bccf ]=_dcbcb (_gaddb .Data [_bccf ],^(_acb ^_gaddb .Data [_bccf ]),_fabd );
_bccf +=_gaddb .BytesPerLine ;_eebb +=_febe .BytesPerLine ;};};if _ffbe {for _dfeb =0;_dfeb < _edba ;_dfeb ++{for _eeff =0;_eeff < _bbce ;_eeff ++{_acb =_dcbcb (_febe .Data [_cff +_eeff ]<<_afac ,_febe .Data [_cff +_eeff +1]>>_aage ,_bdfa );_gaddb .Data [_gfeb +_eeff ]=^(_acb ^_gaddb .Data [_gfeb +_eeff ]);
};_gfeb +=_gaddb .BytesPerLine ;_cff +=_febe .BytesPerLine ;};};if _abaf {for _dfeb =0;_dfeb < _edba ;_dfeb ++{_acb =_febe .Data [_effb ]<<_afac ;if _bddbb {_acb =_dcbcb (_acb ,_febe .Data [_effb +1]>>_aage ,_bdfa );};_gaddb .Data [_bfb ]=_dcbcb (_gaddb .Data [_bfb ],^(_acb ^_gaddb .Data [_bfb ]),_eccag );
_bfb +=_gaddb .BytesPerLine ;_effb +=_febe .BytesPerLine ;};};default:_fc .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_fgcf );
return _g .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};var _ Image =&NRGBA16 {};func (_fcac *RGBA32 )RGBAAt (x ,y int )_aa .RGBA {_gadc ,_ :=ColorAtRGBA32 (x ,y ,_fcac .Width ,_fcac .Data ,_fcac .Alpha ,_fcac .Decode );
return _gadc ;};func (_dfgc *ImageBase )copy ()ImageBase {_cfeg :=*_dfgc ;_cfeg .Data =make ([]byte ,len (_dfgc .Data ));copy (_cfeg .Data ,_dfgc .Data );return _cfeg ;};func _dfbdg (_fgge _f .Image )(Image ,error ){if _fgdc ,_acca :=_fgge .(*RGBA32 );
_acca {return _fgdc .Copy (),nil ;};_gebee ,_fagg ,_gagfb :=_gega (_fgge ,1);_aggb :=&RGBA32 {ImageBase :NewImageBase (_gebee .Max .X ,_gebee .Max .Y ,8,3,nil ,_gagfb ,nil )};_ebbfb (_fgge ,_aggb ,_gebee );if len (_gagfb )!=0&&!_fagg {if _afae :=_fedd (_gagfb ,_aggb );
_afae !=nil {return nil ,_afae ;};};return _aggb ,nil ;};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _dgee (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};type NRGBA64 struct{ImageBase };
func (_fgbb *Monochrome )AddPadding ()(_gbbf error ){if _bddg :=((_fgbb .Width *_fgbb .Height )+7)>>3;len (_fgbb .Data )< _bddg {return _gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_fgbb .Data ),_bddg );
};_gcbg :=_fgbb .Width %8;if _gcbg ==0{return nil ;};_gggb :=_fgbb .Width /8;_fba :=_ga .NewReader (_fgbb .Data );_fcdc :=make ([]byte ,_fgbb .Height *_fgbb .BytesPerLine );_cge :=_ga .NewWriterMSB (_fcdc );_bgf :=make ([]byte ,_gggb );var (_gedf int ;
_adfe uint64 ;);for _gedf =0;_gedf < _fgbb .Height ;_gedf ++{if _ ,_gbbf =_fba .Read (_bgf );_gbbf !=nil {return _gbbf ;};if _ ,_gbbf =_cge .Write (_bgf );_gbbf !=nil {return _gbbf ;};if _adfe ,_gbbf =_fba .ReadBits (byte (_gcbg ));_gbbf !=nil {return _gbbf ;
};if _gbbf =_cge .WriteByte (byte (_adfe )<<uint (8-_gcbg ));_gbbf !=nil {return _gbbf ;};};_fgbb .Data =_cge .Data ();return nil ;};func _edde (_ebac *Monochrome ,_bgaa ,_cgcb ,_ggcfb ,_aca int ,_edfaa RasterOperator ,_cfgg *Monochrome ,_abfe ,_bebg int )error {var (_faa byte ;
_eafb int ;_becd int ;_gcce ,_ccbf int ;_gebg ,_caad int ;);_cdbf :=_ggcfb >>3;_gcegb :=_ggcfb &7;if _gcegb > 0{_faa =_dfbb [_gcegb ];};_eafb =_cfgg .BytesPerLine *_bebg +(_abfe >>3);_becd =_ebac .BytesPerLine *_cgcb +(_bgaa >>3);switch _edfaa {case PixSrc :for _gebg =0;
_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]=_cfgg .Data [_gcce ];_ccbf ++;_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],_cfgg .Data [_gcce ],_faa );
};};case PixNotSrc :for _gebg =0;_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]=^(_cfgg .Data [_gcce ]);_ccbf ++;_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],^_cfgg .Data [_gcce ],_faa );
};};case PixSrcOrDst :for _gebg =0;_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]|=_cfgg .Data [_gcce ];_ccbf ++;_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],_cfgg .Data [_gcce ]|_ebac .Data [_ccbf ],_faa );
};};case PixSrcAndDst :for _gebg =0;_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]&=_cfgg .Data [_gcce ];_ccbf ++;_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],_cfgg .Data [_gcce ]&_ebac .Data [_ccbf ],_faa );
};};case PixSrcXorDst :for _gebg =0;_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]^=_cfgg .Data [_gcce ];_ccbf ++;_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],_cfgg .Data [_gcce ]^_ebac .Data [_ccbf ],_faa );
};};case PixNotSrcOrDst :for _gebg =0;_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]|=^(_cfgg .Data [_gcce ]);_ccbf ++;_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],^(_cfgg .Data [_gcce ])|_ebac .Data [_ccbf ],_faa );
};};case PixNotSrcAndDst :for _gebg =0;_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]&=^(_cfgg .Data [_gcce ]);_ccbf ++;_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],^(_cfgg .Data [_gcce ])&_ebac .Data [_ccbf ],_faa );
};};case PixSrcOrNotDst :for _gebg =0;_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]=_cfgg .Data [_gcce ]|^(_ebac .Data [_ccbf ]);_ccbf ++;
_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],_cfgg .Data [_gcce ]|^(_ebac .Data [_ccbf ]),_faa );};};case PixSrcAndNotDst :for _gebg =0;_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;
for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]=_cfgg .Data [_gcce ]&^(_ebac .Data [_ccbf ]);_ccbf ++;_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],_cfgg .Data [_gcce ]&^(_ebac .Data [_ccbf ]),_faa );};};case PixNotPixSrcOrDst :for _gebg =0;
_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]=^(_cfgg .Data [_gcce ]|_ebac .Data [_ccbf ]);_ccbf ++;_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],^(_cfgg .Data [_gcce ]|_ebac .Data [_ccbf ]),_faa );
};};case PixNotPixSrcAndDst :for _gebg =0;_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]=^(_cfgg .Data [_gcce ]&_ebac .Data [_ccbf ]);
_ccbf ++;_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],^(_cfgg .Data [_gcce ]&_ebac .Data [_ccbf ]),_faa );};};case PixNotPixSrcXorDst :for _gebg =0;_gebg < _aca ;_gebg ++{_gcce =_eafb +_gebg *_cfgg .BytesPerLine ;_ccbf =_becd +_gebg *_ebac .BytesPerLine ;
for _caad =0;_caad < _cdbf ;_caad ++{_ebac .Data [_ccbf ]=^(_cfgg .Data [_gcce ]^_ebac .Data [_ccbf ]);_ccbf ++;_gcce ++;};if _gcegb > 0{_ebac .Data [_ccbf ]=_dcbcb (_ebac .Data [_ccbf ],^(_cfgg .Data [_gcce ]^_ebac .Data [_ccbf ]),_faa );};};default:_fc .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_edfaa );
return _g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_aa .Gray16 ,error ){_eac :=(y *bytesPerLine /2+x )*2;
if _eac +1>=len (data ){return _aa .Gray16 {},_gc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fdde :=uint16 (data [_eac ])<<8|uint16 (data [_eac +1]);if len (decode )==2{_fdde =uint16 (uint64 (LinearInterpolate (float64 (_fdde ),0,65535,decode [0],decode [1])));};return _aa .Gray16 {Y :_fdde },nil ;};func _dee (_cee _aa .Gray )_aa .NRGBA {return _aa .NRGBA {R :_cee .Y ,G :_cee .Y ,B :_cee .Y ,A :0xff}};
func (_gcfb *NRGBA64 )NRGBA64At (x ,y int )_aa .NRGBA64 {_ebdc ,_ :=ColorAtNRGBA64 (x ,y ,_gcfb .Width ,_gcfb .Data ,_gcfb .Alpha ,_gcfb .Decode );return _ebdc ;};type NRGBA16 struct{ImageBase };func _cfa (_edea _f .Image )(Image ,error ){if _gcbd ,_dgea :=_edea .(*CMYK32 );
_dgea {return _gcbd .Copy (),nil ;};_fec :=_edea .Bounds ();_effg ,_eefa :=NewImage (_fec .Max .X ,_fec .Max .Y ,8,4,nil ,nil ,nil );if _eefa !=nil {return nil ,_eefa ;};switch _ddg :=_edea .(type ){case CMYK :_bcde (_ddg ,_effg .(CMYK ),_fec );case Gray :_bcg (_ddg ,_effg .(CMYK ),_fec );
case NRGBA :_caba (_ddg ,_effg .(CMYK ),_fec );case RGBA :_gdca (_ddg ,_effg .(CMYK ),_fec );default:_gfba (_edea ,_effg ,_fec );};return _effg ,nil ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_aa .NRGBA ,error ){_gbe :=y *width +x ;
_bdcd :=3*_gbe ;if _bdcd +2>=len (data ){return _aa .NRGBA {},_gc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_acfbf :=uint8 (0xff);if alpha !=nil &&len (alpha )> _gbe {_acfbf =alpha [_gbe ];};_gcf ,_gdea ,_cbef :=data [_bdcd ],data [_bdcd +1],data [_bdcd +2];if len (decode )==6{_begb :=LinearInterpolate (float64 (_gcf ),0,255.0,decode [0],decode [1]);_ddae :=LinearInterpolate (float64 (_gdea ),0,255.0,decode [2],decode [3]);
_bfdbc :=LinearInterpolate (float64 (_cbef ),0,255.0,decode [4],decode [5]);if _begb <=1.0&&_ddae <=1.0&&_bfdbc <=1.0{_begb *=255.0;_ddae *=255.0;_bfdbc *=255.0;};_gcf =uint8 (_begb )&0xff;_gdea =uint8 (_ddae )&0xff;_cbef =uint8 (_bfdbc )&0xff;};return _aa .NRGBA {R :_gcf ,G :_gdea ,B :_cbef ,A :_acfbf },nil ;
};func (_edfe *RGBA32 )Validate ()error {if len (_edfe .Data )!=3*_edfe .Width *_edfe .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_eega *Monochrome )getBitAt (_bgdf ,_afef int )bool {_gbd :=_afef *_eega .BytesPerLine +(_bgdf >>3);_dcef :=_bgdf &0x07;_fbbd :=uint (7-_dcef );if _gbd > len (_eega .Data )-1{return false ;};if (_eega .Data [_gbd ]>>_fbbd )&0x01>=1{return true ;
};return false ;};func (_fgd *Gray16 )SetGray (x ,y int ,g _aa .Gray ){_efef :=(y *_fgd .BytesPerLine /2+x )*2;if _efef +1>=len (_fgd .Data ){return ;};_fgd .Data [_efef ]=g .Y ;_fgd .Data [_efef +1]=g .Y ;};func FromGoImage (i _f .Image )(Image ,error ){switch _efdb :=i .(type ){case Image :return _efdb .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_f .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_f .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};
func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_aa .RGBA ,error ){_efbb :=y *width +x ;_dgefd :=3*_efbb ;if _dgefd +2>=len (data ){return _aa .RGBA {},_gc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dcddd :=uint8 (0xff);if alpha !=nil &&len (alpha )> _efbb {_dcddd =alpha [_efbb ];};_fggb ,_gdae ,_cggca :=data [_dgefd ],data [_dgefd +1],data [_dgefd +2];if len (decode )==6{_fggb =uint8 (uint32 (LinearInterpolate (float64 (_fggb ),0,255,decode [0],decode [1]))&0xff);
_gdae =uint8 (uint32 (LinearInterpolate (float64 (_gdae ),0,255,decode [2],decode [3]))&0xff);_cggca =uint8 (uint32 (LinearInterpolate (float64 (_cggca ),0,255,decode [4],decode [5]))&0xff);};return _aa .RGBA {R :_fggb ,G :_gdae ,B :_cggca ,A :_dcddd },nil ;
};func _cea (_abf ,_ac *Monochrome )(_cef error ){_db :=_ac .BytesPerLine ;_ff :=_abf .BytesPerLine ;var (_cb byte ;_ceb uint16 ;_bb ,_ge ,_bbc ,_ed ,_bf int ;);for _bbc =0;_bbc < _ac .Height ;_bbc ++{_bb =_bbc *_db ;_ge =2*_bbc *_ff ;for _ed =0;_ed < _db ;
_ed ++{_cb =_ac .Data [_bb +_ed ];_ceb =_gce [_cb ];_bf =_ge +_ed *2;if _abf .BytesPerLine !=_ac .BytesPerLine *2&&(_ed +1)*2> _abf .BytesPerLine {_cef =_abf .setByte (_bf ,byte (_ceb >>8));}else {_cef =_abf .setTwoBytes (_bf ,_ceb );};if _cef !=nil {return _cef ;
};};for _ed =0;_ed < _ff ;_ed ++{_bf =_ge +_ff +_ed ;_cb =_abf .Data [_ge +_ed ];if _cef =_abf .setByte (_bf ,_cb );_cef !=nil {return _cef ;};};};return nil ;};func _gcg (_dfbe ,_dadf *Monochrome ,_bfd []byte ,_fcdg int )(_bga error ){var (_edc ,_cfe ,_gee ,_gbc ,_deg ,_dfd ,_ggge ,_ba int ;
_dbd ,_eeda ,_bab ,_dac uint32 ;_edfg ,_ebc byte ;_bdg uint16 ;);_agf :=make ([]byte ,4);_afaa :=make ([]byte ,4);for _gee =0;_gee < _dfbe .Height -1;_gee ,_gbc =_gee +2,_gbc +1{_edc =_gee *_dfbe .BytesPerLine ;_cfe =_gbc *_dadf .BytesPerLine ;for _deg ,_dfd =0,0;
_deg < _fcdg ;_deg ,_dfd =_deg +4,_dfd +1{for _ggge =0;_ggge < 4;_ggge ++{_ba =_edc +_deg +_ggge ;if _ba <=len (_dfbe .Data )-1&&_ba < _edc +_dfbe .BytesPerLine {_agf [_ggge ]=_dfbe .Data [_ba ];}else {_agf [_ggge ]=0x00;};_ba =_edc +_dfbe .BytesPerLine +_deg +_ggge ;
if _ba <=len (_dfbe .Data )-1&&_ba < _edc +(2*_dfbe .BytesPerLine ){_afaa [_ggge ]=_dfbe .Data [_ba ];}else {_afaa [_ggge ]=0x00;};};_dbd =_af .BigEndian .Uint32 (_agf );_eeda =_af .BigEndian .Uint32 (_afaa );_bab =_dbd &_eeda ;_bab |=_bab <<1;_dac =_dbd |_eeda ;
_dac &=_dac <<1;_eeda =_bab &_dac ;_eeda &=0xaaaaaaaa;_dbd =_eeda |(_eeda <<7);_edfg =byte (_dbd >>24);_ebc =byte ((_dbd >>8)&0xff);_ba =_cfe +_dfd ;if _ba +1==len (_dadf .Data )-1||_ba +1>=_cfe +_dadf .BytesPerLine {if _bga =_dadf .setByte (_ba ,_bfd [_edfg ]);
_bga !=nil {return _gc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ba );};}else {_bdg =(uint16 (_bfd [_edfg ])<<8)|uint16 (_bfd [_ebc ]);if _bga =_dadf .setTwoBytes (_ba ,_bdg );_bga !=nil {return _gc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ba );
};_dfd ++;};};};return nil ;};func _bfe (_geae _aa .RGBA )_aa .CMYK {_begg ,_ecff ,_dba ,_dbb :=_aa .RGBToCMYK (_geae .R ,_geae .G ,_geae .B );return _aa .CMYK {C :_begg ,M :_ecff ,Y :_dba ,K :_dbb };};func _fbdb (_edeb _f .Image ,_cegef Image ,_gfbd _f .Rectangle ){if _ddcec ,_bagg :=_edeb .(SMasker );
_bagg &&_ddcec .HasAlpha (){_cegef .(SMasker ).MakeAlpha ();};switch _cbag :=_edeb .(type ){case Gray :_cebg (_cbag ,_cegef .(NRGBA ),_gfbd );case NRGBA :_bcec (_cbag ,_cegef .(NRGBA ),_gfbd );case *_f .NYCbCrA :_ggec (_cbag ,_cegef .(NRGBA ),_gfbd );case CMYK :_ebcef (_cbag ,_cegef .(NRGBA ),_gfbd );
case RGBA :_gdbgd (_cbag ,_cegef .(NRGBA ),_gfbd );case nrgba64 :_dgded (_cbag ,_cegef .(NRGBA ),_gfbd );default:_gfba (_edeb ,_cegef ,_gfbd );};};func (_bfdbf *NRGBA16 )ColorModel ()_aa .Model {return NRGBA16Model };func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_gc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_aa .Gray ,error ){_aeb :=y *bytesPerLine +x >>3;if _aeb >=len (data ){return _aa .Gray {},_gc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fcfed :=data [_aeb ]>>uint (7-(x &7))&1;if len (decode )==2{_fcfed =uint8 (LinearInterpolate (float64 (_fcfed ),0.0,1.0,decode [0],decode [1]))&1;};return _aa .Gray {Y :_fcfed *255},nil ;};func (_baa *Gray8 )Base ()*ImageBase {return &_baa .ImageBase };
func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _a .Abs (xmax -xmin )< 0.000001{return ymin ;};_efae :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _efae ;};func _gfba (_ebaa _f .Image ,_aacb Image ,_aaga _f .Rectangle ){for _fegb :=0;
_fegb < _aaga .Max .X ;_fegb ++{for _bcdc :=0;_bcdc < _aaga .Max .Y ;_bcdc ++{_geeg :=_ebaa .At (_fegb ,_bcdc );_aacb .Set (_fegb ,_bcdc ,_geeg );};};};func _efgc (_efbf _f .Image )(Image ,error ){if _bcef ,_ccga :=_efbf .(*Gray16 );_ccga {return _bcef .Copy (),nil ;
};_cdaec :=_efbf .Bounds ();_agc ,_cbac :=NewImage (_cdaec .Max .X ,_cdaec .Max .Y ,16,1,nil ,nil ,nil );if _cbac !=nil {return nil ,_cbac ;};_cfdbf (_efbf ,_agc ,_cdaec );return _agc ,nil ;};func _gdg (_cacg ,_aef int ,_afgd []byte )*Monochrome {_ccf :=_fgf (_cacg ,_aef );
_ccf .Data =_afgd ;return _ccf ;};func _dgee (_efgd *Monochrome ,_bgad ,_aafc ,_edfa ,_gggg int ,_bcefg RasterOperator ,_bbcg *Monochrome ,_fbbf ,_fca int )error {if _efgd ==nil {return _g .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _bcefg ==PixDst {return nil ;};switch _bcefg {case PixClr ,PixSet ,PixNotDst :_adda (_efgd ,_bgad ,_aafc ,_edfa ,_gggg ,_bcefg );return nil ;};if _bbcg ==nil {_fc .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _g .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _bbbb :=_ddcc (_efgd ,_bgad ,_aafc ,_edfa ,_gggg ,_bcefg ,_bbcg ,_fbbf ,_fca );_bbbb !=nil {return _bbbb ;};return nil ;};var _ Image =&Gray4 {};
type RGBA interface{RGBAAt (_fbeb ,_cfac int )_aa .RGBA ;SetRGBA (_agbbd ,_egacf int ,_ddce _aa .RGBA );};func _addd (_ccc Gray ,_beb NRGBA ,_fddad _f .Rectangle ){for _bge :=0;_bge < _fddad .Max .X ;_bge ++{for _afcc :=0;_afcc < _fddad .Max .Y ;_afcc ++{_edbg :=_bad (_beb .NRGBAAt (_bge ,_afcc ));
_ccc .SetGray (_bge ,_afcc ,_edbg );};};};func (_cabga *NRGBA32 )Validate ()error {if len (_cabga .Data )!=3*_cabga .Width *_cabga .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_aa .Gray ,error ){_ggcd :=y *bytesPerLine +x ;if _ggcd >=len (data ){return _aa .Gray {},_gc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_debc :=data [_ggcd ];if len (decode )==2{_debc =uint8 (uint32 (LinearInterpolate (float64 (_debc ),0,255,decode [0],decode [1]))&0xff);};return _aa .Gray {Y :_debc },nil ;};func (_egad *Gray16 )ColorModel ()_aa .Model {return _aa .Gray16Model };type colorConverter struct{_aaba func (_dce _f .Image )(Image ,error );
};func (_ggdg *NRGBA32 )NRGBAAt (x ,y int )_aa .NRGBA {_faeg ,_ :=ColorAtNRGBA32 (x ,y ,_ggdg .Width ,_ggdg .Data ,_ggdg .Alpha ,_ggdg .Decode );return _faeg ;};func (_cdce *Monochrome )InverseData ()error {return _cdce .RasterOperation (0,0,_cdce .Width ,_cdce .Height ,PixNotDst ,nil ,0,0);
};func _agge (_gbbfc _f .Image )(Image ,error ){if _edaf ,_edbe :=_gbbfc .(*NRGBA16 );_edbe {return _edaf .Copy (),nil ;};_deef :=_gbbfc .Bounds ();_abdg ,_bgcd :=NewImage (_deef .Max .X ,_deef .Max .Y ,4,3,nil ,nil ,nil );if _bgcd !=nil {return nil ,_bgcd ;
};_fbdb (_gbbfc ,_abdg ,_deef );return _abdg ,nil ;};func (_dfgd *Gray8 )SetGray (x ,y int ,g _aa .Gray ){_cgaa :=y *_dfgd .BytesPerLine +x ;if _cgaa > len (_dfgd .Data )-1{return ;};_dfgd .Data [_cgaa ]=g .Y ;};func (_agfc colorConverter )Convert (src _f .Image )(Image ,error ){return _agfc ._aaba (src )};
func _beg (_ddb ,_ece *Monochrome ,_fdg []byte ,_dca int )(_eege error ){var (_cgg ,_gbg ,_cfc ,_ccg ,_cfg ,_eef ,_fgb ,_fbbg int ;_gdc ,_bdfd ,_bbae ,_fdfb uint32 ;_cefe ,_cd byte ;_eec uint16 ;);_edee :=make ([]byte ,4);_daa :=make ([]byte ,4);for _cfc =0;
_cfc < _ddb .Height -1;_cfc ,_ccg =_cfc +2,_ccg +1{_cgg =_cfc *_ddb .BytesPerLine ;_gbg =_ccg *_ece .BytesPerLine ;for _cfg ,_eef =0,0;_cfg < _dca ;_cfg ,_eef =_cfg +4,_eef +1{for _fgb =0;_fgb < 4;_fgb ++{_fbbg =_cgg +_cfg +_fgb ;if _fbbg <=len (_ddb .Data )-1&&_fbbg < _cgg +_ddb .BytesPerLine {_edee [_fgb ]=_ddb .Data [_fbbg ];
}else {_edee [_fgb ]=0x00;};_fbbg =_cgg +_ddb .BytesPerLine +_cfg +_fgb ;if _fbbg <=len (_ddb .Data )-1&&_fbbg < _cgg +(2*_ddb .BytesPerLine ){_daa [_fgb ]=_ddb .Data [_fbbg ];}else {_daa [_fgb ]=0x00;};};_gdc =_af .BigEndian .Uint32 (_edee );_bdfd =_af .BigEndian .Uint32 (_daa );
_bbae =_gdc &_bdfd ;_bbae |=_bbae <<1;_fdfb =_gdc |_bdfd ;_fdfb &=_fdfb <<1;_bdfd =_bbae |_fdfb ;_bdfd &=0xaaaaaaaa;_gdc =_bdfd |(_bdfd <<7);_cefe =byte (_gdc >>24);_cd =byte ((_gdc >>8)&0xff);_fbbg =_gbg +_eef ;if _fbbg +1==len (_ece .Data )-1||_fbbg +1>=_gbg +_ece .BytesPerLine {if _eege =_ece .setByte (_fbbg ,_fdg [_cefe ]);
_eege !=nil {return _gc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fbbg );};}else {_eec =(uint16 (_fdg [_cefe ])<<8)|uint16 (_fdg [_cd ]);if _eege =_ece .setTwoBytes (_fbbg ,_eec );_eege !=nil {return _gc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fbbg );
};_eef ++;};};};return nil ;};var _ Image =&Gray16 {};func (_ffbf *Gray2 )ColorAt (x ,y int )(_aa .Color ,error ){return ColorAtGray2BPC (x ,y ,_ffbf .BytesPerLine ,_ffbf .Data ,_ffbf .Decode );};type nrgba64 interface{NRGBA64At (_eebca ,_bdacc int )_aa .NRGBA64 ;
SetNRGBA64 (_afeb ,_dbbe int ,_gbdgc _aa .NRGBA64 );};func _fagc (_afff uint8 )bool {if _afff ==0||_afff ==255{return true ;};return false ;};func (_bdde *Gray16 )Set (x ,y int ,c _aa .Color ){_gde :=(y *_bdde .BytesPerLine /2+x )*2;if _gde +1>=len (_bdde .Data ){return ;
};_fegdc :=_aa .Gray16Model .Convert (c ).(_aa .Gray16 );_bdde .Data [_gde ],_bdde .Data [_gde +1]=uint8 (_fegdc .Y >>8),uint8 (_fegdc .Y &0xff);};func (_becf *NRGBA32 )At (x ,y int )_aa .Color {_egdg ,_ :=_becf .ColorAt (x ,y );return _egdg };func _eca (_def ,_gcd *Monochrome ,_afc []byte ,_ccb int )(_fdd error ){var (_gaef ,_afa ,_gfb ,_bba ,_eff ,_gedg ,_ecb ,_aac int ;
_ccdd ,_efg uint32 ;_fege ,_ffe byte ;_bdf uint16 ;);_bbac :=make ([]byte ,4);_ffc :=make ([]byte ,4);for _gfb =0;_gfb < _def .Height -1;_gfb ,_bba =_gfb +2,_bba +1{_gaef =_gfb *_def .BytesPerLine ;_afa =_bba *_gcd .BytesPerLine ;for _eff ,_gedg =0,0;_eff < _ccb ;
_eff ,_gedg =_eff +4,_gedg +1{for _ecb =0;_ecb < 4;_ecb ++{_aac =_gaef +_eff +_ecb ;if _aac <=len (_def .Data )-1&&_aac < _gaef +_def .BytesPerLine {_bbac [_ecb ]=_def .Data [_aac ];}else {_bbac [_ecb ]=0x00;};_aac =_gaef +_def .BytesPerLine +_eff +_ecb ;
if _aac <=len (_def .Data )-1&&_aac < _gaef +(2*_def .BytesPerLine ){_ffc [_ecb ]=_def .Data [_aac ];}else {_ffc [_ecb ]=0x00;};};_ccdd =_af .BigEndian .Uint32 (_bbac );_efg =_af .BigEndian .Uint32 (_ffc );_efg |=_ccdd ;_efg |=_efg <<1;_efg &=0xaaaaaaaa;
_ccdd =_efg |(_efg <<7);_fege =byte (_ccdd >>24);_ffe =byte ((_ccdd >>8)&0xff);_aac =_afa +_gedg ;if _aac +1==len (_gcd .Data )-1||_aac +1>=_afa +_gcd .BytesPerLine {_gcd .Data [_aac ]=_afc [_fege ];}else {_bdf =(uint16 (_afc [_fege ])<<8)|uint16 (_afc [_ffe ]);
if _fdd =_gcd .setTwoBytes (_aac ,_bdf );_fdd !=nil {return _gc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_aac );
};_gedg ++;};};};return nil ;};func (_ecea *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_ecea .ImageBase .copy (),ModelThreshold :_ecea .ModelThreshold };};func (_aaeaa *NRGBA64 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_aaeaa .Width ,Y :_aaeaa .Height }};
};func (_agcd *ImageBase )Pix ()[]byte {return _agcd .Data };func _gbb (_feged _aa .RGBA )_aa .Gray {_eeb :=(19595*uint32 (_feged .R )+38470*uint32 (_feged .G )+7471*uint32 (_feged .B )+1<<7)>>16;return _aa .Gray {Y :uint8 (_eeb )};};func _bbecf (_cfab _aa .NYCbCrA )_aa .NRGBA {_ea :=int32 (_cfab .Y )*0x10101;
_bce :=int32 (_cfab .Cb )-128;_bdb :=int32 (_cfab .Cr )-128;_deed :=_ea +91881*_bdb ;if uint32 (_deed )&0xff000000==0{_deed >>=8;}else {_deed =^(_deed >>31)&0xffff;};_acfa :=_ea -22554*_bce -46802*_bdb ;if uint32 (_acfa )&0xff000000==0{_acfa >>=8;}else {_acfa =^(_acfa >>31)&0xffff;
};_eag :=_ea +116130*_bce ;if uint32 (_eag )&0xff000000==0{_eag >>=8;}else {_eag =^(_eag >>31)&0xffff;};return _aa .NRGBA {R :uint8 (_deed >>8),G :uint8 (_acfa >>8),B :uint8 (_eag >>8),A :_cfab .A };};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_aa .Gray ,error ){_bcea :=y *bytesPerLine +x >>2;
if _bcea >=len (data ){return _aa .Gray {},_gc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ecg :=data [_bcea ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_ecg =uint8 (uint32 (LinearInterpolate (float64 (_ecg ),0,3.0,decode [0],decode [1]))&3);};return _aa .Gray {Y :_ecg *85},nil ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};
func _fgf (_ega ,_add int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_ega ,_add ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func _gdca (_egbf RGBA ,_degf CMYK ,_egg _f .Rectangle ){for _fdb :=0;_fdb < _egg .Max .X ;_fdb ++{for _bdcc :=0;
_bdcc < _egg .Max .Y ;_bdcc ++{_fcf :=_egbf .RGBAAt (_fdb ,_bdcc );_degf .SetCMYK (_fdb ,_bdcc ,_bfe (_fcf ));};};};func GrayHistogram (g Gray )(_eafgd [256]int ){switch _fbad :=g .(type ){case Histogramer :return _fbad .Histogram ();case _f .Image :_fdca :=_fbad .Bounds ();
for _fbc :=0;_fbc < _fdca .Max .X ;_fbc ++{for _ddde :=0;_ddde < _fdca .Max .Y ;_ddde ++{_eafgd [g .GrayAt (_fbc ,_ddde ).Y ]++;};};return _eafgd ;default:return [256]int {};};};var _ Image =&NRGBA64 {};func (_cbea *Gray2 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_cbea .Width ,Y :_cbea .Height }};
};func (_dcda *NRGBA32 )Set (x ,y int ,c _aa .Color ){_adfd :=y *_dcda .Width +x ;_fefe :=3*_adfd ;if _fefe +2>=len (_dcda .Data ){return ;};_dgdcf :=_aa .NRGBAModel .Convert (c ).(_aa .NRGBA );_dcda .setRGBA (_adfd ,_dgdcf );};func (_dacb *Monochrome )Base ()*ImageBase {return &_dacb .ImageBase };
func (_bdc *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_bdc .copy ()}};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_aa .CMYK ,error ){_egb :=4*(y *width +x );if _egb +3>=len (data ){return _aa .CMYK {},_gc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_egb ]&0xff;M :=data [_egb +1]&0xff;Y :=data [_egb +2]&0xff;K :=data [_egb +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _aa .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};var _ Image =&RGBA32 {};func (_cedf *Gray16 )GrayAt (x ,y int )_aa .Gray {_afgcf ,_ :=_cedf .ColorAt (x ,y );
return _aa .Gray {Y :uint8 (_afgcf .(_aa .Gray16 ).Y >>8)};};func _egba (_bdea _f .Image )(Image ,error ){if _cad ,_gfab :=_bdea .(*Gray4 );_gfab {return _cad .Copy (),nil ;};_cbbf :=_bdea .Bounds ();_aaf ,_bfdg :=NewImage (_cbbf .Max .X ,_cbbf .Max .Y ,4,1,nil ,nil ,nil );
if _bfdg !=nil {return nil ,_bfdg ;};_cfdbf (_bdea ,_aaf ,_cbbf );return _aaf ,nil ;};func (_ddgf *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_ddgf .copy ()}};type ColorConverter interface{Convert (_dace _f .Image )(Image ,error );};func _ceed (_gdgb NRGBA ,_abdgc RGBA ,_bdfe _f .Rectangle ){for _cggg :=0;
_cggg < _bdfe .Max .X ;_cggg ++{for _afbb :=0;_afbb < _bdfe .Max .Y ;_afbb ++{_gedc :=_gdgb .NRGBAAt (_cggg ,_afbb );_abdgc .SetRGBA (_cggg ,_afbb ,_gfde (_gedc ));};};};func _bad (_bbec _aa .NRGBA )_aa .Gray {var _ecad _aa .NRGBA ;if _bbec ==_ecad {return _aa .Gray {Y :0xff};
};_geed ,_fegc ,_cgc ,_ :=_bbec .RGBA ();_fga :=(19595*_geed +38470*_fegc +7471*_cgc +1<<15)>>24;return _aa .Gray {Y :uint8 (_fga )};};func (_cda *Gray8 )GrayAt (x ,y int )_aa .Gray {_gabc ,_ :=ColorAtGray8BPC (x ,y ,_cda .BytesPerLine ,_cda .Data ,_cda .Decode );
return _gabc ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_ead :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _ead ==width *colorComponents *bitsPerComponent /8{return data ,nil ;
};_bbaef :=width *colorComponents *bitsPerComponent ;_fgc :=_ead *8;_dgdf :=8-(_fgc -_bbaef );_addf :=_ga .NewReader (data );_ecae :=_ead -1;_ddga :=make ([]byte ,_ecae );_dadfc :=make ([]byte ,height *_ead );_gdbb :=_ga .NewWriterMSB (_dadfc );var _bgb uint64 ;
var _bffb error ;for _cedc :=0;_cedc < height ;_cedc ++{_ ,_bffb =_addf .Read (_ddga );if _bffb !=nil {return nil ,_bffb ;};_ ,_bffb =_gdbb .Write (_ddga );if _bffb !=nil {return nil ,_bffb ;};_bgb ,_bffb =_addf .ReadBits (byte (_dgdf ));if _bffb !=nil {return nil ,_bffb ;
};_ ,_bffb =_gdbb .WriteBits (_bgb ,_dgdf );if _bffb !=nil {return nil ,_bffb ;};_gdbb .FinishByte ();};return _dadfc ,nil ;};func MonochromeModel (threshold uint8 )_aa .Model {return monochromeModel (threshold )};func IsGrayImgBlackAndWhite (i *_f .Gray )bool {return _fdgc (i )};
func _ddcc (_dbgf *Monochrome ,_abe ,_agbb int ,_aggg ,_acgg int ,_cege RasterOperator ,_babg *Monochrome ,_eged ,_egde int )error {var _eaf ,_edbd ,_bged ,_cdcf int ;if _abe < 0{_eged -=_abe ;_aggg +=_abe ;_abe =0;};if _eged < 0{_abe -=_eged ;_aggg +=_eged ;
_eged =0;};_eaf =_abe +_aggg -_dbgf .Width ;if _eaf > 0{_aggg -=_eaf ;};_edbd =_eged +_aggg -_babg .Width ;if _edbd > 0{_aggg -=_edbd ;};if _agbb < 0{_egde -=_agbb ;_acgg +=_agbb ;_agbb =0;};if _egde < 0{_agbb -=_egde ;_acgg +=_egde ;_egde =0;};_bged =_agbb +_acgg -_dbgf .Height ;
if _bged > 0{_acgg -=_bged ;};_cdcf =_egde +_acgg -_babg .Height ;if _cdcf > 0{_acgg -=_cdcf ;};if _aggg <=0||_acgg <=0{return nil ;};var _adff error ;switch {case _abe &7==0&&_eged &7==0:_adff =_edde (_dbgf ,_abe ,_agbb ,_aggg ,_acgg ,_cege ,_babg ,_eged ,_egde );
case _abe &7==_eged &7:_adff =_ebfe (_dbgf ,_abe ,_agbb ,_aggg ,_acgg ,_cege ,_babg ,_eged ,_egde );default:_adff =_bfcd (_dbgf ,_abe ,_agbb ,_aggg ,_acgg ,_cege ,_babg ,_eged ,_egde );};if _adff !=nil {return _adff ;};return nil ;};func (_dccg *RGBA32 )SetRGBA (x ,y int ,c _aa .RGBA ){_cgagc :=y *_dccg .Width +x ;
_fabb :=3*_cgagc ;if _fabb +2>=len (_dccg .Data ){return ;};_dccg .setRGBA (_cgagc ,c );};func _afafb (_fded nrgba64 ,_cdad RGBA ,_efde _f .Rectangle ){for _dbgc :=0;_dbgc < _efde .Max .X ;_dbgc ++{for _aagfc :=0;_aagfc < _efde .Max .Y ;_aagfc ++{_aaef :=_fded .NRGBA64At (_dbgc ,_aagfc );
_cdad .SetRGBA (_dbgc ,_aagfc ,_eeee (_aaef ));};};};func _afea (_cdbe _f .Image )(Image ,error ){if _fefca ,_adbd :=_cdbe .(*Gray8 );_adbd {return _fefca .Copy (),nil ;};_baef :=_cdbe .Bounds ();_cdba ,_afb :=NewImage (_baef .Max .X ,_baef .Max .Y ,8,1,nil ,nil ,nil );
if _afb !=nil {return nil ,_afb ;};_cfdbf (_cdbe ,_cdba ,_baef );return _cdba ,nil ;};type Histogramer interface{Histogram ()[256]int ;};func _fdgc (_cacgf *_f .Gray )bool {for _gffb :=0;_gffb < len (_cacgf .Pix );_gffb ++{if !_fagc (_cacgf .Pix [_gffb ]){return false ;
};};return true ;};func (_dfbee *Gray4 )ColorAt (x ,y int )(_aa .Color ,error ){return ColorAtGray4BPC (x ,y ,_dfbee .BytesPerLine ,_dfbee .Data ,_dfbee .Decode );};func _gdbgd (_dcdd RGBA ,_aegd NRGBA ,_ffcd _f .Rectangle ){for _bece :=0;_bece < _ffcd .Max .X ;
_bece ++{for _cfbc :=0;_cfbc < _ffcd .Max .Y ;_cfbc ++{_fbge :=_dcdd .RGBAAt (_bece ,_cfbc );_aegd .SetNRGBA (_bece ,_cfbc ,_bcgd (_fbge ));};};};func _eeee (_eefe _aa .NRGBA64 )_aa .RGBA {_dacg ,_dded ,_bgd ,_ebcc :=_eefe .RGBA ();return _aa .RGBA {R :uint8 (_dacg >>8),G :uint8 (_dded >>8),B :uint8 (_bgd >>8),A :uint8 (_ebcc >>8)};
};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func (_dcd *CMYK32 )CMYKAt (x ,y int )_aa .CMYK {_aabe ,_ :=ColorAtCMYK (x ,y ,_dcd .Width ,_dcd .Data ,_dcd .Decode );
return _aabe ;};func (_ebbf *ImageBase )setFourBytes (_dgb int ,_dgc uint32 )error {if _dgb +3> len (_ebbf .Data )-1{return _gc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_dgb );
};_ebbf .Data [_dgb ]=byte ((_dgc &0xff000000)>>24);_ebbf .Data [_dgb +1]=byte ((_dgc &0xff0000)>>16);_ebbf .Data [_dgb +2]=byte ((_dgc &0xff00)>>8);_ebbf .Data [_dgb +3]=byte (_dgc &0xff);return nil ;};func _febf (_acc NRGBA ,_aeaf Gray ,_fcba _f .Rectangle ){for _dgfd :=0;
_dgfd < _fcba .Max .X ;_dgfd ++{for _ecca :=0;_ecca < _fcba .Max .Y ;_ecca ++{_aegaf :=_ecf (_acc .NRGBAAt (_dgfd ,_ecca ));_aeaf .SetGray (_dgfd ,_ecca ,_aegaf );};};};func (_cebe *Gray16 )ColorAt (x ,y int )(_aa .Color ,error ){return ColorAtGray16BPC (x ,y ,_cebe .BytesPerLine ,_cebe .Data ,_cebe .Decode );
};var _ Gray =&Monochrome {};func (_feb *CMYK32 )Set (x ,y int ,c _aa .Color ){_acf :=4*(y *_feb .Width +x );if _acf +3>=len (_feb .Data ){return ;};_adcc :=_aa .CMYKModel .Convert (c ).(_aa .CMYK );_feb .Data [_acf ]=_adcc .C ;_feb .Data [_acf +1]=_adcc .M ;
_feb .Data [_acf +2]=_adcc .Y ;_feb .Data [_acf +3]=_adcc .K ;};func (_debb *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_debb .copy ()}};func (_ecge *NRGBA64 )setNRGBA64 (_cgaae int ,_ebec _aa .NRGBA64 ,_ebfg int ){_ecge .Data [_cgaae ]=uint8 (_ebec .R >>8);
_ecge .Data [_cgaae +1]=uint8 (_ebec .R &0xff);_ecge .Data [_cgaae +2]=uint8 (_ebec .G >>8);_ecge .Data [_cgaae +3]=uint8 (_ebec .G &0xff);_ecge .Data [_cgaae +4]=uint8 (_ebec .B >>8);_ecge .Data [_cgaae +5]=uint8 (_ebec .B &0xff);if _ebfg +1< len (_ecge .Alpha ){_ecge .Alpha [_ebfg ]=uint8 (_ebec .A >>8);
_ecge .Alpha [_ebfg +1]=uint8 (_ebec .A &0xff);};};func _cab (_fbf *Monochrome ,_dfe ,_cac int )(*Monochrome ,error ){if _fbf ==nil {return nil ,_g .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _dfe <=0||_cac <=0{return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _dfe ==_cac {if _dfe ==1{return _fbf .copy (),nil ;};if _dfe ==2||_dfe ==4||_dfe ==8{_eee ,_adc :=_gg (_fbf ,_dfe );if _adc !=nil {return nil ,_adc ;};return _eee ,nil ;};};_aba :=_dfe *_fbf .Width ;_dd :=_cac *_fbf .Height ;_gf :=_fgf (_aba ,_dd );
_fef :=_gf .BytesPerLine ;var (_bd ,_da ,_ffd ,_ggb ,_dcb int ;_fg byte ;_feg error ;);for _da =0;_da < _fbf .Height ;_da ++{_bd =_cac *_da *_fef ;for _ffd =0;_ffd < _fbf .Width ;_ffd ++{if _bed :=_fbf .getBitAt (_ffd ,_da );_bed {_dcb =_dfe *_ffd ;for _ggb =0;
_ggb < _dfe ;_ggb ++{_gf .setIndexedBit (_bd *8+_dcb +_ggb );};};};for _ggb =1;_ggb < _cac ;_ggb ++{_fbb :=_bd +_ggb *_fef ;for _gff :=0;_gff < _fef ;_gff ++{if _fg ,_feg =_gf .getByte (_bd +_gff );_feg !=nil {return nil ,_feg ;};if _feg =_gf .setByte (_fbb +_gff ,_fg );
_feg !=nil {return nil ,_feg ;};};};};return _gf ,nil ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_bgc *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_bgc .copy ()}};func (_gecee *Gray2 )ColorModel ()_aa .Model {return Gray2Model };
func InDelta (expected ,current ,delta float64 )bool {_gbbb :=expected -current ;if _gbbb <=-delta ||_gbbb >=delta {return false ;};return true ;};var (_dfbb =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_bee =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);func (_gbgd *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_gbgd .copy ()}};func _gcgbb (_ddcg _f .Image )(Image ,error ){if _fggf ,_ffg :=_ddcg .(*NRGBA32 );_ffg {return _fggf .Copy (),nil ;};_bdgb ,_bdcdc ,_gbdge :=_gega (_ddcg ,1);_ddee ,_dcag :=NewImage (_bdgb .Max .X ,_bdgb .Max .Y ,8,3,nil ,_gbdge ,nil );
if _dcag !=nil {return nil ,_dcag ;};_fbdb (_ddcg ,_ddee ,_bdgb );if len (_gbdge )!=0&&!_bdcdc {if _bag :=_fedd (_gbdge ,_ddee );_bag !=nil {return nil ,_bag ;};};return _ddee ,nil ;};func _eaga (_gece _aa .Gray ,_dbe monochromeModel )_aa .Gray {if _gece .Y > uint8 (_dbe ){return _aa .Gray {Y :_a .MaxUint8 };
};return _aa .Gray {};};func _adda (_cegfg *Monochrome ,_gbfe ,_abdd ,_cca ,_caea int ,_gdfg RasterOperator ){if _gbfe < 0{_cca +=_gbfe ;_gbfe =0;};_gffef :=_gbfe +_cca -_cegfg .Width ;if _gffef > 0{_cca -=_gffef ;};if _abdd < 0{_caea +=_abdd ;_abdd =0;
};_adcd :=_abdd +_caea -_cegfg .Height ;if _adcd > 0{_caea -=_adcd ;};if _cca <=0||_caea <=0{return ;};if (_gbfe &7)==0{_cbbe (_cegfg ,_gbfe ,_abdd ,_cca ,_caea ,_gdfg );}else {_defe (_cegfg ,_gbfe ,_abdd ,_cca ,_caea ,_gdfg );};};func _agac (_daff ,_egbab uint8 )uint8 {if _daff < _egbab {return 255;
};return 0;};func ImgToGray (i _f .Image )*_f .Gray {if _fggdf ,_bbgf :=i .(*_f .Gray );_bbgf {return _fggdf ;};_gfca :=i .Bounds ();_abde :=_f .NewGray (_gfca );for _ebfc :=0;_ebfc < _gfca .Max .X ;_ebfc ++{for _fbfg :=0;_fbfg < _gfca .Max .Y ;_fbfg ++{_gbed :=i .At (_ebfc ,_fbfg );
_abde .Set (_ebfc ,_fbfg ,_gbed );};};return _abde ;};func _ebbfb (_gggdc _f .Image ,_gede Image ,_eafg _f .Rectangle ){if _gffeg ,_fgfa :=_gggdc .(SMasker );_fgfa &&_gffeg .HasAlpha (){_gede .(SMasker ).MakeAlpha ();};switch _dacc :=_gggdc .(type ){case Gray :_ccdg (_dacc ,_gede .(RGBA ),_eafg );
case NRGBA :_ceed (_dacc ,_gede .(RGBA ),_eafg );case *_f .NYCbCrA :_beed (_dacc ,_gede .(RGBA ),_eafg );case CMYK :_aed (_dacc ,_gede .(RGBA ),_eafg );case RGBA :_bbba (_dacc ,_gede .(RGBA ),_eafg );case nrgba64 :_afafb (_dacc ,_gede .(RGBA ),_eafg );
default:_gfba (_gggdc ,_gede ,_eafg );};};func (_cfb *Monochrome )ResolveDecode ()error {if len (_cfb .Decode )!=2{return nil ;};if _cfb .Decode [0]==1&&_cfb .Decode [1]==0{if _ebce :=_cfb .InverseData ();_ebce !=nil {return _ebce ;};_cfb .Decode =nil ;
};return nil ;};func _gfde (_bfg _aa .NRGBA )_aa .RGBA {_gfg ,_acfb ,_bec ,_bcb :=_bfg .RGBA ();return _aa .RGBA {R :uint8 (_gfg >>8),G :uint8 (_acfb >>8),B :uint8 (_bec >>8),A :uint8 (_bcb >>8)};};var _ _f .Image =&NRGBA64 {};func (_ebf *CMYK32 )ColorModel ()_aa .Model {return _aa .CMYKModel };
func (_fadb *ImageBase )setEightFullBytes (_dgdeg int ,_gdbf uint64 )error {if _dgdeg +7> len (_fadb .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_fadb .Data [_dgdeg ]=byte ((_gdbf &0xff00000000000000)>>56);
_fadb .Data [_dgdeg +1]=byte ((_gdbf &0xff000000000000)>>48);_fadb .Data [_dgdeg +2]=byte ((_gdbf &0xff0000000000)>>40);_fadb .Data [_dgdeg +3]=byte ((_gdbf &0xff00000000)>>32);_fadb .Data [_dgdeg +4]=byte ((_gdbf &0xff000000)>>24);_fadb .Data [_dgdeg +5]=byte ((_gdbf &0xff0000)>>16);
_fadb .Data [_dgdeg +6]=byte ((_gdbf &0xff00)>>8);_fadb .Data [_dgdeg +7]=byte (_gdbf &0xff);return nil ;};func (_aabc *RGBA32 )ColorAt (x ,y int )(_aa .Color ,error ){return ColorAtRGBA32 (x ,y ,_aabc .Width ,_aabc .Data ,_aabc .Alpha ,_aabc .Decode );
};func _caba (_fbeg NRGBA ,_ddgb CMYK ,_gea _f .Rectangle ){for _bea :=0;_bea < _gea .Max .X ;_bea ++{for _gge :=0;_gge < _gea .Max .Y ;_gge ++{_cdda :=_fbeg .NRGBAAt (_bea ,_gge );_ddgb .SetCMYK (_bea ,_gge ,_gaed (_cdda ));};};};func _bbba (_ccaf ,_age RGBA ,_ecgd _f .Rectangle ){for _agfcf :=0;
_agfcf < _ecgd .Max .X ;_agfcf ++{for _aecf :=0;_aecf < _ecgd .Max .Y ;_aecf ++{_age .SetRGBA (_agfcf ,_aecf ,_ccaf .RGBAAt (_agfcf ,_aecf ));};};};func AutoThresholdTriangle (histogram [256]int )uint8 {var _ffcdd ,_eabb ,_dgga ,_bgaea int ;for _bccdb :=0;
_bccdb < len (histogram );_bccdb ++{if histogram [_bccdb ]> 0{_ffcdd =_bccdb ;break ;};};if _ffcdd > 0{_ffcdd --;};for _abef :=255;_abef > 0;_abef --{if histogram [_abef ]> 0{_bgaea =_abef ;break ;};};if _bgaea < 255{_bgaea ++;};for _cbcc :=0;_cbcc < 256;
_cbcc ++{if histogram [_cbcc ]> _eabb {_dgga =_cbcc ;_eabb =histogram [_cbcc ];};};var _fgga bool ;if (_dgga -_ffcdd )< (_bgaea -_dgga ){_fgga =true ;var _efce int ;_egbd :=255;for _efce < _egbd {_efcd :=histogram [_efce ];histogram [_efce ]=histogram [_egbd ];
histogram [_egbd ]=_efcd ;_efce ++;_egbd --;};_ffcdd =255-_bgaea ;_dgga =255-_dgga ;};if _ffcdd ==_dgga {return uint8 (_ffcdd );};_fade :=float64 (histogram [_dgga ]);_eagg :=float64 (_ffcdd -_dgga );_ggcc :=_a .Sqrt (_fade *_fade +_eagg *_eagg );_fade /=_ggcc ;
_eagg /=_ggcc ;_ggcc =_fade *float64 (_ffcdd )+_eagg *float64 (histogram [_ffcdd ]);_dabd :=_ffcdd ;var _abcg float64 ;for _egbe :=_ffcdd +1;_egbe <=_dgga ;_egbe ++{_cdac :=_fade *float64 (_egbe )+_eagg *float64 (histogram [_egbe ])-_ggcc ;if _cdac > _abcg {_dabd =_egbe ;
_abcg =_cdac ;};};_dabd --;if _fgga {var _fadg int ;_edga :=255;for _fadg < _edga {_gecd :=histogram [_fadg ];histogram [_fadg ]=histogram [_edga ];histogram [_edga ]=_gecd ;_fadg ++;_edga --;};return uint8 (255-_dabd );};return uint8 (_dabd );};type SMasker interface{HasAlpha ()bool ;
GetAlpha ()[]byte ;MakeAlpha ();};func _efcg (_dda _aa .NRGBA64 )_aa .NRGBA {return _aa .NRGBA {R :uint8 (_dda .R >>8),G :uint8 (_dda .G >>8),B :uint8 (_dda .B >>8),A :uint8 (_dda .A >>8)};};func (_edce *Monochrome )IsUnpadded ()bool {return (_edce .Width *_edce .Height )==len (_edce .Data )};
func (_bdcce *Monochrome )getBit (_bbg ,_fgg int )uint8 {return _bdcce .Data [_bbg +(_fgg >>3)]>>uint (7-(_fgg &7))&1;};func _fegca (_eggg CMYK ,_dadg Gray ,_bbge _f .Rectangle ){for _beda :=0;_beda < _bbge .Max .X ;_beda ++{for _fgaa :=0;_fgaa < _bbge .Max .Y ;
_fgaa ++{_ddbc :=_bac (_eggg .CMYKAt (_beda ,_fgaa ));_dadg .SetGray (_beda ,_fgaa ,_ddbc );};};};func (_edd *Gray4 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_edd .Width ,Y :_edd .Height }};};func _gab (_bcdg _f .Image )(Image ,error ){if _bcgb ,_efa :=_bcdg .(*Monochrome );
_efa {return _bcgb ,nil ;};_dab :=_bcdg .Bounds ();var _dafa Gray ;switch _gba :=_bcdg .(type ){case Gray :_dafa =_gba ;case NRGBA :_dafa =&Gray8 {ImageBase :NewImageBase (_dab .Max .X ,_dab .Max .Y ,8,1,nil ,nil ,nil )};_addd (_dafa ,_gba ,_dab );case nrgba64 :_dafa =&Gray8 {ImageBase :NewImageBase (_dab .Max .X ,_dab .Max .Y ,8,1,nil ,nil ,nil )};
_gagd (_dafa ,_gba ,_dab );default:_fdgg ,_gcc :=GrayConverter .Convert (_bcdg );if _gcc !=nil {return nil ,_gcc ;};_dafa =_fdgg .(Gray );};_ebb ,_adf :=NewImage (_dab .Max .X ,_dab .Max .Y ,1,1,nil ,nil ,nil );if _adf !=nil {return nil ,_adf ;};_fbega :=_ebb .(*Monochrome );
_bde :=AutoThresholdTriangle (GrayHistogram (_dafa ));for _bcc :=0;_bcc < _dab .Max .X ;_bcc ++{for _dcdb :=0;_dcdb < _dab .Max .Y ;_dcdb ++{_acd :=_eaga (_dafa .GrayAt (_bcc ,_dcdb ),monochromeModel (_bde ));_fbega .SetGray (_bcc ,_dcdb ,_acd );};};return _ebb ,nil ;
};func (_abbg *RGBA32 )Base ()*ImageBase {return &_abbg .ImageBase };var _ Gray =&Gray4 {};func (_dbgg *ImageBase )GetAlpha ()[]byte {return _dbgg .Alpha };func _beed (_cbbg *_f .NYCbCrA ,_fdfbc RGBA ,_fceee _f .Rectangle ){for _dbada :=0;_dbada < _fceee .Max .X ;
_dbada ++{for _ebaad :=0;_ebaad < _fceee .Max .Y ;_ebaad ++{_aaefe :=_cbbg .NYCbCrAAt (_dbada ,_ebaad );_fdfbc .SetRGBA (_dbada ,_ebaad ,_ebeb (_aaefe ));};};};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;
PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;
PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func (_acde *Monochrome )copy ()*Monochrome {_bbca :=_fgf (_acde .Width ,_acde .Height );
_bbca .ModelThreshold =_acde .ModelThreshold ;_bbca .Data =make ([]byte ,len (_acde .Data ));copy (_bbca .Data ,_acde .Data );if len (_acde .Decode )!=0{_bbca .Decode =make ([]float64 ,len (_acde .Decode ));copy (_bbca .Decode ,_acde .Decode );};if len (_acde .Alpha )!=0{_bbca .Alpha =make ([]byte ,len (_acde .Alpha ));
copy (_bbca .Alpha ,_acde .Alpha );};return _bbca ;};