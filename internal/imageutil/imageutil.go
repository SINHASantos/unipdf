//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_b "encoding/binary";_a "errors";_gb "fmt";_cca "github.com/unidoc/unipdf/v3/common";_fb "github.com/unidoc/unipdf/v3/internal/bitwise";_f "image";_g "image/color";_cc "image/draw";_af "math";);func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _fgab (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_dga *CMYK32 )CMYKAt (x ,y int )_g .CMYK {_dcd ,_ :=ColorAtCMYK (x ,y ,_dga .Width ,_dga .Data ,_dga .Decode );return _dcd ;};func (_eefe *Gray4 )Validate ()error {if len (_eefe .Data )!=_eefe .Height *_eefe .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_afac *NRGBA16 )ColorModel ()_g .Model {return NRGBA16Model };func (_eef *Gray2 )Base ()*ImageBase {return &_eef .ImageBase };func (_ceed *Monochrome )setBit (_ddbe ,_gcabc int ){_ceed .Data [_ddbe +(_gcabc >>3)]|=0x80>>uint (_gcabc &7);
};var _ _f .Image =&Gray16 {};func _ecgf (_cedce _f .Image )(Image ,error ){if _abbe ,_bffg :=_cedce .(*Gray4 );_bffg {return _abbe .Copy (),nil ;};_bcba :=_cedce .Bounds ();_geac ,_bfdge :=NewImage (_bcba .Max .X ,_bcba .Max .Y ,4,1,nil ,nil ,nil );if _bfdge !=nil {return nil ,_bfdge ;
};_acb (_cedce ,_geac ,_bcba );return _geac ,nil ;};func (_gfeb *NRGBA32 )Set (x ,y int ,c _g .Color ){_cdca :=y *_gfeb .Width +x ;_gfaa :=3*_cdca ;if _gfaa +2>=len (_gfeb .Data ){return ;};_ddfb :=_g .NRGBAModel .Convert (c ).(_g .NRGBA );_gfeb .setRGBA (_cdca ,_ddfb );
};func (_babda *NRGBA64 )Validate ()error {if len (_babda .Data )!=3*2*_babda .Width *_babda .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _gga (_gag _g .NRGBA )_g .Gray {_gcce ,_gcda ,_dcea ,_ :=_gag .RGBA ();_ddaa :=(19595*_gcce +38470*_gcda +7471*_dcea +1<<15)>>24;return _g .Gray {Y :uint8 (_ddaa )};};func _gcf (_bfe _g .Gray )_g .NRGBA {return _g .NRGBA {R :_bfe .Y ,G :_bfe .Y ,B :_bfe .Y ,A :0xff}};
func _fgg (_ffed NRGBA ,_adb CMYK ,_dcde _f .Rectangle ){for _dcdc :=0;_dcdc < _dcde .Max .X ;_dcdc ++{for _cbc :=0;_cbc < _dcde .Max .Y ;_cbc ++{_eacf :=_ffed .NRGBAAt (_dcdc ,_cbc );_adb .SetCMYK (_dcdc ,_cbc ,_edfa (_eacf ));};};};func _ffb (_cge ,_dcg *Monochrome ,_dfg []byte ,_fde int )(_eab error ){var (_caca ,_ddc ,_bae ,_fdf ,_gdag ,_fbc ,_cdb ,_gdbe int ;
_fba ,_cdd ,_fcdg ,_bgb uint32 ;_agd ,_ebed byte ;_eac uint16 ;);_cbd :=make ([]byte ,4);_fgc :=make ([]byte ,4);for _bae =0;_bae < _cge .Height -1;_bae ,_fdf =_bae +2,_fdf +1{_caca =_bae *_cge .BytesPerLine ;_ddc =_fdf *_dcg .BytesPerLine ;for _gdag ,_fbc =0,0;
_gdag < _fde ;_gdag ,_fbc =_gdag +4,_fbc +1{for _cdb =0;_cdb < 4;_cdb ++{_gdbe =_caca +_gdag +_cdb ;if _gdbe <=len (_cge .Data )-1&&_gdbe < _caca +_cge .BytesPerLine {_cbd [_cdb ]=_cge .Data [_gdbe ];}else {_cbd [_cdb ]=0x00;};_gdbe =_caca +_cge .BytesPerLine +_gdag +_cdb ;
if _gdbe <=len (_cge .Data )-1&&_gdbe < _caca +(2*_cge .BytesPerLine ){_fgc [_cdb ]=_cge .Data [_gdbe ];}else {_fgc [_cdb ]=0x00;};};_fba =_b .BigEndian .Uint32 (_cbd );_cdd =_b .BigEndian .Uint32 (_fgc );_fcdg =_fba &_cdd ;_fcdg |=_fcdg <<1;_bgb =_fba |_cdd ;
_bgb &=_bgb <<1;_cdd =_fcdg &_bgb ;_cdd &=0xaaaaaaaa;_fba =_cdd |(_cdd <<7);_agd =byte (_fba >>24);_ebed =byte ((_fba >>8)&0xff);_gdbe =_ddc +_fbc ;if _gdbe +1==len (_dcg .Data )-1||_gdbe +1>=_ddc +_dcg .BytesPerLine {if _eab =_dcg .setByte (_gdbe ,_dfg [_agd ]);
_eab !=nil {return _gb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gdbe );};}else {_eac =(uint16 (_dfg [_agd ])<<8)|uint16 (_dfg [_ebed ]);if _eab =_dcg .setTwoBytes (_gdbe ,_eac );_eab !=nil {return _gb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gdbe );
};_fbc ++;};};};return nil ;};func (_cefg *Monochrome )getBit (_eff ,_gacdd int )uint8 {return _cefg .Data [_eff +(_gacdd >>3)]>>uint (7-(_gacdd &7))&1;};func _abga (_cad _g .CMYK )_g .RGBA {_cff ,_edf ,_bbd :=_g .CMYKToRGB (_cad .C ,_cad .M ,_cad .Y ,_cad .K );
return _g .RGBA {R :_cff ,G :_edf ,B :_bbd ,A :0xff};};type ColorConverter interface{Convert (_dce _f .Image )(Image ,error );};func (_dabd *NRGBA64 )At (x ,y int )_g .Color {_dcdb ,_ :=_dabd .ColorAt (x ,y );return _dcdb };func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_g .CMYK ,error ){_bebc :=4*(y *width +x );
if _bebc +3>=len (data ){return _g .CMYK {},_gb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_bebc ]&0xff;M :=data [_bebc +1]&0xff;Y :=data [_bebc +2]&0xff;K :=data [_bebc +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _g .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_dgfe *ImageBase )setTwoBytes (_aceec int ,_eaba uint16 )error {if _aceec +1> len (_dgfe .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dgfe .Data [_aceec ]=byte ((_eaba &0xff00)>>8);_dgfe .Data [_aceec +1]=byte (_eaba &0xff);return nil ;};func (_eeeg *NRGBA16 )setNRGBA (_daag ,_eaac ,_gfbe int ,_aagd _g .NRGBA ){if _daag *3%2==0{_eeeg .Data [_gfbe ]=(_aagd .R >>4)<<4|(_aagd .G >>4);
_eeeg .Data [_gfbe +1]=(_aagd .B >>4)<<4|(_eeeg .Data [_gfbe +1]&0xf);}else {_eeeg .Data [_gfbe ]=(_eeeg .Data [_gfbe ]&0xf0)|(_aagd .R >>4);_eeeg .Data [_gfbe +1]=(_aagd .G >>4)<<4|(_aagd .B >>4);};if _eeeg .Alpha !=nil {_egca :=_eaac *BytesPerLine (_eeeg .Width ,4,1);
if _egca < len (_eeeg .Alpha ){if _daag %2==0{_eeeg .Alpha [_egca ]=(_aagd .A >>uint (4))<<uint (4)|(_eeeg .Alpha [_gfbe ]&0xf);}else {_eeeg .Alpha [_egca ]=(_eeeg .Alpha [_egca ]&0xf0)|(_aagd .A >>uint (4));};};};};func (_fggg *Monochrome )GrayAt (x ,y int )_g .Gray {_bfg ,_ :=ColorAtGray1BPC (x ,y ,_fggg .BytesPerLine ,_fggg .Data ,_fggg .Decode );
return _bfg ;};func _ef (_gba *Monochrome ,_cccb ,_efb int )(*Monochrome ,error ){if _gba ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _cccb <=0||_efb <=0{return nil ,_a .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _cccb ==_efb {if _cccb ==1{return _gba .copy (),nil ;};if _cccb ==2||_cccb ==4||_cccb ==8{_fa ,_gbd :=_df (_gba ,_cccb );if _gbd !=nil {return nil ,_gbd ;};return _fa ,nil ;};};_dgb :=_cccb *_gba .Width ;_cbb :=_efb *_gba .Height ;_cbg :=_gdge (_dgb ,_cbb );
_gdb :=_cbg .BytesPerLine ;var (_def ,_gf ,_ee ,_be ,_agec int ;_febd byte ;_egc error ;);for _gf =0;_gf < _gba .Height ;_gf ++{_def =_efb *_gf *_gdb ;for _ee =0;_ee < _gba .Width ;_ee ++{if _aa :=_gba .getBitAt (_ee ,_gf );_aa {_agec =_cccb *_ee ;for _be =0;
_be < _cccb ;_be ++{_cbg .setIndexedBit (_def *8+_agec +_be );};};};for _be =1;_be < _efb ;_be ++{_gdbg :=_def +_be *_gdb ;for _fgf :=0;_fgf < _gdb ;_fgf ++{if _febd ,_egc =_cbg .getByte (_def +_fgf );_egc !=nil {return nil ,_egc ;};if _egc =_cbg .setByte (_gdbg +_fgf ,_febd );
_egc !=nil {return nil ,_egc ;};};};};return _cbg ,nil ;};func (_ebcc *Gray4 )Histogram ()(_dacd [256]int ){for _cfgd :=0;_cfgd < _ebcc .Width ;_cfgd ++{for _egce :=0;_egce < _ebcc .Height ;_egce ++{_dacd [_ebcc .GrayAt (_cfgd ,_egce ).Y ]++;};};return _dacd ;
};func (_gcg *Gray16 )GrayAt (x ,y int )_g .Gray {_bcbc ,_ :=_gcg .ColorAt (x ,y );return _g .Gray {Y :uint8 (_bcbc .(_g .Gray16 ).Y >>8)};};type RasterOperator int ;func (_daf *Gray16 )Base ()*ImageBase {return &_daf .ImageBase };func _bdgf (_fggc _g .RGBA )_g .NRGBA {switch _fggc .A {case 0xff:return _g .NRGBA {R :_fggc .R ,G :_fggc .G ,B :_fggc .B ,A :0xff};
case 0x00:return _g .NRGBA {};default:_aaab ,_edgd ,_eecd ,_dab :=_fggc .RGBA ();_aaab =(_aaab *0xffff)/_dab ;_edgd =(_edgd *0xffff)/_dab ;_eecd =(_eecd *0xffff)/_dab ;return _g .NRGBA {R :uint8 (_aaab >>8),G :uint8 (_edgd >>8),B :uint8 (_eecd >>8),A :uint8 (_dab >>8)};
};};func (_abecb *ImageBase )MakeAlpha (){_abecb .newAlpha ()};func ImgToGray (i _f .Image )*_f .Gray {if _gfacb ,_fgec :=i .(*_f .Gray );_fgec {return _gfacb ;};_bfcf :=i .Bounds ();_agfb :=_f .NewGray (_bfcf );for _bbgg :=0;_bbgg < _bfcf .Max .X ;_bbgg ++{for _bcbe :=0;
_bcbe < _bfcf .Max .Y ;_bcbe ++{_cgbb :=i .At (_bbgg ,_bcbe );_agfb .Set (_bbgg ,_bcbe ,_cgbb );};};return _agfb ;};func (_aca *Gray4 )SetGray (x ,y int ,g _g .Gray ){if x >=_aca .Width ||y >=_aca .Height {return ;};g =_fbee (g );_aca .setGray (x ,y ,g );
};func (_efdag *ImageBase )Pix ()[]byte {return _efdag .Data };func (_dddfg *ImageBase )HasAlpha ()bool {if _dddfg .Alpha ==nil {return false ;};for _ceg :=range _dddfg .Alpha {if _dddfg .Alpha [_ceg ]!=0xff{return true ;};};return false ;};func (_fbce *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_fbce .copy ()}};
func _afc (_eg ,_ec *Monochrome )(_cgg error ){_afd :=_ec .BytesPerLine ;_ga :=_eg .BytesPerLine ;var (_eda byte ;_ab uint16 ;_ge ,_bb ,_cf ,_ebe ,_ba int ;);for _cf =0;_cf < _ec .Height ;_cf ++{_ge =_cf *_afd ;_bb =2*_cf *_ga ;for _ebe =0;_ebe < _afd ;
_ebe ++{_eda =_ec .Data [_ge +_ebe ];_ab =_cbgd [_eda ];_ba =_bb +_ebe *2;if _eg .BytesPerLine !=_ec .BytesPerLine *2&&(_ebe +1)*2> _eg .BytesPerLine {_cgg =_eg .setByte (_ba ,byte (_ab >>8));}else {_cgg =_eg .setTwoBytes (_ba ,_ab );};if _cgg !=nil {return _cgg ;
};};for _ebe =0;_ebe < _ga ;_ebe ++{_ba =_bb +_ga +_ebe ;_eda =_eg .Data [_bb +_ebe ];if _cgg =_eg .setByte (_ba ,_eda );_cgg !=nil {return _cgg ;};};};return nil ;};func _egg (_dacdc _f .Image )(Image ,error ){if _fcfd ,_fega :=_dacdc .(*RGBA32 );_fega {return _fcfd .Copy (),nil ;
};_affcd ,_ggdc ,_bebdb :=_fdfe (_dacdc ,1);_eeba :=&RGBA32 {ImageBase :NewImageBase (_affcd .Max .X ,_affcd .Max .Y ,8,3,nil ,_bebdb ,nil )};_aaaba (_dacdc ,_eeba ,_affcd );if len (_bebdb )!=0&&!_ggdc {if _agdg :=_edb (_bebdb ,_eeba );_agdg !=nil {return nil ,_agdg ;
};};return _eeba ,nil ;};var _ Gray =&Gray4 {};func (_dgce *Gray16 )SetGray (x ,y int ,g _g .Gray ){_agc :=(y *_dgce .BytesPerLine /2+x )*2;if _agc +1>=len (_dgce .Data ){return ;};_dgce .Data [_agc ]=g .Y ;_dgce .Data [_agc +1]=g .Y ;};func _afa ()(_gca [256]uint64 ){for _bba :=0;
_bba < 256;_bba ++{if _bba &0x01!=0{_gca [_bba ]|=0xff;};if _bba &0x02!=0{_gca [_bba ]|=0xff00;};if _bba &0x04!=0{_gca [_bba ]|=0xff0000;};if _bba &0x08!=0{_gca [_bba ]|=0xff000000;};if _bba &0x10!=0{_gca [_bba ]|=0xff00000000;};if _bba &0x20!=0{_gca [_bba ]|=0xff0000000000;
};if _bba &0x40!=0{_gca [_bba ]|=0xff000000000000;};if _bba &0x80!=0{_gca [_bba ]|=0xff00000000000000;};};return _gca ;};func (_baa *ImageBase )setEightFullBytes (_edeg int ,_ccab uint64 )error {if _edeg +7> len (_baa .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_baa .Data [_edeg ]=byte ((_ccab &0xff00000000000000)>>56);_baa .Data [_edeg +1]=byte ((_ccab &0xff000000000000)>>48);_baa .Data [_edeg +2]=byte ((_ccab &0xff0000000000)>>40);_baa .Data [_edeg +3]=byte ((_ccab &0xff00000000)>>32);_baa .Data [_edeg +4]=byte ((_ccab &0xff000000)>>24);
_baa .Data [_edeg +5]=byte ((_ccab &0xff0000)>>16);_baa .Data [_edeg +6]=byte ((_ccab &0xff00)>>8);_baa .Data [_edeg +7]=byte (_ccab &0xff);return nil ;};func (_cceb monochromeModel )Convert (c _g .Color )_g .Color {_cda :=_g .GrayModel .Convert (c ).(_g .Gray );
return _bgd (_cda ,_cceb );};func _edac (_ceee CMYK ,_cdae Gray ,_gcabg _f .Rectangle ){for _acfe :=0;_acfe < _gcabg .Max .X ;_acfe ++{for _abca :=0;_abca < _gcabg .Max .Y ;_abca ++{_gfc :=_gfgg (_ceee .CMYKAt (_acfe ,_abca ));_cdae .SetGray (_acfe ,_abca ,_gfc );
};};};var _ RGBA =&RGBA32 {};func _fbdb (_faga _g .RGBA )_g .Gray {_cdda :=(19595*uint32 (_faga .R )+38470*uint32 (_faga .G )+7471*uint32 (_faga .B )+1<<7)>>16;return _g .Gray {Y :uint8 (_cdda )};};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;
};return 1<<(_efada (n )+1);};func (_cbbc *Gray8 )Validate ()error {if len (_cbbc .Data )!=_cbbc .Height *_cbbc .BytesPerLine {return ErrInvalidImage ;};return nil ;};var (_baff =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_cdgc =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);func _fff (_gde _g .RGBA )_g .CMYK {_aeaf ,_aaaf ,_edca ,_acc :=_g .RGBToCMYK (_gde .R ,_gde .G ,_gde .B );return _g .CMYK {C :_aeaf ,M :_aaaf ,Y :_edca ,K :_acc };};func _ccebg (_bdac *Monochrome ,_bcga ,_abcfd ,_eegf ,_cfdb int ,_agfcb RasterOperator ,_deac *Monochrome ,_agag ,_fbae int )error {var (_cbafc bool ;
_efcg bool ;_gcaeag int ;_efec int ;_ggge int ;_dagd bool ;_eace byte ;_bbdb int ;_gddc int ;_ccfa int ;_fagae ,_fab int ;);_bebda :=8-(_bcga &7);_bbb :=_cdgc [_bebda ];_gead :=_bdac .BytesPerLine *_abcfd +(_bcga >>3);_ccb :=_deac .BytesPerLine *_fbae +(_agag >>3);
if _eegf < _bebda {_cbafc =true ;_bbb &=_baff [8-_bebda +_eegf ];};if !_cbafc {_gcaeag =(_eegf -_bebda )>>3;if _gcaeag > 0{_efcg =true ;_efec =_gead +1;_ggge =_ccb +1;};};_bbdb =(_bcga +_eegf )&7;if !(_cbafc ||_bbdb ==0){_dagd =true ;_eace =_baff [_bbdb ];
_gddc =_gead +1+_gcaeag ;_ccfa =_ccb +1+_gcaeag ;};switch _agfcb {case PixSrc :for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],_deac .Data [_ccb ],_bbb );_gead +=_bdac .BytesPerLine ;_ccb +=_deac .BytesPerLine ;
};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;_fab ++{_bdac .Data [_efec +_fab ]=_deac .Data [_ggge +_fab ];};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;};};if _dagd {for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],_deac .Data [_ccfa ],_eace );
_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};case PixNotSrc :for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],^_deac .Data [_ccb ],_bbb );_gead +=_bdac .BytesPerLine ;_ccb +=_deac .BytesPerLine ;
};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;_fab ++{_bdac .Data [_efec +_fab ]=^_deac .Data [_ggge +_fab ];};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;};};if _dagd {for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],^_deac .Data [_ccfa ],_eace );
_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};case PixSrcOrDst :for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],_deac .Data [_ccb ]|_bdac .Data [_gead ],_bbb );_gead +=_bdac .BytesPerLine ;_ccb +=_deac .BytesPerLine ;
};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;_fab ++{_bdac .Data [_efec +_fab ]|=_deac .Data [_ggge +_fab ];};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;};};if _dagd {for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],_deac .Data [_ccfa ]|_bdac .Data [_gddc ],_eace );
_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};case PixSrcAndDst :for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],_deac .Data [_ccb ]&_bdac .Data [_gead ],_bbb );_gead +=_bdac .BytesPerLine ;_ccb +=_deac .BytesPerLine ;
};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;_fab ++{_bdac .Data [_efec +_fab ]&=_deac .Data [_ggge +_fab ];};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;};};if _dagd {for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],_deac .Data [_ccfa ]&_bdac .Data [_gddc ],_eace );
_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};case PixSrcXorDst :for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],_deac .Data [_ccb ]^_bdac .Data [_gead ],_bbb );_gead +=_bdac .BytesPerLine ;_ccb +=_deac .BytesPerLine ;
};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;_fab ++{_bdac .Data [_efec +_fab ]^=_deac .Data [_ggge +_fab ];};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;};};if _dagd {for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],_deac .Data [_ccfa ]^_bdac .Data [_gddc ],_eace );
_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};case PixNotSrcOrDst :for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],^(_deac .Data [_ccb ])|_bdac .Data [_gead ],_bbb );_gead +=_bdac .BytesPerLine ;
_ccb +=_deac .BytesPerLine ;};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;_fab ++{_bdac .Data [_efec +_fab ]|=^(_deac .Data [_ggge +_fab ]);};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;};};if _dagd {for _fagae =0;
_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],^(_deac .Data [_ccfa ])|_bdac .Data [_gddc ],_eace );_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};case PixNotSrcAndDst :for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],^(_deac .Data [_ccb ])&_bdac .Data [_gead ],_bbb );
_gead +=_bdac .BytesPerLine ;_ccb +=_deac .BytesPerLine ;};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;_fab ++{_bdac .Data [_efec +_fab ]&=^_deac .Data [_ggge +_fab ];};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;
};};if _dagd {for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],^(_deac .Data [_ccfa ])&_bdac .Data [_gddc ],_eace );_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};case PixSrcOrNotDst :for _fagae =0;
_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],_deac .Data [_ccb ]|^(_bdac .Data [_gead ]),_bbb );_gead +=_bdac .BytesPerLine ;_ccb +=_deac .BytesPerLine ;};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;
_fab ++{_bdac .Data [_efec +_fab ]=_deac .Data [_ggge +_fab ]|^(_bdac .Data [_efec +_fab ]);};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;};};if _dagd {for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],_deac .Data [_ccfa ]|^(_bdac .Data [_gddc ]),_eace );
_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};case PixSrcAndNotDst :for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],_deac .Data [_ccb ]&^(_bdac .Data [_gead ]),_bbb );_gead +=_bdac .BytesPerLine ;
_ccb +=_deac .BytesPerLine ;};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;_fab ++{_bdac .Data [_efec +_fab ]=_deac .Data [_ggge +_fab ]&^(_bdac .Data [_efec +_fab ]);};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;
};};if _dagd {for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],_deac .Data [_ccfa ]&^(_bdac .Data [_gddc ]),_eace );_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};case PixNotPixSrcOrDst :for _fagae =0;
_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],^(_deac .Data [_ccb ]|_bdac .Data [_gead ]),_bbb );_gead +=_bdac .BytesPerLine ;_ccb +=_deac .BytesPerLine ;};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;
_fab ++{_bdac .Data [_efec +_fab ]=^(_deac .Data [_ggge +_fab ]|_bdac .Data [_efec +_fab ]);};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;};};if _dagd {for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],^(_deac .Data [_ccfa ]|_bdac .Data [_gddc ]),_eace );
_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};case PixNotPixSrcAndDst :for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],^(_deac .Data [_ccb ]&_bdac .Data [_gead ]),_bbb );_gead +=_bdac .BytesPerLine ;
_ccb +=_deac .BytesPerLine ;};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;_fab ++{_bdac .Data [_efec +_fab ]=^(_deac .Data [_ggge +_fab ]&_bdac .Data [_efec +_fab ]);};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;
};};if _dagd {for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],^(_deac .Data [_ccfa ]&_bdac .Data [_gddc ]),_eace );_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};case PixNotPixSrcXorDst :for _fagae =0;
_fagae < _cfdb ;_fagae ++{_bdac .Data [_gead ]=_adec (_bdac .Data [_gead ],^(_deac .Data [_ccb ]^_bdac .Data [_gead ]),_bbb );_gead +=_bdac .BytesPerLine ;_ccb +=_deac .BytesPerLine ;};if _efcg {for _fagae =0;_fagae < _cfdb ;_fagae ++{for _fab =0;_fab < _gcaeag ;
_fab ++{_bdac .Data [_efec +_fab ]=^(_deac .Data [_ggge +_fab ]^_bdac .Data [_efec +_fab ]);};_efec +=_bdac .BytesPerLine ;_ggge +=_deac .BytesPerLine ;};};if _dagd {for _fagae =0;_fagae < _cfdb ;_fagae ++{_bdac .Data [_gddc ]=_adec (_bdac .Data [_gddc ],^(_deac .Data [_ccfa ]^_bdac .Data [_gddc ]),_eace );
_gddc +=_bdac .BytesPerLine ;_ccfa +=_deac .BytesPerLine ;};};default:_cca .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_agfcb );return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func (_dgffg *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_dgffg .copy ()}};func (_efba *Gray16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray16BPC (x ,y ,_efba .BytesPerLine ,_efba .Data ,_efba .Decode );};var _ Image =&Gray4 {};
func (_dgcd *Monochrome )AddPadding ()(_cbbd error ){if _dgeg :=((_dgcd .Width *_dgcd .Height )+7)>>3;len (_dgcd .Data )< _dgeg {return _gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_dgcd .Data ),_dgeg );
};_fbdf :=_dgcd .Width %8;if _fbdf ==0{return nil ;};_dcfc :=_dgcd .Width /8;_bed :=_fb .NewReader (_dgcd .Data );_bdge :=make ([]byte ,_dgcd .Height *_dgcd .BytesPerLine );_gfgf :=_fb .NewWriterMSB (_bdge );_caeb :=make ([]byte ,_dcfc );var (_febe int ;
_fdbd uint64 ;);for _febe =0;_febe < _dgcd .Height ;_febe ++{if _ ,_cbbd =_bed .Read (_caeb );_cbbd !=nil {return _cbbd ;};if _ ,_cbbd =_gfgf .Write (_caeb );_cbbd !=nil {return _cbbd ;};if _fdbd ,_cbbd =_bed .ReadBits (byte (_fbdf ));_cbbd !=nil {return _cbbd ;
};if _cbbd =_gfgf .WriteByte (byte (_fdbd )<<uint (8-_fbdf ));_cbbd !=nil {return _cbbd ;};};_dgcd .Data =_gfgf .Data ();return nil ;};func _abef (_aggc _g .Color )_g .Color {_gfec :=_g .NRGBAModel .Convert (_aggc ).(_g .NRGBA );return _edfe (_gfec );};
func _agf (_aef _g .NRGBA64 )_g .Gray {var _cfbc _g .NRGBA64 ;if _aef ==_cfbc {return _g .Gray {Y :0xff};};_bec ,_afed ,_efa ,_ :=_aef .RGBA ();_eedc :=(19595*_bec +38470*_afed +7471*_efa +1<<15)>>24;return _g .Gray {Y :uint8 (_eedc )};};type monochromeThresholdConverter struct{Threshold uint8 ;
};func (_cdbg *Monochrome )At (x ,y int )_g .Color {_gbec ,_ :=_cdbg .ColorAt (x ,y );return _gbec };var _ Image =&Gray8 {};func _fbcb (_afab *Monochrome ,_ffg ,_bbe ,_cedd ,_debb int ,_dacc RasterOperator ,_daee *Monochrome ,_bbdff ,_cegff int )error {var (_bga bool ;
_cfe bool ;_egef byte ;_bafdb int ;_fbde int ;_eefc int ;_gaacd int ;_becef bool ;_daeee int ;_gccca int ;_dbc int ;_ecca bool ;_gcbb byte ;_bbfa int ;_cabfe int ;_bbaf int ;_fbcdb byte ;_gefb int ;_ffga int ;_ffedf uint ;_daed uint ;_aedf byte ;_cfdc shift ;
_fbacc bool ;_eagf bool ;_gee ,_afgc int ;);if _bbdff &7!=0{_ffga =8-(_bbdff &7);};if _ffg &7!=0{_fbde =8-(_ffg &7);};if _ffga ==0&&_fbde ==0{_aedf =_cdgc [0];}else {if _fbde > _ffga {_ffedf =uint (_fbde -_ffga );}else {_ffedf =uint (8-(_ffga -_fbde ));
};_daed =8-_ffedf ;_aedf =_cdgc [_ffedf ];};if (_ffg &7)!=0{_bga =true ;_bafdb =8-(_ffg &7);_egef =_cdgc [_bafdb ];_eefc =_afab .BytesPerLine *_bbe +(_ffg >>3);_gaacd =_daee .BytesPerLine *_cegff +(_bbdff >>3);_gefb =8-(_bbdff &7);if _bafdb > _gefb {_cfdc =_aaff ;
if _cedd >=_ffga {_fbacc =true ;};}else {_cfdc =_cfc ;};};if _cedd < _bafdb {_cfe =true ;_egef &=_baff [8-_bafdb +_cedd ];};if !_cfe {_daeee =(_cedd -_bafdb )>>3;if _daeee !=0{_becef =true ;_gccca =_afab .BytesPerLine *_bbe +((_ffg +_fbde )>>3);_dbc =_daee .BytesPerLine *_cegff +((_bbdff +_fbde )>>3);
};};_bbfa =(_ffg +_cedd )&7;if !(_cfe ||_bbfa ==0){_ecca =true ;_gcbb =_baff [_bbfa ];_cabfe =_afab .BytesPerLine *_bbe +((_ffg +_fbde )>>3)+_daeee ;_bbaf =_daee .BytesPerLine *_cegff +((_bbdff +_fbde )>>3)+_daeee ;if _bbfa > int (_daed ){_eagf =true ;
};};switch _dacc {case PixSrc :if _bga {for _gee =0;_gee < _debb ;_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;
};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],_fbcdb ,_egef );_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;_afgc < _daeee ;_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );
_afab .Data [_gccca +_afgc ]=_fbcdb ;};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};};if _ecca {for _gee =0;_gee < _debb ;_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );
};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],_fbcdb ,_gcbb );_cabfe +=_afab .BytesPerLine ;_bbaf +=_daee .BytesPerLine ;};};case PixNotSrc :if _bga {for _gee =0;_gee < _debb ;_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );
};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],^_fbcdb ,_egef );_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;_afgc < _daeee ;
_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );_afab .Data [_gccca +_afgc ]=^_fbcdb ;};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};};if _ecca {for _gee =0;_gee < _debb ;_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;
if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],^_fbcdb ,_gcbb );_cabfe +=_afab .BytesPerLine ;_bbaf +=_daee .BytesPerLine ;};};case PixSrcOrDst :if _bga {for _gee =0;_gee < _debb ;
_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],_fbcdb |_afab .Data [_eefc ],_egef );
_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;_afgc < _daeee ;_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );_afab .Data [_gccca +_afgc ]|=_fbcdb ;
};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};};if _ecca {for _gee =0;_gee < _debb ;_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],_fbcdb |_afab .Data [_cabfe ],_gcbb );
_cabfe +=_afab .BytesPerLine ;_bbaf +=_daee .BytesPerLine ;};};case PixSrcAndDst :if _bga {for _gee =0;_gee < _debb ;_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );
};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],_fbcdb &_afab .Data [_eefc ],_egef );_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;
_afgc < _daeee ;_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );_afab .Data [_gccca +_afgc ]&=_fbcdb ;};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};};if _ecca {for _gee =0;_gee < _debb ;
_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],_fbcdb &_afab .Data [_cabfe ],_gcbb );_cabfe +=_afab .BytesPerLine ;_bbaf +=_daee .BytesPerLine ;
};};case PixSrcXorDst :if _bga {for _gee =0;_gee < _debb ;_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],_fbcdb ^_afab .Data [_eefc ],_egef );
_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;_afgc < _daeee ;_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );_afab .Data [_gccca +_afgc ]^=_fbcdb ;
};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};};if _ecca {for _gee =0;_gee < _debb ;_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],_fbcdb ^_afab .Data [_cabfe ],_gcbb );
_cabfe +=_afab .BytesPerLine ;_bbaf +=_daee .BytesPerLine ;};};case PixNotSrcOrDst :if _bga {for _gee =0;_gee < _debb ;_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );
};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],^_fbcdb |_afab .Data [_eefc ],_egef );_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;
_afgc < _daeee ;_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );_afab .Data [_gccca +_afgc ]|=^_fbcdb ;};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};};if _ecca {for _gee =0;_gee < _debb ;
_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],^_fbcdb |_afab .Data [_cabfe ],_gcbb );_cabfe +=_afab .BytesPerLine ;_bbaf +=_daee .BytesPerLine ;
};};case PixNotSrcAndDst :if _bga {for _gee =0;_gee < _debb ;_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],^_fbcdb &_afab .Data [_eefc ],_egef );
_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;_afgc < _daeee ;_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );_afab .Data [_gccca +_afgc ]&=^_fbcdb ;
};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};};if _ecca {for _gee =0;_gee < _debb ;_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],^_fbcdb &_afab .Data [_cabfe ],_gcbb );
_cabfe +=_afab .BytesPerLine ;_bbaf +=_daee .BytesPerLine ;};};case PixSrcOrNotDst :if _bga {for _gee =0;_gee < _debb ;_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );
};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],_fbcdb |^_afab .Data [_eefc ],_egef );_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;
_afgc < _daeee ;_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );_afab .Data [_gccca +_afgc ]=_fbcdb |^_afab .Data [_gccca +_afgc ];};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};};
if _ecca {for _gee =0;_gee < _debb ;_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],_fbcdb |^_afab .Data [_cabfe ],_gcbb );_cabfe +=_afab .BytesPerLine ;
_bbaf +=_daee .BytesPerLine ;};};case PixSrcAndNotDst :if _bga {for _gee =0;_gee < _debb ;_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;
};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],_fbcdb &^_afab .Data [_eefc ],_egef );_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;_afgc < _daeee ;_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );
_afab .Data [_gccca +_afgc ]=_fbcdb &^_afab .Data [_gccca +_afgc ];};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};};if _ecca {for _gee =0;_gee < _debb ;_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );
};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],_fbcdb &^_afab .Data [_cabfe ],_gcbb );_cabfe +=_afab .BytesPerLine ;_bbaf +=_daee .BytesPerLine ;};};case PixNotPixSrcOrDst :if _bga {for _gee =0;_gee < _debb ;_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;
if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],^(_fbcdb |_afab .Data [_eefc ]),_egef );_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;
};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;_afgc < _daeee ;_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );_afab .Data [_gccca +_afgc ]=^(_fbcdb |_afab .Data [_gccca +_afgc ]);
};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};};if _ecca {for _gee =0;_gee < _debb ;_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],^(_fbcdb |_afab .Data [_cabfe ]),_gcbb );
_cabfe +=_afab .BytesPerLine ;_bbaf +=_daee .BytesPerLine ;};};case PixNotPixSrcAndDst :if _bga {for _gee =0;_gee < _debb ;_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );
};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],^(_fbcdb &_afab .Data [_eefc ]),_egef );_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;
_afgc < _daeee ;_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );_afab .Data [_gccca +_afgc ]=^(_fbcdb &_afab .Data [_gccca +_afgc ]);};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};
};if _ecca {for _gee =0;_gee < _debb ;_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],^(_fbcdb &_afab .Data [_cabfe ]),_gcbb );_cabfe +=_afab .BytesPerLine ;
_bbaf +=_daee .BytesPerLine ;};};case PixNotPixSrcXorDst :if _bga {for _gee =0;_gee < _debb ;_gee ++{if _cfdc ==_aaff {_fbcdb =_daee .Data [_gaacd ]<<_ffedf ;if _fbacc {_fbcdb =_adec (_fbcdb ,_daee .Data [_gaacd +1]>>_daed ,_aedf );};}else {_fbcdb =_daee .Data [_gaacd ]>>_daed ;
};_afab .Data [_eefc ]=_adec (_afab .Data [_eefc ],^(_fbcdb ^_afab .Data [_eefc ]),_egef );_eefc +=_afab .BytesPerLine ;_gaacd +=_daee .BytesPerLine ;};};if _becef {for _gee =0;_gee < _debb ;_gee ++{for _afgc =0;_afgc < _daeee ;_afgc ++{_fbcdb =_adec (_daee .Data [_dbc +_afgc ]<<_ffedf ,_daee .Data [_dbc +_afgc +1]>>_daed ,_aedf );
_afab .Data [_gccca +_afgc ]=^(_fbcdb ^_afab .Data [_gccca +_afgc ]);};_gccca +=_afab .BytesPerLine ;_dbc +=_daee .BytesPerLine ;};};if _ecca {for _gee =0;_gee < _debb ;_gee ++{_fbcdb =_daee .Data [_bbaf ]<<_ffedf ;if _eagf {_fbcdb =_adec (_fbcdb ,_daee .Data [_bbaf +1]>>_daed ,_aedf );
};_afab .Data [_cabfe ]=_adec (_afab .Data [_cabfe ],^(_fbcdb ^_afab .Data [_cabfe ]),_gcbb );_cabfe +=_afab .BytesPerLine ;_bbaf +=_daee .BytesPerLine ;};};default:_cca .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_dacc );
return _a .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func (_dfeb *NRGBA64 )ColorModel ()_g .Model {return _g .NRGBA64Model };
func (_fbea *Monochrome )ResolveDecode ()error {if len (_fbea .Decode )!=2{return nil ;};if _fbea .Decode [0]==1&&_fbea .Decode [1]==0{if _dabe :=_fbea .InverseData ();_dabe !=nil {return _dabe ;};_fbea .Decode =nil ;};return nil ;};func (_fdg *Monochrome )Set (x ,y int ,c _g .Color ){_egf :=y *_fdg .BytesPerLine +x >>3;
if _egf > len (_fdg .Data )-1{return ;};_dee :=_fdg .ColorModel ().Convert (c ).(_g .Gray );_fdg .setGray (x ,_dee ,_egf );};var (Gray2Model =_g .ModelFunc (_cgee );Gray4Model =_g .ModelFunc (_aebe );NRGBA16Model =_g .ModelFunc (_abef ););func (_ffcb *NRGBA32 )setRGBA (_ebdd int ,_gdab _g .NRGBA ){_fbgdf :=3*_ebdd ;
_ffcb .Data [_fbgdf ]=_gdab .R ;_ffcb .Data [_fbgdf +1]=_gdab .G ;_ffcb .Data [_fbgdf +2]=_gdab .B ;if _ebdd < len (_ffcb .Alpha ){_ffcb .Alpha [_ebdd ]=_gdab .A ;};};type NRGBA interface{NRGBAAt (_ecdb ,_ecgg int )_g .NRGBA ;SetNRGBA (_efed ,_add int ,_cfed _g .NRGBA );
};func (_ecc *Gray8 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_ecc .Width ,Y :_ecc .Height }};};func (_fcfbc *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_fcfbc .copy ()}};type NRGBA32 struct{ImageBase };type RGBA32 struct{ImageBase };
func init (){_afdcg ()};func (_cbbe *monochromeThresholdConverter )Convert (img _f .Image )(Image ,error ){if _gaf ,_gdfd :=img .(*Monochrome );_gdfd {return _gaf .Copy (),nil ;};_cgegd :=img .Bounds ();_fecc ,_dfeg :=NewImage (_cgegd .Max .X ,_cgegd .Max .Y ,1,1,nil ,nil ,nil );
if _dfeg !=nil {return nil ,_dfeg ;};_fecc .(*Monochrome ).ModelThreshold =_cbbe .Threshold ;for _ecg :=0;_ecg < _cgegd .Max .X ;_ecg ++{for _fdea :=0;_fdea < _cgegd .Max .Y ;_fdea ++{_begb :=img .At (_ecg ,_fdea );_fecc .Set (_ecg ,_fdea ,_begb );};};
return _fecc ,nil ;};var (_cbgd =_gc ();_cef =_bad ();_gfb =_afa (););var _ Image =&RGBA32 {};func (_fbgg *Gray16 )Set (x ,y int ,c _g .Color ){_bece :=(y *_fbgg .BytesPerLine /2+x )*2;if _bece +1>=len (_fbgg .Data ){return ;};_eaeg :=_g .Gray16Model .Convert (c ).(_g .Gray16 );
_fbgg .Data [_bece ],_fbgg .Data [_bece +1]=uint8 (_eaeg .Y >>8),uint8 (_eaeg .Y &0xff);};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;
PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;
PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func (_gcfd *ImageBase )copy ()ImageBase {_fdgg :=*_gcfd ;_fdgg .Data =make ([]byte ,len (_gcfd .Data ));
copy (_fdgg .Data ,_gcfd .Data );return _fdgg ;};func (_fgb *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_cabf :=_efada (uint (factor ));if !IsPowerOf2 (uint (factor )){_cabf ++;};_cde :=make ([]int ,_cabf );for _dfac :=range _cde {_cde [_dfac ]=4;
};_ggbg ,_bcaa :=_gegd (_fgb ,_cde ...);if _bcaa !=nil {return nil ,_bcaa ;};return _ggbg ,nil ;};func _aebe (_fgfc _g .Color )_g .Color {_efad :=_g .GrayModel .Convert (_fgfc ).(_g .Gray );return _fbee (_efad );};func (_aeac *Gray2 )At (x ,y int )_g .Color {_geag ,_ :=_aeac .ColorAt (x ,y );
return _geag };func (_gdagb *ImageBase )setFourBytes (_dddff int ,_badfb uint32 )error {if _dddff +3> len (_gdagb .Data )-1{return _gb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_dddff );
};_gdagb .Data [_dddff ]=byte ((_badfb &0xff000000)>>24);_gdagb .Data [_dddff +1]=byte ((_badfb &0xff0000)>>16);_gdagb .Data [_dddff +2]=byte ((_badfb &0xff00)>>8);_gdagb .Data [_dddff +3]=byte (_badfb &0xff);return nil ;};func _fgee (_ageea nrgba64 ,_cfdbd RGBA ,_bbabe _f .Rectangle ){for _cggd :=0;
_cggd < _bbabe .Max .X ;_cggd ++{for _bfgb :=0;_bfgb < _bbabe .Max .Y ;_bfgb ++{_fbcea :=_ageea .NRGBA64At (_cggd ,_bfgb );_cfdbd .SetRGBA (_cggd ,_bfgb ,_dgecc (_fbcea ));};};};type shift int ;func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func (_gfe *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_gfe .copy ()}};var _ _f .Image =&Gray8 {};func (_eagg *NRGBA64 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA64 (x ,y ,_eagg .Width ,_eagg .Data ,_eagg .Alpha ,_eagg .Decode );};
func _fee (_agefb *_f .NYCbCrA ,_gcbd NRGBA ,_cabd _f .Rectangle ){for _deacg :=0;_deacg < _cabd .Max .X ;_deacg ++{for _dbfeb :=0;_dbfeb < _cabd .Max .Y ;_dbfeb ++{_dgdg :=_agefb .NYCbCrAAt (_deacg ,_dbfeb );_gcbd .SetNRGBA (_deacg ,_dbfeb ,_fbe (_dgdg ));
};};};func _fbee (_eebc _g .Gray )_g .Gray {_eebc .Y >>=4;_eebc .Y |=_eebc .Y <<4;return _eebc };func _gcdc (_aaag ,_bfd *Monochrome ,_gbc []byte ,_afadc int )(_ada error ){var (_edg ,_cae ,_gcc ,_fdff ,_ebc ,_egaf ,_eaa ,_eaf int ;_daa ,_fbd uint32 ;_dcfd ,_fdfd byte ;
_bdc uint16 ;);_fgd :=make ([]byte ,4);_gad :=make ([]byte ,4);for _gcc =0;_gcc < _aaag .Height -1;_gcc ,_fdff =_gcc +2,_fdff +1{_edg =_gcc *_aaag .BytesPerLine ;_cae =_fdff *_bfd .BytesPerLine ;for _ebc ,_egaf =0,0;_ebc < _afadc ;_ebc ,_egaf =_ebc +4,_egaf +1{for _eaa =0;
_eaa < 4;_eaa ++{_eaf =_edg +_ebc +_eaa ;if _eaf <=len (_aaag .Data )-1&&_eaf < _edg +_aaag .BytesPerLine {_fgd [_eaa ]=_aaag .Data [_eaf ];}else {_fgd [_eaa ]=0x00;};_eaf =_edg +_aaag .BytesPerLine +_ebc +_eaa ;if _eaf <=len (_aaag .Data )-1&&_eaf < _edg +(2*_aaag .BytesPerLine ){_gad [_eaa ]=_aaag .Data [_eaf ];
}else {_gad [_eaa ]=0x00;};};_daa =_b .BigEndian .Uint32 (_fgd );_fbd =_b .BigEndian .Uint32 (_gad );_fbd &=_daa ;_fbd &=_fbd <<1;_fbd &=0xaaaaaaaa;_daa =_fbd |(_fbd <<7);_dcfd =byte (_daa >>24);_fdfd =byte ((_daa >>8)&0xff);_eaf =_cae +_egaf ;if _eaf +1==len (_bfd .Data )-1||_eaf +1>=_cae +_bfd .BytesPerLine {_bfd .Data [_eaf ]=_gbc [_dcfd ];
if _ada =_bfd .setByte (_eaf ,_gbc [_dcfd ]);_ada !=nil {return _gb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_eaf );};}else {_bdc =(uint16 (_gbc [_dcfd ])<<8)|uint16 (_gbc [_fdfd ]);if _ada =_bfd .setTwoBytes (_eaf ,_bdc );_ada !=nil {return _gb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_eaf );
};_egaf ++;};};};return nil ;};func _accg (_gdgb *Monochrome ,_deffb ,_ade ,_dff ,_bgfae int ,_eege RasterOperator ){if _deffb < 0{_dff +=_deffb ;_deffb =0;};_dgbg :=_deffb +_dff -_gdgb .Width ;if _dgbg > 0{_dff -=_dgbg ;};if _ade < 0{_bgfae +=_ade ;_ade =0;
};_becd :=_ade +_bgfae -_gdgb .Height ;if _becd > 0{_bgfae -=_becd ;};if _dff <=0||_bgfae <=0{return ;};if (_deffb &7)==0{_befg (_gdgb ,_deffb ,_ade ,_dff ,_bgfae ,_eege );}else {_fddba (_gdgb ,_deffb ,_ade ,_dff ,_bgfae ,_eege );};};func _fdfg (_agg _f .Image )(Image ,error ){if _dbbd ,_ggc :=_agg .(*CMYK32 );
_ggc {return _dbbd .Copy (),nil ;};_bgg :=_agg .Bounds ();_fda ,_fccg :=NewImage (_bgg .Max .X ,_bgg .Max .Y ,8,4,nil ,nil ,nil );if _fccg !=nil {return nil ,_fccg ;};switch _ggbc :=_agg .(type ){case CMYK :_cfg (_ggbc ,_fda .(CMYK ),_bgg );case Gray :_cbe (_ggbc ,_fda .(CMYK ),_bgg );
case NRGBA :_fgg (_ggbc ,_fda .(CMYK ),_bgg );case RGBA :_abea (_ggbc ,_fda .(CMYK ),_bgg );default:_afb (_agg ,_fda ,_bgg );};return _fda ,nil ;};func _edfa (_bceg _g .NRGBA )_g .CMYK {_cag ,_fga ,_dea ,_ :=_bceg .RGBA ();_abgb ,_gcfe ,_bgcb ,_ecf :=_g .RGBToCMYK (uint8 (_cag >>8),uint8 (_fga >>8),uint8 (_dea >>8));
return _g .CMYK {C :_abgb ,M :_gcfe ,Y :_bgcb ,K :_ecf };};func _cebd (_bfef _g .NRGBA64 )_g .NRGBA {return _g .NRGBA {R :uint8 (_bfef .R >>8),G :uint8 (_bfef .G >>8),B :uint8 (_bfef .B >>8),A :uint8 (_bfef .A >>8)};};type Gray8 struct{ImageBase };func _bgd (_dcc _g .Gray ,_bcbb monochromeModel )_g .Gray {if _dcc .Y > uint8 (_bcbb ){return _g .Gray {Y :_af .MaxUint8 };
};return _g .Gray {};};var _ _f .Image =&Gray2 {};func _gfac (_abbc _f .Image )(Image ,error ){if _ebdc ,_dffe :=_abbc .(*NRGBA32 );_dffe {return _ebdc .Copy (),nil ;};_caa ,_bbag ,_bccf :=_fdfe (_abbc ,1);_febb ,_faggf :=NewImage (_caa .Max .X ,_caa .Max .Y ,8,3,nil ,_bccf ,nil );
if _faggf !=nil {return nil ,_faggf ;};_agbec (_abbc ,_febb ,_caa );if len (_bccf )!=0&&!_bbag {if _bfac :=_edb (_bccf ,_febb );_bfac !=nil {return nil ,_bfac ;};};return _febb ,nil ;};var _ Image =&Gray16 {};func GrayHistogram (g Gray )(_agea [256]int ){switch _dgdd :=g .(type ){case Histogramer :return _dgdd .Histogram ();
case _f .Image :_agbg :=_dgdd .Bounds ();for _deba :=0;_deba < _agbg .Max .X ;_deba ++{for _egaff :=0;_egaff < _agbg .Max .Y ;_egaff ++{_agea [g .GrayAt (_deba ,_egaff ).Y ]++;};};return _agea ;default:return [256]int {};};};func (_cbec *ImageBase )setEightPartlyBytes (_bab ,_acag int ,_gef uint64 )(_fbdd error ){var (_afdd byte ;
_agfaa int ;);for _bbab :=1;_bbab <=_acag ;_bbab ++{_agfaa =64-_bbab *8;_afdd =byte (_gef >>uint (_agfaa )&0xff);if _fbdd =_cbec .setByte (_bab +_bbab -1,_afdd );_fbdd !=nil {return _fbdd ;};};_gbcc :=_cbec .BytesPerLine *8-_cbec .Width ;if _gbcc ==0{return nil ;
};_agfaa -=8;_afdd =byte (_gef >>uint (_agfaa )&0xff)<<uint (_gbcc );if _fbdd =_cbec .setByte (_bab +_acag ,_afdd );_fbdd !=nil {return _fbdd ;};return nil ;};func (_effc *RGBA32 )Base ()*ImageBase {return &_effc .ImageBase };func (_bbdd *RGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };
func (_affb *ImageBase )getByte (_cbgb int )(byte ,error ){if _cbgb > len (_affb .Data )-1||_cbgb < 0{return 0,_gb .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_cbgb );
};return _affb .Data [_cbgb ],nil ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_febdf :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _febdf ==width *colorComponents *bitsPerComponent /8{return data ,nil ;
};_fgdf :=width *colorComponents *bitsPerComponent ;_fbba :=_febdf *8;_cebe :=8-(_fbba -_fgdf );_bdaa :=_fb .NewReader (data );_bfaa :=_febdf -1;_cegf :=make ([]byte ,_bfaa );_caf :=make ([]byte ,height *_febdf );_cfgb :=_fb .NewWriterMSB (_caf );var _adf uint64 ;
var _fccdb error ;for _gfdf :=0;_gfdf < height ;_gfdf ++{_ ,_fccdb =_bdaa .Read (_cegf );if _fccdb !=nil {return nil ,_fccdb ;};_ ,_fccdb =_cfgb .Write (_cegf );if _fccdb !=nil {return nil ,_fccdb ;};_adf ,_fccdb =_bdaa .ReadBits (byte (_cebe ));if _fccdb !=nil {return nil ,_fccdb ;
};_ ,_fccdb =_cfgb .WriteBits (_adf ,_cebe );if _fccdb !=nil {return nil ,_fccdb ;};_cfgb .FinishByte ();};return _caf ,nil ;};func (_dfed *Gray8 )Set (x ,y int ,c _g .Color ){_eade :=y *_dfed .BytesPerLine +x ;if _eade > len (_dfed .Data )-1{return ;};
_ccfd :=_g .GrayModel .Convert (c );_dfed .Data [_eade ]=_ccfd .(_g .Gray ).Y ;};func _dd (_feb ,_gg *Monochrome )(_cgd error ){_bg :=_gg .BytesPerLine ;_da :=_feb .BytesPerLine ;_bd :=_gg .BytesPerLine *4-_feb .BytesPerLine ;var (_fbf ,_bf byte ;_bgf uint32 ;
_ega ,_ce ,_gdg ,_ae ,_cgge ,_bc ,_de int ;);for _gdg =0;_gdg < _gg .Height ;_gdg ++{_ega =_gdg *_bg ;_ce =4*_gdg *_da ;for _ae =0;_ae < _bg ;_ae ++{_fbf =_gg .Data [_ega +_ae ];_bgf =_cef [_fbf ];_bc =_ce +_ae *4;if _bd !=0&&(_ae +1)*4> _feb .BytesPerLine {for _cgge =_bd ;
_cgge > 0;_cgge --{_bf =byte ((_bgf >>uint (_cgge *8))&0xff);_de =_bc +(_bd -_cgge );if _cgd =_feb .setByte (_de ,_bf );_cgd !=nil {return _cgd ;};};}else if _cgd =_feb .setFourBytes (_bc ,_bgf );_cgd !=nil {return _cgd ;};if _cgd =_feb .setFourBytes (_ce +_ae *4,_cef [_gg .Data [_ega +_ae ]]);
_cgd !=nil {return _cgd ;};};for _cgge =1;_cgge < 4;_cgge ++{for _ae =0;_ae < _da ;_ae ++{if _cgd =_feb .setByte (_ce +_cgge *_da +_ae ,_feb .Data [_ce +_ae ]);_cgd !=nil {return _cgd ;};};};};return nil ;};var _ _f .Image =&Gray4 {};func (_eeeb *Gray2 )Validate ()error {if len (_eeeb .Data )!=_eeeb .Height *_eeeb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _adec (_abda ,_dedb ,_ccfc byte )byte {return (_abda &^(_ccfc ))|(_dedb &_ccfc )};func (_bdd *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_bdd .copy ()}};type Gray16 struct{ImageBase };func _afde ()(_cbad []byte ){_cbad =make ([]byte ,256);
for _dgec :=0;_dgec < 256;_dgec ++{_gacd :=byte (_dgec );_cbad [_gacd ]=(_gacd &0x01)|((_gacd &0x04)>>1)|((_gacd &0x10)>>2)|((_gacd &0x40)>>3)|((_gacd &0x02)<<3)|((_gacd &0x08)<<2)|((_gacd &0x20)<<1)|(_gacd &0x80);};return _cbad ;};var _ Image =&NRGBA64 {};
var _ _f .Image =&Monochrome {};func _cddbf (_egfb NRGBA ,_babde RGBA ,_faegc _f .Rectangle ){for _ccbb :=0;_ccbb < _faegc .Max .X ;_ccbb ++{for _dbgga :=0;_dbgga < _faegc .Max .Y ;_dbgga ++{_bafb :=_egfb .NRGBAAt (_ccbb ,_dbgga );_babde .SetRGBA (_ccbb ,_dbgga ,_aade (_bafb ));
};};};func _eadg (_agdfb CMYK ,_ebbg RGBA ,_dgcg _f .Rectangle ){for _cecd :=0;_cecd < _dgcg .Max .X ;_cecd ++{for _eadgd :=0;_eadgd < _dgcg .Max .Y ;_eadgd ++{_afdg :=_agdfb .CMYKAt (_cecd ,_eadgd );_ebbg .SetRGBA (_cecd ,_eadgd ,_abga (_afdg ));};};};
func (_bge *Gray16 )At (x ,y int )_g .Color {_agge ,_ :=_bge .ColorAt (x ,y );return _agge };func (_aged *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_aged .ImageBase .copy (),ModelThreshold :_aged .ModelThreshold };};func (_decab *NRGBA64 )Base ()*ImageBase {return &_decab .ImageBase };
type Image interface{_cc .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_abcfb ,_fcfba int )(_g .Color ,error );Validate ()error ;};func (_ccee *NRGBA16 )Base ()*ImageBase {return &_ccee .ImageBase };type Histogramer interface{Histogram ()[256]int ;
};func (_ebca *Monochrome )clearBit (_fcdc ,_cdgf int ){_ebca .Data [_fcdc ]&=^(0x80>>uint (_cdgf &7))};var _ NRGBA =&NRGBA16 {};func _gdge (_egd ,_dfe int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_egd ,_dfe ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};func _deab (_gefc _f .Image )(Image ,error ){if _ecfe ,_ggga :=_gefc .(*NRGBA16 );_ggga {return _ecfe .Copy (),nil ;};_cgda :=_gefc .Bounds ();_gfca ,_dfgc :=NewImage (_cgda .Max .X ,_cgda .Max .Y ,4,3,nil ,nil ,nil );if _dfgc !=nil {return nil ,_dfgc ;
};_agbec (_gefc ,_gfca ,_cgda );return _gfca ,nil ;};func _aaeca (_cggae _f .Image ,_cbac uint8 )*_f .Gray {_gdcgf :=_cggae .Bounds ();_affe :=_f .NewGray (_gdcgf );var (_fagab _g .Color ;_ggcb _g .Gray ;);for _aaafc :=0;_aaafc < _gdcgf .Max .X ;_aaafc ++{for _cbcd :=0;
_cbcd < _gdcgf .Max .Y ;_cbcd ++{_fagab =_cggae .At (_aaafc ,_cbcd );_affe .Set (_aaafc ,_cbcd ,_fagab );_ggcb =_affe .GrayAt (_aaafc ,_cbcd );_affe .SetGray (_aaafc ,_cbcd ,_g .Gray {Y :_cffc (_ggcb .Y ,_cbac )});};};return _affe ;};func _ddfg (_abfga *_f .Gray ,_bededb uint8 )*_f .Gray {_cbca :=_abfga .Bounds ();
_efae :=_f .NewGray (_cbca );for _dcaa :=0;_dcaa < _cbca .Dx ();_dcaa ++{for _cfdgb :=0;_cfdgb < _cbca .Dy ();_cfdgb ++{_dfdbd :=_abfga .GrayAt (_dcaa ,_cfdgb );_efae .SetGray (_dcaa ,_cfdgb ,_g .Gray {Y :_cffc (_dfdbd .Y ,_bededb )});};};return _efae ;
};func (_efd *CMYK32 )Set (x ,y int ,c _g .Color ){_agab :=4*(y *_efd .Width +x );if _agab +3>=len (_efd .Data ){return ;};_aag :=_g .CMYKModel .Convert (c ).(_g .CMYK );_efd .Data [_agab ]=_aag .C ;_efd .Data [_agab +1]=_aag .M ;_efd .Data [_agab +2]=_aag .Y ;
_efd .Data [_agab +3]=_aag .K ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_dbgd :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _gdadf Image ;
switch colorComponents {case 1:switch bitsPerComponent {case 1:_gdadf =&Monochrome {ImageBase :_dbgd ,ModelThreshold :0x0f};case 2:_gdadf =&Gray2 {ImageBase :_dbgd };case 4:_gdadf =&Gray4 {ImageBase :_dbgd };case 8:_gdadf =&Gray8 {ImageBase :_dbgd };case 16:_gdadf =&Gray16 {ImageBase :_dbgd };
};case 3:switch bitsPerComponent {case 4:_gdadf =&NRGBA16 {ImageBase :_dbgd };case 8:_gdadf =&NRGBA32 {ImageBase :_dbgd };case 16:_gdadf =&NRGBA64 {ImageBase :_dbgd };};case 4:_gdadf =&CMYK32 {ImageBase :_dbgd };};if _gdadf ==nil {return nil ,ErrInvalidImage ;
};return _gdadf ,nil ;};var (MonochromeConverter =ConverterFunc (_ffd );Gray2Converter =ConverterFunc (_abcc );Gray4Converter =ConverterFunc (_ecgf );GrayConverter =ConverterFunc (_eabg );Gray16Converter =ConverterFunc (_dedf );NRGBA16Converter =ConverterFunc (_deab );
NRGBAConverter =ConverterFunc (_gfac );NRGBA64Converter =ConverterFunc (_fge );RGBAConverter =ConverterFunc (_egg );CMYKConverter =ConverterFunc (_fdfg ););func (_gdcg *Gray4 )Set (x ,y int ,c _g .Color ){if x >=_gdcg .Width ||y >=_gdcg .Height {return ;
};_cdc :=Gray4Model .Convert (c ).(_g .Gray );_gdcg .setGray (x ,y ,_cdc );};func _abg (_cfa int )[]uint {var _dba []uint ;_ddab :=_cfa ;_eba :=_ddab /8;if _eba !=0{for _cbgc :=0;_cbgc < _eba ;_cbgc ++{_dba =append (_dba ,8);};_bbad :=_ddab %8;_ddab =0;
if _bbad !=0{_ddab =_bbad ;};};_aad :=_ddab /4;if _aad !=0{for _bce :=0;_bce < _aad ;_bce ++{_dba =append (_dba ,4);};_fag :=_ddab %4;_ddab =0;if _fag !=0{_ddab =_fag ;};};_fad :=_ddab /2;if _fad !=0{for _badd :=0;_badd < _fad ;_badd ++{_dba =append (_dba ,2);
};};return _dba ;};func (_eebg *NRGBA16 )SetNRGBA (x ,y int ,c _g .NRGBA ){_cdgd :=y *_eebg .BytesPerLine +x *3/2;if _cdgd +1>=len (_eebg .Data ){return ;};c =_edfe (c );_eebg .setNRGBA (x ,y ,_cdgd ,c );};func (_gdgdg *Gray4 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_gdgdg .Width ,Y :_gdgdg .Height }};
};func _afdcg (){for _becc :=0;_becc < 256;_becc ++{_dfcc [_becc ]=uint8 (_becc &0x1)+(uint8 (_becc >>1)&0x1)+(uint8 (_becc >>2)&0x1)+(uint8 (_becc >>3)&0x1)+(uint8 (_becc >>4)&0x1)+(uint8 (_becc >>5)&0x1)+(uint8 (_becc >>6)&0x1)+(uint8 (_becc >>7)&0x1);
};};func _cgee (_cdef _g .Color )_g .Color {_gfbb :=_g .GrayModel .Convert (_cdef ).(_g .Gray );return _cgga (_gfbb );};type NRGBA16 struct{ImageBase };func (_dag *Gray16 )ColorModel ()_g .Model {return _g .Gray16Model };func _ffda (_gcge RGBA ,_baeb Gray ,_fbfb _f .Rectangle ){for _gdce :=0;
_gdce < _fbfb .Max .X ;_gdce ++{for _cgb :=0;_cgb < _fbfb .Max .Y ;_cgb ++{_deff :=_fbdb (_gcge .RGBAAt (_gdce ,_cgb ));_baeb .SetGray (_gdce ,_cgb ,_deff );};};};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_gced :=y *bytesPerLine +x ;
if _gced >=len (data ){return _g .Gray {},_gb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fbac :=data [_gced ];if len (decode )==2{_fbac =uint8 (uint32 (LinearInterpolate (float64 (_fbac ),0,255,decode [0],decode [1]))&0xff);};return _g .Gray {Y :_fbac },nil ;};func (_eedb colorConverter )Convert (src _f .Image )(Image ,error ){return _eedb ._aae (src )};
func (_fdd *Monochrome )setGrayBit (_fae ,_dbba int ){_fdd .Data [_fae ]|=0x80>>uint (_dbba &7)};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_gb .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _fdfe (_acadc _f .Image ,_gcccd int )(_f .Rectangle ,bool ,[]byte ){_daede :=_acadc .Bounds ();var (_dgbc bool ;_ebeb []byte ;);switch _dccd :=_acadc .(type ){case SMasker :_dgbc =_dccd .HasAlpha ();case NRGBA ,RGBA ,*_f .RGBA64 ,nrgba64 ,*_f .NYCbCrA :_ebeb =make ([]byte ,_daede .Max .X *_daede .Max .Y *_gcccd );
case *_f .Paletted :if !_dccd .Opaque (){_ebeb =make ([]byte ,_daede .Max .X *_daede .Max .Y *_gcccd );};};return _daede ,_dgbc ,_ebeb ;};func (_ead *CMYK32 )Validate ()error {if len (_ead .Data )!=4*_ead .Width *_ead .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func ImgToBinary (i _f .Image ,threshold uint8 )*_f .Gray {switch _gadac :=i .(type ){case *_f .Gray :if _ddfab (_gadac ){return _gadac ;};return _ddfg (_gadac ,threshold );case *_f .Gray16 :return _cegc (_gadac ,threshold );default:return _aaeca (_gadac ,threshold );
};};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_bdacc :=y *bytesPerLine +x *3/2;if _bdacc +1>=len (data ){return _g .NRGBA {},_ceeg (x ,y );};const (_affbd =0xf;_cfdg =uint8 (0xff););_dgfd :=_cfdg ;
if alpha !=nil {_acad :=y *BytesPerLine (width ,4,1);if _acad < len (alpha ){if x %2==0{_dgfd =(alpha [_acad ]>>uint (4))&_affbd ;}else {_dgfd =alpha [_acad ]&_affbd ;};_dgfd |=_dgfd <<4;};};var _gdbfc ,_egaee ,_ebfc uint8 ;if x *3%2==0{_gdbfc =(data [_bdacc ]>>uint (4))&_affbd ;
_egaee =data [_bdacc ]&_affbd ;_ebfc =(data [_bdacc +1]>>uint (4))&_affbd ;}else {_gdbfc =data [_bdacc ]&_affbd ;_egaee =(data [_bdacc +1]>>uint (4))&_affbd ;_ebfc =data [_bdacc +1]&_affbd ;};if len (decode )==6{_gdbfc =uint8 (uint32 (LinearInterpolate (float64 (_gdbfc ),0,15,decode [0],decode [1]))&0xf);
_egaee =uint8 (uint32 (LinearInterpolate (float64 (_egaee ),0,15,decode [2],decode [3]))&0xf);_ebfc =uint8 (uint32 (LinearInterpolate (float64 (_ebfc ),0,15,decode [4],decode [5]))&0xf);};return _g .NRGBA {R :(_gdbfc <<4)|(_gdbfc &0xf),G :(_egaee <<4)|(_egaee &0xf),B :(_ebfc <<4)|(_ebfc &0xf),A :_dgfd },nil ;
};func (_eabd *Gray8 )At (x ,y int )_g .Color {_ddda ,_ :=_eabd .ColorAt (x ,y );return _ddda };func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray16 ,error ){_bcf :=(y *bytesPerLine /2+x )*2;if _bcf +1>=len (data ){return _g .Gray16 {},_gb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_efef :=uint16 (data [_bcf ])<<8|uint16 (data [_bcf +1]);if len (decode )==2{_efef =uint16 (uint64 (LinearInterpolate (float64 (_efef ),0,65535,decode [0],decode [1])));};return _g .Gray16 {Y :_efef },nil ;};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_ccg :=y *bytesPerLine +x >>3;
if _ccg >=len (data ){return _g .Gray {},_gb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gce :=data [_ccg ]>>uint (7-(x &7))&1;if len (decode )==2{_gce =uint8 (LinearInterpolate (float64 (_gce ),0.0,1.0,decode [0],decode [1]))&1;};return _g .Gray {Y :_gce *255},nil ;};func (_bgfa *Gray8 )Base ()*ImageBase {return &_bgfa .ImageBase };func (_cdgdd *NRGBA64 )NRGBA64At (x ,y int )_g .NRGBA64 {_cefc ,_ :=ColorAtNRGBA64 (x ,y ,_cdgdd .Width ,_cdgdd .Data ,_cdgdd .Alpha ,_cdgdd .Decode );
return _cefc ;};func (_aaba *NRGBA16 )NRGBAAt (x ,y int )_g .NRGBA {_eeca ,_ :=ColorAtNRGBA16 (x ,y ,_aaba .Width ,_aaba .BytesPerLine ,_aaba .Data ,_aaba .Alpha ,_aaba .Decode );return _eeca ;};func _dedf (_gaef _f .Image )(Image ,error ){if _gdbee ,_eega :=_gaef .(*Gray16 );
_eega {return _gdbee .Copy (),nil ;};_gfggf :=_gaef .Bounds ();_gfggfe ,_gcaea :=NewImage (_gfggf .Max .X ,_gfggf .Max .Y ,16,1,nil ,nil ,nil );if _gcaea !=nil {return nil ,_gcaea ;};_acb (_gaef ,_gfggfe ,_gfggf );return _gfggfe ,nil ;};func (_bcgd *Monochrome )Validate ()error {if len (_bcgd .Data )!=_bcgd .Height *_bcgd .BytesPerLine {return ErrInvalidImage ;
};return nil ;};var _ Gray =&Gray16 {};func _gc ()(_aeb [256]uint16 ){for _geg :=0;_geg < 256;_geg ++{if _geg &0x01!=0{_aeb [_geg ]|=0x3;};if _geg &0x02!=0{_aeb [_geg ]|=0xc;};if _geg &0x04!=0{_aeb [_geg ]|=0x30;};if _geg &0x08!=0{_aeb [_geg ]|=0xc0;};
if _geg &0x10!=0{_aeb [_geg ]|=0x300;};if _geg &0x20!=0{_aeb [_geg ]|=0xc00;};if _geg &0x40!=0{_aeb [_geg ]|=0x3000;};if _geg &0x80!=0{_aeb [_geg ]|=0xc000;};};return _aeb ;};func _agbec (_fgfd _f .Image ,_egcd Image ,_gcfa _f .Rectangle ){if _dfge ,_degb :=_fgfd .(SMasker );
_degb &&_dfge .HasAlpha (){_egcd .(SMasker ).MakeAlpha ();};switch _ceac :=_fgfd .(type ){case Gray :_fgde (_ceac ,_egcd .(NRGBA ),_gcfa );case NRGBA :_adfc (_ceac ,_egcd .(NRGBA ),_gcfa );case *_f .NYCbCrA :_fee (_ceac ,_egcd .(NRGBA ),_gcfa );case CMYK :_cbea (_ceac ,_egcd .(NRGBA ),_gcfa );
case RGBA :_dgcdc (_ceac ,_egcd .(NRGBA ),_gcfa );case nrgba64 :_gecb (_ceac ,_egcd .(NRGBA ),_gcfa );default:_afb (_fgfd ,_egcd ,_gcfa );};};func (_ggd *NRGBA32 )At (x ,y int )_g .Color {_ebgf ,_ :=_ggd .ColorAt (x ,y );return _ebgf };var _ NRGBA =&NRGBA32 {};
func (_gaac *CMYK32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_gaac .Width ,Y :_gaac .Height }};};func _fc (_dbb *Monochrome ,_afe int ,_fg []uint )(*Monochrome ,error ){_cg :=_afe *_dbb .Width ;_cac :=_afe *_dbb .Height ;_ed :=_gdge (_cg ,_cac );
for _eb ,_dg :=range _fg {var _ad error ;switch _dg {case 2:_ad =_afc (_ed ,_dbb );case 4:_ad =_dd (_ed ,_dbb );case 8:_ad =_age (_ed ,_dbb );};if _ad !=nil {return nil ,_ad ;};if _eb !=len (_fg )-1{_dbb =_ed .copy ();};};return _ed ,nil ;};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA64 ,error ){_efg :=(y *width +x )*2;
_aedgc :=_efg *3;if _aedgc +5>=len (data ){return _g .NRGBA64 {},_gb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _cfae =0xffff;_abdba :=uint16 (_cfae );if alpha !=nil &&len (alpha )> _efg +1{_abdba =uint16 (alpha [_efg ])<<8|uint16 (alpha [_efg +1]);};_dbde :=uint16 (data [_aedgc ])<<8|uint16 (data [_aedgc +1]);_beded :=uint16 (data [_aedgc +2])<<8|uint16 (data [_aedgc +3]);
_cgc :=uint16 (data [_aedgc +4])<<8|uint16 (data [_aedgc +5]);if len (decode )==6{_dbde =uint16 (uint64 (LinearInterpolate (float64 (_dbde ),0,65535,decode [0],decode [1]))&_cfae );_beded =uint16 (uint64 (LinearInterpolate (float64 (_beded ),0,65535,decode [2],decode [3]))&_cfae );
_cgc =uint16 (uint64 (LinearInterpolate (float64 (_cgc ),0,65535,decode [4],decode [5]))&_cfae );};return _g .NRGBA64 {R :_dbde ,G :_beded ,B :_cgc ,A :_abdba },nil ;};func _abea (_eacff RGBA ,_gaaa CMYK ,_edc _f .Rectangle ){for _gccf :=0;_gccf < _edc .Max .X ;
_gccf ++{for _bee :=0;_bee < _edc .Max .Y ;_bee ++{_fccd :=_eacff .RGBAAt (_gccf ,_bee );_gaaa .SetCMYK (_gccf ,_bee ,_fff (_fccd ));};};};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _af .Abs (xmax -xmin )< 0.000001{return ymin ;
};_ccad :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _ccad ;};func (_gdad *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_a .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_cea :=_gdge (width ,height );_dfegd :=make ([]int ,height );_dgea :=make ([]int ,width );_cbbec :=float64 (_gdad .Width )/float64 (width );_ebef :=float64 (_gdad .Height )/float64 (height );for _ddfdg :=0;_ddfdg < height ;_ddfdg ++{_dfegd [_ddfdg ]=int (_af .Min (_ebef *float64 (_ddfdg )+0.5,float64 (_gdad .Height -1)));
};for _bfb :=0;_bfb < width ;_bfb ++{_dgea [_bfb ]=int (_af .Min (_cbbec *float64 (_bfb )+0.5,float64 (_gdad .Width -1)));};_fbfeg :=-1;_dfbc :=byte (0);for _gec :=0;_gec < height ;_gec ++{_ccfg :=_dfegd [_gec ]*_gdad .BytesPerLine ;_ccd :=_gec *_cea .BytesPerLine ;
for _gfa :=0;_gfa < width ;_gfa ++{_ebab :=_dgea [_gfa ];if _ebab !=_fbfeg {_dfbc =_gdad .getBit (_ccfg ,_ebab );if _dfbc !=0{_cea .setBit (_ccd ,_gfa );};_fbfeg =_ebab ;}else {if _dfbc !=0{_cea .setBit (_ccd ,_gfa );};};};};return _cea ,nil ;};func (_ddg *ImageBase )setEightBytes (_cgab int ,_ddee uint64 )error {_agfa :=_ddg .BytesPerLine -(_cgab %_ddg .BytesPerLine );
if _ddg .BytesPerLine !=_ddg .Width >>3{_agfa --;};if _agfa >=8{return _ddg .setEightFullBytes (_cgab ,_ddee );};return _ddg .setEightPartlyBytes (_cgab ,_agfa ,_ddee );};func _cffc (_gedbc ,_dccf uint8 )uint8 {if _gedbc < _dccf {return 255;};return 0;
};func _beab (_cfcg _f .Image ,_fcded Image ,_cgfd _f .Rectangle ){if _fage ,_gcaa :=_cfcg .(SMasker );_gcaa &&_fage .HasAlpha (){_fcded .(SMasker ).MakeAlpha ();};_afb (_cfcg ,_fcded ,_cgfd );};func _afg (_defa ,_daaa Gray ,_affc _f .Rectangle ){for _dde :=0;
_dde < _affc .Max .X ;_dde ++{for _ccgc :=0;_ccgc < _affc .Max .Y ;_ccgc ++{_daaa .SetGray (_dde ,_ccgc ,_defa .GrayAt (_dde ,_ccgc ));};};};func _cgga (_fea _g .Gray )_g .Gray {_abd :=_fea .Y >>6;_abd |=_abd <<2;_fea .Y =_abd |_abd <<4;return _fea ;};
func _fggf (_bfc _g .CMYK )_g .NRGBA {_afbd ,_cacc ,_cfab :=_g .CMYKToRGB (_bfc .C ,_bfc .M ,_bfc .Y ,_bfc .K );return _g .NRGBA {R :_afbd ,G :_cacc ,B :_cfab ,A :0xff};};func (_abec *Gray2 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray2BPC (x ,y ,_abec .BytesPerLine ,_abec .Data ,_abec .Decode );
};func (_beaf *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_beaf .copy ()}};type RGBA interface{RGBAAt (_agcb ,_dded int )_g .RGBA ;SetRGBA (_dcgg ,_cafb int ,_dbcc _g .RGBA );};func InDelta (expected ,current ,delta float64 )bool {_degf :=expected -current ;
if _degf <=-delta ||_degf >=delta {return false ;};return true ;};func (_efca *RGBA32 )Validate ()error {if len (_efca .Data )!=3*_efca .Width *_efca .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _ebcb (_aacd _g .NYCbCrA )_g .RGBA {_agb ,_gccc ,_eeb ,_ced :=_fbe (_aacd ).RGBA ();return _g .RGBA {R :uint8 (_agb >>8),G :uint8 (_gccc >>8),B :uint8 (_eeb >>8),A :uint8 (_ced >>8)};};func (_agbc *ImageBase )setByte (_bceb int ,_bffc byte )error {if _bceb > len (_agbc .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_agbc .Data [_bceb ]=_bffc ;return nil ;};type monochromeModel uint8 ;func _afb (_ccac _f .Image ,_dgf Image ,_cfb _f .Rectangle ){for _afcc :=0;_afcc < _cfb .Max .X ;_afcc ++{for _bgfb :=0;_bgfb < _cfb .Max .Y ;_bgfb ++{_cce :=_ccac .At (_afcc ,_bgfb );
_dgf .Set (_afcc ,_bgfb ,_cce );};};};const (_aaff shift =iota ;_cfc ;);func (_agbe *Monochrome )ColorModel ()_g .Model {return MonochromeModel (_agbe .ModelThreshold )};func _aade (_edaf _g .NRGBA )_g .RGBA {_fec ,_ffeg ,_dbf ,_aaae :=_edaf .RGBA ();return _g .RGBA {R :uint8 (_fec >>8),G :uint8 (_ffeg >>8),B :uint8 (_dbf >>8),A :uint8 (_aaae >>8)};
};func _fbe (_bda _g .NYCbCrA )_g .NRGBA {_geb :=int32 (_bda .Y )*0x10101;_gdf :=int32 (_bda .Cb )-128;_bbda :=int32 (_bda .Cr )-128;_ddfd :=_geb +91881*_bbda ;if uint32 (_ddfd )&0xff000000==0{_ddfd >>=8;}else {_ddfd =^(_ddfd >>31)&0xffff;};_ccfb :=_geb -22554*_gdf -46802*_bbda ;
if uint32 (_ccfb )&0xff000000==0{_ccfb >>=8;}else {_ccfb =^(_ccfb >>31)&0xffff;};_ebfb :=_geb +116130*_gdf ;if uint32 (_ebfb )&0xff000000==0{_ebfb >>=8;}else {_ebfb =^(_ebfb >>31)&0xffff;};return _g .NRGBA {R :uint8 (_ddfd >>8),G :uint8 (_ccfb >>8),B :uint8 (_ebfb >>8),A :_bda .A };
};func (_cfbf *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_cfbf .copy ()}};var _ _f .Image =&RGBA32 {};func _bdcc (_ffc int ,_cgaf int )int {if _ffc < _cgaf {return _ffc ;};return _cgaf ;};func (_gfba *Monochrome )InverseData ()error {return _gfba .RasterOperation (0,0,_gfba .Width ,_gfba .Height ,PixNotDst ,nil ,0,0);
};func (_dbag *Gray16 )Histogram ()(_cddb [256]int ){for _fcac :=0;_fcac < _dbag .Width ;_fcac ++{for _eccf :=0;_eccf < _dbag .Height ;_eccf ++{_cddb [_dbag .GrayAt (_fcac ,_eccf ).Y ]++;};};return _cddb ;};func _efada (_bebd uint )uint {var _ecge uint ;
for _bebd !=0{_bebd >>=1;_ecge ++;};return _ecge -1;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func (_agfe *Monochrome )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_agfe .Width ,Y :_agfe .Height }};};func (_ggcg *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _bfda bool ;
_cedg :=scale ;if scale < 1{_cedg =1/scale ;_bfda =true ;};_cdeb :=NextPowerOf2 (uint (_cedg ));if InDelta (float64 (_cdeb ),_cedg ,0.001){if _bfda {return _ggcg .ReduceBinary (_cedg );};return _ggcg .ExpandBinary (int (_cdeb ));};_dgff :=int (_af .RoundToEven (float64 (_ggcg .Width )*scale ));
_affg :=int (_af .RoundToEven (float64 (_ggcg .Height )*scale ));return _ggcg .ScaleLow (_dgff ,_affg );};func _dgcdc (_ageda RGBA ,_ddgb NRGBA ,_cefge _f .Rectangle ){for _aeba :=0;_aeba < _cefge .Max .X ;_aeba ++{for _gcaeb :=0;_gcaeb < _cefge .Max .Y ;
_gcaeb ++{_fagc :=_ageda .RGBAAt (_aeba ,_gcaeb );_ddgb .SetNRGBA (_aeba ,_gcaeb ,_bdgf (_fagc ));};};};func (_aabg *NRGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };func (_dced *Gray8 )SetGray (x ,y int ,g _g .Gray ){_ggfc :=y *_dced .BytesPerLine +x ;
if _ggfc > len (_dced .Data )-1{return ;};_dced .Data [_ggfc ]=g .Y ;};func _ddfab (_badb *_f .Gray )bool {for _aggee :=0;_aggee < len (_badb .Pix );_aggee ++{if !_ddae (_badb .Pix [_aggee ]){return false ;};};return true ;};func _ggbd (_abcf _g .Gray )_g .CMYK {return _g .CMYK {K :0xff-_abcf .Y }};
func (_ded *Gray4 )At (x ,y int )_g .Color {_afcf ,_ :=_ded .ColorAt (x ,y );return _afcf };func (_adecb *NRGBA16 )Set (x ,y int ,c _g .Color ){_abdg :=y *_adecb .BytesPerLine +x *3/2;if _abdg +1>=len (_adecb .Data ){return ;};_agfaac :=NRGBA16Model .Convert (c ).(_g .NRGBA );
_adecb .setNRGBA (x ,y ,_abdg ,_agfaac );};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};var _ _f .Image =&NRGBA32 {};func (_gbcd *RGBA32 )SetRGBA (x ,y int ,c _g .RGBA ){_abdab :=y *_gbcd .Width +x ;
_aebgf :=3*_abdab ;if _aebgf +2>=len (_gbcd .Data ){return ;};_gbcd .setRGBA (_abdab ,c );};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_gdda :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_gdda .Data =make ([]byte ,height *_gdda .BytesPerLine );};return _gdda ;};func (_aafc *RGBA32 )RGBAAt (x ,y int )_g .RGBA {_eacg ,_ :=ColorAtRGBA32 (x ,y ,_aafc .Width ,_aafc .Data ,_aafc .Alpha ,_aafc .Decode );return _eacg ;};func _fddba (_aedg *Monochrome ,_cdgfc ,_ccfab int ,_aeca ,_dcbd int ,_dfef RasterOperator ){var (_deca bool ;
_gbdd bool ;_aacgg int ;_fbcf int ;_egfd int ;_gffg int ;_abee bool ;_eaga byte ;);_cfeb :=8-(_cdgfc &7);_egac :=_cdgc [_cfeb ];_afgd :=_aedg .BytesPerLine *_ccfab +(_cdgfc >>3);if _aeca < _cfeb {_deca =true ;_egac &=_baff [8-_cfeb +_aeca ];};if !_deca {_aacgg =(_aeca -_cfeb )>>3;
if _aacgg !=0{_gbdd =true ;_fbcf =_afgd +1;};};_egfd =(_cdgfc +_aeca )&7;if !(_deca ||_egfd ==0){_abee =true ;_eaga =_baff [_egfd ];_gffg =_afgd +1+_aacgg ;};var _bfgf ,_gcceb int ;switch _dfef {case PixClr :for _bfgf =0;_bfgf < _dcbd ;_bfgf ++{_aedg .Data [_afgd ]=_adec (_aedg .Data [_afgd ],0x0,_egac );
_afgd +=_aedg .BytesPerLine ;};if _gbdd {for _bfgf =0;_bfgf < _dcbd ;_bfgf ++{for _gcceb =0;_gcceb < _aacgg ;_gcceb ++{_aedg .Data [_fbcf +_gcceb ]=0x0;};_fbcf +=_aedg .BytesPerLine ;};};if _abee {for _bfgf =0;_bfgf < _dcbd ;_bfgf ++{_aedg .Data [_gffg ]=_adec (_aedg .Data [_gffg ],0x0,_eaga );
_gffg +=_aedg .BytesPerLine ;};};case PixSet :for _bfgf =0;_bfgf < _dcbd ;_bfgf ++{_aedg .Data [_afgd ]=_adec (_aedg .Data [_afgd ],0xff,_egac );_afgd +=_aedg .BytesPerLine ;};if _gbdd {for _bfgf =0;_bfgf < _dcbd ;_bfgf ++{for _gcceb =0;_gcceb < _aacgg ;
_gcceb ++{_aedg .Data [_fbcf +_gcceb ]=0xff;};_fbcf +=_aedg .BytesPerLine ;};};if _abee {for _bfgf =0;_bfgf < _dcbd ;_bfgf ++{_aedg .Data [_gffg ]=_adec (_aedg .Data [_gffg ],0xff,_eaga );_gffg +=_aedg .BytesPerLine ;};};case PixNotDst :for _bfgf =0;_bfgf < _dcbd ;
_bfgf ++{_aedg .Data [_afgd ]=_adec (_aedg .Data [_afgd ],^_aedg .Data [_afgd ],_egac );_afgd +=_aedg .BytesPerLine ;};if _gbdd {for _bfgf =0;_bfgf < _dcbd ;_bfgf ++{for _gcceb =0;_gcceb < _aacgg ;_gcceb ++{_aedg .Data [_fbcf +_gcceb ]=^(_aedg .Data [_fbcf +_gcceb ]);
};_fbcf +=_aedg .BytesPerLine ;};};if _abee {for _bfgf =0;_bfgf < _dcbd ;_bfgf ++{_aedg .Data [_gffg ]=_adec (_aedg .Data [_gffg ],^_aedg .Data [_gffg ],_eaga );_gffg +=_aedg .BytesPerLine ;};};};};func _bdeg (_bdgg *_f .NYCbCrA ,_bbcg RGBA ,_gbeb _f .Rectangle ){for _cgcf :=0;
_cgcf < _gbeb .Max .X ;_cgcf ++{for _aedc :=0;_aedc < _gbeb .Max .Y ;_aedc ++{_bacaa :=_bdgg .NYCbCrAAt (_cgcf ,_aedc );_bbcg .SetRGBA (_cgcf ,_aedc ,_ebcb (_bacaa ));};};};func _bcb (_gbdc _g .Gray )_g .RGBA {return _g .RGBA {R :_gbdc .Y ,G :_gbdc .Y ,B :_gbdc .Y ,A :0xff}};
func _dgecc (_cgeg _g .NRGBA64 )_g .RGBA {_bde ,_dcec ,_abb ,_ddcdg :=_cgeg .RGBA ();return _g .RGBA {R :uint8 (_bde >>8),G :uint8 (_dcec >>8),B :uint8 (_abb >>8),A :uint8 (_ddcdg >>8)};};var _ Image =&CMYK32 {};func (_bfaf *Gray2 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_bfaf .Width ,Y :_bfaf .Height }};
};func (_ffge *NRGBA32 )Validate ()error {if len (_ffge .Data )!=3*_ffge .Width *_ffge .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_ccbe *NRGBA64 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_ccbe .Width ,Y :_ccbe .Height }};};func (_ecba *Gray4 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray4BPC (x ,y ,_ecba .BytesPerLine ,_ecba .Data ,_ecba .Decode );
};func MonochromeModel (threshold uint8 )_g .Model {return monochromeModel (threshold )};type Gray2 struct{ImageBase };func (_dgad *Monochrome )setIndexedBit (_cbaf int ){_dgad .Data [(_cbaf >>3)]|=0x80>>uint (_cbaf &7)};func (_dgfc *Monochrome )setGray (_aada int ,_dae _g .Gray ,_afaf int ){if _dae .Y ==0{_dgfc .clearBit (_afaf ,_aada );
}else {_dgfc .setGrayBit (_afaf ,_aada );};};func (_gebg *NRGBA32 )NRGBAAt (x ,y int )_g .NRGBA {_efbdc ,_ :=ColorAtNRGBA32 (x ,y ,_gebg .Width ,_gebg .Data ,_gebg .Alpha ,_gebg .Decode );return _efbdc ;};type colorConverter struct{_aae func (_ccacc _f .Image )(Image ,error );
};func (_eaab *CMYK32 )SetCMYK (x ,y int ,c _g .CMYK ){_daac :=4*(y *_eaab .Width +x );if _daac +3>=len (_eaab .Data ){return ;};_eaab .Data [_daac ]=c .C ;_eaab .Data [_daac +1]=c .M ;_eaab .Data [_daac +2]=c .Y ;_eaab .Data [_daac +3]=c .K ;};func (_gagab *Gray16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_gagab .Width ,Y :_gagab .Height }};
};func _eabg (_acae _f .Image )(Image ,error ){if _faa ,_bageg :=_acae .(*Gray8 );_bageg {return _faa .Copy (),nil ;};_cdaa :=_acae .Bounds ();_gfd ,_eea :=NewImage (_cdaa .Max .X ,_cdaa .Max .Y ,8,1,nil ,nil ,nil );if _eea !=nil {return nil ,_eea ;};_acb (_acae ,_gfd ,_cdaa );
return _gfd ,nil ;};func _cbe (_gbe Gray ,_fdab CMYK ,_ddde _f .Rectangle ){for _acee :=0;_acee < _ddde .Max .X ;_acee ++{for _fbdc :=0;_fbdc < _ddde .Max .Y ;_fbdc ++{_ddcd :=_gbe .GrayAt (_acee ,_fbdc );_fdab .SetCMYK (_acee ,_fbdc ,_ggbd (_ddcd ));};
};};func (_gcfg *Gray2 )Set (x ,y int ,c _g .Color ){if x >=_gcfg .Width ||y >=_gcfg .Height {return ;};_fcfb :=Gray2Model .Convert (c ).(_g .Gray );_bgba :=y *_gcfg .BytesPerLine ;_aba :=_bgba +(x >>2);_bag :=_fcfb .Y >>6;_gcfg .Data [_aba ]=(_gcfg .Data [_aba ]&(^(0xc0>>uint (2*((x )&3)))))|(_bag <<uint (6-2*(x &3)));
};func (_gdfdc *Gray2 )GrayAt (x ,y int )_g .Gray {_gbca ,_ :=ColorAtGray2BPC (x ,y ,_gdfdc .BytesPerLine ,_gdfdc .Data ,_gdfdc .Decode );return _gbca ;};func (_dddf *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_dddf .copy ()}};type Gray interface{GrayAt (_ddac ,_geaa int )_g .Gray ;
SetGray (_egdd ,_deae int ,_fefg _g .Gray );};func (_bfcc *RGBA32 )At (x ,y int )_g .Color {_badfg ,_ :=_bfcc .ColorAt (x ,y );return _badfg };var _ Image =&NRGBA32 {};func (_bdb *Monochrome )Histogram ()(_bfdg [256]int ){for _ ,_afdc :=range _bdb .Data {_bfdg [0xff]+=int (_dfcc [_bdb .Data [_afdc ]]);
};return _bfdg ;};func (_fcdd *NRGBA16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_fcdd .Width ,Y :_fcdd .Height }};};func _gegd (_cba *Monochrome ,_adg ...int )(_fca *Monochrome ,_eee error ){if _cba ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_adg )==0{return nil ,_a .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_ddd :=_afde ();_fca =_cba ;for _ ,_afad :=range _adg {if _afad <=0{break ;};_fca ,_eee =_fcd (_fca ,_afad ,_ddd );if _eee !=nil {return nil ,_eee ;};};return _fca ,nil ;};func _gfgg (_cfd _g .CMYK )_g .Gray {_bfa ,_aac ,_adce :=_g .CMYKToRGB (_cfd .C ,_cfd .M ,_cfd .Y ,_cfd .K );
_baf :=(19595*uint32 (_bfa )+38470*uint32 (_aac )+7471*uint32 (_adce )+1<<7)>>16;return _g .Gray {Y :uint8 (_baf )};};type nrgba64 interface{NRGBA64At (_cebf ,_deaa int )_g .NRGBA64 ;SetNRGBA64 (_aadf ,_ccda int ,_ece _g .NRGBA64 );};func _abcc (_dbbg _f .Image )(Image ,error ){if _adac ,_aadg :=_dbbg .(*Gray2 );
_aadg {return _adac .Copy (),nil ;};_fcgfg :=_dbbg .Bounds ();_agdd ,_ebb :=NewImage (_fcgfg .Max .X ,_fcgfg .Max .Y ,2,1,nil ,nil ,nil );if _ebb !=nil {return nil ,_ebb ;};_acb (_dbbg ,_agdd ,_fcgfg );return _agdd ,nil ;};func (_aee *CMYK32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtCMYK (x ,y ,_aee .Width ,_aee .Data ,_aee .Decode );
};func (_dedg *Gray4 )setGray (_eecdd int ,_bage int ,_cded _g .Gray ){_fdaf :=_bage *_dedg .BytesPerLine ;_cdce :=_fdaf +(_eecdd >>1);if _cdce >=len (_dedg .Data ){return ;};_cedc :=_cded .Y >>4;_dedg .Data [_cdce ]=(_dedg .Data [_cdce ]&(^(0xf0>>uint (4*(_eecdd &1)))))|(_cedc <<uint (4-4*(_eecdd &1)));
};func (_dgcdb *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_dgcdb .copy ()}};func (_eagd *Gray4 )Base ()*ImageBase {return &_eagd .ImageBase };func _fcfe (_fbcd *Monochrome ,_babd ,_fbeg int ,_cbgce ,_geca int ,_gbf RasterOperator ,_fcag *Monochrome ,_ecd ,_acfd int )error {var _edga ,_begf ,_fdfbb ,_ddcb int ;
if _babd < 0{_ecd -=_babd ;_cbgce +=_babd ;_babd =0;};if _ecd < 0{_babd -=_ecd ;_cbgce +=_ecd ;_ecd =0;};_edga =_babd +_cbgce -_fbcd .Width ;if _edga > 0{_cbgce -=_edga ;};_begf =_ecd +_cbgce -_fcag .Width ;if _begf > 0{_cbgce -=_begf ;};if _fbeg < 0{_acfd -=_fbeg ;
_geca +=_fbeg ;_fbeg =0;};if _acfd < 0{_fbeg -=_acfd ;_geca +=_acfd ;_acfd =0;};_fdfbb =_fbeg +_geca -_fbcd .Height ;if _fdfbb > 0{_geca -=_fdfbb ;};_ddcb =_acfd +_geca -_fcag .Height ;if _ddcb > 0{_geca -=_ddcb ;};if _cbgce <=0||_geca <=0{return nil ;
};var _efbd error ;switch {case _babd &7==0&&_ecd &7==0:_efbd =_dfbef (_fbcd ,_babd ,_fbeg ,_cbgce ,_geca ,_gbf ,_fcag ,_ecd ,_acfd );case _babd &7==_ecd &7:_efbd =_ccebg (_fbcd ,_babd ,_fbeg ,_cbgce ,_geca ,_gbf ,_fcag ,_ecd ,_acfd );default:_efbd =_fbcb (_fbcd ,_babd ,_fbeg ,_cbgce ,_geca ,_gbf ,_fcag ,_ecd ,_acfd );
};if _efbd !=nil {return _efbd ;};return nil ;};func ConverterFunc (converterFunc func (_dgg _f .Image )(Image ,error ))ColorConverter {return colorConverter {_aae :converterFunc };};var _ Gray =&Gray8 {};func (_acd *Monochrome )copy ()*Monochrome {_gaga :=_gdge (_acd .Width ,_acd .Height );
_gaga .ModelThreshold =_acd .ModelThreshold ;_gaga .Data =make ([]byte ,len (_acd .Data ));copy (_gaga .Data ,_acd .Data );if len (_acd .Decode )!=0{_gaga .Decode =make ([]float64 ,len (_acd .Decode ));copy (_gaga .Decode ,_acd .Decode );};if len (_acd .Alpha )!=0{_gaga .Alpha =make ([]byte ,len (_acd .Alpha ));
copy (_gaga .Alpha ,_acd .Alpha );};return _gaga ;};func (_gdba *NRGBA64 )SetNRGBA64 (x ,y int ,c _g .NRGBA64 ){_cbgg :=(y *_gdba .Width +x )*2;_dgef :=_cbgg *3;if _dgef +5>=len (_gdba .Data ){return ;};_gdba .setNRGBA64 (_dgef ,c ,_cbgg );};func (_effe *Gray2 )SetGray (x ,y int ,gray _g .Gray ){_cgaga :=_cgga (gray );
_dbe :=y *_effe .BytesPerLine ;_cffb :=_dbe +(x >>2);if _cffb >=len (_effe .Data ){return ;};_fdgb :=_cgaga .Y >>6;_effe .Data [_cffb ]=(_effe .Data [_cffb ]&(^(0xc0>>uint (2*((x )&3)))))|(_fdgb <<uint (6-2*(x &3)));};var _ _f .Image =&NRGBA64 {};func _cbea (_acfb CMYK ,_gaeb NRGBA ,_fdeaf _f .Rectangle ){for _gdbc :=0;
_gdbc < _fdeaf .Max .X ;_gdbc ++{for _adca :=0;_adca < _fdeaf .Max .Y ;_adca ++{_dfcf :=_acfb .CMYKAt (_gdbc ,_adca );_gaeb .SetNRGBA (_gdbc ,_adca ,_fggf (_dfcf ));};};};func _bea (_deg ,_aga *Monochrome ,_fcg []byte ,_gda int )(_ggb error ){var (_beb ,_aff ,_cgf ,_fef ,_ddaba ,_gaa ,_gea ,_ac int ;
_gdgd ,_ggf uint32 ;_ccaa ,_gfg byte ;_cd uint16 ;);_efc :=make ([]byte ,4);_egab :=make ([]byte ,4);for _cgf =0;_cgf < _deg .Height -1;_cgf ,_fef =_cgf +2,_fef +1{_beb =_cgf *_deg .BytesPerLine ;_aff =_fef *_aga .BytesPerLine ;for _ddaba ,_gaa =0,0;_ddaba < _gda ;
_ddaba ,_gaa =_ddaba +4,_gaa +1{for _gea =0;_gea < 4;_gea ++{_ac =_beb +_ddaba +_gea ;if _ac <=len (_deg .Data )-1&&_ac < _beb +_deg .BytesPerLine {_efc [_gea ]=_deg .Data [_ac ];}else {_efc [_gea ]=0x00;};_ac =_beb +_deg .BytesPerLine +_ddaba +_gea ;if _ac <=len (_deg .Data )-1&&_ac < _beb +(2*_deg .BytesPerLine ){_egab [_gea ]=_deg .Data [_ac ];
}else {_egab [_gea ]=0x00;};};_gdgd =_b .BigEndian .Uint32 (_efc );_ggf =_b .BigEndian .Uint32 (_egab );_ggf |=_gdgd ;_ggf |=_ggf <<1;_ggf &=0xaaaaaaaa;_gdgd =_ggf |(_ggf <<7);_ccaa =byte (_gdgd >>24);_gfg =byte ((_gdgd >>8)&0xff);_ac =_aff +_gaa ;if _ac +1==len (_aga .Data )-1||_ac +1>=_aff +_aga .BytesPerLine {_aga .Data [_ac ]=_fcg [_ccaa ];
}else {_cd =(uint16 (_fcg [_ccaa ])<<8)|uint16 (_fcg [_gfg ]);if _ggb =_aga .setTwoBytes (_ac ,_cd );_ggb !=nil {return _gb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ac );
};_gaa ++;};};};return nil ;};func (_fbbb *Monochrome )IsUnpadded ()bool {return (_fbbb .Width *_fbbb .Height )==len (_fbbb .Data )};func (_cbag *NRGBA32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_cbag .Width ,Y :_cbag .Height }};
};func (_fcab *CMYK32 )At (x ,y int )_g .Color {_dec ,_ :=_fcab .ColorAt (x ,y );return _dec };type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_dabec *ImageBase )newAlpha (){_egb :=BytesPerLine (_dabec .Width ,_dabec .BitsPerComponent ,1);
_dabec .Alpha =make ([]byte ,_dabec .Height *_egb );};func (_gagg *Gray8 )ColorModel ()_g .Model {return _g .GrayModel };func _gecb (_cadg nrgba64 ,_cfda NRGBA ,_ageb _f .Rectangle ){for _adad :=0;_adad < _ageb .Max .X ;_adad ++{for _gfcf :=0;_gfcf < _ageb .Max .Y ;
_gfcf ++{_ffgcd :=_cadg .NRGBA64At (_adad ,_gfcf );_cfda .SetNRGBA (_adad ,_gfcf ,_cebd (_ffgcd ));};};};func _adfc (_gabd ,_agcc NRGBA ,_fgcc _f .Rectangle ){for _dca :=0;_dca < _fgcc .Max .X ;_dca ++{for _gdae :=0;_gdae < _fgcc .Max .Y ;_gdae ++{_agcc .SetNRGBA (_dca ,_gdae ,_gabd .NRGBAAt (_dca ,_gdae ));
};};};func (_ecb *CMYK32 )Base ()*ImageBase {return &_ecb .ImageBase };func _dbg (_ffe ,_ddf *Monochrome ,_fd []byte ,_ged int )(_afce error ){var (_efe ,_dfb ,_gae ,_gac ,_ceb ,_aea ,_abc ,_adc int ;_eec ,_afdb ,_dcf ,_bcg uint32 ;_ace ,_dbd byte ;_aaa uint16 ;
);_cdg :=make ([]byte ,4);_eed :=make ([]byte ,4);for _gae =0;_gae < _ffe .Height -1;_gae ,_gac =_gae +2,_gac +1{_efe =_gae *_ffe .BytesPerLine ;_dfb =_gac *_ddf .BytesPerLine ;for _ceb ,_aea =0,0;_ceb < _ged ;_ceb ,_aea =_ceb +4,_aea +1{for _abc =0;_abc < 4;
_abc ++{_adc =_efe +_ceb +_abc ;if _adc <=len (_ffe .Data )-1&&_adc < _efe +_ffe .BytesPerLine {_cdg [_abc ]=_ffe .Data [_adc ];}else {_cdg [_abc ]=0x00;};_adc =_efe +_ffe .BytesPerLine +_ceb +_abc ;if _adc <=len (_ffe .Data )-1&&_adc < _efe +(2*_ffe .BytesPerLine ){_eed [_abc ]=_ffe .Data [_adc ];
}else {_eed [_abc ]=0x00;};};_eec =_b .BigEndian .Uint32 (_cdg );_afdb =_b .BigEndian .Uint32 (_eed );_dcf =_eec &_afdb ;_dcf |=_dcf <<1;_bcg =_eec |_afdb ;_bcg &=_bcg <<1;_afdb =_dcf |_bcg ;_afdb &=0xaaaaaaaa;_eec =_afdb |(_afdb <<7);_ace =byte (_eec >>24);
_dbd =byte ((_eec >>8)&0xff);_adc =_dfb +_aea ;if _adc +1==len (_ddf .Data )-1||_adc +1>=_dfb +_ddf .BytesPerLine {if _afce =_ddf .setByte (_adc ,_fd [_ace ]);_afce !=nil {return _gb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_adc );};}else {_aaa =(uint16 (_fd [_ace ])<<8)|uint16 (_fd [_dbd ]);
if _afce =_ddf .setTwoBytes (_adc ,_aaa );_afce !=nil {return _gb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_adc );
};_aea ++;};};};return nil ;};func _df (_ag *Monochrome ,_gd int )(*Monochrome ,error ){if _ag ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _gd ==1{return _ag .copy (),nil ;
};if !IsPowerOf2 (uint (_gd )){return nil ,_gb .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gd );};_db :=_abg (_gd );
return _fc (_ag ,_gd ,_db );};func _bafd (_gab Gray ,_cab nrgba64 ,_daab _f .Rectangle ){for _ggbf :=0;_ggbf < _daab .Max .X ;_ggbf ++{for _edec :=0;_edec < _daab .Max .Y ;_edec ++{_dfc :=_agf (_cab .NRGBA64At (_ggbf ,_edec ));_gab .SetGray (_ggbf ,_edec ,_dfc );
};};};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_abdf :=y *bytesPerLine +x >>2;if _abdf >=len (data ){return _g .Gray {},_gb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eaca :=data [_abdf ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_eaca =uint8 (uint32 (LinearInterpolate (float64 (_eaca ),0,3.0,decode [0],decode [1]))&3);};return _g .Gray {Y :_eaca *85},nil ;};type Gray4 struct{ImageBase };func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};var _ Image =&Gray2 {};func AutoThresholdTriangle (histogram [256]int )uint8 {var _dddg ,_cffg ,_egdc ,_aaec int ;for _bcac :=0;_bcac < len (histogram );_bcac ++{if histogram [_bcac ]> 0{_dddg =_bcac ;break ;};};if _dddg > 0{_dddg --;};for _abfb :=255;
_abfb > 0;_abfb --{if histogram [_abfb ]> 0{_aaec =_abfb ;break ;};};if _aaec < 255{_aaec ++;};for _cbbca :=0;_cbbca < 256;_cbbca ++{if histogram [_cbbca ]> _cffg {_egdc =_cbbca ;_cffg =histogram [_cbbca ];};};var _dgfa bool ;if (_egdc -_dddg )< (_aaec -_egdc ){_dgfa =true ;
var _bgff int ;_bdad :=255;for _bgff < _bdad {_aaagb :=histogram [_bgff ];histogram [_bgff ]=histogram [_bdad ];histogram [_bdad ]=_aaagb ;_bgff ++;_bdad --;};_dddg =255-_aaec ;_egdc =255-_egdc ;};if _dddg ==_egdc {return uint8 (_dddg );};_gcfc :=float64 (histogram [_egdc ]);
_eedcb :=float64 (_dddg -_egdc );_eece :=_af .Sqrt (_gcfc *_gcfc +_eedcb *_eedcb );_gcfc /=_eece ;_eedcb /=_eece ;_eece =_gcfc *float64 (_dddg )+_eedcb *float64 (histogram [_dddg ]);_feeg :=_dddg ;var _ggde float64 ;for _ccag :=_dddg +1;_ccag <=_egdc ;
_ccag ++{_eagdc :=_gcfc *float64 (_ccag )+_eedcb *float64 (histogram [_ccag ])-_eece ;if _eagdc > _ggde {_feeg =_ccag ;_ggde =_eagdc ;};};_feeg --;if _dgfa {var _gadd int ;_ddfae :=255;for _gadd < _ddfae {_fafc :=histogram [_gadd ];histogram [_gadd ]=histogram [_ddfae ];
histogram [_ddfae ]=_fafc ;_gadd ++;_ddfae --;};return uint8 (255-_feeg );};return uint8 (_feeg );};type NRGBA64 struct{ImageBase };func _eaec (_fccf NRGBA ,_agcd Gray ,_acaa _f .Rectangle ){for _gfbbc :=0;_gfbbc < _acaa .Max .X ;_gfbbc ++{for _dgga :=0;
_dgga < _acaa .Max .Y ;_dgga ++{_gggf :=_gga (_fccf .NRGBAAt (_gfbbc ,_dgga ));_agcd .SetGray (_gfbbc ,_dgga ,_gggf );};};};func (_gecf *NRGBA32 )SetNRGBA (x ,y int ,c _g .NRGBA ){_bedf :=y *_gecf .Width +x ;_gdceb :=3*_bedf ;if _gdceb +2>=len (_gecf .Data ){return ;
};_gecf .setRGBA (_bedf ,c );};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_gb .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_ecgc *NRGBA16 )At (x ,y int )_g .Color {_eddc ,_ :=_ecgc .ColorAt (x ,y );return _eddc };func _aaaba (_ccbd _f .Image ,_gdec Image ,_decb _f .Rectangle ){if _decc ,_eabe :=_ccbd .(SMasker );_eabe &&_decc .HasAlpha (){_gdec .(SMasker ).MakeAlpha ();
};switch _dgbgg :=_ccbd .(type ){case Gray :_baee (_dgbgg ,_gdec .(RGBA ),_decb );case NRGBA :_cddbf (_dgbgg ,_gdec .(RGBA ),_decb );case *_f .NYCbCrA :_bdeg (_dgbgg ,_gdec .(RGBA ),_decb );case CMYK :_eadg (_dgbgg ,_gdec .(RGBA ),_decb );case RGBA :_fdbe (_dgbgg ,_gdec .(RGBA ),_decb );
case nrgba64 :_fgee (_dgbgg ,_gdec .(RGBA ),_decb );default:_afb (_ccbd ,_gdec ,_decb );};};func (_ffbc *Gray8 )Histogram ()(_bac [256]int ){for _efbe :=0;_efbe < len (_ffbc .Data );_efbe ++{_bac [_ffbc .Data [_efbe ]]++;};return _bac ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_gcee :=y *bytesPerLine +x >>1;
if _gcee >=len (data ){return _g .Gray {},_gb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_feccb :=data [_gcee ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_feccb =uint8 (uint32 (LinearInterpolate (float64 (_feccb ),0,15,decode [0],decode [1]))&0xf);};return _g .Gray {Y :_feccb *17&0xff},nil ;};func (_ggg *Monochrome )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray1BPC (x ,y ,_ggg .BytesPerLine ,_ggg .Data ,_ggg .Decode );
};func _fcd (_fcde *Monochrome ,_ea int ,_fbfe []byte )(_ddb *Monochrome ,_dge error ){const _gcd ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _fcde ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _ea < 1||_ea > 4{return nil ,_a .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _fcde .Height <=1{return nil ,_a .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_ddb =_gdge (_fcde .Width /2,_fcde .Height /2);if _fbfe ==nil {_fbfe =_afde ();};_ccf :=_bdcc (_fcde .BytesPerLine ,2*_ddb .BytesPerLine );switch _ea {case 1:_dge =_bea (_fcde ,_ddb ,_fbfe ,_ccf );case 2:_dge =_dbg (_fcde ,_ddb ,_fbfe ,_ccf );case 3:_dge =_ffb (_fcde ,_ddb ,_fbfe ,_ccf );
case 4:_dge =_gcdc (_fcde ,_ddb ,_fbfe ,_ccf );};if _dge !=nil {return nil ,_dge ;};return _ddb ,nil ;};func IsGrayImgBlackAndWhite (i *_f .Gray )bool {return _ddfab (i )};var _dfcc [256]uint8 ;func (_acab *NRGBA64 )setNRGBA64 (_gacf int ,_dccac _g .NRGBA64 ,_gaefg int ){_acab .Data [_gacf ]=uint8 (_dccac .R >>8);
_acab .Data [_gacf +1]=uint8 (_dccac .R &0xff);_acab .Data [_gacf +2]=uint8 (_dccac .G >>8);_acab .Data [_gacf +3]=uint8 (_dccac .G &0xff);_acab .Data [_gacf +4]=uint8 (_dccac .B >>8);_acab .Data [_gacf +5]=uint8 (_dccac .B &0xff);if _gaefg +1< len (_acab .Alpha ){_acab .Alpha [_gaefg ]=uint8 (_dccac .A >>8);
_acab .Alpha [_gaefg +1]=uint8 (_dccac .A &0xff);};};var _ _f .Image =&NRGBA16 {};var _ Gray =&Monochrome {};func (_gada *Monochrome )getBitAt (_fcgf ,_gfad int )bool {_faf :=_gfad *_gada .BytesPerLine +(_fcgf >>3);_fbg :=_fcgf &0x07;_cade :=uint (7-_fbg );
if _faf > len (_gada .Data )-1{return false ;};if (_gada .Data [_faf ]>>_cade )&0x01>=1{return true ;};return false ;};func (_fce *Gray2 )ColorModel ()_g .Model {return Gray2Model };func (_bcad *RGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtRGBA32 (x ,y ,_bcad .Width ,_bcad .Data ,_bcad .Alpha ,_bcad .Decode );
};func (_cgfc *NRGBA16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA16 (x ,y ,_cgfc .Width ,_cgfc .BytesPerLine ,_cgfc .Data ,_cgfc .Alpha ,_cgfc .Decode );};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_gb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};type CMYK interface{CMYKAt (_gcae ,_dfga int )_g .CMYK ;SetCMYK (_ebd ,_aaf int ,_fdfb _g .CMYK );};func _befg (_dabg *Monochrome ,_abdb ,_beed int ,_daccd ,_gedag int ,_gedb RasterOperator ){var (_aagg int ;_ggcge byte ;_cedf ,_fbgd int ;_daca int ;
);_fddb :=_daccd >>3;_fbeec :=_daccd &7;if _fbeec > 0{_ggcge =_baff [_fbeec ];};_aagg =_dabg .BytesPerLine *_beed +(_abdb >>3);switch _gedb {case PixClr :for _cedf =0;_cedf < _gedag ;_cedf ++{_daca =_aagg +_cedf *_dabg .BytesPerLine ;for _fbgd =0;_fbgd < _fddb ;
_fbgd ++{_dabg .Data [_daca ]=0x0;_daca ++;};if _fbeec > 0{_dabg .Data [_daca ]=_adec (_dabg .Data [_daca ],0x0,_ggcge );};};case PixSet :for _cedf =0;_cedf < _gedag ;_cedf ++{_daca =_aagg +_cedf *_dabg .BytesPerLine ;for _fbgd =0;_fbgd < _fddb ;_fbgd ++{_dabg .Data [_daca ]=0xff;
_daca ++;};if _fbeec > 0{_dabg .Data [_daca ]=_adec (_dabg .Data [_daca ],0xff,_ggcge );};};case PixNotDst :for _cedf =0;_cedf < _gedag ;_cedf ++{_daca =_aagg +_cedf *_dabg .BytesPerLine ;for _fbgd =0;_fbgd < _fddb ;_fbgd ++{_dabg .Data [_daca ]=^_dabg .Data [_daca ];
_daca ++;};if _fbeec > 0{_dabg .Data [_daca ]=_adec (_dabg .Data [_daca ],^_dabg .Data [_daca ],_ggcge );};};};};func (_acg *NRGBA16 )Validate ()error {if len (_acg .Data )!=3*_acg .Width *_acg .Height /2{return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _baee (_bgfbb Gray ,_efde RGBA ,_ggac _f .Rectangle ){for _cdcb :=0;_cdcb < _ggac .Max .X ;_cdcb ++{for _cacaa :=0;_cacaa < _ggac .Max .Y ;_cacaa ++{_cgegc :=_bgfbb .GrayAt (_cdcb ,_cacaa );_efde .SetRGBA (_cdcb ,_cacaa ,_bcb (_cgegc ));
};};};func (_dcedg *NRGBA32 )Base ()*ImageBase {return &_dcedg .ImageBase };func _cdf (_egae Gray ,_bca NRGBA ,_fdb _f .Rectangle ){for _cccd :=0;_cccd < _fdb .Max .X ;_cccd ++{for _bff :=0;_bff < _fdb .Max .Y ;_bff ++{_dcff :=_aebd (_bca .NRGBAAt (_cccd ,_bff ));
_egae .SetGray (_cccd ,_bff ,_dcff );};};};func _acb (_agdf _f .Image ,_cecg Image ,_acf _f .Rectangle ){switch _agfc :=_agdf .(type ){case Gray :_afg (_agfc ,_cecg .(Gray ),_acf );case NRGBA :_eaec (_agfc ,_cecg .(Gray ),_acf );case CMYK :_edac (_agfc ,_cecg .(Gray ),_acf );
case RGBA :_ffda (_agfc ,_cecg .(Gray ),_acf );default:_afb (_agdf ,_cecg ,_acf );};};func _ffd (_ggff _f .Image )(Image ,error ){if _gdaf ,_gcab :=_ggff .(*Monochrome );_gcab {return _gdaf ,nil ;};_gdc :=_ggff .Bounds ();var _eecc Gray ;switch _aec :=_ggff .(type ){case Gray :_eecc =_aec ;
case NRGBA :_eecc =&Gray8 {ImageBase :NewImageBase (_gdc .Max .X ,_gdc .Max .Y ,8,1,nil ,nil ,nil )};_cdf (_eecc ,_aec ,_gdc );case nrgba64 :_eecc =&Gray8 {ImageBase :NewImageBase (_gdc .Max .X ,_gdc .Max .Y ,8,1,nil ,nil ,nil )};_bafd (_eecc ,_aec ,_gdc );
default:_fbb ,_gdgdf :=GrayConverter .Convert (_ggff );if _gdgdf !=nil {return nil ,_gdgdf ;};_eecc =_fbb .(Gray );};_bdf ,_aab :=NewImage (_gdc .Max .X ,_gdc .Max .Y ,1,1,nil ,nil ,nil );if _aab !=nil {return nil ,_aab ;};_gdbf :=_bdf .(*Monochrome );
_fagd :=AutoThresholdTriangle (GrayHistogram (_eecc ));for _dgc :=0;_dgc < _gdc .Max .X ;_dgc ++{for _gcb :=0;_gcb < _gdc .Max .Y ;_gcb ++{_geda :=_bgd (_eecc .GrayAt (_dgc ,_gcb ),monochromeModel (_fagd ));_gdbf .SetGray (_dgc ,_gcb ,_geda );};};return _bdf ,nil ;
};func (_edgdd *Gray4 )ColorModel ()_g .Model {return Gray4Model };func (_defg *Monochrome )SetGray (x ,y int ,g _g .Gray ){_ccdf :=y *_defg .BytesPerLine +x >>3;if _ccdf > len (_defg .Data )-1{return ;};g =_bgd (g ,monochromeModel (_defg .ModelThreshold ));
_defg .setGray (x ,g ,_ccdf );};var _ Image =&Monochrome {};func _fgab (_dfdb *Monochrome ,_afcd ,_gagaa ,_bdef ,_aed int ,_dddd RasterOperator ,_dbfe *Monochrome ,_bbfb ,_ecfc int )error {if _dfdb ==nil {return _a .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _dddd ==PixDst {return nil ;};switch _dddd {case PixClr ,PixSet ,PixNotDst :_accg (_dfdb ,_afcd ,_gagaa ,_bdef ,_aed ,_dddd );return nil ;};if _dbfe ==nil {_cca .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _a .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _beag :=_fcfe (_dfdb ,_afcd ,_gagaa ,_bdef ,_aed ,_dddd ,_dbfe ,_bbfb ,_ecfc );_beag !=nil {return _beag ;};return nil ;};var _ Image =&NRGBA16 {};
var _ Gray =&Gray2 {};func _age (_cec ,_bbf *Monochrome )(_ccc error ){_bdg :=_bbf .BytesPerLine ;_gbg :=_cec .BytesPerLine ;var _cb ,_dda ,_cbf ,_dfa ,_dac int ;for _cbf =0;_cbf < _bbf .Height ;_cbf ++{_cb =_cbf *_bdg ;_dda =8*_cbf *_gbg ;for _dfa =0;
_dfa < _bdg ;_dfa ++{if _ccc =_cec .setEightBytes (_dda +_dfa *8,_gfb [_bbf .Data [_cb +_dfa ]]);_ccc !=nil {return _ccc ;};};for _dac =1;_dac < 8;_dac ++{for _dfa =0;_dfa < _gbg ;_dfa ++{if _ccc =_cec .setByte (_dda +_dac *_gbg +_dfa ,_cec .Data [_dda +_dfa ]);
_ccc !=nil {return _ccc ;};};};};return nil ;};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_gb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_ebcbf *RGBA32 )setRGBA (_dbbcf int ,_gfcd _g .RGBA ){_gcdg :=3*_dbbcf ;_ebcbf .Data [_gcdg ]=_gfcd .R ;_ebcbf .Data [_gcdg +1]=_gfcd .G ;_ebcbf .Data [_gcdg +2]=_gfcd .B ;if _dbbcf < len (_ebcbf .Alpha ){_ebcbf .Alpha [_dbbcf ]=_gfcd .A ;};};
func FromGoImage (i _f .Image )(Image ,error ){switch _gbb :=i .(type ){case Image :return _gbb .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_f .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );
case *_f .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_bcgc *ImageBase )GetAlpha ()[]byte {return _bcgc .Alpha };func (_edd *Gray2 )Histogram ()(_gge [256]int ){for _aefe :=0;_aefe < _edd .Width ;
_aefe ++{for _feg :=0;_feg < _edd .Height ;_feg ++{_gge [_edd .GrayAt (_aefe ,_feg ).Y ]++;};};return _gge ;};func _ddae (_faegd uint8 )bool {if _faegd ==0||_faegd ==255{return true ;};return false ;};func (_eae *CMYK32 )ColorModel ()_g .Model {return _g .CMYKModel };
func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_d :=BytesPerLine (width ,8,1);if len (data )< _d *height {return nil ,nil ;};_e :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_ca ,_fe :=MonochromeConverter .Convert (_e );
if _fe !=nil {return nil ,_fe ;};return _ca .Base ().Data ,nil ;};func (_badf *Gray4 )GrayAt (x ,y int )_g .Gray {_cace ,_ :=ColorAtGray4BPC (x ,y ,_badf .BytesPerLine ,_badf .Data ,_badf .Decode );return _cace ;};func _fdbe (_gdea ,_deabg RGBA ,_ggce _f .Rectangle ){for _gdfdf :=0;
_gdfdf < _ggce .Max .X ;_gdfdf ++{for _dgba :=0;_dgba < _ggce .Max .Y ;_dgba ++{_deabg .SetRGBA (_gdfdf ,_dgba ,_gdea .RGBAAt (_gdfdf ,_dgba ));};};};var ErrInvalidImage =_a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func _aebd (_daad _g .NRGBA )_g .Gray {var _egaba _g .NRGBA ;if _daad ==_egaba {return _g .Gray {Y :0xff};};_fcf ,_ebf ,_badc ,_ :=_daad .RGBA ();_gbcg :=(19595*_fcf +38470*_ebf +7471*_badc +1<<15)>>24;return _g .Gray {Y :uint8 (_gbcg )};};func (_egddc *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _df (_egddc ,factor );};func _edfe (_agee _g .NRGBA )_g .NRGBA {_agee .R =_agee .R >>4|(_agee .R >>4)<<4;_agee .G =_agee .G >>4|(_agee .G >>4)<<4;_agee .B =_agee .B >>4|(_agee .B >>4)<<4;return _agee ;};type CMYK32 struct{ImageBase };func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .RGBA ,error ){_dbgg :=y *width +x ;
_ccfcc :=3*_dbgg ;if _ccfcc +2>=len (data ){return _g .RGBA {},_gb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_faed :=uint8 (0xff);if alpha !=nil &&len (alpha )> _dbgg {_faed =alpha [_dbgg ];};_gfee ,_acbb ,_deeb :=data [_ccfcc ],data [_ccfcc +1],data [_ccfcc +2];if len (decode )==6{_gfee =uint8 (uint32 (LinearInterpolate (float64 (_gfee ),0,255,decode [0],decode [1]))&0xff);
_acbb =uint8 (uint32 (LinearInterpolate (float64 (_acbb ),0,255,decode [2],decode [3]))&0xff);_deeb =uint8 (uint32 (LinearInterpolate (float64 (_deeb ),0,255,decode [4],decode [5]))&0xff);};return _g .RGBA {R :_gfee ,G :_acbb ,B :_deeb ,A :_faed },nil ;
};func (_ege *Gray8 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray8BPC (x ,y ,_ege .BytesPerLine ,_ege .Data ,_ege .Decode );};func _fge (_dcgb _f .Image )(Image ,error ){if _abfg ,_fefgf :=_dcgb .(*NRGBA64 );_fefgf {return _abfg .Copy (),nil ;
};_deaea ,_dad ,_gbgb :=_fdfe (_dcgb ,2);_feae ,_cebg :=NewImage (_deaea .Max .X ,_deaea .Max .Y ,16,3,nil ,_gbgb ,nil );if _cebg !=nil {return nil ,_cebg ;};_beab (_dcgb ,_feae ,_deaea );if len (_gbgb )!=0&&!_dad {if _gcgc :=_edb (_gbgb ,_feae );_gcgc !=nil {return nil ,_gcgc ;
};};return _feae ,nil ;};func _cegc (_agce *_f .Gray16 ,_cfaec uint8 )*_f .Gray {_bgfg :=_agce .Bounds ();_gaaf :=_f .NewGray (_bgfg );for _acgf :=0;_acgf < _bgfg .Dx ();_acgf ++{for _ffbg :=0;_ffbg < _bgfg .Dy ();_ffbg ++{_gcde :=_agce .Gray16At (_acgf ,_ffbg );
_gaaf .SetGray (_acgf ,_ffbg ,_g .Gray {Y :_cffc (uint8 (_gcde .Y /256),_cfaec )});};};return _gaaf ;};func _ceeg (_baca int ,_gfbd int )error {return _gb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_baca ,_gfbd );
};func (_ebg *Monochrome )Base ()*ImageBase {return &_ebg .ImageBase };func _edb (_ffgb []byte ,_eca Image )error {_acef :=true ;for _egcc :=0;_egcc < len (_ffgb );_egcc ++{if _ffgb [_egcc ]!=0xff{_acef =false ;break ;};};if _acef {switch _bbfag :=_eca .(type ){case *NRGBA32 :_bbfag .Alpha =nil ;
case *NRGBA64 :_bbfag .Alpha =nil ;default:return _gb .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_eca );
};};return nil ;};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func (_edag *Gray8 )GrayAt (x ,y int )_g .Gray {_bdea ,_ :=ColorAtGray8BPC (x ,y ,_edag .BytesPerLine ,_edag .Data ,_edag .Decode );return _bdea ;};func (_efag *Gray16 )Validate ()error {if len (_efag .Data )!=_efag .Height *_efag .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_fcaa *NRGBA64 )Set (x ,y int ,c _g .Color ){_fcgc :=(y *_fcaa .Width +x )*2;_dgca :=_fcgc *3;if _dgca +5>=len (_fcaa .Data ){return ;};_bbfd :=_g .NRGBA64Model .Convert (c ).(_g .NRGBA64 );_fcaa .setNRGBA64 (_dgca ,_bbfd ,_fcgc );
};func _dfbef (_cgde *Monochrome ,_acfec ,_ddcf ,_cccg ,_cbee int ,_aacdg RasterOperator ,_ddabb *Monochrome ,_bbc ,_gadg int )error {var (_cebdc byte ;_bef int ;_fbaa int ;_aacg ,_agef int ;_bdfd ,_acbc int ;);_fagdd :=_cccg >>3;_ffa :=_cccg &7;if _ffa > 0{_cebdc =_baff [_ffa ];
};_bef =_ddabb .BytesPerLine *_gadg +(_bbc >>3);_fbaa =_cgde .BytesPerLine *_ddcf +(_acfec >>3);switch _aacdg {case PixSrc :for _bdfd =0;_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;for _acbc =0;
_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]=_ddabb .Data [_aacg ];_agef ++;_aacg ++;};if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],_ddabb .Data [_aacg ],_cebdc );};};case PixNotSrc :for _bdfd =0;_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;
_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;for _acbc =0;_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]=^(_ddabb .Data [_aacg ]);_agef ++;_aacg ++;};if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],^_ddabb .Data [_aacg ],_cebdc );};};case PixSrcOrDst :for _bdfd =0;
_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;for _acbc =0;_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]|=_ddabb .Data [_aacg ];_agef ++;_aacg ++;};if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],_ddabb .Data [_aacg ]|_cgde .Data [_agef ],_cebdc );
};};case PixSrcAndDst :for _bdfd =0;_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;for _acbc =0;_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]&=_ddabb .Data [_aacg ];_agef ++;_aacg ++;};if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],_ddabb .Data [_aacg ]&_cgde .Data [_agef ],_cebdc );
};};case PixSrcXorDst :for _bdfd =0;_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;for _acbc =0;_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]^=_ddabb .Data [_aacg ];_agef ++;_aacg ++;};if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],_ddabb .Data [_aacg ]^_cgde .Data [_agef ],_cebdc );
};};case PixNotSrcOrDst :for _bdfd =0;_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;for _acbc =0;_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]|=^(_ddabb .Data [_aacg ]);_agef ++;_aacg ++;};if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],^(_ddabb .Data [_aacg ])|_cgde .Data [_agef ],_cebdc );
};};case PixNotSrcAndDst :for _bdfd =0;_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;for _acbc =0;_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]&=^(_ddabb .Data [_aacg ]);_agef ++;_aacg ++;};
if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],^(_ddabb .Data [_aacg ])&_cgde .Data [_agef ],_cebdc );};};case PixSrcOrNotDst :for _bdfd =0;_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;
for _acbc =0;_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]=_ddabb .Data [_aacg ]|^(_cgde .Data [_agef ]);_agef ++;_aacg ++;};if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],_ddabb .Data [_aacg ]|^(_cgde .Data [_agef ]),_cebdc );};};case PixSrcAndNotDst :for _bdfd =0;
_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;for _acbc =0;_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]=_ddabb .Data [_aacg ]&^(_cgde .Data [_agef ]);_agef ++;_aacg ++;};if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],_ddabb .Data [_aacg ]&^(_cgde .Data [_agef ]),_cebdc );
};};case PixNotPixSrcOrDst :for _bdfd =0;_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;for _acbc =0;_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]=^(_ddabb .Data [_aacg ]|_cgde .Data [_agef ]);
_agef ++;_aacg ++;};if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],^(_ddabb .Data [_aacg ]|_cgde .Data [_agef ]),_cebdc );};};case PixNotPixSrcAndDst :for _bdfd =0;_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;
for _acbc =0;_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]=^(_ddabb .Data [_aacg ]&_cgde .Data [_agef ]);_agef ++;_aacg ++;};if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],^(_ddabb .Data [_aacg ]&_cgde .Data [_agef ]),_cebdc );};};case PixNotPixSrcXorDst :for _bdfd =0;
_bdfd < _cbee ;_bdfd ++{_aacg =_bef +_bdfd *_ddabb .BytesPerLine ;_agef =_fbaa +_bdfd *_cgde .BytesPerLine ;for _acbc =0;_acbc < _fagdd ;_acbc ++{_cgde .Data [_agef ]=^(_ddabb .Data [_aacg ]^_cgde .Data [_agef ]);_agef ++;_aacg ++;};if _ffa > 0{_cgde .Data [_agef ]=_adec (_cgde .Data [_agef ],^(_ddabb .Data [_aacg ]^_cgde .Data [_agef ]),_cebdc );
};};default:_cca .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_aacdg );return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func (_bbdf *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _fgab (_bbdf ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func _dfee (_ede ,_dc int ,_ff []byte )*Monochrome {_fcc :=_gdge (_ede ,_dc );
_fcc .Data =_ff ;return _fcc ;};func _bad ()(_abe [256]uint32 ){for _gff :=0;_gff < 256;_gff ++{if _gff &0x01!=0{_abe [_gff ]|=0xf;};if _gff &0x02!=0{_abe [_gff ]|=0xf0;};if _gff &0x04!=0{_abe [_gff ]|=0xf00;};if _gff &0x08!=0{_abe [_gff ]|=0xf000;};if _gff &0x10!=0{_abe [_gff ]|=0xf0000;
};if _gff &0x20!=0{_abe [_gff ]|=0xf00000;};if _gff &0x40!=0{_abe [_gff ]|=0xf000000;};if _gff &0x80!=0{_abe [_gff ]|=0xf0000000;};};return _abe ;};func _cfg (_eag ,_dcb CMYK ,_cgag _f .Rectangle ){for _beg :=0;_beg < _cgag .Max .X ;_beg ++{for _cee :=0;
_cee < _cgag .Max .Y ;_cee ++{_dcb .SetCMYK (_beg ,_cee ,_eag .CMYKAt (_beg ,_cee ));};};};func _fgde (_cdcf Gray ,_feag NRGBA ,_bbabg _f .Rectangle ){for _fbddc :=0;_fbddc < _bbabg .Max .X ;_fbddc ++{for _dcbe :=0;_dcbe < _bbabg .Max .Y ;_dcbe ++{_ddddf :=_cdcf .GrayAt (_fbddc ,_dcbe );
_feag .SetNRGBA (_fbddc ,_dcbe ,_gcf (_ddddf ));};};};func (_cgbd *RGBA32 )Set (x ,y int ,c _g .Color ){_bdfe :=y *_cgbd .Width +x ;_bbac :=3*_bdfe ;if _bbac +2>=len (_cgbd .Data ){return ;};_aadc :=_g .RGBAModel .Convert (c ).(_g .RGBA );_cgbd .setRGBA (_bdfe ,_aadc );
};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_bede :=y *width +x ;_cefd :=3*_bede ;if _cefd +2>=len (data ){return _g .NRGBA {},_gb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fded :=uint8 (0xff);if alpha !=nil &&len (alpha )> _bede {_fded =alpha [_bede ];};_faeg ,_eefca ,_dfacd :=data [_cefd ],data [_cefd +1],data [_cefd +2];if len (decode )==6{_faeg =uint8 (uint32 (LinearInterpolate (float64 (_faeg ),0,255,decode [0],decode [1]))&0xff);
_eefca =uint8 (uint32 (LinearInterpolate (float64 (_eefca ),0,255,decode [2],decode [3]))&0xff);_dfacd =uint8 (uint32 (LinearInterpolate (float64 (_dfacd ),0,255,decode [4],decode [5]))&0xff);};return _g .NRGBA {R :_faeg ,G :_eefca ,B :_dfacd ,A :_fded },nil ;
};func (_ccdc *NRGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA32 (x ,y ,_ccdc .Width ,_ccdc .Data ,_ccdc .Alpha ,_ccdc .Decode );};func (_afgf *RGBA32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_afgf .Width ,Y :_afgf .Height }};
};