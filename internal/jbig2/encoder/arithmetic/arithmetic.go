//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "bytes";_c "github.com/unidoc/unipdf/v3/common";_d "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_fd "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);func (_gef *Encoder )encodeOOB (_bged Class )error {_daf :=_gef ._fec [_bged ];
_ea :=_gef .encodeBit (_daf ,1,1);if _ea !=nil {return _ea ;};_ea =_gef .encodeBit (_daf ,3,0);if _ea !=nil {return _ea ;};_ea =_gef .encodeBit (_daf ,6,0);if _ea !=nil {return _ea ;};_ea =_gef .encodeBit (_daf ,12,0);if _ea !=nil {return _ea ;};return nil ;
};func (_ac *codingContext )flipMps (_ed uint32 ){_ac ._ca [_ed ]=1-_ac ._ca [_ed ]};func (_ggb *Encoder )EncodeIAID (symbolCodeLength ,value int )(_dc error ){_c .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _dc =_ggb .encodeIAID (symbolCodeLength ,value );_dc !=nil {return _fd .Wrap (_dc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_acf *Encoder )codeMPS (_adg *codingContext ,_bdf uint32 ,_cafg uint16 ,_ge byte ){_acf ._bd -=_cafg ;
if _acf ._bd &0x8000!=0{_acf ._fe +=uint32 (_cafg );return ;};if _acf ._bd < _cafg {_acf ._bd =_cafg ;}else {_acf ._fe +=uint32 (_cafg );};_adg ._fb [_bdf ]=_bed [_ge ]._beg ;_acf .renormalize ();};func (_ec *codingContext )mps (_bb uint32 )int {return int (_ec ._ca [_bb ])};
func (_acg *Encoder )codeLPS (_bag *codingContext ,_gfb uint32 ,_bda uint16 ,_bff byte ){_acg ._bd -=_bda ;if _acg ._bd < _bda {_acg ._fe +=uint32 (_bda );}else {_acg ._bd =_bda ;};if _bed [_bff ]._bce ==1{_bag .flipMps (_gfb );};_bag ._fb [_gfb ]=_bed [_bff ]._bdeb ;
_acg .renormalize ();};func (_ebag *Encoder )flush (){_ebag .setBits ();_ebag ._fe <<=_ebag ._gd ;_ebag .byteOut ();_ebag ._fe <<=_ebag ._gd ;_ebag .byteOut ();_ebag .emit ();if _ebag ._fc !=0xff{_ebag ._ab ++;_ebag ._fc =0xff;_ebag .emit ();};_ebag ._ab ++;
_ebag ._fc =0xac;_ebag ._ab ++;_ebag .emit ();};func (_fca *Encoder )Init (){_fca ._cae =_dd (_gdb );_fca ._bd =0x8000;_fca ._fe =0;_fca ._gd =12;_fca ._ab =-1;_fca ._fc =0;_fca ._ef =0;_fca ._cdg =make ([]byte ,_cfd );for _af :=0;_af < len (_fca ._fec );
_af ++{_fca ._fec [_af ]=_dd (512);};_fca ._bf =nil ;};func (_cg *Encoder )EncodeBitmap (bm *_d .Bitmap ,duplicateLineRemoval bool )error {_c .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_cf ,_afa uint8 ;_aae ,_ff ,_fbc uint16 ;_eg ,_edc ,_cce byte ;_eb ,_fa ,_bab int ;_cb ,_fbb []byte ;);for _ebg :=0;_ebg < bm .Height ;_ebg ++{_eg ,_edc =0,0;if _ebg >=2{_eg =bm .Data [(_ebg -2)*bm .RowStride ];};if _ebg >=1{_edc =bm .Data [(_ebg -1)*bm .RowStride ];
if duplicateLineRemoval {_fa =_ebg *bm .RowStride ;_cb =bm .Data [_fa :_fa +bm .RowStride ];_bab =(_ebg -1)*bm .RowStride ;_fbb =bm .Data [_bab :_bab +bm .RowStride ];if _e .Equal (_cb ,_fbb ){_afa =_cf ^1;_cf =1;}else {_afa =_cf ;_cf =0;};};};if duplicateLineRemoval {if _fdf :=_cg .encodeBit (_cg ._cae ,_ddg ,_afa );
_fdf !=nil {return _fdf ;};if _cf !=0{continue ;};};_cce =bm .Data [_ebg *bm .RowStride ];_aae =uint16 (_eg >>5);_ff =uint16 (_edc >>4);_eg <<=3;_edc <<=4;_fbc =0;for _eb =0;_eb < bm .Width ;_eb ++{_bee :=uint32 (_aae <<11|_ff <<4|_fbc );_ag :=(_cce &0x80)>>7;
_fg :=_cg .encodeBit (_cg ._cae ,_bee ,_ag );if _fg !=nil {return _fg ;};_aae <<=1;_ff <<=1;_fbc <<=1;_aae |=uint16 ((_eg &0x80)>>7);_ff |=uint16 ((_edc &0x80)>>7);_fbc |=uint16 (_ag );_gg :=_eb %8;_caf :=_eb /8+1;if _gg ==4&&_ebg >=2{_eg =0;if _caf < bm .RowStride {_eg =bm .Data [(_ebg -2)*bm .RowStride +_caf ];
};}else {_eg <<=1;};if _gg ==3&&_ebg >=1{_edc =0;if _caf < bm .RowStride {_edc =bm .Data [(_ebg -1)*bm .RowStride +_caf ];};}else {_edc <<=1;};if _gg ==7{_cce =0;if _caf < bm .RowStride {_cce =bm .Data [_ebg *bm .RowStride +_caf ];};}else {_cce <<=1;};
_aae &=31;_ff &=127;_fbc &=15;};};return nil ;};type state struct{_bfd uint16 ;_beg ,_bdeb uint8 ;_bce uint8 ;};func (_bc *Encoder )WriteTo (w _a .Writer )(int64 ,error ){const _ffd ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _efd int64 ;for _agg ,_gae :=range _bc ._eda {_gbfe ,_ffe :=w .Write (_gae );if _ffe !=nil {return 0,_fd .Wrapf (_ffe ,_ffd ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_agg );
};_efd +=int64 (_gbfe );};_bc ._cdg =_bc ._cdg [:_bc ._ef ];_fda ,_ade :=w .Write (_bc ._cdg );if _ade !=nil {return 0,_fd .Wrap (_ade ,_ffd ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_efd +=int64 (_fda );return _efd ,nil ;
};func (_ce *Encoder )dataSize ()int {return _cfd *len (_ce ._eda )+_ce ._ef };func (_edd *Encoder )byteOut (){if _edd ._fc ==0xff{_edd .rBlock ();return ;};if _edd ._fe < 0x8000000{_edd .lBlock ();return ;};_edd ._fc ++;if _edd ._fc !=0xff{_edd .lBlock ();
return ;};_edd ._fe &=0x7ffffff;_edd .rBlock ();};func (_ccd *Encoder )Flush (){_ccd ._ef =0;_ccd ._eda =nil ;_ccd ._ab =-1};func New ()*Encoder {_be :=&Encoder {};_be .Init ();return _be };func (_fbca *Encoder )code1 (_fbg *codingContext ,_agc uint32 ,_da uint16 ,_ccdf byte ){if _fbg .mps (_agc )==1{_fbca .codeMPS (_fbg ,_agc ,_da ,_ccdf );
}else {_fbca .codeLPS (_fbg ,_agc ,_da ,_ccdf );};};func (_ebe *Encoder )Refine (iTemp ,iTarget *_d .Bitmap ,ox ,oy int )error {for _caee :=0;_caee < iTarget .Height ;_caee ++{var _ecg int ;_acd :=_caee +oy ;var (_aeg ,_beef ,_ad ,_adc ,_gfe uint16 ;_eba ,_gfec ,_beb ,_ddd ,_fga byte ;
);if _acd >=1&&(_acd -1)< iTemp .Height {_eba =iTemp .Data [(_acd -1)*iTemp .RowStride ];};if _acd >=0&&_acd < iTemp .Height {_gfec =iTemp .Data [_acd *iTemp .RowStride ];};if _acd >=-1&&_acd +1< iTemp .Height {_beb =iTemp .Data [(_acd +1)*iTemp .RowStride ];
};if _caee >=1{_ddd =iTarget .Data [(_caee -1)*iTarget .RowStride ];};_fga =iTarget .Data [_caee *iTarget .RowStride ];_eff :=uint (6+ox );_aeg =uint16 (_eba >>_eff );_beef =uint16 (_gfec >>_eff );_ad =uint16 (_beb >>_eff );_adc =uint16 (_ddd >>6);_cdf :=uint (2-ox );
_eba <<=_cdf ;_gfec <<=_cdf ;_beb <<=_cdf ;_ddd <<=2;for _ecg =0;_ecg < iTarget .Width ;_ecg ++{_gbf :=(_aeg <<10)|(_beef <<7)|(_ad <<4)|(_adc <<1)|_gfe ;_ebb :=_fga >>7;_bgg :=_ebe .encodeBit (_ebe ._cae ,uint32 (_gbf ),_ebb );if _bgg !=nil {return _bgg ;
};_aeg <<=1;_beef <<=1;_ad <<=1;_adc <<=1;_aeg |=uint16 (_eba >>7);_beef |=uint16 (_gfec >>7);_ad |=uint16 (_beb >>7);_adc |=uint16 (_ddd >>7);_gfe =uint16 (_ebb );_afc :=_ecg %8;_ebd :=_ecg /8+1;if _afc ==5+ox {_eba ,_gfec ,_beb =0,0,0;if _ebd < iTemp .RowStride &&_acd >=1&&(_acd -1)< iTemp .Height {_eba =iTemp .Data [(_acd -1)*iTemp .RowStride +_ebd ];
};if _ebd < iTemp .RowStride &&_acd >=0&&_acd < iTemp .Height {_gfec =iTemp .Data [_acd *iTemp .RowStride +_ebd ];};if _ebd < iTemp .RowStride &&_acd >=-1&&(_acd +1)< iTemp .Height {_beb =iTemp .Data [(_acd +1)*iTemp .RowStride +_ebd ];};}else {_eba <<=1;
_gfec <<=1;_beb <<=1;};if _afc ==5&&_caee >=1{_ddd =0;if _ebd < iTarget .RowStride {_ddd =iTarget .Data [(_caee -1)*iTarget .RowStride +_ebd ];};}else {_ddd <<=1;};if _afc ==7{_fga =0;if _ebd < iTarget .RowStride {_fga =iTarget .Data [_caee *iTarget .RowStride +_ebd ];
};}else {_fga <<=1;};_aeg &=7;_beef &=7;_ad &=7;_adc &=7;};};return nil ;};func (_bdc *Encoder )encodeBit (_db *codingContext ,_fef uint32 ,_age uint8 )error {const _cda ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_bdc ._cc ++;if _fef >=uint32 (len (_db ._fb )){return _fd .Errorf (_cda ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fef );
};_cfg :=_db ._fb [_fef ];_adb :=_db .mps (_fef );_bde :=_bed [_cfg ]._bfd ;_c .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_bdc ._cc ,_age ,_cfg ,_adb ,_bde ,_bdc ._bd ,_bdc ._fe ,_bdc ._gd ,_bdc ._fc ,_bdc ._ab );
if _age ==0{_bdc .code0 (_db ,_fef ,_bde ,_cfg );}else {_bdc .code1 (_db ,_fef ,_bde ,_cfg );};return nil ;};func (_fbfd *Encoder )Reset (){_fbfd ._bd =0x8000;_fbfd ._fe =0;_fbfd ._gd =12;_fbfd ._ab =-1;_fbfd ._fc =0;_fbfd ._bf =nil ;_fbfd ._cae =_dd (_gdb );
};var _bed =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
var _ _a .WriterTo =&Encoder {};func (_bg *Encoder )EncodeOOB (proc Class )(_fcg error ){_c .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _fcg =_bg .encodeOOB (proc );_fcg !=nil {return _fd .Wrap (_fcg ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};type Class int ;type codingContext struct{_fb []byte ;_ca []byte ;};type intEncRangeS struct{_b ,_cd int ;_gf ,_ga uint8 ;
_aa uint16 ;_ae uint8 ;};func (_agcb *Encoder )rBlock (){if _agcb ._ab >=0{_agcb .emit ();};_agcb ._ab ++;_agcb ._fc =uint8 (_agcb ._fe >>20);_agcb ._fe &=0xfffff;_agcb ._gd =7;};func (_fbf *Encoder )Final (){_fbf .flush ()};var _gb =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func _dd (_gc int )*codingContext {return &codingContext {_fb :make ([]byte ,_gc ),_ca :make ([]byte ,_gc )};};const (_gdb =65536;_cfd =20*1024;);func (_acc *Encoder )code0 (_ecf *codingContext ,_bgd uint32 ,_ebae uint16 ,_gaef byte ){if _ecf .mps (_bgd )==0{_acc .codeMPS (_ecf ,_bgd ,_ebae ,_gaef );
}else {_acc .codeLPS (_ecf ,_bgd ,_ebae ,_gaef );};};func (_bfa *Encoder )encodeInteger (_de Class ,_cac int )error {const _faf ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _cac > 2000000000||_cac < -2000000000{return _fd .Errorf (_faf ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_cac );
};_dg :=_bfa ._fec [_de ];_abb :=uint32 (1);var _bded int ;for ;;_bded ++{if _gb [_bded ]._b <=_cac &&_gb [_bded ]._cd >=_cac {break ;};};if _cac < 0{_cac =-_cac ;};_cac -=int (_gb [_bded ]._aa );_gfc :=_gb [_bded ]._gf ;for _adeg :=uint8 (0);_adeg < _gb [_bded ]._ga ;
_adeg ++{_cfb :=_gfc &1;if _cab :=_bfa .encodeBit (_dg ,_abb ,_cfb );_cab !=nil {return _fd .Wrap (_cab ,_faf ,"");};_gfc >>=1;if _abb &0x100> 0{_abb =(((_abb <<1)|uint32 (_cfb ))&0x1ff)|0x100;}else {_abb =(_abb <<1)|uint32 (_cfb );};};_cac <<=32-_gb [_bded ]._ae ;
for _fag :=uint8 (0);_fag < _gb [_bded ]._ae ;_fag ++{_fcf :=uint8 ((uint32 (_cac )&0x80000000)>>31);if _bec :=_bfa .encodeBit (_dg ,_abb ,_fcf );_bec !=nil {return _fd .Wrap (_bec ,_faf ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_cac <<=1;if _abb &0x100!=0{_abb =(((_abb <<1)|uint32 (_fcf ))&0x1ff)|0x100;}else {_abb =(_abb <<1)|uint32 (_fcf );};};return nil ;};func (_ffef *Encoder )renormalize (){for {_ffef ._bd <<=1;_ffef ._fe <<=1;_ffef ._gd --;if _ffef ._gd ==0{_ffef .byteOut ();
};if (_ffef ._bd &0x8000)!=0{break ;};};};func (_ba *Encoder )DataSize ()int {return _ba .dataSize ()};func (_dbb *Encoder )encodeIAID (_abbb ,_dba int )error {if _dbb ._bf ==nil {_dbb ._bf =_dd (1<<uint (_abbb ));};_ece :=uint32 (1<<uint32 (_abbb +1))-1;
_dba <<=uint (32-_abbb );_deg :=uint32 (1);for _fgg :=0;_fgg < _abbb ;_fgg ++{_deb :=_deg &_ece ;_bge :=uint8 ((uint32 (_dba )&0x80000000)>>31);if _ccc :=_dbb .encodeBit (_dbb ._bf ,_deb ,_bge );_ccc !=nil {return _ccc ;};_deg =(_deg <<1)|uint32 (_bge );
_dba <<=1;};return nil ;};const _ddg =0x9b25;func (_fed *Encoder )lBlock (){if _fed ._ab >=0{_fed .emit ();};_fed ._ab ++;_fed ._fc =uint8 (_fed ._fe >>19);_fed ._fe &=0x7ffff;_fed ._gd =8;};func (_g Class )String ()string {switch _g {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_gfd *Encoder )setBits (){_bfe :=_gfd ._fe +uint32 (_gfd ._bd );_gfd ._fe |=0xffff;if _gfd ._fe >=_bfe {_gfd ._fe -=0x8000;};};func (_agb *Encoder )EncodeInteger (proc Class ,value int )(_fcaa error ){_c .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _fcaa =_agb .encodeInteger (proc ,value );_fcaa !=nil {return _fd .Wrap (_fcaa ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type Encoder struct{_fe uint32 ;_bd uint16 ;_gd ,_fc uint8 ;_ab int ;
_cc int ;_eda [][]byte ;_cdg []byte ;_ef int ;_cae *codingContext ;_fec [13]*codingContext ;_bf *codingContext ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_bdg *Encoder )emit (){if _bdg ._ef ==_cfd {_bdg ._eda =append (_bdg ._eda ,_bdg ._cdg );
_bdg ._cdg =make ([]byte ,_cfd );_bdg ._ef =0;};_bdg ._cdg [_bdg ._ef ]=_bdg ._fc ;_bdg ._ef ++;};