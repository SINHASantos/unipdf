//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "bytes";_e "github.com/unidoc/unipdf/v3/common";_d "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_f "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_g "io";);type Encoder struct{_ea uint32 ;_ecc uint16 ;_fg ,_fa uint8 ;
_ae int ;_ad int ;_adf [][]byte ;_de []byte ;_beg int ;_cc *codingContext ;_cg [13]*codingContext ;_dca *codingContext ;};const (_ffb =65536;_agg =20*1024;);func (_eae *Encoder )Init (){_eae ._cc =_bd (_ffb );_eae ._ecc =0x8000;_eae ._ea =0;_eae ._fg =12;
_eae ._ae =-1;_eae ._fa =0;_eae ._beg =0;_eae ._de =make ([]byte ,_agg );for _fed :=0;_fed < len (_eae ._cg );_fed ++{_eae ._cg [_fed ]=_bd (512);};_eae ._dca =nil ;};func New ()*Encoder {_ed :=&Encoder {};_ed .Init ();return _ed };func (_bbd *Encoder )EncodeIAID (symbolCodeLength ,value int )(_cbd error ){_e .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _cbd =_bbd .encodeIAID (symbolCodeLength ,value );_cbd !=nil {return _f .Wrap (_cbd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_bcac *Encoder )flush (){_bcac .setBits ();_bcac ._ea <<=_bcac ._fg ;_bcac .byteOut ();
_bcac ._ea <<=_bcac ._fg ;_bcac .byteOut ();_bcac .emit ();if _bcac ._fa !=0xff{_bcac ._ae ++;_bcac ._fa =0xff;_bcac .emit ();};_bcac ._ae ++;_bcac ._fa =0xac;_bcac ._ae ++;_bcac .emit ();};func (_fabg *Encoder )rBlock (){if _fabg ._ae >=0{_fabg .emit ();
};_fabg ._ae ++;_fabg ._fa =uint8 (_fabg ._ea >>20);_fabg ._ea &=0xfffff;_fabg ._fg =7;};func (_fada *Encoder )byteOut (){if _fada ._fa ==0xff{_fada .rBlock ();return ;};if _fada ._ea < 0x8000000{_fada .lBlock ();return ;};_fada ._fa ++;if _fada ._fa !=0xff{_fada .lBlock ();
return ;};_fada ._ea &=0x7ffffff;_fada .rBlock ();};const _bb =0x9b25;func (_gg *Encoder )renormalize (){for {_gg ._ecc <<=1;_gg ._ea <<=1;_gg ._fg --;if _gg ._fg ==0{_gg .byteOut ();};if (_gg ._ecc &0x8000)!=0{break ;};};};func (_bee *Encoder )encodeBit (_gfb *codingContext ,_ac uint32 ,_deg uint8 )error {const _effd ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_bee ._ad ++;if _ac >=uint32 (len (_gfb ._fc )){return _f .Errorf (_effd ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_ac );
};_bcd :=_gfb ._fc [_ac ];_gce :=_gfb .mps (_ac );_edc :=_gef [_bcd ]._fdd ;_e .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_bee ._ad ,_deg ,_bcd ,_gce ,_edc ,_bee ._ecc ,_bee ._ea ,_bee ._fg ,_bee ._fa ,_bee ._ae );
if _deg ==0{_bee .code0 (_gfb ,_ac ,_edc ,_bcd );}else {_bee .code1 (_gfb ,_ac ,_edc ,_bcd );};return nil ;};func (_gfee *Encoder )emit (){if _gfee ._beg ==_agg {_gfee ._adf =append (_gfee ._adf ,_gfee ._de );_gfee ._de =make ([]byte ,_agg );_gfee ._beg =0;
};_gfee ._de [_gfee ._beg ]=_gfee ._fa ;_gfee ._beg ++;};var _ _g .WriterTo =&Encoder {};func (_efb *Encoder )lBlock (){if _efb ._ae >=0{_efb .emit ();};_efb ._ae ++;_efb ._fa =uint8 (_efb ._ea >>19);_efb ._ea &=0x7ffff;_efb ._fg =8;};func (_ga *Encoder )Final (){_ga .flush ()};
func _bd (_fe int )*codingContext {return &codingContext {_fc :make ([]byte ,_fe ),_ab :make ([]byte ,_fe )};};func (_bg *Encoder )EncodeOOB (proc Class )(_fgf error ){_e .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _fgf =_bg .encodeOOB (proc );_fgf !=nil {return _f .Wrap (_fgf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_add *Encoder )setBits (){_bfgd :=_add ._ea +uint32 (_add ._ecc );_add ._ea |=0xffff;if _add ._ea >=_bfgd {_add ._ea -=0x8000;
};};var _gef =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
var _aa =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_dfd *Encoder )dataSize ()int {return _agg *len (_dfd ._adf )+_dfd ._beg };func (_bcea *Encoder )code1 (_eed *codingContext ,_db uint32 ,_eg uint16 ,_bec byte ){if _eed .mps (_db )==1{_bcea .codeMPS (_eed ,_db ,_eg ,_bec );}else {_bcea .codeLPS (_eed ,_db ,_eg ,_bec );
};};func (_gdd *Encoder )EncodeBitmap (bm *_d .Bitmap ,duplicateLineRemoval bool )error {_e .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_bce ,_fde uint8 ;_dd ,_aef ,_ead uint16 ;_ba ,_gf ,_abb byte ;_gfe ,_ef ,_ce int ;_feg ,_aab []byte ;);for _ee :=0;_ee < bm .Height ;_ee ++{_ba ,_gf =0,0;if _ee >=2{_ba =bm .Data [(_ee -2)*bm .RowStride ];};if _ee >=1{_gf =bm .Data [(_ee -1)*bm .RowStride ];
if duplicateLineRemoval {_ef =_ee *bm .RowStride ;_feg =bm .Data [_ef :_ef +bm .RowStride ];_ce =(_ee -1)*bm .RowStride ;_aab =bm .Data [_ce :_ce +bm .RowStride ];if _b .Equal (_feg ,_aab ){_fde =_bce ^1;_bce =1;}else {_fde =_bce ;_bce =0;};};};if duplicateLineRemoval {if _eff :=_gdd .encodeBit (_gdd ._cc ,_bb ,_fde );
_eff !=nil {return _eff ;};if _bce !=0{continue ;};};_abb =bm .Data [_ee *bm .RowStride ];_dd =uint16 (_ba >>5);_aef =uint16 (_gf >>4);_ba <<=3;_gf <<=4;_ead =0;for _gfe =0;_gfe < bm .Width ;_gfe ++{_faa :=uint32 (_dd <<11|_aef <<4|_ead );_beb :=(_abb &0x80)>>7;
_baa :=_gdd .encodeBit (_gdd ._cc ,_faa ,_beb );if _baa !=nil {return _baa ;};_dd <<=1;_aef <<=1;_ead <<=1;_dd |=uint16 ((_ba &0x80)>>7);_aef |=uint16 ((_gf &0x80)>>7);_ead |=uint16 (_beb );_fab :=_gfe %8;_bdg :=_gfe /8+1;if _fab ==4&&_ee >=2{_ba =0;if _bdg < bm .RowStride {_ba =bm .Data [(_ee -2)*bm .RowStride +_bdg ];
};}else {_ba <<=1;};if _fab ==3&&_ee >=1{_gf =0;if _bdg < bm .RowStride {_gf =bm .Data [(_ee -1)*bm .RowStride +_bdg ];};}else {_gf <<=1;};if _fab ==7{_abb =0;if _bdg < bm .RowStride {_abb =bm .Data [_ee *bm .RowStride +_bdg ];};}else {_abb <<=1;};_dd &=31;
_aef &=127;_ead &=15;};};return nil ;};func (_cd *codingContext )flipMps (_bc uint32 ){_cd ._ab [_bc ]=1-_cd ._ab [_bc ]};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_ffc *Encoder )codeLPS (_fb *codingContext ,_ddb uint32 ,_ega uint16 ,_bfa byte ){_ffc ._ecc -=_ega ;
if _ffc ._ecc < _ega {_ffc ._ea +=uint32 (_ega );}else {_ffc ._ecc =_ega ;};if _gef [_bfa ]._bdc ==1{_fb .flipMps (_ddb );};_fb ._fc [_ddb ]=_gef [_bfa ]._cdf ;_ffc .renormalize ();};func (_bdd *Encoder )Reset (){_bdd ._ecc =0x8000;_bdd ._ea =0;_bdd ._fg =12;
_bdd ._ae =-1;_bdd ._fa =0;_bdd ._dca =nil ;_bdd ._cc =_bd (_ffb );};func (_gd *codingContext )mps (_dc uint32 )int {return int (_gd ._ab [_dc ])};type state struct{_fdd uint16 ;_gda ,_cdf uint8 ;_bdc uint8 ;};func (_eccb *Encoder )Flush (){_eccb ._beg =0;
_eccb ._adf =nil ;_eccb ._ae =-1};func (_cebf *Encoder )encodeOOB (_fff Class )error {_bca :=_cebf ._cg [_fff ];_da :=_cebf .encodeBit (_bca ,1,1);if _da !=nil {return _da ;};_da =_cebf .encodeBit (_bca ,3,0);if _da !=nil {return _da ;};_da =_cebf .encodeBit (_bca ,6,0);
if _da !=nil {return _da ;};_da =_cebf .encodeBit (_bca ,12,0);if _da !=nil {return _da ;};return nil ;};func (_fad *Encoder )WriteTo (w _g .Writer )(int64 ,error ){const _bedg ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _gc int64 ;for _cdb ,_dec :=range _fad ._adf {_fee ,_dgc :=w .Write (_dec );if _dgc !=nil {return 0,_f .Wrapf (_dgc ,_bedg ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_cdb );
};_gc +=int64 (_fee );};_fad ._de =_fad ._de [:_fad ._beg ];_dce ,_aecg :=w .Write (_fad ._de );if _aecg !=nil {return 0,_f .Wrap (_aecg ,_bedg ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_gc +=int64 (_dce );return _gc ,nil ;
};type Class int ;func (_cdc *Encoder )codeMPS (_gea *codingContext ,_gac uint32 ,_fca uint16 ,_dbd byte ){_cdc ._ecc -=_fca ;if _cdc ._ecc &0x8000!=0{_cdc ._ea +=uint32 (_fca );return ;};if _cdc ._ecc < _fca {_cdc ._ecc =_fca ;}else {_cdc ._ea +=uint32 (_fca );
};_gea ._fc [_gac ]=_gef [_dbd ]._gda ;_cdc .renormalize ();};func (_edg *Encoder )code0 (_bfg *codingContext ,_gaf uint32 ,_df uint16 ,_gde byte ){if _bfg .mps (_gaf )==0{_edg .codeMPS (_bfg ,_gaf ,_df ,_gde );}else {_edg .codeLPS (_bfg ,_gaf ,_df ,_gde );
};};func (_cb *Encoder )DataSize ()int {return _cb .dataSize ()};type codingContext struct{_fc []byte ;_ab []byte ;};func (_abc *Encoder )encodeIAID (_cffb ,_cfe int )error {if _abc ._dca ==nil {_abc ._dca =_bd (1<<uint (_cffb ));};_efdb :=uint32 (1<<uint32 (_cffb +1))-1;
_cfe <<=uint (32-_cffb );_gb :=uint32 (1);for _ccg :=0;_ccg < _cffb ;_ccg ++{_faad :=_gb &_efdb ;_bfb :=uint8 ((uint32 (_cfe )&0x80000000)>>31);if _cebc :=_abc .encodeBit (_abc ._dca ,_faad ,_bfb );_cebc !=nil {return _cebc ;};_gb =(_gb <<1)|uint32 (_bfb );
_cfe <<=1;};return nil ;};type intEncRangeS struct{_fd ,_dg int ;_bf ,_ec uint8 ;_a uint16 ;_ge uint8 ;};func (_gag *Encoder )Refine (iTemp ,iTarget *_d .Bitmap ,ox ,oy int )error {for _ded :=0;_ded < iTarget .Height ;_ded ++{var _ade int ;_bab :=_ded +oy ;
var (_ca ,_aec ,_edb ,_efd ,_fcb uint16 ;_eaef ,_adeg ,_bed ,_cf ,_ceb byte ;);if _bab >=1&&(_bab -1)< iTemp .Height {_eaef =iTemp .Data [(_bab -1)*iTemp .RowStride ];};if _bab >=0&&_bab < iTemp .Height {_adeg =iTemp .Data [_bab *iTemp .RowStride ];};if _bab >=-1&&_bab +1< iTemp .Height {_bed =iTemp .Data [(_bab +1)*iTemp .RowStride ];
};if _ded >=1{_cf =iTarget .Data [(_ded -1)*iTarget .RowStride ];};_ceb =iTarget .Data [_ded *iTarget .RowStride ];_bcb :=uint (6+ox );_ca =uint16 (_eaef >>_bcb );_aec =uint16 (_adeg >>_bcb );_edb =uint16 (_bed >>_bcb );_efd =uint16 (_cf >>6);_cbf :=uint (2-ox );
_eaef <<=_cbf ;_adeg <<=_cbf ;_bed <<=_cbf ;_cf <<=2;for _ade =0;_ade < iTarget .Width ;_ade ++{_ag :=(_ca <<10)|(_aec <<7)|(_edb <<4)|(_efd <<1)|_fcb ;_ecb :=_ceb >>7;_ddd :=_gag .encodeBit (_gag ._cc ,uint32 (_ag ),_ecb );if _ddd !=nil {return _ddd ;
};_ca <<=1;_aec <<=1;_edb <<=1;_efd <<=1;_ca |=uint16 (_eaef >>7);_aec |=uint16 (_adeg >>7);_edb |=uint16 (_bed >>7);_efd |=uint16 (_cf >>7);_fcb =uint16 (_ecb );_cfa :=_ade %8;_eac :=_ade /8+1;if _cfa ==5+ox {_eaef ,_adeg ,_bed =0,0,0;if _eac < iTemp .RowStride &&_bab >=1&&(_bab -1)< iTemp .Height {_eaef =iTemp .Data [(_bab -1)*iTemp .RowStride +_eac ];
};if _eac < iTemp .RowStride &&_bab >=0&&_bab < iTemp .Height {_adeg =iTemp .Data [_bab *iTemp .RowStride +_eac ];};if _eac < iTemp .RowStride &&_bab >=-1&&(_bab +1)< iTemp .Height {_bed =iTemp .Data [(_bab +1)*iTemp .RowStride +_eac ];};}else {_eaef <<=1;
_adeg <<=1;_bed <<=1;};if _cfa ==5&&_ded >=1{_cf =0;if _eac < iTarget .RowStride {_cf =iTarget .Data [(_ded -1)*iTarget .RowStride +_eac ];};}else {_cf <<=1;};if _cfa ==7{_ceb =0;if _eac < iTarget .RowStride {_ceb =iTarget .Data [_ded *iTarget .RowStride +_eac ];
};}else {_ceb <<=1;};_ca &=7;_aec &=7;_edb &=7;_efd &=7;};};return nil ;};func (_be Class )String ()string {switch _be {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";
case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";
case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_ccd *Encoder )encodeInteger (_cab Class ,_cebg int )error {const _cgb ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _cebg > 2000000000||_cebg < -2000000000{return _f .Errorf (_cgb ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_cebg );
};_edcg :=_ccd ._cg [_cab ];_fbd :=uint32 (1);var _agc int ;for ;;_agc ++{if _aa [_agc ]._fd <=_cebg &&_aa [_agc ]._dg >=_cebg {break ;};};if _cebg < 0{_cebg =-_cebg ;};_cebg -=int (_aa [_agc ]._a );_aeca :=_aa [_agc ]._bf ;for _gfc :=uint8 (0);_gfc < _aa [_agc ]._ec ;
_gfc ++{_dcd :=_aeca &1;if _dba :=_ccd .encodeBit (_edcg ,_fbd ,_dcd );_dba !=nil {return _f .Wrap (_dba ,_cgb ,"");};_aeca >>=1;if _fbd &0x100> 0{_fbd =(((_fbd <<1)|uint32 (_dcd ))&0x1ff)|0x100;}else {_fbd =(_fbd <<1)|uint32 (_dcd );};};_cebg <<=32-_aa [_agc ]._ge ;
for _adfg :=uint8 (0);_adfg < _aa [_agc ]._ge ;_adfg ++{_cff :=uint8 ((uint32 (_cebg )&0x80000000)>>31);if _bfae :=_ccd .encodeBit (_edcg ,_fbd ,_cff );_bfae !=nil {return _f .Wrap (_bfae ,_cgb ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_cebg <<=1;if _fbd &0x100!=0{_fbd =(((_fbd <<1)|uint32 (_cff ))&0x1ff)|0x100;}else {_fbd =(_fbd <<1)|uint32 (_cff );};};return nil ;};func (_dcg *Encoder )EncodeInteger (proc Class ,value int )(_ff error ){_e .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _ff =_dcg .encodeInteger (proc ,value );_ff !=nil {return _f .Wrap (_ff ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};