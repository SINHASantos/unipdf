//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_c "bytes";_a "github.com/unidoc/unipdf/v3/common";_aa "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ea "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_dae *Encoder )codeMPS (_fcg *codingContext ,_gac uint32 ,_bac uint16 ,_fbd byte ){_dae ._fd -=_bac ;
if _dae ._fd &0x8000!=0{_dae ._fbc +=uint32 (_bac );return ;};if _dae ._fd < _bac {_dae ._fd =_bac ;}else {_dae ._fbc +=uint32 (_bac );};_fcg ._ga [_gac ]=_def [_fbd ]._bbb ;_dae .renormalize ();};func (_ce *codingContext )flipMps (_fb uint32 ){_ce ._cb [_fb ]=1-_ce ._cb [_fb ]};
func (_bcf *Encoder )dataSize ()int {return _dee *len (_bcf ._gc )+_bcf ._gec };func (_dcc *Encoder )DataSize ()int {return _dcc .dataSize ()};var _def =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_f Class )String ()string {switch _f {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";
case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";
case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_cag *Encoder )codeLPS (_afg *codingContext ,_fbdd uint32 ,_dgb uint16 ,_fec byte ){_cag ._fd -=_dgb ;
if _cag ._fd < _dgb {_cag ._fbc +=uint32 (_dgb );}else {_cag ._fd =_dgb ;};if _def [_fec ]._aacg ==1{_afg .flipMps (_fbdd );};_afg ._ga [_fbdd ]=_def [_fec ]._cbc ;_cag .renormalize ();};func (_cabb *Encoder )lBlock (){if _cabb ._ag >=0{_cabb .emit ();
};_cabb ._ag ++;_cabb ._ege =uint8 (_cabb ._fbc >>19);_cabb ._fbc &=0x7ffff;_cabb ._cd =8;};type Class int ;type state struct{_cge uint16 ;_bbb ,_cbc uint8 ;_aacg uint8 ;};func (_gb *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _aed ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _cba int64 ;for _ddc ,_cc :=range _gb ._gc {_fbg ,_dde :=w .Write (_cc );if _dde !=nil {return 0,_ea .Wrapf (_dde ,_aed ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ddc );
};_cba +=int64 (_fbg );};_gb ._dg =_gb ._dg [:_gb ._gec ];_cdc ,_cfdb :=w .Write (_gb ._dg );if _cfdb !=nil {return 0,_ea .Wrap (_cfdb ,_aed ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_cba +=int64 (_cdc );return _cba ,nil ;
};func (_de *Encoder )byteOut (){if _de ._ege ==0xff{_de .rBlock ();return ;};if _de ._fbc < 0x8000000{_de .lBlock ();return ;};_de ._ege ++;if _de ._ege !=0xff{_de .lBlock ();return ;};_de ._fbc &=0x7ffffff;_de .rBlock ();};func (_dgba *Encoder )encodeInteger (_dff Class ,_ecg int )error {const _ffc ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _ecg > 2000000000||_ecg < -2000000000{return _ea .Errorf (_ffc ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_ecg );
};_bga :=_dgba ._ae [_dff ];_cdd :=uint32 (1);var _feb int ;for ;;_feb ++{if _af [_feb ]._g <=_ecg &&_af [_feb ]._ge >=_ecg {break ;};};if _ecg < 0{_ecg =-_ecg ;};_ecg -=int (_af [_feb ]._ad );_aad :=_af [_feb ]._ff ;for _cbb :=uint8 (0);_cbb < _af [_feb ]._eg ;
_cbb ++{_bb :=_aad &1;if _cdf :=_dgba .encodeBit (_bga ,_cdd ,_bb );_cdf !=nil {return _ea .Wrap (_cdf ,_ffc ,"");};_aad >>=1;if _cdd &0x100> 0{_cdd =(((_cdd <<1)|uint32 (_bb ))&0x1ff)|0x100;}else {_cdd =(_cdd <<1)|uint32 (_bb );};};_ecg <<=32-_af [_feb ]._d ;
for _ade :=uint8 (0);_ade < _af [_feb ]._d ;_ade ++{_adfd :=uint8 ((uint32 (_ecg )&0x80000000)>>31);if _be :=_dgba .encodeBit (_bga ,_cdd ,_adfd );_be !=nil {return _ea .Wrap (_be ,_ffc ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_ecg <<=1;if _cdd &0x100!=0{_cdd =(((_cdd <<1)|uint32 (_adfd ))&0x1ff)|0x100;}else {_cdd =(_cdd <<1)|uint32 (_adfd );};};return nil ;};func (_gad *Encoder )emit (){if _gad ._gec ==_dee {_gad ._gc =append (_gad ._gc ,_gad ._dg );_gad ._dg =make ([]byte ,_dee );
_gad ._gec =0;};_gad ._dg [_gad ._gec ]=_gad ._ege ;_gad ._gec ++;};var _af =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_fe *Encoder )EncodeInteger (proc Class ,value int )(_aec error ){_a .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _aec =_fe .encodeInteger (proc ,value );_aec !=nil {return _ea .Wrap (_aec ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func New ()*Encoder {_fg :=&Encoder {};_fg .Init ();return _fg };func (_gff *Encoder )Final (){_gff .flush ()};
func (_dc *Encoder )Init (){_dc ._bda =_df (_dga );_dc ._fd =0x8000;_dc ._fbc =0;_dc ._cd =12;_dc ._ag =-1;_dc ._ege =0;_dc ._gec =0;_dc ._dg =make ([]byte ,_dee );for _bc :=0;_bc < len (_dc ._ae );_bc ++{_dc ._ae [_bc ]=_df (512);};_dc ._ba =nil ;};const (_dga =65536;
_dee =20*1024;);func (_fde *Encoder )encodeIAID (_ccb ,_cgf int )error {if _fde ._ba ==nil {_fde ._ba =_df (1<<uint (_ccb ));};_ecce :=uint32 (1<<uint32 (_ccb +1))-1;_cgf <<=uint (32-_ccb );_eaea :=uint32 (1);for _adfdb :=0;_adfdb < _ccb ;_adfdb ++{_deg :=_eaea &_ecce ;
_fa :=uint8 ((uint32 (_cgf )&0x80000000)>>31);if _bf :=_fde .encodeBit (_fde ._ba ,_deg ,_fa );_bf !=nil {return _bf ;};_eaea =(_eaea <<1)|uint32 (_fa );_cgf <<=1;};return nil ;};func (_gccf *Encoder )EncodeOOB (proc Class )(_cac error ){_a .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _cac =_gccf .encodeOOB (proc );_cac !=nil {return _ea .Wrap (_cac ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_aef *Encoder )EncodeBitmap (bm *_aa .Bitmap ,duplicateLineRemoval bool )error {_a .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_dfdc ,_ec uint8 ;_gcc ,_adf ,_dd uint16 ;_acb ,_cf ,_aac byte ;_gee ,_agg ,_eae int ;_cg ,_cfb []byte ;);for _agd :=0;_agd < bm .Height ;_agd ++{_acb ,_cf =0,0;if _agd >=2{_acb =bm .Data [(_agd -2)*bm .RowStride ];};if _agd >=1{_cf =bm .Data [(_agd -1)*bm .RowStride ];
if duplicateLineRemoval {_agg =_agd *bm .RowStride ;_cg =bm .Data [_agg :_agg +bm .RowStride ];_eae =(_agd -1)*bm .RowStride ;_cfb =bm .Data [_eae :_eae +bm .RowStride ];if _c .Equal (_cg ,_cfb ){_ec =_dfdc ^1;_dfdc =1;}else {_ec =_dfdc ;_dfdc =0;};};};
if duplicateLineRemoval {if _fc :=_aef .encodeBit (_aef ._bda ,_ef ,_ec );_fc !=nil {return _fc ;};if _dfdc !=0{continue ;};};_aac =bm .Data [_agd *bm .RowStride ];_gcc =uint16 (_acb >>5);_adf =uint16 (_cf >>4);_acb <<=3;_cf <<=4;_dd =0;for _gee =0;_gee < bm .Width ;
_gee ++{_cdb :=uint32 (_gcc <<11|_adf <<4|_dd );_afe :=(_aac &0x80)>>7;_ca :=_aef .encodeBit (_aef ._bda ,_cdb ,_afe );if _ca !=nil {return _ca ;};_gcc <<=1;_adf <<=1;_dd <<=1;_gcc |=uint16 ((_acb &0x80)>>7);_adf |=uint16 ((_cf &0x80)>>7);_dd |=uint16 (_afe );
_eab :=_gee %8;_db :=_gee /8+1;if _eab ==4&&_agd >=2{_acb =0;if _db < bm .RowStride {_acb =bm .Data [(_agd -2)*bm .RowStride +_db ];};}else {_acb <<=1;};if _eab ==3&&_agd >=1{_cf =0;if _db < bm .RowStride {_cf =bm .Data [(_agd -1)*bm .RowStride +_db ];
};}else {_cf <<=1;};if _eab ==7{_aac =0;if _db < bm .RowStride {_aac =bm .Data [_agd *bm .RowStride +_db ];};}else {_aac <<=1;};_gcc &=31;_adf &=127;_dd &=15;};};return nil ;};type Encoder struct{_fbc uint32 ;_fd uint16 ;_cd ,_ege uint8 ;_ag int ;_gf int ;
_gc [][]byte ;_dg []byte ;_gec int ;_bda *codingContext ;_ae [13]*codingContext ;_ba *codingContext ;};type intEncRangeS struct{_g ,_ge int ;_ff ,_eg uint8 ;_ad uint16 ;_d uint8 ;};func (_bd *codingContext )mps (_ac uint32 )int {return int (_bd ._cb [_ac ])};
func (_cca *Encoder )encodeBit (_ab *codingContext ,_abd uint32 ,_geef uint8 )error {const _bacc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_cca ._gf ++;if _abd >=uint32 (len (_ab ._ga )){return _ea .Errorf (_bacc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_abd );
};_gef :=_ab ._ga [_abd ];_afec :=_ab .mps (_abd );_cbg :=_def [_gef ]._cge ;_a .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_cca ._gf ,_geef ,_gef ,_afec ,_cbg ,_cca ._fd ,_cca ._fbc ,_cca ._cd ,_cca ._ege ,_cca ._ag );
if _geef ==0{_cca .code0 (_ab ,_abd ,_cbg ,_gef );}else {_cca .code1 (_ab ,_abd ,_cbg ,_gef );};return nil ;};func (_bdbf *Encoder )Reset (){_bdbf ._fd =0x8000;_bdbf ._fbc =0;_bdbf ._cd =12;_bdbf ._ag =-1;_bdbf ._ege =0;_bdbf ._ba =nil ;_bdbf ._bda =_df (_dga );
};func (_bag *Encoder )EncodeIAID (symbolCodeLength ,value int )(_fcb error ){_a .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _fcb =_bag .encodeIAID (symbolCodeLength ,value );_fcb !=nil {return _ea .Wrap (_fcb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_bcfdg *Encoder )rBlock (){if _bcfdg ._ag >=0{_bcfdg .emit ();};_bcfdg ._ag ++;
_bcfdg ._ege =uint8 (_bcfdg ._fbc >>20);_bcfdg ._fbc &=0xfffff;_bcfdg ._cd =7;};func (_gda *Encoder )renormalize (){for {_gda ._fd <<=1;_gda ._fbc <<=1;_gda ._cd --;if _gda ._cd ==0{_gda .byteOut ();};if (_gda ._fd &0x8000)!=0{break ;};};};func (_cfd *Encoder )Flush (){_cfd ._gec =0;
_cfd ._gc =nil ;_cfd ._ag =-1};func (_ega *Encoder )encodeOOB (_egaa Class )error {_ecge :=_ega ._ae [_egaa ];_bcfd :=_ega .encodeBit (_ecge ,1,1);if _bcfd !=nil {return _bcfd ;};_bcfd =_ega .encodeBit (_ecge ,3,0);if _bcfd !=nil {return _bcfd ;};_bcfd =_ega .encodeBit (_ecge ,6,0);
if _bcfd !=nil {return _bcfd ;};_bcfd =_ega .encodeBit (_ecge ,12,0);if _bcfd !=nil {return _bcfd ;};return nil ;};var _ _e .WriterTo =&Encoder {};func _df (_dfd int )*codingContext {return &codingContext {_ga :make ([]byte ,_dfd ),_cb :make ([]byte ,_dfd )};
};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_da *Encoder )code0 (_bgc *codingContext ,_geg uint32 ,_dfdb uint16 ,_bgb byte ){if _bgc .mps (_geg )==0{_da .codeMPS (_bgc ,_geg ,_dfdb ,_bgb );
}else {_da .codeLPS (_bgc ,_geg ,_dfdb ,_bgb );};};func (_afed *Encoder )Refine (iTemp ,iTarget *_aa .Bitmap ,ox ,oy int )error {for _ead :=0;_ead < iTarget .Height ;_ead ++{var _dge int ;_bdb :=_ead +oy ;var (_bg ,_gd ,_ee ,_fdc ,_ffb uint16 ;_fge ,_gcg ,_caa ,_gaf ,_aca byte ;
);if _bdb >=1&&(_bdb -1)< iTemp .Height {_fge =iTemp .Data [(_bdb -1)*iTemp .RowStride ];};if _bdb >=0&&_bdb < iTemp .Height {_gcg =iTemp .Data [_bdb *iTemp .RowStride ];};if _bdb >=-1&&_bdb +1< iTemp .Height {_caa =iTemp .Data [(_bdb +1)*iTemp .RowStride ];
};if _ead >=1{_gaf =iTarget .Data [(_ead -1)*iTarget .RowStride ];};_aca =iTarget .Data [_ead *iTarget .RowStride ];_ecc :=uint (6+ox );_bg =uint16 (_fge >>_ecc );_gd =uint16 (_gcg >>_ecc );_ee =uint16 (_caa >>_ecc );_fdc =uint16 (_gaf >>6);_agb :=uint (2-ox );
_fge <<=_agb ;_gcg <<=_agb ;_caa <<=_agb ;_gaf <<=2;for _dge =0;_dge < iTarget .Width ;_dge ++{_fbb :=(_bg <<10)|(_gd <<7)|(_ee <<4)|(_fdc <<1)|_ffb ;_eb :=_aca >>7;_cab :=_afed .encodeBit (_afed ._bda ,uint32 (_fbb ),_eb );if _cab !=nil {return _cab ;
};_bg <<=1;_gd <<=1;_ee <<=1;_fdc <<=1;_bg |=uint16 (_fge >>7);_gd |=uint16 (_gcg >>7);_ee |=uint16 (_caa >>7);_fdc |=uint16 (_gaf >>7);_ffb =uint16 (_eb );_caag :=_dge %8;_gca :=_dge /8+1;if _caag ==5+ox {_fge ,_gcg ,_caa =0,0,0;if _gca < iTemp .RowStride &&_bdb >=1&&(_bdb -1)< iTemp .Height {_fge =iTemp .Data [(_bdb -1)*iTemp .RowStride +_gca ];
};if _gca < iTemp .RowStride &&_bdb >=0&&_bdb < iTemp .Height {_gcg =iTemp .Data [_bdb *iTemp .RowStride +_gca ];};if _gca < iTemp .RowStride &&_bdb >=-1&&(_bdb +1)< iTemp .Height {_caa =iTemp .Data [(_bdb +1)*iTemp .RowStride +_gca ];};}else {_fge <<=1;
_gcg <<=1;_caa <<=1;};if _caag ==5&&_ead >=1{_gaf =0;if _gca < iTarget .RowStride {_gaf =iTarget .Data [(_ead -1)*iTarget .RowStride +_gca ];};}else {_gaf <<=1;};if _caag ==7{_aca =0;if _gca < iTarget .RowStride {_aca =iTarget .Data [_ead *iTarget .RowStride +_gca ];
};}else {_aca <<=1;};_bg &=7;_gd &=7;_ee &=7;_fdc &=7;};};return nil ;};func (_ecb *Encoder )code1 (_eaa *codingContext ,_gdg uint32 ,_fcc uint16 ,_dgec byte ){if _eaa .mps (_gdg )==1{_ecb .codeMPS (_eaa ,_gdg ,_fcc ,_dgec );}else {_ecb .codeLPS (_eaa ,_gdg ,_fcc ,_dgec );
};};type codingContext struct{_ga []byte ;_cb []byte ;};func (_cgb *Encoder )flush (){_cgb .setBits ();_cgb ._fbc <<=_cgb ._cd ;_cgb .byteOut ();_cgb ._fbc <<=_cgb ._cd ;_cgb .byteOut ();_cgb .emit ();if _cgb ._ege !=0xff{_cgb ._ag ++;_cgb ._ege =0xff;
_cgb .emit ();};_cgb ._ag ++;_cgb ._ege =0xac;_cgb ._ag ++;_cgb .emit ();};const _ef =0x9b25;func (_bee *Encoder )setBits (){_agga :=_bee ._fbc +uint32 (_bee ._fd );_bee ._fbc |=0xffff;if _bee ._fbc >=_agga {_bee ._fbc -=0x8000;};};