//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_f "bytes";_e "github.com/unidoc/unipdf/v4/common";_a "github.com/unidoc/unipdf/v4/internal/jbig2/bitmap";_c "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_d "io";);func (_dcb *Encoder )EncodeInteger (proc Class ,value int )(_cc error ){_e .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _cc =_dcb .encodeInteger (proc ,value );_cc !=nil {return _c .Wrap (_cc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_cgae *Encoder )rBlock (){if _cgae ._dcg >=0{_cgae .emit ();};_cgae ._dcg ++;
_cgae ._abd =uint8 (_cgae ._aae >>20);_cgae ._aae &=0xfffff;_cgae ._ca =7;};func (_gcc *Encoder )dataSize ()int {return _faf *len (_gcc ._bf )+_gcc ._gac };func (_aa Class )String ()string {switch _aa {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};func (_ffd *Encoder )Reset (){_ffd ._dc =0x8000;_ffd ._aae =0;_ffd ._ca =12;_ffd ._dcg =-1;_ffd ._abd =0;_ffd ._cdb =nil ;_ffd ._ad =_df (_fbea );};type Encoder struct{_aae uint32 ;_dc uint16 ;_ca ,_abd uint8 ;_dcg int ;_af int ;_bf [][]byte ;_aaa []byte ;
_gac int ;_ad *codingContext ;_ac [13]*codingContext ;_cdb *codingContext ;};func (_fdb *Encoder )encodeBit (_deae *codingContext ,_dfb uint32 ,_fgd uint8 )error {const _fdc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_fdb ._af ++;if _dfb >=uint32 (len (_deae ._ed )){return _c .Errorf (_fdc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_dfb );
};_ebg :=_deae ._ed [_dfb ];_fgdb :=_deae .mps (_dfb );_cbfa :=_cgdb [_ebg ]._aaef ;_e .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_fdb ._af ,_fgd ,_ebg ,_fgdb ,_cbfa ,_fdb ._dc ,_fdb ._aae ,_fdb ._ca ,_fdb ._abd ,_fdb ._dcg );
if _fgd ==0{_fdb .code0 (_deae ,_dfb ,_cbfa ,_ebg );}else {_fdb .code1 (_deae ,_dfb ,_cbfa ,_ebg );};return nil ;};func (_dd *codingContext )mps (_abc uint32 )int {return int (_dd ._ab [_abc ])};func (_caa *Encoder )Flush (){_caa ._gac =0;_caa ._bf =nil ;
_caa ._dcg =-1};func _df (_ga int )*codingContext {return &codingContext {_ed :make ([]byte ,_ga ),_ab :make ([]byte ,_ga )};};func (_aag *Encoder )byteOut (){if _aag ._abd ==0xff{_aag .rBlock ();return ;};if _aag ._aae < 0x8000000{_aag .lBlock ();return ;
};_aag ._abd ++;if _aag ._abd !=0xff{_aag .lBlock ();return ;};_aag ._aae &=0x7ffffff;_aag .rBlock ();};func (_ecd *Encoder )encodeOOB (_ggb Class )error {_bdc :=_ecd ._ac [_ggb ];_fec :=_ecd .encodeBit (_bdc ,1,1);if _fec !=nil {return _fec ;};_fec =_ecd .encodeBit (_bdc ,3,0);
if _fec !=nil {return _fec ;};_fec =_ecd .encodeBit (_bdc ,6,0);if _fec !=nil {return _fec ;};_fec =_ecd .encodeBit (_bdc ,12,0);if _fec !=nil {return _fec ;};return nil ;};const _ce =0x9b25;const (_fbea =65536;_faf =20*1024;);func (_cfd *Encoder )codeLPS (_fee *codingContext ,_eg uint32 ,_ced uint16 ,_cga byte ){_cfd ._dc -=_ced ;
if _cfd ._dc < _ced {_cfd ._aae +=uint32 (_ced );}else {_cfd ._dc =_ced ;};if _cgdb [_cga ]._fga ==1{_fee .flipMps (_eg );};_fee ._ed [_eg ]=_cgdb [_cga ]._acf ;_cfd .renormalize ();};func (_cae *Encoder )lBlock (){if _cae ._dcg >=0{_cae .emit ();};_cae ._dcg ++;
_cae ._abd =uint8 (_cae ._aae >>19);_cae ._aae &=0x7ffff;_cae ._ca =8;};func (_efe *Encoder )encodeInteger (_cce Class ,_dcd int )error {const _bac ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _dcd > 2000000000||_dcd < -2000000000{return _c .Errorf (_bac ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_dcd );
};_bbc :=_efe ._ac [_cce ];_fbe :=uint32 (1);var _fed int ;for ;;_fed ++{if _ff [_fed ]._fd <=_dcd &&_ff [_fed ]._ee >=_dcd {break ;};};if _dcd < 0{_dcd =-_dcd ;};_dcd -=int (_ff [_fed ]._b );_fdfc :=_ff [_fed ]._eeg ;for _eea :=uint8 (0);_eea < _ff [_fed ]._dg ;
_eea ++{_da :=_fdfc &1;if _ddd :=_efe .encodeBit (_bbc ,_fbe ,_da );_ddd !=nil {return _c .Wrap (_ddd ,_bac ,"");};_fdfc >>=1;if _fbe &0x100> 0{_fbe =(((_fbe <<1)|uint32 (_da ))&0x1ff)|0x100;}else {_fbe =(_fbe <<1)|uint32 (_da );};};_dcd <<=32-_ff [_fed ]._cb ;
for _eae :=uint8 (0);_eae < _ff [_fed ]._cb ;_eae ++{_gcba :=uint8 ((uint32 (_dcd )&0x80000000)>>31);if _fdgd :=_efe .encodeBit (_bbc ,_fbe ,_gcba );_fdgd !=nil {return _c .Wrap (_fdgd ,_bac ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_dcd <<=1;if _fbe &0x100!=0{_fbe =(((_fbe <<1)|uint32 (_gcba ))&0x1ff)|0x100;}else {_fbe =(_fbe <<1)|uint32 (_gcba );};};return nil ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_cab *Encoder )renormalize (){for {_cab ._dc <<=1;
_cab ._aae <<=1;_cab ._ca --;if _cab ._ca ==0{_cab .byteOut ();};if (_cab ._dc &0x8000)!=0{break ;};};};func (_ageb *Encoder )flush (){_ageb .setBits ();_ageb ._aae <<=_ageb ._ca ;_ageb .byteOut ();_ageb ._aae <<=_ageb ._ca ;_ageb .byteOut ();_ageb .emit ();
if _ageb ._abd !=0xff{_ageb ._dcg ++;_ageb ._abd =0xff;_ageb .emit ();};_ageb ._dcg ++;_ageb ._abd =0xac;_ageb ._dcg ++;_ageb .emit ();};func (_fe *codingContext )flipMps (_cd uint32 ){_fe ._ab [_cd ]=1-_fe ._ab [_cd ]};func (_aad *Encoder )codeMPS (_ddg *codingContext ,_bb uint32 ,_aff uint16 ,_ba byte ){_aad ._dc -=_aff ;
if _aad ._dc &0x8000!=0{_aad ._aae +=uint32 (_aff );return ;};if _aad ._dc < _aff {_aad ._dc =_aff ;}else {_aad ._aae +=uint32 (_aff );};_ddg ._ed [_bb ]=_cgdb [_ba ]._ace ;_aad .renormalize ();};func (_dca *Encoder )EncodeBitmap (bm *_a .Bitmap ,duplicateLineRemoval bool )error {_e .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_aaf ,_eb uint8 ;_ef ,_bc ,_gab uint16 ;_afc ,_edc ,_fb byte ;_db ,_dgg ,_bcf int ;_bcb ,_fc []byte ;);for _gg :=0;_gg < bm .Height ;_gg ++{_afc ,_edc =0,0;if _gg >=2{_afc =bm .Data [(_gg -2)*bm .RowStride ];};if _gg >=1{_edc =bm .Data [(_gg -1)*bm .RowStride ];
if duplicateLineRemoval {_dgg =_gg *bm .RowStride ;_bcb =bm .Data [_dgg :_dgg +bm .RowStride ];_bcf =(_gg -1)*bm .RowStride ;_fc =bm .Data [_bcf :_bcf +bm .RowStride ];if _f .Equal (_bcb ,_fc ){_eb =_aaf ^1;_aaf =1;}else {_eb =_aaf ;_aaf =0;};};};if duplicateLineRemoval {if _ggc :=_dca .encodeBit (_dca ._ad ,_ce ,_eb );
_ggc !=nil {return _ggc ;};if _aaf !=0{continue ;};};_fb =bm .Data [_gg *bm .RowStride ];_ef =uint16 (_afc >>5);_bc =uint16 (_edc >>4);_afc <<=3;_edc <<=4;_gab =0;for _db =0;_db < bm .Width ;_db ++{_ggcb :=uint32 (_ef <<11|_bc <<4|_gab );_bd :=(_fb &0x80)>>7;
_de :=_dca .encodeBit (_dca ._ad ,_ggcb ,_bd );if _de !=nil {return _de ;};_ef <<=1;_bc <<=1;_gab <<=1;_ef |=uint16 ((_afc &0x80)>>7);_bc |=uint16 ((_edc &0x80)>>7);_gab |=uint16 (_bd );_dea :=_db %8;_eff :=_db /8+1;if _dea ==4&&_gg >=2{_afc =0;if _eff < bm .RowStride {_afc =bm .Data [(_gg -2)*bm .RowStride +_eff ];
};}else {_afc <<=1;};if _dea ==3&&_gg >=1{_edc =0;if _eff < bm .RowStride {_edc =bm .Data [(_gg -1)*bm .RowStride +_eff ];};}else {_edc <<=1;};if _dea ==7{_fb =0;if _eff < bm .RowStride {_fb =bm .Data [_gg *bm .RowStride +_eff ];};}else {_fb <<=1;};_ef &=31;
_bc &=127;_gab &=15;};};return nil ;};var _ff =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_gd *Encoder )Refine (iTemp ,iTarget *_a .Bitmap ,ox ,oy int )error {for _dce :=0;_dce < iTarget .Height ;_dce ++{var _gge int ;_ge :=_dce +oy ;var (_acg ,_ea ,_deaf ,_gca ,_def uint16 ;_fdf ,_cbb ,_acc ,_fdg ,_gdb byte ;);if _ge >=1&&(_ge -1)< iTemp .Height {_fdf =iTemp .Data [(_ge -1)*iTemp .RowStride ];
};if _ge >=0&&_ge < iTemp .Height {_cbb =iTemp .Data [_ge *iTemp .RowStride ];};if _ge >=-1&&_ge +1< iTemp .Height {_acc =iTemp .Data [(_ge +1)*iTemp .RowStride ];};if _dce >=1{_fdg =iTarget .Data [(_dce -1)*iTarget .RowStride ];};_gdb =iTarget .Data [_dce *iTarget .RowStride ];
_gb :=uint (6+ox );_acg =uint16 (_fdf >>_gb );_ea =uint16 (_cbb >>_gb );_deaf =uint16 (_acc >>_gb );_gca =uint16 (_fdg >>6);_afg :=uint (2-ox );_fdf <<=_afg ;_cbb <<=_afg ;_acc <<=_afg ;_fdg <<=2;for _gge =0;_gge < iTarget .Width ;_gge ++{_aaeg :=(_acg <<10)|(_ea <<7)|(_deaf <<4)|(_gca <<1)|_def ;
_cg :=_gdb >>7;_cgd :=_gd .encodeBit (_gd ._ad ,uint32 (_aaeg ),_cg );if _cgd !=nil {return _cgd ;};_acg <<=1;_ea <<=1;_deaf <<=1;_gca <<=1;_acg |=uint16 (_fdf >>7);_ea |=uint16 (_cbb >>7);_deaf |=uint16 (_acc >>7);_gca |=uint16 (_fdg >>7);_def =uint16 (_cg );
_gce :=_gge %8;_edd :=_gge /8+1;if _gce ==5+ox {_fdf ,_cbb ,_acc =0,0,0;if _edd < iTemp .RowStride &&_ge >=1&&(_ge -1)< iTemp .Height {_fdf =iTemp .Data [(_ge -1)*iTemp .RowStride +_edd ];};if _edd < iTemp .RowStride &&_ge >=0&&_ge < iTemp .Height {_cbb =iTemp .Data [_ge *iTemp .RowStride +_edd ];
};if _edd < iTemp .RowStride &&_ge >=-1&&(_ge +1)< iTemp .Height {_acc =iTemp .Data [(_ge +1)*iTemp .RowStride +_edd ];};}else {_fdf <<=1;_cbb <<=1;_acc <<=1;};if _gce ==5&&_dce >=1{_fdg =0;if _edd < iTarget .RowStride {_fdg =iTarget .Data [(_dce -1)*iTarget .RowStride +_edd ];
};}else {_fdg <<=1;};if _gce ==7{_gdb =0;if _edd < iTarget .RowStride {_gdb =iTarget .Data [_dce *iTarget .RowStride +_edd ];};}else {_gdb <<=1;};_acg &=7;_ea &=7;_deaf &=7;_gca &=7;};};return nil ;};func (_dcc *Encoder )setBits (){_eag :=_dcc ._aae +uint32 (_dcc ._dc );
_dcc ._aae |=0xffff;if _dcc ._aae >=_eag {_dcc ._aae -=0x8000;};};func (_fdd *Encoder )DataSize ()int {return _fdd .dataSize ()};func (_fgc *Encoder )code0 (_fa *codingContext ,_cdd uint32 ,_ebe uint16 ,_ag byte ){if _fa .mps (_cdd )==0{_fgc .codeMPS (_fa ,_cdd ,_ebe ,_ag );
}else {_fgc .codeLPS (_fa ,_cdd ,_ebe ,_ag );};};var _cgdb =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
type intEncRangeS struct{_fd ,_ee int ;_eeg ,_dg uint8 ;_b uint16 ;_cb uint8 ;};func (_ceg *Encoder )encodeIAID (_fbf ,_adb int )error {if _ceg ._cdb ==nil {_ceg ._cdb =_df (1<<uint (_fbf ));};_cedg :=uint32 (1<<uint32 (_fbf +1))-1;_adb <<=uint (32-_fbf );
_gba :=uint32 (1);for _fae :=0;_fae < _fbf ;_fae ++{_dffb :=_gba &_cedg ;_baa :=uint8 ((uint32 (_adb )&0x80000000)>>31);if _eddd :=_ceg .encodeBit (_ceg ._cdb ,_dffb ,_baa );_eddd !=nil {return _eddd ;};_gba =(_gba <<1)|uint32 (_baa );_adb <<=1;};return nil ;
};type codingContext struct{_ed []byte ;_ab []byte ;};func (_dfa *Encoder )Init (){_dfa ._ad =_df (_fbea );_dfa ._dc =0x8000;_dfa ._aae =0;_dfa ._ca =12;_dfa ._dcg =-1;_dfa ._abd =0;_dfa ._gac =0;_dfa ._aaa =make ([]byte ,_faf );for _dff :=0;_dff < len (_dfa ._ac );
_dff ++{_dfa ._ac [_dff ]=_df (512);};_dfa ._cdb =nil ;};func New ()*Encoder {_dgd :=&Encoder {};_dgd .Init ();return _dgd };func (_fef *Encoder )emit (){if _fef ._gac ==_faf {_fef ._bf =append (_fef ._bf ,_fef ._aaa );_fef ._aaa =make ([]byte ,_faf );
_fef ._gac =0;};_fef ._aaa [_fef ._gac ]=_fef ._abd ;_fef ._gac ++;};type state struct{_aaef uint16 ;_ace ,_acf uint8 ;_fga uint8 ;};type Class int ;func (_cee *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gc error ){_e .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _gc =_cee .encodeIAID (symbolCodeLength ,value );_gc !=nil {return _c .Wrap (_gc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_fg *Encoder )EncodeOOB (proc Class )(_afd error ){_e .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _afd =_fg .encodeOOB (proc );_afd !=nil {return _c .Wrap (_afd ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_gf *Encoder )WriteTo (w _d .Writer )(int64 ,error ){const _dcf ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _eaf int64 ;for _edb ,_eed :=range _gf ._bf {_cbf ,_gcb :=w .Write (_eed );if _gcb !=nil {return 0,_c .Wrapf (_gcb ,_dcf ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_edb );
};_eaf +=int64 (_cbf );};_gf ._aaa =_gf ._aaa [:_gf ._gac ];_ec ,_ggg :=w .Write (_gf ._aaa );if _ggg !=nil {return 0,_c .Wrap (_ggg ,_dcf ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_eaf +=int64 (_ec );return _eaf ,nil ;
};func (_deb *Encoder )Final (){_deb .flush ()};var _ _d .WriterTo =&Encoder {};func (_edg *Encoder )code1 (_cbd *codingContext ,_cf uint32 ,_age uint16 ,_bfd byte ){if _cbd .mps (_cf )==1{_edg .codeMPS (_cbd ,_cf ,_age ,_bfd );}else {_edg .codeLPS (_cbd ,_cf ,_age ,_bfd );
};};