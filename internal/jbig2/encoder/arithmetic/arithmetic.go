//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_ace "github.com/unidoc/unipdf/v3/common";_e "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_c "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ac "io";);func (_gf *Encoder )Init (){_gf ._bd =_cg (_fde );
_gf ._ag =0x8000;_gf ._cb =0;_gf ._b =12;_gf ._bb =-1;_gf ._gda =0;_gf ._bg =0;_gf ._eb =make ([]byte ,_aad );for _be :=0;_be < len (_gf ._ad );_be ++{_gf ._ad [_be ]=_cg (512);};_gf ._bgg =nil ;};func (_ff *codingContext )mps (_fe uint32 )int {return int (_ff ._da [_fe ])};
func (_fc *Encoder )EncodeBitmap (bm *_e .Bitmap ,duplicateLineRemoval bool )error {_ace .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_efc ,_bga uint8 ;_cbf ,_bc ,_db uint16 ;_fcf ,_fb ,_efd byte ;_egc ,_cf ,_gg int ;_fee ,_ggc []byte ;);for _ba :=0;_ba < bm .Height ;_ba ++{_fcf ,_fb =0,0;if _ba >=2{_fcf =bm .Data [(_ba -2)*bm .RowStride ];};if _ba >=1{_fb =bm .Data [(_ba -1)*bm .RowStride ];
if duplicateLineRemoval {_cf =_ba *bm .RowStride ;_fee =bm .Data [_cf :_cf +bm .RowStride ];_gg =(_ba -1)*bm .RowStride ;_ggc =bm .Data [_gg :_gg +bm .RowStride ];if _a .Equal (_fee ,_ggc ){_bga =_efc ^1;_efc =1;}else {_bga =_efc ;_efc =0;};};};if duplicateLineRemoval {if _dbd :=_fc .encodeBit (_fc ._bd ,_cbb ,_bga );
_dbd !=nil {return _dbd ;};if _efc !=0{continue ;};};_efd =bm .Data [_ba *bm .RowStride ];_cbf =uint16 (_fcf >>5);_bc =uint16 (_fb >>4);_fcf <<=3;_fb <<=4;_db =0;for _egc =0;_egc < bm .Width ;_egc ++{_bge :=uint32 (_cbf <<11|_bc <<4|_db );_af :=(_efd &0x80)>>7;
_bf :=_fc .encodeBit (_fc ._bd ,_bge ,_af );if _bf !=nil {return _bf ;};_cbf <<=1;_bc <<=1;_db <<=1;_cbf |=uint16 ((_fcf &0x80)>>7);_bc |=uint16 ((_fb &0x80)>>7);_db |=uint16 (_af );_cce :=_egc %8;_bggc :=_egc /8+1;if _cce ==4&&_ba >=2{_fcf =0;if _bggc < bm .RowStride {_fcf =bm .Data [(_ba -2)*bm .RowStride +_bggc ];
};}else {_fcf <<=1;};if _cce ==3&&_ba >=1{_fb =0;if _bggc < bm .RowStride {_fb =bm .Data [(_ba -1)*bm .RowStride +_bggc ];};}else {_fb <<=1;};if _cce ==7{_efd =0;if _bggc < bm .RowStride {_efd =bm .Data [_ba *bm .RowStride +_bggc ];};}else {_efd <<=1;};
_cbf &=31;_bc &=127;_db &=15;};};return nil ;};func _cg (_ed int )*codingContext {return &codingContext {_ga :make ([]byte ,_ed ),_da :make ([]byte ,_ed )};};func (_eagg *Encoder )code1 (_aga *codingContext ,_fa uint32 ,_gaa uint16 ,_gga byte ){if _aga .mps (_fa )==1{_eagg .codeMPS (_aga ,_fa ,_gaa ,_gga );
}else {_eagg .codeLPS (_aga ,_fa ,_gaa ,_gga );};};type codingContext struct{_ga []byte ;_da []byte ;};func (_dd *Encoder )EncodeIAID (symbolCodeLength ,value int )(_cfa error ){_ace .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _cfa =_dd .encodeIAID (symbolCodeLength ,value );_cfa !=nil {return _c .Wrap (_cfa ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};type intEncRangeS struct{_gb ,_gd int ;_d ,_fg uint8 ;_de uint16 ;_fd uint8 ;};type Encoder struct{_cb uint32 ;
_ag uint16 ;_b ,_gda uint8 ;_bb int ;_df int ;_eg [][]byte ;_eb []byte ;_bg int ;_bd *codingContext ;_ad [13]*codingContext ;_bgg *codingContext ;};func (_ffba *Encoder )encodeInteger (_acb Class ,_ddc int )error {const _ge ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _ddc > 2000000000||_ddc < -2000000000{return _c .Errorf (_ge ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_ddc );
};_cba :=_ffba ._ad [_acb ];_eeb :=uint32 (1);var _adge int ;for ;;_adge ++{if _cc [_adge ]._gb <=_ddc &&_cc [_adge ]._gd >=_ddc {break ;};};if _ddc < 0{_ddc =-_ddc ;};_ddc -=int (_cc [_adge ]._de );_afb :=_cc [_adge ]._d ;for _adf :=uint8 (0);_adf < _cc [_adge ]._fg ;
_adf ++{_gef :=_afb &1;if _cd :=_ffba .encodeBit (_cba ,_eeb ,_gef );_cd !=nil {return _c .Wrap (_cd ,_ge ,"");};_afb >>=1;if _eeb &0x100> 0{_eeb =(((_eeb <<1)|uint32 (_gef ))&0x1ff)|0x100;}else {_eeb =(_eeb <<1)|uint32 (_gef );};};_ddc <<=32-_cc [_adge ]._fd ;
for _ec :=uint8 (0);_ec < _cc [_adge ]._fd ;_ec ++{_cea :=uint8 ((uint32 (_ddc )&0x80000000)>>31);if _bad :=_ffba .encodeBit (_cba ,_eeb ,_cea );_bad !=nil {return _c .Wrap (_bad ,_ge ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_ddc <<=1;if _eeb &0x100!=0{_eeb =(((_eeb <<1)|uint32 (_cea ))&0x1ff)|0x100;}else {_eeb =(_eeb <<1)|uint32 (_cea );};};return nil ;};func (_ebb *Encoder )Refine (iTemp ,iTarget *_e .Bitmap ,ox ,oy int )error {for _agf :=0;_agf < iTarget .Height ;_agf ++{var _bda int ;
_dbf :=_agf +oy ;var (_bea ,_ea ,_deg ,_gba ,_bbf uint16 ;_ee ,_cge ,_edd ,_bgf ,_bbg byte ;);if _dbf >=1&&(_dbf -1)< iTemp .Height {_ee =iTemp .Data [(_dbf -1)*iTemp .RowStride ];};if _dbf >=0&&_dbf < iTemp .Height {_cge =iTemp .Data [_dbf *iTemp .RowStride ];
};if _dbf >=-1&&_dbf +1< iTemp .Height {_edd =iTemp .Data [(_dbf +1)*iTemp .RowStride ];};if _agf >=1{_bgf =iTarget .Data [(_agf -1)*iTarget .RowStride ];};_bbg =iTarget .Data [_agf *iTarget .RowStride ];_ffb :=uint (6+ox );_bea =uint16 (_ee >>_ffb );_ea =uint16 (_cge >>_ffb );
_deg =uint16 (_edd >>_ffb );_gba =uint16 (_bgf >>6);_eag :=uint (2-ox );_ee <<=_eag ;_cge <<=_eag ;_edd <<=_eag ;_bgf <<=2;for _bda =0;_bda < iTarget .Width ;_bda ++{_ega :=(_bea <<10)|(_ea <<7)|(_deg <<4)|(_gba <<1)|_bbf ;_aec :=_bbg >>7;_gdd :=_ebb .encodeBit (_ebb ._bd ,uint32 (_ega ),_aec );
if _gdd !=nil {return _gdd ;};_bea <<=1;_ea <<=1;_deg <<=1;_gba <<=1;_bea |=uint16 (_ee >>7);_ea |=uint16 (_cge >>7);_deg |=uint16 (_edd >>7);_gba |=uint16 (_bgf >>7);_bbf =uint16 (_aec );_adc :=_bda %8;_def :=_bda /8+1;if _adc ==5+ox {_ee ,_cge ,_edd =0,0,0;
if _def < iTemp .RowStride &&_dbf >=1&&(_dbf -1)< iTemp .Height {_ee =iTemp .Data [(_dbf -1)*iTemp .RowStride +_def ];};if _def < iTemp .RowStride &&_dbf >=0&&_dbf < iTemp .Height {_cge =iTemp .Data [_dbf *iTemp .RowStride +_def ];};if _def < iTemp .RowStride &&_dbf >=-1&&(_dbf +1)< iTemp .Height {_edd =iTemp .Data [(_dbf +1)*iTemp .RowStride +_def ];
};}else {_ee <<=1;_cge <<=1;_edd <<=1;};if _adc ==5&&_agf >=1{_bgf =0;if _def < iTarget .RowStride {_bgf =iTarget .Data [(_agf -1)*iTarget .RowStride +_def ];};}else {_bgf <<=1;};if _adc ==7{_bbg =0;if _def < iTarget .RowStride {_bbg =iTarget .Data [_agf *iTarget .RowStride +_def ];
};}else {_bbg <<=1;};_bea &=7;_ea &=7;_deg &=7;_gba &=7;};};return nil ;};func New ()*Encoder {_bdf :=&Encoder {};_bdf .Init ();return _bdf };func (_cgg *Encoder )emit (){if _cgg ._bg ==_aad {_cgg ._eg =append (_cgg ._eg ,_cgg ._eb );_cgg ._eb =make ([]byte ,_aad );
_cgg ._bg =0;};_cgg ._eb [_cgg ._bg ]=_cgg ._gda ;_cgg ._bg ++;};func (_bae *Encoder )codeLPS (_gc *codingContext ,_aa uint32 ,_cgd uint16 ,_fad byte ){_bae ._ag -=_cgd ;if _bae ._ag < _cgd {_bae ._cb +=uint32 (_cgd );}else {_bae ._ag =_cgd ;};if _cbfc [_fad ]._baeb ==1{_gc .flipMps (_aa );
};_gc ._ga [_aa ]=_cbfc [_fad ]._ddb ;_bae .renormalize ();};func (_bca *Encoder )EncodeOOB (proc Class )(_gbb error ){_ace .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _gbb =_bca .encodeOOB (proc );_gbb !=nil {return _c .Wrap (_gbb ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_acf *Encoder )Flush (){_acf ._bg =0;_acf ._eg =nil ;_acf ._bb =-1};const _cbb =0x9b25;func (_ede *Encoder )dataSize ()int {return _aad *len (_ede ._eg )+_ede ._bg };
func (_aafb *Encoder )lBlock (){if _aafb ._bb >=0{_aafb .emit ();};_aafb ._bb ++;_aafb ._gda =uint8 (_aafb ._cb >>19);_aafb ._cb &=0x7ffff;_aafb ._b =8;};func (_cggc *Encoder )renormalize (){for {_cggc ._ag <<=1;_cggc ._cb <<=1;_cggc ._b --;if _cggc ._b ==0{_cggc .byteOut ();
};if (_cggc ._ag &0x8000)!=0{break ;};};};func (_aaf *Encoder )flush (){_aaf .setBits ();_aaf ._cb <<=_aaf ._b ;_aaf .byteOut ();_aaf ._cb <<=_aaf ._b ;_aaf .byteOut ();_aaf .emit ();if _aaf ._gda !=0xff{_aaf ._bb ++;_aaf ._gda =0xff;_aaf .emit ();};_aaf ._bb ++;
_aaf ._gda =0xac;_aaf ._bb ++;_aaf .emit ();};func (_egb *Encoder )encodeBit (_adg *codingContext ,_fba uint32 ,_bec uint8 )error {const _eac ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_egb ._df ++;
if _fba >=uint32 (len (_adg ._ga )){return _c .Errorf (_eac ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fba );
};_beca :=_adg ._ga [_fba ];_bfg :=_adg .mps (_fba );_dc :=_cbfc [_beca ]._dfd ;_ace .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_egb ._df ,_bec ,_beca ,_bfg ,_dc ,_egb ._ag ,_egb ._cb ,_egb ._b ,_egb ._gda ,_egb ._bb );
if _bec ==0{_egb .code0 (_adg ,_fba ,_dc ,_beca );}else {_egb .code1 (_adg ,_fba ,_dc ,_beca );};return nil ;};var _cbfc =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_ca *Encoder )setBits (){_bff :=_ca ._cb +uint32 (_ca ._ag );_ca ._cb |=0xffff;if _ca ._cb >=_bff {_ca ._cb -=0x8000;};};func (_bcg *Encoder )codeMPS (_aca *codingContext ,_bee uint32 ,_dde uint16 ,_ab byte ){_bcg ._ag -=_dde ;if _bcg ._ag &0x8000!=0{_bcg ._cb +=uint32 (_dde );
return ;};if _bcg ._ag < _dde {_bcg ._ag =_dde ;}else {_bcg ._cb +=uint32 (_dde );};_aca ._ga [_bee ]=_cbfc [_ab ]._dbaa ;_bcg .renormalize ();};func (_f Class )String ()string {switch _f {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};type Class int ;var _ _ac .WriterTo =&Encoder {};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);var _cc =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_ada *Encoder )rBlock (){if _ada ._bb >=0{_ada .emit ();};_ada ._bb ++;_ada ._gda =uint8 (_ada ._cb >>20);_ada ._cb &=0xfffff;_ada ._b =7;};func (_eddf *Encoder )Reset (){_eddf ._ag =0x8000;_eddf ._cb =0;_eddf ._b =12;_eddf ._bb =-1;_eddf ._gda =0;
_eddf ._bgg =nil ;_eddf ._bd =_cg (_fde );};func (_gbba *Encoder )encodeOOB (_bdac Class )error {_egbg :=_gbba ._ad [_bdac ];_beeg :=_gbba .encodeBit (_egbg ,1,1);if _beeg !=nil {return _beeg ;};_beeg =_gbba .encodeBit (_egbg ,3,0);if _beeg !=nil {return _beeg ;
};_beeg =_gbba .encodeBit (_egbg ,6,0);if _beeg !=nil {return _beeg ;};_beeg =_gbba .encodeBit (_egbg ,12,0);if _beeg !=nil {return _beeg ;};return nil ;};func (_ae *Encoder )EncodeInteger (proc Class ,value int )(_dac error ){_ace .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _dac =_ae .encodeInteger (proc ,value );_dac !=nil {return _c .Wrap (_dac ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type state struct{_dfd uint16 ;_dbaa ,_ddb uint8 ;_baeb uint8 ;};func (_ce *Encoder )code0 (_fgg *codingContext ,_ccf uint32 ,_efa uint16 ,_edg byte ){if _fgg .mps (_ccf )==0{_ce .codeMPS (_fgg ,_ccf ,_efa ,_edg );
}else {_ce .codeLPS (_fgg ,_ccf ,_efa ,_edg );};};func (_gad *Encoder )byteOut (){if _gad ._gda ==0xff{_gad .rBlock ();return ;};if _gad ._cb < 0x8000000{_gad .lBlock ();return ;};_gad ._gda ++;if _gad ._gda !=0xff{_gad .lBlock ();return ;};_gad ._cb &=0x7ffffff;
_gad .rBlock ();};func (_efce *Encoder )WriteTo (w _ac .Writer )(int64 ,error ){const _add ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _fea int64 ;for _cfd ,_dg :=range _efce ._eg {_eba ,_dad :=w .Write (_dg );
if _dad !=nil {return 0,_c .Wrapf (_dad ,_add ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_cfd );};_fea +=int64 (_eba );};_efce ._eb =_efce ._eb [:_efce ._bg ];
_ccg ,_dba :=w .Write (_efce ._eb );if _dba !=nil {return 0,_c .Wrap (_dba ,_add ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_fea +=int64 (_ccg );return _fea ,nil ;};func (_bcaa *Encoder )Final (){_bcaa .flush ()};
func (_fag *Encoder )encodeIAID (_ebf ,_gfb int )error {if _fag ._bgg ==nil {_fag ._bgg =_cg (1<<uint (_ebf ));};_cee :=uint32 (1<<uint32 (_ebf +1))-1;_gfb <<=uint (32-_ebf );_dfg :=uint32 (1);for _bgd :=0;_bgd < _ebf ;_bgd ++{_dcd :=_dfg &_cee ;_ccee :=uint8 ((uint32 (_gfb )&0x80000000)>>31);
if _bde :=_fag .encodeBit (_fag ._bgg ,_dcd ,_ccee );_bde !=nil {return _bde ;};_dfg =(_dfg <<1)|uint32 (_ccee );_gfb <<=1;};return nil ;};const (_fde =65536;_aad =20*1024;);func (_ccc *codingContext )flipMps (_ef uint32 ){_ccc ._da [_ef ]=1-_ccc ._da [_ef ]};
func (_ebg *Encoder )DataSize ()int {return _ebg .dataSize ()};