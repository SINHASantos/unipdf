//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_g "bytes";_b "github.com/unidoc/unipdf/v3/common";_fb "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_d "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);type state struct{_fbbf uint16 ;_cda ,_eefb uint8 ;_bdfd uint8 ;
};type codingContext struct{_ec []byte ;_bf []byte ;};func (_dg *Encoder )EncodeBitmap (bm *_fb .Bitmap ,duplicateLineRemoval bool )error {_b .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_ga ,_ce uint8 ;_gb ,_fcf ,_af uint16 ;_dge ,_bgg ,_bc byte ;_deaa ,_dcb ,_gc int ;_efa ,_feg []byte ;);for _eg :=0;_eg < bm .Height ;_eg ++{_dge ,_bgg =0,0;if _eg >=2{_dge =bm .Data [(_eg -2)*bm .RowStride ];};if _eg >=1{_bgg =bm .Data [(_eg -1)*bm .RowStride ];
if duplicateLineRemoval {_dcb =_eg *bm .RowStride ;_efa =bm .Data [_dcb :_dcb +bm .RowStride ];_gc =(_eg -1)*bm .RowStride ;_feg =bm .Data [_gc :_gc +bm .RowStride ];if _g .Equal (_efa ,_feg ){_ce =_ga ^1;_ga =1;}else {_ce =_ga ;_ga =0;};};};if duplicateLineRemoval {if _ad :=_dg .encodeBit (_dg ._ge ,_aac ,_ce );
_ad !=nil {return _ad ;};if _ga !=0{continue ;};};_bc =bm .Data [_eg *bm .RowStride ];_gb =uint16 (_dge >>5);_fcf =uint16 (_bgg >>4);_dge <<=3;_bgg <<=4;_af =0;for _deaa =0;_deaa < bm .Width ;_deaa ++{_dgf :=uint32 (_gb <<11|_fcf <<4|_af );_fba :=(_bc &0x80)>>7;
_cgg :=_dg .encodeBit (_dg ._ge ,_dgf ,_fba );if _cgg !=nil {return _cgg ;};_gb <<=1;_fcf <<=1;_af <<=1;_gb |=uint16 ((_dge &0x80)>>7);_fcf |=uint16 ((_bgg &0x80)>>7);_af |=uint16 (_fba );_ecc :=_deaa %8;_cc :=_deaa /8+1;if _ecc ==4&&_eg >=2{_dge =0;if _cc < bm .RowStride {_dge =bm .Data [(_eg -2)*bm .RowStride +_cc ];
};}else {_dge <<=1;};if _ecc ==3&&_eg >=1{_bgg =0;if _cc < bm .RowStride {_bgg =bm .Data [(_eg -1)*bm .RowStride +_cc ];};}else {_bgg <<=1;};if _ecc ==7{_bc =0;if _cc < bm .RowStride {_bc =bm .Data [_eg *bm .RowStride +_cc ];};}else {_bc <<=1;};_gb &=31;
_fcf &=127;_af &=15;};};return nil ;};func (_gd *Encoder )Refine (iTemp ,iTarget *_fb .Bitmap ,ox ,oy int )error {for _bd :=0;_bd < iTarget .Height ;_bd ++{var _afd int ;_ggf :=_bd +oy ;var (_fdb ,_ae ,_ecf ,_cbd ,_fg uint16 ;_fea ,_bga ,_eab ,_ddf ,_gcb byte ;
);if _ggf >=1&&(_ggf -1)< iTemp .Height {_fea =iTemp .Data [(_ggf -1)*iTemp .RowStride ];};if _ggf >=0&&_ggf < iTemp .Height {_bga =iTemp .Data [_ggf *iTemp .RowStride ];};if _ggf >=-1&&_ggf +1< iTemp .Height {_eab =iTemp .Data [(_ggf +1)*iTemp .RowStride ];
};if _bd >=1{_ddf =iTarget .Data [(_bd -1)*iTarget .RowStride ];};_gcb =iTarget .Data [_bd *iTarget .RowStride ];_ag :=uint (6+ox );_fdb =uint16 (_fea >>_ag );_ae =uint16 (_bga >>_ag );_ecf =uint16 (_eab >>_ag );_cbd =uint16 (_ddf >>6);_da :=uint (2-ox );
_fea <<=_da ;_bga <<=_da ;_eab <<=_da ;_ddf <<=2;for _afd =0;_afd < iTarget .Width ;_afd ++{_ffag :=(_fdb <<10)|(_ae <<7)|(_ecf <<4)|(_cbd <<1)|_fg ;_dbg :=_gcb >>7;_gde :=_gd .encodeBit (_gd ._ge ,uint32 (_ffag ),_dbg );if _gde !=nil {return _gde ;};_fdb <<=1;
_ae <<=1;_ecf <<=1;_cbd <<=1;_fdb |=uint16 (_fea >>7);_ae |=uint16 (_bga >>7);_ecf |=uint16 (_eab >>7);_cbd |=uint16 (_ddf >>7);_fg =uint16 (_dbg );_fbg :=_afd %8;_egc :=_afd /8+1;if _fbg ==5+ox {_fea ,_bga ,_eab =0,0,0;if _egc < iTemp .RowStride &&_ggf >=1&&(_ggf -1)< iTemp .Height {_fea =iTemp .Data [(_ggf -1)*iTemp .RowStride +_egc ];
};if _egc < iTemp .RowStride &&_ggf >=0&&_ggf < iTemp .Height {_bga =iTemp .Data [_ggf *iTemp .RowStride +_egc ];};if _egc < iTemp .RowStride &&_ggf >=-1&&(_ggf +1)< iTemp .Height {_eab =iTemp .Data [(_ggf +1)*iTemp .RowStride +_egc ];};}else {_fea <<=1;
_bga <<=1;_eab <<=1;};if _fbg ==5&&_bd >=1{_ddf =0;if _egc < iTarget .RowStride {_ddf =iTarget .Data [(_bd -1)*iTarget .RowStride +_egc ];};}else {_ddf <<=1;};if _fbg ==7{_gcb =0;if _egc < iTarget .RowStride {_gcb =iTarget .Data [_bd *iTarget .RowStride +_egc ];
};}else {_gcb <<=1;};_fdb &=7;_ae &=7;_ecf &=7;_cbd &=7;};};return nil ;};func (_egca *Encoder )Reset (){_egca ._ef =0x8000;_egca ._ff =0;_egca ._bb =12;_egca ._dea =-1;_egca ._ea =0;_egca ._ba =nil ;_egca ._ge =_db (_bfg );};func (_fd *Encoder )EncodeInteger (proc Class ,value int )(_ffg error ){_b .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _ffg =_fd .encodeInteger (proc ,value );_ffg !=nil {return _d .Wrap (_ffg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_cb *codingContext )flipMps (_aa uint32 ){_cb ._bf [_aa ]=1-_cb ._bf [_aa ]};
func (_bce *Encoder )flush (){_bce .setBits ();_bce ._ff <<=_bce ._bb ;_bce .byteOut ();_bce ._ff <<=_bce ._bb ;_bce .byteOut ();_bce .emit ();if _bce ._ea !=0xff{_bce ._dea ++;_bce ._ea =0xff;_bce .emit ();};_bce ._dea ++;_bce ._ea =0xac;_bce ._dea ++;
_bce .emit ();};type Class int ;func (_bab *Encoder )Flush (){_bab ._fc =0;_bab ._ffa =nil ;_bab ._dea =-1};func (_deg *Encoder )renormalize (){for {_deg ._ef <<=1;_deg ._ff <<=1;_deg ._bb --;if _deg ._bb ==0{_deg .byteOut ();};if (_deg ._ef &0x8000)!=0{break ;
};};};func (_cbb *Encoder )EncodeOOB (proc Class )(_gg error ){_b .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _gg =_cbb .encodeOOB (proc );
_gg !=nil {return _d .Wrap (_gg ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_abf *Encoder )code0 (_fcd *codingContext ,_bcd uint32 ,_gbb uint16 ,_eb byte ){if _fcd .mps (_bcd )==0{_abf .codeMPS (_fcd ,_bcd ,_gbb ,_eb );}else {_abf .codeLPS (_fcd ,_bcd ,_gbb ,_eb );
};};var _gbg =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_a *codingContext )mps (_ece uint32 )int {return int (_a ._bf [_ece ])};func (_edf *Encoder )codeMPS (_fgc *codingContext ,_adb uint32 ,_eef uint16 ,_aega byte ){_edf ._ef -=_eef ;if _edf ._ef &0x8000!=0{_edf ._ff +=uint32 (_eef );return ;};if _edf ._ef < _eef {_edf ._ef =_eef ;
}else {_edf ._ff +=uint32 (_eef );};_fgc ._ec [_adb ]=_gbg [_aega ]._cda ;_edf .renormalize ();};func _db (_dd int )*codingContext {return &codingContext {_ec :make ([]byte ,_dd ),_bf :make ([]byte ,_dd )};};func (_gba *Encoder )rBlock (){if _gba ._dea >=0{_gba .emit ();
};_gba ._dea ++;_gba ._ea =uint8 (_gba ._ff >>20);_gba ._ff &=0xfffff;_gba ._bb =7;};func (_gefd *Encoder )encodeIAID (_gga ,_bfb int )error {if _gefd ._ba ==nil {_gefd ._ba =_db (1<<uint (_gga ));};_efad :=uint32 (1<<uint32 (_gga +1))-1;_bfb <<=uint (32-_gga );
_ffe :=uint32 (1);for _fgg :=0;_fgg < _gga ;_fgg ++{_ggfg :=_ffe &_efad ;_egb :=uint8 ((uint32 (_bfb )&0x80000000)>>31);if _ffd :=_gefd .encodeBit (_gefd ._ba ,_ggfg ,_egb );_ffd !=nil {return _ffd ;};_ffe =(_ffe <<1)|uint32 (_egb );_bfb <<=1;};return nil ;
};type Encoder struct{_ff uint32 ;_ef uint16 ;_bb ,_ea uint8 ;_dea int ;_dbc int ;_ffa [][]byte ;_aad []byte ;_fc int ;_ge *codingContext ;_cf [13]*codingContext ;_ba *codingContext ;};func (_ab *Encoder )DataSize ()int {return _ab .dataSize ()};var _ _e .WriterTo =&Encoder {};
var _cg =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_gcf *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _gce ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _dde int64 ;for _gf ,_dbcb :=range _gcf ._ffa {_eea ,_faf :=w .Write (_dbcb );if _faf !=nil {return 0,_d .Wrapf (_faf ,_gce ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_gf );
};_dde +=int64 (_eea );};_gcf ._aad =_gcf ._aad [:_gcf ._fc ];_agb ,_eae :=w .Write (_gcf ._aad );if _eae !=nil {return 0,_d .Wrap (_eae ,_gce ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_dde +=int64 (_agb );return _dde ,nil ;
};func (_ecff *Encoder )byteOut (){if _ecff ._ea ==0xff{_ecff .rBlock ();return ;};if _ecff ._ff < 0x8000000{_ecff .lBlock ();return ;};_ecff ._ea ++;if _ecff ._ea !=0xff{_ecff .lBlock ();return ;};_ecff ._ff &=0x7ffffff;_ecff .rBlock ();};func (_bcf *Encoder )encodeOOB (_cbf Class )error {_fgdc :=_bcf ._cf [_cbf ];
_ddfe :=_bcf .encodeBit (_fgdc ,1,1);if _ddfe !=nil {return _ddfe ;};_ddfe =_bcf .encodeBit (_fgdc ,3,0);if _ddfe !=nil {return _ddfe ;};_ddfe =_bcf .encodeBit (_fgdc ,6,0);if _ddfe !=nil {return _ddfe ;};_ddfe =_bcf .encodeBit (_fgdc ,12,0);if _ddfe !=nil {return _ddfe ;
};return nil ;};const (_bfg =65536;_fdbf =20*1024;);func New ()*Encoder {_gef :=&Encoder {};_gef .Init ();return _gef };func (_ee *Encoder )Final (){_ee .flush ()};func (_fbb *Encoder )setBits (){_dbb :=_fbb ._ff +uint32 (_fbb ._ef );_fbb ._ff |=0xffff;
if _fbb ._ff >=_dbb {_fbb ._ff -=0x8000;};};func (_bbb *Encoder )emit (){if _bbb ._fc ==_fdbf {_bbb ._ffa =append (_bbb ._ffa ,_bbb ._aad );_bbb ._aad =make ([]byte ,_fdbf );_bbb ._fc =0;};_bbb ._aad [_bbb ._fc ]=_bbb ._ea ;_bbb ._fc ++;};const _aac =0x9b25;
func (_fa Class )String ()string {switch _fa {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";
case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";
case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};type intEncRangeS struct{_c ,_bg int ;_dc ,_fe uint8 ;_de uint16 ;_bge uint8 ;};func (_ed *Encoder )Init (){_ed ._ge =_db (_bfg );
_ed ._ef =0x8000;_ed ._ff =0;_ed ._bb =12;_ed ._dea =-1;_ed ._ea =0;_ed ._fc =0;_ed ._aad =make ([]byte ,_fdbf );for _cfa :=0;_cfa < len (_ed ._cf );_cfa ++{_ed ._cf [_cfa ]=_db (512);};_ed ._ba =nil ;};func (_bgc *Encoder )dataSize ()int {return _fdbf *len (_bgc ._ffa )+_bgc ._fc };
func (_fcb *Encoder )encodeInteger (_bfa Class ,_gfbf int )error {const _deac ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _gfbf > 2000000000||_gfbf < -2000000000{return _d .Errorf (_deac ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gfbf );
};_cfff :=_fcb ._cf [_bfa ];_bdf :=uint32 (1);var _fdc int ;for ;;_fdc ++{if _cg [_fdc ]._c <=_gfbf &&_cg [_fdc ]._bg >=_gfbf {break ;};};if _gfbf < 0{_gfbf =-_gfbf ;};_gfbf -=int (_cg [_fdc ]._de );_cge :=_cg [_fdc ]._dc ;for _cd :=uint8 (0);_cd < _cg [_fdc ]._fe ;
_cd ++{_bda :=_cge &1;if _ac :=_fcb .encodeBit (_cfff ,_bdf ,_bda );_ac !=nil {return _d .Wrap (_ac ,_deac ,"");};_cge >>=1;if _bdf &0x100> 0{_bdf =(((_bdf <<1)|uint32 (_bda ))&0x1ff)|0x100;}else {_bdf =(_bdf <<1)|uint32 (_bda );};};_gfbf <<=32-_cg [_fdc ]._bge ;
for _aab :=uint8 (0);_aab < _cg [_fdc ]._bge ;_aab ++{_df :=uint8 ((uint32 (_gfbf )&0x80000000)>>31);if _eee :=_fcb .encodeBit (_cfff ,_bdf ,_df );_eee !=nil {return _d .Wrap (_eee ,_deac ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_gfbf <<=1;if _bdf &0x100!=0{_bdf =(((_bdf <<1)|uint32 (_df ))&0x1ff)|0x100;}else {_bdf =(_bdf <<1)|uint32 (_df );};};return nil ;};func (_fgd *Encoder )codeLPS (_gcfb *codingContext ,_eba uint32 ,_cef uint16 ,_cefc byte ){_fgd ._ef -=_cef ;if _fgd ._ef < _cef {_fgd ._ff +=uint32 (_cef );
}else {_fgd ._ef =_cef ;};if _gbg [_cefc ]._bdfd ==1{_gcfb .flipMps (_eba );};_gcfb ._ec [_eba ]=_gbg [_cefc ]._eefb ;_fgd .renormalize ();};func (_ebe *Encoder )lBlock (){if _ebe ._dea >=0{_ebe .emit ();};_ebe ._dea ++;_ebe ._ea =uint8 (_ebe ._ff >>19);
_ebe ._ff &=0x7ffff;_ebe ._bb =8;};func (_gfa *Encoder )encodeBit (_ebb *codingContext ,_gcd uint32 ,_eabe uint8 )error {const _gbbc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_gfa ._dbc ++;if _gcd >=uint32 (len (_ebb ._ec )){return _d .Errorf (_gbbc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_gcd );
};_ecd :=_ebb ._ec [_gcd ];_bgcc :=_ebb .mps (_gcd );_fafc :=_gbg [_ecd ]._fbbf ;_b .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_gfa ._dbc ,_eabe ,_ecd ,_bgcc ,_fafc ,_gfa ._ef ,_gfa ._ff ,_gfa ._bb ,_gfa ._ea ,_gfa ._dea );
if _eabe ==0{_gfa .code0 (_ebb ,_gcd ,_fafc ,_ecd );}else {_gfa .code1 (_ebb ,_gcd ,_fafc ,_ecd );};return nil ;};func (_aeg *Encoder )code1 (_dce *codingContext ,_afdg uint32 ,_gfb uint16 ,_dbca byte ){if _dce .mps (_afdg )==1{_aeg .codeMPS (_dce ,_afdg ,_gfb ,_dbca );
}else {_aeg .codeLPS (_dce ,_afdg ,_gfb ,_dbca );};};func (_efd *Encoder )EncodeIAID (symbolCodeLength ,value int )(_cff error ){_b .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _cff =_efd .encodeIAID (symbolCodeLength ,value );_cff !=nil {return _d .Wrap (_cff ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;
IARDX ;IARDY ;IARI ;);