//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_d "bytes";_cb "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_gc *Encoder )Final (){_gc .flush ()};func (_gd Class )String ()string {switch _gd {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_f *codingContext )mps (_bb uint32 )int {return int (_f ._b [_bb ])};type Class int ;func (_eg *Encoder )EncodeOOB (proc Class )(_fab error ){_cb .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _fab =_eg .encodeOOB (proc );_fab !=nil {return _e .Wrap (_fab ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_ec *Encoder )EncodeBitmap (bm *_g .Bitmap ,duplicateLineRemoval bool )error {_cb .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_da ,_abd uint8 ;_de ,_ad ,_abb uint16 ;_adb ,_gdb ,_gefa byte ;_fa ,_gba ,_ae int ;_aa ,_dc []byte ;);for _cc :=0;_cc < bm .Height ;_cc ++{_adb ,_gdb =0,0;if _cc >=2{_adb =bm .Data [(_cc -2)*bm .RowStride ];};if _cc >=1{_gdb =bm .Data [(_cc -1)*bm .RowStride ];
if duplicateLineRemoval {_gba =_cc *bm .RowStride ;_aa =bm .Data [_gba :_gba +bm .RowStride ];_ae =(_cc -1)*bm .RowStride ;_dc =bm .Data [_ae :_ae +bm .RowStride ];if _d .Equal (_aa ,_dc ){_abd =_da ^1;_da =1;}else {_abd =_da ;_da =0;};};};if duplicateLineRemoval {if _cdb :=_ec .encodeBit (_ec ._ce ,_fc ,_abd );
_cdb !=nil {return _cdb ;};if _da !=0{continue ;};};_gefa =bm .Data [_cc *bm .RowStride ];_de =uint16 (_adb >>5);_ad =uint16 (_gdb >>4);_adb <<=3;_gdb <<=4;_abb =0;for _fa =0;_fa < bm .Width ;_fa ++{_gdd :=uint32 (_de <<11|_ad <<4|_abb );_fce :=(_gefa &0x80)>>7;
_cce :=_ec .encodeBit (_ec ._ce ,_gdd ,_fce );if _cce !=nil {return _cce ;};_de <<=1;_ad <<=1;_abb <<=1;_de |=uint16 ((_adb &0x80)>>7);_ad |=uint16 ((_gdb &0x80)>>7);_abb |=uint16 (_fce );_ca :=_fa %8;_dcc :=_fa /8+1;if _ca ==4&&_cc >=2{_adb =0;if _dcc < bm .RowStride {_adb =bm .Data [(_cc -2)*bm .RowStride +_dcc ];
};}else {_adb <<=1;};if _ca ==3&&_cc >=1{_gdb =0;if _dcc < bm .RowStride {_gdb =bm .Data [(_cc -1)*bm .RowStride +_dcc ];};}else {_gdb <<=1;};if _ca ==7{_gefa =0;if _dcc < bm .RowStride {_gefa =bm .Data [_cc *bm .RowStride +_dcc ];};}else {_gefa <<=1;};
_de &=31;_ad &=127;_abb &=15;};};return nil ;};const _fc =0x9b25;const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_gfa *Encoder )Reset (){_gfa ._ab =0x8000;_gfa ._agd =0;_gfa ._gb =12;_gfa ._fe =-1;
_gfa ._ge =0;_gfa ._bc =nil ;_gfa ._ce =_gge (_gab );};func (_bdb *Encoder )setBits (){_fff :=_bdb ._agd +uint32 (_bdb ._ab );_bdb ._agd |=0xffff;if _bdb ._agd >=_fff {_bdb ._agd -=0x8000;};};type codingContext struct{_ac []byte ;_b []byte ;};func (_dfg *Encoder )code0 (_bed *codingContext ,_fgb uint32 ,_cgg uint16 ,_fbe byte ){if _bed .mps (_fgb )==0{_dfg .codeMPS (_bed ,_fgb ,_cgg ,_fbe );
}else {_dfg .codeLPS (_bed ,_fgb ,_cgg ,_fbe );};};func (_dcce *Encoder )rBlock (){if _dcce ._fe >=0{_dcce .emit ();};_dcce ._fe ++;_dcce ._ge =uint8 (_dcce ._agd >>20);_dcce ._agd &=0xfffff;_dcce ._gb =7;};func (_dbdd *Encoder )flush (){_dbdd .setBits ();
_dbdd ._agd <<=_dbdd ._gb ;_dbdd .byteOut ();_dbdd ._agd <<=_dbdd ._gb ;_dbdd .byteOut ();_dbdd .emit ();if _dbdd ._ge !=0xff{_dbdd ._fe ++;_dbdd ._ge =0xff;_dbdd .emit ();};_dbdd ._fe ++;_dbdd ._ge =0xac;_dbdd ._fe ++;_dbdd .emit ();};func (_dge *Encoder )Init (){_dge ._ce =_gge (_gab );
_dge ._ab =0x8000;_dge ._agd =0;_dge ._gb =12;_dge ._fe =-1;_dge ._ge =0;_dge ._gf =0;_dge ._af =make ([]byte ,_dea );for _fb :=0;_fb < len (_dge ._gga );_fb ++{_dge ._gga [_fb ]=_gge (512);};_dge ._bc =nil ;};var _ _c .WriterTo =&Encoder {};func (_eba *Encoder )lBlock (){if _eba ._fe >=0{_eba .emit ();
};_eba ._fe ++;_eba ._ge =uint8 (_eba ._agd >>19);_eba ._agd &=0x7ffff;_eba ._gb =8;};func (_dec *Encoder )byteOut (){if _dec ._ge ==0xff{_dec .rBlock ();return ;};if _dec ._agd < 0x8000000{_dec .lBlock ();return ;};_dec ._ge ++;if _dec ._ge !=0xff{_dec .lBlock ();
return ;};_dec ._agd &=0x7ffffff;_dec .rBlock ();};func (_fbf *Encoder )emit (){if _fbf ._gf ==_dea {_fbf ._ee =append (_fbf ._ee ,_fbf ._af );_fbf ._af =make ([]byte ,_dea );_fbf ._gf =0;};_fbf ._af [_fbf ._gf ]=_fbf ._ge ;_fbf ._gf ++;};var _egf =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_agg *Encoder )code1 (_faf *codingContext ,_bcc uint32 ,_cgfb uint16 ,_gdg byte ){if _faf .mps (_bcc )==1{_agg .codeMPS (_faf ,_bcc ,_cgfb ,_gdg );}else {_agg .codeLPS (_faf ,_bcc ,_cgfb ,_gdg );};};func (_aca *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ggb error ){_cb .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ggb =_aca .encodeIAID (symbolCodeLength ,value );_ggb !=nil {return _e .Wrap (_ggb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_cg *Encoder )EncodeInteger (proc Class ,value int )(_gdde error ){_cb .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _gdde =_cg .encodeInteger (proc ,value );_gdde !=nil {return _e .Wrap (_gdde ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type state struct{_cab uint16 ;_afd ,_cdg uint8 ;_ecbd uint8 ;};func (_cbdd *Encoder )codeMPS (_fcb *codingContext ,_aggg uint32 ,_deg uint16 ,_ebb byte ){_cbdd ._ab -=_deg ;
if _cbdd ._ab &0x8000!=0{_cbdd ._agd +=uint32 (_deg );return ;};if _cbdd ._ab < _deg {_cbdd ._ab =_deg ;}else {_cbdd ._agd +=uint32 (_deg );};_fcb ._ac [_aggg ]=_egf [_ebb ]._afd ;_cbdd .renormalize ();};func (_daa *Encoder )encodeIAID (_cde ,_abbe int )error {if _daa ._bc ==nil {_daa ._bc =_gge (1<<uint (_cde ));
};_ecb :=uint32 (1<<uint32 (_cde +1))-1;_abbe <<=uint (32-_cde );_bcb :=uint32 (1);for _cdcf :=0;_cdcf < _cde ;_cdcf ++{_cga :=_bcb &_ecb ;_ba :=uint8 ((uint32 (_abbe )&0x80000000)>>31);if _bccb :=_daa .encodeBit (_daa ._bc ,_cga ,_ba );_bccb !=nil {return _bccb ;
};_bcb =(_bcb <<1)|uint32 (_ba );_abbe <<=1;};return nil ;};type intEncRangeS struct{_cd ,_gg int ;_ag ,_db uint8 ;_ed uint16 ;_agf uint8 ;};func (_eaf *Encoder )Flush (){_eaf ._gf =0;_eaf ._ee =nil ;_eaf ._fe =-1};func (_ccec *Encoder )dataSize ()int {return _dea *len (_ccec ._ee )+_ccec ._gf };
func (_fcc *Encoder )encodeInteger (_aeg Class ,_ceb int )error {const _eab ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _ceb > 2000000000||_ceb < -2000000000{return _e .Errorf (_eab ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_ceb );
};_dbf :=_fcc ._gga [_aeg ];_cf :=uint32 (1);var _ccb int ;for ;;_ccb ++{if _ef [_ccb ]._cd <=_ceb &&_ef [_ccb ]._gg >=_ceb {break ;};};if _ceb < 0{_ceb =-_ceb ;};_ceb -=int (_ef [_ccb ]._ed );_bd :=_ef [_ccb ]._ag ;for _caa :=uint8 (0);_caa < _ef [_ccb ]._db ;
_caa ++{_ccg :=_bd &1;if _ff :=_fcc .encodeBit (_dbf ,_cf ,_ccg );_ff !=nil {return _e .Wrap (_ff ,_eab ,"");};_bd >>=1;if _cf &0x100> 0{_cf =(((_cf <<1)|uint32 (_ccg ))&0x1ff)|0x100;}else {_cf =(_cf <<1)|uint32 (_ccg );};};_ceb <<=32-_ef [_ccb ]._agf ;
for _aee :=uint8 (0);_aee < _ef [_ccb ]._agf ;_aee ++{_dba :=uint8 ((uint32 (_ceb )&0x80000000)>>31);if _fgba :=_fcc .encodeBit (_dbf ,_cf ,_dba );_fgba !=nil {return _e .Wrap (_fgba ,_eab ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_ceb <<=1;if _cf &0x100!=0{_cf =(((_cf <<1)|uint32 (_dba ))&0x1ff)|0x100;}else {_cf =(_cf <<1)|uint32 (_dba );};};return nil ;};func (_bbf *Encoder )codeLPS (_bef *codingContext ,_gbg uint32 ,_cgga uint16 ,_cdd byte ){_bbf ._ab -=_cgga ;if _bbf ._ab < _cgga {_bbf ._agd +=uint32 (_cgga );
}else {_bbf ._ab =_cgga ;};if _egf [_cdd ]._ecbd ==1{_bef .flipMps (_gbg );};_bef ._ac [_gbg ]=_egf [_cdd ]._cdg ;_bbf .renormalize ();};var _ef =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
type Encoder struct{_agd uint32 ;_ab uint16 ;_gb ,_ge uint8 ;_fe int ;_gef int ;_ee [][]byte ;_af []byte ;_gf int ;_ce *codingContext ;_gga [13]*codingContext ;_bc *codingContext ;};func (_fbbed *Encoder )encodeOOB (_gdba Class )error {_afb :=_fbbed ._gga [_gdba ];
_gfdg :=_fbbed .encodeBit (_afb ,1,1);if _gfdg !=nil {return _gfdg ;};_gfdg =_fbbed .encodeBit (_afb ,3,0);if _gfdg !=nil {return _gfdg ;};_gfdg =_fbbed .encodeBit (_afb ,6,0);if _gfdg !=nil {return _gfdg ;};_gfdg =_fbbed .encodeBit (_afb ,12,0);if _gfdg !=nil {return _gfdg ;
};return nil ;};func New ()*Encoder {_bg :=&Encoder {};_bg .Init ();return _bg };func (_cgeb *Encoder )renormalize (){for {_cgeb ._ab <<=1;_cgeb ._agd <<=1;_cgeb ._gb --;if _cgeb ._gb ==0{_cgeb .byteOut ();};if (_cgeb ._ab &0x8000)!=0{break ;};};};func _gge (_fg int )*codingContext {return &codingContext {_ac :make ([]byte ,_fg ),_b :make ([]byte ,_fg )};
};func (_aga *Encoder )WriteTo (w _c .Writer )(int64 ,error ){const _gce ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _beb int64 ;for _cad ,_gefaf :=range _aga ._ee {_cea ,_cgf :=w .Write (_gefaf );if _cgf !=nil {return 0,_e .Wrapf (_cgf ,_gce ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_cad );
};_beb +=int64 (_cea );};_aga ._af =_aga ._af [:_aga ._gf ];_dd ,_abdg :=w .Write (_aga ._af );if _abdg !=nil {return 0,_e .Wrap (_abdg ,_gce ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_beb +=int64 (_dd );return _beb ,nil ;
};func (_abf *Encoder )DataSize ()int {return _abf .dataSize ()};func (_dbb *Encoder )Refine (iTemp ,iTarget *_g .Bitmap ,ox ,oy int )error {for _eb :=0;_eb < iTarget .Height ;_eb ++{var _df int ;_ede :=_eb +oy ;var (_fbb ,_fad ,_edd ,_ccd ,_cbd uint16 ;
_ga ,_gfd ,_daf ,_cdc ,_dbbe byte ;);if _ede >=1&&(_ede -1)< iTemp .Height {_ga =iTemp .Data [(_ede -1)*iTemp .RowStride ];};if _ede >=0&&_ede < iTemp .Height {_gfd =iTemp .Data [_ede *iTemp .RowStride ];};if _ede >=-1&&_ede +1< iTemp .Height {_daf =iTemp .Data [(_ede +1)*iTemp .RowStride ];
};if _eb >=1{_cdc =iTarget .Data [(_eb -1)*iTarget .RowStride ];};_dbbe =iTarget .Data [_eb *iTarget .RowStride ];_gec :=uint (6+ox );_fbb =uint16 (_ga >>_gec );_fad =uint16 (_gfd >>_gec );_edd =uint16 (_daf >>_gec );_ccd =uint16 (_cdc >>6);_ggac :=uint (2-ox );
_ga <<=_ggac ;_gfd <<=_ggac ;_daf <<=_ggac ;_cdc <<=2;for _df =0;_df < iTarget .Width ;_df ++{_be :=(_fbb <<10)|(_fad <<7)|(_edd <<4)|(_ccd <<1)|_cbd ;_cge :=_dbbe >>7;_fd :=_dbb .encodeBit (_dbb ._ce ,uint32 (_be ),_cge );if _fd !=nil {return _fd ;};_fbb <<=1;
_fad <<=1;_edd <<=1;_ccd <<=1;_fbb |=uint16 (_ga >>7);_fad |=uint16 (_gfd >>7);_edd |=uint16 (_daf >>7);_ccd |=uint16 (_cdc >>7);_cbd =uint16 (_cge );_fbbe :=_df %8;_dccf :=_df /8+1;if _fbbe ==5+ox {_ga ,_gfd ,_daf =0,0,0;if _dccf < iTemp .RowStride &&_ede >=1&&(_ede -1)< iTemp .Height {_ga =iTemp .Data [(_ede -1)*iTemp .RowStride +_dccf ];
};if _dccf < iTemp .RowStride &&_ede >=0&&_ede < iTemp .Height {_gfd =iTemp .Data [_ede *iTemp .RowStride +_dccf ];};if _dccf < iTemp .RowStride &&_ede >=-1&&(_ede +1)< iTemp .Height {_daf =iTemp .Data [(_ede +1)*iTemp .RowStride +_dccf ];};}else {_ga <<=1;
_gfd <<=1;_daf <<=1;};if _fbbe ==5&&_eb >=1{_cdc =0;if _dccf < iTarget .RowStride {_cdc =iTarget .Data [(_eb -1)*iTarget .RowStride +_dccf ];};}else {_cdc <<=1;};if _fbbe ==7{_dbbe =0;if _dccf < iTarget .RowStride {_dbbe =iTarget .Data [_eb *iTarget .RowStride +_dccf ];
};}else {_dbbe <<=1;};_fbb &=7;_fad &=7;_edd &=7;_ccd &=7;};};return nil ;};func (_ea *codingContext )flipMps (_dg uint32 ){_ea ._b [_dg ]=1-_ea ._b [_dg ]};func (_eeb *Encoder )encodeBit (_aaf *codingContext ,_dae uint32 ,_egg uint8 )error {const _bgc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_eeb ._gef ++;if _dae >=uint32 (len (_aaf ._ac )){return _e .Errorf (_bgc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_dae );
};_dbd :=_aaf ._ac [_dae ];_ggae :=_aaf .mps (_dae );_gfdc :=_egf [_dbd ]._cab ;_cb .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_eeb ._gef ,_egg ,_dbd ,_ggae ,_gfdc ,_eeb ._ab ,_eeb ._agd ,_eeb ._gb ,_eeb ._ge ,_eeb ._fe );
if _egg ==0{_eeb .code0 (_aaf ,_dae ,_gfdc ,_dbd );}else {_eeb .code1 (_aaf ,_dae ,_gfdc ,_dbd );};return nil ;};const (_gab =65536;_dea =20*1024;);