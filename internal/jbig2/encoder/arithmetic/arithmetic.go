//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_c "bytes";_da "github.com/unidoc/unipdf/v3/common";_bg "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_bf *codingContext )mps (_cd uint32 )int {return int (_bf ._ab [_cd ])};
type Class int ;func (_ae *Encoder )DataSize ()int {return _ae .dataSize ()};const (_eaf =65536;_ace =20*1024;);func (_g Class )String ()string {switch _g {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";
case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";
case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};const _daa =0x9b25;
func (_fcf *Encoder )encodeIAID (_ffd ,_abc int )error {if _fcf ._ccd ==nil {_fcf ._ccd =_adc (1<<uint (_ffd ));};_gc :=uint32 (1<<uint32 (_ffd +1))-1;_abc <<=uint (32-_ffd );_gec :=uint32 (1);for _aca :=0;_aca < _ffd ;_aca ++{_eacb :=_gec &_gc ;_dga :=uint8 ((uint32 (_abc )&0x80000000)>>31);
if _bcb :=_fcf .encodeBit (_fcf ._ccd ,_eacb ,_dga );_bcb !=nil {return _bcb ;};_gec =(_gec <<1)|uint32 (_dga );_abc <<=1;};return nil ;};func (_afa *Encoder )codeMPS (_gad *codingContext ,_bfde uint32 ,_aae uint16 ,_afag byte ){_afa ._cb -=_aae ;if _afa ._cb &0x8000!=0{_afa ._fd +=uint32 (_aae );
return ;};if _afa ._cb < _aae {_afa ._cb =_aae ;}else {_afa ._fd +=uint32 (_aae );};_gad ._efa [_bfde ]=_gfb [_afag ]._adf ;_afa .renormalize ();};func (_bb *Encoder )Final (){_bb .flush ()};func (_edda *Encoder )encodeOOB (_gge Class )error {_bfa :=_edda ._cgc [_gge ];
_dbe :=_edda .encodeBit (_bfa ,1,1);if _dbe !=nil {return _dbe ;};_dbe =_edda .encodeBit (_bfa ,3,0);if _dbe !=nil {return _dbe ;};_dbe =_edda .encodeBit (_bfa ,6,0);if _dbe !=nil {return _dbe ;};_dbe =_edda .encodeBit (_bfa ,12,0);if _dbe !=nil {return _dbe ;
};return nil ;};type codingContext struct{_efa []byte ;_ab []byte ;};func (_ad *codingContext )flipMps (_bfc uint32 ){_ad ._ab [_bfc ]=1-_ad ._ab [_bfc ]};func (_ee *Encoder )EncodeInteger (proc Class ,value int )(_fc error ){_da .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _fc =_ee .encodeInteger (proc ,value );_fc !=nil {return _e .Wrap (_fc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_fag *Encoder )renormalize (){for {_fag ._cb <<=1;_fag ._fd <<=1;_fag ._ce --;
if _fag ._ce ==0{_fag .byteOut ();};if (_fag ._cb &0x8000)!=0{break ;};};};func (_cgg *Encoder )Refine (iTemp ,iTarget *_bg .Bitmap ,ox ,oy int )error {for _eac :=0;_eac < iTarget .Height ;_eac ++{var _ca int ;_dcc :=_eac +oy ;var (_ceg ,_bbf ,_bea ,_gdb ,_ff uint16 ;
_cce ,_fge ,_eacg ,_abe ,_df byte ;);if _dcc >=1&&(_dcc -1)< iTemp .Height {_cce =iTemp .Data [(_dcc -1)*iTemp .RowStride ];};if _dcc >=0&&_dcc < iTemp .Height {_fge =iTemp .Data [_dcc *iTemp .RowStride ];};if _dcc >=-1&&_dcc +1< iTemp .Height {_eacg =iTemp .Data [(_dcc +1)*iTemp .RowStride ];
};if _eac >=1{_abe =iTarget .Data [(_eac -1)*iTarget .RowStride ];};_df =iTarget .Data [_eac *iTarget .RowStride ];_dbg :=uint (6+ox );_ceg =uint16 (_cce >>_dbg );_bbf =uint16 (_fge >>_dbg );_bea =uint16 (_eacg >>_dbg );_gdb =uint16 (_abe >>6);_bac :=uint (2-ox );
_cce <<=_bac ;_fge <<=_bac ;_eacg <<=_bac ;_abe <<=2;for _ca =0;_ca < iTarget .Width ;_ca ++{_ac :=(_ceg <<10)|(_bbf <<7)|(_bea <<4)|(_gdb <<1)|_ff ;_eaae :=_df >>7;_bae :=_cgg .encodeBit (_cgg ._cg ,uint32 (_ac ),_eaae );if _bae !=nil {return _bae ;};
_ceg <<=1;_bbf <<=1;_bea <<=1;_gdb <<=1;_ceg |=uint16 (_cce >>7);_bbf |=uint16 (_fge >>7);_bea |=uint16 (_eacg >>7);_gdb |=uint16 (_abe >>7);_ff =uint16 (_eaae );_cdf :=_ca %8;_ag :=_ca /8+1;if _cdf ==5+ox {_cce ,_fge ,_eacg =0,0,0;if _ag < iTemp .RowStride &&_dcc >=1&&(_dcc -1)< iTemp .Height {_cce =iTemp .Data [(_dcc -1)*iTemp .RowStride +_ag ];
};if _ag < iTemp .RowStride &&_dcc >=0&&_dcc < iTemp .Height {_fge =iTemp .Data [_dcc *iTemp .RowStride +_ag ];};if _ag < iTemp .RowStride &&_dcc >=-1&&(_dcc +1)< iTemp .Height {_eacg =iTemp .Data [(_dcc +1)*iTemp .RowStride +_ag ];};}else {_cce <<=1;_fge <<=1;
_eacg <<=1;};if _cdf ==5&&_eac >=1{_abe =0;if _ag < iTarget .RowStride {_abe =iTarget .Data [(_eac -1)*iTarget .RowStride +_ag ];};}else {_abe <<=1;};if _cdf ==7{_df =0;if _ag < iTarget .RowStride {_df =iTarget .Data [_eac *iTarget .RowStride +_ag ];};
}else {_df <<=1;};_ceg &=7;_bbf &=7;_bea &=7;_gdb &=7;};};return nil ;};func (_gfg *Encoder )flush (){_gfg .setBits ();_gfg ._fd <<=_gfg ._ce ;_gfg .byteOut ();_gfg ._fd <<=_gfg ._ce ;_gfg .byteOut ();_gfg .emit ();if _gfg ._cc !=0xff{_gfg ._be ++;_gfg ._cc =0xff;
_gfg .emit ();};_gfg ._be ++;_gfg ._cc =0xac;_gfg ._be ++;_gfg .emit ();};func (_aag *Encoder )rBlock (){if _aag ._be >=0{_aag .emit ();};_aag ._be ++;_aag ._cc =uint8 (_aag ._fd >>20);_aag ._fd &=0xfffff;_aag ._ce =7;};func (_aad *Encoder )emit (){if _aad ._bce ==_ace {_aad ._bc =append (_aad ._bc ,_aad ._eaa );
_aad ._eaa =make ([]byte ,_ace );_aad ._bce =0;};_aad ._eaa [_aad ._bce ]=_aad ._cc ;_aad ._bce ++;};func (_edag *Encoder )EncodeOOB (proc Class )(_fgf error ){_da .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _fgf =_edag .encodeOOB (proc );_fgf !=nil {return _e .Wrap (_fgf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_cceb *Encoder )Reset (){_cceb ._cb =0x8000;_cceb ._fd =0;_cceb ._ce =12;_cceb ._be =-1;_cceb ._cc =0;_cceb ._ccd =nil ;
_cceb ._cg =_adc (_eaf );};var _gfb =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_afd *Encoder )dataSize ()int {return _ace *len (_afd ._bc )+_afd ._bce };const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func New ()*Encoder {_edaa :=&Encoder {};_edaa .Init ();return _edaa };
func (_cdg *Encoder )encodeBit (_bcf *codingContext ,_aec uint32 ,_gfa uint8 )error {const _ccde ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_cdg ._ea ++;if _aec >=uint32 (len (_bcf ._efa )){return _e .Errorf (_ccde ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_aec );
};_aac :=_bcf ._efa [_aec ];_ecf :=_bcf .mps (_aec );_gab :=_gfb [_aac ]._baf ;_da .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_cdg ._ea ,_gfa ,_aac ,_ecf ,_gab ,_cdg ._cb ,_cdg ._fd ,_cdg ._ce ,_cdg ._cc ,_cdg ._be );
if _gfa ==0{_cdg .code0 (_bcf ,_aec ,_gab ,_aac );}else {_cdg .code1 (_bcf ,_aec ,_gab ,_aac );};return nil ;};var _ _b .WriterTo =&Encoder {};func (_dbed *Encoder )setBits (){_cef :=_dbed ._fd +uint32 (_dbed ._cb );_dbed ._fd |=0xffff;if _dbed ._fd >=_cef {_dbed ._fd -=0x8000;
};};func (_aff *Encoder )code0 (_bfe *codingContext ,_eacgd uint32 ,_gb uint16 ,_fgad byte ){if _bfe .mps (_eacgd )==0{_aff .codeMPS (_bfe ,_eacgd ,_gb ,_fgad );}else {_aff .codeLPS (_bfe ,_eacgd ,_gb ,_fgad );};};func (_ede *Encoder )EncodeBitmap (bm *_bg .Bitmap ,duplicateLineRemoval bool )error {_da .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_aee ,_af uint8 ;_aed ,_daac ,_fg uint16 ;_ge ,_fdd ,_dad byte ;_edf ,_fga ,_bfd int ;_ddd ,_bd []byte ;);for _gd :=0;_gd < bm .Height ;_gd ++{_ge ,_fdd =0,0;if _gd >=2{_ge =bm .Data [(_gd -2)*bm .RowStride ];};if _gd >=1{_fdd =bm .Data [(_gd -1)*bm .RowStride ];
if duplicateLineRemoval {_fga =_gd *bm .RowStride ;_ddd =bm .Data [_fga :_fga +bm .RowStride ];_bfd =(_gd -1)*bm .RowStride ;_bd =bm .Data [_bfd :_bfd +bm .RowStride ];if _c .Equal (_ddd ,_bd ){_af =_aee ^1;_aee =1;}else {_af =_aee ;_aee =0;};};};if duplicateLineRemoval {if _faa :=_ede .encodeBit (_ede ._cg ,_daa ,_af );
_faa !=nil {return _faa ;};if _aee !=0{continue ;};};_dad =bm .Data [_gd *bm .RowStride ];_aed =uint16 (_ge >>5);_daac =uint16 (_fdd >>4);_ge <<=3;_fdd <<=4;_fg =0;for _edf =0;_edf < bm .Width ;_edf ++{_dc :=uint32 (_aed <<11|_daac <<4|_fg );_bgb :=(_dad &0x80)>>7;
_db :=_ede .encodeBit (_ede ._cg ,_dc ,_bgb );if _db !=nil {return _db ;};_aed <<=1;_daac <<=1;_fg <<=1;_aed |=uint16 ((_ge &0x80)>>7);_daac |=uint16 ((_fdd &0x80)>>7);_fg |=uint16 (_bgb );_ba :=_edf %8;_ced :=_edf /8+1;if _ba ==4&&_gd >=2{_ge =0;if _ced < bm .RowStride {_ge =bm .Data [(_gd -2)*bm .RowStride +_ced ];
};}else {_ge <<=1;};if _ba ==3&&_gd >=1{_fdd =0;if _ced < bm .RowStride {_fdd =bm .Data [(_gd -1)*bm .RowStride +_ced ];};}else {_fdd <<=1;};if _ba ==7{_dad =0;if _ced < bm .RowStride {_dad =bm .Data [_gd *bm .RowStride +_ced ];};}else {_dad <<=1;};_aed &=31;
_daac &=127;_fg &=15;};};return nil ;};func (_dbb *Encoder )EncodeIAID (symbolCodeLength ,value int )(_aa error ){_da .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _aa =_dbb .encodeIAID (symbolCodeLength ,value );_aa !=nil {return _e .Wrap (_aa ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};type state struct{_baf uint16 ;_adf ,_bgc uint8 ;_fab uint8 ;};func (_bacg *Encoder )encodeInteger (_bbc Class ,_ddee int )error {const _cdb ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _ddee > 2000000000||_ddee < -2000000000{return _e .Errorf (_cdb ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_ddee );
};_dg :=_bacg ._cgc [_bbc ];_dfb :=uint32 (1);var _ecc int ;for ;;_ecc ++{if _ef [_ecc ]._ed <=_ddee &&_ef [_ecc ]._f >=_ddee {break ;};};if _ddee < 0{_ddee =-_ddee ;};_ddee -=int (_ef [_ecc ]._dd );_dge :=_ef [_ecc ]._fa ;for _bgbf :=uint8 (0);_bgbf < _ef [_ecc ]._a ;
_bgbf ++{_gbb :=_dge &1;if _caf :=_bacg .encodeBit (_dg ,_dfb ,_gbb );_caf !=nil {return _e .Wrap (_caf ,_cdb ,"");};_dge >>=1;if _dfb &0x100> 0{_dfb =(((_dfb <<1)|uint32 (_gbb ))&0x1ff)|0x100;}else {_dfb =(_dfb <<1)|uint32 (_gbb );};};_ddee <<=32-_ef [_ecc ]._eda ;
for _afb :=uint8 (0);_afb < _ef [_ecc ]._eda ;_afb ++{_aeea :=uint8 ((uint32 (_ddee )&0x80000000)>>31);if _aadc :=_bacg .encodeBit (_dg ,_dfb ,_aeea );_aadc !=nil {return _e .Wrap (_aadc ,_cdb ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_ddee <<=1;if _dfb &0x100!=0{_dfb =(((_dfb <<1)|uint32 (_aeea ))&0x1ff)|0x100;}else {_dfb =(_dfb <<1)|uint32 (_aeea );};};return nil ;};func (_fb *Encoder )Init (){_fb ._cg =_adc (_eaf );_fb ._cb =0x8000;_fb ._fd =0;_fb ._ce =12;_fb ._be =-1;_fb ._cc =0;
_fb ._bce =0;_fb ._eaa =make ([]byte ,_ace );for _bef :=0;_bef < len (_fb ._cgc );_bef ++{_fb ._cgc [_bef ]=_adc (512);};_fb ._ccd =nil ;};func (_fae *Encoder )lBlock (){if _fae ._be >=0{_fae .emit ();};_fae ._be ++;_fae ._cc =uint8 (_fae ._fd >>19);_fae ._fd &=0x7ffff;
_fae ._ce =8;};func (_dde *Encoder )Flush (){_dde ._bce =0;_dde ._bc =nil ;_dde ._be =-1};func (_edd *Encoder )WriteTo (w _b .Writer )(int64 ,error ){const _cf ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _dfg int64 ;
for _eb ,_ec :=range _edd ._bc {_fdf ,_ebg :=w .Write (_ec );if _ebg !=nil {return 0,_e .Wrapf (_ebg ,_cf ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_eb );
};_dfg +=int64 (_fdf );};_edd ._eaa =_edd ._eaa [:_edd ._bce ];_abg ,_geb :=w .Write (_edd ._eaa );if _geb !=nil {return 0,_e .Wrap (_geb ,_cf ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_dfg +=int64 (_abg );return _dfg ,nil ;
};type intEncRangeS struct{_ed ,_f int ;_fa ,_a uint8 ;_dd uint16 ;_eda uint8 ;};func (_eace *Encoder )codeLPS (_fcg *codingContext ,_bdb uint32 ,_eeb uint16 ,_eeg byte ){_eace ._cb -=_eeb ;if _eace ._cb < _eeb {_eace ._fd +=uint32 (_eeb );}else {_eace ._cb =_eeb ;
};if _gfb [_eeg ]._fab ==1{_fcg .flipMps (_bdb );};_fcg ._efa [_bdb ]=_gfb [_eeg ]._bgc ;_eace .renormalize ();};func _adc (_ga int )*codingContext {return &codingContext {_efa :make ([]byte ,_ga ),_ab :make ([]byte ,_ga )};};func (_gf *Encoder )byteOut (){if _gf ._cc ==0xff{_gf .rBlock ();
return ;};if _gf ._fd < 0x8000000{_gf .lBlock ();return ;};_gf ._cc ++;if _gf ._cc !=0xff{_gf .lBlock ();return ;};_gf ._fd &=0x7ffffff;_gf .rBlock ();};var _ef =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
type Encoder struct{_fd uint32 ;_cb uint16 ;_ce ,_cc uint8 ;_be int ;_ea int ;_bc [][]byte ;_eaa []byte ;_bce int ;_cg *codingContext ;_cgc [13]*codingContext ;_ccd *codingContext ;};func (_fdb *Encoder )code1 (_gg *codingContext ,_cge uint32 ,_eg uint16 ,_eae byte ){if _gg .mps (_cge )==1{_fdb .codeMPS (_gg ,_cge ,_eg ,_eae );
}else {_fdb .codeLPS (_gg ,_cge ,_eg ,_eae );};};