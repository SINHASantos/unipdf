//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_ec "bytes";_a "github.com/unidoc/unipdf/v3/common";_ab "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_d "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ea "io";);func (_gbg *Encoder )emit (){if _gbg ._eb ==_eeac {_gbg ._cdd =append (_gbg ._cdd ,_gbg ._eca );
_gbg ._eca =make ([]byte ,_eeac );_gbg ._eb =0;};_gbg ._eca [_gbg ._eb ]=_gbg ._ecf ;_gbg ._eb ++;};func (_cdba *Encoder )codeMPS (_ba *codingContext ,_eea uint32 ,_fgb uint16 ,_aad byte ){_cdba ._fc -=_fgb ;if _cdba ._fc &0x8000!=0{_cdba ._be +=uint32 (_fgb );
return ;};if _cdba ._fc < _fgb {_cdba ._fc =_fgb ;}else {_cdba ._be +=uint32 (_fgb );};_ba ._dc [_eea ]=_cfd [_aad ]._fec ;_cdba .renormalize ();};const (_bee =65536;_eeac =20*1024;);func (_bbed *Encoder )DataSize ()int {return _bbed .dataSize ()};func (_bbg *Encoder )WriteTo (w _ea .Writer )(int64 ,error ){const _agg ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _aabb int64 ;for _acf ,_cgg :=range _bbg ._cdd {_ffb ,_dce :=w .Write (_cgg );if _dce !=nil {return 0,_d .Wrapf (_dce ,_agg ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_acf );
};_aabb +=int64 (_ffb );};_bbg ._eca =_bbg ._eca [:_bbg ._eb ];_ggc ,_adg :=w .Write (_bbg ._eca );if _adg !=nil {return 0,_d .Wrap (_adg ,_agg ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_aabb +=int64 (_ggc );
return _aabb ,nil ;};func (_bgf *Encoder )Reset (){_bgf ._fc =0x8000;_bgf ._be =0;_bgf ._abb =12;_bgf ._gc =-1;_bgf ._ecf =0;_bgf ._fd =nil ;_bgf ._fe =_ead (_bee );};func (_df *Encoder )Refine (iTemp ,iTarget *_ab .Bitmap ,ox ,oy int )error {for _dab :=0;
_dab < iTarget .Height ;_dab ++{var _fdd int ;_cff :=_dab +oy ;var (_fg ,_cdg ,_cdb ,_cgc ,_bgb uint16 ;_ca ,_gf ,_gbf ,_gce ,_efd byte ;);if _cff >=1&&(_cff -1)< iTemp .Height {_ca =iTemp .Data [(_cff -1)*iTemp .RowStride ];};if _cff >=0&&_cff < iTemp .Height {_gf =iTemp .Data [_cff *iTemp .RowStride ];
};if _cff >=-1&&_cff +1< iTemp .Height {_gbf =iTemp .Data [(_cff +1)*iTemp .RowStride ];};if _dab >=1{_gce =iTarget .Data [(_dab -1)*iTarget .RowStride ];};_efd =iTarget .Data [_dab *iTarget .RowStride ];_edc :=uint (6+ox );_fg =uint16 (_ca >>_edc );_cdg =uint16 (_gf >>_edc );
_cdb =uint16 (_gbf >>_edc );_cgc =uint16 (_gce >>6);_cga :=uint (2-ox );_ca <<=_cga ;_gf <<=_cga ;_gbf <<=_cga ;_gce <<=2;for _fdd =0;_fdd < iTarget .Width ;_fdd ++{_gdca :=(_fg <<10)|(_cdg <<7)|(_cdb <<4)|(_cgc <<1)|_bgb ;_dad :=_efd >>7;_ff :=_df .encodeBit (_df ._fe ,uint32 (_gdca ),_dad );
if _ff !=nil {return _ff ;};_fg <<=1;_cdg <<=1;_cdb <<=1;_cgc <<=1;_fg |=uint16 (_ca >>7);_cdg |=uint16 (_gf >>7);_cdb |=uint16 (_gbf >>7);_cgc |=uint16 (_gce >>7);_bgb =uint16 (_dad );_ge :=_fdd %8;_ad :=_fdd /8+1;if _ge ==5+ox {_ca ,_gf ,_gbf =0,0,0;
if _ad < iTemp .RowStride &&_cff >=1&&(_cff -1)< iTemp .Height {_ca =iTemp .Data [(_cff -1)*iTemp .RowStride +_ad ];};if _ad < iTemp .RowStride &&_cff >=0&&_cff < iTemp .Height {_gf =iTemp .Data [_cff *iTemp .RowStride +_ad ];};if _ad < iTemp .RowStride &&_cff >=-1&&(_cff +1)< iTemp .Height {_gbf =iTemp .Data [(_cff +1)*iTemp .RowStride +_ad ];
};}else {_ca <<=1;_gf <<=1;_gbf <<=1;};if _ge ==5&&_dab >=1{_gce =0;if _ad < iTarget .RowStride {_gce =iTarget .Data [(_dab -1)*iTarget .RowStride +_ad ];};}else {_gce <<=1;};if _ge ==7{_efd =0;if _ad < iTarget .RowStride {_efd =iTarget .Data [_dab *iTarget .RowStride +_ad ];
};}else {_efd <<=1;};_fg &=7;_cdg &=7;_cdb &=7;_cgc &=7;};};return nil ;};func (_eda *Encoder )Init (){_eda ._fe =_ead (_bee );_eda ._fc =0x8000;_eda ._be =0;_eda ._abb =12;_eda ._gc =-1;_eda ._ecf =0;_eda ._eb =0;_eda ._eca =make ([]byte ,_eeac );for _bbe :=0;
_bbe < len (_eda ._ed );_bbe ++{_eda ._ed [_bbe ]=_ead (512);};_eda ._fd =nil ;};func (_fcg *Encoder )EncodeBitmap (bm *_ab .Bitmap ,duplicateLineRemoval bool )error {_a .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_edg ,_fca uint8 ;_bg ,_cg ,_bd uint16 ;_aea ,_fb ,_cf byte ;_bba ,_af ,_dca int ;_gdc ,_ac []byte ;);for _aed :=0;_aed < bm .Height ;_aed ++{_aea ,_fb =0,0;if _aed >=2{_aea =bm .Data [(_aed -2)*bm .RowStride ];};if _aed >=1{_fb =bm .Data [(_aed -1)*bm .RowStride ];
if duplicateLineRemoval {_af =_aed *bm .RowStride ;_gdc =bm .Data [_af :_af +bm .RowStride ];_dca =(_aed -1)*bm .RowStride ;_ac =bm .Data [_dca :_dca +bm .RowStride ];if _ec .Equal (_gdc ,_ac ){_fca =_edg ^1;_edg =1;}else {_fca =_edg ;_edg =0;};};};if duplicateLineRemoval {if _ga :=_fcg .encodeBit (_fcg ._fe ,_gd ,_fca );
_ga !=nil {return _ga ;};if _edg !=0{continue ;};};_cf =bm .Data [_aed *bm .RowStride ];_bg =uint16 (_aea >>5);_cg =uint16 (_fb >>4);_aea <<=3;_fb <<=4;_bd =0;for _bba =0;_bba < bm .Width ;_bba ++{_edgf :=uint32 (_bg <<11|_cg <<4|_bd );_dg :=(_cf &0x80)>>7;
_gaa :=_fcg .encodeBit (_fcg ._fe ,_edgf ,_dg );if _gaa !=nil {return _gaa ;};_bg <<=1;_cg <<=1;_bd <<=1;_bg |=uint16 ((_aea &0x80)>>7);_cg |=uint16 ((_fb &0x80)>>7);_bd |=uint16 (_dg );_eg :=_bba %8;_da :=_bba /8+1;if _eg ==4&&_aed >=2{_aea =0;if _da < bm .RowStride {_aea =bm .Data [(_aed -2)*bm .RowStride +_da ];
};}else {_aea <<=1;};if _eg ==3&&_aed >=1{_fb =0;if _da < bm .RowStride {_fb =bm .Data [(_aed -1)*bm .RowStride +_da ];};}else {_fb <<=1;};if _eg ==7{_cf =0;if _da < bm .RowStride {_cf =bm .Data [_aed *bm .RowStride +_da ];};}else {_cf <<=1;};_bg &=31;
_cg &=127;_bd &=15;};};return nil ;};func (_gb *codingContext )mps (_db uint32 )int {return int (_gb ._bb [_db ])};type intEncRangeS struct{_g ,_b int ;_f ,_gg uint8 ;_ag uint16 ;_c uint8 ;};type Class int ;var _cd =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_gbfb *Encoder )code1 (_adge *codingContext ,_dfg uint32 ,_ebe uint16 ,_ce byte ){if _adge .mps (_dfg )==1{_gbfb .codeMPS (_adge ,_dfg ,_ebe ,_ce );}else {_gbfb .codeLPS (_adge ,_dfg ,_ebe ,_ce );};};func (_aa Class )String ()string {switch _aa {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_aee *Encoder )code0 (_daf *codingContext ,_aeda uint32 ,_bddf uint16 ,_de byte ){if _daf .mps (_aeda )==0{_aee .codeMPS (_daf ,_aeda ,_bddf ,_de );}else {_aee .codeLPS (_daf ,_aeda ,_bddf ,_de );
};};func (_dcd *Encoder )EncodeOOB (proc Class )(_fdc error ){_a .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _fdc =_dcd .encodeOOB (proc );
_fdc !=nil {return _d .Wrap (_fdc ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_bf *Encoder )codeLPS (_gbfd *codingContext ,_gee uint32 ,_gba uint16 ,_ecd byte ){_bf ._fc -=_gba ;if _bf ._fc < _gba {_bf ._be +=uint32 (_gba );
}else {_bf ._fc =_gba ;};if _cfd [_ecd ]._bac ==1{_gbfd .flipMps (_gee );};_gbfd ._dc [_gee ]=_cfd [_ecd ]._gca ;_bf .renormalize ();};func (_cgga *Encoder )lBlock (){if _cgga ._gc >=0{_cgga .emit ();};_cgga ._gc ++;_cgga ._ecf =uint8 (_cgga ._be >>19);
_cgga ._be &=0x7ffff;_cgga ._abb =8;};func (_aggb *Encoder )rBlock (){if _aggb ._gc >=0{_aggb .emit ();};_aggb ._gc ++;_aggb ._ecf =uint8 (_aggb ._be >>20);_aggb ._be &=0xfffff;_aggb ._abb =7;};func (_feg *Encoder )byteOut (){if _feg ._ecf ==0xff{_feg .rBlock ();
return ;};if _feg ._be < 0x8000000{_feg .lBlock ();return ;};_feg ._ecf ++;if _feg ._ecf !=0xff{_feg .lBlock ();return ;};_feg ._be &=0x7ffffff;_feg .rBlock ();};func (_cgd *Encoder )encodeInteger (_acc Class ,_fa int )error {const _cda ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _fa > 2000000000||_fa < -2000000000{return _d .Errorf (_cda ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_fa );
};_dadc :=_cgd ._ed [_acc ];_dbb :=uint32 (1);var _dbg int ;for ;;_dbg ++{if _cd [_dbg ]._g <=_fa &&_cd [_dbg ]._b >=_fa {break ;};};if _fa < 0{_fa =-_fa ;};_fa -=int (_cd [_dbg ]._ag );_cgag :=_cd [_dbg ]._f ;for _cea :=uint8 (0);_cea < _cd [_dbg ]._gg ;
_cea ++{_bef :=_cgag &1;if _eeg :=_cgd .encodeBit (_dadc ,_dbb ,_bef );_eeg !=nil {return _d .Wrap (_eeg ,_cda ,"");};_cgag >>=1;if _dbb &0x100> 0{_dbb =(((_dbb <<1)|uint32 (_bef ))&0x1ff)|0x100;}else {_dbb =(_dbb <<1)|uint32 (_bef );};};_fa <<=32-_cd [_dbg ]._c ;
for _ggf :=uint8 (0);_ggf < _cd [_dbg ]._c ;_ggf ++{_gdg :=uint8 ((uint32 (_fa )&0x80000000)>>31);if _bc :=_cgd .encodeBit (_dadc ,_dbb ,_gdg );_bc !=nil {return _d .Wrap (_bc ,_cda ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_fa <<=1;if _dbb &0x100!=0{_dbb =(((_dbb <<1)|uint32 (_gdg ))&0x1ff)|0x100;}else {_dbb =(_dbb <<1)|uint32 (_gdg );};};return nil ;};func (_cb *codingContext )flipMps (_ae uint32 ){_cb ._bb [_ae ]=1-_cb ._bb [_ae ]};const _gd =0x9b25;func (_dac *Encoder )dataSize ()int {return _eeac *len (_dac ._cdd )+_dac ._eb };
func (_baf *Encoder )encodeBit (_gcg *codingContext ,_egb uint32 ,_gcd uint8 )error {const _bed ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_baf ._fcd ++;if _egb >=uint32 (len (_gcg ._dc )){return _d .Errorf (_bed ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_egb );
};_edge :=_gcg ._dc [_egb ];_baa :=_gcg .mps (_egb );_cgcg :=_cfd [_edge ]._ede ;_a .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_baf ._fcd ,_gcd ,_edge ,_baa ,_cgcg ,_baf ._fc ,_baf ._be ,_baf ._abb ,_baf ._ecf ,_baf ._gc );
if _gcd ==0{_baf .code0 (_gcg ,_egb ,_cgcg ,_edge );}else {_baf .code1 (_gcg ,_egb ,_cgcg ,_edge );};return nil ;};func (_dd *Encoder )Flush (){_dd ._eb =0;_dd ._cdd =nil ;_dd ._gc =-1};func (_dcf *Encoder )encodeOOB (_ddb Class )error {_ddg :=_dcf ._ed [_ddb ];
_dbe :=_dcf .encodeBit (_ddg ,1,1);if _dbe !=nil {return _dbe ;};_dbe =_dcf .encodeBit (_ddg ,3,0);if _dbe !=nil {return _dbe ;};_dbe =_dcf .encodeBit (_ddg ,6,0);if _dbe !=nil {return _dbe ;};_dbe =_dcf .encodeBit (_ddg ,12,0);if _dbe !=nil {return _dbe ;
};return nil ;};func (_fbc *Encoder )Final (){_fbc .flush ()};type codingContext struct{_dc []byte ;_bb []byte ;};func (_gda *Encoder )setBits (){_bca :=_gda ._be +uint32 (_gda ._fc );_gda ._be |=0xffff;if _gda ._be >=_bca {_gda ._be -=0x8000;};};func (_egbc *Encoder )encodeIAID (_cdf ,_bdc int )error {if _egbc ._fd ==nil {_egbc ._fd =_ead (1<<uint (_cdf ));
};_dbf :=uint32 (1<<uint32 (_cdf +1))-1;_bdc <<=uint (32-_cdf );_ccg :=uint32 (1);for _beg :=0;_beg < _cdf ;_beg ++{_faa :=_ccg &_dbf ;_ggce :=uint8 ((uint32 (_bdc )&0x80000000)>>31);if _gga :=_egbc .encodeBit (_egbc ._fd ,_faa ,_ggce );_gga !=nil {return _gga ;
};_ccg =(_ccg <<1)|uint32 (_ggce );_bdc <<=1;};return nil ;};var _cfd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
var _ _ea .WriterTo =&Encoder {};func _ead (_cc int )*codingContext {return &codingContext {_dc :make ([]byte ,_cc ),_bb :make ([]byte ,_cc )};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_bgc *Encoder )renormalize (){for {_bgc ._fc <<=1;
_bgc ._be <<=1;_bgc ._abb --;if _bgc ._abb ==0{_bgc .byteOut ();};if (_bgc ._fc &0x8000)!=0{break ;};};};func (_ded *Encoder )flush (){_ded .setBits ();_ded ._be <<=_ded ._abb ;_ded .byteOut ();_ded ._be <<=_ded ._abb ;_ded .byteOut ();_ded .emit ();if _ded ._ecf !=0xff{_ded ._gc ++;
_ded ._ecf =0xff;_ded .emit ();};_ded ._gc ++;_ded ._ecf =0xac;_ded ._gc ++;_ded .emit ();};func (_aab *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ef error ){_a .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ef =_aab .encodeIAID (symbolCodeLength ,value );_ef !=nil {return _d .Wrap (_ef ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};type Encoder struct{_be uint32 ;_fc uint16 ;_abb ,_ecf uint8 ;_gc int ;_fcd int ;_cdd [][]byte ;
_eca []byte ;_eb int ;_fe *codingContext ;_ed [13]*codingContext ;_fd *codingContext ;};func New ()*Encoder {_fea :=&Encoder {};_fea .Init ();return _fea };func (_bdd *Encoder )EncodeInteger (proc Class ,value int )(_egf error ){_a .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _egf =_bdd .encodeInteger (proc ,value );_egf !=nil {return _d .Wrap (_egf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type state struct{_ede uint16 ;_fec ,_gca uint8 ;_bac uint8 ;};