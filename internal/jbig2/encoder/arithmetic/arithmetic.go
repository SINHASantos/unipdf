//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_f "bytes";_d "github.com/unidoc/unipdf/v4/common";_g "github.com/unidoc/unipdf/v4/internal/jbig2/bitmap";_dd "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_b "io";);func (_cc *Encoder )Flush (){_cc ._ec =0;_cc ._fb =nil ;
_cc ._ce =-1};var _cde =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_dgf *Encoder )renormalize (){for {_dgf ._c <<=1;_dgf ._ff <<=1;_dgf ._bf --;if _dgf ._bf ==0{_dgf .byteOut ();};if (_dgf ._c &0x8000)!=0{break ;};};};const (_dcd =65536;_befb =20*1024;);func (_af *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ceg error ){_d .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ceg =_af .encodeIAID (symbolCodeLength ,value );_ceg !=nil {return _dd .Wrap (_ceg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_faga *Encoder )WriteTo (w _b .Writer )(int64 ,error ){const _bec ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _bad int64 ;for _db ,_fdf :=range _faga ._fb {_cga ,_afb :=w .Write (_fdf );if _afb !=nil {return 0,_dd .Wrapf (_afb ,_bec ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_db );
};_bad +=int64 (_cga );};_faga ._a =_faga ._a [:_faga ._ec ];_ggg ,_bac :=w .Write (_faga ._a );if _bac !=nil {return 0,_dd .Wrap (_bac ,_bec ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_bad +=int64 (_ggg );return _bad ,nil ;
};func (_cf *Encoder )encodeInteger (_fdg Class ,_aabg int )error {const _ced ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _aabg > 2000000000||_aabg < -2000000000{return _dd .Errorf (_ced ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_aabg );
};_cge :=_cf ._ca [_fdg ];_efc :=uint32 (1);var _cdb int ;for ;;_cdb ++{if _gb [_cdb ]._eb <=_aabg &&_gb [_cdb ]._bg >=_aabg {break ;};};if _aabg < 0{_aabg =-_aabg ;};_aabg -=int (_gb [_cdb ]._ge );_bcb :=_gb [_cdb ]._fa ;for _dac :=uint8 (0);_dac < _gb [_cdb ]._fc ;
_dac ++{_egf :=_bcb &1;if _gba :=_cf .encodeBit (_cge ,_efc ,_egf );_gba !=nil {return _dd .Wrap (_gba ,_ced ,"");};_bcb >>=1;if _efc &0x100> 0{_efc =(((_efc <<1)|uint32 (_egf ))&0x1ff)|0x100;}else {_efc =(_efc <<1)|uint32 (_egf );};};_aabg <<=32-_gb [_cdb ]._fac ;
for _bea :=uint8 (0);_bea < _gb [_cdb ]._fac ;_bea ++{_fcb :=uint8 ((uint32 (_aabg )&0x80000000)>>31);if _fbf :=_cf .encodeBit (_cge ,_efc ,_fcb );_fbf !=nil {return _dd .Wrap (_fbf ,_ced ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_aabg <<=1;if _efc &0x100!=0{_efc =(((_efc <<1)|uint32 (_fcb ))&0x1ff)|0x100;}else {_efc =(_efc <<1)|uint32 (_fcb );};};return nil ;};func (_aeb *Encoder )byteOut (){if _aeb ._fag ==0xff{_aeb .rBlock ();return ;};if _aeb ._ff < 0x8000000{_aeb .lBlock ();
return ;};_aeb ._fag ++;if _aeb ._fag !=0xff{_aeb .lBlock ();return ;};_aeb ._ff &=0x7ffffff;_aeb .rBlock ();};func (_cgf *Encoder )Reset (){_cgf ._c =0x8000;_cgf ._ff =0;_cgf ._bf =12;_cgf ._ce =-1;_cgf ._fag =0;_cgf ._fd =nil ;_cgf ._dc =_fce (_dcd );
};func (_fee *Encoder )EncodeOOB (proc Class )(_bc error ){_d .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _bc =_fee .encodeOOB (proc );
_bc !=nil {return _dd .Wrap (_bc ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_de *Encoder )EncodeBitmap (bm *_g .Bitmap ,duplicateLineRemoval bool )error {_d .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_ecf ,_bfd uint8 ;_dcb ,_cef ,_dg uint16 ;_deb ,_gc ,_gdf byte ;_aag ,_ddd ,_beb int ;_gca ,_ac []byte ;);for _cea :=0;_cea < bm .Height ;_cea ++{_deb ,_gc =0,0;if _cea >=2{_deb =bm .Data [(_cea -2)*bm .RowStride ];};if _cea >=1{_gc =bm .Data [(_cea -1)*bm .RowStride ];
if duplicateLineRemoval {_ddd =_cea *bm .RowStride ;_gca =bm .Data [_ddd :_ddd +bm .RowStride ];_beb =(_cea -1)*bm .RowStride ;_ac =bm .Data [_beb :_beb +bm .RowStride ];if _f .Equal (_gca ,_ac ){_bfd =_ecf ^1;_ecf =1;}else {_bfd =_ecf ;_ecf =0;};};};if duplicateLineRemoval {if _eaf :=_de .encodeBit (_de ._dc ,_gd ,_bfd );
_eaf !=nil {return _eaf ;};if _ecf !=0{continue ;};};_gdf =bm .Data [_cea *bm .RowStride ];_dcb =uint16 (_deb >>5);_cef =uint16 (_gc >>4);_deb <<=3;_gc <<=4;_dg =0;for _aag =0;_aag < bm .Width ;_aag ++{_ded :=uint32 (_dcb <<11|_cef <<4|_dg );_bef :=(_gdf &0x80)>>7;
_ab :=_de .encodeBit (_de ._dc ,_ded ,_bef );if _ab !=nil {return _ab ;};_dcb <<=1;_cef <<=1;_dg <<=1;_dcb |=uint16 ((_deb &0x80)>>7);_cef |=uint16 ((_gc &0x80)>>7);_dg |=uint16 (_bef );_fbe :=_aag %8;_ege :=_aag /8+1;if _fbe ==4&&_cea >=2{_deb =0;if _ege < bm .RowStride {_deb =bm .Data [(_cea -2)*bm .RowStride +_ege ];
};}else {_deb <<=1;};if _fbe ==3&&_cea >=1{_gc =0;if _ege < bm .RowStride {_gc =bm .Data [(_cea -1)*bm .RowStride +_ege ];};}else {_gc <<=1;};if _fbe ==7{_gdf =0;if _ege < bm .RowStride {_gdf =bm .Data [_cea *bm .RowStride +_ege ];};}else {_gdf <<=1;};
_dcb &=31;_cef &=127;_dg &=15;};};return nil ;};func (_ffcg *Encoder )lBlock (){if _ffcg ._ce >=0{_ffcg .emit ();};_ffcg ._ce ++;_ffcg ._fag =uint8 (_ffcg ._ff >>19);_ffcg ._ff &=0x7ffff;_ffcg ._bf =8;};func (_gac *Encoder )encodeBit (_gf *codingContext ,_bcf uint32 ,_bgcg uint8 )error {const _aab ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_gac ._ffb ++;if _bcf >=uint32 (len (_gf ._da )){return _dd .Errorf (_aab ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_bcf );
};_ged :=_gf ._da [_bcf ];_acff :=_gf .mps (_bcf );_ggga :=_cde [_ged ]._ag ;_d .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_gac ._ffb ,_bgcg ,_ged ,_acff ,_ggga ,_gac ._c ,_gac ._ff ,_gac ._bf ,_gac ._fag ,_gac ._ce );
if _bgcg ==0{_gac .code0 (_gf ,_bcf ,_ggga ,_ged );}else {_gac .code1 (_gf ,_bcf ,_ggga ,_ged );};return nil ;};func (_gad *Encoder )encodeIAID (_gff ,_eda int )error {if _gad ._fd ==nil {_gad ._fd =_fce (1<<uint (_gff ));};_ega :=uint32 (1<<uint32 (_gff +1))-1;
_eda <<=uint (32-_gff );_gcf :=uint32 (1);for _bce :=0;_bce < _gff ;_bce ++{_eag :=_gcf &_ega ;_egd :=uint8 ((uint32 (_eda )&0x80000000)>>31);if _cgc :=_gad .encodeBit (_gad ._fd ,_eag ,_egd );_cgc !=nil {return _cgc ;};_gcf =(_gcf <<1)|uint32 (_egd );
_eda <<=1;};return nil ;};func (_bda *Encoder )flush (){_bda .setBits ();_bda ._ff <<=_bda ._bf ;_bda .byteOut ();_bda ._ff <<=_bda ._bf ;_bda .byteOut ();_bda .emit ();if _bda ._fag !=0xff{_bda ._ce ++;_bda ._fag =0xff;_bda .emit ();};_bda ._ce ++;_bda ._fag =0xac;
_bda ._ce ++;_bda .emit ();};func (_ga *Encoder )codeMPS (_dff *codingContext ,_cd uint32 ,_ede uint16 ,_aff byte ){_ga ._c -=_ede ;if _ga ._c &0x8000!=0{_ga ._ff +=uint32 (_ede );return ;};if _ga ._c < _ede {_ga ._c =_ede ;}else {_ga ._ff +=uint32 (_ede );
};_dff ._da [_cd ]=_cde [_aff ]._dbb ;_ga .renormalize ();};func (_cage *Encoder )code0 (_aee *codingContext ,_bbac uint32 ,_fff uint16 ,_gdd byte ){if _aee .mps (_bbac )==0{_cage .codeMPS (_aee ,_bbac ,_fff ,_gdd );}else {_cage .codeLPS (_aee ,_bbac ,_fff ,_gdd );
};};type state struct{_ag uint16 ;_dbb ,_daa uint8 ;_gggb uint8 ;};type codingContext struct{_da []byte ;_eg []byte ;};var _gb =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_ed *codingContext )flipMps (_ea uint32 ){_ed ._eg [_ea ]=1-_ed ._eg [_ea ]};func (_bfb *Encoder )emit (){if _bfb ._ec ==_befb {_bfb ._fb =append (_bfb ._fb ,_bfb ._a );_bfb ._a =make ([]byte ,_befb );_bfb ._ec =0;};_bfb ._a [_bfb ._ec ]=_bfb ._fag ;
_bfb ._ec ++;};type intEncRangeS struct{_eb ,_bg int ;_fa ,_fc uint8 ;_ge uint16 ;_fac uint8 ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);type Encoder struct{_ff uint32 ;_c uint16 ;_bf ,_fag uint8 ;
_ce int ;_ffb int ;_fb [][]byte ;_a []byte ;_ec int ;_dc *codingContext ;_ca [13]*codingContext ;_fd *codingContext ;};func _fce (_fe int )*codingContext {return &codingContext {_da :make ([]byte ,_fe ),_eg :make ([]byte ,_fe )};};func (_fagc *Encoder )setBits (){_ebb :=_fagc ._ff +uint32 (_fagc ._c );
_fagc ._ff |=0xffff;if _fagc ._ff >=_ebb {_fagc ._ff -=0x8000;};};func (_cae *Encoder )dataSize ()int {return _befb *len (_cae ._fb )+_cae ._ec };func (_bb *Encoder )Refine (iTemp ,iTarget *_g .Bitmap ,ox ,oy int )error {for _gda :=0;_gda < iTarget .Height ;
_gda ++{var _cee int ;_ceac :=_gda +oy ;var (_ecb ,_ef ,_bba ,_ecc ,_gcb uint16 ;_cag ,_fdb ,_ceb ,_bfg ,_bfa byte ;);if _ceac >=1&&(_ceac -1)< iTemp .Height {_cag =iTemp .Data [(_ceac -1)*iTemp .RowStride ];};if _ceac >=0&&_ceac < iTemp .Height {_fdb =iTemp .Data [_ceac *iTemp .RowStride ];
};if _ceac >=-1&&_ceac +1< iTemp .Height {_ceb =iTemp .Data [(_ceac +1)*iTemp .RowStride ];};if _gda >=1{_bfg =iTarget .Data [(_gda -1)*iTarget .RowStride ];};_bfa =iTarget .Data [_gda *iTarget .RowStride ];_caa :=uint (6+ox );_ecb =uint16 (_cag >>_caa );
_ef =uint16 (_fdb >>_caa );_bba =uint16 (_ceb >>_caa );_ecc =uint16 (_bfg >>6);_df :=uint (2-ox );_cag <<=_df ;_fdb <<=_df ;_ceb <<=_df ;_bfg <<=2;for _cee =0;_cee < iTarget .Width ;_cee ++{_bgd :=(_ecb <<10)|(_ef <<7)|(_bba <<4)|(_ecc <<1)|_gcb ;_cebf :=_bfa >>7;
_ffc :=_bb .encodeBit (_bb ._dc ,uint32 (_bgd ),_cebf );if _ffc !=nil {return _ffc ;};_ecb <<=1;_ef <<=1;_bba <<=1;_ecc <<=1;_ecb |=uint16 (_cag >>7);_ef |=uint16 (_fdb >>7);_bba |=uint16 (_ceb >>7);_ecc |=uint16 (_bfg >>7);_gcb =uint16 (_cebf );_ceeg :=_cee %8;
_ae :=_cee /8+1;if _ceeg ==5+ox {_cag ,_fdb ,_ceb =0,0,0;if _ae < iTemp .RowStride &&_ceac >=1&&(_ceac -1)< iTemp .Height {_cag =iTemp .Data [(_ceac -1)*iTemp .RowStride +_ae ];};if _ae < iTemp .RowStride &&_ceac >=0&&_ceac < iTemp .Height {_fdb =iTemp .Data [_ceac *iTemp .RowStride +_ae ];
};if _ae < iTemp .RowStride &&_ceac >=-1&&(_ceac +1)< iTemp .Height {_ceb =iTemp .Data [(_ceac +1)*iTemp .RowStride +_ae ];};}else {_cag <<=1;_fdb <<=1;_ceb <<=1;};if _ceeg ==5&&_gda >=1{_bfg =0;if _ae < iTarget .RowStride {_bfg =iTarget .Data [(_gda -1)*iTarget .RowStride +_ae ];
};}else {_bfg <<=1;};if _ceeg ==7{_bfa =0;if _ae < iTarget .RowStride {_bfa =iTarget .Data [_gda *iTarget .RowStride +_ae ];};}else {_bfa <<=1;};_ecb &=7;_ef &=7;_bba &=7;_ecc &=7;};};return nil ;};type Class int ;func (_cg *Encoder )DataSize ()int {return _cg .dataSize ()};
func (_fec *Encoder )Init (){_fec ._dc =_fce (_dcd );_fec ._c =0x8000;_fec ._ff =0;_fec ._bf =12;_fec ._ce =-1;_fec ._fag =0;_fec ._ec =0;_fec ._a =make ([]byte ,_befb );for _aa :=0;_aa < len (_fec ._ca );_aa ++{_fec ._ca [_aa ]=_fce (512);};_fec ._fd =nil ;
};var _ _b .WriterTo =&Encoder {};func (_bgc *Encoder )Final (){_bgc .flush ()};func (_acc *Encoder )code1 (_bgg *codingContext ,_ccc uint32 ,_cce uint16 ,_cebd byte ){if _bgg .mps (_ccc )==1{_acc .codeMPS (_bgg ,_ccc ,_cce ,_cebd );}else {_acc .codeLPS (_bgg ,_ccc ,_cce ,_cebd );
};};func (_gg *Encoder )EncodeInteger (proc Class ,value int )(_ba error ){_d .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _ba =_gg .encodeInteger (proc ,value );_ba !=nil {return _dd .Wrap (_ba ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_fgc *Encoder )rBlock (){if _fgc ._ce >=0{_fgc .emit ();};_fgc ._ce ++;
_fgc ._fag =uint8 (_fgc ._ff >>20);_fgc ._ff &=0xfffff;_fgc ._bf =7;};const _gd =0x9b25;func (_be *codingContext )mps (_bd uint32 )int {return int (_be ._eg [_bd ])};func (_acf *Encoder )codeLPS (_ddb *codingContext ,_bdb uint32 ,_ee uint16 ,_egc byte ){_acf ._c -=_ee ;
if _acf ._c < _ee {_acf ._ff +=uint32 (_ee );}else {_acf ._c =_ee ;};if _cde [_egc ]._gggb ==1{_ddb .flipMps (_bdb );};_ddb ._da [_bdb ]=_cde [_egc ]._daa ;_acf .renormalize ();};func (_fg Class )String ()string {switch _fg {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_ecfa *Encoder )encodeOOB (_gae Class )error {_ece :=_ecfa ._ca [_gae ];_bbf :=_ecfa .encodeBit (_ece ,1,1);if _bbf !=nil {return _bbf ;};_bbf =_ecfa .encodeBit (_ece ,3,0);if _bbf !=nil {return _bbf ;
};_bbf =_ecfa .encodeBit (_ece ,6,0);if _bbf !=nil {return _bbf ;};_bbf =_ecfa .encodeBit (_ece ,12,0);if _bbf !=nil {return _bbf ;};return nil ;};func New ()*Encoder {_ad :=&Encoder {};_ad .Init ();return _ad };