//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "bytes";_aa "github.com/unidoc/unipdf/v3/common";_d "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_c "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);func (_eag *Encoder )encodeOOB (_ced Class )error {_gfe :=_eag ._dd [_ced ];
_aegc :=_eag .encodeBit (_gfe ,1,1);if _aegc !=nil {return _aegc ;};_aegc =_eag .encodeBit (_gfe ,3,0);if _aegc !=nil {return _aegc ;};_aegc =_eag .encodeBit (_gfe ,6,0);if _aegc !=nil {return _aegc ;};_aegc =_eag .encodeBit (_gfe ,12,0);if _aegc !=nil {return _aegc ;
};return nil ;};func (_cfe *Encoder )Reset (){_cfe ._b =0x8000;_cfe ._da =0;_cfe ._gc =12;_cfe ._ggg =-1;_cfe ._bc =0;_cfe ._ba =nil ;_cfe ._aeg =_fe (_ece );};func (_aab *codingContext )mps (_ef uint32 )int {return int (_aab ._ecg [_ef ])};func _fe (_gd int )*codingContext {return &codingContext {_gg :make ([]byte ,_gd ),_ecg :make ([]byte ,_gd )};
};func (_abd *Encoder )emit (){if _abd ._fa ==_bfb {_abd ._ee =append (_abd ._ee ,_abd ._fb );_abd ._fb =make ([]byte ,_bfb );_abd ._fa =0;};_abd ._fb [_abd ._fa ]=_abd ._bc ;_abd ._fa ++;};func (_geb *Encoder )Refine (iTemp ,iTarget *_d .Bitmap ,ox ,oy int )error {for _fc :=0;
_fc < iTarget .Height ;_fc ++{var _bcf int ;_fed :=_fc +oy ;var (_dfb ,_bd ,_af ,_gf ,_ada uint16 ;_dcd ,_edf ,_edag ,_gge ,_gde byte ;);if _fed >=1&&(_fed -1)< iTemp .Height {_dcd =iTemp .Data [(_fed -1)*iTemp .RowStride ];};if _fed >=0&&_fed < iTemp .Height {_edf =iTemp .Data [_fed *iTemp .RowStride ];
};if _fed >=-1&&_fed +1< iTemp .Height {_edag =iTemp .Data [(_fed +1)*iTemp .RowStride ];};if _fc >=1{_gge =iTarget .Data [(_fc -1)*iTarget .RowStride ];};_gde =iTarget .Data [_fc *iTarget .RowStride ];_ged :=uint (6+ox );_dfb =uint16 (_dcd >>_ged );_bd =uint16 (_edf >>_ged );
_af =uint16 (_edag >>_ged );_gf =uint16 (_gge >>6);_eg :=uint (2-ox );_dcd <<=_eg ;_edf <<=_eg ;_edag <<=_eg ;_gge <<=2;for _bcf =0;_bcf < iTarget .Width ;_bcf ++{_abg :=(_dfb <<10)|(_bd <<7)|(_af <<4)|(_gf <<1)|_ada ;_egg :=_gde >>7;_ffb :=_geb .encodeBit (_geb ._aeg ,uint32 (_abg ),_egg );
if _ffb !=nil {return _ffb ;};_dfb <<=1;_bd <<=1;_af <<=1;_gf <<=1;_dfb |=uint16 (_dcd >>7);_bd |=uint16 (_edf >>7);_af |=uint16 (_edag >>7);_gf |=uint16 (_gge >>7);_ada =uint16 (_egg );_gcf :=_bcf %8;_ag :=_bcf /8+1;if _gcf ==5+ox {_dcd ,_edf ,_edag =0,0,0;
if _ag < iTemp .RowStride &&_fed >=1&&(_fed -1)< iTemp .Height {_dcd =iTemp .Data [(_fed -1)*iTemp .RowStride +_ag ];};if _ag < iTemp .RowStride &&_fed >=0&&_fed < iTemp .Height {_edf =iTemp .Data [_fed *iTemp .RowStride +_ag ];};if _ag < iTemp .RowStride &&_fed >=-1&&(_fed +1)< iTemp .Height {_edag =iTemp .Data [(_fed +1)*iTemp .RowStride +_ag ];
};}else {_dcd <<=1;_edf <<=1;_edag <<=1;};if _gcf ==5&&_fc >=1{_gge =0;if _ag < iTarget .RowStride {_gge =iTarget .Data [(_fc -1)*iTarget .RowStride +_ag ];};}else {_gge <<=1;};if _gcf ==7{_gde =0;if _ag < iTarget .RowStride {_gde =iTarget .Data [_fc *iTarget .RowStride +_ag ];
};}else {_gde <<=1;};_dfb &=7;_bd &=7;_af &=7;_gf &=7;};};return nil ;};func (_eaf *Encoder )Flush (){_eaf ._fa =0;_eaf ._ee =nil ;_eaf ._ggg =-1};var _bag =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func New ()*Encoder {_de :=&Encoder {};_de .Init ();return _de };func (_eda *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ea error ){_aa .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ea =_eda .encodeIAID (symbolCodeLength ,value );_ea !=nil {return _c .Wrap (_ea ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_cea *Encoder )EncodeBitmap (bm *_d .Bitmap ,duplicateLineRemoval bool )error {_aa .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_bce ,_bcg uint8 ;_ac ,_gb ,_dg uint16 ;_fac ,_ddg ,_aaca byte ;_ddga ,_ggd ,_cg int ;_bcee ,_dc []byte ;);for _ddge :=0;_ddge < bm .Height ;_ddge ++{_fac ,_ddg =0,0;if _ddge >=2{_fac =bm .Data [(_ddge -2)*bm .RowStride ];};if _ddge >=1{_ddg =bm .Data [(_ddge -1)*bm .RowStride ];
if duplicateLineRemoval {_ggd =_ddge *bm .RowStride ;_bcee =bm .Data [_ggd :_ggd +bm .RowStride ];_cg =(_ddge -1)*bm .RowStride ;_dc =bm .Data [_cg :_cg +bm .RowStride ];if _e .Equal (_bcee ,_dc ){_bcg =_bce ^1;_bce =1;}else {_bcg =_bce ;_bce =0;};};};
if duplicateLineRemoval {if _efc :=_cea .encodeBit (_cea ._aeg ,_ab ,_bcg );_efc !=nil {return _efc ;};if _bce !=0{continue ;};};_aaca =bm .Data [_ddge *bm .RowStride ];_ac =uint16 (_fac >>5);_gb =uint16 (_ddg >>4);_fac <<=3;_ddg <<=4;_dg =0;for _ddga =0;
_ddga < bm .Width ;_ddga ++{_faf :=uint32 (_ac <<11|_gb <<4|_dg );_aca :=(_aaca &0x80)>>7;_ecd :=_cea .encodeBit (_cea ._aeg ,_faf ,_aca );if _ecd !=nil {return _ecd ;};_ac <<=1;_gb <<=1;_dg <<=1;_ac |=uint16 ((_fac &0x80)>>7);_gb |=uint16 ((_ddg &0x80)>>7);
_dg |=uint16 (_aca );_gga :=_ddga %8;_cc :=_ddga /8+1;if _gga ==4&&_ddge >=2{_fac =0;if _cc < bm .RowStride {_fac =bm .Data [(_ddge -2)*bm .RowStride +_cc ];};}else {_fac <<=1;};if _gga ==3&&_ddge >=1{_ddg =0;if _cc < bm .RowStride {_ddg =bm .Data [(_ddge -1)*bm .RowStride +_cc ];
};}else {_ddg <<=1;};if _gga ==7{_aaca =0;if _cc < bm .RowStride {_aaca =bm .Data [_ddge *bm .RowStride +_cc ];};}else {_aaca <<=1;};_ac &=31;_gb &=127;_dg &=15;};};return nil ;};type Class int ;func (_bg *Encoder )WriteTo (w _a .Writer )(int64 ,error ){const _fgd ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _eaec int64 ;for _fag ,_fcc :=range _bg ._ee {_ega ,_cgd :=w .Write (_fcc );if _cgd !=nil {return 0,_c .Wrapf (_cgd ,_fgd ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_fag );
};_eaec +=int64 (_ega );};_bg ._fb =_bg ._fb [:_bg ._fa ];_db ,_eee :=w .Write (_bg ._fb );if _eee !=nil {return 0,_c .Wrap (_eee ,_fgd ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_eaec +=int64 (_db );return _eaec ,nil ;
};func (_gaa *Encoder )flush (){_gaa .setBits ();_gaa ._da <<=_gaa ._gc ;_gaa .byteOut ();_gaa ._da <<=_gaa ._gc ;_gaa .byteOut ();_gaa .emit ();if _gaa ._bc !=0xff{_gaa ._ggg ++;_gaa ._bc =0xff;_gaa .emit ();};_gaa ._ggg ++;_gaa ._bc =0xac;_gaa ._ggg ++;
_gaa .emit ();};func (_dgc *Encoder )dataSize ()int {return _bfb *len (_dgc ._ee )+_dgc ._fa };func (_cfc *Encoder )codeMPS (_ade *codingContext ,_bf uint32 ,_abf uint16 ,_gbg byte ){_cfc ._b -=_abf ;if _cfc ._b &0x8000!=0{_cfc ._da +=uint32 (_abf );return ;
};if _cfc ._b < _abf {_cfc ._b =_abf ;}else {_cfc ._da +=uint32 (_abf );};_ade ._gg [_bf ]=_bag [_gbg ]._ecc ;_cfc .renormalize ();};const _ab =0x9b25;func (_gfc *Encoder )encodeBit (_feg *codingContext ,_bgg uint32 ,_fef uint8 )error {const _bbe ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_gfc ._ecb ++;if _bgg >=uint32 (len (_feg ._gg )){return _c .Errorf (_bbe ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_bgg );
};_bceg :=_feg ._gg [_bgg ];_fd :=_feg .mps (_bgg );_baea :=_bag [_bceg ]._egac ;_aa .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_gfc ._ecb ,_fef ,_bceg ,_fd ,_baea ,_gfc ._b ,_gfc ._da ,_gfc ._gc ,_gfc ._bc ,_gfc ._ggg );
if _fef ==0{_gfc .code0 (_feg ,_bgg ,_baea ,_bceg );}else {_gfc .code1 (_feg ,_bgg ,_baea ,_bceg );};return nil ;};func (_bab *Encoder )code1 (_ebb *codingContext ,_gbb uint32 ,_cfg uint16 ,_bb byte ){if _ebb .mps (_gbb )==1{_bab .codeMPS (_ebb ,_gbb ,_cfg ,_bb );
}else {_bab .codeLPS (_ebb ,_gbb ,_cfg ,_bb );};};func (_ad Class )String ()string {switch _ad {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";
case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";
case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_ga *Encoder )DataSize ()int {return _ga .dataSize ()};
type Encoder struct{_da uint32 ;_b uint16 ;_gc ,_bc uint8 ;_ggg int ;_ecb int ;_ee [][]byte ;_fb []byte ;_fa int ;_aeg *codingContext ;_dd [13]*codingContext ;_ba *codingContext ;};var _ _a .WriterTo =&Encoder {};func (_edff *Encoder )encodeIAID (_dgd ,_gcc int )error {if _edff ._ba ==nil {_edff ._ba =_fe (1<<uint (_dgd ));
};_bed :=uint32 (1<<uint32 (_dgd +1))-1;_gcc <<=uint (32-_dgd );_cdb :=uint32 (1);for _ggeb :=0;_ggeb < _dgd ;_ggeb ++{_cga :=_cdb &_bed ;_gbd :=uint8 ((uint32 (_gcc )&0x80000000)>>31);if _dgdc :=_edff .encodeBit (_edff ._ba ,_cga ,_gbd );_dgdc !=nil {return _dgdc ;
};_cdb =(_cdb <<1)|uint32 (_gbd );_gcc <<=1;};return nil ;};func (_daf *Encoder )codeLPS (_ecda *codingContext ,_bcggd uint32 ,_ddgg uint16 ,_ceae byte ){_daf ._b -=_ddgg ;if _daf ._b < _ddgg {_daf ._da +=uint32 (_ddgg );}else {_daf ._b =_ddgg ;};if _bag [_ceae ]._cb ==1{_ecda .flipMps (_bcggd );
};_ecda ._gg [_bcggd ]=_bag [_ceae ]._dcf ;_daf .renormalize ();};type intEncRangeS struct{_ce ,_ed int ;_aac ,_ae uint8 ;_f uint16 ;_ec uint8 ;};func (_fg *Encoder )EncodeInteger (proc Class ,value int )(_cf error ){_aa .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _cf =_fg .encodeInteger (proc ,value );_cf !=nil {return _c .Wrap (_cf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_beg *Encoder )lBlock (){if _beg ._ggg >=0{_beg .emit ();};_beg ._ggg ++;
_beg ._bc =uint8 (_beg ._da >>19);_beg ._da &=0x7ffff;_beg ._gc =8;};var _ff =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
type state struct{_egac uint16 ;_ecc ,_dcf uint8 ;_cb uint8 ;};func (_bcgg *Encoder )byteOut (){if _bcgg ._bc ==0xff{_bcgg .rBlock ();return ;};if _bcgg ._da < 0x8000000{_bcgg .lBlock ();return ;};_bcgg ._bc ++;if _bcgg ._bc !=0xff{_bcgg .lBlock ();return ;
};_bcgg ._da &=0x7ffffff;_bcgg .rBlock ();};func (_dag *Encoder )rBlock (){if _dag ._ggg >=0{_dag .emit ();};_dag ._ggg ++;_dag ._bc =uint8 (_dag ._da >>20);_dag ._da &=0xfffff;_dag ._gc =7;};func (_bgb *Encoder )renormalize (){for {_bgb ._b <<=1;_bgb ._da <<=1;
_bgb ._gc --;if _bgb ._gc ==0{_bgb .byteOut ();};if (_bgb ._b &0x8000)!=0{break ;};};};func (_ge *Encoder )Init (){_ge ._aeg =_fe (_ece );_ge ._b =0x8000;_ge ._da =0;_ge ._gc =12;_ge ._ggg =-1;_ge ._bc =0;_ge ._fa =0;_ge ._fb =make ([]byte ,_bfb );for _aef :=0;
_aef < len (_ge ._dd );_aef ++{_ge ._dd [_aef ]=_fe (512);};_ge ._ba =nil ;};type codingContext struct{_gg []byte ;_ecg []byte ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_eae *Encoder )EncodeOOB (proc Class )(_bae error ){_aa .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _bae =_eae .encodeOOB (proc );_bae !=nil {return _c .Wrap (_bae ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_df *codingContext )flipMps (_adc uint32 ){_df ._ecg [_adc ]=1-_df ._ecg [_adc ]};const (_ece =65536;_bfb =20*1024;
);func (_cgdf *Encoder )setBits (){_gec :=_cgdf ._da +uint32 (_cgdf ._b );_cgdf ._da |=0xffff;if _cgdf ._da >=_gec {_cgdf ._da -=0x8000;};};func (_acad *Encoder )Final (){_acad .flush ()};func (_egge *Encoder )encodeInteger (_agf Class ,_adef int )error {const _bba ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _adef > 2000000000||_adef < -2000000000{return _c .Errorf (_bba ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_adef );
};_agc :=_egge ._dd [_agf ];_bbed :=uint32 (1);var _ccf int ;for ;;_ccf ++{if _ff [_ccf ]._ce <=_adef &&_ff [_ccf ]._ed >=_adef {break ;};};if _adef < 0{_adef =-_adef ;};_adef -=int (_ff [_ccf ]._f );_cca :=_ff [_ccf ]._aac ;for _bff :=uint8 (0);_bff < _ff [_ccf ]._ae ;
_bff ++{_fff :=_cca &1;if _dfg :=_egge .encodeBit (_agc ,_bbed ,_fff );_dfg !=nil {return _c .Wrap (_dfg ,_bba ,"");};_cca >>=1;if _bbed &0x100> 0{_bbed =(((_bbed <<1)|uint32 (_fff ))&0x1ff)|0x100;}else {_bbed =(_bbed <<1)|uint32 (_fff );};};_adef <<=32-_ff [_ccf ]._ec ;
for _ccad :=uint8 (0);_ccad < _ff [_ccf ]._ec ;_ccad ++{_afe :=uint8 ((uint32 (_adef )&0x80000000)>>31);if _bcc :=_egge .encodeBit (_agc ,_bbed ,_afe );_bcc !=nil {return _c .Wrap (_bcc ,_bba ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_adef <<=1;if _bbed &0x100!=0{_bbed =(((_bbed <<1)|uint32 (_afe ))&0x1ff)|0x100;}else {_bbed =(_bbed <<1)|uint32 (_afe );};};return nil ;};func (_ca *Encoder )code0 (_cce *codingContext ,_be uint32 ,_deg uint16 ,_cd byte ){if _cce .mps (_be )==0{_ca .codeMPS (_cce ,_be ,_deg ,_cd );
}else {_ca .codeLPS (_cce ,_be ,_deg ,_cd );};};