//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_g "errors";_e "fmt";_f "github.com/unidoc/unipdf/v4/common";_a "github.com/unidoc/unipdf/v4/internal/bitwise";_eg "github.com/unidoc/unipdf/v4/internal/jbig2/bitmap";_ef "io";);func (_fg *Decoder )UncompressMMR ()(_bd *_eg .Bitmap ,_fccf error ){_bd =_eg .New (_fg ._gbf ,_fg ._gc );
_bdd :=make ([]int ,_bd .Width +5);_eeac :=make ([]int ,_bd .Width +5);_eeac [0]=_bd .Width ;_fge :=1;var _cag int ;for _cba :=0;_cba < _bd .Height ;_cba ++{_cag ,_fccf =_fg .uncompress2d (_fg ._aca ,_eeac ,_fge ,_bdd ,_bd .Width );if _fccf !=nil {return nil ,_fccf ;
};if _cag ==EOF {break ;};if _cag > 0{_fccf =_fg .fillBitmap (_bd ,_cba ,_bdd ,_cag );if _fccf !=nil {return nil ,_fccf ;};};_eeac ,_bdd =_bdd ,_eeac ;_fge =_cag ;};if _fccf =_fg .detectAndSkipEOL ();_fccf !=nil {return nil ,_fccf ;};_fg ._aca .align ();
return _bd ,nil ;};func _eda (_be [3]int )*code {return &code {_bb :_be [0],_fb :_be [1],_c :_be [2]}};func (_ga *Decoder )detectAndSkipEOL ()error {for {_dc ,_fcf :=_ga ._aca .uncompressGetCode (_ga ._eeg );if _fcf !=nil {return _fcf ;};if _dc !=nil &&_dc ._c ==EOL {_ga ._aca ._aba +=_dc ._bb ;
}else {return nil ;};};};func (_dggc *runData )uncompressGetCode (_fed []*code )(*code ,error ){return _dggc .uncompressGetCodeLittleEndian (_fed );};func _bc (_eed ,_eb int )int {if _eed < _eb {return _eb ;};return _eed ;};func (_gdf *Decoder )initTables ()(_cbb error ){if _gdf ._fab ==nil {_gdf ._fab ,_cbb =_gdf .createLittleEndianTable (_af );
if _cbb !=nil {return ;};_gdf ._gce ,_cbb =_gdf .createLittleEndianTable (_dg );if _cbb !=nil {return ;};_gdf ._eeg ,_cbb =_gdf .createLittleEndianTable (_ebd );if _cbb !=nil {return ;};};return nil ;};func _bac (_dea *_a .Reader )(*runData ,error ){_afb :=&runData {_adgd :_dea ,_aba :0,_cgf :1};
_fcd :=_fe (_bc (_bba ,int (_dea .Length ())),_bff );_afb ._daa =make ([]byte ,_fcd );if _eeae :=_afb .fillBuffer (0);_eeae !=nil {if _eeae ==_ef .EOF {_afb ._daa =make ([]byte ,10);_f .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_eeae );
}else {return nil ,_eeae ;};};return _afb ,nil ;};func (_eff *runData )uncompressGetCodeLittleEndian (_afa []*code )(*code ,error ){_abe ,_afac :=_eff .uncompressGetNextCodeLittleEndian ();if _afac !=nil {_f .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_afac );
return nil ,_afac ;};_abe &=0xffffff;_dfd :=_abe >>(_dga -_ebc );_dggf :=_afa [_dfd ];if _dggf !=nil &&_dggf ._ed {_dfd =(_abe >>(_dga -_ebc -_ad ))&_gb ;_dggf =_dggf ._ee [_dfd ];};return _dggf ,nil ;};type code struct{_bb int ;_fb int ;_c int ;_ee []*code ;
_ed bool ;};func _fe (_cb ,_gg int )int {if _cb > _gg {return _gg ;};return _cb ;};func (_ege *Decoder )uncompress1d (_gfc *runData ,_dad []int ,_ecg int )(int ,error ){var (_ea =true ;_dab int ;_dee *code ;_fcg int ;_ffa error ;);_ffg :for _dab < _ecg {_gcc :for {if _ea {_dee ,_ffa =_gfc .uncompressGetCode (_ege ._fab );
if _ffa !=nil {return 0,_ffa ;};}else {_dee ,_ffa =_gfc .uncompressGetCode (_ege ._gce );if _ffa !=nil {return 0,_ffa ;};};_gfc ._aba +=_dee ._bb ;if _dee ._c < 0{break _ffg ;};_dab +=_dee ._c ;if _dee ._c < 64{_ea =!_ea ;_dad [_fcg ]=_dab ;_fcg ++;break _gcc ;
};};};if _dad [_fcg ]!=_ecg {_dad [_fcg ]=_ecg ;};_ecf :=EOL ;if _dee !=nil &&_dee ._c !=EOL {_ecf =_fcg ;};return _ecf ,nil ;};func (_eeb *code )String ()string {return _e .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_eeb ._bb ,_eeb ._fb ,_eeb ._c );
};func (_gfcd *runData )align (){_gfcd ._aba =((_gfcd ._aba +7)>>3)<<3};func New (r *_a .Reader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_ff :=&Decoder {_gbf :width ,_gc :height };_ffe ,_fcc :=r .NewPartialReader (int (dataOffset ),int (dataLength ),false );
if _fcc !=nil {return nil ,_fcc ;};_eea ,_fcc :=_bac (_ffe );if _fcc !=nil {return nil ,_fcc ;};_ ,_fcc =r .Seek (_ffe .RelativePosition (),_ef .SeekCurrent );if _fcc !=nil {return nil ,_fcc ;};_ff ._aca =_eea ;if _ab :=_ff .initTables ();_ab !=nil {return nil ,_ab ;
};return _ff ,nil ;};const (_bff int =1024<<7;_bba int =3;_dga uint =24;);func (_ffeb *Decoder )uncompress2d (_bf *runData ,_dbe []int ,_cbe int ,_cff []int ,_ccc int )(int ,error ){var (_gab int ;_eab int ;_fd int ;_fad =true ;_gfca error ;_edb *code ;
);_dbe [_cbe ]=_ccc ;_dbe [_cbe +1]=_ccc ;_dbe [_cbe +2]=_ccc +1;_dbe [_cbe +3]=_ccc +1;_edf :for _fd < _ccc {_edb ,_gfca =_bf .uncompressGetCode (_ffeb ._eeg );if _gfca !=nil {return EOL ,nil ;};if _edb ==nil {_bf ._aba ++;break _edf ;};_bf ._aba +=_edb ._bb ;
switch mmrCode (_edb ._c ){case _fc :_fd =_dbe [_gab ];case _ec :_fd =_dbe [_gab ]+1;case _ggg :_fd =_dbe [_gab ]-1;case _ag :for {var _eeba []*code ;if _fad {_eeba =_ffeb ._fab ;}else {_eeba =_ffeb ._gce ;};_edb ,_gfca =_bf .uncompressGetCode (_eeba );
if _gfca !=nil {return 0,_gfca ;};if _edb ==nil {break _edf ;};_bf ._aba +=_edb ._bb ;if _edb ._c < 64{if _edb ._c < 0{_cff [_eab ]=_fd ;_eab ++;_edb =nil ;break _edf ;};_fd +=_edb ._c ;_cff [_eab ]=_fd ;_eab ++;break ;};_fd +=_edb ._c ;};_efe :=_fd ;_df :for {var _gea []*code ;
if !_fad {_gea =_ffeb ._fab ;}else {_gea =_ffeb ._gce ;};_edb ,_gfca =_bf .uncompressGetCode (_gea );if _gfca !=nil {return 0,_gfca ;};if _edb ==nil {break _edf ;};_bf ._aba +=_edb ._bb ;if _edb ._c < 64{if _edb ._c < 0{_cff [_eab ]=_fd ;_eab ++;break _edf ;
};_fd +=_edb ._c ;if _fd < _ccc ||_fd !=_efe {_cff [_eab ]=_fd ;_eab ++;};break _df ;};_fd +=_edb ._c ;};for _fd < _ccc &&_dbe [_gab ]<=_fd {_gab +=2;};continue _edf ;case _ac :_gab ++;_fd =_dbe [_gab ];_gab ++;continue _edf ;case _ca :_fd =_dbe [_gab ]+2;
case _bg :_fd =_dbe [_gab ]-2;case _bcf :_fd =_dbe [_gab ]+3;case _cc :_fd =_dbe [_gab ]-3;default:if _bf ._aba ==12&&_edb ._c ==EOL {_bf ._aba =0;if _ ,_gfca =_ffeb .uncompress1d (_bf ,_dbe ,_ccc );_gfca !=nil {return 0,_gfca ;};_bf ._aba ++;if _ ,_gfca =_ffeb .uncompress1d (_bf ,_cff ,_ccc );
_gfca !=nil {return 0,_gfca ;};_ccb ,_cg :=_ffeb .uncompress1d (_bf ,_dbe ,_ccc );if _cg !=nil {return EOF ,_cg ;};_bf ._aba ++;return _ccb ,nil ;};_fd =_ccc ;continue _edf ;};if _fd <=_ccc {_fad =!_fad ;_cff [_eab ]=_fd ;_eab ++;if _gab > 0{_gab --;}else {_gab ++;
};for _fd < _ccc &&_dbe [_gab ]<=_fd {_gab +=2;};};};if _cff [_eab ]!=_ccc {_cff [_eab ]=_ccc ;};if _edb ==nil {return EOL ,nil ;};return _eab ,nil ;};func (_agb *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_baa :=_agb ._aba -_agb ._cgf ;
if _baa < 0||_baa > 24{_cge :=(_agb ._aba >>3)-_agb ._acabd ;if _cge >=_agb ._dgg {_cge +=_agb ._acabd ;if _caa :=_agb .fillBuffer (_cge );_caa !=nil {return 0,_caa ;};_cge -=_agb ._acabd ;};_cfg :=(uint32 (_agb ._daa [_cge ]&0xFF)<<16)|(uint32 (_agb ._daa [_cge +1]&0xFF)<<8)|(uint32 (_agb ._daa [_cge +2]&0xFF));
_dfc :=uint32 (_agb ._aba &7);_cfg <<=_dfc ;_agb ._ba =int (_cfg );}else {_fbf :=_agb ._cgf &7;_ada :=7-_fbf ;if _baa <=_ada {_agb ._ba <<=uint (_baa );}else {_deg :=(_agb ._cgf >>3)+3-_agb ._acabd ;if _deg >=_agb ._dgg {_deg +=_agb ._acabd ;if _baae :=_agb .fillBuffer (_deg );
_baae !=nil {return 0,_baae ;};_deg -=_agb ._acabd ;};_fbf =8-_fbf ;for {_agb ._ba <<=uint (_fbf );_agb ._ba |=int (uint (_agb ._daa [_deg ])&0xFF);_baa -=_fbf ;_deg ++;_fbf =8;if !(_baa >=8){break ;};};_agb ._ba <<=uint (_baa );};};_agb ._cgf =_agb ._aba ;
return _agb ._ba ,nil ;};type runData struct{_adgd *_a .Reader ;_aba int ;_cgf int ;_ba int ;_daa []byte ;_acabd int ;_dgg int ;};const (EOF =-3;_fa =-2;EOL =-1;_ebc =8;_egg =(1<<_ebc )-1;_ad =5;_gb =(1<<_ad )-1;);func (_ccee *runData )fillBuffer (_cgfd int )error {_ccee ._acabd =_cgfd ;
_ ,_fbfa :=_ccee ._adgd .Seek (int64 (_cgfd ),_ef .SeekStart );if _fbfa !=nil {if _fbfa ==_ef .EOF {_f .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_ccee ._dgg =-1;}else {return _fbfa ;};};if _fbfa ==nil {_ccee ._dgg ,_fbfa =_ccee ._adgd .Read (_ccee ._daa );
if _fbfa !=nil {if _fbfa ==_ef .EOF {_f .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_ccee ._dgg =-1;}else {return _fbfa ;};};};if _ccee ._dgg > -1&&_ccee ._dgg < 3{for _ccee ._dgg < 3{_eabb ,_gceg :=_ccee ._adgd .ReadByte ();if _gceg !=nil {if _gceg ==_ef .EOF {_ccee ._daa [_ccee ._dgg ]=0;
}else {return _gceg ;};}else {_ccee ._daa [_ccee ._dgg ]=_eabb &0xFF;};_ccee ._dgg ++;};};_ccee ._dgg -=3;if _ccee ._dgg < 0{_ccee ._daa =make ([]byte ,len (_ccee ._daa ));_ccee ._dgg =len (_ccee ._daa )-3;};return nil ;};func (_abd *Decoder )createLittleEndianTable (_gcg [][3]int )([]*code ,error ){_gcd :=make ([]*code ,_egg +1);
for _cf :=0;_cf < len (_gcg );_cf ++{_eef :=_eda (_gcg [_cf ]);if _eef ._bb <=_ebc {_bcd :=_ebc -_eef ._bb ;_dd :=_eef ._fb <<uint (_bcd );for _gd :=(1<<uint (_bcd ))-1;_gd >=0;_gd --{_da :=_dd |_gd ;_gcd [_da ]=_eef ;};}else {_acab :=_eef ._fb >>uint (_eef ._bb -_ebc );
if _gcd [_acab ]==nil {var _de =_eda ([3]int {});_de ._ee =make ([]*code ,_gb +1);_gcd [_acab ]=_de ;};if _eef ._bb <=_ebc +_ad {_cce :=_ebc +_ad -_eef ._bb ;_eead :=(_eef ._fb <<uint (_cce ))&_gb ;_gcd [_acab ]._ed =true ;for _gba :=(1<<uint (_cce ))-1;
_gba >=0;_gba --{_gcd [_acab ]._ee [_eead |_gba ]=_eef ;};}else {return nil ,_g .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _gcd ,nil ;};type mmrCode int ;var (_ebd =[][3]int {{4,0x1,int (_ac )},{3,0x1,int (_ag )},{1,0x1,int (_fc )},{3,0x3,int (_ec )},{6,0x3,int (_ca )},{7,0x3,int (_bcf )},{3,0x2,int (_ggg )},{6,0x2,int (_bg )},{7,0x2,int (_cc )},{10,0xf,int (_d )},{12,0xf,int (_feg )},{12,0x1,int (EOL )}};
_af =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_fa },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_fa },{11,0x01,_fa },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_dg =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_fa },{9,0x18,15},{10,0x01,_fa },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_fa },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);const (_ac mmrCode =iota ;_ag ;_fc ;_ec ;_ca ;_bcf ;_ggg ;_bg ;_cc ;_d ;_feg ;);type Decoder struct{_gbf ,_gc int ;_aca *runData ;_fab []*code ;_gce []*code ;_eeg []*code ;};func (_ece *Decoder )fillBitmap (_faa *_eg .Bitmap ,_aa int ,_adg []int ,_dge int )error {var _eedb byte ;
_daf :=0;_aab :=_faa .GetByteIndex (_daf ,_aa );for _ge :=0;_ge < _dge ;_ge ++{_cfc :=byte (1);_dcb :=_adg [_ge ];if (_ge &1)==0{_cfc =0;};for _daf < _dcb {_eedb =(_eedb <<1)|_cfc ;_daf ++;if (_daf &7)==0{if _efa :=_faa .SetByte (_aab ,_eedb );_efa !=nil {return _efa ;
};_aab ++;_eedb =0;};};};if (_daf &7)!=0{_eedb <<=uint (8-(_daf &7));if _gf :=_faa .SetByte (_aab ,_eedb );_gf !=nil {return _gf ;};};return nil ;};