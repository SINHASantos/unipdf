//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_eb "errors";_c "fmt";_d "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "io";);func _df (_gd [3]int )*code {return &code {_cd :_gd [0],_fd :_gd [1],_de :_gd [2]}};
func New (r *_g .Reader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_cfa :=&Decoder {_ff :width ,_afg :height };_dd ,_fdb :=r .NewPartialReader (int (dataOffset ),int (dataLength ),false );if _fdb !=nil {return nil ,_fdb ;};_bgb ,_fdb :=_agd (_dd );
if _fdb !=nil {return nil ,_fdb ;};_ ,_fdb =r .Seek (_dd .RelativePosition (),_e .SeekCurrent );if _fdb !=nil {return nil ,_fdb ;};_cfa ._dag =_bgb ;if _ge :=_cfa .initTables ();_ge !=nil {return nil ,_ge ;};return _cfa ,nil ;};func _fc (_ac ,_deg int )int {if _ac > _deg {return _deg ;
};return _ac ;};func (_egc *runData )uncompressGetCodeLittleEndian (_bbd []*code )(*code ,error ){_bfa ,_db :=_egc .uncompressGetNextCodeLittleEndian ();if _db !=nil {_d .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_db );
return nil ,_db ;};_bfa &=0xffffff;_gff :=_bfa >>(_gge -_gb );_fbg :=_bbd [_gff ];if _fbg !=nil &&_fbg ._cf {_gff =(_bfa >>(_gge -_gb -_feg ))&_dce ;_fbg =_fbg ._fe [_gff ];};return _fbg ,nil ;};type runData struct{_aead *_g .Reader ;_cdc int ;_dde int ;
_eed int ;_bef []byte ;_bbbe int ;_gdff int ;};const (_fegc int =1024<<7;_daf int =3;_gge uint =24;);func _b (_ec ,_dc int )int {if _ec < _dc {return _dc ;};return _ec ;};var (_cdf =[][3]int {{4,0x1,int (_cfg )},{3,0x1,int (_dff )},{1,0x1,int (_af )},{3,0x3,int (_bb )},{6,0x3,int (_dec )},{7,0x3,int (_ba )},{3,0x2,int (_ae )},{6,0x2,int (_da )},{7,0x2,int (_gdc )},{10,0xf,int (_fcf )},{12,0xf,int (_be )},{12,0x1,int (EOL )}};
_bf =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_bg },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_bg },{11,0x01,_bg },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_eg =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_bg },{9,0x18,15},{10,0x01,_bg },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_bg },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func (_agg *Decoder )uncompress2d (_egf *runData ,_cfb []int ,_dda int ,_cdb []int ,_caag int )(int ,error ){var (_bgc int ;_ebg int ;_gg int ;_aab =true ;_acg error ;_cfc *code ;);_cfb [_dda ]=_caag ;_cfb [_dda +1]=_caag ;_cfb [_dda +2]=_caag +1;_cfb [_dda +3]=_caag +1;
_fcc :for _gg < _caag {_cfc ,_acg =_egf .uncompressGetCode (_agg ._ecd );if _acg !=nil {return EOL ,nil ;};if _cfc ==nil {_egf ._cdc ++;break _fcc ;};_egf ._cdc +=_cfc ._cd ;switch mmrCode (_cfc ._de ){case _af :_gg =_cfb [_bgc ];case _bb :_gg =_cfb [_bgc ]+1;
case _ae :_gg =_cfb [_bgc ]-1;case _dff :for {var _cbg []*code ;if _aab {_cbg =_agg ._ad ;}else {_cbg =_agg ._dfb ;};_cfc ,_acg =_egf .uncompressGetCode (_cbg );if _acg !=nil {return 0,_acg ;};if _cfc ==nil {break _fcc ;};_egf ._cdc +=_cfc ._cd ;if _cfc ._de < 64{if _cfc ._de < 0{_cdb [_ebg ]=_gg ;
_ebg ++;_cfc =nil ;break _fcc ;};_gg +=_cfc ._de ;_cdb [_ebg ]=_gg ;_ebg ++;break ;};_gg +=_cfc ._de ;};_cc :=_gg ;_dffa :for {var _cbb []*code ;if !_aab {_cbb =_agg ._ad ;}else {_cbb =_agg ._dfb ;};_cfc ,_acg =_egf .uncompressGetCode (_cbb );if _acg !=nil {return 0,_acg ;
};if _cfc ==nil {break _fcc ;};_egf ._cdc +=_cfc ._cd ;if _cfc ._de < 64{if _cfc ._de < 0{_cdb [_ebg ]=_gg ;_ebg ++;break _fcc ;};_gg +=_cfc ._de ;if _gg < _caag ||_gg !=_cc {_cdb [_ebg ]=_gg ;_ebg ++;};break _dffa ;};_gg +=_cfc ._de ;};for _gg < _caag &&_cfb [_bgc ]<=_gg {_bgc +=2;
};continue _fcc ;case _cfg :_bgc ++;_gg =_cfb [_bgc ];_bgc ++;continue _fcc ;case _dec :_gg =_cfb [_bgc ]+2;case _da :_gg =_cfb [_bgc ]-2;case _ba :_gg =_cfb [_bgc ]+3;case _gdc :_gg =_cfb [_bgc ]-3;default:if _egf ._cdc ==12&&_cfc ._de ==EOL {_egf ._cdc =0;
if _ ,_acg =_agg .uncompress1d (_egf ,_cfb ,_caag );_acg !=nil {return 0,_acg ;};_egf ._cdc ++;if _ ,_acg =_agg .uncompress1d (_egf ,_cdb ,_caag );_acg !=nil {return 0,_acg ;};_afgg ,_ea :=_agg .uncompress1d (_egf ,_cfb ,_caag );if _ea !=nil {return EOF ,_ea ;
};_egf ._cdc ++;return _afgg ,nil ;};_gg =_caag ;continue _fcc ;};if _gg <=_caag {_aab =!_aab ;_cdb [_ebg ]=_gg ;_ebg ++;if _bgc > 0{_bgc --;}else {_bgc ++;};for _gg < _caag &&_cfb [_bgc ]<=_gg {_bgc +=2;};};};if _cdb [_ebg ]!=_caag {_cdb [_ebg ]=_caag ;
};if _cfc ==nil {return EOL ,nil ;};return _ebg ,nil ;};type Decoder struct{_ff ,_afg int ;_dag *runData ;_ad []*code ;_dfb []*code ;_ecd []*code ;};func (_fdf *Decoder )uncompress1d (_ege *runData ,_aga []int ,_cab int )(int ,error ){var (_daa =true ;
_caa int ;_gcd *code ;_ee int ;_fdbc error ;);_ged :for _caa < _cab {_adb :for {if _daa {_gcd ,_fdbc =_ege .uncompressGetCode (_fdf ._ad );if _fdbc !=nil {return 0,_fdbc ;};}else {_gcd ,_fdbc =_ege .uncompressGetCode (_fdf ._dfb );if _fdbc !=nil {return 0,_fdbc ;
};};_ege ._cdc +=_gcd ._cd ;if _gcd ._de < 0{break _ged ;};_caa +=_gcd ._de ;if _gcd ._de < 64{_daa =!_daa ;_aga [_ee ]=_caa ;_ee ++;break _adb ;};};};if _aga [_ee ]!=_cab {_aga [_ee ]=_cab ;};_fda :=EOL ;if _gcd !=nil &&_gcd ._de !=EOL {_fda =_ee ;};return _fda ,nil ;
};func _agd (_fde *_g .Reader )(*runData ,error ){_fa :=&runData {_aead :_fde ,_cdc :0,_dde :1};_aad :=_fc (_b (_daf ,int (_fde .Length ())),_fegc );_fa ._bef =make ([]byte ,_aad );if _dfbd :=_fa .fillBuffer (0);_dfbd !=nil {if _dfbd ==_e .EOF {_fa ._bef =make ([]byte ,10);
_d .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_dfbd );}else {return nil ,_dfbd ;};};return _fa ,nil ;};func (_agc *Decoder )createLittleEndianTable (_gbe [][3]int )([]*code ,error ){_fb :=make ([]*code ,_gdf +1);
for _dg :=0;_dg < len (_gbe );_dg ++{_gdg :=_df (_gbe [_dg ]);if _gdg ._cd <=_gb {_aag :=_gb -_gdg ._cd ;_acc :=_gdg ._fd <<uint (_aag );for _bba :=(1<<uint (_aag ))-1;_bba >=0;_bba --{_bfg :=_acc |_bba ;_fb [_bfg ]=_gdg ;};}else {_aea :=_gdg ._fd >>uint (_gdg ._cd -_gb );
if _fb [_aea ]==nil {var _ga =_df ([3]int {});_ga ._fe =make ([]*code ,_dce +1);_fb [_aea ]=_ga ;};if _gdg ._cd <=_gb +_feg {_bfd :=_gb +_feg -_gdg ._cd ;_fcg :=(_gdg ._fd <<uint (_bfd ))&_dce ;_fb [_aea ]._cf =true ;for _ab :=(1<<uint (_bfd ))-1;_ab >=0;
_ab --{_fb [_aea ]._fe [_fcg |_ab ]=_gdg ;};}else {return nil ,_eb .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _fb ,nil ;};func (_cce *runData )align (){_cce ._cdc =((_cce ._cdc +7)>>3)<<3};func (_baf *Decoder )fillBitmap (_gce *_f .Bitmap ,_bd int ,_bcg []int ,_ece int )error {var _fce byte ;_bcf :=0;_fdbb :=_gce .GetByteIndex (_bcf ,_bd );for _accf :=0;
_accf < _ece ;_accf ++{_ecc :=byte (1);_afa :=_bcg [_accf ];if (_accf &1)==0{_ecc =0;};for _bcf < _afa {_fce =(_fce <<1)|_ecc ;_bcf ++;if (_bcf &7)==0{if _gbb :=_gce .SetByte (_fdbb ,_fce );_gbb !=nil {return _gbb ;};_fdbb ++;_fce =0;};};};if (_bcf &7)!=0{_fce <<=uint (8-(_bcf &7));
if _aae :=_gce .SetByte (_fdbb ,_fce );_aae !=nil {return _aae ;};};return nil ;};type code struct{_cd int ;_fd int ;_de int ;_fe []*code ;_cf bool ;};func (_dagc *Decoder )UncompressMMR ()(_aa *_f .Bitmap ,_bee error ){_aa =_f .New (_dagc ._ff ,_dagc ._afg );
_fdg :=make ([]int ,_aa .Width +5);_bbb :=make ([]int ,_aa .Width +5);_bbb [0]=_aa .Width ;_fef :=1;var _ag int ;for _bc :=0;_bc < _aa .Height ;_bc ++{_ag ,_bee =_dagc .uncompress2d (_dagc ._dag ,_bbb ,_fef ,_fdg ,_aa .Width );if _bee !=nil {return nil ,_bee ;
};if _ag ==EOF {break ;};if _ag > 0{_bee =_dagc .fillBitmap (_aa ,_bc ,_fdg ,_ag );if _bee !=nil {return nil ,_bee ;};};_bbb ,_fdg =_fdg ,_bbb ;_fef =_ag ;};if _bee =_dagc .detectAndSkipEOL ();_bee !=nil {return nil ,_bee ;};_dagc ._dag .align ();return _aa ,nil ;
};func (_dgb *Decoder )initTables ()(_cb error ){if _dgb ._ad ==nil {_dgb ._ad ,_cb =_dgb .createLittleEndianTable (_bf );if _cb !=nil {return ;};_dgb ._dfb ,_cb =_dgb .createLittleEndianTable (_eg );if _cb !=nil {return ;};_dgb ._ecd ,_cb =_dgb .createLittleEndianTable (_cdf );
if _cb !=nil {return ;};};return nil ;};func (_cg *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_afc :=_cg ._cdc -_cg ._dde ;if _afc < 0||_afc > 24{_abe :=(_cg ._cdc >>3)-_cg ._bbbe ;if _abe >=_cg ._gdff {_abe +=_cg ._bbbe ;if _gac :=_cg .fillBuffer (_abe );
_gac !=nil {return 0,_gac ;};_abe -=_cg ._bbbe ;};_acce :=(uint32 (_cg ._bef [_abe ]&0xFF)<<16)|(uint32 (_cg ._bef [_abe +1]&0xFF)<<8)|(uint32 (_cg ._bef [_abe +2]&0xFF));_fdeb :=uint32 (_cg ._cdc &7);_acce <<=_fdeb ;_cg ._eed =int (_acce );}else {_aeac :=_cg ._dde &7;
_bgf :=7-_aeac ;if _afc <=_bgf {_cg ._eed <<=uint (_afc );}else {_adba :=(_cg ._dde >>3)+3-_cg ._bbbe ;if _adba >=_cg ._gdff {_adba +=_cg ._bbbe ;if _gfa :=_cg .fillBuffer (_adba );_gfa !=nil {return 0,_gfa ;};_adba -=_cg ._bbbe ;};_aeac =8-_aeac ;for {_cg ._eed <<=uint (_aeac );
_cg ._eed |=int (uint (_cg ._bef [_adba ])&0xFF);_afc -=_aeac ;_adba ++;_aeac =8;if !(_afc >=8){break ;};};_cg ._eed <<=uint (_afc );};};_cg ._dde =_cg ._cdc ;return _cg ._eed ,nil ;};const (_cfg mmrCode =iota ;_dff ;_af ;_bb ;_dec ;_ba ;_ae ;_da ;_gdc ;
_fcf ;_be ;);type mmrCode int ;const (EOF =-3;_bg =-2;EOL =-1;_gb =8;_gdf =(1<<_gb )-1;_feg =5;_dce =(1<<_feg )-1;);func (_eba *code )String ()string {return _c .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_eba ._cd ,_eba ._fd ,_eba ._de );
};func (_ca *Decoder )detectAndSkipEOL ()error {for {_gc ,_cfe :=_ca ._dag .uncompressGetCode (_ca ._ecd );if _cfe !=nil {return _cfe ;};if _gc !=nil &&_gc ._de ==EOL {_ca ._dag ._cdc +=_gc ._cd ;}else {return nil ;};};};func (_eef *runData )uncompressGetCode (_dge []*code )(*code ,error ){return _eef .uncompressGetCodeLittleEndian (_dge );
};func (_aaee *runData )fillBuffer (_ebge int )error {_aaee ._bbbe =_ebge ;_ ,_abd :=_aaee ._aead .Seek (int64 (_ebge ),_e .SeekStart );if _abd !=nil {if _abd ==_e .EOF {_d .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_aaee ._gdff =-1;
}else {return _abd ;};};if _abd ==nil {_aaee ._gdff ,_abd =_aaee ._aead .Read (_aaee ._bef );if _abd !=nil {if _abd ==_e .EOF {_d .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_aaee ._gdff =-1;}else {return _abd ;};};};if _aaee ._gdff > -1&&_aaee ._gdff < 3{for _aaee ._gdff < 3{_ace ,_ada :=_aaee ._aead .ReadByte ();
if _ada !=nil {if _ada ==_e .EOF {_aaee ._bef [_aaee ._gdff ]=0;}else {return _ada ;};}else {_aaee ._bef [_aaee ._gdff ]=_ace &0xFF;};_aaee ._gdff ++;};};_aaee ._gdff -=3;if _aaee ._gdff < 0{_aaee ._bef =make ([]byte ,len (_aaee ._bef ));_aaee ._gdff =len (_aaee ._bef )-3;
};return nil ;};