//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_eg "errors";_g "fmt";_ga "github.com/unidoc/unipdf/v4/common";_gd "github.com/unidoc/unipdf/v4/internal/bitwise";_d "github.com/unidoc/unipdf/v4/internal/jbig2/bitmap";_e "io";);type mmrCode int ;func (_af *runData )uncompressGetCode (_gad []*code )(*code ,error ){return _af .uncompressGetCodeLittleEndian (_gad );
};func (_bbeb *Decoder )uncompress1d (_gdf *runData ,_fg []int ,_bfb int )(int ,error ){var (_aac =true ;_gda int ;_adg *code ;_cdd int ;_faf error ;);_be :for _gda < _bfb {_eae :for {if _aac {_adg ,_faf =_gdf .uncompressGetCode (_bbeb ._bad );if _faf !=nil {return 0,_faf ;
};}else {_adg ,_faf =_gdf .uncompressGetCode (_bbeb ._efa );if _faf !=nil {return 0,_faf ;};};_gdf ._fcf +=_adg ._b ;if _adg ._dd < 0{break _be ;};_gda +=_adg ._dd ;if _adg ._dd < 64{_aac =!_aac ;_fg [_cdd ]=_gda ;_cdd ++;break _eae ;};};};if _fg [_cdd ]!=_bfb {_fg [_cdd ]=_bfb ;
};_cddc :=EOL ;if _adg !=nil &&_adg ._dd !=EOL {_cddc =_cdd ;};return _cddc ,nil ;};func (_bf *Decoder )createLittleEndianTable (_fac [][3]int )([]*code ,error ){_ggb :=make ([]*code ,_dfc +1);for _bbe :=0;_bbe < len (_fac );_bbe ++{_agb :=_cd (_fac [_bbe ]);
if _agb ._b <=_gcf {_cg :=_gcf -_agb ._b ;_ebd :=_agb ._a <<uint (_cg );for _cf :=(1<<uint (_cg ))-1;_cf >=0;_cf --{_face :=_ebd |_cf ;_ggb [_face ]=_agb ;};}else {_edg :=_agb ._a >>uint (_agb ._b -_gcf );if _ggb [_edg ]==nil {var _add =_cd ([3]int {});
_add ._ef =make ([]*code ,_ag +1);_ggb [_edg ]=_add ;};if _agb ._b <=_gcf +_dfe {_agg :=_gcf +_dfe -_agb ._b ;_gae :=(_agb ._a <<uint (_agg ))&_ag ;_ggb [_edg ]._df =true ;for _dcee :=(1<<uint (_agg ))-1;_dcee >=0;_dcee --{_ggb [_edg ]._ef [_gae |_dcee ]=_agb ;
};}else {return nil ,_eg .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");};};};return _ggb ,nil ;};const (EOF =-3;
_fc =-2;EOL =-1;_gcf =8;_dfc =(1<<_gcf )-1;_dfe =5;_ag =(1<<_dfe )-1;);type code struct{_b int ;_a int ;_dd int ;_ef []*code ;_df bool ;};func _ba (_ca ,_dc int )int {if _ca > _dc {return _dc ;};return _ca ;};func (_efb *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_gef :=_efb ._fcf -_efb ._abf ;
if _gef < 0||_gef > 24{_dcd :=(_efb ._fcf >>3)-_efb ._gdd ;if _dcd >=_efb ._ebdc {_dcd +=_efb ._gdd ;if _begg :=_efb .fillBuffer (_dcd );_begg !=nil {return 0,_begg ;};_dcd -=_efb ._gdd ;};_fee :=(uint32 (_efb ._dcbf [_dcd ]&0xFF)<<16)|(uint32 (_efb ._dcbf [_dcd +1]&0xFF)<<8)|(uint32 (_efb ._dcbf [_dcd +2]&0xFF));
_aeb :=uint32 (_efb ._fcf &7);_fee <<=_aeb ;_efb ._beg =int (_fee );}else {_decf :=_efb ._abf &7;_fdc :=7-_decf ;if _gef <=_fdc {_efb ._beg <<=uint (_gef );}else {_befg :=(_efb ._abf >>3)+3-_efb ._gdd ;if _befg >=_efb ._ebdc {_befg +=_efb ._gdd ;if _gbba :=_efb .fillBuffer (_befg );
_gbba !=nil {return 0,_gbba ;};_befg -=_efb ._gdd ;};_decf =8-_decf ;for {_efb ._beg <<=uint (_decf );_efb ._beg |=int (uint (_efb ._dcbf [_befg ])&0xFF);_gef -=_decf ;_befg ++;_decf =8;if !(_gef >=8){break ;};};_efb ._beg <<=uint (_gef );};};_efb ._abf =_efb ._fcf ;
return _efb ._beg ,nil ;};func (_gebb *runData )align (){_gebb ._fcf =((_gebb ._fcf +7)>>3)<<3};func (_gde *Decoder )detectAndSkipEOL ()error {for {_cfa ,_cae :=_gde ._fa .uncompressGetCode (_gde ._ae );if _cae !=nil {return _cae ;};if _cfa !=nil &&_cfa ._dd ==EOL {_gde ._fa ._fcf +=_cfa ._b ;
}else {return nil ;};};};const (_dce mmrCode =iota ;_gg ;_gc ;_eb ;_ce ;_ee ;_f ;_cab ;_cb ;_dcg ;_aa ;);type runData struct{_dcb *_gd .Reader ;_fcf int ;_abf int ;_beg int ;_dcbf []byte ;_gdd int ;_ebdc int ;};const (_cga int =1024<<7;_caf int =3;_bed uint =24;
);var (_edd =[][3]int {{4,0x1,int (_dce )},{3,0x1,int (_gg )},{1,0x1,int (_gc )},{3,0x3,int (_eb )},{6,0x3,int (_ce )},{7,0x3,int (_ee )},{3,0x2,int (_f )},{6,0x2,int (_cab )},{7,0x2,int (_cb )},{10,0xf,int (_dcg )},{12,0xf,int (_aa )},{12,0x1,int (EOL )}};
_bag =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_fc },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_fc },{11,0x01,_fc },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_ge =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_fc },{9,0x18,15},{10,0x01,_fc },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_fc },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func _cd (_de [3]int )*code {return &code {_b :_de [0],_a :_de [1],_dd :_de [2]}};func (_bbf *Decoder )fillBitmap (_eeb *_d .Bitmap ,_dbe int ,_gf []int ,_ded int )error {var _gec byte ;_ddb :=0;_da :=_eeb .GetByteIndex (_ddb ,_dbe );for _bd :=0;_bd < _ded ;
_bd ++{_gbe :=byte (1);_cc :=_gf [_bd ];if (_bd &1)==0{_gbe =0;};for _ddb < _cc {_gec =(_gec <<1)|_gbe ;_ddb ++;if (_ddb &7)==0{if _eab :=_eeb .SetByte (_da ,_gec );_eab !=nil {return _eab ;};_da ++;_gec =0;};};};if (_ddb &7)!=0{_gec <<=uint (8-(_ddb &7));
if _dcf :=_eeb .SetByte (_da ,_gec );_dcf !=nil {return _dcf ;};};return nil ;};func _egc (_dgg *_gd .Reader )(*runData ,error ){_gac :=&runData {_dcb :_dgg ,_fcf :0,_abf :1};_gddc :=_ba (_ed (_caf ,int (_dgg .Length ())),_cga );_gac ._dcbf =make ([]byte ,_gddc );
if _fde :=_gac .fillBuffer (0);_fde !=nil {if _fde ==_e .EOF {_gac ._dcbf =make ([]byte ,10);_ga .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_fde );}else {return nil ,_fde ;};};return _gac ,nil ;
};func (_cbe *Decoder )UncompressMMR ()(_geb *_d .Bitmap ,_eda error ){_geb =_d .New (_cbe ._db ,_cbe ._bb );_egg :=make ([]int ,_geb .Width +5);_bg :=make ([]int ,_geb .Width +5);_bg [0]=_geb .Width ;_ec :=1;var _gcg int ;for _ff :=0;_ff < _geb .Height ;
_ff ++{_gcg ,_eda =_cbe .uncompress2d (_cbe ._fa ,_bg ,_ec ,_egg ,_geb .Width );if _eda !=nil {return nil ,_eda ;};if _gcg ==EOF {break ;};if _gcg > 0{_eda =_cbe .fillBitmap (_geb ,_ff ,_egg ,_gcg );if _eda !=nil {return nil ,_eda ;};};_bg ,_egg =_egg ,_bg ;
_ec =_gcg ;};if _eda =_cbe .detectAndSkipEOL ();_eda !=nil {return nil ,_eda ;};_cbe ._fa .align ();return _geb ,nil ;};func (_eaf *runData )fillBuffer (_bfbb int )error {_eaf ._gdd =_bfbb ;_ ,_ade :=_eaf ._dcb .Seek (int64 (_bfbb ),_e .SeekStart );if _ade !=nil {if _ade ==_e .EOF {_ga .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");
_eaf ._ebdc =-1;}else {return _ade ;};};if _ade ==nil {_eaf ._ebdc ,_ade =_eaf ._dcb .Read (_eaf ._dcbf );if _ade !=nil {if _ade ==_e .EOF {_ga .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_eaf ._ebdc =-1;}else {return _ade ;};};};if _eaf ._ebdc > -1&&_eaf ._ebdc < 3{for _eaf ._ebdc < 3{_aad ,_cgd :=_eaf ._dcb .ReadByte ();
if _cgd !=nil {if _cgd ==_e .EOF {_eaf ._dcbf [_eaf ._ebdc ]=0;}else {return _cgd ;};}else {_eaf ._dcbf [_eaf ._ebdc ]=_aad &0xFF;};_eaf ._ebdc ++;};};_eaf ._ebdc -=3;if _eaf ._ebdc < 0{_eaf ._dcbf =make ([]byte ,len (_eaf ._dcbf ));_eaf ._ebdc =len (_eaf ._dcbf )-3;
};return nil ;};func New (r *_gd .Reader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_aga :=&Decoder {_db :width ,_bb :height };_ea ,_deb :=r .NewPartialReader (int (dataOffset ),int (dataLength ),false );if _deb !=nil {return nil ,_deb ;
};_ged ,_deb :=_egc (_ea );if _deb !=nil {return nil ,_deb ;};_ ,_deb =r .Seek (_ea .RelativePosition (),_e .SeekCurrent );if _deb !=nil {return nil ,_deb ;};_aga ._fa =_ged ;if _fd :=_aga .initTables ();_fd !=nil {return nil ,_fd ;};return _aga ,nil ;
};func (_fga *Decoder )uncompress2d (_bc *runData ,_egga []int ,_gcb int ,_bdf []int ,_eaed int )(int ,error ){var (_bbd int ;_gbb int ;_efac int ;_aggc =true ;_ccc error ;_dgc *code ;);_egga [_gcb ]=_eaed ;_egga [_gcb +1]=_eaed ;_egga [_gcb +2]=_eaed +1;
_egga [_gcb +3]=_eaed +1;_bef :for _efac < _eaed {_dgc ,_ccc =_bc .uncompressGetCode (_fga ._ae );if _ccc !=nil {return EOL ,nil ;};if _dgc ==nil {_bc ._fcf ++;break _bef ;};_bc ._fcf +=_dgc ._b ;switch mmrCode (_dgc ._dd ){case _gc :_efac =_egga [_bbd ];
case _eb :_efac =_egga [_bbd ]+1;case _f :_efac =_egga [_bbd ]-1;case _gg :for {var _fb []*code ;if _aggc {_fb =_fga ._bad ;}else {_fb =_fga ._efa ;};_dgc ,_ccc =_bc .uncompressGetCode (_fb );if _ccc !=nil {return 0,_ccc ;};if _dgc ==nil {break _bef ;};
_bc ._fcf +=_dgc ._b ;if _dgc ._dd < 64{if _dgc ._dd < 0{_bdf [_gbb ]=_efac ;_gbb ++;_dgc =nil ;break _bef ;};_efac +=_dgc ._dd ;_bdf [_gbb ]=_efac ;_gbb ++;break ;};_efac +=_dgc ._dd ;};_gce :=_efac ;_eef :for {var _fe []*code ;if !_aggc {_fe =_fga ._bad ;
}else {_fe =_fga ._efa ;};_dgc ,_ccc =_bc .uncompressGetCode (_fe );if _ccc !=nil {return 0,_ccc ;};if _dgc ==nil {break _bef ;};_bc ._fcf +=_dgc ._b ;if _dgc ._dd < 64{if _dgc ._dd < 0{_bdf [_gbb ]=_efac ;_gbb ++;break _bef ;};_efac +=_dgc ._dd ;if _efac < _eaed ||_efac !=_gce {_bdf [_gbb ]=_efac ;
_gbb ++;};break _eef ;};_efac +=_dgc ._dd ;};for _efac < _eaed &&_egga [_bbd ]<=_efac {_bbd +=2;};continue _bef ;case _dce :_bbd ++;_efac =_egga [_bbd ];_bbd ++;continue _bef ;case _ce :_efac =_egga [_bbd ]+2;case _cab :_efac =_egga [_bbd ]-2;case _ee :_efac =_egga [_bbd ]+3;
case _cb :_efac =_egga [_bbd ]-3;default:if _bc ._fcf ==12&&_dgc ._dd ==EOL {_bc ._fcf =0;if _ ,_ccc =_fga .uncompress1d (_bc ,_egga ,_eaed );_ccc !=nil {return 0,_ccc ;};_bc ._fcf ++;if _ ,_ccc =_fga .uncompress1d (_bc ,_bdf ,_eaed );_ccc !=nil {return 0,_ccc ;
};_abb ,_ceg :=_fga .uncompress1d (_bc ,_egga ,_eaed );if _ceg !=nil {return EOF ,_ceg ;};_bc ._fcf ++;return _abb ,nil ;};_efac =_eaed ;continue _bef ;};if _efac <=_eaed {_aggc =!_aggc ;_bdf [_gbb ]=_efac ;_gbb ++;if _bbd > 0{_bbd --;}else {_bbd ++;};
for _efac < _eaed &&_egga [_bbd ]<=_efac {_bbd +=2;};};};if _bdf [_gbb ]!=_eaed {_bdf [_gbb ]=_eaed ;};if _dgc ==nil {return EOL ,nil ;};return _gbb ,nil ;};type Decoder struct{_db ,_bb int ;_fa *runData ;_bad []*code ;_efa []*code ;_ae []*code ;};func (_dg *Decoder )initTables ()(_ggd error ){if _dg ._bad ==nil {_dg ._bad ,_ggd =_dg .createLittleEndianTable (_bag );
if _ggd !=nil {return ;};_dg ._efa ,_ggd =_dg .createLittleEndianTable (_ge );if _ggd !=nil {return ;};_dg ._ae ,_ggd =_dg .createLittleEndianTable (_edd );if _ggd !=nil {return ;};};return nil ;};func (_ad *code )String ()string {return _g .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_ad ._b ,_ad ._a ,_ad ._dd );
};func (_fce *runData )uncompressGetCodeLittleEndian (_bbg []*code )(*code ,error ){_bfd ,_gbg :=_fce .uncompressGetNextCodeLittleEndian ();if _gbg !=nil {_ga .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_gbg );
return nil ,_gbg ;};_bfd &=0xffffff;_dec :=_bfd >>(_bed -_gcf );_ddg :=_bbg [_dec ];if _ddg !=nil &&_ddg ._df {_dec =(_bfd >>(_bed -_gcf -_dfe ))&_ag ;_ddg =_ddg ._ef [_dec ];};return _ddg ,nil ;};func _ed (_ab ,_gb int )int {if _ab < _gb {return _gb ;
};return _ab ;};