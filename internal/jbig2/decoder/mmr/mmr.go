//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_ab "errors";_d "fmt";_e "github.com/unidoc/unipdf/v3/common";_c "github.com/unidoc/unipdf/v3/internal/bitwise";_aba "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_g "io";);type Decoder struct{_dbg ,_faf int ;_ba *runData ;_bdb []*code ;
_bdg []*code ;_aa []*code ;};func (_ceg *Decoder )uncompress2d (_faae *runData ,_egd []int ,_cc int ,_cad []int ,_bde int )(int ,error ){var (_aed int ;_beeb int ;_dde int ;_cb =true ;_ebe error ;_gdb *code ;);_egd [_cc ]=_bde ;_egd [_cc +1]=_bde ;_egd [_cc +2]=_bde +1;
_egd [_cc +3]=_bde +1;_dbcc :for _dde < _bde {_gdb ,_ebe =_faae .uncompressGetCode (_ceg ._aa );if _ebe !=nil {return EOL ,nil ;};if _gdb ==nil {_faae ._gegd ++;break _dbcc ;};_faae ._gegd +=_gdb ._b ;switch mmrCode (_gdb ._gc ){case _ac :_dde =_egd [_aed ];
case _dg :_dde =_egd [_aed ]+1;case _fd :_dde =_egd [_aed ]-1;case _ce :for {var _ggc []*code ;if _cb {_ggc =_ceg ._bdb ;}else {_ggc =_ceg ._bdg ;};_gdb ,_ebe =_faae .uncompressGetCode (_ggc );if _ebe !=nil {return 0,_ebe ;};if _gdb ==nil {break _dbcc ;
};_faae ._gegd +=_gdb ._b ;if _gdb ._gc < 64{if _gdb ._gc < 0{_cad [_beeb ]=_dde ;_beeb ++;_gdb =nil ;break _dbcc ;};_dde +=_gdb ._gc ;_cad [_beeb ]=_dde ;_beeb ++;break ;};_dde +=_gdb ._gc ;};_ggcf :=_dde ;_bdc :for {var _ga []*code ;if !_cb {_ga =_ceg ._bdb ;
}else {_ga =_ceg ._bdg ;};_gdb ,_ebe =_faae .uncompressGetCode (_ga );if _ebe !=nil {return 0,_ebe ;};if _gdb ==nil {break _dbcc ;};_faae ._gegd +=_gdb ._b ;if _gdb ._gc < 64{if _gdb ._gc < 0{_cad [_beeb ]=_dde ;_beeb ++;break _dbcc ;};_dde +=_gdb ._gc ;
if _dde < _bde ||_dde !=_ggcf {_cad [_beeb ]=_dde ;_beeb ++;};break _bdc ;};_dde +=_gdb ._gc ;};for _dde < _bde &&_egd [_aed ]<=_dde {_aed +=2;};continue _dbcc ;case _ee :_aed ++;_dde =_egd [_aed ];_aed ++;continue _dbcc ;case _ae :_dde =_egd [_aed ]+2;
case _af :_dde =_egd [_aed ]-2;case _fb :_dde =_egd [_aed ]+3;case _fc :_dde =_egd [_aed ]-3;default:if _faae ._gegd ==12&&_gdb ._gc ==EOL {_faae ._gegd =0;if _ ,_ebe =_ceg .uncompress1d (_faae ,_egd ,_bde );_ebe !=nil {return 0,_ebe ;};_faae ._gegd ++;
if _ ,_ebe =_ceg .uncompress1d (_faae ,_cad ,_bde );_ebe !=nil {return 0,_ebe ;};_fef ,_gcd :=_ceg .uncompress1d (_faae ,_egd ,_bde );if _gcd !=nil {return EOF ,_gcd ;};_faae ._gegd ++;return _fef ,nil ;};_dde =_bde ;continue _dbcc ;};if _dde <=_bde {_cb =!_cb ;
_cad [_beeb ]=_dde ;_beeb ++;if _aed > 0{_aed --;}else {_aed ++;};for _dde < _bde &&_egd [_aed ]<=_dde {_aed +=2;};};};if _cad [_beeb ]!=_bde {_cad [_beeb ]=_bde ;};if _gdb ==nil {return EOL ,nil ;};return _beeb ,nil ;};const (EOF =-3;_gb =-2;EOL =-1;_eg =8;
_bd =(1<<_eg )-1;_gbg =5;_ad =(1<<_gbg )-1;);func _cf (_dec ,_db int )int {if _dec < _db {return _db ;};return _dec ;};func (_fg *code )String ()string {return _d .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_fg ._b ,_fg ._de ,_fg ._gc );
};type code struct{_b int ;_de int ;_gc int ;_ca []*code ;_be bool ;};var (_gf =[][3]int {{4,0x1,int (_ee )},{3,0x1,int (_ce )},{1,0x1,int (_ac )},{3,0x3,int (_dg )},{6,0x3,int (_ae )},{7,0x3,int (_fb )},{3,0x2,int (_fd )},{6,0x2,int (_af )},{7,0x2,int (_fc )},{10,0xf,int (_ag )},{12,0xf,int (_fa )},{12,0x1,int (EOL )}};
_fcb =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_gb },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_gb },{11,0x01,_gb },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_gcg =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_gb },{9,0x18,15},{10,0x01,_gb },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_gb },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);type runData struct{_dcf *_c .Reader ;_gegd int ;_gaf int ;_fbfe int ;_cgf []byte ;_cca int ;_dbgb int ;};const (_ee mmrCode =iota ;_ce ;_ac ;_dg ;_ae ;_fb ;_fd ;_af ;_fc ;_ag ;_fa ;);func (_fab *Decoder )fillBitmap (_dede *_aba .Bitmap ,_dd int ,_gcc []int ,_bcg int )error {var _eba byte ;
_gba :=0;_ea :=_dede .GetByteIndex (_gba ,_dd );for _ebg :=0;_ebg < _bcg ;_ebg ++{_cdf :=byte (1);_gee :=_gcc [_ebg ];if (_ebg &1)==0{_cdf =0;};for _gba < _gee {_eba =(_eba <<1)|_cdf ;_gba ++;if (_gba &7)==0{if _ace :=_dede .SetByte (_ea ,_eba );_ace !=nil {return _ace ;
};_ea ++;_eba =0;};};};if (_gba &7)!=0{_eba <<=uint (8-(_gba &7));if _abbd :=_dede .SetByte (_ea ,_eba );_abbd !=nil {return _abbd ;};};return nil ;};func (_dagb *runData )fillBuffer (_gdd int )error {_dagb ._cca =_gdd ;_ ,_fee :=_dagb ._dcf .Seek (int64 (_gdd ),_g .SeekStart );
if _fee !=nil {if _fee ==_g .EOF {_e .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_dagb ._dbgb =-1;}else {return _fee ;};};if _fee ==nil {_dagb ._dbgb ,_fee =_dagb ._dcf .Read (_dagb ._cgf );if _fee !=nil {if _fee ==_g .EOF {_e .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");
_dagb ._dbgb =-1;}else {return _fee ;};};};if _dagb ._dbgb > -1&&_dagb ._dbgb < 3{for _dagb ._dbgb < 3{_gfa ,_fgf :=_dagb ._dcf .ReadByte ();if _fgf !=nil {if _fgf ==_g .EOF {_dagb ._cgf [_dagb ._dbgb ]=0;}else {return _fgf ;};}else {_dagb ._cgf [_dagb ._dbgb ]=_gfa &0xFF;
};_dagb ._dbgb ++;};};_dagb ._dbgb -=3;if _dagb ._dbgb < 0{_dagb ._cgf =make ([]byte ,len (_dagb ._cgf ));_dagb ._dbgb =len (_dagb ._cgf )-3;};return nil ;};func New (r *_c .Reader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_gbgf :=&Decoder {_dbg :width ,_faf :height };
_ef ,_fga :=r .NewPartialReader (int (dataOffset ),int (dataLength ),false );if _fga !=nil {return nil ,_fga ;};_dbc ,_fga :=_dga (_ef );if _fga !=nil {return nil ,_fga ;};_ ,_fga =r .Seek (_ef .RelativePosition (),_g .SeekCurrent );if _fga !=nil {return nil ,_fga ;
};_gbgf ._ba =_dbc ;if _bb :=_gbgf .initTables ();_bb !=nil {return nil ,_bb ;};return _gbgf ,nil ;};func (_cabe *Decoder )detectAndSkipEOL ()error {for {_bdd ,_bc :=_cabe ._ba .uncompressGetCode (_cabe ._aa );if _bc !=nil {return _bc ;};if _bdd !=nil &&_bdd ._gc ==EOL {_cabe ._ba ._gegd +=_bdd ._b ;
}else {return nil ;};};};func _dga (_ebec *_c .Reader )(*runData ,error ){_aaf :=&runData {_dcf :_ebec ,_gegd :0,_gaf :1};_fabd :=_df (_cf (_fcf ,int (_ebec .Length ())),_geg );_aaf ._cgf =make ([]byte ,_fabd );if _bac :=_aaf .fillBuffer (0);_bac !=nil {if _bac ==_g .EOF {_aaf ._cgf =make ([]byte ,10);
_e .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_bac );}else {return nil ,_bac ;};};return _aaf ,nil ;};type mmrCode int ;func (_fbd *Decoder )initTables ()(_afd error ){if _fbd ._bdb ==nil {_fbd ._bdb ,_afd =_fbd .createLittleEndianTable (_fcb );
if _afd !=nil {return ;};_fbd ._bdg ,_afd =_fbd .createLittleEndianTable (_gcg );if _afd !=nil {return ;};_fbd ._aa ,_afd =_fbd .createLittleEndianTable (_gf );if _afd !=nil {return ;};};return nil ;};func _cd (_f [3]int )*code {return &code {_b :_f [0],_de :_f [1],_gc :_f [2]}};
func (_dcfd *runData )uncompressGetCode (_eaf []*code )(*code ,error ){return _dcfd .uncompressGetCodeLittleEndian (_eaf );};func _df (_ec ,_bf int )int {if _ec > _bf {return _bf ;};return _ec ;};func (_bee *Decoder )UncompressMMR ()(_dc *_aba .Bitmap ,_egg error ){_dc =_aba .New (_bee ._dbg ,_bee ._faf );
_gd :=make ([]int ,_dc .Width +5);_abb :=make ([]int ,_dc .Width +5);_abb [0]=_dc .Width ;_eb :=1;var _gg int ;for _cg :=0;_cg < _dc .Height ;_cg ++{_gg ,_egg =_bee .uncompress2d (_bee ._ba ,_abb ,_eb ,_gd ,_dc .Width );if _egg !=nil {return nil ,_egg ;
};if _gg ==EOF {break ;};if _gg > 0{_egg =_bee .fillBitmap (_dc ,_cg ,_gd ,_gg );if _egg !=nil {return nil ,_egg ;};};_abb ,_gd =_gd ,_abb ;_eb =_gg ;};if _egg =_bee .detectAndSkipEOL ();_egg !=nil {return nil ,_egg ;};_bee ._ba .align ();return _dc ,nil ;
};const (_geg int =1024<<7;_fcf int =3;_efa uint =24;);func (_ge *Decoder )createLittleEndianTable (_cde [][3]int )([]*code ,error ){_gcb :=make ([]*code ,_bd +1);for _bg :=0;_bg < len (_cde );_bg ++{_gga :=_cd (_cde [_bg ]);if _gga ._b <=_eg {_cfe :=_eg -_gga ._b ;
_caf :=_gga ._de <<uint (_cfe );for _bgf :=(1<<uint (_cfe ))-1;_bgf >=0;_bgf --{_ded :=_caf |_bgf ;_gcb [_ded ]=_gga ;};}else {_bfc :=_gga ._de >>uint (_gga ._b -_eg );if _gcb [_bfc ]==nil {var _dff =_cd ([3]int {});_dff ._ca =make ([]*code ,_ad +1);_gcb [_bfc ]=_dff ;
};if _gga ._b <=_eg +_gbg {_fe :=_eg +_gbg -_gga ._b ;_bab :=(_gga ._de <<uint (_fe ))&_ad ;_gcb [_bfc ]._be =true ;for _cab :=(1<<uint (_fe ))-1;_cab >=0;_cab --{_gcb [_bfc ]._ca [_bab |_cab ]=_gga ;};}else {return nil ,_ab .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _gcb ,nil ;};func (_ebgd *runData )align (){_ebgd ._gegd =((_ebgd ._gegd +7)>>3)<<3};func (_afc *Decoder )uncompress1d (_bgg *runData ,_bdbd []int ,_acg int )(int ,error ){var (_da =true ;_cdfc int ;_ced *code ;_eab int ;_faa error ;);_fbf :for _cdfc < _acg {_ece :for {if _da {_ced ,_faa =_bgg .uncompressGetCode (_afc ._bdb );
if _faa !=nil {return 0,_faa ;};}else {_ced ,_faa =_bgg .uncompressGetCode (_afc ._bdg );if _faa !=nil {return 0,_faa ;};};_bgg ._gegd +=_ced ._b ;if _ced ._gc < 0{break _fbf ;};_cdfc +=_ced ._gc ;if _ced ._gc < 64{_da =!_da ;_bdbd [_eab ]=_cdfc ;_eab ++;
break _ece ;};};};if _bdbd [_eab ]!=_acg {_bdbd [_eab ]=_acg ;};_afb :=EOL ;if _ced !=nil &&_ced ._gc !=EOL {_afb =_eab ;};return _afb ,nil ;};func (_bbe *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_gfd :=_bbe ._gegd -_bbe ._gaf ;if _gfd < 0||_gfd > 24{_beee :=(_bbe ._gegd >>3)-_bbe ._cca ;
if _beee >=_bbe ._dbgb {_beee +=_bbe ._cca ;if _baf :=_bbe .fillBuffer (_beee );_baf !=nil {return 0,_baf ;};_beee -=_bbe ._cca ;};_fefb :=(uint32 (_bbe ._cgf [_beee ]&0xFF)<<16)|(uint32 (_bbe ._cgf [_beee +1]&0xFF)<<8)|(uint32 (_bbe ._cgf [_beee +2]&0xFF));
_dgc :=uint32 (_bbe ._gegd &7);_fefb <<=_dgc ;_bbe ._fbfe =int (_fefb );}else {_cedb :=_bbe ._gaf &7;_dag :=7-_cedb ;if _gfd <=_dag {_bbe ._fbfe <<=uint (_gfd );}else {_eabe :=(_bbe ._gaf >>3)+3-_bbe ._cca ;if _eabe >=_bbe ._dbgb {_eabe +=_bbe ._cca ;if _dab :=_bbe .fillBuffer (_eabe );
_dab !=nil {return 0,_dab ;};_eabe -=_bbe ._cca ;};_cedb =8-_cedb ;for {_bbe ._fbfe <<=uint (_cedb );_bbe ._fbfe |=int (uint (_bbe ._cgf [_eabe ])&0xFF);_gfd -=_cedb ;_eabe ++;_cedb =8;if !(_gfd >=8){break ;};};_bbe ._fbfe <<=uint (_gfd );};};_bbe ._gaf =_bbe ._gegd ;
return _bbe ._fbfe ,nil ;};func (_abbg *runData )uncompressGetCodeLittleEndian (_ed []*code )(*code ,error ){_cff ,_fgb :=_abbg .uncompressGetNextCodeLittleEndian ();if _fgb !=nil {_e .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_fgb );
return nil ,_fgb ;};_cff &=0xffffff;_dfc :=_cff >>(_efa -_eg );_gbd :=_ed [_dfc ];if _gbd !=nil &&_gbd ._be {_dfc =(_cff >>(_efa -_eg -_gbg ))&_ad ;_gbd =_gbd ._ca [_dfc ];};return _gbd ,nil ;};