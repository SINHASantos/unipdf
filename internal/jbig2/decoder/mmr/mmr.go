//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_c "errors";_d "fmt";_e "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/bitwise";_ef "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_a "io";);var (_fc =[][3]int {{4,0x1,int (_aa )},{3,0x1,int (_gg )},{1,0x1,int (_ed )},{3,0x3,int (_cc )},{6,0x3,int (_ca )},{7,0x3,int (_ccc )},{3,0x2,int (_bd )},{6,0x2,int (_dfg )},{7,0x2,int (_de )},{10,0xf,int (_ag )},{12,0xf,int (_bf )},{12,0x1,int (EOL )}};
_bge =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_bff },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_bff },{11,0x01,_bff },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_af =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_bff },{9,0x18,15},{10,0x01,_bff },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_bff },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);const (EOF =-3;_bff =-2;EOL =-1;_ae =8;_ac =(1<<_ae )-1;_ab =5;_acc =(1<<_ab )-1;);func (_ee *Decoder )UncompressMMR ()(_bdc *_ef .Bitmap ,_cee error ){_bdc =_ef .New (_ee ._edf ,_ee ._ff );_ceeg :=make ([]int ,_bdc .Width +5);_ceg :=make ([]int ,_bdc .Width +5);
_ceg [0]=_bdc .Width ;_bfe :=1;var _ege int ;for _afc :=0;_afc < _bdc .Height ;_afc ++{_ege ,_cee =_ee .uncompress2d (_ee ._ge ,_ceg ,_bfe ,_ceeg ,_bdc .Width );if _cee !=nil {return nil ,_cee ;};if _ege ==EOF {break ;};if _ege > 0{_cee =_ee .fillBitmap (_bdc ,_afc ,_ceeg ,_ege );
if _cee !=nil {return nil ,_cee ;};};_ceg ,_ceeg =_ceeg ,_ceg ;_bfe =_ege ;};if _cee =_ee .detectAndSkipEOL ();_cee !=nil {return nil ,_cee ;};_ee ._ge .align ();return _bdc ,nil ;};const (_bdb int =1024<<7;_ccf int =3;_gdb uint =24;);func _cb (_gdc *_g .Reader )(*runData ,error ){_ded :=&runData {_beb :_gdc ,_ddd :0,_afe :1};
_ebd :=_eb (_cg (_ccf ,int (_gdc .Length ())),_bdb );_ded ._bbea =make ([]byte ,_ebd );if _cd :=_ded .fillBuffer (0);_cd !=nil {if _cd ==_a .EOF {_ded ._bbea =make ([]byte ,10);_e .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_cd );
}else {return nil ,_cd ;};};return _ded ,nil ;};type code struct{_bc int ;_df int ;_ba int ;_ce []*code ;_dg bool ;};func _ga (_efg [3]int )*code {return &code {_bc :_efg [0],_df :_efg [1],_ba :_efg [2]}};func (_eab *runData )align (){_eab ._ddd =((_eab ._ddd +7)>>3)<<3};
func (_deb *Decoder )initTables ()(_be error ){if _deb ._fcc ==nil {_deb ._fcc ,_be =_deb .createLittleEndianTable (_bge );if _be !=nil {return ;};_deb ._bae ,_be =_deb .createLittleEndianTable (_af );if _be !=nil {return ;};_deb ._gf ,_be =_deb .createLittleEndianTable (_fc );
if _be !=nil {return ;};};return nil ;};func (_cfg *Decoder )uncompress1d (_adg *runData ,_ccb []int ,_ffaa int )(int ,error ){var (_eeg =true ;_eeb int ;_bcf *code ;_daf int ;_fed error ;);_dff :for _eeb < _ffaa {_bce :for {if _eeg {_bcf ,_fed =_adg .uncompressGetCode (_cfg ._fcc );
if _fed !=nil {return 0,_fed ;};}else {_bcf ,_fed =_adg .uncompressGetCode (_cfg ._bae );if _fed !=nil {return 0,_fed ;};};_adg ._ddd +=_bcf ._bc ;if _bcf ._ba < 0{break _dff ;};_eeb +=_bcf ._ba ;if _bcf ._ba < 64{_eeg =!_eeg ;_ccb [_daf ]=_eeb ;_daf ++;
break _bce ;};};};if _ccb [_daf ]!=_ffaa {_ccb [_daf ]=_ffaa ;};_gaa :=EOL ;if _bcf !=nil &&_bcf ._ba !=EOL {_gaa =_daf ;};return _gaa ,nil ;};func (_bca *code )String ()string {return _d .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_bca ._bc ,_bca ._df ,_bca ._ba );
};func _eb (_da ,_ea int )int {if _da > _ea {return _ea ;};return _da ;};type Decoder struct{_edf ,_ff int ;_ge *runData ;_fcc []*code ;_bae []*code ;_gf []*code ;};func (_gec *Decoder )detectAndSkipEOL ()error {for {_bba ,_gae :=_gec ._ge .uncompressGetCode (_gec ._gf );
if _gae !=nil {return _gae ;};if _bba !=nil &&_bba ._ba ==EOL {_gec ._ge ._ddd +=_bba ._bc ;}else {return nil ;};};};func (_ffc *Decoder )fillBitmap (_bbfc *_ef .Bitmap ,_bag int ,_cad []int ,_bbeb int )error {var _bcad byte ;_efd :=0;_fa :=_bbfc .GetByteIndex (_efd ,_bag );
for _ffa :=0;_ffa < _bbeb ;_ffa ++{_acb :=byte (1);_ffd :=_cad [_ffa ];if (_ffa &1)==0{_acb =0;};for _efd < _ffd {_bcad =(_bcad <<1)|_acb ;_efd ++;if (_efd &7)==0{if _ad :=_bbfc .SetByte (_fa ,_bcad );_ad !=nil {return _ad ;};_fa ++;_bcad =0;};};};if (_efd &7)!=0{_bcad <<=uint (8-(_efd &7));
if _db :=_bbfc .SetByte (_fa ,_bcad );_db !=nil {return _db ;};};return nil ;};type mmrCode int ;func (_dbb *runData )fillBuffer (_effa int )error {_dbb ._bda =_effa ;_ ,_adgc :=_dbb ._beb .Seek (int64 (_effa ),_a .SeekStart );if _adgc !=nil {if _adgc ==_a .EOF {_e .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");
_dbb ._dac =-1;}else {return _adgc ;};};if _adgc ==nil {_dbb ._dac ,_adgc =_dbb ._beb .Read (_dbb ._bbea );if _adgc !=nil {if _adgc ==_a .EOF {_e .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_dbb ._dac =-1;}else {return _adgc ;};};};
if _dbb ._dac > -1&&_dbb ._dac < 3{for _dbb ._dac < 3{_abc ,_aaa :=_dbb ._beb .ReadByte ();if _aaa !=nil {if _aaa ==_a .EOF {_dbb ._bbea [_dbb ._dac ]=0;}else {return _aaa ;};}else {_dbb ._bbea [_dbb ._dac ]=_abc &0xFF;};_dbb ._dac ++;};};_dbb ._dac -=3;
if _dbb ._dac < 0{_dbb ._bbea =make ([]byte ,len (_dbb ._bbea ));_dbb ._dac =len (_dbb ._bbea )-3;};return nil ;};func (_edc *runData )uncompressGetCode (_dde []*code )(*code ,error ){return _edc .uncompressGetCodeLittleEndian (_dde );};func (_ebg *Decoder )createLittleEndianTable (_cea [][3]int )([]*code ,error ){_bb :=make ([]*code ,_ac +1);
for _ffg :=0;_ffg < len (_cea );_ffg ++{_cf :=_ga (_cea [_ffg ]);if _cf ._bc <=_ae {_abb :=_ae -_cf ._bc ;_bbe :=_cf ._df <<uint (_abb );for _bad :=(1<<uint (_abb ))-1;_bad >=0;_bad --{_dc :=_bbe |_bad ;_bb [_dc ]=_cf ;};}else {_aga :=_cf ._df >>uint (_cf ._bc -_ae );
if _bb [_aga ]==nil {var _gd =_ga ([3]int {});_gd ._ce =make ([]*code ,_acc +1);_bb [_aga ]=_gd ;};if _cf ._bc <=_ae +_ab {_bbf :=_ae +_ab -_cf ._bc ;_fe :=(_cf ._df <<uint (_bbf ))&_acc ;_bb [_aga ]._dg =true ;for _dfc :=(1<<uint (_bbf ))-1;_dfc >=0;_dfc --{_bb [_aga ]._ce [_fe |_dfc ]=_cf ;
};}else {return nil ,_c .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");};};};return _bb ,nil ;};func _cg (_bg ,_f int )int {if _bg < _f {return _f ;
};return _bg ;};const (_aa mmrCode =iota ;_gg ;_ed ;_cc ;_ca ;_ccc ;_bd ;_dfg ;_de ;_ag ;_bf ;);type runData struct{_beb *_g .Reader ;_ddd int ;_afe int ;_ec int ;_bbea []byte ;_bda int ;_dac int ;};func (_bec *runData )uncompressGetCodeLittleEndian (_ceed []*code )(*code ,error ){_fgb ,_bfb :=_bec .uncompressGetNextCodeLittleEndian ();
if _bfb !=nil {_e .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_bfb );
return nil ,_bfb ;};_fgb &=0xffffff;_gef :=_fgb >>(_gdb -_ae );_age :=_ceed [_gef ];if _age !=nil &&_age ._dg {_gef =(_fgb >>(_gdb -_ae -_ab ))&_acc ;_age =_age ._ce [_gef ];};return _age ,nil ;};func New (r *_g .Reader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_fg :=&Decoder {_edf :width ,_ff :height };
_bcd ,_dea :=r .NewPartialReader (int (dataOffset ),int (dataLength ),false );if _dea !=nil {return nil ,_dea ;};_eg ,_dea :=_cb (_bcd );if _dea !=nil {return nil ,_dea ;};_ ,_dea =r .Seek (_bcd .RelativePosition (),_a .SeekCurrent );if _dea !=nil {return nil ,_dea ;
};_fg ._ge =_eg ;if _gc :=_fg .initTables ();_gc !=nil {return nil ,_gc ;};return _fg ,nil ;};func (_ced *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_baf :=_ced ._ddd -_ced ._afe ;if _baf < 0||_baf > 24{_eec :=(_ced ._ddd >>3)-_ced ._bda ;
if _eec >=_ced ._dac {_eec +=_ced ._bda ;if _ddc :=_ced .fillBuffer (_eec );_ddc !=nil {return 0,_ddc ;};_eec -=_ced ._bda ;};_cce :=(uint32 (_ced ._bbea [_eec ]&0xFF)<<16)|(uint32 (_ced ._bbea [_eec +1]&0xFF)<<8)|(uint32 (_ced ._bbea [_eec +2]&0xFF));
_gefe :=uint32 (_ced ._ddd &7);_cce <<=_gefe ;_ced ._ec =int (_cce );}else {_dafe :=_ced ._afe &7;_aeg :=7-_dafe ;if _baf <=_aeg {_ced ._ec <<=uint (_baf );}else {_fb :=(_ced ._afe >>3)+3-_ced ._bda ;if _fb >=_ced ._dac {_fb +=_ced ._bda ;if _cgb :=_ced .fillBuffer (_fb );
_cgb !=nil {return 0,_cgb ;};_fb -=_ced ._bda ;};_dafe =8-_dafe ;for {_ced ._ec <<=uint (_dafe );_ced ._ec |=int (uint (_ced ._bbea [_fb ])&0xFF);_baf -=_dafe ;_fb ++;_dafe =8;if !(_baf >=8){break ;};};_ced ._ec <<=uint (_baf );};};_ced ._afe =_ced ._ddd ;
return _ced ._ec ,nil ;};func (_edd *Decoder )uncompress2d (_cag *runData ,_eaf []int ,_ega int ,_gac []int ,_dgb int )(int ,error ){var (_dab int ;_ace int ;_bbag int ;_daa =true ;_ade error ;_dd *code ;);_eaf [_ega ]=_dgb ;_eaf [_ega +1]=_dgb ;_eaf [_ega +2]=_dgb +1;
_eaf [_ega +3]=_dgb +1;_eff :for _bbag < _dgb {_dd ,_ade =_cag .uncompressGetCode (_edd ._gf );if _ade !=nil {return EOL ,nil ;};if _dd ==nil {_cag ._ddd ++;break _eff ;};_cag ._ddd +=_dd ._bc ;switch mmrCode (_dd ._ba ){case _ed :_bbag =_eaf [_dab ];case _cc :_bbag =_eaf [_dab ]+1;
case _bd :_bbag =_eaf [_dab ]-1;case _gg :for {var _gaec []*code ;if _daa {_gaec =_edd ._fcc ;}else {_gaec =_edd ._bae ;};_dd ,_ade =_cag .uncompressGetCode (_gaec );if _ade !=nil {return 0,_ade ;};if _dd ==nil {break _eff ;};_cag ._ddd +=_dd ._bc ;if _dd ._ba < 64{if _dd ._ba < 0{_gac [_ace ]=_bbag ;
_ace ++;_dd =nil ;break _eff ;};_bbag +=_dd ._ba ;_gac [_ace ]=_bbag ;_ace ++;break ;};_bbag +=_dd ._ba ;};_faa :=_bbag ;_ceaf :for {var _bbd []*code ;if !_daa {_bbd =_edd ._fcc ;}else {_bbd =_edd ._bae ;};_dd ,_ade =_cag .uncompressGetCode (_bbd );if _ade !=nil {return 0,_ade ;
};if _dd ==nil {break _eff ;};_cag ._ddd +=_dd ._bc ;if _dd ._ba < 64{if _dd ._ba < 0{_gac [_ace ]=_bbag ;_ace ++;break _eff ;};_bbag +=_dd ._ba ;if _bbag < _dgb ||_bbag !=_faa {_gac [_ace ]=_bbag ;_ace ++;};break _ceaf ;};_bbag +=_dd ._ba ;};for _bbag < _dgb &&_eaf [_dab ]<=_bbag {_dab +=2;
};continue _eff ;case _aa :_dab ++;_bbag =_eaf [_dab ];_dab ++;continue _eff ;case _ca :_bbag =_eaf [_dab ]+2;case _dfg :_bbag =_eaf [_dab ]-2;case _ccc :_bbag =_eaf [_dab ]+3;case _de :_bbag =_eaf [_dab ]-3;default:if _cag ._ddd ==12&&_dd ._ba ==EOL {_cag ._ddd =0;
if _ ,_ade =_edd .uncompress1d (_cag ,_eaf ,_dgb );_ade !=nil {return 0,_ade ;};_cag ._ddd ++;if _ ,_ade =_edd .uncompress1d (_cag ,_gac ,_dgb );_ade !=nil {return 0,_ade ;};_fd ,_ede :=_edd .uncompress1d (_cag ,_eaf ,_dgb );if _ede !=nil {return EOF ,_ede ;
};_cag ._ddd ++;return _fd ,nil ;};_bbag =_dgb ;continue _eff ;};if _bbag <=_dgb {_daa =!_daa ;_gac [_ace ]=_bbag ;_ace ++;if _dab > 0{_dab --;}else {_dab ++;};for _bbag < _dgb &&_eaf [_dab ]<=_bbag {_dab +=2;};};};if _gac [_ace ]!=_dgb {_gac [_ace ]=_dgb ;
};if _dd ==nil {return EOL ,nil ;};return _ace ,nil ;};