//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_c "fmt";_fb "github.com/unidoc/unipdf/v3/common";_fe "github.com/unidoc/unipdf/v3/internal/bitwise";_d "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_b "io";_fc "strings";);func (_cf *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_fbd int ;
_db =_de [stats .cx ()][0];_gef =int32 (stats .cx ()););defer func (){_cf ._dee ++}();_cf ._ge -=_db ;if (_cf ._g >>16)< uint64 (_db ){_fbd =_cf .lpsExchange (stats ,_gef ,_db );if _fdb :=_cf .renormalize ();_fdb !=nil {return 0,_fdb ;};}else {_cf ._g -=uint64 (_db )<<16;
if (_cf ._ge &0x8000)==0{_fbd =_cf .mpsExchange (stats ,_gef );if _caf :=_cf .renormalize ();_caf !=nil {return 0,_caf ;};}else {_fbd =int (stats .getMps ());};};return _fbd ,nil ;};func (_dbf *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_bd ,_ba int32 ;
_ee ,_dfb ,_ga int ;_gc error ;);if stats ==nil {stats =NewStats (512,1);};_dbf ._e =1;_dfb ,_gc =_dbf .decodeIntBit (stats );if _gc !=nil {return 0,_gc ;};_ee ,_gc =_dbf .decodeIntBit (stats );if _gc !=nil {return 0,_gc ;};if _ee ==1{_ee ,_gc =_dbf .decodeIntBit (stats );
if _gc !=nil {return 0,_gc ;};if _ee ==1{_ee ,_gc =_dbf .decodeIntBit (stats );if _gc !=nil {return 0,_gc ;};if _ee ==1{_ee ,_gc =_dbf .decodeIntBit (stats );if _gc !=nil {return 0,_gc ;};if _ee ==1{_ee ,_gc =_dbf .decodeIntBit (stats );if _gc !=nil {return 0,_gc ;
};if _ee ==1{_ga =32;_ba =4436;}else {_ga =12;_ba =340;};}else {_ga =8;_ba =84;};}else {_ga =6;_ba =20;};}else {_ga =4;_ba =4;};}else {_ga =2;_ba =0;};for _a :=0;_a < _ga ;_a ++{_ee ,_gc =_dbf .decodeIntBit (stats );if _gc !=nil {return 0,_gc ;};_bd =(_bd <<1)|int32 (_ee );
};_bd +=_ba ;if _dfb ==0{return _bd ,nil ;}else if _dfb ==1&&_bd > 0{return -_bd ,nil ;};return 0,_d .ErrOOB ;};func (_gf *Decoder )renormalize ()error {for {if _gf ._ca ==0{if _dg :=_gf .readByte ();_dg !=nil {return _dg ;};};_gf ._ge <<=1;_gf ._g <<=1;
_gf ._ca --;if (_gf ._ge &0x8000)!=0{break ;};};_gf ._g &=0xffffffff;return nil ;};func (_gcd *Decoder )readByte ()error {if _gcd ._dd .AbsolutePosition ()> _gcd ._be {if _ ,_fcg :=_gcd ._dd .Seek (-1,_b .SeekCurrent );_fcg !=nil {return _fcg ;};};_cbe ,_fg :=_gcd ._dd .ReadByte ();
if _fg !=nil {return _fg ;};_gcd ._fd =_cbe ;if _gcd ._fd ==0xFF{_da ,_dec :=_gcd ._dd .ReadByte ();if _dec !=nil {return _dec ;};if _da > 0x8F{_gcd ._g +=0xFF00;_gcd ._ca =8;if _ ,_dde :=_gcd ._dd .Seek (-2,_b .SeekCurrent );_dde !=nil {return _dde ;};
}else {_gcd ._g +=uint64 (_da )<<9;_gcd ._ca =7;};}else {_cbe ,_fg =_gcd ._dd .ReadByte ();if _fg !=nil {return _fg ;};_gcd ._fd =_cbe ;_gcd ._g +=uint64 (_gcd ._fd )<<8;_gcd ._ca =8;};_gcd ._g &=0xFFFFFFFFFF;return nil ;};var (_de =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_dbb :index ,_fad :contextSize ,_bdg :make ([]byte ,contextSize ),_gd :make ([]byte ,contextSize )};};func (_fea *Decoder )init ()error {_fea ._be =_fea ._dd .AbsolutePosition ();
_ad ,_ff :=_fea ._dd .ReadByte ();if _ff !=nil {_fb .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_ff );return _ff ;};_fea ._fd =_ad ;_fea ._g =uint64 (_ad )<<16;
if _ff =_fea .readByte ();_ff !=nil {return _ff ;};_fea ._g <<=7;_fea ._ca -=7;_fea ._ge =0x8000;_fea ._dee ++;return nil ;};func (_cfa *DecoderStats )SetIndex (index int32 ){_cfa ._dbb =index };func (_gg *Decoder )decodeIntBit (_af *DecoderStats )(int ,error ){_af .SetIndex (int32 (_gg ._e ));
_aae ,_fa :=_gg .DecodeBit (_af );if _fa !=nil {_fb .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_fa );
return _aae ,_fa ;};if _gg ._e < 256{_gg ._e =((_gg ._e <<uint64 (1))|int64 (_aae ))&0x1ff;}else {_gg ._e =(((_gg ._e <<uint64 (1)|int64 (_aae ))&511)|256)&0x1ff;};return _aae ,nil ;};func (_eb *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_eb ._e =1;
var _dea uint64 ;for _dea =0;_dea < codeLen ;_dea ++{stats .SetIndex (int32 (_eb ._e ));_cb ,_aa :=_eb .DecodeBit (stats );if _aa !=nil {return 0,_aa ;};_eb ._e =(_eb ._e <<1)|int64 (_cb );};_ef :=_eb ._e -(1<<codeLen );return _ef ,nil ;};func (_daa *DecoderStats )toggleMps (){_daa ._gd [_daa ._dbb ]^=1};
type DecoderStats struct{_dbb int32 ;_fad int32 ;_bdg []byte ;_gd []byte ;};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_dd *_fe .Reader ;_fd uint8 ;_g uint64 ;_ge uint32 ;_e int64 ;_ca int32 ;_dee int32 ;_be int64 ;};func (_ce *DecoderStats )cx ()byte {return _ce ._bdg [_ce ._dbb ]};
func (_gea *DecoderStats )String ()string {_bgd :=&_fc .Builder {};_bgd .WriteString (_c .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_gea ._bdg )));for _fbb ,_cbg :=range _gea ._bdg {if _cbg !=0{_bgd .WriteString (_c .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_fbb ,_cbg ));
};};return _bgd .String ();};func (_bg *Decoder )mpsExchange (_ac *DecoderStats ,_dgc int32 )int {_ea :=_ac ._gd [_ac ._dbb ];if _bg ._ge < _de [_dgc ][0]{if _de [_dgc ][3]==1{_ac .toggleMps ();};_ac .setEntry (int (_de [_dgc ][2]));return int (1-_ea );
};_ac .setEntry (int (_de [_dgc ][1]));return int (_ea );};func (_cfd *DecoderStats )Reset (){for _ag :=0;_ag < len (_cfd ._bdg );_ag ++{_cfd ._bdg [_ag ]=0;_cfd ._gd [_ag ]=0;};};func (_cc *DecoderStats )Overwrite (dNew *DecoderStats ){for _dc :=0;_dc < len (_cc ._bdg );
_dc ++{_cc ._bdg [_dc ]=dNew ._bdg [_dc ];_cc ._gd [_dc ]=dNew ._gd [_dc ];};};func New (r *_fe .Reader )(*Decoder ,error ){_df :=&Decoder {_dd :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _cd :=_df .init ();_cd !=nil {return nil ,_cd ;
};return _df ,nil ;};func (_eaf *DecoderStats )setEntry (_bc int ){_fbe :=byte (_bc &0x7f);_eaf ._bdg [_eaf ._dbb ]=_fbe };func (_bac *Decoder )lpsExchange (_eeg *DecoderStats ,_gb int32 ,_bgc uint32 )int {_fab :=_eeg .getMps ();if _bac ._ge < _bgc {_eeg .setEntry (int (_de [_gb ][1]));
_bac ._ge =_bgc ;return int (_fab );};if _de [_gb ][3]==1{_eeg .toggleMps ();};_eeg .setEntry (int (_de [_gb ][2]));_bac ._ge =_bgc ;return int (1-_fab );};func (_fed *DecoderStats )getMps ()byte {return _fed ._gd [_fed ._dbb ]};func (_ggc *DecoderStats )Copy ()*DecoderStats {_gfc :=&DecoderStats {_fad :_ggc ._fad ,_bdg :make ([]byte ,_ggc ._fad )};
copy (_gfc ._bdg ,_ggc ._bdg );return _gfc ;};