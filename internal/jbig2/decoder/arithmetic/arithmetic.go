//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "fmt";_g "github.com/unidoc/unipdf/v4/common";_f "github.com/unidoc/unipdf/v4/internal/bitwise";_fc "github.com/unidoc/unipdf/v4/internal/jbig2/internal";_b "io";_cg "strings";);func (_af *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_fa ,_aaa int32 ;
_cbb ,_cbe ,_cc int ;_gdf error ;);if stats ==nil {stats =NewStats (512,1);};_af ._bbd =1;_cbe ,_gdf =_af .decodeIntBit (stats );if _gdf !=nil {return 0,_gdf ;};_cbb ,_gdf =_af .decodeIntBit (stats );if _gdf !=nil {return 0,_gdf ;};if _cbb ==1{_cbb ,_gdf =_af .decodeIntBit (stats );
if _gdf !=nil {return 0,_gdf ;};if _cbb ==1{_cbb ,_gdf =_af .decodeIntBit (stats );if _gdf !=nil {return 0,_gdf ;};if _cbb ==1{_cbb ,_gdf =_af .decodeIntBit (stats );if _gdf !=nil {return 0,_gdf ;};if _cbb ==1{_cbb ,_gdf =_af .decodeIntBit (stats );if _gdf !=nil {return 0,_gdf ;
};if _cbb ==1{_cc =32;_aaa =4436;}else {_cc =12;_aaa =340;};}else {_cc =8;_aaa =84;};}else {_cc =6;_aaa =20;};}else {_cc =4;_aaa =4;};}else {_cc =2;_aaa =0;};for _ag :=0;_ag < _cc ;_ag ++{_cbb ,_gdf =_af .decodeIntBit (stats );if _gdf !=nil {return 0,_gdf ;
};_fa =(_fa <<1)|int32 (_cbb );};_fa +=_aaa ;if _cbe ==0{return _fa ,nil ;}else if _cbe ==1&&_fa > 0{return -_fa ,nil ;};return 0,_fc .ErrOOB ;};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_bb *_f .Reader ;_fd uint8 ;_gd uint64 ;
_d uint32 ;_bbd int64 ;_ce int32 ;_gb int32 ;_bf int64 ;};func (_bce *Decoder )renormalize ()error {for {if _bce ._ce ==0{if _ca :=_bce .readByte ();_ca !=nil {return _ca ;};};_bce ._d <<=1;_bce ._gd <<=1;_bce ._ce --;if (_bce ._d &0x8000)!=0{break ;};
};_bce ._gd &=0xffffffff;return nil ;};var (_fca =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func (_dc *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_ee int ;_bd =_fca [stats .cx ()][0];_aa =int32 (stats .cx ()););defer func (){_dc ._gb ++}();_dc ._d -=_bd ;if (_dc ._gd >>16)< uint64 (_bd ){_ee =_dc .lpsExchange (stats ,_aa ,_bd );
if _ba :=_dc .renormalize ();_ba !=nil {return 0,_ba ;};}else {_dc ._gd -=uint64 (_bd )<<16;if (_dc ._d &0x8000)==0{_ee =_dc .mpsExchange (stats ,_aa );if _cb :=_dc .renormalize ();_cb !=nil {return 0,_cb ;};}else {_ee =int (stats .getMps ());};};return _ee ,nil ;
};type DecoderStats struct{_gcf int32 ;_cgg int32 ;_cd []byte ;_efc []byte ;};func (_gec *Decoder )init ()error {_gec ._bf =_gec ._bb .AbsolutePosition ();_fbb ,_db :=_gec ._bb .ReadByte ();if _db !=nil {_g .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_db );
return _db ;};_gec ._fd =_fbb ;_gec ._gd =uint64 (_fbb )<<16;if _db =_gec .readByte ();_db !=nil {return _db ;};_gec ._gd <<=7;_gec ._ce -=7;_gec ._d =0x8000;_gec ._gb ++;return nil ;};func (_ege *Decoder )lpsExchange (_bcc *DecoderStats ,_efa int32 ,_gcd uint32 )int {_gda :=_bcc .getMps ();
if _ege ._d < _gcd {_bcc .setEntry (int (_fca [_efa ][1]));_ege ._d =_gcd ;return int (_gda );};if _fca [_efa ][3]==1{_bcc .toggleMps ();};_bcc .setEntry (int (_fca [_efa ][2]));_ege ._d =_gcd ;return int (1-_gda );};func New (r *_f .Reader )(*Decoder ,error ){_a :=&Decoder {_bb :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};
if _gdb :=_a .init ();_gdb !=nil {return nil ,_gdb ;};return _a ,nil ;};func (_eedc *DecoderStats )setEntry (_fff int ){_bfc :=byte (_fff &0x7f);_eedc ._cd [_eedc ._gcf ]=_bfc ;};func (_fe *DecoderStats )cx ()byte {return _fe ._cd [_fe ._gcf ]};func (_fad *Decoder )mpsExchange (_bde *DecoderStats ,_eg int32 )int {_bg :=_bde ._efc [_bde ._gcf ];
if _fad ._d < _fca [_eg ][0]{if _fca [_eg ][3]==1{_bde .toggleMps ();};_bde .setEntry (int (_fca [_eg ][2]));return int (1-_bg );};_bde .setEntry (int (_fca [_eg ][1]));return int (_bg );};func (_ad *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_ad ._bbd =1;
var _ge uint64 ;for _ge =0;_ge < codeLen ;_ge ++{stats .SetIndex (int32 (_ad ._bbd ));_fb ,_gc :=_ad .DecodeBit (stats );if _gc !=nil {return 0,_gc ;};_ad ._bbd =(_ad ._bbd <<1)|int64 (_fb );};_ccf :=_ad ._bbd -(1<<codeLen );return _ccf ,nil ;};func (_gbe *DecoderStats )Reset (){for _eed :=0;
_eed < len (_gbe ._cd );_eed ++{_gbe ._cd [_eed ]=0;_gbe ._efc [_eed ]=0;};};func (_ff *Decoder )readByte ()error {if _ff ._bb .AbsolutePosition ()> _ff ._bf {if _ ,_ef :=_ff ._bb .Seek (-1,_b .SeekCurrent );_ef !=nil {return _ef ;};};_gbf ,_ac :=_ff ._bb .ReadByte ();
if _ac !=nil {return _ac ;};_ff ._fd =_gbf ;if _ff ._fd ==0xFF{_ab ,_cgc :=_ff ._bb .ReadByte ();if _cgc !=nil {return _cgc ;};if _ab > 0x8F{_ff ._gd +=0xFF00;_ff ._ce =8;if _ ,_df :=_ff ._bb .Seek (-2,_b .SeekCurrent );_df !=nil {return _df ;};}else {_ff ._gd +=uint64 (_ab )<<9;
_ff ._ce =7;};}else {_gbf ,_ac =_ff ._bb .ReadByte ();if _ac !=nil {return _ac ;};_ff ._fd =_gbf ;_ff ._gd +=uint64 (_ff ._fd )<<8;_ff ._ce =8;};_ff ._gd &=0xFFFFFFFFFF;return nil ;};func (_afa *DecoderStats )SetIndex (index int32 ){_afa ._gcf =index };
func (_cgf *DecoderStats )Overwrite (dNew *DecoderStats ){for _cee :=0;_cee < len (_cgf ._cd );_cee ++{_cgf ._cd [_cee ]=dNew ._cd [_cee ];_cgf ._efc [_cee ]=dNew ._efc [_cee ];};};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_gcf :index ,_cgg :contextSize ,_cd :make ([]byte ,contextSize ),_efc :make ([]byte ,contextSize )};
};func (_fdc *DecoderStats )getMps ()byte {return _fdc ._efc [_fdc ._gcf ]};func (_gdbc *DecoderStats )String ()string {_cdf :=&_cg .Builder {};_cdf .WriteString (_e .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_gdbc ._cd )));
for _aag ,_dba :=range _gdbc ._cd {if _dba !=0{_cdf .WriteString (_e .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_aag ,_dba ));};};return _cdf .String ();};func (_ed *Decoder )decodeIntBit (_afd *DecoderStats )(int ,error ){_afd .SetIndex (int32 (_ed ._bbd ));
_gdfd ,_gcg :=_ed .DecodeBit (_afd );if _gcg !=nil {_g .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_gcg );
return _gdfd ,_gcg ;};if _ed ._bbd < 256{_ed ._bbd =((_ed ._bbd <<uint64 (1))|int64 (_gdfd ))&0x1ff;}else {_ed ._bbd =(((_ed ._bbd <<uint64 (1)|int64 (_gdfd ))&511)|256)&0x1ff;};return _gdfd ,nil ;};func (_acb *DecoderStats )Copy ()*DecoderStats {_cgb :=&DecoderStats {_cgg :_acb ._cgg ,_cd :make ([]byte ,_acb ._cgg )};
copy (_cgb ._cd ,_acb ._cd );return _cgb ;};func (_eee *DecoderStats )toggleMps (){_eee ._efc [_eee ._gcf ]^=1};