//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_ca "fmt";_gf "github.com/unidoc/unipdf/v3/common";_cg "github.com/unidoc/unipdf/v3/internal/bitwise";_gd "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_g "io";_c "strings";);func (_eda *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_cab int ;
_bef =_ge [stats .cx ()][0];_ce =int32 (stats .cx ()););defer func (){_eda ._ee ++}();_eda ._eg -=_bef ;if (_eda ._f >>16)< uint64 (_bef ){_cab =_eda .lpsExchange (stats ,_ce ,_bef );if _a :=_eda .renormalize ();_a !=nil {return 0,_a ;};}else {_eda ._f -=uint64 (_bef )<<16;
if (_eda ._eg &0x8000)==0{_cab =_eda .mpsExchange (stats ,_ce );if _fg :=_eda .renormalize ();_fg !=nil {return 0,_fg ;};}else {_cab =int (stats .getMps ());};};return _cab ,nil ;};func (_ff *Decoder )decodeIntBit (_cc *DecoderStats )(int ,error ){_cc .SetIndex (int32 (_ff ._d ));
_gg ,_aa :=_ff .DecodeBit (_cc );if _aa !=nil {_gf .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_aa );
return _gg ,_aa ;};if _ff ._d < 256{_ff ._d =((_ff ._d <<uint64 (1))|int64 (_gg ))&0x1ff;}else {_ff ._d =(((_ff ._d <<uint64 (1)|int64 (_gg ))&511)|256)&0x1ff;};return _gg ,nil ;};type DecoderStats struct{_gec int32 ;_eed int32 ;_df []byte ;_efd []byte ;
};func (_abc *Decoder )lpsExchange (_aaa *DecoderStats ,_ef int32 ,_ffd uint32 )int {_ecd :=_aaa .getMps ();if _abc ._eg < _ffd {_aaa .setEntry (int (_ge [_ef ][1]));_abc ._eg =_ffd ;return int (_ecd );};if _ge [_ef ][3]==1{_aaa .toggleMps ();};_aaa .setEntry (int (_ge [_ef ][2]));
_abc ._eg =_ffd ;return int (1-_ecd );};func (_af *Decoder )mpsExchange (_gcg *DecoderStats ,_fe int32 )int {_cedeb :=_gcg ._efd [_gcg ._gec ];if _af ._eg < _ge [_fe ][0]{if _ge [_fe ][3]==1{_gcg .toggleMps ();};_gcg .setEntry (int (_ge [_fe ][2]));return int (1-_cedeb );
};_gcg .setEntry (int (_ge [_fe ][1]));return int (_cedeb );};func (_ced *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_bec ,_ab int32 ;_cag ,_ac ,_cb int ;_edf error ;);if stats ==nil {stats =NewStats (512,1);};_ced ._d =1;_ac ,_edf =_ced .decodeIntBit (stats );
if _edf !=nil {return 0,_edf ;};_cag ,_edf =_ced .decodeIntBit (stats );if _edf !=nil {return 0,_edf ;};if _cag ==1{_cag ,_edf =_ced .decodeIntBit (stats );if _edf !=nil {return 0,_edf ;};if _cag ==1{_cag ,_edf =_ced .decodeIntBit (stats );if _edf !=nil {return 0,_edf ;
};if _cag ==1{_cag ,_edf =_ced .decodeIntBit (stats );if _edf !=nil {return 0,_edf ;};if _cag ==1{_cag ,_edf =_ced .decodeIntBit (stats );if _edf !=nil {return 0,_edf ;};if _cag ==1{_cb =32;_ab =4436;}else {_cb =12;_ab =340;};}else {_cb =8;_ab =84;};}else {_cb =6;
_ab =20;};}else {_cb =4;_ab =4;};}else {_cb =2;_ab =0;};for _cede :=0;_cede < _cb ;_cede ++{_cag ,_edf =_ced .decodeIntBit (stats );if _edf !=nil {return 0,_edf ;};_bec =(_bec <<1)|int32 (_cag );};_bec +=_ab ;if _ac ==0{return _bec ,nil ;}else if _ac ==1&&_bec > 0{return -_bec ,nil ;
};return 0,_gd .ErrOOB ;};func (_dd *Decoder )init ()error {_dd ._ea =_dd ._gfg .AbsolutePosition ();_cbc ,_gee :=_dd ._gfg .ReadByte ();if _gee !=nil {_gf .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_gee );
return _gee ;};_dd ._b =_cbc ;_dd ._f =uint64 (_cbc )<<16;if _gee =_dd .readByte ();_gee !=nil {return _gee ;};_dd ._f <<=7;_dd ._ed -=7;_dd ._eg =0x8000;_dd ._ee ++;return nil ;};func (_cce *DecoderStats )setEntry (_gcd int ){_eef :=byte (_gcd &0x7f);
_cce ._df [_cce ._gec ]=_eef };func (_bc *DecoderStats )cx ()byte {return _bc ._df [_bc ._gec ]};func (_adc *DecoderStats )getMps ()byte {return _adc ._efd [_adc ._gec ]};func (_gdd *DecoderStats )Copy ()*DecoderStats {_ga :=&DecoderStats {_eed :_gdd ._eed ,_df :make ([]byte ,_gdd ._eed )};
copy (_ga ._df ,_gdd ._df );return _ga ;};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_gfg *_cg .Reader ;_b uint8 ;_f uint64 ;_eg uint32 ;_d int64 ;_ed int32 ;_ee int32 ;_ea int64 ;};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_gec :index ,_eed :contextSize ,_df :make ([]byte ,contextSize ),_efd :make ([]byte ,contextSize )};
};func (_eag *DecoderStats )toggleMps (){_eag ._efd [_eag ._gec ]^=1};func (_da *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_da ._d =1;var _cbf uint64 ;for _cbf =0;_cbf < codeLen ;_cbf ++{stats .SetIndex (int32 (_da ._d ));
_gc ,_cf :=_da .DecodeBit (stats );if _cf !=nil {return 0,_cf ;};_da ._d =(_da ._d <<1)|int64 (_gc );};_ae :=_da ._d -(1<<codeLen );return _ae ,nil ;};func (_bg *DecoderStats )SetIndex (index int32 ){_bg ._gec =index };func (_gcf *DecoderStats )String ()string {_ecda :=&_c .Builder {};
_ecda .WriteString (_ca .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_gcf ._df )));for _agf ,_efb :=range _gcf ._df {if _efb !=0{_ecda .WriteString (_ca .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_agf ,_efb ));
};};return _ecda .String ();};func New (r *_cg .Reader )(*Decoder ,error ){_be :=&Decoder {_gfg :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _edc :=_be .init ();_edc !=nil {return nil ,_edc ;};return _be ,nil ;};func (_edcc *DecoderStats )Reset (){for _ag :=0;
_ag < len (_edcc ._df );_ag ++{_edcc ._df [_ag ]=0;_edcc ._efd [_ag ]=0;};};func (_egf *Decoder )readByte ()error {if _egf ._gfg .AbsolutePosition ()> _egf ._ea {if _ ,_ad :=_egf ._gfg .Seek (-1,_g .SeekCurrent );_ad !=nil {return _ad ;};};_bd ,_ade :=_egf ._gfg .ReadByte ();
if _ade !=nil {return _ade ;};_egf ._b =_bd ;if _egf ._b ==0xFF{_ec ,_eec :=_egf ._gfg .ReadByte ();if _eec !=nil {return _eec ;};if _ec > 0x8F{_egf ._f +=0xFF00;_egf ._ed =8;if _ ,_cgd :=_egf ._gfg .Seek (-2,_g .SeekCurrent );_cgd !=nil {return _cgd ;
};}else {_egf ._f +=uint64 (_ec )<<9;_egf ._ed =7;};}else {_bd ,_ade =_egf ._gfg .ReadByte ();if _ade !=nil {return _ade ;};_egf ._b =_bd ;_egf ._f +=uint64 (_egf ._b )<<8;_egf ._ed =8;};_egf ._f &=0xFFFFFFFFFF;return nil ;};func (_eff *DecoderStats )Overwrite (dNew *DecoderStats ){for _dad :=0;
_dad < len (_eff ._df );_dad ++{_eff ._df [_dad ]=dNew ._df [_dad ];_eff ._efd [_dad ]=dNew ._efd [_dad ];};};var (_ge =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func (_fa *Decoder )renormalize ()error {for {if _fa ._ed ==0{if _bb :=_fa .readByte ();_bb !=nil {return _bb ;};};_fa ._eg <<=1;_fa ._f <<=1;_fa ._ed --;if (_fa ._eg &0x8000)!=0{break ;};};_fa ._f &=0xffffffff;return nil ;};