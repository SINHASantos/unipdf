//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_bf "fmt";_d "github.com/unidoc/unipdf/v3/common";_cb "github.com/unidoc/unipdf/v3/internal/bitwise";_dc "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_c "io";_f "strings";);func (_bde *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_ag ,_ffb int32 ;
_ce ,_da ,_eg int ;_de error ;);if stats ==nil {stats =NewStats (512,1);};_bde ._bfb =1;_da ,_de =_bde .decodeIntBit (stats );if _de !=nil {return 0,_de ;};_ce ,_de =_bde .decodeIntBit (stats );if _de !=nil {return 0,_de ;};if _ce ==1{_ce ,_de =_bde .decodeIntBit (stats );
if _de !=nil {return 0,_de ;};if _ce ==1{_ce ,_de =_bde .decodeIntBit (stats );if _de !=nil {return 0,_de ;};if _ce ==1{_ce ,_de =_bde .decodeIntBit (stats );if _de !=nil {return 0,_de ;};if _ce ==1{_ce ,_de =_bde .decodeIntBit (stats );if _de !=nil {return 0,_de ;
};if _ce ==1{_eg =32;_ffb =4436;}else {_eg =12;_ffb =340;};}else {_eg =8;_ffb =84;};}else {_eg =6;_ffb =20;};}else {_eg =4;_ffb =4;};}else {_eg =2;_ffb =0;};for _gae :=0;_gae < _eg ;_gae ++{_ce ,_de =_bde .decodeIntBit (stats );if _de !=nil {return 0,_de ;
};_ag =(_ag <<1)|int32 (_ce );};_ag +=_ffb ;if _da ==0{return _ag ,nil ;}else if _da ==1&&_ag > 0{return -_ag ,nil ;};return 0,_dc .ErrOOB ;};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_a *_cb .Reader ;_e uint8 ;_fe uint64 ;
_ff uint32 ;_bfb int64 ;_ffe int32 ;_cd int32 ;_bg int64 ;};func (_gfec *DecoderStats )cx ()byte {return _gfec ._cgad [_gfec ._efc ]};func (_dac *Decoder )decodeIntBit (_gac *DecoderStats )(int ,error ){_gac .SetIndex (int32 (_dac ._bfb ));_aa ,_ba :=_dac .DecodeBit (_gac );
if _ba !=nil {_d .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_ba );
return _aa ,_ba ;};if _dac ._bfb < 256{_dac ._bfb =((_dac ._bfb <<uint64 (1))|int64 (_aa ))&0x1ff;}else {_dac ._bfb =(((_dac ._bfb <<uint64 (1)|int64 (_aa ))&511)|256)&0x1ff;};return _aa ,nil ;};func (_fa *DecoderStats )Overwrite (dNew *DecoderStats ){for _ed :=0;
_ed < len (_fa ._cgad );_ed ++{_fa ._cgad [_ed ]=dNew ._cgad [_ed ];_fa ._cee [_ed ]=dNew ._cee [_ed ];};};func (_gdd *DecoderStats )toggleMps (){_gdd ._cee [_gdd ._efc ]^=1};func (_gb *Decoder )init ()error {_gb ._bg =_gb ._a .AbsolutePosition ();_ge ,_cgf :=_gb ._a .ReadByte ();
if _cgf !=nil {_d .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_cgf );return _cgf ;};_gb ._e =_ge ;_gb ._fe =uint64 (_ge )<<16;if _cgf =_gb .readByte ();
_cgf !=nil {return _cgf ;};_gb ._fe <<=7;_gb ._ffe -=7;_gb ._ff =0x8000;_gb ._cd ++;return nil ;};func (_af *DecoderStats )SetIndex (index int32 ){_af ._efc =index };func (_ef *Decoder )renormalize ()error {for {if _ef ._ffe ==0{if _abg :=_ef .readByte ();
_abg !=nil {return _abg ;};};_ef ._ff <<=1;_ef ._fe <<=1;_ef ._ffe --;if (_ef ._ff &0x8000)!=0{break ;};};_ef ._fe &=0xffffffff;return nil ;};type DecoderStats struct{_efc int32 ;_agb int32 ;_cgad []byte ;_cee []byte ;};func (_gd *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_gd ._bfb =1;
var _def uint64 ;for _def =0;_def < codeLen ;_def ++{stats .SetIndex (int32 (_gd ._bfb ));_dcf ,_ae :=_gd .DecodeBit (stats );if _ae !=nil {return 0,_ae ;};_gd ._bfb =(_gd ._bfb <<1)|int64 (_dcf );};_cge :=_gd ._bfb -(1<<codeLen );return _cge ,nil ;};func (_abf *Decoder )lpsExchange (_cdd *DecoderStats ,_gge int32 ,_dd uint32 )int {_bgc :=_cdd .getMps ();
if _abf ._ff < _dd {_cdd .setEntry (int (_bd [_gge ][1]));_abf ._ff =_dd ;return int (_bgc );};if _bd [_gge ][3]==1{_cdd .toggleMps ();};_cdd .setEntry (int (_bd [_gge ][2]));_abf ._ff =_dd ;return int (1-_bgc );};func (_faa *DecoderStats )String ()string {_bb :=&_f .Builder {};
_bb .WriteString (_bf .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_faa ._cgad )));for _ac ,_ca :=range _faa ._cgad {if _ca !=0{_bb .WriteString (_bf .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_ac ,_ca ));
};};return _bb .String ();};func New (r *_cb .Reader )(*Decoder ,error ){_cg :=&Decoder {_a :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _ab :=_cg .init ();_ab !=nil {return nil ,_ab ;};return _cg ,nil ;};func (_ccg *DecoderStats )Reset (){for _dag :=0;
_dag < len (_ccg ._cgad );_dag ++{_ccg ._cgad [_dag ]=0;_ccg ._cee [_dag ]=0;};};func (_bc *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_g int ;_ga =_bd [stats .cx ()][0];_bgf =int32 (stats .cx ()););defer func (){_bc ._cd ++}();_bc ._ff -=_ga ;
if (_bc ._fe >>16)< uint64 (_ga ){_g =_bc .lpsExchange (stats ,_bgf ,_ga );if _cf :=_bc .renormalize ();_cf !=nil {return 0,_cf ;};}else {_bc ._fe -=uint64 (_ga )<<16;if (_bc ._ff &0x8000)==0{_g =_bc .mpsExchange (stats ,_bgf );if _cga :=_bc .renormalize ();
_cga !=nil {return 0,_cga ;};}else {_g =int (stats .getMps ());};};return _g ,nil ;};func (_ffd *DecoderStats )getMps ()byte {return _ffd ._cee [_ffd ._efc ]};func (_gfc *Decoder )mpsExchange (_gfe *DecoderStats ,_gg int32 )int {_cc :=_gfe ._cee [_gfe ._efc ];
if _gfc ._ff < _bd [_gg ][0]{if _bd [_gg ][3]==1{_gfe .toggleMps ();};_gfe .setEntry (int (_bd [_gg ][2]));return int (1-_cc );};_gfe .setEntry (int (_bd [_gg ][1]));return int (_cc );};func (_fd *Decoder )readByte ()error {if _fd ._a .AbsolutePosition ()> _fd ._bg {if _ ,_gc :=_fd ._a .Seek (-1,_c .SeekCurrent );
_gc !=nil {return _gc ;};};_gaa ,_db :=_fd ._a .ReadByte ();if _db !=nil {return _db ;};_fd ._e =_gaa ;if _fd ._e ==0xFF{_ee ,_abb :=_fd ._a .ReadByte ();if _abb !=nil {return _abb ;};if _ee > 0x8F{_fd ._fe +=0xFF00;_fd ._ffe =8;if _ ,_cdf :=_fd ._a .Seek (-2,_c .SeekCurrent );
_cdf !=nil {return _cdf ;};}else {_fd ._fe +=uint64 (_ee )<<9;_fd ._ffe =7;};}else {_gaa ,_db =_fd ._a .ReadByte ();if _db !=nil {return _db ;};_fd ._e =_gaa ;_fd ._fe +=uint64 (_fd ._e )<<8;_fd ._ffe =8;};_fd ._fe &=0xFFFFFFFFFF;return nil ;};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_efc :index ,_agb :contextSize ,_cgad :make ([]byte ,contextSize ),_cee :make ([]byte ,contextSize )};
};func (_ec *DecoderStats )Copy ()*DecoderStats {_cgfc :=&DecoderStats {_agb :_ec ._agb ,_cgad :make ([]byte ,_ec ._agb )};copy (_cgfc ._cgad ,_ec ._cgad );return _cgfc ;};func (_ea *DecoderStats )setEntry (_bcd int ){_eeg :=byte (_bcd &0x7f);_ea ._cgad [_ea ._efc ]=_eeg };
var (_bd =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);