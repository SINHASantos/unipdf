//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package ccittfax ;import (_f "errors";_g "github.com/unidoc/unipdf/v3/internal/bitwise";_ab "io";_ae "math";);func (_gdc *Decoder )decode1D ()error {var (_abf int ;_debd error ;);_fag :=true ;_gdc ._de =0;for {var _efd int ;if _fag {_efd ,_debd =_gdc .decodeRun (_ee );
}else {_efd ,_debd =_gdc .decodeRun (_fg );};if _debd !=nil {return _debd ;};_abf +=_efd ;_gdc ._cef [_gdc ._de ]=_abf ;_gdc ._de ++;_fag =!_fag ;if _abf >=_gdc ._dgc {break ;};};return nil ;};func init (){_ag =&treeNode {_abce :true ,_deg :_fga };_e =&treeNode {_deg :_b ,_ceb :_ag };
_e ._gcab =_e ;_c =&tree {_fcff :&treeNode {}};if _fc :=_c .fillWithNode (12,0,_e );_fc !=nil {panic (_fc .Error ());};if _ba :=_c .fillWithNode (12,1,_ag );_ba !=nil {panic (_ba .Error ());};_fg =&tree {_fcff :&treeNode {}};for _ef :=0;_ef < len (_adb );
_ef ++{for _af :=0;_af < len (_adb [_ef ]);_af ++{if _bad :=_fg .fill (_ef +2,int (_adb [_ef ][_af ]),int (_gc [_ef ][_af ]));_bad !=nil {panic (_bad .Error ());};};};if _dg :=_fg .fillWithNode (12,0,_e );_dg !=nil {panic (_dg .Error ());};if _cb :=_fg .fillWithNode (12,1,_ag );
_cb !=nil {panic (_cb .Error ());};_ee =&tree {_fcff :&treeNode {}};for _fe :=0;_fe < len (_aee );_fe ++{for _cbb :=0;_cbb < len (_aee [_fe ]);_cbb ++{if _ca :=_ee .fill (_fe +4,int (_aee [_fe ][_cbb ]),int (_aea [_fe ][_cbb ]));_ca !=nil {panic (_ca .Error ());
};};};if _fcf :=_ee .fillWithNode (12,0,_e );_fcf !=nil {panic (_fcf .Error ());};if _fgaf :=_ee .fillWithNode (12,1,_ag );_fgaf !=nil {panic (_fgaf .Error ());};_d =&tree {_fcff :&treeNode {}};if _bd :=_d .fill (4,1,_bc );_bd !=nil {panic (_bd .Error ());
};if _bde :=_d .fill (3,1,_bcb );_bde !=nil {panic (_bde .Error ());};if _cbd :=_d .fill (1,1,0);_cbd !=nil {panic (_cbd .Error ());};if _db :=_d .fill (3,3,1);_db !=nil {panic (_db .Error ());};if _eff :=_d .fill (6,3,2);_eff !=nil {panic (_eff .Error ());
};if _bdc :=_d .fill (7,3,3);_bdc !=nil {panic (_bdc .Error ());};if _aga :=_d .fill (3,2,-1);_aga !=nil {panic (_aga .Error ());};if _ad :=_d .fill (6,2,-2);_ad !=nil {panic (_ad .Error ());};if _abg :=_d .fill (7,2,-3);_abg !=nil {panic (_abg .Error ());
};};func (_gg *Decoder )decodeRowType2 ()error {if _gg ._fbb {_gg ._dgf .Align ();};if _ecg :=_gg .decode1D ();_ecg !=nil {return _ecg ;};return nil ;};func _gbac (_fca int )([]byte ,int ){var _eae []byte ;for _bcge :=0;_bcge < 2;_bcge ++{_eae ,_fca =_eccd (_eae ,_fca ,_gce );
};return _eae ,_fca %8;};func (_cfe *Decoder )decodeRow ()(_bbf error ){if !_cfe ._bgd &&_cfe ._cc > 0&&_cfe ._cc ==_cfe ._ec {return _ab .EOF ;};switch _cfe ._beb {case _aac :_bbf =_cfe .decodeRowType2 ();case _bcd :_bbf =_cfe .decodeRowType4 ();case _bdd :_bbf =_cfe .decodeRowType6 ();
};if _bbf !=nil {return _bbf ;};_ed :=0;_gcef :=true ;_cfe ._dbg =0;for _bgcb :=0;_bgcb < _cfe ._de ;_bgcb ++{_bdf :=_cfe ._dgc ;if _bgcb !=_cfe ._de {_bdf =_cfe ._cef [_bgcb ];};if _bdf > _cfe ._dgc {_bdf =_cfe ._dgc ;};_eab :=_ed /8;for _ed %8!=0&&_bdf -_ed > 0{var _bbe byte ;
if !_gcef {_bbe =1<<uint (7-(_ed %8));};_cfe ._fa [_eab ]|=_bbe ;_ed ++;};if _ed %8==0{_eab =_ed /8;var _cfa byte ;if !_gcef {_cfa =0xff;};for _bdf -_ed > 7{_cfe ._fa [_eab ]=_cfa ;_ed +=8;_eab ++;};};for _bdf -_ed > 0{if _ed %8==0{_cfe ._fa [_eab ]=0;
};var _deb byte ;if !_gcef {_deb =1<<uint (7-(_ed %8));};_cfe ._fa [_eab ]|=_deb ;_ed ++;};_gcef =!_gcef ;};if _ed !=_cfe ._dgc {return _f .New ("\u0073\u0075\u006d\u0020\u006f\u0066 \u0072\u0075\u006e\u002d\u006c\u0065\u006e\u0067\u0074\u0068\u0073\u0020\u0064\u006f\u0065\u0073\u0020\u006e\u006f\u0074 \u0065\u0071\u0075\u0061\u006c\u0020\u0073\u0063\u0061\u006e\u0020\u006c\u0069\u006ee\u0020w\u0069\u0064\u0074\u0068");
};_cfe ._dd =(_ed +7)/8;_cfe ._ec ++;return nil ;};const (_ tiffType =iota ;_aac ;_bcd ;_bdd ;);func (_bcdf *Decoder )decoderRowType41D ()error {if _bcdf ._fbb {_bcdf ._dgf .Align ();};_bcdf ._dgf .Mark ();var (_fgd bool ;_gde error ;);if _bcdf ._fge {_fgd ,_gde =_bcdf .tryFetchEOL ();
if _gde !=nil {return _gde ;};if !_fgd {return _dbb ;};}else {_fgd ,_gde =_bcdf .looseFetchEOL ();if _gde !=nil {return _gde ;};};if !_fgd {_bcdf ._dgf .Reset ();};if _fgd &&_bcdf ._bgd {_bcdf ._dgf .Mark ();for _fbd :=0;_fbd < 5;_fbd ++{_fgd ,_gde =_bcdf .tryFetchEOL ();
if _gde !=nil {if _f .Is (_gde ,_ab .EOF ){if _fbd ==0{break ;};return _fef ;};};if _fgd {continue ;};if _fbd > 0{return _fef ;};break ;};if _fgd {return _ab .EOF ;};_bcdf ._dgf .Reset ();};if _gde =_bcdf .decode1D ();_gde !=nil {return _gde ;};return nil ;
};type Decoder struct{_dgc int ;_cc int ;_ec int ;_fa []byte ;_ce int ;_caca bool ;_eeb bool ;_bgc bool ;_dbc bool ;_fge bool ;_bgd bool ;_fbb bool ;_dd int ;_ac int ;_gdg []int ;_cef []int ;_eeff int ;_de int ;_fea int ;_dbg int ;_dgf *_g .Reader ;_beb tiffType ;
_ga error ;};func init (){_aa =make (map[int ]code );_aa [0]=code {Code :13<<8|3<<6,BitsWritten :10};_aa [1]=code {Code :2<<(5+8),BitsWritten :3};_aa [2]=code {Code :3<<(6+8),BitsWritten :2};_aa [3]=code {Code :2<<(6+8),BitsWritten :2};_aa [4]=code {Code :3<<(5+8),BitsWritten :3};
_aa [5]=code {Code :3<<(4+8),BitsWritten :4};_aa [6]=code {Code :2<<(4+8),BitsWritten :4};_aa [7]=code {Code :3<<(3+8),BitsWritten :5};_aa [8]=code {Code :5<<(2+8),BitsWritten :6};_aa [9]=code {Code :4<<(2+8),BitsWritten :6};_aa [10]=code {Code :4<<(1+8),BitsWritten :7};
_aa [11]=code {Code :5<<(1+8),BitsWritten :7};_aa [12]=code {Code :7<<(1+8),BitsWritten :7};_aa [13]=code {Code :4<<8,BitsWritten :8};_aa [14]=code {Code :7<<8,BitsWritten :8};_aa [15]=code {Code :12<<8,BitsWritten :9};_aa [16]=code {Code :5<<8|3<<6,BitsWritten :10};
_aa [17]=code {Code :6<<8,BitsWritten :10};_aa [18]=code {Code :2<<8,BitsWritten :10};_aa [19]=code {Code :12<<8|7<<5,BitsWritten :11};_aa [20]=code {Code :13<<8,BitsWritten :11};_aa [21]=code {Code :13<<8|4<<5,BitsWritten :11};_aa [22]=code {Code :6<<8|7<<5,BitsWritten :11};
_aa [23]=code {Code :5<<8,BitsWritten :11};_aa [24]=code {Code :2<<8|7<<5,BitsWritten :11};_aa [25]=code {Code :3<<8,BitsWritten :11};_aa [26]=code {Code :12<<8|10<<4,BitsWritten :12};_aa [27]=code {Code :12<<8|11<<4,BitsWritten :12};_aa [28]=code {Code :12<<8|12<<4,BitsWritten :12};
_aa [29]=code {Code :12<<8|13<<4,BitsWritten :12};_aa [30]=code {Code :6<<8|8<<4,BitsWritten :12};_aa [31]=code {Code :6<<8|9<<4,BitsWritten :12};_aa [32]=code {Code :6<<8|10<<4,BitsWritten :12};_aa [33]=code {Code :6<<8|11<<4,BitsWritten :12};_aa [34]=code {Code :13<<8|2<<4,BitsWritten :12};
_aa [35]=code {Code :13<<8|3<<4,BitsWritten :12};_aa [36]=code {Code :13<<8|4<<4,BitsWritten :12};_aa [37]=code {Code :13<<8|5<<4,BitsWritten :12};_aa [38]=code {Code :13<<8|6<<4,BitsWritten :12};_aa [39]=code {Code :13<<8|7<<4,BitsWritten :12};_aa [40]=code {Code :6<<8|12<<4,BitsWritten :12};
_aa [41]=code {Code :6<<8|13<<4,BitsWritten :12};_aa [42]=code {Code :13<<8|10<<4,BitsWritten :12};_aa [43]=code {Code :13<<8|11<<4,BitsWritten :12};_aa [44]=code {Code :5<<8|4<<4,BitsWritten :12};_aa [45]=code {Code :5<<8|5<<4,BitsWritten :12};_aa [46]=code {Code :5<<8|6<<4,BitsWritten :12};
_aa [47]=code {Code :5<<8|7<<4,BitsWritten :12};_aa [48]=code {Code :6<<8|4<<4,BitsWritten :12};_aa [49]=code {Code :6<<8|5<<4,BitsWritten :12};_aa [50]=code {Code :5<<8|2<<4,BitsWritten :12};_aa [51]=code {Code :5<<8|3<<4,BitsWritten :12};_aa [52]=code {Code :2<<8|4<<4,BitsWritten :12};
_aa [53]=code {Code :3<<8|7<<4,BitsWritten :12};_aa [54]=code {Code :3<<8|8<<4,BitsWritten :12};_aa [55]=code {Code :2<<8|7<<4,BitsWritten :12};_aa [56]=code {Code :2<<8|8<<4,BitsWritten :12};_aa [57]=code {Code :5<<8|8<<4,BitsWritten :12};_aa [58]=code {Code :5<<8|9<<4,BitsWritten :12};
_aa [59]=code {Code :2<<8|11<<4,BitsWritten :12};_aa [60]=code {Code :2<<8|12<<4,BitsWritten :12};_aa [61]=code {Code :5<<8|10<<4,BitsWritten :12};_aa [62]=code {Code :6<<8|6<<4,BitsWritten :12};_aa [63]=code {Code :6<<8|7<<4,BitsWritten :12};_be =make (map[int ]code );
_be [0]=code {Code :53<<8,BitsWritten :8};_be [1]=code {Code :7<<(2+8),BitsWritten :6};_be [2]=code {Code :7<<(4+8),BitsWritten :4};_be [3]=code {Code :8<<(4+8),BitsWritten :4};_be [4]=code {Code :11<<(4+8),BitsWritten :4};_be [5]=code {Code :12<<(4+8),BitsWritten :4};
_be [6]=code {Code :14<<(4+8),BitsWritten :4};_be [7]=code {Code :15<<(4+8),BitsWritten :4};_be [8]=code {Code :19<<(3+8),BitsWritten :5};_be [9]=code {Code :20<<(3+8),BitsWritten :5};_be [10]=code {Code :7<<(3+8),BitsWritten :5};_be [11]=code {Code :8<<(3+8),BitsWritten :5};
_be [12]=code {Code :8<<(2+8),BitsWritten :6};_be [13]=code {Code :3<<(2+8),BitsWritten :6};_be [14]=code {Code :52<<(2+8),BitsWritten :6};_be [15]=code {Code :53<<(2+8),BitsWritten :6};_be [16]=code {Code :42<<(2+8),BitsWritten :6};_be [17]=code {Code :43<<(2+8),BitsWritten :6};
_be [18]=code {Code :39<<(1+8),BitsWritten :7};_be [19]=code {Code :12<<(1+8),BitsWritten :7};_be [20]=code {Code :8<<(1+8),BitsWritten :7};_be [21]=code {Code :23<<(1+8),BitsWritten :7};_be [22]=code {Code :3<<(1+8),BitsWritten :7};_be [23]=code {Code :4<<(1+8),BitsWritten :7};
_be [24]=code {Code :40<<(1+8),BitsWritten :7};_be [25]=code {Code :43<<(1+8),BitsWritten :7};_be [26]=code {Code :19<<(1+8),BitsWritten :7};_be [27]=code {Code :36<<(1+8),BitsWritten :7};_be [28]=code {Code :24<<(1+8),BitsWritten :7};_be [29]=code {Code :2<<8,BitsWritten :8};
_be [30]=code {Code :3<<8,BitsWritten :8};_be [31]=code {Code :26<<8,BitsWritten :8};_be [32]=code {Code :27<<8,BitsWritten :8};_be [33]=code {Code :18<<8,BitsWritten :8};_be [34]=code {Code :19<<8,BitsWritten :8};_be [35]=code {Code :20<<8,BitsWritten :8};
_be [36]=code {Code :21<<8,BitsWritten :8};_be [37]=code {Code :22<<8,BitsWritten :8};_be [38]=code {Code :23<<8,BitsWritten :8};_be [39]=code {Code :40<<8,BitsWritten :8};_be [40]=code {Code :41<<8,BitsWritten :8};_be [41]=code {Code :42<<8,BitsWritten :8};
_be [42]=code {Code :43<<8,BitsWritten :8};_be [43]=code {Code :44<<8,BitsWritten :8};_be [44]=code {Code :45<<8,BitsWritten :8};_be [45]=code {Code :4<<8,BitsWritten :8};_be [46]=code {Code :5<<8,BitsWritten :8};_be [47]=code {Code :10<<8,BitsWritten :8};
_be [48]=code {Code :11<<8,BitsWritten :8};_be [49]=code {Code :82<<8,BitsWritten :8};_be [50]=code {Code :83<<8,BitsWritten :8};_be [51]=code {Code :84<<8,BitsWritten :8};_be [52]=code {Code :85<<8,BitsWritten :8};_be [53]=code {Code :36<<8,BitsWritten :8};
_be [54]=code {Code :37<<8,BitsWritten :8};_be [55]=code {Code :88<<8,BitsWritten :8};_be [56]=code {Code :89<<8,BitsWritten :8};_be [57]=code {Code :90<<8,BitsWritten :8};_be [58]=code {Code :91<<8,BitsWritten :8};_be [59]=code {Code :74<<8,BitsWritten :8};
_be [60]=code {Code :75<<8,BitsWritten :8};_be [61]=code {Code :50<<8,BitsWritten :8};_be [62]=code {Code :51<<8,BitsWritten :8};_be [63]=code {Code :52<<8,BitsWritten :8};_eb =make (map[int ]code );_eb [64]=code {Code :3<<8|3<<6,BitsWritten :10};_eb [128]=code {Code :12<<8|8<<4,BitsWritten :12};
_eb [192]=code {Code :12<<8|9<<4,BitsWritten :12};_eb [256]=code {Code :5<<8|11<<4,BitsWritten :12};_eb [320]=code {Code :3<<8|3<<4,BitsWritten :12};_eb [384]=code {Code :3<<8|4<<4,BitsWritten :12};_eb [448]=code {Code :3<<8|5<<4,BitsWritten :12};_eb [512]=code {Code :3<<8|12<<3,BitsWritten :13};
_eb [576]=code {Code :3<<8|13<<3,BitsWritten :13};_eb [640]=code {Code :2<<8|10<<3,BitsWritten :13};_eb [704]=code {Code :2<<8|11<<3,BitsWritten :13};_eb [768]=code {Code :2<<8|12<<3,BitsWritten :13};_eb [832]=code {Code :2<<8|13<<3,BitsWritten :13};_eb [896]=code {Code :3<<8|18<<3,BitsWritten :13};
_eb [960]=code {Code :3<<8|19<<3,BitsWritten :13};_eb [1024]=code {Code :3<<8|20<<3,BitsWritten :13};_eb [1088]=code {Code :3<<8|21<<3,BitsWritten :13};_eb [1152]=code {Code :3<<8|22<<3,BitsWritten :13};_eb [1216]=code {Code :119<<3,BitsWritten :13};_eb [1280]=code {Code :2<<8|18<<3,BitsWritten :13};
_eb [1344]=code {Code :2<<8|19<<3,BitsWritten :13};_eb [1408]=code {Code :2<<8|20<<3,BitsWritten :13};_eb [1472]=code {Code :2<<8|21<<3,BitsWritten :13};_eb [1536]=code {Code :2<<8|26<<3,BitsWritten :13};_eb [1600]=code {Code :2<<8|27<<3,BitsWritten :13};
_eb [1664]=code {Code :3<<8|4<<3,BitsWritten :13};_eb [1728]=code {Code :3<<8|5<<3,BitsWritten :13};_cbf =make (map[int ]code );_cbf [64]=code {Code :27<<(3+8),BitsWritten :5};_cbf [128]=code {Code :18<<(3+8),BitsWritten :5};_cbf [192]=code {Code :23<<(2+8),BitsWritten :6};
_cbf [256]=code {Code :55<<(1+8),BitsWritten :7};_cbf [320]=code {Code :54<<8,BitsWritten :8};_cbf [384]=code {Code :55<<8,BitsWritten :8};_cbf [448]=code {Code :100<<8,BitsWritten :8};_cbf [512]=code {Code :101<<8,BitsWritten :8};_cbf [576]=code {Code :104<<8,BitsWritten :8};
_cbf [640]=code {Code :103<<8,BitsWritten :8};_cbf [704]=code {Code :102<<8,BitsWritten :9};_cbf [768]=code {Code :102<<8|1<<7,BitsWritten :9};_cbf [832]=code {Code :105<<8,BitsWritten :9};_cbf [896]=code {Code :105<<8|1<<7,BitsWritten :9};_cbf [960]=code {Code :106<<8,BitsWritten :9};
_cbf [1024]=code {Code :106<<8|1<<7,BitsWritten :9};_cbf [1088]=code {Code :107<<8,BitsWritten :9};_cbf [1152]=code {Code :107<<8|1<<7,BitsWritten :9};_cbf [1216]=code {Code :108<<8,BitsWritten :9};_cbf [1280]=code {Code :108<<8|1<<7,BitsWritten :9};_cbf [1344]=code {Code :109<<8,BitsWritten :9};
_cbf [1408]=code {Code :109<<8|1<<7,BitsWritten :9};_cbf [1472]=code {Code :76<<8,BitsWritten :9};_cbf [1536]=code {Code :76<<8|1<<7,BitsWritten :9};_cbf [1600]=code {Code :77<<8,BitsWritten :9};_cbf [1664]=code {Code :24<<(2+8),BitsWritten :6};_cbf [1728]=code {Code :77<<8|1<<7,BitsWritten :9};
_eg =make (map[int ]code );_eg [1792]=code {Code :1<<8,BitsWritten :11};_eg [1856]=code {Code :1<<8|4<<5,BitsWritten :11};_eg [1920]=code {Code :1<<8|5<<5,BitsWritten :11};_eg [1984]=code {Code :1<<8|2<<4,BitsWritten :12};_eg [2048]=code {Code :1<<8|3<<4,BitsWritten :12};
_eg [2112]=code {Code :1<<8|4<<4,BitsWritten :12};_eg [2176]=code {Code :1<<8|5<<4,BitsWritten :12};_eg [2240]=code {Code :1<<8|6<<4,BitsWritten :12};_eg [2304]=code {Code :1<<8|7<<4,BitsWritten :12};_eg [2368]=code {Code :1<<8|12<<4,BitsWritten :12};_eg [2432]=code {Code :1<<8|13<<4,BitsWritten :12};
_eg [2496]=code {Code :1<<8|14<<4,BitsWritten :12};_eg [2560]=code {Code :1<<8|15<<4,BitsWritten :12};_cac =make (map[int ]byte );_cac [0]=0xFF;_cac [1]=0xFE;_cac [2]=0xFC;_cac [3]=0xF8;_cac [4]=0xF0;_cac [5]=0xE0;_cac [6]=0xC0;_cac [7]=0x80;_cac [8]=0x00;
};func (_gb *Decoder )decodeRun (_ebg *tree )(int ,error ){var _cbc int ;_dcf :=_ebg ._fcff ;for {_effca ,_dee :=_gb ._dgf .ReadBool ();if _dee !=nil {return 0,_dee ;};_dcf =_dcf .walk (_effca );if _dcf ==nil {return 0,_f .New ("\u0075\u006e\u006bno\u0077\u006e\u0020\u0063\u006f\u0064\u0065\u0020\u0069n\u0020H\u0075f\u0066m\u0061\u006e\u0020\u0052\u004c\u0045\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};if _dcf ._abce {_cbc +=_dcf ._deg ;switch {case _dcf ._deg >=64:_dcf =_ebg ._fcff ;case _dcf ._deg >=0:return _cbc ,nil ;default:return _gb ._dgc ,nil ;};};};};func _fgf (_bfb []byte ,_aab int ,_ceg int ,_df bool )([]byte ,int ){var (_dgb code ;_egae bool ;
);for !_egae {_dgb ,_ceg ,_egae =_cec (_ceg ,_df );_bfb ,_aab =_eccd (_bfb ,_aab ,_dgb );};return _bfb ,_aab ;};var _aee =[...][]uint16 {{0x7,0x8,0xb,0xc,0xe,0xf},{0x12,0x13,0x14,0x1b,0x7,0x8},{0x17,0x18,0x2a,0x2b,0x3,0x34,0x35,0x7,0x8},{0x13,0x17,0x18,0x24,0x27,0x28,0x2b,0x3,0x37,0x4,0x8,0xc},{0x12,0x13,0x14,0x15,0x16,0x17,0x1a,0x1b,0x2,0x24,0x25,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x3,0x32,0x33,0x34,0x35,0x36,0x37,0x4,0x4a,0x4b,0x5,0x52,0x53,0x54,0x55,0x58,0x59,0x5a,0x5b,0x64,0x65,0x67,0x68,0xa,0xb},{0x98,0x99,0x9a,0x9b,0xcc,0xcd,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb},{},{0x8,0xc,0xd},{0x12,0x13,0x14,0x15,0x16,0x17,0x1c,0x1d,0x1e,0x1f}};
func (_daf *treeNode )set (_gda bool ,_eadf *treeNode ){if !_gda {_daf ._gcab =_eadf ;}else {_daf ._ceb =_eadf ;};};var (_fef =_f .New ("\u0063\u0063\u0069\u0074tf\u0061\u0078\u0020\u0063\u006f\u0072\u0072\u0075\u0070\u0074\u0065\u0064\u0020\u0052T\u0043");
_dbb =_f .New ("\u0063\u0063\u0069\u0074tf\u0061\u0078\u0020\u0045\u004f\u004c\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064"););func _gac (_aec []byte ,_gge ,_bef ,_ccc int )([]byte ,int ){_ebe :=_gdeb (_bef ,_ccc );_aec ,_gge =_eccd (_aec ,_gge ,_ebe );
return _aec ,_gge ;};func (_dge *Encoder )Encode (pixels [][]byte )[]byte {if _dge .BlackIs1 {_feag =0;_cagf =1;}else {_feag =1;_cagf =0;};if _dge .K ==0{return _dge .encodeG31D (pixels );};if _dge .K > 0{return _dge .encodeG32D (pixels );};if _dge .K < 0{return _dge .encodeG4 (pixels );
};return nil ;};func _aacg (_fdf int )([]byte ,int ){var _affa []byte ;for _cca :=0;_cca < 6;_cca ++{_affa ,_fdf =_eccd (_affa ,_fdf ,_gce );};return _affa ,_fdf %8;};func NewDecoder (data []byte ,options DecodeOptions )(*Decoder ,error ){_cg :=&Decoder {_dgf :_g .NewReader (data ),_dgc :options .Columns ,_cc :options .Rows ,_ce :options .DamagedRowsBeforeError ,_fa :make ([]byte ,(options .Columns +7)/8),_gdg :make ([]int ,options .Columns +2),_cef :make ([]int ,options .Columns +2),_fbb :options .EncodedByteAligned ,_dbc :options .BlackIsOne ,_fge :options .EndOfLine ,_bgd :options .EndOfBlock };
switch {case options .K ==0:_cg ._beb =_bcd ;if len (data )< 20{return nil ,_f .New ("\u0074o\u006f\u0020\u0073\u0068o\u0072\u0074\u0020\u0063\u0063i\u0074t\u0066a\u0078\u0020\u0073\u0074\u0072\u0065\u0061m");};_ff :=data [:20];if _ff [0]!=0||(_ff [1]>>4!=1&&_ff [1]!=1){_cg ._beb =_aac ;
_bb :=(uint16 (_ff [0])<<8+uint16 (_ff [1]&0xff))>>4;for _gf :=12;_gf < 160;_gf ++{_bb =(_bb <<1)+uint16 ((_ff [_gf /8]>>uint16 (7-(_gf %8)))&0x01);if _bb &0xfff==1{_cg ._beb =_bcd ;break ;};};};case options .K < 0:_cg ._beb =_bdd ;case options .K > 0:_cg ._beb =_bcd ;
_cg ._caca =true ;};switch _cg ._beb {case _aac ,_bcd ,_bdd :default:return nil ,_f .New ("\u0075\u006ek\u006e\u006f\u0077\u006e\u0020\u0063\u0063\u0069\u0074\u0074\u0066\u0061\u0078\u002e\u0044\u0065\u0063\u006f\u0064\u0065\u0072\u0020ty\u0070\u0065");
};return _cg ,nil ;};func (_cba *Decoder )tryFetchRTC2D ()(_dgg error ){_cba ._dgf .Mark ();var _gega bool ;for _ebf :=0;_ebf < 5;_ebf ++{_gega ,_dgg =_cba .tryFetchEOL1 ();if _dgg !=nil {if _f .Is (_dgg ,_ab .EOF ){if _ebf ==0{break ;};return _fef ;};
};if _gega {continue ;};if _ebf > 0{return _fef ;};break ;};if _gega {return _ab .EOF ;};_cba ._dgf .Reset ();return _dgg ;};func _ggg (_dcac [][]byte )[][]byte {_babd :=make ([]byte ,len (_dcac [0]));for _aced :=range _babd {_babd [_aced ]=_feag ;};_dcac =append (_dcac ,[]byte {});
for _gcf :=len (_dcac )-1;_gcf > 0;_gcf --{_dcac [_gcf ]=_dcac [_gcf -1];};_dcac [0]=_babd ;return _dcac ;};func (_ddf *Decoder )tryFetchEOL ()(bool ,error ){_bea ,_dbe :=_ddf ._dgf .ReadBits (12);if _dbe !=nil {return false ,_dbe ;};return _bea ==0x1,nil ;
};func (_abc tiffType )String ()string {switch _abc {case _aac :return "\u0074\u0069\u0066\u0066\u0054\u0079\u0070\u0065\u004d\u006f\u0064i\u0066\u0069\u0065\u0064\u0048\u0075\u0066\u0066\u006d\u0061n\u0052\u006c\u0065";case _bcd :return "\u0074\u0069\u0066\u0066\u0054\u0079\u0070\u0065\u0054\u0034";
case _bdd :return "\u0074\u0069\u0066\u0066\u0054\u0079\u0070\u0065\u0054\u0036";default:return "\u0075n\u0064\u0065\u0066\u0069\u006e\u0065d";};};func (_gcee *tree )fill (_ccgd ,_ecca ,_dba int )error {_ddfc :=_gcee ._fcff ;for _egad :=0;_egad < _ccgd ;
_egad ++{_ecd :=_ccgd -1-_egad ;_cdb :=((_ecca >>uint (_ecd ))&1)!=0;_afd :=_ddfc .walk (_cdb );if _afd !=nil {if _afd ._abce {return _f .New ("\u006e\u006f\u0064\u0065\u0020\u0069\u0073\u0020\u006c\u0065\u0061\u0066\u002c\u0020\u006eo\u0020o\u0074\u0068\u0065\u0072\u0020\u0066\u006f\u006c\u006c\u006f\u0077\u0069\u006e\u0067");
};_ddfc =_afd ;continue ;};_afd =&treeNode {};if _egad ==_ccgd -1{_afd ._deg =_dba ;_afd ._abce =true ;};if _ecca ==0{_afd ._ccgb =true ;};_ddfc .set (_cdb ,_afd );_ddfc =_afd ;};return nil ;};type code struct{Code uint16 ;BitsWritten int ;};var (_feag byte =1;
_cagf byte =0;);func _eccd (_dbcd []byte ,_eac int ,_gcbd code )([]byte ,int ){_acb :=0;for _acb < _gcbd .BitsWritten {_caag :=_eac /8;_fgb :=_eac %8;if _caag >=len (_dbcd ){_dbcd =append (_dbcd ,0);};_fba :=8-_fgb ;_agab :=_gcbd .BitsWritten -_acb ;if _fba > _agab {_fba =_agab ;
};if _acb < 8{_dbcd [_caag ]=_dbcd [_caag ]|byte (_gcbd .Code >>uint (8+_fgb -_acb ))&_cac [8-_fba -_fgb ];}else {_dbcd [_caag ]=_dbcd [_caag ]|(byte (_gcbd .Code <<uint (_acb -8))&_cac [8-_fba ])>>uint (_fgb );};_eac +=_fba ;_acb +=_fba ;};return _dbcd ,_eac ;
};func (_gcc *Decoder )decodeRowType4 ()error {if !_gcc ._caca {return _gcc .decoderRowType41D ();};if _gcc ._fbb {_gcc ._dgf .Align ();};_gcc ._dgf .Mark ();_dc ,_ge :=_gcc .tryFetchEOL ();if _ge !=nil {return _ge ;};if !_dc &&_gcc ._fge {_gcc ._fea ++;
if _gcc ._fea > _gcc ._ce {return _dbb ;};_gcc ._dgf .Reset ();};if !_dc {_gcc ._dgf .Reset ();};_acc ,_ge :=_gcc ._dgf .ReadBool ();if _ge !=nil {return _ge ;};if _acc {if _dc &&_gcc ._bgd {if _ge =_gcc .tryFetchRTC2D ();_ge !=nil {return _ge ;};};_ge =_gcc .decode1D ();
}else {_ge =_gcc .decode2D ();};if _ge !=nil {return _ge ;};return nil ;};func _bbeg (_dbbe int )([]byte ,int ){var _bac []byte ;for _adc :=0;_adc < 6;_adc ++{_bac ,_dbbe =_eccd (_bac ,_dbbe ,_afg );};return _bac ,_dbbe %8;};func (_ffe *Decoder )Read (in []byte )(int ,error ){if _ffe ._ga !=nil {return 0,_ffe ._ga ;
};_egd :=len (in );var (_effc int ;_aag int ;);for _egd !=0{if _ffe ._ac >=_ffe ._dd {if _gca :=_ffe .fetch ();_gca !=nil {_ffe ._ga =_gca ;return 0,_gca ;};};if _ffe ._dd ==-1{return _effc ,_ab .EOF ;};switch {case _egd <=_ffe ._dd -_ffe ._ac :_cbde :=_ffe ._fa [_ffe ._ac :_ffe ._ac +_egd ];
for _ ,_aeaa :=range _cbde {if !_ffe ._dbc {_aeaa =^_aeaa ;};in [_aag ]=_aeaa ;_aag ++;};_effc +=len (_cbde );_ffe ._ac +=len (_cbde );return _effc ,nil ;default:_ebb :=_ffe ._fa [_ffe ._ac :];for _ ,_aeed :=range _ebb {if !_ffe ._dbc {_aeed =^_aeed ;};
in [_aag ]=_aeed ;_aag ++;};_effc +=len (_ebb );_ffe ._ac +=len (_ebb );_egd -=len (_ebb );};};return _effc ,nil ;};func _bgdd (_dfe []byte ,_fefe int )([]byte ,int ){return _eccd (_dfe ,_fefe ,_eef )};func _gdeb (_gfa ,_ebgd int )code {var _bce code ;
switch _ebgd -_gfa {case -1:_bce =_gd ;case -2:_bce =_gcd ;case -3:_bce =_fb ;case 0:_bce =_fd ;case 1:_bce =_ea ;case 2:_bce =_cag ;case 3:_bce =_efc ;};return _bce ;};var _aea =[...][]uint16 {{2,3,4,5,6,7},{128,8,9,64,10,11},{192,1664,16,17,13,14,15,1,12},{26,21,28,27,18,24,25,22,256,23,20,19},{33,34,35,36,37,38,31,32,29,53,54,39,40,41,42,43,44,30,61,62,63,0,320,384,45,59,60,46,49,50,51,52,55,56,57,58,448,512,640,576,47,48},{1472,1536,1600,1728,704,768,832,896,960,1024,1088,1152,1216,1280,1344,1408},{},{1792,1856,1920},{1984,2048,2112,2176,2240,2304,2368,2432,2496,2560}};
var (_ag *treeNode ;_e *treeNode ;_fg *tree ;_ee *tree ;_c *tree ;_d *tree ;_fga =-2000;_b =-1000;_bc =-3000;_bcb =-4000;);func (_gcb *Encoder )encodeG32D (_fff [][]byte )[]byte {var _dac []byte ;var _aaf int ;for _cd :=0;_cd < len (_fff );_cd +=_gcb .K {if _gcb .Rows > 0&&!_gcb .EndOfBlock &&_cd ==_gcb .Rows {break ;
};_ecf ,_effe :=_gaf (_fff [_cd ],_aaf ,_afg );_dac =_gcb .appendEncodedRow (_dac ,_ecf ,_aaf );if _gcb .EncodedByteAlign {_effe =0;};_aaf =_effe ;for _bda :=_cd +1;_bda < (_cd +_gcb .K )&&_bda < len (_fff );_bda ++{if _gcb .Rows > 0&&!_gcb .EndOfBlock &&_bda ==_gcb .Rows {break ;
};_bdag ,_dca :=_eccd (nil ,_aaf ,_ege );var _dbf ,_bae ,_agg int ;_bee :=-1;for _bee < len (_fff [_bda ]){_dbf =_dcc (_fff [_bda ],_bee );_bae =_beee (_fff [_bda ],_fff [_bda -1],_bee );_agg =_dcc (_fff [_bda -1],_bae );if _agg < _dbf {_bdag ,_dca =_bgdd (_bdag ,_dca );
_bee =_agg ;}else {if _ae .Abs (float64 (_bae -_dbf ))> 3{_bdag ,_dca ,_bee =_bbde (_fff [_bda ],_bdag ,_dca ,_bee ,_dbf );}else {_bdag ,_dca =_gac (_bdag ,_dca ,_dbf ,_bae );_bee =_dbf ;};};};_dac =_gcb .appendEncodedRow (_dac ,_bdag ,_aaf );if _gcb .EncodedByteAlign {_dca =0;
};_aaf =_dca %8;};};if _gcb .EndOfBlock {_afb ,_ :=_bbeg (_aaf );_dac =_gcb .appendEncodedRow (_dac ,_afb ,_aaf );};return _dac ;};func _cec (_cda int ,_aad bool )(code ,int ,bool ){if _cda < 64{if _aad {return _be [_cda ],0,true ;};return _aa [_cda ],0,true ;
};_cbfb :=_cda /64;if _cbfb > 40{return _eg [2560],_cda -2560,false ;};if _cbfb > 27{return _eg [_cbfb *64],_cda -_cbfb *64,false ;};if _aad {return _cbf [_cbfb *64],_cda -_cbfb *64,false ;};return _eb [_cbfb *64],_cda -_cbfb *64,false ;};func (_gfd *treeNode )walk (_bba bool )*treeNode {if _bba {return _gfd ._ceb ;
};return _gfd ._gcab ;};type DecodeOptions struct{Columns int ;Rows int ;K int ;EncodedByteAligned bool ;BlackIsOne bool ;EndOfBlock bool ;EndOfLine bool ;DamagedRowsBeforeError int ;};var _gc =[...][]uint16 {{3,2},{1,4},{6,5},{7},{9,8},{10,11,12},{13,14},{15},{16,17,0,18,64},{24,25,23,22,19,20,21,1792,1856,1920},{1984,2048,2112,2176,2240,2304,2368,2432,2496,2560,52,55,56,59,60,320,384,448,53,54,50,51,44,45,46,47,57,58,61,256,48,49,62,63,30,31,32,33,40,41,128,192,26,27,28,29,34,35,36,37,38,39,42,43},{640,704,768,832,1280,1344,1408,1472,1536,1600,1664,1728,512,576,896,960,1024,1088,1152,1216}};
func (_fbbb *tree )fillWithNode (_eadga ,_ccd int ,_fbaa *treeNode )error {_gdf :=_fbbb ._fcff ;for _egaf :=0;_egaf < _eadga ;_egaf ++{_aabb :=uint (_eadga -1-_egaf );_ccaf :=((_ccd >>_aabb )&1)!=0;_gaae :=_gdf .walk (_ccaf );if _gaae !=nil {if _gaae ._abce {return _f .New ("\u006e\u006f\u0064\u0065\u0020\u0069\u0073\u0020\u006c\u0065\u0061\u0066\u002c\u0020\u006eo\u0020o\u0074\u0068\u0065\u0072\u0020\u0066\u006f\u006c\u006c\u006f\u0077\u0069\u006e\u0067");
};_gdf =_gaae ;continue ;};if _egaf ==_eadga -1{_gaae =_fbaa ;}else {_gaae =&treeNode {};};if _ccd ==0{_gaae ._ccgb =true ;};_gdf .set (_ccaf ,_gaae );_gdf =_gaae ;};return nil ;};func (_bead *Encoder )encodeG31D (_ddc [][]byte )[]byte {var _fdad []byte ;
_cbbe :=0;for _bfc :=range _ddc {if _bead .Rows > 0&&!_bead .EndOfBlock &&_bfc ==_bead .Rows {break ;};_gdd ,_gba :=_gaf (_ddc [_bfc ],_cbbe ,_gce );_fdad =_bead .appendEncodedRow (_fdad ,_gdd ,_cbbe );if _bead .EncodedByteAlign {_gba =0;};_cbbe =_gba ;
};if _bead .EndOfBlock {_aff ,_ :=_aacg (_cbbe );_fdad =_bead .appendEncodedRow (_fdad ,_aff ,_cbbe );};return _fdad ;};func (_agb *Encoder )appendEncodedRow (_cfbf ,_ecbb []byte ,_dfb int )[]byte {if len (_cfbf )> 0&&_dfb !=0&&!_agb .EncodedByteAlign {_cfbf [len (_cfbf )-1]=_cfbf [len (_cfbf )-1]|_ecbb [0];
_cfbf =append (_cfbf ,_ecbb [1:]...);}else {_cfbf =append (_cfbf ,_ecbb ...);};return _cfbf ;};type tree struct{_fcff *treeNode };func _dcc (_gbf []byte ,_bdea int )int {if _bdea >=len (_gbf ){return _bdea ;};if _bdea < -1{_bdea =-1;};var _bga byte ;if _bdea > -1{_bga =_gbf [_bdea ];
}else {_bga =_feag ;};_bfd :=_bdea +1;for _bfd < len (_gbf ){if _gbf [_bfd ]!=_bga {break ;};_bfd ++;};return _bfd ;};func (_da *Decoder )decode2D ()error {_da ._eeff =_da ._de ;_da ._cef ,_da ._gdg =_da ._gdg ,_da ._cef ;_cfd :=true ;var (_cee bool ;_ebd int ;
_gagf error ;);_da ._de =0;_cagb :for _ebd < _da ._dgc {_aca :=_d ._fcff ;for {_cee ,_gagf =_da ._dgf .ReadBool ();if _gagf !=nil {return _gagf ;};_aca =_aca .walk (_cee );if _aca ==nil {continue _cagb ;};if !_aca ._abce {continue ;};switch _aca ._deg {case _bcb :var _fed int ;
if _cfd {_fed ,_gagf =_da .decodeRun (_ee );}else {_fed ,_gagf =_da .decodeRun (_fg );};if _gagf !=nil {return _gagf ;};_ebd +=_fed ;_da ._cef [_da ._de ]=_ebd ;_da ._de ++;if _cfd {_fed ,_gagf =_da .decodeRun (_fg );}else {_fed ,_gagf =_da .decodeRun (_ee );
};if _gagf !=nil {return _gagf ;};_ebd +=_fed ;_da ._cef [_da ._de ]=_ebd ;_da ._de ++;case _bc :_cfb :=_da .getNextChangingElement (_ebd ,_cfd )+1;if _cfb >=_da ._eeff {_ebd =_da ._dgc ;}else {_ebd =_da ._gdg [_cfb ];};default:_cacc :=_da .getNextChangingElement (_ebd ,_cfd );
if _cacc >=_da ._eeff ||_cacc ==-1{_ebd =_da ._dgc +_aca ._deg ;}else {_ebd =_da ._gdg [_cacc ]+_aca ._deg ;};_da ._cef [_da ._de ]=_ebd ;_da ._de ++;_cfd =!_cfd ;};continue _cagb ;};};return nil ;};func (_dcd *Decoder )getNextChangingElement (_fefg int ,_ggb bool )int {_edg :=0;
if !_ggb {_edg =1;};_ecc :=int (uint32 (_dcd ._dbg )&0xFFFFFFFE)+_edg ;if _ecc > 2{_ecc -=2;};if _fefg ==0{return _ecc ;};for _agd :=_ecc ;_agd < _dcd ._eeff ;_agd +=2{if _fefg < _dcd ._gdg [_agd ]{_dcd ._dbg =_agd ;return _agd ;};};return -1;};func (_geg *Decoder )decodeRowType6 ()error {if _geg ._fbb {_geg ._dgf .Align ();
};if _geg ._bgd {_geg ._dgf .Mark ();_fda ,_gad :=_geg .tryFetchEOL ();if _gad !=nil {return _gad ;};if _fda {_fda ,_gad =_geg .tryFetchEOL ();if _gad !=nil {return _gad ;};if _fda {return _ab .EOF ;};};_geg ._dgf .Reset ();};return _geg .decode2D ();};
func _gaf (_eag []byte ,_gae int ,_aaa code )([]byte ,int ){_egda :=true ;var _ffg []byte ;_ffg ,_gae =_eccd (nil ,_gae ,_aaa );_ece :=0;var _gfg int ;for _ece < len (_eag ){_gfg ,_ece =_fgag (_eag ,_egda ,_ece );_ffg ,_gae =_fgf (_ffg ,_gae ,_gfg ,_egda );
_egda =!_egda ;};return _ffg ,_gae %8;};type treeNode struct{_gcab *treeNode ;_ceb *treeNode ;_deg int ;_ccgb bool ;_abce bool ;};func (_dbeb *Encoder )encodeG4 (_fcg [][]byte )[]byte {_afe :=make ([][]byte ,len (_fcg ));copy (_afe ,_fcg );_afe =_ggg (_afe );
var _caa []byte ;var _dbef int ;for _cagd :=1;_cagd < len (_afe );_cagd ++{if _dbeb .Rows > 0&&!_dbeb .EndOfBlock &&_cagd ==(_dbeb .Rows +1){break ;};var _ebc []byte ;var _gaa ,_bgg ,_bebf int ;_aae :=_dbef ;_gded :=-1;for _gded < len (_afe [_cagd ]){_gaa =_dcc (_afe [_cagd ],_gded );
_bgg =_beee (_afe [_cagd ],_afe [_cagd -1],_gded );_bebf =_dcc (_afe [_cagd -1],_bgg );if _bebf < _gaa {_ebc ,_aae =_eccd (_ebc ,_aae ,_eef );_gded =_bebf ;}else {if _ae .Abs (float64 (_bgg -_gaa ))> 3{_ebc ,_aae ,_gded =_bbde (_afe [_cagd ],_ebc ,_aae ,_gded ,_gaa );
}else {_ebc ,_aae =_gac (_ebc ,_aae ,_gaa ,_bgg );_gded =_gaa ;};};};_caa =_dbeb .appendEncodedRow (_caa ,_ebc ,_dbef );if _dbeb .EncodedByteAlign {_aae =0;};_dbef =_aae %8;};if _dbeb .EndOfBlock {_affg ,_ :=_gbac (_dbef );_caa =_dbeb .appendEncodedRow (_caa ,_affg ,_dbef );
};return _caa ;};func (_gef *Decoder )decodeG32D ()error {_gef ._eeff =_gef ._de ;_gef ._cef ,_gef ._gdg =_gef ._gdg ,_gef ._cef ;_efa :=true ;var (_bdg bool ;_bf int ;_cab error ;);_gef ._de =0;_cbfa :for _bf < _gef ._dgc {_bbc :=_d ._fcff ;for {_bdg ,_cab =_gef ._dgf .ReadBool ();
if _cab !=nil {return _cab ;};_bbc =_bbc .walk (_bdg );if _bbc ==nil {continue _cbfa ;};if !_bbc ._abce {continue ;};switch _bbc ._deg {case _bcb :var _egc int ;if _efa {_egc ,_cab =_gef .decodeRun (_ee );}else {_egc ,_cab =_gef .decodeRun (_fg );};if _cab !=nil {return _cab ;
};_bf +=_egc ;_gef ._cef [_gef ._de ]=_bf ;_gef ._de ++;if _efa {_egc ,_cab =_gef .decodeRun (_fg );}else {_egc ,_cab =_gef .decodeRun (_ee );};if _cab !=nil {return _cab ;};_bf +=_egc ;_gef ._cef [_gef ._de ]=_bf ;_gef ._de ++;case _bc :_bab :=_gef .getNextChangingElement (_bf ,_efa )+1;
if _bab >=_gef ._eeff {_bf =_gef ._dgc ;}else {_bf =_gef ._gdg [_bab ];};default:_egb :=_gef .getNextChangingElement (_bf ,_efa );if _egb >=_gef ._eeff ||_egb ==-1{_bf =_gef ._dgc +_bbc ._deg ;}else {_bf =_gef ._gdg [_egb ]+_bbc ._deg ;};_gef ._cef [_gef ._de ]=_bf ;
_gef ._de ++;_efa =!_efa ;};continue _cbfa ;};};return nil ;};var (_aa map[int ]code ;_be map[int ]code ;_eb map[int ]code ;_cbf map[int ]code ;_eg map[int ]code ;_cac map[int ]byte ;_gce =code {Code :1<<4,BitsWritten :12};_afg =code {Code :3<<3,BitsWritten :13};
_ege =code {Code :2<<3,BitsWritten :13};_eef =code {Code :1<<12,BitsWritten :4};_bg =code {Code :1<<13,BitsWritten :3};_fd =code {Code :1<<15,BitsWritten :1};_gd =code {Code :3<<13,BitsWritten :3};_gcd =code {Code :3<<10,BitsWritten :6};_fb =code {Code :3<<9,BitsWritten :7};
_ea =code {Code :2<<13,BitsWritten :3};_cag =code {Code :2<<10,BitsWritten :6};_efc =code {Code :2<<9,BitsWritten :7};);func (_eaaa *Decoder )tryFetchEOL1 ()(bool ,error ){_fcd ,_fcb :=_eaaa ._dgf .ReadBits (13);if _fcb !=nil {return false ,_fcb ;};return _fcd ==0x3,nil ;
};func _egbg (_bcc ,_edf []byte ,_dcdb int ,_dad bool )int {_edfa :=_dcc (_edf ,_dcdb );if _edfa < len (_edf )&&(_dcdb ==-1&&_edf [_edfa ]==_feag ||_dcdb >=0&&_dcdb < len (_bcc )&&_bcc [_dcdb ]==_edf [_edfa ]||_dcdb >=len (_bcc )&&_dad &&_edf [_edfa ]==_feag ||_dcdb >=len (_bcc )&&!_dad &&_edf [_edfa ]==_cagf ){_edfa =_dcc (_edf ,_edfa );
};return _edfa ;};func (_cbe *Decoder )fetch ()error {if _cbe ._dd ==-1{return nil ;};if _cbe ._ac < _cbe ._dd {return nil ;};_cbe ._dd =0;_eaa :=_cbe .decodeRow ();if _eaa !=nil {if !_f .Is (_eaa ,_ab .EOF ){return _eaa ;};if _cbe ._dd !=0{return _eaa ;
};_cbe ._dd =-1;};_cbe ._ac =0;return nil ;};func (_eeba *Decoder )looseFetchEOL ()(bool ,error ){_cbcf ,_ega :=_eeba ._dgf .ReadBits (12);if _ega !=nil {return false ,_ega ;};switch _cbcf {case 0x1:return true ,nil ;case 0x0:for {_fee ,_deed :=_eeba ._dgf .ReadBool ();
if _deed !=nil {return false ,_deed ;};if _fee {return true ,nil ;};};default:return false ,nil ;};};func _beee (_bbd ,_cgb []byte ,_aaad int )int {_ead :=_dcc (_cgb ,_aaad );if _ead < len (_cgb )&&(_aaad ==-1&&_cgb [_ead ]==_feag ||_aaad >=0&&_aaad < len (_bbd )&&_bbd [_aaad ]==_cgb [_ead ]||_aaad >=len (_bbd )&&_bbd [_aaad -1]!=_cgb [_ead ]){_ead =_dcc (_cgb ,_ead );
};return _ead ;};var _adb =[...][]uint16 {{0x2,0x3},{0x2,0x3},{0x2,0x3},{0x3},{0x4,0x5},{0x4,0x5,0x7},{0x4,0x7},{0x18},{0x17,0x18,0x37,0x8,0xf},{0x17,0x18,0x28,0x37,0x67,0x68,0x6c,0x8,0xc,0xd},{0x12,0x13,0x14,0x15,0x16,0x17,0x1c,0x1d,0x1e,0x1f,0x24,0x27,0x28,0x2b,0x2c,0x33,0x34,0x35,0x37,0x38,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xda,0xdb},{0x4a,0x4b,0x4c,0x4d,0x52,0x53,0x54,0x55,0x5a,0x5b,0x64,0x65,0x6c,0x6d,0x72,0x73,0x74,0x75,0x76,0x77}};
type tiffType int ;type Encoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};func _bbde (_gfge ,_ecba []byte ,_dbcg ,_bdfg ,_eadg int )([]byte ,int ,int ){_cfdd :=_dcc (_gfge ,_eadg );
_bfca :=_bdfg >=0&&_gfge [_bdfg ]==_feag ||_bdfg ==-1;_ecba ,_dbcg =_eccd (_ecba ,_dbcg ,_bg );var _bec int ;if _bdfg > -1{_bec =_eadg -_bdfg ;}else {_bec =_eadg -_bdfg -1;};_ecba ,_dbcg =_fgf (_ecba ,_dbcg ,_bec ,_bfca );_bfca =!_bfca ;_eda :=_cfdd -_eadg ;
_ecba ,_dbcg =_fgf (_ecba ,_dbcg ,_eda ,_bfca );_bdfg =_cfdd ;return _ecba ,_dbcg ,_bdfg ;};func _fgag (_effa []byte ,_ecb bool ,_adbf int )(int ,int ){_efb :=0;for _adbf < len (_effa ){if _ecb {if _effa [_adbf ]!=_feag {break ;};}else {if _effa [_adbf ]!=_cagf {break ;
};};_efb ++;_adbf ++;};return _efb ,_adbf ;};