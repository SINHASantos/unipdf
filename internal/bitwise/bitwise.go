//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_e "encoding/binary";_c "errors";_fa "fmt";_g "github.com/unidoc/unipdf/v3/common";_aa "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_f "io";);type BufferedWriter struct{_d []byte ;_fc uint8 ;_dc int ;_da bool ;};func (_cf *BufferedWriter )WriteBits (bits uint64 ,number int )(_bee int ,_bc error ){const _ad ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_aa .Errorf (_ad ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_df :=number /8;if _df > 0{_acd :=number -_df *8;for _fdb :=_df -1;_fdb >=0;_fdb --{_eff :=byte ((bits >>uint (_fdb *8+_acd ))&0xff);if _bc =_cf .WriteByte (_eff );_bc !=nil {return _bee ,_aa .Wrapf (_bc ,_ad ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_df -_fdb +1);
};};number -=_df *8;if number ==0{return _df ,nil ;};};var _bgc int ;for _efg :=0;_efg < number ;_efg ++{if _cf ._da {_bgc =int ((bits >>uint (number -1-_efg ))&0x1);}else {_bgc =int (bits &0x1);bits >>=1;};if _bc =_cf .WriteBit (_bgc );_bc !=nil {return _bee ,_aa .Wrapf (_bc ,_ad ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_efg );
};};return _df ,nil ;};type Writer struct{_beb []byte ;_dgb uint8 ;_faf int ;_aed bool ;};func NewReader (data []byte )*Reader {return &Reader {_fgf :readerSource {_fde :data ,_dgd :len (data ),_fgdg :0}};};func (_eac *Writer )WriteBits (bits uint64 ,number int )(_aea int ,_aggg error ){const _fgg ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_aa .Errorf (_fgg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_deg :=number /8;if _deg > 0{_efcg :=number -_deg *8;for _aeag :=_deg -1;_aeag >=0;_aeag --{_bca :=byte ((bits >>uint (_aeag *8+_efcg ))&0xff);if _aggg =_eac .WriteByte (_bca );_aggg !=nil {return _aea ,_aa .Wrapf (_aggg ,_fgg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_deg -_aeag +1);
};};number -=_deg *8;if number ==0{return _deg ,nil ;};};var _aeda int ;for _ddd :=0;_ddd < number ;_ddd ++{if _eac ._aed {_aeda =int ((bits >>uint (number -1-_ddd ))&0x1);}else {_aeda =int (bits &0x1);bits >>=1;};if _aggg =_eac .WriteBit (_aeda );_aggg !=nil {return _aea ,_aa .Wrapf (_aggg ,_fgg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ddd );
};};return _deg ,nil ;};func (_ddc *Writer )SkipBits (skip int )error {const _bdd ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_aada :=int (_ddc ._dgb )+skip ;if _aada >=0&&_aada < 8{_ddc ._dgb =uint8 (_aada );
return nil ;};_aada =int (_ddc ._dgb )+_ddc ._faf *8+skip ;if _aada < 0{return _aa .Errorf (_bdd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_def :=_aada /8;_aefd :=_aada %8;_g .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_g .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_ddc ._dgb ,_ddc ._faf ,int (_ddc ._dgb )+(_ddc ._faf )*8,len (_ddc ._beb ),cap (_ddc ._beb ));
_g .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_aada ,_aefd );_ddc ._dgb =uint8 (_aefd );
if _abc :=_def -_ddc ._faf ;_abc > 0&&len (_ddc ._beb )-1< _def {_g .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_abc );return _aa .Errorf (_bdd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ddc ._faf =_def ;_g .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_ddc ._dgb ,_ddc ._faf );return nil ;};func (_bgg *Reader )read (_gg []byte )(int ,error ){if _bgg ._fgd >=int64 (_bgg ._fgf ._dgd ){return 0,_f .EOF ;
};_bgg ._gdf =-1;_gfb :=copy (_gg ,_bgg ._fgf ._fde [(int64 (_bgg ._fgf ._fgdg )+_bgg ._fgd ):(_bgg ._fgf ._fgdg +_bgg ._fgf ._dgd )]);_bgg ._fgd +=int64 (_gfb );return _gfb ,nil ;};func (_de *BufferedWriter )byteCapacity ()int {_af :=len (_de ._d )-_de ._dc ;
if _de ._fc !=0{_af --;};return _af ;};func (_ca *Reader )Align ()(_bcf byte ){_bcf =_ca ._db ;_ca ._db =0;return _bcf };func (_dfaa *Writer )Data ()[]byte {return _dfaa ._beb };func (_bb *Reader )ReadBool ()(bool ,error ){return _bb .readBool ()};type StreamReader interface{_f .Reader ;
_f .ByteReader ;_f .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_fce byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_dcd *Reader )readBool ()(_cae bool ,_dfa error ){if _dcd ._db ==0{_dcd ._ea ,_dfa =_dcd .readBufferByte ();
if _dfa !=nil {return false ,_dfa ;};_cae =(_dcd ._ea &0x80)!=0;_dcd ._ea ,_dcd ._db =_dcd ._ea &0x7f,7;return _cae ,nil ;};_dcd ._db --;_cae =(_dcd ._ea &(1<<_dcd ._db ))!=0;_dcd ._ea &=1<<_dcd ._db -1;return _cae ,nil ;};func (_bbc *Writer )WriteByte (c byte )error {return _bbc .writeByte (c )};
func (_cbg *Reader )RelativePosition ()int64 {return _cbg ._fgd };func (_dd *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_c .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_dd ._fgf ._fgdg +offset ;};if length > 0{_dfc :=len (_dd ._fgf ._fde );if relative {_dfc =_dd ._fgf ._dgd ;};if offset +length > _dfc {return nil ,_fa .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_dd ._fgf ._dgd );
};};if length < 0{_aecc :=len (_dd ._fgf ._fde );if relative {_aecc =_dd ._fgf ._dgd ;};length =_aecc -offset ;};return &Reader {_fgf :readerSource {_fde :_dd ._fgf ._fde ,_dgd :length ,_fgdg :offset }},nil ;};func (_aef *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _aa .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_aef ._d )-1< _aef ._dc {_aef .expandIfNeeded (1);};_bea :=_aef ._fc ;if _aef ._da {_bea =7-_aef ._fc ;};_aef ._d [_aef ._dc ]|=byte (uint16 (bit <<_bea )&0xff);_aef ._fc ++;if _aef ._fc ==8{_aef ._dc ++;_aef ._fc =0;};return nil ;};func (_eb *Reader )Mark (){_eb ._bef =_eb ._fgd ;
_eb ._fcb =_eb ._db ;_eb ._bcd =_eb ._ea ;_eb ._eab =_eb ._dbf ;};func (_dgg *Reader )AbsolutePosition ()int64 {return _dgg ._fgd +int64 (_dgg ._fgf ._fgdg )};func (_fd *BufferedWriter )FinishByte (){if _fd ._fc ==0{return ;};_fd ._fc =0;_fd ._dc ++;};
var _ BinaryWriter =&Writer {};func (_ce *Reader )Length ()uint64 {return uint64 (_ce ._fgf ._dgd )};func (_add *Reader )readUnalignedByte ()(_gea byte ,_cbe error ){_cad :=_add ._db ;_gea =_add ._ea <<(8-_cad );_add ._ea ,_cbe =_add .readBufferByte ();
if _cbe !=nil {return 0,_cbe ;};_gea |=_add ._ea >>_cad ;_add ._ea &=1<<_cad -1;return _gea ,nil ;};func (_cc *BufferedWriter )fullOffset ()int {_egf :=_cc ._dc ;if _cc ._fc !=0{_egf ++;};return _egf ;};func (_cdf *BufferedWriter )grow (_ba int ){if _cdf ._d ==nil &&_ba < _cb {_cdf ._d =make ([]byte ,_ba ,_cb );
return ;};_dea :=len (_cdf ._d );if _cdf ._fc !=0{_dea ++;};_gd :=cap (_cdf ._d );switch {case _ba <=_gd /2-_dea :_g .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_cdf ._d ),cap (_cdf ._d ),_ba );
_g .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_gd ,_dea );copy (_cdf ._d ,_cdf ._d [_cdf .fullOffset ():]);
case _gd > _fg -_gd -_ba :_g .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ag :=make ([]byte ,2*_gd +_ba );copy (_ag ,_cdf ._d );_cdf ._d =_ag ;};_cdf ._d =_cdf ._d [:_dea +_ba ];
};type readerSource struct{_fde []byte ;_fgdg int ;_dgd int ;};func (_agg *Reader )ReadBit ()(_fad int ,_cfd error ){_bcdb ,_cfd :=_agg .readBool ();if _cfd !=nil {return 0,_cfd ;};if _bcdb {_fad =1;};return _fad ,nil ;};func (_bdcg *Writer )UseMSB ()bool {return _bdcg ._aed };
var _ _f .Writer =&BufferedWriter {};func NewWriterMSB (data []byte )*Writer {return &Writer {_beb :data ,_aed :true }};func (_dg *BufferedWriter )Reset (){_dg ._d =_dg ._d [:0];_dg ._dc =0;_dg ._fc =0};func (_aec *BufferedWriter )tryGrowByReslice (_cde int )bool {if _ecc :=len (_aec ._d );
_cde <=cap (_aec ._d )-_ecc {_aec ._d =_aec ._d [:_ecc +_cde ];return true ;};return false ;};func NewWriter (data []byte )*Writer {return &Writer {_beb :data }};func (_cdc *Reader )BitPosition ()int {return int (_cdc ._db )};type BinaryWriter interface{BitWriter ;
_f .Writer ;_f .ByteWriter ;Data ()[]byte ;};func (_gfd *Reader )Reset (){_gfd ._fgd =_gfd ._bef ;_gfd ._db =_gfd ._fcb ;_gfd ._ea =_gfd ._bcd ;_gfd ._dbf =_gfd ._eab ;};type BitWriter interface{WriteBit (_bd int )error ;WriteBits (_bgf uint64 ,_fga int )(_fcd int ,_bdc error );
FinishByte ();SkipBits (_ab int )error ;};var _ BinaryWriter =&BufferedWriter {};func (_dad *BufferedWriter )expandIfNeeded (_aae int ){if !_dad .tryGrowByReslice (_aae ){_dad .grow (_aae );};};const (_cb =64;_fg =int (^uint (0)>>1););func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_da :true }};
func (_ge *BufferedWriter )writeByte (_dab byte ){switch {case _ge ._fc ==0:_ge ._d [_ge ._dc ]=_dab ;_ge ._dc ++;case _ge ._da :_ge ._d [_ge ._dc ]|=_dab >>_ge ._fc ;_ge ._dc ++;_ge ._d [_ge ._dc ]=byte (uint16 (_dab )<<(8-_ge ._fc )&0xff);default:_ge ._d [_ge ._dc ]|=byte (uint16 (_dab )<<_ge ._fc &0xff);
_ge ._dc ++;_ge ._d [_ge ._dc ]=_dab >>(8-_ge ._fc );};};var (_ _f .Reader =&Reader {};_ _f .ByteReader =&Reader {};_ _f .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_gca *Reader )readBufferByte ()(byte ,error ){if _gca ._fgd >=int64 (_gca ._fgf ._dgd ){return 0,_f .EOF ;
};_gca ._gdf =-1;_cdg :=_gca ._fgf ._fde [int64 (_gca ._fgf ._fgdg )+_gca ._fgd ];_gca ._fgd ++;_gca ._dbf =int (_cdg );return _cdg ,nil ;};func (_ef *BufferedWriter )Len ()int {return _ef .byteCapacity ()};func (_aaeb *Reader )AbsoluteLength ()uint64 {return uint64 (len (_aaeb ._fgf ._fde ))};
func (_bbcc *Writer )writeByte (_bde byte )error {if _bbcc ._faf > len (_bbcc ._beb )-1{return _f .EOF ;};if _bbcc ._faf ==len (_bbcc ._beb )-1&&_bbcc ._dgb !=0{return _f .EOF ;};if _bbcc ._dgb ==0{_bbcc ._beb [_bbcc ._faf ]=_bde ;_bbcc ._faf ++;return nil ;
};if _bbcc ._aed {_bbcc ._beb [_bbcc ._faf ]|=_bde >>_bbcc ._dgb ;_bbcc ._faf ++;_bbcc ._beb [_bbcc ._faf ]=byte (uint16 (_bde )<<(8-_bbcc ._dgb )&0xff);}else {_bbcc ._beb [_bbcc ._faf ]|=byte (uint16 (_bde )<<_bbcc ._dgb &0xff);_bbcc ._faf ++;_bbcc ._beb [_bbcc ._faf ]=_bde >>(8-_bbcc ._dgb );
};return nil ;};func (_dfb *BufferedWriter )writeShiftedBytes (_aad []byte )int {for _ ,_cce :=range _aad {_dfb .writeByte (_cce );};return len (_aad );};func (_efc *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _efc .writeBit (uint8 (bit ));
};return _aa .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_fdf *Writer )ResetBit (){_fdf ._dgb =0};func (_aag *Reader )ReadUint32 ()(uint32 ,error ){_acb :=make ([]byte ,4);
_ ,_dcc :=_aag .Read (_acb );if _dcc !=nil {return 0,_dcc ;};return _e .BigEndian .Uint32 (_acb ),nil ;};func (_cbc *BufferedWriter )WriteByte (bt byte )error {if _cbc ._dc > len (_cbc ._d )-1||(_cbc ._dc ==len (_cbc ._d )-1&&_cbc ._fc !=0){_cbc .expandIfNeeded (1);
};_cbc .writeByte (bt );return nil ;};func (_fe *BufferedWriter )Data ()[]byte {return _fe ._d };func (_dbc *Reader )ReadBits (n byte )(_dca uint64 ,_cbf error ){if n < _dbc ._db {_fgc :=_dbc ._db -n ;_dca =uint64 (_dbc ._ea >>_fgc );_dbc ._ea &=1<<_fgc -1;
_dbc ._db =_fgc ;return _dca ,nil ;};if n > _dbc ._db {if _dbc ._db > 0{_dca =uint64 (_dbc ._ea );n -=_dbc ._db ;};for n >=8{_ade ,_fb :=_dbc .readBufferByte ();if _fb !=nil {return 0,_fb ;};_dca =_dca <<8+uint64 (_ade );n -=8;};if n > 0{if _dbc ._ea ,_cbf =_dbc .readBufferByte ();
_cbf !=nil {return 0,_cbf ;};_ccf :=8-n ;_dca =_dca <<n +uint64 (_dbc ._ea >>_ccf );_dbc ._ea &=1<<_ccf -1;_dbc ._db =_ccf ;}else {_dbc ._db =0;};return _dca ,nil ;};_dbc ._db =0;return uint64 (_dbc ._ea ),nil ;};func (_gfe *Writer )FinishByte (){if _gfe ._dgb ==0{return ;
};_gfe ._dgb =0;_gfe ._faf ++;};func (_bf *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ff :=int (_bf ._fc )+skip ;if _ff >=0&&_ff < 8{_bf ._fc =uint8 (_ff );return nil ;};_ff =int (_bf ._fc )+_bf ._dc *8+skip ;if _ff < 0{return _aa .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_be :=_ff /8;_ae :=_ff %8;_bf ._fc =uint8 (_ae );if _cd :=_be -_bf ._dc ;_cd > 0&&len (_bf ._d )-1< _be {if _bf ._fc !=0{_cd ++;};_bf .expandIfNeeded (_cd );};_bf ._dc =_be ;return nil ;};func (_gcab *Writer )byteCapacity ()int {_aac :=len (_gcab ._beb )-_gcab ._faf ;
if _gcab ._dgb !=0{_aac --;};return _aac ;};func (_ec *BufferedWriter )Write (d []byte )(int ,error ){_ec .expandIfNeeded (len (d ));if _ec ._fc ==0{return _ec .writeFullBytes (d ),nil ;};return _ec .writeShiftedBytes (d ),nil ;};var _ _f .ByteWriter =&BufferedWriter {};
func (_efgd *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_efgd ._gdf =-1;_efgd ._db =0;_efgd ._ea =0;_efgd ._dbf =0;var _ee int64 ;switch whence {case _f .SeekStart :_ee =offset ;case _f .SeekCurrent :_ee =_efgd ._fgd +offset ;case _f .SeekEnd :_ee =int64 (_efgd ._fgf ._dgd )+offset ;
default:return 0,_c .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _ee < 0{return 0,_c .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_efgd ._fgd =_ee ;_efgd ._db =0;return _ee ,nil ;};func (_defg *Writer )Write (p []byte )(int ,error ){if len (p )> _defg .byteCapacity (){return 0,_f .EOF ;};for _ ,_gdfa :=range p {if _ebd :=_defg .writeByte (_gdfa );_ebd !=nil {return 0,_ebd ;};};
return len (p ),nil ;};func (_ed *Writer )writeBit (_abd uint8 )error {if len (_ed ._beb )-1< _ed ._faf {return _f .EOF ;};_gdfb :=_ed ._dgb ;if _ed ._aed {_gdfb =7-_ed ._dgb ;};_ed ._beb [_ed ._faf ]|=byte (uint16 (_abd <<_gdfb )&0xff);_ed ._dgb ++;if _ed ._dgb ==8{_ed ._faf ++;
_ed ._dgb =0;};return nil ;};func (_fcec *Reader )ReadByte ()(byte ,error ){if _fcec ._db ==0{return _fcec .readBufferByte ();};return _fcec .readUnalignedByte ();};func (_eg *BufferedWriter )ResetBitIndex (){_eg ._fc =0};func (_bcc *BufferedWriter )writeFullBytes (_daf []byte )int {_cca :=copy (_bcc ._d [_bcc .fullOffset ():],_daf );
_bcc ._dc +=_cca ;return _cca ;};func (_fda *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _fda ._db !=0{return _fda .ReadBits (_fda ._db );};return 0,nil ;};func (_ga *Reader )Read (p []byte )(_fab int ,_gdc error ){if _ga ._db ==0{return _ga .read (p );
};for ;_fab < len (p );_fab ++{if p [_fab ],_gdc =_ga .readUnalignedByte ();_gdc !=nil {return 0,_gdc ;};};return _fab ,nil ;};type Reader struct{_fgf readerSource ;_ea byte ;_db byte ;_fgd int64 ;_dbf int ;_gdf int ;_bef int64 ;_fcb byte ;_bcd byte ;_eab int ;
};