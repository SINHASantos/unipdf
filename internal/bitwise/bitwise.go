//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_c "encoding/binary";_aa "errors";_a "fmt";_d "github.com/unidoc/unipdf/v4/common";_e "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_f "io";);func (_af *BufferedWriter )tryGrowByReslice (_cgea int )bool {if _bf :=len (_af ._fd );
_cgea <=cap (_af ._fd )-_bf {_af ._fd =_af ._fd [:_bf +_cgea ];return true ;};return false ;};func (_gdf *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _gdf ._gag !=0{return _gdf .ReadBits (_gdf ._gag );};return 0,nil ;};func (_gdg *Writer )UseMSB ()bool {return _gdg ._dgc };
func (_bbbg *Writer )byteCapacity ()int {_dae :=len (_bbbg ._gggg )-_bbbg ._debf ;if _bbbg ._ffba !=0{_dae --;};return _dae ;};func (_dgd *Writer )WriteByte (c byte )error {return _dgd .writeByte (c )};func (_gef *BufferedWriter )WriteBits (bits uint64 ,number int )(_gfc int ,_deb error ){const _fe ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_e .Errorf (_fe ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_cf :=number /8;if _cf > 0{_fbe :=number -_cf *8;for _eg :=_cf -1;_eg >=0;_eg --{_fbb :=byte ((bits >>uint (_eg *8+_fbe ))&0xff);if _deb =_gef .WriteByte (_fbb );_deb !=nil {return _gfc ,_e .Wrapf (_deb ,_fe ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cf -_eg +1);
};};number -=_cf *8;if number ==0{return _cf ,nil ;};};var _ce int ;for _gge :=0;_gge < number ;_gge ++{if _gef ._fg {_ce =int ((bits >>uint (number -1-_gge ))&0x1);}else {_ce =int (bits &0x1);bits >>=1;};if _deb =_gef .WriteBit (_ce );_deb !=nil {return _gfc ,_e .Wrapf (_deb ,_fe ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gge );
};};return _cf ,nil ;};var _ _f .Writer =&BufferedWriter {};func (_ee *BufferedWriter )Write (d []byte )(int ,error ){_ee .expandIfNeeded (len (d ));if _ee ._ag ==0{return _ee .writeFullBytes (d ),nil ;};return _ee .writeShiftedBytes (d ),nil ;};func (_gad *Reader )AbsoluteLength ()uint64 {return uint64 (len (_gad ._cdb ._ffc ))};
func (_db *BufferedWriter )ResetBitIndex (){_db ._ag =0};func (_ggb *Reader )Align ()(_cgc byte ){_cgc =_ggb ._gag ;_ggb ._gag =0;return _cgc };func (_eae *Reader )ReadByte ()(byte ,error ){if _eae ._gag ==0{return _eae .readBufferByte ();};return _eae .readUnalignedByte ();
};type readerSource struct{_ffc []byte ;_ffe int ;_ba int ;};func (_gf *BufferedWriter )Len ()int {return _gf .byteCapacity ()};func (_aga *BufferedWriter )writeByte (_gdc byte ){switch {case _aga ._ag ==0:_aga ._fd [_aga ._ad ]=_gdc ;_aga ._ad ++;case _aga ._fg :_aga ._fd [_aga ._ad ]|=_gdc >>_aga ._ag ;
_aga ._ad ++;_aga ._fd [_aga ._ad ]=byte (uint16 (_gdc )<<(8-_aga ._ag )&0xff);default:_aga ._fd [_aga ._ad ]|=byte (uint16 (_gdc )<<_aga ._ag &0xff);_aga ._ad ++;_aga ._fd [_aga ._ad ]=_gdc >>(8-_aga ._ag );};};func (_ccg *Reader )Mark (){_ccg ._cc =_ccg ._ef ;
_ccg ._bgcd =_ccg ._gag ;_ccg ._da =_ccg ._dba ;_ccg ._acd =_ccg ._ac ;};func NewWriter (data []byte )*Writer {return &Writer {_gggg :data }};func (_fgc *BufferedWriter )fullOffset ()int {_fa :=_fgc ._ad ;if _fgc ._ag !=0{_fa ++;};return _fa ;};func (_adc *BufferedWriter )Reset (){_adc ._fd =_adc ._fd [:0];
_adc ._ad =0;_adc ._ag =0};func (_dc *Reader )Read (p []byte )(_dfd int ,_gddc error ){if _dc ._gag ==0{return _dc .read (p );};for ;_dfd < len (p );_dfd ++{if p [_dfd ],_gddc =_dc .readUnalignedByte ();_gddc !=nil {return 0,_gddc ;};};return _dfd ,nil ;
};type BinaryWriter interface{BitWriter ;_f .Writer ;_f .ByteWriter ;Data ()[]byte ;};func (_aff *Reader )RelativePosition ()int64 {return _aff ._ef };func (_fc *BufferedWriter )WriteByte (bt byte )error {if _fc ._ad > len (_fc ._fd )-1||(_fc ._ad ==len (_fc ._fd )-1&&_fc ._ag !=0){_fc .expandIfNeeded (1);
};_fc .writeByte (bt );return nil ;};func (_gade *Writer )writeByte (_cdg byte )error {if _gade ._debf > len (_gade ._gggg )-1{return _f .EOF ;};if _gade ._debf ==len (_gade ._gggg )-1&&_gade ._ffba !=0{return _f .EOF ;};if _gade ._ffba ==0{_gade ._gggg [_gade ._debf ]=_cdg ;
_gade ._debf ++;return nil ;};if _gade ._dgc {_gade ._gggg [_gade ._debf ]|=_cdg >>_gade ._ffba ;_gade ._debf ++;_gade ._gggg [_gade ._debf ]=byte (uint16 (_cdg )<<(8-_gade ._ffba )&0xff);}else {_gade ._gggg [_gade ._debf ]|=byte (uint16 (_cdg )<<_gade ._ffba &0xff);
_gade ._debf ++;_gade ._gggg [_gade ._debf ]=_cdg >>(8-_gade ._ffba );};return nil ;};func (_eef *Writer )Write (p []byte )(int ,error ){if len (p )> _eef .byteCapacity (){return 0,_f .EOF ;};for _ ,_cba :=range p {if _cff :=_eef .writeByte (_cba );_cff !=nil {return 0,_cff ;
};};return len (p ),nil ;};func (_abc *Writer )Data ()[]byte {return _abc ._gggg };func (_dca *Writer )FinishByte (){if _dca ._ffba ==0{return ;};_dca ._ffba =0;_dca ._debf ++;};func (_bb *Reader )ReadUint32 ()(uint32 ,error ){_bbb :=make ([]byte ,4);_ ,_fcf :=_bb .Read (_bbb );
if _fcf !=nil {return 0,_fcf ;};return _c .BigEndian .Uint32 (_bbb ),nil ;};func (_bdb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _bdb .writeBit (uint8 (bit ));};return _e .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_agf *Reader )BitPosition ()int {return int (_agf ._gag )};func (_gg *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_bg :=int (_gg ._ag )+skip ;if _bg >=0&&_bg < 8{_gg ._ag =uint8 (_bg );return nil ;};_bg =int (_gg ._ag )+_gg ._ad *8+skip ;
if _bg < 0{return _e .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_gb :=_bg /8;_be :=_bg %8;_gg ._ag =uint8 (_be );
if _ga :=_gb -_gg ._ad ;_ga > 0&&len (_gg ._fd )-1< _gb {if _gg ._ag !=0{_ga ++;};_gg .expandIfNeeded (_ga );};_gg ._ad =_gb ;return nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_gggg :data ,_dgc :true }};func (_gff *Reader )ReadBits (n byte )(_bgd uint64 ,_abe error ){if n < _gff ._gag {_dd :=_gff ._gag -n ;
_bgd =uint64 (_gff ._dba >>_dd );_gff ._dba &=1<<_dd -1;_gff ._gag =_dd ;return _bgd ,nil ;};if n > _gff ._gag {if _gff ._gag > 0{_bgd =uint64 (_gff ._dba );n -=_gff ._gag ;};for n >=8{_bec ,_ebf :=_gff .readBufferByte ();if _ebf !=nil {return 0,_ebf ;
};_bgd =_bgd <<8+uint64 (_bec );n -=8;};if n > 0{if _gff ._dba ,_abe =_gff .readBufferByte ();_abe !=nil {return 0,_abe ;};_fdg :=8-n ;_bgd =_bgd <<n +uint64 (_gff ._dba >>_fdg );_gff ._dba &=1<<_fdg -1;_gff ._gag =_fdg ;}else {_gff ._gag =0;};return _bgd ,nil ;
};_gff ._gag =0;return uint64 (_gff ._dba ),nil ;};func (_ebc *Reader )read (_ed []byte )(int ,error ){if _ebc ._ef >=int64 (_ebc ._cdb ._ba ){return 0,_f .EOF ;};_ebc ._gc =-1;_dbac :=copy (_ed ,_ebc ._cdb ._ffc [(int64 (_ebc ._cdb ._ffe )+_ebc ._ef ):(_ebc ._cdb ._ffe +_ebc ._cdb ._ba )]);
_ebc ._ef +=int64 (_dbac );return _dbac ,nil ;};func (_bbc *Writer )ResetBit (){_bbc ._ffba =0};type BufferedWriter struct{_fd []byte ;_ag uint8 ;_ad int ;_fg bool ;};var _ BinaryWriter =&BufferedWriter {};type Writer struct{_gggg []byte ;_ffba uint8 ;
_debf int ;_dgc bool ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_fg :true }};var _ _f .ByteWriter =&BufferedWriter {};func (_cdf *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_cdf ._gc =-1;_cdf ._gag =0;_cdf ._dba =0;_cdf ._ac =0;
var _bc int64 ;switch whence {case _f .SeekStart :_bc =offset ;case _f .SeekCurrent :_bc =_cdf ._ef +offset ;case _f .SeekEnd :_bc =int64 (_cdf ._cdb ._ba )+offset ;default:return 0,_aa .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _bc < 0{return 0,_aa .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_cdf ._ef =_bc ;_cdf ._gag =0;
return _bc ,nil ;};func (_cd *BufferedWriter )byteCapacity ()int {_cge :=len (_cd ._fd )-_cd ._ad ;if _cd ._ag !=0{_cge --;};return _cge ;};func (_ca *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _e .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ca ._fd )-1< _ca ._ad {_ca .expandIfNeeded (1);};_ea :=_ca ._ag ;if _ca ._fg {_ea =7-_ca ._ag ;};_ca ._fd [_ca ._ad ]|=byte (uint16 (bit <<_ea )&0xff);_ca ._ag ++;if _ca ._ag ==8{_ca ._ad ++;_ca ._ag =0;};return nil ;};func (_b *BufferedWriter )Data ()[]byte {return _b ._fd };
func (_cb *BufferedWriter )FinishByte (){if _cb ._ag ==0{return ;};_cb ._ag =0;_cb ._ad ++;};func (_fca *Reader )ReadBool ()(bool ,error ){return _fca .readBool ()};func (_eaa *Reader )ReadBit ()(_aba int ,_beee error ){_fee ,_beee :=_eaa .readBool ();
if _beee !=nil {return 0,_beee ;};if _fee {_aba =1;};return _aba ,nil ;};func (_bd *Writer )SkipBits (skip int )error {const _gcf ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_ebe :=int (_bd ._ffba )+skip ;
if _ebe >=0&&_ebe < 8{_bd ._ffba =uint8 (_ebe );return nil ;};_ebe =int (_bd ._ffba )+_bd ._debf *8+skip ;if _ebe < 0{return _e .Errorf (_gcf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_gadd :=_ebe /8;
_cfe :=_ebe %8;_d .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_d .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_bd ._ffba ,_bd ._debf ,int (_bd ._ffba )+(_bd ._debf )*8,len (_bd ._gggg ),cap (_bd ._gggg ));
_d .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_ebe ,_cfe );_bd ._ffba =uint8 (_cfe );if _gde :=_gadd -_bd ._debf ;
_gde > 0&&len (_bd ._gggg )-1< _gadd {_d .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_gde );return _e .Errorf (_gcf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bd ._debf =_gadd ;
_d .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_bd ._ffba ,_bd ._debf );return nil ;};func (_bbd *Reader )readUnalignedByte ()(_ffb byte ,_edb error ){_face :=_bbd ._gag ;
_ffb =_bbd ._dba <<(8-_face );_bbd ._dba ,_edb =_bbd .readBufferByte ();if _edb !=nil {return 0,_edb ;};_ffb |=_bbd ._dba >>_face ;_bbd ._dba &=1<<_face -1;return _ffb ,nil ;};func (_gbc *Reader )readBool ()(_bab bool ,_dea error ){if _gbc ._gag ==0{_gbc ._dba ,_dea =_gbc .readBufferByte ();
if _dea !=nil {return false ,_dea ;};_bab =(_gbc ._dba &0x80)!=0;_gbc ._dba ,_gbc ._gag =_gbc ._dba &0x7f,7;return _bab ,nil ;};_gbc ._gag --;_bab =(_gbc ._dba &(1<<_gbc ._gag ))!=0;_gbc ._dba &=1<<_gbc ._gag -1;return _bab ,nil ;};func (_cdbb *Writer )writeBit (_dfda uint8 )error {if len (_cdbb ._gggg )-1< _cdbb ._debf {return _f .EOF ;
};_ged :=_cdbb ._ffba ;if _cdbb ._dgc {_ged =7-_cdbb ._ffba ;};_cdbb ._gggg [_cdbb ._debf ]|=byte (uint16 (_dfda <<_ged )&0xff);_cdbb ._ffba ++;if _cdbb ._ffba ==8{_cdbb ._debf ++;_cdbb ._ffba =0;};return nil ;};type BitWriter interface{WriteBit (_fac int )error ;
WriteBits (_ff uint64 ,_eb int )(_afc int ,_bgc error );FinishByte ();SkipBits (_afb int )error ;};func (_dfa *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_aa .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_dfa ._cdb ._ffe +offset ;};if length > 0{_ccf :=len (_dfa ._cdb ._ffc );if relative {_ccf =_dfa ._cdb ._ba ;};if offset +length > _ccf {return nil ,_a .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_dfa ._cdb ._ba );
};};if length < 0{_cgf :=len (_dfa ._cdb ._ffc );if relative {_cgf =_dfa ._cdb ._ba ;};length =_cgf -offset ;};return &Reader {_cdb :readerSource {_ffc :_dfa ._cdb ._ffc ,_ba :length ,_ffe :offset }},nil ;};func (_dga *Writer )WriteBits (bits uint64 ,number int )(_gcda int ,_caf error ){const _dfc ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_e .Errorf (_dfc ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_cfc :=number /8;if _cfc > 0{_beed :=number -_cfc *8;for _fdab :=_cfc -1;_fdab >=0;_fdab --{_adce :=byte ((bits >>uint (_fdab *8+_beed ))&0xff);if _caf =_dga .WriteByte (_adce );_caf !=nil {return _gcda ,_e .Wrapf (_caf ,_dfc ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cfc -_fdab +1);
};};number -=_cfc *8;if number ==0{return _cfc ,nil ;};};var _agg int ;for _baf :=0;_baf < number ;_baf ++{if _dga ._dgc {_agg =int ((bits >>uint (number -1-_baf ))&0x1);}else {_agg =int (bits &0x1);bits >>=1;};if _caf =_dga .WriteBit (_agg );_caf !=nil {return _gcda ,_e .Wrapf (_caf ,_dfc ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_baf );
};};return _cfc ,nil ;};func (_fdge *Reader )AbsolutePosition ()int64 {return _fdge ._ef +int64 (_fdge ._cdb ._ffe )};func (_dg *BufferedWriter )writeShiftedBytes (_bee []byte )int {for _ ,_gdcb :=range _bee {_dg .writeByte (_gdcb );};return len (_bee );
};func (_dff *BufferedWriter )writeFullBytes (_bgb []byte )int {_fda :=copy (_dff ._fd [_dff .fullOffset ():],_bgb );_dff ._ad +=_fda ;return _fda ;};type Reader struct{_cdb readerSource ;_dba byte ;_gag byte ;_ef int64 ;_ac int ;_gc int ;_cc int64 ;_bgcd byte ;
_da byte ;_acd int ;};type StreamReader interface{_f .Reader ;_f .ByteReader ;_f .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_fgb byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );
Reset ();AbsolutePosition ()int64 ;};func (_ege *BufferedWriter )grow (_gbe int ){if _ege ._fd ==nil &&_gbe < _ab {_ege ._fd =make ([]byte ,_gbe ,_ab );return ;};_gd :=len (_ege ._fd );if _ege ._ag !=0{_gd ++;};_gdd :=cap (_ege ._fd );switch {case _gbe <=_gdd /2-_gd :_d .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ege ._fd ),cap (_ege ._fd ),_gbe );
_d .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_gdd ,_gd );copy (_ege ._fd ,_ege ._fd [_ege .fullOffset ():]);
case _gdd > _ge -_gdd -_gbe :_d .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_df :=make ([]byte ,2*_gdd +_gbe );copy (_df ,_ege ._fd );_ege ._fd =_df ;};_ege ._fd =_ege ._fd [:_gd +_gbe ];
};var (_ _f .Reader =&Reader {};_ _f .ByteReader =&Reader {};_ _f .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_gfe *Reader )Length ()uint64 {return uint64 (_gfe ._cdb ._ba )};const (_ab =64;_ge =int (^uint (0)>>1););func (_cbd *Reader )readBufferByte ()(byte ,error ){if _cbd ._ef >=int64 (_cbd ._cdb ._ba ){return 0,_f .EOF ;
};_cbd ._gc =-1;_ffa :=_cbd ._cdb ._ffc [int64 (_cbd ._cdb ._ffe )+_cbd ._ef ];_cbd ._ef ++;_cbd ._ac =int (_ffa );return _ffa ,nil ;};func (_faf *Reader )Reset (){_faf ._ef =_faf ._cc ;_faf ._gag =_faf ._bgcd ;_faf ._dba =_faf ._da ;_faf ._ac =_faf ._acd ;
};func (_ec *BufferedWriter )expandIfNeeded (_gbb int ){if !_ec .tryGrowByReslice (_gbb ){_ec .grow (_gbb );};};func NewReader (data []byte )*Reader {return &Reader {_cdb :readerSource {_ffc :data ,_ba :len (data ),_ffe :0}};};var _ BinaryWriter =&Writer {};
