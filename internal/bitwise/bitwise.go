//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_cc "encoding/binary";_a "errors";_g "fmt";_f "github.com/unidoc/unipdf/v3/common";_df "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);type BitWriter interface{WriteBit (_bcc int )error ;WriteBits (_dca uint64 ,_bda int )(_efe int ,_gdd error );
FinishByte ();SkipBits (_bgg int )error ;};func (_gcg *BufferedWriter )writeShiftedBytes (_gcb []byte )int {for _ ,_ge :=range _gcb {_gcg .writeByte (_ge );};return len (_gcb );};type Writer struct{_bggdf []byte ;_bggf uint8 ;_fcf int ;_eeb bool ;};func (_fe *BufferedWriter )WriteBits (bits uint64 ,number int )(_bc int ,_ad error ){const _ac ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_df .Errorf (_ac ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_eg :=number /8;if _eg > 0{_bee :=number -_eg *8;for _cb :=_eg -1;_cb >=0;_cb --{_aed :=byte ((bits >>uint (_cb *8+_bee ))&0xff);if _ad =_fe .WriteByte (_aed );_ad !=nil {return _bc ,_df .Wrapf (_ad ,_ac ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_eg -_cb +1);
};};number -=_eg *8;if number ==0{return _eg ,nil ;};};var _ea int ;for _dd :=0;_dd < number ;_dd ++{if _fe ._ae {_ea =int ((bits >>uint (number -1-_dd ))&0x1);}else {_ea =int (bits &0x1);bits >>=1;};if _ad =_fe .WriteBit (_ea );_ad !=nil {return _bc ,_df .Wrapf (_ad ,_ac ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dd );
};};return _eg ,nil ;};var _ _d .Writer =&BufferedWriter {};var _ _d .ByteWriter =&BufferedWriter {};func (_dg *BufferedWriter )tryGrowByReslice (_ab int )bool {if _eab :=len (_dg ._cd );_ab <=cap (_dg ._cd )-_eab {_dg ._cd =_dg ._cd [:_eab +_ab ];return true ;
};return false ;};type StreamReader interface{_d .Reader ;_d .ByteReader ;_d .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_cfa byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );
Reset ();AbsolutePosition ()int64 ;};func (_bde *Reader )AbsolutePosition ()int64 {return _bde ._bfd +int64 (_bde ._ed ._gg )};func (_gbd *Writer )writeByte (_ggec byte )error {if _gbd ._fcf > len (_gbd ._bggdf )-1{return _d .EOF ;};if _gbd ._fcf ==len (_gbd ._bggdf )-1&&_gbd ._bggf !=0{return _d .EOF ;
};if _gbd ._bggf ==0{_gbd ._bggdf [_gbd ._fcf ]=_ggec ;_gbd ._fcf ++;return nil ;};if _gbd ._eeb {_gbd ._bggdf [_gbd ._fcf ]|=_ggec >>_gbd ._bggf ;_gbd ._fcf ++;_gbd ._bggdf [_gbd ._fcf ]=byte (uint16 (_ggec )<<(8-_gbd ._bggf )&0xff);}else {_gbd ._bggdf [_gbd ._fcf ]|=byte (uint16 (_ggec )<<_gbd ._bggf &0xff);
_gbd ._fcf ++;_gbd ._bggdf [_gbd ._fcf ]=_ggec >>(8-_gbd ._bggf );};return nil ;};type readerSource struct{_fbb []byte ;_gg int ;_aff int ;};func (_ba *BufferedWriter )Reset (){_ba ._cd =_ba ._cd [:0];_ba ._fg =0;_ba ._ag =0};func (_bec *Reader )readBufferByte ()(byte ,error ){if _bec ._bfd >=int64 (_bec ._ed ._aff ){return 0,_d .EOF ;
};_bec ._dgb =-1;_ddb :=_bec ._ed ._fbb [int64 (_bec ._ed ._gg )+_bec ._bfd ];_bec ._bfd ++;_bec ._dcb =int (_ddb );return _ddb ,nil ;};func (_cbf *Reader )Reset (){_cbf ._bfd =_cbf ._gff ;_cbf ._bdd =_cbf ._fgeb ;_cbf ._efeg =_cbf ._fbc ;_cbf ._dcb =_cbf ._bcd ;
};type BufferedWriter struct{_cd []byte ;_ag uint8 ;_fg int ;_ae bool ;};func (_ef *BufferedWriter )fullOffset ()int {_afe :=_ef ._fg ;if _ef ._ag !=0{_afe ++;};return _afe ;};func (_dfgc *Reader )read (_bcf []byte )(int ,error ){if _dfgc ._bfd >=int64 (_dfgc ._ed ._aff ){return 0,_d .EOF ;
};_dfgc ._dgb =-1;_ccb :=copy (_bcf ,_dfgc ._ed ._fbb [(int64 (_dfgc ._ed ._gg )+_dfgc ._bfd ):(_dfgc ._ed ._gg +_dfgc ._ed ._aff )]);_dfgc ._bfd +=int64 (_ccb );return _ccb ,nil ;};func (_fc *BufferedWriter )Len ()int {return _fc .byteCapacity ()};func (_caf *Reader )ReadUint32 ()(uint32 ,error ){_gaa :=make ([]byte ,4);
_ ,_eba :=_caf .Read (_gaa );if _eba !=nil {return 0,_eba ;};return _cc .BigEndian .Uint32 (_gaa ),nil ;};func (_geb *Reader )Length ()uint64 {return uint64 (_geb ._ed ._aff )};func (_fee *Reader )Align ()(_fea byte ){_fea =_fee ._bdd ;_fee ._bdd =0;return _fea };
func (_cgg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _cgg .writeBit (uint8 (bit ));};return _df .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};type BinaryWriter interface{BitWriter ;_d .Writer ;_d .ByteWriter ;Data ()[]byte ;};func (_adf *Writer )Write (p []byte )(int ,error ){if len (p )> _adf .byteCapacity (){return 0,_d .EOF ;};for _ ,_fa :=range p {if _bbg :=_adf .writeByte (_fa );_bbg !=nil {return 0,_bbg ;
};};return len (p ),nil ;};var _ BinaryWriter =&BufferedWriter {};func (_egb *Writer )UseMSB ()bool {return _egb ._eeb };func (_eac *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _eac ._bdd !=0{return _eac .ReadBits (_eac ._bdd );};return 0,nil ;};
func NewReader (data []byte )*Reader {return &Reader {_ed :readerSource {_fbb :data ,_aff :len (data ),_gg :0}};};func (_e *BufferedWriter )Write (d []byte )(int ,error ){_e .expandIfNeeded (len (d ));if _e ._ag ==0{return _e .writeFullBytes (d ),nil ;
};return _e .writeShiftedBytes (d ),nil ;};func (_bfc *Reader )RelativePosition ()int64 {return _bfc ._bfd };func (_aegc *Reader )BitPosition ()int {return int (_aegc ._bdd )};var (_ _d .Reader =&Reader {};_ _d .ByteReader =&Reader {};_ _d .Seeker =&Reader {};
_ StreamReader =&Reader {};);func (_dcf *Writer )FinishByte (){if _dcf ._bggf ==0{return ;};_dcf ._bggf =0;_dcf ._fcf ++;};func (_ead *Reader )Mark (){_ead ._gff =_ead ._bfd ;_ead ._fgeb =_ead ._bdd ;_ead ._fbc =_ead ._efeg ;_ead ._bcd =_ead ._dcb ;};func (_gdcd *Reader )ReadBit ()(_caa int ,_dfa error ){_aaa ,_dfa :=_gdcd .readBool ();
if _dfa !=nil {return 0,_dfa ;};if _aaa {_caa =1;};return _caa ,nil ;};func (_cf *BufferedWriter )writeFullBytes (_adc []byte )int {_gb :=copy (_cf ._cd [_cf .fullOffset ():],_adc );_cf ._fg +=_gb ;return _gb ;};func (_cca *Reader )ReadBool ()(bool ,error ){return _cca .readBool ()};
func (_egc *Reader )Read (p []byte )(_gcgb int ,_feg error ){if _egc ._bdd ==0{return _egc .read (p );};for ;_gcgb < len (p );_gcgb ++{if p [_gcgb ],_feg =_egc .readUnalignedByte ();_feg !=nil {return 0,_feg ;};};return _gcgb ,nil ;};const (_b =64;_dfb =int (^uint (0)>>1);
);func (_gge *Reader )ReadByte ()(byte ,error ){if _gge ._bdd ==0{return _gge .readBufferByte ();};return _gge .readUnalignedByte ();};func (_ga *BufferedWriter )grow (_aa int ){if _ga ._cd ==nil &&_aa < _b {_ga ._cd =make ([]byte ,_aa ,_b );return ;};
_bb :=len (_ga ._cd );if _ga ._ag !=0{_bb ++;};_bg :=cap (_ga ._cd );switch {case _aa <=_bg /2-_bb :_f .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ga ._cd ),cap (_ga ._cd ),_aa );
_f .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_bg ,_bb );copy (_ga ._cd ,_ga ._cd [_ga .fullOffset ():]);
case _bg > _dfb -_bg -_aa :_f .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ee :=make ([]byte ,2*_bg +_aa );copy (_ee ,_ga ._cd );_ga ._cd =_ee ;};_ga ._cd =_ga ._cd [:_bb +_aa ];
};func (_gfc *Reader )ReadBits (n byte )(_eb uint64 ,_bggd error ){if n < _gfc ._bdd {_aba :=_gfc ._bdd -n ;_eb =uint64 (_gfc ._efeg >>_aba );_gfc ._efeg &=1<<_aba -1;_gfc ._bdd =_aba ;return _eb ,nil ;};if n > _gfc ._bdd {if _gfc ._bdd > 0{_eb =uint64 (_gfc ._efeg );
n -=_gfc ._bdd ;};for n >=8{_ddd ,_egg :=_gfc .readBufferByte ();if _egg !=nil {return 0,_egg ;};_eb =_eb <<8+uint64 (_ddd );n -=8;};if n > 0{if _gfc ._efeg ,_bggd =_gfc .readBufferByte ();_bggd !=nil {return 0,_bggd ;};_db :=8-n ;_eb =_eb <<n +uint64 (_gfc ._efeg >>_db );
_gfc ._efeg &=1<<_db -1;_gfc ._bdd =_db ;}else {_gfc ._bdd =0;};return _eb ,nil ;};_gfc ._bdd =0;return uint64 (_gfc ._efeg ),nil ;};func (_dcd *Writer )Data ()[]byte {return _dcd ._bggdf };func (_gde *BufferedWriter )byteCapacity ()int {_dc :=len (_gde ._cd )-_gde ._fg ;
if _gde ._ag !=0{_dc --;};return _dc ;};func (_fge *BufferedWriter )Data ()[]byte {return _fge ._cd };func (_gdef *Writer )WriteByte (c byte )error {return _gdef .writeByte (c )};func (_cgc *Writer )writeBit (_bge uint8 )error {if len (_cgc ._bggdf )-1< _cgc ._fcf {return _d .EOF ;
};_gbe :=_cgc ._bggf ;if _cgc ._eeb {_gbe =7-_cgc ._bggf ;};_cgc ._bggdf [_cgc ._fcf ]|=byte (uint16 (_bge <<_gbe )&0xff);_cgc ._bggf ++;if _cgc ._bggf ==8{_cgc ._fcf ++;_cgc ._bggf =0;};return nil ;};func (_bed *BufferedWriter )expandIfNeeded (_aeg int ){if !_bed .tryGrowByReslice (_aeg ){_bed .grow (_aeg );
};};func (_acc *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_a .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_acc ._ed ._gg +offset ;};if length > 0{_ege :=len (_acc ._ed ._fbb );if relative {_ege =_acc ._ed ._aff ;};if offset +length > _ege {return nil ,_g .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_acc ._ed ._aff );
};};if length < 0{_eeg :=len (_acc ._ed ._fbb );if relative {_eeg =_acc ._ed ._aff ;};length =_eeg -offset ;};return &Reader {_ed :readerSource {_fbb :_acc ._ed ._fbb ,_aff :length ,_gg :offset }},nil ;};func (_afb *Reader )readBool ()(_dfd bool ,_cbaf error ){if _afb ._bdd ==0{_afb ._efeg ,_cbaf =_afb .readBufferByte ();
if _cbaf !=nil {return false ,_cbaf ;};_dfd =(_afb ._efeg &0x80)!=0;_afb ._efeg ,_afb ._bdd =_afb ._efeg &0x7f,7;return _dfd ,nil ;};_afb ._bdd --;_dfd =(_afb ._efeg &(1<<_afb ._bdd ))!=0;_afb ._efeg &=1<<_afb ._bdd -1;return _dfd ,nil ;};func (_fd *BufferedWriter )ResetBitIndex (){_fd ._ag =0};
func NewWriterMSB (data []byte )*Writer {return &Writer {_bggdf :data ,_eeb :true }};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ae :true }};func (_cdd *Reader )readUnalignedByte ()(_efg byte ,_gddb error ){_fba :=_cdd ._bdd ;_efg =_cdd ._efeg <<(8-_fba );
_cdd ._efeg ,_gddb =_cdd .readBufferByte ();if _gddb !=nil {return 0,_gddb ;};_efg |=_cdd ._efeg >>_fba ;_cdd ._efeg &=1<<_fba -1;return _efg ,nil ;};func (_bca *BufferedWriter )writeByte (_fda byte ){switch {case _bca ._ag ==0:_bca ._cd [_bca ._fg ]=_fda ;
_bca ._fg ++;case _bca ._ae :_bca ._cd [_bca ._fg ]|=_fda >>_bca ._ag ;_bca ._fg ++;_bca ._cd [_bca ._fg ]=byte (uint16 (_fda )<<(8-_bca ._ag )&0xff);default:_bca ._cd [_bca ._fg ]|=byte (uint16 (_fda )<<_bca ._ag &0xff);_bca ._fg ++;_bca ._cd [_bca ._fg ]=_fda >>(8-_bca ._ag );
};};func (_efa *Writer )ResetBit (){_efa ._bggf =0};var _ BinaryWriter =&Writer {};func (_gdc *Reader )AbsoluteLength ()uint64 {return uint64 (len (_gdc ._ed ._fbb ))};type Reader struct{_ed readerSource ;_efeg byte ;_bdd byte ;_bfd int64 ;_dcb int ;_dgb int ;
_gff int64 ;_fgeb byte ;_fbc byte ;_bcd int ;};func (_gcge *Writer )SkipBits (skip int )error {const _bag ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_eebb :=int (_gcge ._bggf )+skip ;if _eebb >=0&&_eebb < 8{_gcge ._bggf =uint8 (_eebb );
return nil ;};_eebb =int (_gcge ._bggf )+_gcge ._fcf *8+skip ;if _eebb < 0{return _df .Errorf (_bag ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_feea :=_eebb /8;_aegb :=_eebb %8;_f .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_f .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_gcge ._bggf ,_gcge ._fcf ,int (_gcge ._bggf )+(_gcge ._fcf )*8,len (_gcge ._bggdf ),cap (_gcge ._bggdf ));
_f .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_eebb ,_aegb );_gcge ._bggf =uint8 (_aegb );
if _bdg :=_feea -_gcge ._fcf ;_bdg > 0&&len (_gcge ._bggdf )-1< _feea {_f .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_bdg );return _df .Errorf (_bag ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gcge ._fcf =_feea ;_f .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_gcge ._bggf ,_gcge ._fcf );return nil ;
};func (_cg *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _df .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_cg ._cd )-1< _cg ._fg {_cg .expandIfNeeded (1);};_dfg :=_cg ._ag ;if _cg ._ae {_dfg =7-_cg ._ag ;};_cg ._cd [_cg ._fg ]|=byte (uint16 (bit <<_dfg )&0xff);_cg ._ag ++;if _cg ._ag ==8{_cg ._fg ++;_cg ._ag =0;};return nil ;};func NewWriter (data []byte )*Writer {return &Writer {_bggdf :data }};
func (_gd *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_af :=int (_gd ._ag )+skip ;if _af >=0&&_af < 8{_gd ._ag =uint8 (_af );return nil ;};_af =int (_gd ._ag )+_gd ._fg *8+skip ;if _af < 0{return _df .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gc :=_af /8;_be :=_af %8;_gd ._ag =uint8 (_be );if _fb :=_gc -_gd ._fg ;_fb > 0&&len (_gd ._cd )-1< _gc {if _gd ._ag !=0{_fb ++;};_gd .expandIfNeeded (_fb );};_gd ._fg =_gc ;return nil ;};func (_ebb *Writer )byteCapacity ()int {_dcbb :=len (_ebb ._bggdf )-_ebb ._fcf ;
if _ebb ._bggf !=0{_dcbb --;};return _dcbb ;};func (_dbd *Writer )WriteBits (bits uint64 ,number int )(_dfc int ,_dfba error ){const _egcf ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_df .Errorf (_egcf ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_baeb :=number /8;if _baeb > 0{_adcf :=number -_baeb *8;for _bdb :=_baeb -1;_bdb >=0;_bdb --{_beb :=byte ((bits >>uint (_bdb *8+_adcf ))&0xff);if _dfba =_dbd .WriteByte (_beb );_dfba !=nil {return _dfc ,_df .Wrapf (_dfba ,_egcf ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_baeb -_bdb +1);
};};number -=_baeb *8;if number ==0{return _baeb ,nil ;};};var _gdf int ;for _gffd :=0;_gffd < number ;_gffd ++{if _dbd ._eeb {_gdf =int ((bits >>uint (number -1-_gffd ))&0x1);}else {_gdf =int (bits &0x1);bits >>=1;};if _dfba =_dbd .WriteBit (_gdf );_dfba !=nil {return _dfc ,_df .Wrapf (_dfba ,_egcf ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gffd );
};};return _baeb ,nil ;};func (_ddf *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_ddf ._dgb =-1;_ddf ._bdd =0;_ddf ._efeg =0;_ddf ._dcb =0;var _ebe int64 ;switch whence {case _d .SeekStart :_ebe =offset ;case _d .SeekCurrent :_ebe =_ddf ._bfd +offset ;
case _d .SeekEnd :_ebe =int64 (_ddf ._ed ._aff )+offset ;default:return 0,_a .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _ebe < 0{return 0,_a .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_ddf ._bfd =_ebe ;
_ddf ._bdd =0;return _ebe ,nil ;};func (_gf *BufferedWriter )FinishByte (){if _gf ._ag ==0{return ;};_gf ._ag =0;_gf ._fg ++;};func (_bf *BufferedWriter )WriteByte (bt byte )error {if _bf ._fg > len (_bf ._cd )-1||(_bf ._fg ==len (_bf ._cd )-1&&_bf ._ag !=0){_bf .expandIfNeeded (1);
};_bf .writeByte (bt );return nil ;};