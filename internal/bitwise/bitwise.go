//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_g "encoding/binary";_b "errors";_e "fmt";_ga "github.com/unidoc/unipdf/v3/common";_gad "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ba :true }};type BufferedWriter struct{_fe []byte ;
_gf uint8 ;_gab int ;_ba bool ;};func (_ed *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _gad .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ed ._fe )-1< _ed ._gab {_ed .expandIfNeeded (1);};_fb :=_ed ._gf ;if _ed ._ba {_fb =7-_ed ._gf ;};_ed ._fe [_ed ._gab ]|=byte (uint16 (bit <<_fb )&0xff);_ed ._gf ++;if _ed ._gf ==8{_ed ._gab ++;_ed ._gf =0;};return nil ;};func (_bg *BufferedWriter )ResetBitIndex (){_bg ._gf =0};
type Reader struct{_dec readerSource ;_gbc byte ;_gbe byte ;_fbb int64 ;_add int ;_cb int ;_bfae int64 ;_ebg byte ;_gcd byte ;_ddf int ;};type BitWriter interface{WriteBit (_bd int )error ;WriteBits (_gdd uint64 ,_aad int )(_eea int ,_abb error );FinishByte ();
SkipBits (_af int )error ;};type StreamReader interface{_d .Reader ;_d .ByteReader ;_d .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_ede byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );
Reset ();AbsolutePosition ()int64 ;};func (_gaec *Writer )ResetBit (){_gaec ._abf =0};func (_ade *Reader )readBool ()(_gfa bool ,_bfc error ){if _ade ._gbe ==0{_ade ._gbc ,_bfc =_ade .readBufferByte ();if _bfc !=nil {return false ,_bfc ;};_gfa =(_ade ._gbc &0x80)!=0;
_ade ._gbc ,_ade ._gbe =_ade ._gbc &0x7f,7;return _gfa ,nil ;};_ade ._gbe --;_gfa =(_ade ._gbc &(1<<_ade ._gbe ))!=0;_ade ._gbc &=1<<_ade ._gbe -1;return _gfa ,nil ;};func (_cbe *Reader )Align ()(_dgfa byte ){_dgfa =_cbe ._gbe ;_cbe ._gbe =0;return _dgfa };
func (_ca *Reader )ReadUint32 ()(uint32 ,error ){_ddffg :=make ([]byte ,4);_ ,_ge :=_ca .Read (_ddffg );if _ge !=nil {return 0,_ge ;};return _g .BigEndian .Uint32 (_ddffg ),nil ;};func (_dgbe *Writer )WriteByte (c byte )error {return _dgbe .writeByte (c )};
func (_bff *Reader )RelativePosition ()int64 {return _bff ._fbb };func (_acf *Reader )read (_eee []byte )(int ,error ){if _acf ._fbb >=int64 (_acf ._dec ._gfd ){return 0,_d .EOF ;};_acf ._cb =-1;_dbf :=copy (_eee ,_acf ._dec ._bda [(int64 (_acf ._dec ._bb )+_acf ._fbb ):(_acf ._dec ._bb +_acf ._dec ._gfd )]);
_acf ._fbb +=int64 (_dbf );return _dbf ,nil ;};func (_fa *BufferedWriter )fullOffset ()int {_gac :=_fa ._gab ;if _fa ._gf !=0{_gac ++;};return _gac ;};func (_cac *Reader )readUnalignedByte ()(_cgd byte ,_feeg error ){_agc :=_cac ._gbe ;_cgd =_cac ._gbc <<(8-_agc );
_cac ._gbc ,_feeg =_cac .readBufferByte ();if _feeg !=nil {return 0,_feeg ;};_cgd |=_cac ._gbc >>_agc ;_cac ._gbc &=1<<_agc -1;return _cgd ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_baf :data }};func (_dbed *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _dbed ._gbe !=0{return _dbed .ReadBits (_dbed ._gbe );
};return 0,nil ;};func (_cd *Reader )BitPosition ()int {return int (_cd ._gbe )};func (_dfa *BufferedWriter )WriteBits (bits uint64 ,number int )(_ad int ,_fgg error ){const _gbf ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_gad .Errorf (_gbf ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_db :=number /8;if _db > 0{_fbc :=number -_db *8;for _gae :=_db -1;_gae >=0;_gae --{_ag :=byte ((bits >>uint (_gae *8+_fbc ))&0xff);if _fgg =_dfa .WriteByte (_ag );_fgg !=nil {return _ad ,_gad .Wrapf (_fgg ,_gbf ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_db -_gae +1);
};};number -=_db *8;if number ==0{return _db ,nil ;};};var _bfb int ;for _dd :=0;_dd < number ;_dd ++{if _dfa ._ba {_bfb =int ((bits >>uint (number -1-_dd ))&0x1);}else {_bfb =int (bits &0x1);bits >>=1;};if _fgg =_dfa .WriteBit (_bfb );_fgg !=nil {return _ad ,_gad .Wrapf (_fgg ,_gbf ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dd );
};};return _db ,nil ;};const (_dg =64;_cc =int (^uint (0)>>1););type BinaryWriter interface{BitWriter ;_d .Writer ;_d .ByteWriter ;Data ()[]byte ;};var _ BinaryWriter =&BufferedWriter {};func (_faa *BufferedWriter )writeByte (_gc byte ){switch {case _faa ._gf ==0:_faa ._fe [_faa ._gab ]=_gc ;
_faa ._gab ++;case _faa ._ba :_faa ._fe [_faa ._gab ]|=_gc >>_faa ._gf ;_faa ._gab ++;_faa ._fe [_faa ._gab ]=byte (uint16 (_gc )<<(8-_faa ._gf )&0xff);default:_faa ._fe [_faa ._gab ]|=byte (uint16 (_gc )<<_faa ._gf &0xff);_faa ._gab ++;_faa ._fe [_faa ._gab ]=_gc >>(8-_faa ._gf );
};};func (_fd *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_b .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_fd ._dec ._bb +offset ;};if length > 0{_bgd :=len (_fd ._dec ._bda );if relative {_bgd =_fd ._dec ._gfd ;};if offset +length > _bgd {return nil ,_e .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_fd ._dec ._gfd );
};};if length < 0{_cg :=len (_fd ._dec ._bda );if relative {_cg =_fd ._dec ._gfd ;};length =_cg -offset ;};return &Reader {_dec :readerSource {_bda :_fd ._dec ._bda ,_gfd :length ,_bb :offset }},nil ;};func (_dgf *BufferedWriter )byteCapacity ()int {_fgga :=len (_dgf ._fe )-_dgf ._gab ;
if _dgf ._gf !=0{_fgga --;};return _fgga ;};func (_eg *BufferedWriter )grow (_gffd int ){if _eg ._fe ==nil &&_gffd < _dg {_eg ._fe =make ([]byte ,_gffd ,_dg );return ;};_ee :=len (_eg ._fe );if _eg ._gf !=0{_ee ++;};_ec :=cap (_eg ._fe );switch {case _gffd <=_ec /2-_ee :_ga .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_eg ._fe ),cap (_eg ._fe ),_gffd );
_ga .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ec ,_ee );copy (_eg ._fe ,_eg ._fe [_eg .fullOffset ():]);
case _ec > _cc -_ec -_gffd :_ga .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_gdc :=make ([]byte ,2*_ec +_gffd );copy (_gdc ,_eg ._fe );_eg ._fe =_gdc ;};_eg ._fe =_eg ._fe [:_ee +_gffd ];
};func (_dbfc *Writer )writeByte (_ccg byte )error {if _dbfc ._feb > len (_dbfc ._baf )-1{return _d .EOF ;};if _dbfc ._feb ==len (_dbfc ._baf )-1&&_dbfc ._abf !=0{return _d .EOF ;};if _dbfc ._abf ==0{_dbfc ._baf [_dbfc ._feb ]=_ccg ;_dbfc ._feb ++;return nil ;
};if _dbfc ._ecb {_dbfc ._baf [_dbfc ._feb ]|=_ccg >>_dbfc ._abf ;_dbfc ._feb ++;_dbfc ._baf [_dbfc ._feb ]=byte (uint16 (_ccg )<<(8-_dbfc ._abf )&0xff);}else {_dbfc ._baf [_dbfc ._feb ]|=byte (uint16 (_ccg )<<_dbfc ._abf &0xff);_dbfc ._feb ++;_dbfc ._baf [_dbfc ._feb ]=_ccg >>(8-_dbfc ._abf );
};return nil ;};func (_a *BufferedWriter )Len ()int {return _a .byteCapacity ()};func (_ae *Reader )readBufferByte ()(byte ,error ){if _ae ._fbb >=int64 (_ae ._dec ._gfd ){return 0,_d .EOF ;};_ae ._cb =-1;_egb :=_ae ._dec ._bda [int64 (_ae ._dec ._bb )+_ae ._fbb ];
_ae ._fbb ++;_ae ._add =int (_egb );return _egb ,nil ;};func (_gffc *Reader )Reset (){_gffc ._fbb =_gffc ._bfae ;_gffc ._gbe =_gffc ._ebg ;_gffc ._gbc =_gffc ._gcd ;_gffc ._add =_gffc ._ddf ;};func (_da *BufferedWriter )writeShiftedBytes (_fef []byte )int {for _ ,_ac :=range _fef {_da .writeByte (_ac );
};return len (_fef );};func (_gd *BufferedWriter )Reset (){_gd ._fe =_gd ._fe [:0];_gd ._gab =0;_gd ._gf =0};func (_adg *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_adg ._cb =-1;_adg ._gbe =0;_adg ._gbc =0;_adg ._add =0;var _cbg int64 ;switch whence {case _d .SeekStart :_cbg =offset ;
case _d .SeekCurrent :_cbg =_adg ._fbb +offset ;case _d .SeekEnd :_cbg =int64 (_adg ._dec ._gfd )+offset ;default:return 0,_b .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _cbg < 0{return 0,_b .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_adg ._fbb =_cbg ;
_adg ._gbe =0;return _cbg ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_baf :data ,_ecb :true }};func (_bgf *BufferedWriter )expandIfNeeded (_bfa int ){if !_bgf .tryGrowByReslice (_bfa ){_bgf .grow (_bfa );};};func (_fc *Reader )ReadBit ()(_ddff int ,_aaf error ){_ef ,_aaf :=_fc .readBool ();
if _aaf !=nil {return 0,_aaf ;};if _ef {_ddff =1;};return _ddff ,nil ;};func (_eca *Writer )Data ()[]byte {return _eca ._baf };func (_ebcg *Writer )FinishByte (){if _ebcg ._abf ==0{return ;};_ebcg ._abf =0;_ebcg ._feb ++;};var (_ _d .Reader =&Reader {};
_ _d .ByteReader =&Reader {};_ _d .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_agb *Reader )Length ()uint64 {return uint64 (_agb ._dec ._gfd )};func (_gcb *Writer )Write (p []byte )(int ,error ){if len (p )> _gcb .byteCapacity (){return 0,_d .EOF ;
};for _ ,_abd :=range p {if _ddb :=_gcb .writeByte (_abd );_ddb !=nil {return 0,_ddb ;};};return len (p ),nil ;};func (_gaf *Reader )Read (p []byte )(_afd int ,_bbg error ){if _gaf ._gbe ==0{return _gaf .read (p );};for ;_afd < len (p );_afd ++{if p [_afd ],_bbg =_gaf .readUnalignedByte ();
_bbg !=nil {return 0,_bbg ;};};return _afd ,nil ;};var _ _d .ByteWriter =&BufferedWriter {};var _ _d .Writer =&BufferedWriter {};func (_aae *Writer )writeBit (_ggd uint8 )error {if len (_aae ._baf )-1< _aae ._feb {return _d .EOF ;};_dab :=_aae ._abf ;if _aae ._ecb {_dab =7-_aae ._abf ;
};_aae ._baf [_aae ._feb ]|=byte (uint16 (_ggd <<_dab )&0xff);_aae ._abf ++;if _aae ._abf ==8{_aae ._feb ++;_aae ._abf =0;};return nil ;};func (_gga *Reader )Mark (){_gga ._bfae =_gga ._fbb ;_gga ._ebg =_gga ._gbe ;_gga ._gcd =_gga ._gbc ;_gga ._ddf =_gga ._add ;
};func NewReader (data []byte )*Reader {return &Reader {_dec :readerSource {_bda :data ,_gfd :len (data ),_bb :0}};};func (_beg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _beg .writeBit (uint8 (bit ));};return _gad .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_eb *BufferedWriter )FinishByte (){if _eb ._gf ==0{return ;};_eb ._gf =0;_eb ._gab ++;};func (_ecf *BufferedWriter )writeFullBytes (_ecff []byte )int {_fbd :=copy (_ecf ._fe [_ecf .fullOffset ():],_ecff );_ecf ._gab +=_fbd ;return _fbd ;};func (_gea *Writer )UseMSB ()bool {return _gea ._ecb };
func (_fca *Writer )SkipBits (skip int )error {const _gba ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_ea :=int (_fca ._abf )+skip ;if _ea >=0&&_ea < 8{_fca ._abf =uint8 (_ea );return nil ;
};_ea =int (_fca ._abf )+_fca ._feb *8+skip ;if _ea < 0{return _gad .Errorf (_gba ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_beb :=_ea /8;_dgb :=_ea %8;_ga .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_ga .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_fca ._abf ,_fca ._feb ,int (_fca ._abf )+(_fca ._feb )*8,len (_fca ._baf ),cap (_fca ._baf ));
_ga .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_ea ,_dgb );_fca ._abf =uint8 (_dgb );if _gfff :=_beb -_fca ._feb ;
_gfff > 0&&len (_fca ._baf )-1< _beb {_ga .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_gfff );return _gad .Errorf (_gba ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fca ._feb =_beb ;_ga .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_fca ._abf ,_fca ._feb );return nil ;};func (_fdd *Reader )ReadBits (n byte )(_gge uint64 ,_fec error ){if n < _fdd ._gbe {_baa :=_fdd ._gbe -n ;
_gge =uint64 (_fdd ._gbc >>_baa );_fdd ._gbc &=1<<_baa -1;_fdd ._gbe =_baa ;return _gge ,nil ;};if n > _fdd ._gbe {if _fdd ._gbe > 0{_gge =uint64 (_fdd ._gbc );n -=_fdd ._gbe ;};for n >=8{_dba ,_fgb :=_fdd .readBufferByte ();if _fgb !=nil {return 0,_fgb ;
};_gge =_gge <<8+uint64 (_dba );n -=8;};if n > 0{if _fdd ._gbc ,_fec =_fdd .readBufferByte ();_fec !=nil {return 0,_fec ;};_dff :=8-n ;_gge =_gge <<n +uint64 (_fdd ._gbc >>_dff );_fdd ._gbc &=1<<_dff -1;_fdd ._gbe =_dff ;}else {_fdd ._gbe =0;};return _gge ,nil ;
};_fdd ._gbe =0;return uint64 (_fdd ._gbc ),nil ;};func (_fee *Reader )AbsolutePosition ()int64 {return _fee ._fbb +int64 (_fee ._dec ._bb )};type readerSource struct{_bda []byte ;_bb int ;_gfd int ;};type Writer struct{_baf []byte ;_abf uint8 ;_feb int ;
_ecb bool ;};func (_fcg *Reader )ReadBool ()(bool ,error ){return _fcg .readBool ()};func (_adb *Reader )ReadByte ()(byte ,error ){if _adb ._gbe ==0{return _adb .readBufferByte ();};return _adb .readUnalignedByte ();};func (_bf *BufferedWriter )Data ()[]byte {return _bf ._fe };
func (_dbd *Writer )byteCapacity ()int {_cff :=len (_dbd ._baf )-_dbd ._feb ;if _dbd ._abf !=0{_cff --;};return _cff ;};func (_dae *Writer )WriteBits (bits uint64 ,number int )(_ccc int ,_cfe error ){const _cgc ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_gad .Errorf (_cgc ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_cbf :=number /8;if _cbf > 0{_dgcd :=number -_cbf *8;for _cfb :=_cbf -1;_cfb >=0;_cfb --{_fce :=byte ((bits >>uint (_cfb *8+_dgcd ))&0xff);if _cfe =_dae .WriteByte (_fce );_cfe !=nil {return _ccc ,_gad .Wrapf (_cfe ,_cgc ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cbf -_cfb +1);
};};number -=_cbf *8;if number ==0{return _cbf ,nil ;};};var _efd int ;for _ggae :=0;_ggae < number ;_ggae ++{if _dae ._ecb {_efd =int ((bits >>uint (number -1-_ggae ))&0x1);}else {_efd =int (bits &0x1);bits >>=1;};if _cfe =_dae .WriteBit (_efd );_cfe !=nil {return _ccc ,_gad .Wrapf (_cfe ,_cgc ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ggae );
};};return _cbf ,nil ;};func (_dgc *BufferedWriter )WriteByte (bt byte )error {if _dgc ._gab > len (_dgc ._fe )-1||(_dgc ._gab ==len (_dgc ._fe )-1&&_dgc ._gf !=0){_dgc .expandIfNeeded (1);};_dgc .writeByte (bt );return nil ;};var _ BinaryWriter =&Writer {};
func (_gbg *BufferedWriter )tryGrowByReslice (_dbe int )bool {if _cf :=len (_gbg ._fe );_dbe <=cap (_gbg ._fe )-_cf {_gbg ._fe =_gbg ._fe [:_cf +_dbe ];return true ;};return false ;};func (_gg *Reader )AbsoluteLength ()uint64 {return uint64 (len (_gg ._dec ._bda ))};
func (_de *BufferedWriter )Write (d []byte )(int ,error ){_de .expandIfNeeded (len (d ));if _de ._gf ==0{return _de .writeFullBytes (d ),nil ;};return _de .writeShiftedBytes (d ),nil ;};func (_gaa *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_ccd :=int (_gaa ._gf )+skip ;if _ccd >=0&&_ccd < 8{_gaa ._gf =uint8 (_ccd );return nil ;};_ccd =int (_gaa ._gf )+_gaa ._gab *8+skip ;if _ccd < 0{return _gad .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_aa :=_ccd /8;_fg :=_ccd %8;_gaa ._gf =uint8 (_fg );if _df :=_aa -_gaa ._gab ;_df > 0&&len (_gaa ._fe )-1< _aa {if _gaa ._gf !=0{_df ++;};_gaa .expandIfNeeded (_df );};_gaa ._gab =_aa ;return nil ;};