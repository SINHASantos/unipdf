//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_c "encoding/binary";_ec "errors";_b "fmt";_bf "github.com/unidoc/unipdf/v3/common";_f "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func NewWriter (data []byte )*Writer {return &Writer {_def :data }};func (_fge *Reader )Read (p []byte )(_fce int ,_cde error ){if _fge ._de ==0{return _fge .read (p );
};for ;_fce < len (p );_fce ++{if p [_fce ],_cde =_fge .readUnalignedByte ();_cde !=nil {return 0,_cde ;};};return _fce ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_def :data ,_fef :true }};func (_dfg *Reader )read (_acc []byte )(int ,error ){if _dfg ._adb >=int64 (_dfg ._ca ._bbd ){return 0,_e .EOF ;
};_dfg ._bb =-1;_gfe :=copy (_acc ,_dfg ._ca ._dbd [(int64 (_dfg ._ca ._aabe )+_dfg ._adb ):(_dfg ._ca ._aabe +_dfg ._ca ._bbd )]);_dfg ._adb +=int64 (_gfe );return _gfe ,nil ;};func (_ff *BufferedWriter )Len ()int {return _ff .byteCapacity ()};func (_afg *Reader )ReadBits (n byte )(_adc uint64 ,_edd error ){if n < _afg ._de {_fa :=_afg ._de -n ;
_adc =uint64 (_afg ._ad >>_fa );_afg ._ad &=1<<_fa -1;_afg ._de =_fa ;return _adc ,nil ;};if n > _afg ._de {if _afg ._de > 0{_adc =uint64 (_afg ._ad );n -=_afg ._de ;};for n >=8{_fcec ,_dge :=_afg .readBufferByte ();if _dge !=nil {return 0,_dge ;};_adc =_adc <<8+uint64 (_fcec );
n -=8;};if n > 0{if _afg ._ad ,_edd =_afg .readBufferByte ();_edd !=nil {return 0,_edd ;};_aae :=8-n ;_adc =_adc <<n +uint64 (_afg ._ad >>_aae );_afg ._ad &=1<<_aae -1;_afg ._de =_aae ;}else {_afg ._de =0;};return _adc ,nil ;};_afg ._de =0;return uint64 (_afg ._ad ),nil ;
};func (_ae *BufferedWriter )writeByte (_db byte ){switch {case _ae ._bfb ==0:_ae ._bg [_ae ._eg ]=_db ;_ae ._eg ++;case _ae ._cc :_ae ._bg [_ae ._eg ]|=_db >>_ae ._bfb ;_ae ._eg ++;_ae ._bg [_ae ._eg ]=byte (uint16 (_db )<<(8-_ae ._bfb )&0xff);default:_ae ._bg [_ae ._eg ]|=byte (uint16 (_db )<<_ae ._bfb &0xff);
_ae ._eg ++;_ae ._bg [_ae ._eg ]=_db >>(8-_ae ._bfb );};};func (_add *Reader )BitPosition ()int {return int (_add ._de )};func (_bcc *Reader )readBool ()(_bbcb bool ,_ccd error ){if _bcc ._de ==0{_bcc ._ad ,_ccd =_bcc .readBufferByte ();if _ccd !=nil {return false ,_ccd ;
};_bbcb =(_bcc ._ad &0x80)!=0;_bcc ._ad ,_bcc ._de =_bcc ._ad &0x7f,7;return _bbcb ,nil ;};_bcc ._de --;_bbcb =(_bcc ._ad &(1<<_bcc ._de ))!=0;_bcc ._ad &=1<<_bcc ._de -1;return _bbcb ,nil ;};func (_fbc *Reader )RelativePosition ()int64 {return _fbc ._adb };
func (_ega *Writer )byteCapacity ()int {_fda :=len (_ega ._def )-_ega ._dag ;if _ega ._cad !=0{_fda --;};return _fda ;};func (_bfg *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _f .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_bfg ._bg )-1< _bfg ._eg {_bfg .expandIfNeeded (1);};_bc :=_bfg ._bfb ;if _bfg ._cc {_bc =7-_bfg ._bfb ;};_bfg ._bg [_bfg ._eg ]|=byte (uint16 (bit <<_bc )&0xff);_bfg ._bfb ++;if _bfg ._bfb ==8{_bfg ._eg ++;_bfg ._bfb =0;};return nil ;};func (_fcee *Writer )ResetBit (){_fcee ._cad =0};
func (_gaf *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _gaf .writeBit (uint8 (bit ));};return _f .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_gbg *Writer )FinishByte (){if _gbg ._cad ==0{return ;};_gbg ._cad =0;_gbg ._dag ++;};func (_debg *Writer )Write (p []byte )(int ,error ){if len (p )> _debg .byteCapacity (){return 0,_e .EOF ;};for _ ,_dfe :=range p {if _aag :=_debg .writeByte (_dfe );
_aag !=nil {return 0,_aag ;};};return len (p ),nil ;};func (_be *Reader )ReadBit ()(_ddce int ,_dcd error ){_afb ,_dcd :=_be .readBool ();if _dcd !=nil {return 0,_dcd ;};if _afb {_ddce =1;};return _ddce ,nil ;};func (_dc *BufferedWriter )Data ()[]byte {return _dc ._bg };
func (_cfa *Reader )Align ()(_eed byte ){_eed =_cfa ._de ;_cfa ._de =0;return _eed };func (_dg *BufferedWriter )expandIfNeeded (_ed int ){if !_dg .tryGrowByReslice (_ed ){_dg .grow (_ed );};};func (_a *BufferedWriter )FinishByte (){if _a ._bfb ==0{return ;
};_a ._bfb =0;_a ._eg ++;};func (_ee *BufferedWriter )writeFullBytes (_fdc []byte )int {_bac :=copy (_ee ._bg [_ee .fullOffset ():],_fdc );_ee ._eg +=_bac ;return _bac ;};func (_acf *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_acf ._bb =-1;
_acf ._de =0;_acf ._ad =0;_acf ._fca =0;var _abab int64 ;switch whence {case _e .SeekStart :_abab =offset ;case _e .SeekCurrent :_abab =_acf ._adb +offset ;case _e .SeekEnd :_abab =int64 (_acf ._ca ._bbd )+offset ;default:return 0,_ec .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _abab < 0{return 0,_ec .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_acf ._adb =_abab ;
_acf ._de =0;return _abab ,nil ;};func (_fg *BufferedWriter )grow (_fc int ){if _fg ._bg ==nil &&_fc < _gc {_fg ._bg =make ([]byte ,_fc ,_gc );return ;};_cf :=len (_fg ._bg );if _fg ._bfb !=0{_cf ++;};_bgb :=cap (_fg ._bg );switch {case _fc <=_bgb /2-_cf :_bf .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_fg ._bg ),cap (_fg ._bg ),_fc );
_bf .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_bgb ,_cf );copy (_fg ._bg ,_fg ._bg [_fg .fullOffset ():]);
case _bgb > _d -_bgb -_fc :_bf .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_dca :=make ([]byte ,2*_bgb +_fc );copy (_dca ,_fg ._bg );_fg ._bg =_dca ;};_fg ._bg =_fg ._bg [:_cf +_fc ];
};type Writer struct{_def []byte ;_cad uint8 ;_dag int ;_fef bool ;};func (_ddc *Reader )AbsoluteLength ()uint64 {return uint64 (len (_ddc ._ca ._dbd ))};var (_ _e .Reader =&Reader {};_ _e .ByteReader =&Reader {};_ _e .Seeker =&Reader {};_ StreamReader =&Reader {};
);func (_ga *Reader )ReadBool ()(bool ,error ){return _ga .readBool ()};func (_fdb *Reader )ReadUint32 ()(uint32 ,error ){_aabb :=make ([]byte ,4);_ ,_fde :=_fdb .Read (_aabb );if _fde !=nil {return 0,_fde ;};return _c .BigEndian .Uint32 (_aabb ),nil ;
};func (_ge *BufferedWriter )writeShiftedBytes (_ea []byte )int {for _ ,_efg :=range _ea {_ge .writeByte (_efg );};return len (_ea );};var _ _e .Writer =&BufferedWriter {};func (_bbc *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _bbc ._de !=0{return _bbc .ReadBits (_bbc ._de );
};return 0,nil ;};func (_dd *BufferedWriter )Reset (){_dd ._bg =_dd ._bg [:0];_dd ._eg =0;_dd ._bfb =0};type StreamReader interface{_e .Reader ;_e .ByteReader ;_e .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );
ReadBits (_gcd byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_ag *BufferedWriter )ResetBitIndex (){_ag ._bfb =0};func (_agdd *Reader )readUnalignedByte ()(_cgd byte ,_edc error ){_ffd :=_agdd ._de ;
_cgd =_agdd ._ad <<(8-_ffd );_agdd ._ad ,_edc =_agdd .readBufferByte ();if _edc !=nil {return 0,_edc ;};_cgd |=_agdd ._ad >>_ffd ;_agdd ._ad &=1<<_ffd -1;return _cgd ,nil ;};func (_efge *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_ec .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_efge ._ca ._aabe +offset ;};if length > 0{_aba :=len (_efge ._ca ._dbd );if relative {_aba =_efge ._ca ._bbd ;};if offset +length > _aba {return nil ,_b .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_efge ._ca ._bbd );
};};if length < 0{_geg :=len (_efge ._ca ._dbd );if relative {_geg =_efge ._ca ._bbd ;};length =_geg -offset ;};return &Reader {_ca :readerSource {_dbd :_efge ._ca ._dbd ,_bbd :length ,_aabe :offset }},nil ;};func (_ab *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_eb :=int (_ab ._bfb )+skip ;if _eb >=0&&_eb < 8{_ab ._bfb =uint8 (_eb );return nil ;};_eb =int (_ab ._bfb )+_ab ._eg *8+skip ;if _eb < 0{return _f .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_abe :=_eb /8;_age :=_eb %8;_ab ._bfb =uint8 (_age );if _gg :=_abe -_ab ._eg ;_gg > 0&&len (_ab ._bg )-1< _abe {if _ab ._bfb !=0{_gg ++;};_ab .expandIfNeeded (_gg );};_ab ._eg =_abe ;return nil ;};func NewReader (data []byte )*Reader {return &Reader {_ca :readerSource {_dbd :data ,_bbd :len (data ),_aabe :0}};
};func (_bff *Writer )SkipBits (skip int )error {const _bbb ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_agef :=int (_bff ._cad )+skip ;if _agef >=0&&_agef < 8{_bff ._cad =uint8 (_agef );
return nil ;};_agef =int (_bff ._cad )+_bff ._dag *8+skip ;if _agef < 0{return _f .Errorf (_bbb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_gbf :=_agef /8;_ebe :=_agef %8;_bf .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_bf .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_bff ._cad ,_bff ._dag ,int (_bff ._cad )+(_bff ._dag )*8,len (_bff ._def ),cap (_bff ._def ));
_bf .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_agef ,_ebe );_bff ._cad =uint8 (_ebe );if _cgb :=_gbf -_bff ._dag ;
_cgb > 0&&len (_bff ._def )-1< _gbf {_bf .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_cgb );return _f .Errorf (_bbb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bff ._dag =_gbf ;
_bf .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_bff ._cad ,_bff ._dag );return nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_cc :true }};
func (_abf *Writer )writeByte (_bga byte )error {if _abf ._dag > len (_abf ._def )-1{return _e .EOF ;};if _abf ._dag ==len (_abf ._def )-1&&_abf ._cad !=0{return _e .EOF ;};if _abf ._cad ==0{_abf ._def [_abf ._dag ]=_bga ;_abf ._dag ++;return nil ;};if _abf ._fef {_abf ._def [_abf ._dag ]|=_bga >>_abf ._cad ;
_abf ._dag ++;_abf ._def [_abf ._dag ]=byte (uint16 (_bga )<<(8-_abf ._cad )&0xff);}else {_abf ._def [_abf ._dag ]|=byte (uint16 (_bga )<<_abf ._cad &0xff);_abf ._dag ++;_abf ._def [_abf ._dag ]=_bga >>(8-_abf ._cad );};return nil ;};func (_ef *BufferedWriter )fullOffset ()int {_gd :=_ef ._eg ;
if _ef ._bfb !=0{_gd ++;};return _gd ;};func (_bbda *Writer )WriteByte (c byte )error {return _bbda .writeByte (c )};func (_eae *Reader )readBufferByte ()(byte ,error ){if _eae ._adb >=int64 (_eae ._ca ._bbd ){return 0,_e .EOF ;};_eae ._bb =-1;_agb :=_eae ._ca ._dbd [int64 (_eae ._ca ._aabe )+_eae ._adb ];
_eae ._adb ++;_eae ._fca =int (_agb );return _agb ,nil ;};type Reader struct{_ca readerSource ;_ad byte ;_de byte ;_adb int64 ;_fca int ;_bb int ;_edg int64 ;_ddd byte ;_cd byte ;_egg int ;};func (_ccg *BufferedWriter )WriteByte (bt byte )error {if _ccg ._eg > len (_ccg ._bg )-1||(_ccg ._eg ==len (_ccg ._bg )-1&&_ccg ._bfb !=0){_ccg .expandIfNeeded (1);
};_ccg .writeByte (bt );return nil ;};const (_gc =64;_d =int (^uint (0)>>1););func (_af *BufferedWriter )Write (d []byte )(int ,error ){_af .expandIfNeeded (len (d ));if _af ._bfb ==0{return _af .writeFullBytes (d ),nil ;};return _af .writeShiftedBytes (d ),nil ;
};func (_gee *Reader )AbsolutePosition ()int64 {return _gee ._adb +int64 (_gee ._ca ._aabe )};var _ _e .ByteWriter =&BufferedWriter {};func (_bgd *BufferedWriter )byteCapacity ()int {_agd :=len (_bgd ._bg )-_bgd ._eg ;if _bgd ._bfb !=0{_agd --;};return _agd ;
};func (_deb *Reader )Reset (){_deb ._adb =_deb ._edg ;_deb ._de =_deb ._ddd ;_deb ._ad =_deb ._cd ;_deb ._fca =_deb ._egg ;};type BufferedWriter struct{_bg []byte ;_bfb uint8 ;_eg int ;_cc bool ;};func (_ccga *Reader )Mark (){_ccga ._edg =_ccga ._adb ;
_ccga ._ddd =_ccga ._de ;_ccga ._cd =_ccga ._ad ;_ccga ._egg =_ccga ._fca ;};func (_dcf *BufferedWriter )WriteBits (bits uint64 ,number int )(_fb int ,_aa error ){const _fd ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_f .Errorf (_fd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_fbe :=number /8;if _fbe > 0{_aab :=number -_fbe *8;for _df :=_fbe -1;_df >=0;_df --{_ecb :=byte ((bits >>uint (_df *8+_aab ))&0xff);if _aa =_dcf .WriteByte (_ecb );_aa !=nil {return _fb ,_f .Wrapf (_aa ,_fd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fbe -_df +1);
};};number -=_fbe *8;if number ==0{return _fbe ,nil ;};};var _ba int ;for _fe :=0;_fe < number ;_fe ++{if _dcf ._cc {_ba =int ((bits >>uint (number -1-_fe ))&0x1);}else {_ba =int (bits &0x1);bits >>=1;};if _aa =_dcf .WriteBit (_ba );_aa !=nil {return _fb ,_f .Wrapf (_aa ,_fd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_fe );
};};return _fbe ,nil ;};func (_dea *Reader )ReadByte ()(byte ,error ){if _dea ._de ==0{return _dea .readBufferByte ();};return _dea .readUnalignedByte ();};type readerSource struct{_dbd []byte ;_aabe int ;_bbd int ;};var _ BinaryWriter =&BufferedWriter {};
func (_agc *Writer )WriteBits (bits uint64 ,number int )(_gec int ,_cdd error ){const _dcca ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_f .Errorf (_dcca ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_gba :=number /8;if _gba > 0{_dda :=number -_gba *8;for _aeb :=_gba -1;_aeb >=0;_aeb --{_gaa :=byte ((bits >>uint (_aeb *8+_dda ))&0xff);if _cdd =_agc .WriteByte (_gaa );_cdd !=nil {return _gec ,_f .Wrapf (_cdd ,_dcca ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gba -_aeb +1);
};};number -=_gba *8;if number ==0{return _gba ,nil ;};};var _bge int ;for _ggc :=0;_ggc < number ;_ggc ++{if _agc ._fef {_bge =int ((bits >>uint (number -1-_ggc ))&0x1);}else {_bge =int (bits &0x1);bits >>=1;};if _cdd =_agc .WriteBit (_bge );_cdd !=nil {return _gec ,_f .Wrapf (_cdd ,_dcca ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ggc );
};};return _gba ,nil ;};func (_bed *Writer )UseMSB ()bool {return _bed ._fef };func (_gga *Reader )Length ()uint64 {return uint64 (_gga ._ca ._bbd )};func (_aee *Writer )writeBit (_daa uint8 )error {if len (_aee ._def )-1< _aee ._dag {return _e .EOF ;};
_adbd :=_aee ._cad ;if _aee ._fef {_adbd =7-_aee ._cad ;};_aee ._def [_aee ._dag ]|=byte (uint16 (_daa <<_adbd )&0xff);_aee ._cad ++;if _aee ._cad ==8{_aee ._dag ++;_aee ._cad =0;};return nil ;};type BinaryWriter interface{BitWriter ;_e .Writer ;_e .ByteWriter ;
Data ()[]byte ;};type BitWriter interface{WriteBit (_ecd int )error ;WriteBits (_ffb uint64 ,_cgc int )(_ecc int ,_gb error );FinishByte ();SkipBits (_dfb int )error ;};var _ BinaryWriter =&Writer {};func (_gfc *Writer )Data ()[]byte {return _gfc ._def };
func (_cb *BufferedWriter )tryGrowByReslice (_ac int )bool {if _cg :=len (_cb ._bg );_ac <=cap (_cb ._bg )-_cg {_cb ._bg =_cb ._bg [:_cg +_ac ];return true ;};return false ;};