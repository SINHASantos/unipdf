//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_b "encoding/binary";_gb "errors";_ca "fmt";_bg "github.com/unidoc/unipdf/v3/common";_gc "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_g "io";);func (_caf *Reader )AbsoluteLength ()uint64 {return uint64 (len (_caf ._fgd ._ccc ))};
type StreamReader interface{_g .Reader ;_g .ByteReader ;_g .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_ddf byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();
AbsolutePosition ()int64 ;};func (_bge *Writer )UseMSB ()bool {return _bge ._bgc };var _ BinaryWriter =&BufferedWriter {};func (_ebf *BufferedWriter )writeShiftedBytes (_ba []byte )int {for _ ,_bbe :=range _ba {_ebf .writeByte (_bbe );};return len (_ba );
};func (_ecd *Writer )writeBit (_gac uint8 )error {if len (_ecd ._ed )-1< _ecd ._ebb {return _g .EOF ;};_bdc :=_ecd ._cbb ;if _ecd ._bgc {_bdc =7-_ecd ._cbb ;};_ecd ._ed [_ecd ._ebb ]|=byte (uint16 (_gac <<_bdc )&0xff);_ecd ._cbb ++;if _ecd ._cbb ==8{_ecd ._ebb ++;
_ecd ._cbb =0;};return nil ;};func (_ecb *BufferedWriter )writeFullBytes (_dbe []byte )int {_ga :=copy (_ecb ._a [_ecb .fullOffset ():],_dbe );_ecb ._cf +=_ga ;return _ga ;};func (_bce *BufferedWriter )FinishByte (){if _bce ._gcd ==0{return ;};_bce ._gcd =0;
_bce ._cf ++;};func (_bcg *Reader )read (_ffd []byte )(int ,error ){if _bcg ._egab >=int64 (_bcg ._fgd ._eggb ){return 0,_g .EOF ;};_bcg ._cde =-1;_beeg :=copy (_ffd ,_bcg ._fgd ._ccc [(int64 (_bcg ._fgd ._fb )+_bcg ._egab ):(_bcg ._fgd ._fb +_bcg ._fgd ._eggb )]);
_bcg ._egab +=int64 (_beeg );return _beeg ,nil ;};func (_aac *Reader )Align ()(_bab byte ){_bab =_aac ._cfgf ;_aac ._cfgf =0;return _bab };func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_bc :true }};func (_caad *Writer )WriteByte (c byte )error {return _caad .writeByte (c )};
func (_bfb *Reader )ReadByte ()(byte ,error ){if _bfb ._cfgf ==0{return _bfb .readBufferByte ();};return _bfb .readUnalignedByte ();};func (_cba *BufferedWriter )tryGrowByReslice (_egf int )bool {if _ab :=len (_cba ._a );_egf <=cap (_cba ._a )-_ab {_cba ._a =_cba ._a [:_ab +_egf ];
return true ;};return false ;};func (_bbc *Reader )Mark (){_bbc ._caa =_bbc ._egab ;_bbc ._ceba =_bbc ._cfgf ;_bbc ._dgg =_bbc ._fe ;_bbc ._ebe =_bbc ._bbd ;};func (_faa *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _faa ._cfgf !=0{return _faa .ReadBits (_faa ._cfgf );
};return 0,nil ;};func (_gbc *BufferedWriter )Write (d []byte )(int ,error ){_gbc .expandIfNeeded (len (d ));if _gbc ._gcd ==0{return _gbc .writeFullBytes (d ),nil ;};return _gbc .writeShiftedBytes (d ),nil ;};var (_ _g .Reader =&Reader {};_ _g .ByteReader =&Reader {};
_ _g .Seeker =&Reader {};_ StreamReader =&Reader {};);func NewReader (data []byte )*Reader {return &Reader {_fgd :readerSource {_ccc :data ,_eggb :len (data ),_fb :0}};};func (_gcc *BufferedWriter )grow (_cag int ){if _gcc ._a ==nil &&_cag < _cc {_gcc ._a =make ([]byte ,_cag ,_cc );
return ;};_df :=len (_gcc ._a );if _gcc ._gcd !=0{_df ++;};_cb :=cap (_gcc ._a );switch {case _cag <=_cb /2-_df :_bg .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_gcc ._a ),cap (_gcc ._a ),_cag );
_bg .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_cb ,_df );copy (_gcc ._a ,_gcc ._a [_gcc .fullOffset ():]);
case _cb > _f -_cb -_cag :_bg .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ag :=make ([]byte ,2*_cb +_cag );copy (_ag ,_gcc ._a );_gcc ._a =_ag ;};_gcc ._a =_gcc ._a [:_df +_cag ];
};func (_eggd *Reader )ReadBits (n byte )(_ccgb uint64 ,_cbe error ){if n < _eggd ._cfgf {_cbd :=_eggd ._cfgf -n ;_ccgb =uint64 (_eggd ._fe >>_cbd );_eggd ._fe &=1<<_cbd -1;_eggd ._cfgf =_cbd ;return _ccgb ,nil ;};if n > _eggd ._cfgf {if _eggd ._cfgf > 0{_ccgb =uint64 (_eggd ._fe );
n -=_eggd ._cfgf ;};for n >=8{_ccgf ,_gad :=_eggd .readBufferByte ();if _gad !=nil {return 0,_gad ;};_ccgb =_ccgb <<8+uint64 (_ccgf );n -=8;};if n > 0{if _eggd ._fe ,_cbe =_eggd .readBufferByte ();_cbe !=nil {return 0,_cbe ;};_be :=8-n ;_ccgb =_ccgb <<n +uint64 (_eggd ._fe >>_be );
_eggd ._fe &=1<<_be -1;_eggd ._cfgf =_be ;}else {_eggd ._cfgf =0;};return _ccgb ,nil ;};_eggd ._cfgf =0;return uint64 (_eggd ._fe ),nil ;};type BinaryWriter interface{BitWriter ;_g .Writer ;_g .ByteWriter ;Data ()[]byte ;};func (_baf *Writer )Write (p []byte )(int ,error ){if len (p )> _baf .byteCapacity (){return 0,_g .EOF ;
};for _ ,_gea :=range p {if _gdf :=_baf .writeByte (_gea );_gdf !=nil {return 0,_gdf ;};};return len (p ),nil ;};func (_ccg *Reader )BitPosition ()int {return int (_ccg ._cfgf )};func (_eae *Reader )readUnalignedByte ()(_dcg byte ,_gbcg error ){_bea :=_eae ._cfgf ;
_dcg =_eae ._fe <<(8-_bea );_eae ._fe ,_gbcg =_eae .readBufferByte ();if _gbcg !=nil {return 0,_gbcg ;};_dcg |=_eae ._fe >>_bea ;_eae ._fe &=1<<_bea -1;return _dcg ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_ed :data }};var _ BinaryWriter =&Writer {};
func (_gbcc *BufferedWriter )WriteByte (bt byte )error {if _gbcc ._cf > len (_gbcc ._a )-1||(_gbcc ._cf ==len (_gbcc ._a )-1&&_gbcc ._gcd !=0){_gbcc .expandIfNeeded (1);};_gbcc .writeByte (bt );return nil ;};func (_abe *Reader )Read (p []byte )(_babe int ,_dff error ){if _abe ._cfgf ==0{return _abe .read (p );
};for ;_babe < len (p );_babe ++{if p [_babe ],_dff =_abe .readUnalignedByte ();_dff !=nil {return 0,_dff ;};};return _babe ,nil ;};type Writer struct{_ed []byte ;_cbb uint8 ;_ebb int ;_bgc bool ;};func (_bd *Reader )AbsolutePosition ()int64 {return _bd ._egab +int64 (_bd ._fgd ._fb )};
var _ _g .ByteWriter =&BufferedWriter {};const (_cc =64;_f =int (^uint (0)>>1););func NewWriterMSB (data []byte )*Writer {return &Writer {_ed :data ,_bgc :true }};func (_dc *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_gb .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_dc ._fgd ._fb +offset ;};if length > 0{_fda :=len (_dc ._fgd ._ccc );if relative {_fda =_dc ._fgd ._eggb ;};if offset +length > _fda {return nil ,_ca .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_dc ._fgd ._eggb );
};};if length < 0{_aa :=len (_dc ._fgd ._ccc );if relative {_aa =_dc ._fgd ._eggb ;};length =_aa -offset ;};return &Reader {_fgd :readerSource {_ccc :_dc ._fgd ._ccc ,_eggb :length ,_fb :offset }},nil ;};func (_fcc *Reader )readBufferByte ()(byte ,error ){if _fcc ._egab >=int64 (_fcc ._fgd ._eggb ){return 0,_g .EOF ;
};_fcc ._cde =-1;_fcb :=_fcc ._fgd ._ccc [int64 (_fcc ._fgd ._fb )+_fcc ._egab ];_fcc ._egab ++;_fcc ._bbd =int (_fcb );return _fcb ,nil ;};var _ _g .Writer =&BufferedWriter {};func (_bba *Reader )ReadUint32 ()(uint32 ,error ){_ee :=make ([]byte ,4);_ ,_gdd :=_bba .Read (_ee );
if _gdd !=nil {return 0,_gdd ;};return _b .BigEndian .Uint32 (_ee ),nil ;};func (_cga *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_cga ._cde =-1;_cga ._cfgf =0;_cga ._fe =0;_cga ._bbd =0;var _bcae int64 ;switch whence {case _g .SeekStart :_bcae =offset ;
case _g .SeekCurrent :_bcae =_cga ._egab +offset ;case _g .SeekEnd :_bcae =int64 (_cga ._fgd ._eggb )+offset ;default:return 0,_gb .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _bcae < 0{return 0,_gb .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_cga ._egab =_bcae ;
_cga ._cfgf =0;return _bcae ,nil ;};func (_bcb *Reader )ReadBit ()(_gee int ,_gda error ){_de ,_gda :=_bcb .readBool ();if _gda !=nil {return 0,_gda ;};if _de {_gee =1;};return _gee ,nil ;};type readerSource struct{_ccc []byte ;_fb int ;_eggb int ;};func (_fc *Reader )ReadBool ()(bool ,error ){return _fc .readBool ()};
func (_cd *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _gc .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_cd ._a )-1< _cd ._cf {_cd .expandIfNeeded (1);};_fd :=_cd ._gcd ;if _cd ._bc {_fd =7-_cd ._gcd ;};_cd ._a [_cd ._cf ]|=byte (uint16 (bit <<_fd )&0xff);_cd ._gcd ++;if _cd ._gcd ==8{_cd ._cf ++;_cd ._gcd =0;};return nil ;};func (_gag *Writer )ResetBit (){_gag ._cbb =0};
func (_fac *Writer )WriteBits (bits uint64 ,number int )(_caab int ,_bcea error ){const _ead ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_gc .Errorf (_ead ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_cef :=number /8;if _cef > 0{_fdc :=number -_cef *8;for _dbdc :=_cef -1;_dbdc >=0;_dbdc --{_dee :=byte ((bits >>uint (_dbdc *8+_fdc ))&0xff);if _bcea =_fac .WriteByte (_dee );_bcea !=nil {return _caab ,_gc .Wrapf (_bcea ,_ead ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cef -_dbdc +1);
};};number -=_cef *8;if number ==0{return _cef ,nil ;};};var _dgd int ;for _dab :=0;_dab < number ;_dab ++{if _fac ._bgc {_dgd =int ((bits >>uint (number -1-_dab ))&0x1);}else {_dgd =int (bits &0x1);bits >>=1;};if _bcea =_fac .WriteBit (_dgd );_bcea !=nil {return _caab ,_gc .Wrapf (_bcea ,_ead ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dab );
};};return _cef ,nil ;};type BitWriter interface{WriteBit (_cg int )error ;WriteBits (_ega uint64 ,_cgc int )(_bfe int ,_ffa error );FinishByte ();SkipBits (_abd int )error ;};func (_ec *BufferedWriter )WriteBits (bits uint64 ,number int )(_gf int ,_af error ){const _bb ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_gc .Errorf (_bb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_ce :=number /8;if _ce > 0{_adc :=number -_ce *8;for _fa :=_ce -1;_fa >=0;_fa --{_da :=byte ((bits >>uint (_fa *8+_adc ))&0xff);if _af =_ec .WriteByte (_da );_af !=nil {return _gf ,_gc .Wrapf (_af ,_bb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ce -_fa +1);
};};number -=_ce *8;if number ==0{return _ce ,nil ;};};var _ceb int ;for _egg :=0;_egg < number ;_egg ++{if _ec ._bc {_ceb =int ((bits >>uint (number -1-_egg ))&0x1);}else {_ceb =int (bits &0x1);bits >>=1;};if _af =_ec .WriteBit (_ceb );_af !=nil {return _gf ,_gc .Wrapf (_af ,_bb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_egg );
};};return _ce ,nil ;};func (_ff *BufferedWriter )fullOffset ()int {_fdb :=_ff ._cf ;if _ff ._gcd !=0{_fdb ++;};return _fdb ;};func (_dag *BufferedWriter )byteCapacity ()int {_eca :=len (_dag ._a )-_dag ._cf ;if _dag ._gcd !=0{_eca --;};return _eca ;};
func (_ddc *Reader )readBool ()(_def bool ,_fdeb error ){if _ddc ._cfgf ==0{_ddc ._fe ,_fdeb =_ddc .readBufferByte ();if _fdeb !=nil {return false ,_fdeb ;};_def =(_ddc ._fe &0x80)!=0;_ddc ._fe ,_ddc ._cfgf =_ddc ._fe &0x7f,7;return _def ,nil ;};_ddc ._cfgf --;
_def =(_ddc ._fe &(1<<_ddc ._cfgf ))!=0;_ddc ._fe &=1<<_ddc ._cfgf -1;return _def ,nil ;};func (_bf *BufferedWriter )Reset (){_bf ._a =_bf ._a [:0];_bf ._cf =0;_bf ._gcd =0};func (_abf *Writer )SkipBits (skip int )error {const _gcf ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_bed :=int (_abf ._cbb )+skip ;if _bed >=0&&_bed < 8{_abf ._cbb =uint8 (_bed );return nil ;};_bed =int (_abf ._cbb )+_abf ._ebb *8+skip ;if _bed < 0{return _gc .Errorf (_gcf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gbb :=_bed /8;_eag :=_bed %8;_bg .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_bg .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_abf ._cbb ,_abf ._ebb ,int (_abf ._cbb )+(_abf ._ebb )*8,len (_abf ._ed ),cap (_abf ._ed ));
_bg .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_bed ,_eag );_abf ._cbb =uint8 (_eag );if _eda :=_gbb -_abf ._ebb ;
_eda > 0&&len (_abf ._ed )-1< _gbb {_bg .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_eda );return _gc .Errorf (_gcf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_abf ._ebb =_gbb ;
_bg .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_abf ._cbb ,_abf ._ebb );return nil ;};type BufferedWriter struct{_a []byte ;
_gcd uint8 ;_cf int ;_bc bool ;};func (_adg *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_dg :=int (_adg ._gcd )+skip ;if _dg >=0&&_dg < 8{_adg ._gcd =uint8 (_dg );return nil ;};_dg =int (_adg ._gcd )+_adg ._cf *8+skip ;if _dg < 0{return _gc .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_eb :=_dg /8;_db :=_dg %8;_adg ._gcd =uint8 (_db );if _eg :=_eb -_adg ._cf ;_eg > 0&&len (_adg ._a )-1< _eb {if _adg ._gcd !=0{_eg ++;};_adg .expandIfNeeded (_eg );};_adg ._cf =_eb ;return nil ;};type Reader struct{_fgd readerSource ;_fe byte ;_cfgf byte ;
_egab int64 ;_bbd int ;_cde int ;_caa int64 ;_ceba byte ;_dgg byte ;_ebe int ;};func (_fad *Writer )Data ()[]byte {return _fad ._ed };func (_ffc *Writer )writeByte (_dfb byte )error {if _ffc ._ebb > len (_ffc ._ed )-1{return _g .EOF ;};if _ffc ._ebb ==len (_ffc ._ed )-1&&_ffc ._cbb !=0{return _g .EOF ;
};if _ffc ._cbb ==0{_ffc ._ed [_ffc ._ebb ]=_dfb ;_ffc ._ebb ++;return nil ;};if _ffc ._bgc {_ffc ._ed [_ffc ._ebb ]|=_dfb >>_ffc ._cbb ;_ffc ._ebb ++;_ffc ._ed [_ffc ._ebb ]=byte (uint16 (_dfb )<<(8-_ffc ._cbb )&0xff);}else {_ffc ._ed [_ffc ._ebb ]|=byte (uint16 (_dfb )<<_ffc ._cbb &0xff);
_ffc ._ebb ++;_ffc ._ed [_ffc ._ebb ]=_dfb >>(8-_ffc ._cbb );};return nil ;};func (_geg *Reader )RelativePosition ()int64 {return _geg ._egab };func (_d *BufferedWriter )ResetBitIndex (){_d ._gcd =0};func (_gd *BufferedWriter )Data ()[]byte {return _gd ._a };
func (_cgd *Writer )byteCapacity ()int {_ebg :=len (_cgd ._ed )-_cgd ._ebb ;if _cgd ._cbb !=0{_ebg --;};return _ebg ;};func (_bcf *BufferedWriter )expandIfNeeded (_ea int ){if !_bcf .tryGrowByReslice (_ea ){_bcf .grow (_ea );};};func (_dd *BufferedWriter )writeByte (_fde byte ){switch {case _dd ._gcd ==0:_dd ._a [_dd ._cf ]=_fde ;
_dd ._cf ++;case _dd ._bc :_dd ._a [_dd ._cf ]|=_fde >>_dd ._gcd ;_dd ._cf ++;_dd ._a [_dd ._cf ]=byte (uint16 (_fde )<<(8-_dd ._gcd )&0xff);default:_dd ._a [_dd ._cf ]|=byte (uint16 (_fde )<<_dd ._gcd &0xff);_dd ._cf ++;_dd ._a [_dd ._cf ]=_fde >>(8-_dd ._gcd );
};};func (_fab *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _fab .writeBit (uint8 (bit ));};return _gc .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_bee *Reader )Reset (){_bee ._egab =_bee ._caa ;_bee ._cfgf =_bee ._ceba ;_bee ._fe =_bee ._dgg ;_bee ._bbd =_bee ._ebe ;};func (_ge *Reader )Length ()uint64 {return uint64 (_ge ._fgd ._eggb )};func (_fbg *Writer )FinishByte (){if _fbg ._cbb ==0{return ;
};_fbg ._cbb =0;_fbg ._ebb ++;};func (_ad *BufferedWriter )Len ()int {return _ad .byteCapacity ()};