//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_gf "encoding/binary";_c "errors";_b "fmt";_d "github.com/unidoc/unipdf/v3/common";_gc "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_g "io";);func (_bf *BufferedWriter )FinishByte (){if _bf ._cg ==0{return ;};_bf ._cg =0;
_bf ._e ++;};func (_eda *Reader )BitPosition ()int {return int (_eda ._fg )};func (_ad *BufferedWriter )Len ()int {return _ad .byteCapacity ()};func (_eef *Writer )SkipBits (skip int )error {const _fgge ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_adag :=int (_eef ._fgd )+skip ;if _adag >=0&&_adag < 8{_eef ._fgd =uint8 (_adag );return nil ;};_adag =int (_eef ._fgd )+_eef ._bdc *8+skip ;if _adag < 0{return _gc .Errorf (_fgge ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bgbb :=_adag /8;_efd :=_adag %8;_d .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_d .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_eef ._fgd ,_eef ._bdc ,int (_eef ._fgd )+(_eef ._bdc )*8,len (_eef ._afa ),cap (_eef ._afa ));
_d .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_adag ,_efd );_eef ._fgd =uint8 (_efd );if _dga :=_bgbb -_eef ._bdc ;
_dga > 0&&len (_eef ._afa )-1< _bgbb {_d .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_dga );return _gc .Errorf (_fgge ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_eef ._bdc =_bgbb ;_d .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_eef ._fgd ,_eef ._bdc );return nil ;};var (_ _g .Reader =&Reader {};
_ _g .ByteReader =&Reader {};_ _g .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_ccaf *Reader )Align ()(_aad byte ){_aad =_ccaf ._fg ;_ccaf ._fg =0;return _aad };func (_ed *BufferedWriter )ResetBitIndex (){_ed ._cg =0};func (_aac *Reader )Reset (){_aac ._ag =_aac ._bef ;
_aac ._fg =_aac ._gga ;_aac ._eec =_aac ._fe ;_aac ._eca =_aac ._baa ;};func (_fba *BufferedWriter )byteCapacity ()int {_cff :=len (_fba ._cb )-_fba ._e ;if _fba ._cg !=0{_cff --;};return _cff ;};func (_dgg *BufferedWriter )fullOffset ()int {_gb :=_dgg ._e ;
if _dgg ._cg !=0{_gb ++;};return _gb ;};func (_bbc *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _bbc .writeBit (uint8 (bit ));};return _gc .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_fgg *Writer )Data ()[]byte {return _fgg ._afa };var _ BinaryWriter =&BufferedWriter {};func (_cdcb *BufferedWriter )writeFullBytes (_gd []byte )int {_eb :=copy (_cdcb ._cb [_cdcb .fullOffset ():],_gd );_cdcb ._e +=_eb ;return _eb ;};func (_gba *BufferedWriter )grow (_ef int ){if _gba ._cb ==nil &&_ef < _de {_gba ._cb =make ([]byte ,_ef ,_de );
return ;};_ggf :=len (_gba ._cb );if _gba ._cg !=0{_ggf ++;};_df :=cap (_gba ._cb );switch {case _ef <=_df /2-_ggf :_d .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_gba ._cb ),cap (_gba ._cb ),_ef );
_d .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_df ,_ggf );copy (_gba ._cb ,_gba ._cb [_gba .fullOffset ():]);
case _df > _f -_df -_ef :_d .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_acf :=make ([]byte ,2*_df +_ef );copy (_acf ,_gba ._cb );_gba ._cb =_acf ;};_gba ._cb =_gba ._cb [:_ggf +_ef ];
};func (_beaf *Reader )Read (p []byte )(_dfea int ,_fbb error ){if _beaf ._fg ==0{return _beaf .read (p );};for ;_dfea < len (p );_dfea ++{if p [_dfea ],_fbb =_beaf .readUnalignedByte ();_fbb !=nil {return 0,_fbb ;};};return _dfea ,nil ;};func (_bgfa *Reader )RelativePosition ()int64 {return _bgfa ._ag };
func (_eefe *Writer )byteCapacity ()int {_cffd :=len (_eefe ._afa )-_eefe ._bdc ;if _eefe ._fgd !=0{_cffd --;};return _cffd ;};type BinaryWriter interface{BitWriter ;_g .Writer ;_g .ByteWriter ;Data ()[]byte ;};func (_bbe *BufferedWriter )expandIfNeeded (_cc int ){if !_bbe .tryGrowByReslice (_cc ){_bbe .grow (_cc );
};};func (_ecdd *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _ecdd ._fg !=0{return _ecdd .ReadBits (_ecdd ._fg );};return 0,nil ;};func (_dfe *Reader )AbsoluteLength ()uint64 {return uint64 (len (_dfe ._bcg ._ecab ))};func (_bfb *Writer )ResetBit (){_bfb ._fgd =0};
func (_ab *BufferedWriter )Data ()[]byte {return _ab ._cb };func (_aa *BufferedWriter )writeShiftedBytes (_bg []byte )int {for _ ,_bd :=range _bg {_aa .writeByte (_bd );};return len (_bg );};func (_ee *BufferedWriter )Write (d []byte )(int ,error ){_ee .expandIfNeeded (len (d ));
if _ee ._cg ==0{return _ee .writeFullBytes (d ),nil ;};return _ee .writeShiftedBytes (d ),nil ;};var _ _g .Writer =&BufferedWriter {};type Writer struct{_afa []byte ;_fgd uint8 ;_bdc int ;_ccg bool ;};func NewReader (data []byte )*Reader {return &Reader {_bcg :readerSource {_ecab :data ,_bea :len (data ),_af :0}};
};func (_ada *Reader )AbsolutePosition ()int64 {return _ada ._ag +int64 (_ada ._bcg ._af )};func (_cad *Reader )Length ()uint64 {return uint64 (_cad ._bcg ._bea )};func (_aeb *Reader )ReadBit ()(_aff int ,_fef error ){_dfg ,_fef :=_aeb .readBool ();if _fef !=nil {return 0,_fef ;
};if _dfg {_aff =1;};return _aff ,nil ;};func (_gab *Writer )WriteByte (c byte )error {return _gab .writeByte (c )};func (_egd *Reader )readBufferByte ()(byte ,error ){if _egd ._ag >=int64 (_egd ._bcg ._bea ){return 0,_g .EOF ;};_egd ._ecd =-1;_bad :=_egd ._bcg ._ecab [int64 (_egd ._bcg ._af )+_egd ._ag ];
_egd ._ag ++;_egd ._eca =int (_bad );return _bad ,nil ;};func (_acg *Reader )read (_fgf []byte )(int ,error ){if _acg ._ag >=int64 (_acg ._bcg ._bea ){return 0,_g .EOF ;};_acg ._ecd =-1;_cda :=copy (_fgf ,_acg ._bcg ._ecab [(int64 (_acg ._bcg ._af )+_acg ._ag ):(_acg ._bcg ._af +_acg ._bcg ._bea )]);
_acg ._ag +=int64 (_cda );return _cda ,nil ;};func (_daa *Reader )ReadBits (n byte )(_ccc uint64 ,_bgd error ){if n < _daa ._fg {_bgf :=_daa ._fg -n ;_ccc =uint64 (_daa ._eec >>_bgf );_daa ._eec &=1<<_bgf -1;_daa ._fg =_bgf ;return _ccc ,nil ;};if n > _daa ._fg {if _daa ._fg > 0{_ccc =uint64 (_daa ._eec );
n -=_daa ._fg ;};for n >=8{_ccf ,_aee :=_daa .readBufferByte ();if _aee !=nil {return 0,_aee ;};_ccc =_ccc <<8+uint64 (_ccf );n -=8;};if n > 0{if _daa ._eec ,_bgd =_daa .readBufferByte ();_bgd !=nil {return 0,_bgd ;};_egg :=8-n ;_ccc =_ccc <<n +uint64 (_daa ._eec >>_egg );
_daa ._eec &=1<<_egg -1;_daa ._fg =_egg ;}else {_daa ._fg =0;};return _ccc ,nil ;};_daa ._fg =0;return uint64 (_daa ._eec ),nil ;};func (_da *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ac :=int (_da ._cg )+skip ;if _ac >=0&&_ac < 8{_da ._cg =uint8 (_ac );
return nil ;};_ac =int (_da ._cg )+_da ._e *8+skip ;if _ac < 0{return _gc .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_adc :=_ac /8;_db :=_ac %8;_da ._cg =uint8 (_db );if _fb :=_adc -_da ._e ;_fb > 0&&len (_da ._cb )-1< _adc {if _da ._cg !=0{_fb ++;};_da .expandIfNeeded (_fb );};_da ._e =_adc ;return nil ;};func (_fgff *Writer )Write (p []byte )(int ,error ){if len (p )> _fgff .byteCapacity (){return 0,_g .EOF ;
};for _ ,_ff :=range p {if _afb :=_fgff .writeByte (_ff );_afb !=nil {return 0,_afb ;};};return len (p ),nil ;};func (_efg *Reader )readBool ()(_fab bool ,_fbc error ){if _efg ._fg ==0{_efg ._eec ,_fbc =_efg .readBufferByte ();if _fbc !=nil {return false ,_fbc ;
};_fab =(_efg ._eec &0x80)!=0;_efg ._eec ,_efg ._fg =_efg ._eec &0x7f,7;return _fab ,nil ;};_efg ._fg --;_fab =(_efg ._eec &(1<<_efg ._fg ))!=0;_efg ._eec &=1<<_efg ._fg -1;return _fab ,nil ;};func (_gcce *Writer )WriteBits (bits uint64 ,number int )(_faa int ,_bff error ){const _gbf ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_gc .Errorf (_gbf ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_aag :=number /8;if _aag > 0{_eecg :=number -_aag *8;for _aec :=_aag -1;_aec >=0;_aec --{_ege :=byte ((bits >>uint (_aec *8+_eecg ))&0xff);if _bff =_gcce .WriteByte (_ege );_bff !=nil {return _faa ,_gc .Wrapf (_bff ,_gbf ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_aag -_aec +1);
};};number -=_aag *8;if number ==0{return _aag ,nil ;};};var _edc int ;for _aagd :=0;_aagd < number ;_aagd ++{if _gcce ._ccg {_edc =int ((bits >>uint (number -1-_aagd ))&0x1);}else {_edc =int (bits &0x1);bits >>=1;};if _bff =_gcce .WriteBit (_edc );_bff !=nil {return _faa ,_gc .Wrapf (_bff ,_gbf ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_aagd );
};};return _aag ,nil ;};func (_cfe *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_cfe ._ecd =-1;_cfe ._fg =0;_cfe ._eec =0;_cfe ._eca =0;var _adcg int64 ;switch whence {case _g .SeekStart :_adcg =offset ;case _g .SeekCurrent :_adcg =_cfe ._ag +offset ;
case _g .SeekEnd :_adcg =int64 (_cfe ._bcg ._bea )+offset ;default:return 0,_c .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _adcg < 0{return 0,_c .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_cfe ._ag =_adcg ;
_cfe ._fg =0;return _adcg ,nil ;};func (_gcc *BufferedWriter )Reset (){_gcc ._cb =_gcc ._cb [:0];_gcc ._e =0;_gcc ._cg =0};func (_aebg *Writer )FinishByte (){if _aebg ._fgd ==0{return ;};_aebg ._fgd =0;_aebg ._bdc ++;};func NewWriterMSB (data []byte )*Writer {return &Writer {_afa :data ,_ccg :true }};
func (_geg *Writer )writeBit (_cgf uint8 )error {if len (_geg ._afa )-1< _geg ._bdc {return _g .EOF ;};_bgc :=_geg ._fgd ;if _geg ._ccg {_bgc =7-_geg ._fgd ;};_geg ._afa [_geg ._bdc ]|=byte (uint16 (_cgf <<_bgc )&0xff);_geg ._fgd ++;if _geg ._fgd ==8{_geg ._bdc ++;
_geg ._fgd =0;};return nil ;};func (_cd *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _gc .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_cd ._cb )-1< _cd ._e {_cd .expandIfNeeded (1);};_be :=_cd ._cg ;if _cd ._dg {_be =7-_cd ._cg ;};_cd ._cb [_cd ._e ]|=byte (uint16 (bit <<_be )&0xff);_cd ._cg ++;if _cd ._cg ==8{_cd ._e ++;_cd ._cg =0;};return nil ;};func (_aae *BufferedWriter )tryGrowByReslice (_ec int )bool {if _ga :=len (_aae ._cb );
_ec <=cap (_aae ._cb )-_ga {_aae ._cb =_aae ._cb [:_ga +_ec ];return true ;};return false ;};type BitWriter interface{WriteBit (_cbg int )error ;WriteBits (_gdf uint64 ,_cbb int )(_ae int ,_dce error );FinishByte ();SkipBits (_edg int )error ;};func (_ebb *Reader )readUnalignedByte ()(_deb byte ,_afc error ){_cag :=_ebb ._fg ;
_deb =_ebb ._eec <<(8-_cag );_ebb ._eec ,_afc =_ebb .readBufferByte ();if _afc !=nil {return 0,_afc ;};_deb |=_ebb ._eec >>_cag ;_ebb ._eec &=1<<_cag -1;return _deb ,nil ;};var _ _g .ByteWriter =&BufferedWriter {};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_dg :true }};
type Reader struct{_bcg readerSource ;_eec byte ;_fg byte ;_ag int64 ;_eca int ;_ecd int ;_bef int64 ;_gga byte ;_fe byte ;_baa int ;};const (_de =64;_f =int (^uint (0)>>1););type BufferedWriter struct{_cb []byte ;_cg uint8 ;_e int ;_dg bool ;};func NewWriter (data []byte )*Writer {return &Writer {_afa :data }};
func (_adb *Writer )writeByte (_cea byte )error {if _adb ._bdc > len (_adb ._afa )-1{return _g .EOF ;};if _adb ._bdc ==len (_adb ._afa )-1&&_adb ._fgd !=0{return _g .EOF ;};if _adb ._fgd ==0{_adb ._afa [_adb ._bdc ]=_cea ;_adb ._bdc ++;return nil ;};if _adb ._ccg {_adb ._afa [_adb ._bdc ]|=_cea >>_adb ._fgd ;
_adb ._bdc ++;_adb ._afa [_adb ._bdc ]=byte (uint16 (_cea )<<(8-_adb ._fgd )&0xff);}else {_adb ._afa [_adb ._bdc ]|=byte (uint16 (_cea )<<_adb ._fgd &0xff);_adb ._bdc ++;_adb ._afa [_adb ._bdc ]=_cea >>(8-_adb ._fgd );};return nil ;};func (_dd *Writer )UseMSB ()bool {return _dd ._ccg };
type readerSource struct{_ecab []byte ;_af int ;_bea int ;};type StreamReader interface{_g .Reader ;_g .ByteReader ;_g .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_gae byte )(uint64 ,error );ReadBool ()(bool ,error );
ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_cfdf *Reader )Mark (){_cfdf ._bef =_cfdf ._ag ;_cfdf ._gga =_cfdf ._fg ;_cfdf ._fe =_cfdf ._eec ;_cfdf ._baa =_cfdf ._eca ;};func (_cce *Reader )ReadBool ()(bool ,error ){return _cce .readBool ()};
func (_bb *BufferedWriter )WriteBits (bits uint64 ,number int )(_ca int ,_gg error ){const _fc ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_gc .Errorf (_fc ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_fa :=number /8;if _fa > 0{_ea :=number -_fa *8;for _cf :=_fa -1;_cf >=0;_cf --{_eg :=byte ((bits >>uint (_cf *8+_ea ))&0xff);if _gg =_bb .WriteByte (_eg );_gg !=nil {return _ca ,_gc .Wrapf (_gg ,_fc ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fa -_cf +1);
};};number -=_fa *8;if number ==0{return _fa ,nil ;};};var _cfd int ;for _cdc :=0;_cdc < number ;_cdc ++{if _bb ._dg {_cfd =int ((bits >>uint (number -1-_cdc ))&0x1);}else {_cfd =int (bits &0x1);bits >>=1;};if _gg =_bb .WriteBit (_cfd );_gg !=nil {return _ca ,_gc .Wrapf (_gg ,_fc ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cdc );
};};return _fa ,nil ;};func (_ce *BufferedWriter )writeByte (_dfa byte ){switch {case _ce ._cg ==0:_ce ._cb [_ce ._e ]=_dfa ;_ce ._e ++;case _ce ._dg :_ce ._cb [_ce ._e ]|=_dfa >>_ce ._cg ;_ce ._e ++;_ce ._cb [_ce ._e ]=byte (uint16 (_dfa )<<(8-_ce ._cg )&0xff);
default:_ce ._cb [_ce ._e ]|=byte (uint16 (_dfa )<<_ce ._cg &0xff);_ce ._e ++;_ce ._cb [_ce ._e ]=_dfa >>(8-_ce ._cg );};};func (_dcf *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_c .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_dcf ._bcg ._af +offset ;};if length > 0{_dee :=len (_dcf ._bcg ._ecab );if relative {_dee =_dcf ._bcg ._bea ;};if offset +length > _dee {return nil ,_b .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_dcf ._bcg ._bea );
};};if length < 0{_bga :=len (_dcf ._bcg ._ecab );if relative {_bga =_dcf ._bcg ._bea ;};length =_bga -offset ;};return &Reader {_bcg :readerSource {_ecab :_dcf ._bcg ._ecab ,_bea :length ,_af :offset }},nil ;};func (_ba *BufferedWriter )WriteByte (bt byte )error {if _ba ._e > len (_ba ._cb )-1||(_ba ._e ==len (_ba ._cb )-1&&_ba ._cg !=0){_ba .expandIfNeeded (1);
};_ba .writeByte (bt );return nil ;};var _ BinaryWriter =&Writer {};func (_bae *Reader )ReadUint32 ()(uint32 ,error ){_ge :=make ([]byte ,4);_ ,_dbe :=_bae .Read (_ge );if _dbe !=nil {return 0,_dbe ;};return _gf .BigEndian .Uint32 (_ge ),nil ;};func (_acb *Reader )ReadByte ()(byte ,error ){if _acb ._fg ==0{return _acb .readBufferByte ();
};return _acb .readUnalignedByte ();};