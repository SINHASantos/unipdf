//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_f "encoding/binary";_g "errors";_ec "fmt";_ff "github.com/unidoc/unipdf/v4/common";_dd "github.com/unidoc/unipdf/v4/internal/jbig2/errors";_d "io";);const (_ecc =64;_c =int (^uint (0)>>1););var _ BinaryWriter =&Writer {};func (_cdf *BufferedWriter )Write (d []byte )(int ,error ){_cdf .expandIfNeeded (len (d ));
if _cdf ._b ==0{return _cdf .writeFullBytes (d ),nil ;};return _cdf .writeShiftedBytes (d ),nil ;};func (_bg *Reader )Reset (){_bg ._fde =_bg ._bd ;_bg ._gcf =_bg ._fda ;_bg ._ecf =_bg ._gbc ;_bg ._eg =_bg ._gbg ;};func (_aa *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _aa .writeBit (uint8 (bit ));
};return _dd .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_gd *Reader )ReadBool ()(bool ,error ){return _gd .readBool ()};func (_ee *BufferedWriter )FinishByte (){if _ee ._b ==0{return ;
};_ee ._b =0;_ee ._fa ++;};func (_gab *Writer )UseMSB ()bool {return _gab ._fbga };func (_gaf *Writer )writeBit (_ageb uint8 )error {if len (_gaf ._dac )-1< _gaf ._bag {return _d .EOF ;};_gbgc :=_gaf ._ffb ;if _gaf ._fbga {_gbgc =7-_gaf ._ffb ;};_gaf ._dac [_gaf ._bag ]|=byte (uint16 (_ageb <<_gbgc )&0xff);
_gaf ._ffb ++;if _gaf ._ffb ==8{_gaf ._bag ++;_gaf ._ffb =0;};return nil ;};func (_gg *BufferedWriter )expandIfNeeded (_fc int ){if !_gg .tryGrowByReslice (_fc ){_gg .grow (_fc );};};func (_dfe *Reader )Mark (){_dfe ._bd =_dfe ._fde ;_dfe ._fda =_dfe ._gcf ;
_dfe ._gbc =_dfe ._ecf ;_dfe ._gbg =_dfe ._eg ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_dac :data ,_fbga :true }};func (_dgde *Writer )WriteBits (bits uint64 ,number int )(_gfg int ,_ggag error ){const _ddd ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_dd .Errorf (_ddd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_bce :=number /8;if _bce > 0{_egg :=number -_bce *8;for _bccf :=_bce -1;_bccf >=0;_bccf --{_dcbd :=byte ((bits >>uint (_bccf *8+_egg ))&0xff);if _ggag =_dgde .WriteByte (_dcbd );_ggag !=nil {return _gfg ,_dd .Wrapf (_ggag ,_ddd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bce -_bccf +1);
};};number -=_bce *8;if number ==0{return _bce ,nil ;};};var _bac int ;for _def :=0;_def < number ;_def ++{if _dgde ._fbga {_bac =int ((bits >>uint (number -1-_def ))&0x1);}else {_bac =int (bits &0x1);bits >>=1;};if _ggag =_dgde .WriteBit (_bac );_ggag !=nil {return _gfg ,_dd .Wrapf (_ggag ,_ddd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_def );
};};return _bce ,nil ;};func (_dge *Writer )FinishByte (){if _dge ._ffb ==0{return ;};_dge ._ffb =0;_dge ._bag ++;};var _ BinaryWriter =&BufferedWriter {};func (_beb *BufferedWriter )fullOffset ()int {_gga :=_beb ._fa ;if _beb ._b !=0{_gga ++;};return _gga ;
};type StreamReader interface{_d .Reader ;_d .ByteReader ;_d .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_aee byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();
AbsolutePosition ()int64 ;};func (_bdg *Writer )byteCapacity ()int {_aeb :=len (_bdg ._dac )-_bdg ._bag ;if _bdg ._ffb !=0{_aeb --;};return _aeb ;};func (_ea *BufferedWriter )writeByte (_cba byte ){switch {case _ea ._b ==0:_ea ._a [_ea ._fa ]=_cba ;_ea ._fa ++;
case _ea ._ag :_ea ._a [_ea ._fa ]|=_cba >>_ea ._b ;_ea ._fa ++;_ea ._a [_ea ._fa ]=byte (uint16 (_cba )<<(8-_ea ._b )&0xff);default:_ea ._a [_ea ._fa ]|=byte (uint16 (_cba )<<_ea ._b &0xff);_ea ._fa ++;_ea ._a [_ea ._fa ]=_cba >>(8-_ea ._b );};};func (_bc *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _bc ._gcf !=0{return _bc .ReadBits (_bc ._gcf );
};return 0,nil ;};func (_dcb *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_g .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_dcb ._ef ._fb +offset ;};if length > 0{_cad :=len (_dcb ._ef ._edc );if relative {_cad =_dcb ._ef ._efg ;};if offset +length > _cad {return nil ,_ec .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_dcb ._ef ._efg );
};};if length < 0{_fg :=len (_dcb ._ef ._edc );if relative {_fg =_dcb ._ef ._efg ;};length =_fg -offset ;};return &Reader {_ef :readerSource {_edc :_dcb ._ef ._edc ,_efg :length ,_fb :offset }},nil ;};func (_gf *Reader )Length ()uint64 {return uint64 (_gf ._ef ._efg )};
func (_ggf *BufferedWriter )writeShiftedBytes (_bed []byte )int {for _ ,_cce :=range _bed {_ggf .writeByte (_cce );};return len (_bed );};func (_agce *Writer )WriteByte (c byte )error {return _agce .writeByte (c )};func (_fac *Reader )ReadBit ()(_faa int ,_dgd error ){_cge ,_dgd :=_fac .readBool ();
if _dgd !=nil {return 0,_dgd ;};if _cge {_faa =1;};return _faa ,nil ;};func (_feb *Reader )ReadBits (n byte )(_gfa uint64 ,_bb error ){if n < _feb ._gcf {_dcd :=_feb ._gcf -n ;_gfa =uint64 (_feb ._ecf >>_dcd );_feb ._ecf &=1<<_dcd -1;_feb ._gcf =_dcd ;
return _gfa ,nil ;};if n > _feb ._gcf {if _feb ._gcf > 0{_gfa =uint64 (_feb ._ecf );n -=_feb ._gcf ;};for n >=8{_fee ,_dca :=_feb .readBufferByte ();if _dca !=nil {return 0,_dca ;};_gfa =_gfa <<8+uint64 (_fee );n -=8;};if n > 0{if _feb ._ecf ,_bb =_feb .readBufferByte ();
_bb !=nil {return 0,_bb ;};_efd :=8-n ;_gfa =_gfa <<n +uint64 (_feb ._ecf >>_efd );_feb ._ecf &=1<<_efd -1;_feb ._gcf =_efd ;}else {_feb ._gcf =0;};return _gfa ,nil ;};_feb ._gcf =0;return uint64 (_feb ._ecf ),nil ;};func (_bbc *Writer )ResetBit (){_bbc ._ffb =0};
func NewWriter (data []byte )*Writer {return &Writer {_dac :data }};func (_eeg *Reader )AbsolutePosition ()int64 {return _eeg ._fde +int64 (_eeg ._ef ._fb )};func (_ed *BufferedWriter )byteCapacity ()int {_ace :=len (_ed ._a )-_ed ._fa ;if _ed ._b !=0{_ace --;
};return _ace ;};func (_gac *Reader )readBool ()(_gfd bool ,_fbg error ){if _gac ._gcf ==0{_gac ._ecf ,_fbg =_gac .readBufferByte ();if _fbg !=nil {return false ,_fbg ;};_gfd =(_gac ._ecf &0x80)!=0;_gac ._ecf ,_gac ._gcf =_gac ._ecf &0x7f,7;return _gfd ,nil ;
};_gac ._gcf --;_gfd =(_gac ._ecf &(1<<_gac ._gcf ))!=0;_gac ._ecf &=1<<_gac ._gcf -1;return _gfd ,nil ;};func (_ffcf *BufferedWriter )WriteBits (bits uint64 ,number int )(_gb int ,_acb error ){const _gca ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_dd .Errorf (_gca ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_df :=number /8;if _df > 0{_cgb :=number -_df *8;for _fd :=_df -1;_fd >=0;_fd --{_bea :=byte ((bits >>uint (_fd *8+_cgb ))&0xff);if _acb =_ffcf .WriteByte (_bea );_acb !=nil {return _gb ,_dd .Wrapf (_acb ,_gca ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_df -_fd +1);
};};number -=_df *8;if number ==0{return _df ,nil ;};};var _bf int ;for _ece :=0;_ece < number ;_ece ++{if _ffcf ._ag {_bf =int ((bits >>uint (number -1-_ece ))&0x1);}else {_bf =int (bits &0x1);bits >>=1;};if _acb =_ffcf .WriteBit (_bf );_acb !=nil {return _gb ,_dd .Wrapf (_acb ,_gca ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ece );
};};return _df ,nil ;};func NewReader (data []byte )*Reader {return &Reader {_ef :readerSource {_edc :data ,_efg :len (data ),_fb :0}};};func (_ce *Reader )ReadByte ()(byte ,error ){if _ce ._gcf ==0{return _ce .readBufferByte ();};return _ce .readUnalignedByte ();
};func (_be *BufferedWriter )Reset (){_be ._a =_be ._a [:0];_be ._fa =0;_be ._b =0};func (_age *BufferedWriter )Data ()[]byte {return _age ._a };func (_de *BufferedWriter )WriteByte (bt byte )error {if _de ._fa > len (_de ._a )-1||(_de ._fa ==len (_de ._a )-1&&_de ._b !=0){_de .expandIfNeeded (1);
};_de .writeByte (bt );return nil ;};func (_af *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ac :=int (_af ._b )+skip ;if _ac >=0&&_ac < 8{_af ._b =uint8 (_ac );return nil ;};_ac =int (_af ._b )+_af ._fa *8+skip ;if _ac < 0{return _dd .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ab :=_ac /8;_cc :=_ac %8;_af ._b =uint8 (_cc );if _ffc :=_ab -_af ._fa ;_ffc > 0&&len (_af ._a )-1< _ab {if _af ._b !=0{_ffc ++;};_af .expandIfNeeded (_ffc );};_af ._fa =_ab ;return nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ag :true }};
func (_dc *BufferedWriter )Len ()int {return _dc .byteCapacity ()};func (_bdc *Writer )Write (p []byte )(int ,error ){if len (p )> _bdc .byteCapacity (){return 0,_d .EOF ;};for _ ,_gacd :=range p {if _gcaf :=_bdc .writeByte (_gacd );_gcaf !=nil {return 0,_gcaf ;
};};return len (p ),nil ;};type readerSource struct{_edc []byte ;_fb int ;_efg int ;};func (_bfe *Reader )RelativePosition ()int64 {return _bfe ._fde };func (_da *BufferedWriter )tryGrowByReslice (_ccee int )bool {if _ffcb :=len (_da ._a );_ccee <=cap (_da ._a )-_ffcb {_da ._a =_da ._a [:_ffcb +_ccee ];
return true ;};return false ;};func (_fdc *Reader )Align ()(_ffa byte ){_ffa =_fdc ._gcf ;_fdc ._gcf =0;return _ffa };type Writer struct{_dac []byte ;_ffb uint8 ;_bag int ;_fbga bool ;};func (_cbb *Writer )Data ()[]byte {return _cbb ._dac };var _ _d .ByteWriter =&BufferedWriter {};
func (_bbd *Writer )SkipBits (skip int )error {const _cebb ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_fcc :=int (_bbd ._ffb )+skip ;if _fcc >=0&&_fcc < 8{_bbd ._ffb =uint8 (_fcc );return nil ;
};_fcc =int (_bbd ._ffb )+_bbd ._bag *8+skip ;if _fcc < 0{return _dd .Errorf (_cebb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bbcf :=_fcc /8;_cbg :=_fcc %8;_ff .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_ff .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_bbd ._ffb ,_bbd ._bag ,int (_bbd ._ffb )+(_bbd ._bag )*8,len (_bbd ._dac ),cap (_bbd ._dac ));
_ff .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_fcc ,_cbg );_bbd ._ffb =uint8 (_cbg );if _ecge :=_bbcf -_bbd ._bag ;
_ecge > 0&&len (_bbd ._dac )-1< _bbcf {_ff .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ecge );return _dd .Errorf (_cebb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bbd ._bag =_bbcf ;_ff .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_bbd ._ffb ,_bbd ._bag );return nil ;};type Reader struct{_ef readerSource ;
_ecf byte ;_gcf byte ;_fde int64 ;_eg int ;_fcd int ;_bd int64 ;_fda byte ;_gbc byte ;_gbg int ;};type BinaryWriter interface{BitWriter ;_d .Writer ;_d .ByteWriter ;Data ()[]byte ;};func (_ca *BufferedWriter )grow (_fcf int ){if _ca ._a ==nil &&_fcf < _ecc {_ca ._a =make ([]byte ,_fcf ,_ecc );
return ;};_cb :=len (_ca ._a );if _ca ._b !=0{_cb ++;};_ga :=cap (_ca ._a );switch {case _fcf <=_ga /2-_cb :_ff .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ca ._a ),cap (_ca ._a ),_fcf );
_ff .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ga ,_cb );copy (_ca ._a ,_ca ._a [_ca .fullOffset ():]);
case _ga > _c -_ga -_fcf :_ff .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_fab :=make ([]byte ,2*_ga +_fcf );copy (_fab ,_ca ._a );_ca ._a =_fab ;};_ca ._a =_ca ._a [:_cb +_fcf ];
};func (_bec *Reader )BitPosition ()int {return int (_bec ._gcf )};var (_ _d .Reader =&Reader {};_ _d .ByteReader =&Reader {};_ _d .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_bee *Reader )ReadUint32 ()(uint32 ,error ){_ceb :=make ([]byte ,4);
_ ,_cbae :=_bee .Read (_ceb );if _cbae !=nil {return 0,_cbae ;};return _f .BigEndian .Uint32 (_ceb ),nil ;};func (_cdc *Reader )read (_bdb []byte )(int ,error ){if _cdc ._fde >=int64 (_cdc ._ef ._efg ){return 0,_d .EOF ;};_cdc ._fcd =-1;_fabe :=copy (_bdb ,_cdc ._ef ._edc [(int64 (_cdc ._ef ._fb )+_cdc ._fde ):(_cdc ._ef ._fb +_cdc ._ef ._efg )]);
_cdc ._fde +=int64 (_fabe );return _fabe ,nil ;};type BitWriter interface{WriteBit (_dg int )error ;WriteBits (_ad uint64 ,_ae int )(_aga int ,_eced error );FinishByte ();SkipBits (_daa int )error ;};type BufferedWriter struct{_a []byte ;_b uint8 ;_fa int ;
_ag bool ;};func (_ceg *Writer )writeByte (_eee byte )error {if _ceg ._bag > len (_ceg ._dac )-1{return _d .EOF ;};if _ceg ._bag ==len (_ceg ._dac )-1&&_ceg ._ffb !=0{return _d .EOF ;};if _ceg ._ffb ==0{_ceg ._dac [_ceg ._bag ]=_eee ;_ceg ._bag ++;return nil ;
};if _ceg ._fbga {_ceg ._dac [_ceg ._bag ]|=_eee >>_ceg ._ffb ;_ceg ._bag ++;_ceg ._dac [_ceg ._bag ]=byte (uint16 (_eee )<<(8-_ceg ._ffb )&0xff);}else {_ceg ._dac [_ceg ._bag ]|=byte (uint16 (_eee )<<_ceg ._ffb &0xff);_ceg ._bag ++;_ceg ._dac [_ceg ._bag ]=_eee >>(8-_ceg ._ffb );
};return nil ;};func (_fgb *Reader )AbsoluteLength ()uint64 {return uint64 (len (_fgb ._ef ._edc ))};func (_abd *Reader )readUnalignedByte ()(_eff byte ,_ecee error ){_bcc :=_abd ._gcf ;_eff =_abd ._ecf <<(8-_bcc );_abd ._ecf ,_ecee =_abd .readBufferByte ();
if _ecee !=nil {return 0,_ecee ;};_eff |=_abd ._ecf >>_bcc ;_abd ._ecf &=1<<_bcc -1;return _eff ,nil ;};func (_ccc *Reader )readBufferByte ()(byte ,error ){if _ccc ._fde >=int64 (_ccc ._ef ._efg ){return 0,_d .EOF ;};_ccc ._fcd =-1;_ba :=_ccc ._ef ._edc [int64 (_ccc ._ef ._fb )+_ccc ._fde ];
_ccc ._fde ++;_ccc ._eg =int (_ba );return _ba ,nil ;};func (_abc *Reader )Read (p []byte )(_bfa int ,_eb error ){if _abc ._gcf ==0{return _abc .read (p );};for ;_bfa < len (p );_bfa ++{if p [_bfa ],_eb =_abc .readUnalignedByte ();_eb !=nil {return 0,_eb ;
};};return _bfa ,nil ;};func (_ecg *BufferedWriter )writeFullBytes (_fe []byte )int {_ccf :=copy (_ecg ._a [_ecg .fullOffset ():],_fe );_ecg ._fa +=_ccf ;return _ccf ;};func (_ddb *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_ddb ._fcd =-1;
_ddb ._gcf =0;_ddb ._ecf =0;_ddb ._eg =0;var _dde int64 ;switch whence {case _d .SeekStart :_dde =offset ;case _d .SeekCurrent :_dde =_ddb ._fde +offset ;case _d .SeekEnd :_dde =int64 (_ddb ._ef ._efg )+offset ;default:return 0,_g .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _dde < 0{return 0,_g .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_ddb ._fde =_dde ;
_ddb ._gcf =0;return _dde ,nil ;};func (_cg *BufferedWriter )ResetBitIndex (){_cg ._b =0};var _ _d .Writer =&BufferedWriter {};func (_ddg *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _dd .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ddg ._a )-1< _ddg ._fa {_ddg .expandIfNeeded (1);};_afd :=_ddg ._b ;if _ddg ._ag {_afd =7-_ddg ._b ;};_ddg ._a [_ddg ._fa ]|=byte (uint16 (bit <<_afd )&0xff);_ddg ._b ++;if _ddg ._b ==8{_ddg ._fa ++;_ddg ._b =0;};return nil ;};