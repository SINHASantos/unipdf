//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_c "encoding/binary";_b "errors";_e "fmt";_f "github.com/unidoc/unipdf/v3/common";_cb "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_gf "io";);func (_eccc *Reader )ReadUint32 ()(uint32 ,error ){_gfa :=make ([]byte ,4);_ ,_cafc :=_eccc .Read (_gfa );
if _cafc !=nil {return 0,_cafc ;};return _c .BigEndian .Uint32 (_gfa ),nil ;};func (_ecc *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _ecc ._dda !=0{return _ecc .ReadBits (_ecc ._dda );};return 0,nil ;};func (_cg *BufferedWriter )Data ()[]byte {return _cg ._d };
func (_ec *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_gc :=int (_ec ._ag )+skip ;if _gc >=0&&_gc < 8{_ec ._ag =uint8 (_gc );return nil ;};_gc =int (_ec ._ag )+_ec ._ce *8+skip ;if _gc < 0{return _cb .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bc :=_gc /8;_fc :=_gc %8;_ec ._ag =uint8 (_fc );if _ae :=_bc -_ec ._ce ;_ae > 0&&len (_ec ._d )-1< _bc {if _ec ._ag !=0{_ae ++;};_ec .expandIfNeeded (_ae );};_ec ._ce =_bc ;return nil ;};func (_cfb *Reader )RelativePosition ()int64 {return _cfb ._bd };
func (_gfd *BufferedWriter )grow (_ff int ){if _gfd ._d ==nil &&_ff < _a {_gfd ._d =make ([]byte ,_ff ,_a );return ;};_fdf :=len (_gfd ._d );if _gfd ._ag !=0{_fdf ++;};_bf :=cap (_gfd ._d );switch {case _ff <=_bf /2-_fdf :_f .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_gfd ._d ),cap (_gfd ._d ),_ff );
_f .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_bf ,_fdf );copy (_gfd ._d ,_gfd ._d [_gfd .fullOffset ():]);
case _bf > _ef -_bf -_ff :_f .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_fdc :=make ([]byte ,2*_bf +_ff );copy (_fdc ,_gfd ._d );_gfd ._d =_fdc ;};_gfd ._d =_gfd ._d [:_fdf +_ff ];
};func (_dga *Reader )AbsoluteLength ()uint64 {return uint64 (len (_dga ._gd ._aba ))};type BinaryWriter interface{BitWriter ;_gf .Writer ;_gf .ByteWriter ;Data ()[]byte ;};func (_aa *Writer )writeByte (_dgf byte )error {if _aa ._egf > len (_aa ._gee )-1{return _gf .EOF ;
};if _aa ._egf ==len (_aa ._gee )-1&&_aa ._aeee !=0{return _gf .EOF ;};if _aa ._aeee ==0{_aa ._gee [_aa ._egf ]=_dgf ;_aa ._egf ++;return nil ;};if _aa ._cab {_aa ._gee [_aa ._egf ]|=_dgf >>_aa ._aeee ;_aa ._egf ++;_aa ._gee [_aa ._egf ]=byte (uint16 (_dgf )<<(8-_aa ._aeee )&0xff);
}else {_aa ._gee [_aa ._egf ]|=byte (uint16 (_dgf )<<_aa ._aeee &0xff);_aa ._egf ++;_aa ._gee [_aa ._egf ]=_dgf >>(8-_aa ._aeee );};return nil ;};func (_dg *BufferedWriter )expandIfNeeded (_bba int ){if !_dg .tryGrowByReslice (_bba ){_dg .grow (_bba );
};};func (_agd *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _agd .writeBit (uint8 (bit ));};return _cb .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_db :true }};func (_egc *Reader )readUnalignedByte ()(_ddag byte ,_gae error ){_dab :=_egc ._dda ;_ddag =_egc ._ead <<(8-_dab );_egc ._ead ,_gae =_egc .readBufferByte ();if _gae !=nil {return 0,_gae ;
};_ddag |=_egc ._ead >>_dab ;_egc ._ead &=1<<_dab -1;return _ddag ,nil ;};func (_gaf *BufferedWriter )Write (d []byte )(int ,error ){_gaf .expandIfNeeded (len (d ));if _gaf ._ag ==0{return _gaf .writeFullBytes (d ),nil ;};return _gaf .writeShiftedBytes (d ),nil ;
};func (_fb *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_b .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_fb ._gd ._fdb +offset ;};if length > 0{_fbd :=len (_fb ._gd ._aba );if relative {_fbd =_fb ._gd ._gfb ;};if offset +length > _fbd {return nil ,_e .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_fb ._gd ._gfb );
};};if length < 0{_aca :=len (_fb ._gd ._aba );if relative {_aca =_fb ._gd ._gfb ;};length =_aca -offset ;};return &Reader {_gd :readerSource {_aba :_fb ._gd ._aba ,_gfb :length ,_fdb :offset }},nil ;};func (_gb *Reader )BitPosition ()int {return int (_gb ._dda )};
func (_gg *BufferedWriter )FinishByte (){if _gg ._ag ==0{return ;};_gg ._ag =0;_gg ._ce ++;};type StreamReader interface{_gf .Reader ;_gf .ByteReader ;_gf .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_fe byte )(uint64 ,error );
ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_bgg *Writer )Data ()[]byte {return _bgg ._gee };func NewReader (data []byte )*Reader {return &Reader {_gd :readerSource {_aba :data ,_gfb :len (data ),_fdb :0}};
};type Writer struct{_gee []byte ;_aeee uint8 ;_egf int ;_cab bool ;};func (_ede *Reader )ReadBits (n byte )(_bge uint64 ,_gcg error ){if n < _ede ._dda {_cfa :=_ede ._dda -n ;_bge =uint64 (_ede ._ead >>_cfa );_ede ._ead &=1<<_cfa -1;_ede ._dda =_cfa ;
return _bge ,nil ;};if n > _ede ._dda {if _ede ._dda > 0{_bge =uint64 (_ede ._ead );n -=_ede ._dda ;};for n >=8{_ggg ,_cbd :=_ede .readBufferByte ();if _cbd !=nil {return 0,_cbd ;};_bge =_bge <<8+uint64 (_ggg );n -=8;};if n > 0{if _ede ._ead ,_gcg =_ede .readBufferByte ();
_gcg !=nil {return 0,_gcg ;};_ebf :=8-n ;_bge =_bge <<n +uint64 (_ede ._ead >>_ebf );_ede ._ead &=1<<_ebf -1;_ede ._dda =_ebf ;}else {_ede ._dda =0;};return _bge ,nil ;};_ede ._dda =0;return uint64 (_ede ._ead ),nil ;};type Reader struct{_gd readerSource ;
_ead byte ;_dda byte ;_bd int64 ;_df int ;_ee int ;_cee int64 ;_dc byte ;_bbe byte ;_ge int ;};func (_bad *Reader )Length ()uint64 {return uint64 (_bad ._gd ._gfb )};func (_ggf *BufferedWriter )tryGrowByReslice (_eg int )bool {if _deb :=len (_ggf ._d );
_eg <=cap (_ggf ._d )-_deb {_ggf ._d =_ggf ._d [:_deb +_eg ];return true ;};return false ;};func (_fg *BufferedWriter )WriteBits (bits uint64 ,number int )(_fd int ,_bb error ){const _age ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_cb .Errorf (_age ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_caf :=number /8;if _caf > 0{_ed :=number -_caf *8;for _gfc :=_caf -1;_gfc >=0;_gfc --{_dd :=byte ((bits >>uint (_gfc *8+_ed ))&0xff);if _bb =_fg .WriteByte (_dd );_bb !=nil {return _fd ,_cb .Wrapf (_bb ,_age ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_caf -_gfc +1);
};};number -=_caf *8;if number ==0{return _caf ,nil ;};};var _cc int ;for _de :=0;_de < number ;_de ++{if _fg ._db {_cc =int ((bits >>uint (number -1-_de ))&0x1);}else {_cc =int (bits &0x1);bits >>=1;};if _bb =_fg .WriteBit (_cc );_bb !=nil {return _fd ,_cb .Wrapf (_bb ,_age ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_de );
};};return _caf ,nil ;};func (_bfe *Reader )Align ()(_bg byte ){_bg =_bfe ._dda ;_bfe ._dda =0;return _bg };var _ _gf .Writer =&BufferedWriter {};func (_ggc *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _cb .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ggc ._d )-1< _ggc ._ce {_ggc .expandIfNeeded (1);};_fcf :=_ggc ._ag ;if _ggc ._db {_fcf =7-_ggc ._ag ;};_ggc ._d [_ggc ._ce ]|=byte (uint16 (bit <<_fcf )&0xff);_ggc ._ag ++;if _ggc ._ag ==8{_ggc ._ce ++;_ggc ._ag =0;};return nil ;};func (_cef *Reader )readBufferByte ()(byte ,error ){if _cef ._bd >=int64 (_cef ._gd ._gfb ){return 0,_gf .EOF ;
};_cef ._ee =-1;_feeg :=_cef ._gd ._aba [int64 (_cef ._gd ._fdb )+_cef ._bd ];_cef ._bd ++;_cef ._df =int (_feeg );return _feeg ,nil ;};var _ BinaryWriter =&Writer {};func (_ac *BufferedWriter )writeFullBytes (_fge []byte )int {_aed :=copy (_ac ._d [_ac .fullOffset ():],_fge );
_ac ._ce +=_aed ;return _aed ;};func (_abd *Writer )UseMSB ()bool {return _abd ._cab };func (_fab *Reader )Mark (){_fab ._cee =_fab ._bd ;_fab ._dc =_fab ._dda ;_fab ._bbe =_fab ._ead ;_fab ._ge =_fab ._df ;};func (_bbb *Writer )WriteBits (bits uint64 ,number int )(_bbc int ,_gbc error ){const _ad ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_cb .Errorf (_ad ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_gbe :=number /8;if _gbe > 0{_gag :=number -_gbe *8;for _bada :=_gbe -1;_bada >=0;_bada --{_abg :=byte ((bits >>uint (_bada *8+_gag ))&0xff);if _gbc =_bbb .WriteByte (_abg );_gbc !=nil {return _bbc ,_cb .Wrapf (_gbc ,_ad ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gbe -_bada +1);
};};number -=_gbe *8;if number ==0{return _gbe ,nil ;};};var _fac int ;for _fbag :=0;_fbag < number ;_fbag ++{if _bbb ._cab {_fac =int ((bits >>uint (number -1-_fbag ))&0x1);}else {_fac =int (bits &0x1);bits >>=1;};if _gbc =_bbb .WriteBit (_fac );_gbc !=nil {return _bbc ,_cb .Wrapf (_gbc ,_ad ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_fbag );
};};return _gbe ,nil ;};func (_abcc *Reader )ReadBit ()(_agg int ,_aee error ){_acc ,_aee :=_abcc .readBool ();if _aee !=nil {return 0,_aee ;};if _acc {_agg =1;};return _agg ,nil ;};func (_fgc *Reader )read (_bbg []byte )(int ,error ){if _fgc ._bd >=int64 (_fgc ._gd ._gfb ){return 0,_gf .EOF ;
};_fgc ._ee =-1;_gbb :=copy (_bbg ,_fgc ._gd ._aba [(int64 (_fgc ._gd ._fdb )+_fgc ._bd ):(_fgc ._gd ._fdb +_fgc ._gd ._gfb )]);_fgc ._bd +=int64 (_gbb );return _gbb ,nil ;};const (_a =64;_ef =int (^uint (0)>>1););func (_ga *BufferedWriter )Len ()int {return _ga .byteCapacity ()};
func (_eag *Writer )ResetBit (){_eag ._aeee =0};type BufferedWriter struct{_d []byte ;_ag uint8 ;_ce int ;_db bool ;};func (_egcc *Writer )WriteByte (c byte )error {return _egcc .writeByte (c )};func (_cgg *BufferedWriter )Reset (){_cgg ._d =_cgg ._d [:0];
_cgg ._ce =0;_cgg ._ag =0};func (_ecg *Reader )readBool ()(_af bool ,_ceg error ){if _ecg ._dda ==0{_ecg ._ead ,_ceg =_ecg .readBufferByte ();if _ceg !=nil {return false ,_ceg ;};_af =(_ecg ._ead &0x80)!=0;_ecg ._ead ,_ecg ._dda =_ecg ._ead &0x7f,7;return _af ,nil ;
};_ecg ._dda --;_af =(_ecg ._ead &(1<<_ecg ._dda ))!=0;_ecg ._ead &=1<<_ecg ._dda -1;return _af ,nil ;};func (_bde *Writer )byteCapacity ()int {_be :=len (_bde ._gee )-_bde ._egf ;if _bde ._aeee !=0{_be --;};return _be ;};func (_ccc *BufferedWriter )writeByte (_cf byte ){switch {case _ccc ._ag ==0:_ccc ._d [_ccc ._ce ]=_cf ;
_ccc ._ce ++;case _ccc ._db :_ccc ._d [_ccc ._ce ]|=_cf >>_ccc ._ag ;_ccc ._ce ++;_ccc ._d [_ccc ._ce ]=byte (uint16 (_cf )<<(8-_ccc ._ag )&0xff);default:_ccc ._d [_ccc ._ce ]|=byte (uint16 (_cf )<<_ccc ._ag &0xff);_ccc ._ce ++;_ccc ._d [_ccc ._ce ]=_cf >>(8-_ccc ._ag );
};};var _ BinaryWriter =&BufferedWriter {};func (_ebd *Reader )Reset (){_ebd ._bd =_ebd ._cee ;_ebd ._dda =_ebd ._dc ;_ebd ._ead =_ebd ._bbe ;_ebd ._df =_ebd ._ge ;};func (_gac *BufferedWriter )WriteByte (bt byte )error {if _gac ._ce > len (_gac ._d )-1||(_gac ._ce ==len (_gac ._d )-1&&_gac ._ag !=0){_gac .expandIfNeeded (1);
};_gac .writeByte (bt );return nil ;};func NewWriter (data []byte )*Writer {return &Writer {_gee :data }};func (_fda *BufferedWriter )byteCapacity ()int {_aea :=len (_fda ._d )-_fda ._ce ;if _fda ._ag !=0{_aea --;};return _aea ;};func (_da *BufferedWriter )ResetBitIndex (){_da ._ag =0};
func NewWriterMSB (data []byte )*Writer {return &Writer {_gee :data ,_cab :true }};func (_dac *BufferedWriter )writeShiftedBytes (_ab []byte )int {for _ ,_bag :=range _ab {_dac .writeByte (_bag );};return len (_ab );};type readerSource struct{_aba []byte ;
_fdb int ;_gfb int ;};var _ _gf .ByteWriter =&BufferedWriter {};type BitWriter interface{WriteBit (_ffe int )error ;WriteBits (_abc uint64 ,_dbg int )(_cff int ,_bbd error );FinishByte ();SkipBits (_cfc int )error ;};func (_cfe *Reader )ReadByte ()(byte ,error ){if _cfe ._dda ==0{return _cfe .readBufferByte ();
};return _cfe .readUnalignedByte ();};func (_bagc *Reader )ReadBool ()(bool ,error ){return _bagc .readBool ()};func (_daa *BufferedWriter )fullOffset ()int {_ba :=_daa ._ce ;if _daa ._ag !=0{_ba ++;};return _ba ;};func (_gdc *Writer )writeBit (_gbcg uint8 )error {if len (_gdc ._gee )-1< _gdc ._egf {return _gf .EOF ;
};_feb :=_gdc ._aeee ;if _gdc ._cab {_feb =7-_gdc ._aeee ;};_gdc ._gee [_gdc ._egf ]|=byte (uint16 (_gbcg <<_feb )&0xff);_gdc ._aeee ++;if _gdc ._aeee ==8{_gdc ._egf ++;_gdc ._aeee =0;};return nil ;};func (_fgg *Writer )SkipBits (skip int )error {const _cbe ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_afe :=int (_fgg ._aeee )+skip ;if _afe >=0&&_afe < 8{_fgg ._aeee =uint8 (_afe );return nil ;};_afe =int (_fgg ._aeee )+_fgg ._egf *8+skip ;if _afe < 0{return _cb .Errorf (_cbe ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dacg :=_afe /8;_gcd :=_afe %8;_f .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_f .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_fgg ._aeee ,_fgg ._egf ,int (_fgg ._aeee )+(_fgg ._egf )*8,len (_fgg ._gee ),cap (_fgg ._gee ));
_f .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_afe ,_gcd );_fgg ._aeee =uint8 (_gcd );if _fgcg :=_dacg -_fgg ._egf ;
_fgcg > 0&&len (_fgg ._gee )-1< _dacg {_f .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_fgcg );return _cb .Errorf (_cbe ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_fgg ._egf =_dacg ;_f .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_fgg ._aeee ,_fgg ._egf );return nil ;};func (_edg *Writer )FinishByte (){if _edg ._aeee ==0{return ;
};_edg ._aeee =0;_edg ._egf ++;};func (_acd *Reader )Read (p []byte )(_dag int ,_dfa error ){if _acd ._dda ==0{return _acd .read (p );};for ;_dag < len (p );_dag ++{if p [_dag ],_dfa =_acd .readUnalignedByte ();_dfa !=nil {return 0,_dfa ;};};return _dag ,nil ;
};var (_ _gf .Reader =&Reader {};_ _gf .ByteReader =&Reader {};_ _gf .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_bcc *Writer )Write (p []byte )(int ,error ){if len (p )> _bcc .byteCapacity (){return 0,_gf .EOF ;};for _ ,_eae :=range p {if _dcg :=_bcc .writeByte (_eae );
_dcg !=nil {return 0,_dcg ;};};return len (p ),nil ;};func (_fba *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fba ._ee =-1;_fba ._dda =0;_fba ._ead =0;_fba ._df =0;var _fee int64 ;switch whence {case _gf .SeekStart :_fee =offset ;case _gf .SeekCurrent :_fee =_fba ._bd +offset ;
case _gf .SeekEnd :_fee =int64 (_fba ._gd ._gfb )+offset ;default:return 0,_b .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _fee < 0{return 0,_b .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_fba ._bd =_fee ;
_fba ._dda =0;return _fee ,nil ;};func (_bcd *Reader )AbsolutePosition ()int64 {return _bcd ._bd +int64 (_bcd ._gd ._fdb )};