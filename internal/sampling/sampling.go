//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_c "github.com/unidoc/unipdf/v3/internal/bitwise";_d "github.com/unidoc/unipdf/v3/internal/imageutil";_e "io";);func (_dd *Writer )WriteSample (sample uint32 )error {if _ ,_fef :=_dd ._fg .WriteBits (uint64 (sample ),_dd ._egd .BitsPerComponent );
_fef !=nil {return _fef ;};_dd ._gfa --;if _dd ._gfa ==0{_dd ._gfa =_dd ._egd .ColorComponents ;_dd ._aa ++;};if _dd ._aa ==_dd ._egd .Width {if _dd ._ad {_dd ._fg .FinishByte ();};_dd ._aa =0;};return nil ;};type Reader struct{_ec _d .ImageBase ;_gg *_c .Reader ;
_bc ,_bf ,_bg int ;_ca bool ;};type SampleWriter interface{WriteSample (_bcb uint32 )error ;WriteSamples (_fd []uint32 )error ;};func (_ge *Reader )ReadSamples (samples []uint32 )(_gf error ){for _f :=0;_f < len (samples );_f ++{samples [_f ],_gf =_ge .ReadSample ();
if _gf !=nil {return _gf ;};};return nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_g []uint32 )error ;};type Writer struct{_egd _d .ImageBase ;_fg *_c .Writer ;_aa ,_gfa int ;_ad bool ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _a []uint32 ;
_af :=bitsPerSample ;var _fe uint32 ;var _ce byte ;_ac :=0;_bd :=0;_gb :=0;for _gb < len (data ){if _ac > 0{_gbc :=_ac ;if _af < _gbc {_gbc =_af ;};_fe =(_fe <<uint (_gbc ))|uint32 (_ce >>uint (8-_gbc ));_ac -=_gbc ;if _ac > 0{_ce =_ce <<uint (_gbc );}else {_ce =0;
};_af -=_gbc ;if _af ==0{_a =append (_a ,_fe );_af =bitsPerSample ;_fe =0;_bd ++;};}else {_eca :=data [_gb ];_gb ++;_ee :=8;if _af < _ee {_ee =_af ;};_ac =8-_ee ;_fe =(_fe <<uint (_ee ))|uint32 (_eca >>uint (_ac ));if _ee < 8{_ce =_eca <<uint (_ee );};
_af -=_ee ;if _af ==0{_a =append (_a ,_fe );_af =bitsPerSample ;_fe =0;_bd ++;};};};for _ac >=bitsPerSample {_afd :=_ac ;if _af < _afd {_afd =_af ;};_fe =(_fe <<uint (_afd ))|uint32 (_ce >>uint (8-_afd ));_ac -=_afd ;if _ac > 0{_ce =_ce <<uint (_afd );
}else {_ce =0;};_af -=_afd ;if _af ==0{_a =append (_a ,_fe );_af =bitsPerSample ;_fe =0;_bd ++;};};return _a ;};func NewReader (img _d .ImageBase )*Reader {return &Reader {_gg :_c .NewReader (img .Data ),_ec :img ,_bg :img .ColorComponents ,_ca :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_cd *Writer )WriteSamples (samples []uint32 )error {for _dcf :=0;_dcf < len (samples );_dcf ++{if _gfd :=_cd .WriteSample (samples [_dcf ]);_gfd !=nil {return _gfd ;};};return nil ;};func NewWriter (img _d .ImageBase )*Writer {return &Writer {_fg :_c .NewWriterMSB (img .Data ),_egd :img ,_gfa :img .ColorComponents ,_ad :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_caf *Reader )ReadSample ()(uint32 ,error ){if _caf ._bf ==_caf ._ec .Height {return 0,_e .EOF ;};_ea ,_de :=_caf ._gg .ReadBits (byte (_caf ._ec .BitsPerComponent ));if _de !=nil {return 0,_de ;};_caf ._bg --;if _caf ._bg ==0{_caf ._bg =_caf ._ec .ColorComponents ;
_caf ._bc ++;};if _caf ._bc ==_caf ._ec .Width {if _caf ._ca {_caf ._gg .ConsumeRemainingBits ();};_caf ._bc =0;_caf ._bf ++;};return uint32 (_ea ),nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _acd []uint32 ;
_eg :=bitsPerOutputSample ;var _ceb uint32 ;var _ed uint32 ;_bff :=0;_gc :=0;_bfa :=0;for _bfa < len (data ){if _bff > 0{_eb :=_bff ;if _eg < _eb {_eb =_eg ;};_ceb =(_ceb <<uint (_eb ))|(_ed >>uint (bitsPerInputSample -_eb ));_bff -=_eb ;if _bff > 0{_ed =_ed <<uint (_eb );
}else {_ed =0;};_eg -=_eb ;if _eg ==0{_acd =append (_acd ,_ceb );_eg =bitsPerOutputSample ;_ceb =0;_gc ++;};}else {_bge :=data [_bfa ];_bfa ++;_ege :=bitsPerInputSample ;if _eg < _ege {_ege =_eg ;};_bff =bitsPerInputSample -_ege ;_ceb =(_ceb <<uint (_ege ))|(_bge >>uint (_bff ));
if _ege < bitsPerInputSample {_ed =_bge <<uint (_ege );};_eg -=_ege ;if _eg ==0{_acd =append (_acd ,_ceb );_eg =bitsPerOutputSample ;_ceb =0;_gc ++;};};};for _bff >=bitsPerOutputSample {_ebb :=_bff ;if _eg < _ebb {_ebb =_eg ;};_ceb =(_ceb <<uint (_ebb ))|(_ed >>uint (bitsPerInputSample -_ebb ));
_bff -=_ebb ;if _bff > 0{_ed =_ed <<uint (_ebb );}else {_ed =0;};_eg -=_ebb ;if _eg ==0{_acd =append (_acd ,_ceb );_eg =bitsPerOutputSample ;_ceb =0;_gc ++;};};if _eg > 0&&_eg < bitsPerOutputSample {_ceb <<=uint (_eg );_acd =append (_acd ,_ceb );};return _acd ;
};