//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_f "github.com/unidoc/unipdf/v3/internal/bitwise";_b "github.com/unidoc/unipdf/v3/internal/imageutil";_c "io";);type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_a []uint32 )error ;};func (_cg *Reader )ReadSamples (samples []uint32 )(_ge error ){for _da :=0;
_da < len (samples );_da ++{samples [_da ],_ge =_cg .ReadSample ();if _ge !=nil {return _ge ;};};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _bf []uint32 ;_bd :=bitsPerOutputSample ;var _bcb uint32 ;
var _ca uint32 ;_ad :=0;_dbe :=0;_ac :=0;for _ac < len (data ){if _ad > 0{_adg :=_ad ;if _bd < _adg {_adg =_bd ;};_bcb =(_bcb <<uint (_adg ))|(_ca >>uint (bitsPerInputSample -_adg ));_ad -=_adg ;if _ad > 0{_ca =_ca <<uint (_adg );}else {_ca =0;};_bd -=_adg ;
if _bd ==0{_bf =append (_bf ,_bcb );_bd =bitsPerOutputSample ;_bcb =0;_dbe ++;};}else {_dd :=data [_ac ];_ac ++;_ecf :=bitsPerInputSample ;if _bd < _ecf {_ecf =_bd ;};_ad =bitsPerInputSample -_ecf ;_bcb =(_bcb <<uint (_ecf ))|(_dd >>uint (_ad ));if _ecf < bitsPerInputSample {_ca =_dd <<uint (_ecf );
};_bd -=_ecf ;if _bd ==0{_bf =append (_bf ,_bcb );_bd =bitsPerOutputSample ;_bcb =0;_dbe ++;};};};for _ad >=bitsPerOutputSample {_bdc :=_ad ;if _bd < _bdc {_bdc =_bd ;};_bcb =(_bcb <<uint (_bdc ))|(_ca >>uint (bitsPerInputSample -_bdc ));_ad -=_bdc ;if _ad > 0{_ca =_ca <<uint (_bdc );
}else {_ca =0;};_bd -=_bdc ;if _bd ==0{_bf =append (_bf ,_bcb );_bd =bitsPerOutputSample ;_bcb =0;_dbe ++;};};if _bd > 0&&_bd < bitsPerOutputSample {_bcb <<=uint (_bd );_bf =append (_bf ,_bcb );};return _bf ;};type SampleWriter interface{WriteSample (_fg uint32 )error ;
WriteSamples (_beg []uint32 )error ;};func (_g *Reader )ReadSample ()(uint32 ,error ){if _g ._ae ==_g ._cf .Height {return 0,_c .EOF ;};_be ,_d :=_g ._fa .ReadBits (byte (_g ._cf .BitsPerComponent ));if _d !=nil {return 0,_d ;};_g ._bc --;if _g ._bc ==0{_g ._bc =_g ._cf .ColorComponents ;
_g ._cd ++;};if _g ._cd ==_g ._cf .Width {if _g ._eb {_g ._fa .ConsumeRemainingBits ();};_g ._cd =0;_g ._ae ++;};return uint32 (_be ),nil ;};func NewWriter (img _b .ImageBase )*Writer {return &Writer {_bdf :_f .NewWriterMSB (img .Data ),_bce :img ,_gc :img .ColorComponents ,_gf :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Writer struct{_bce _b .ImageBase ;_bdf *_f .Writer ;_cge ,_gc int ;_gf bool ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _aeg []uint32 ;_cff :=bitsPerSample ;var _ab uint32 ;var _bcg byte ;_gb :=0;_ec :=0;_ea :=0;for _ea < len (data ){if _gb > 0{_db :=_gb ;
if _cff < _db {_db =_cff ;};_ab =(_ab <<uint (_db ))|uint32 (_bcg >>uint (8-_db ));_gb -=_db ;if _gb > 0{_bcg =_bcg <<uint (_db );}else {_bcg =0;};_cff -=_db ;if _cff ==0{_aeg =append (_aeg ,_ab );_cff =bitsPerSample ;_ab =0;_ec ++;};}else {_ecc :=data [_ea ];
_ea ++;_aba :=8;if _cff < _aba {_aba =_cff ;};_gb =8-_aba ;_ab =(_ab <<uint (_aba ))|uint32 (_ecc >>uint (_gb ));if _aba < 8{_bcg =_ecc <<uint (_aba );};_cff -=_aba ;if _cff ==0{_aeg =append (_aeg ,_ab );_cff =bitsPerSample ;_ab =0;_ec ++;};};};for _gb >=bitsPerSample {_ee :=_gb ;
if _cff < _ee {_ee =_cff ;};_ab =(_ab <<uint (_ee ))|uint32 (_bcg >>uint (8-_ee ));_gb -=_ee ;if _gb > 0{_bcg =_bcg <<uint (_ee );}else {_bcg =0;};_cff -=_ee ;if _cff ==0{_aeg =append (_aeg ,_ab );_cff =bitsPerSample ;_ab =0;_ec ++;};};return _aeg ;};func (_eg *Writer )WriteSamples (samples []uint32 )error {for _fb :=0;
_fb < len (samples );_fb ++{if _bee :=_eg .WriteSample (samples [_fb ]);_bee !=nil {return _bee ;};};return nil ;};func NewReader (img _b .ImageBase )*Reader {return &Reader {_fa :_f .NewReader (img .Data ),_cf :img ,_bc :img .ColorComponents ,_eb :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Reader struct{_cf _b .ImageBase ;_fa *_f .Reader ;_cd ,_ae ,_bc int ;_eb bool ;};func (_df *Writer )WriteSample (sample uint32 )error {if _ ,_cfb :=_df ._bdf .WriteBits (uint64 (sample ),_df ._bce .BitsPerComponent );_cfb !=nil {return _cfb ;};_df ._gc --;
if _df ._gc ==0{_df ._gc =_df ._bce .ColorComponents ;_df ._cge ++;};if _df ._cge ==_df ._bce .Width {if _df ._gf {_df ._bdf .FinishByte ();};_df ._cge =0;};return nil ;};