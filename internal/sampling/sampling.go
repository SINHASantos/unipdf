//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_d "github.com/unidoc/unipdf/v3/internal/bitwise";_de "github.com/unidoc/unipdf/v3/internal/imageutil";_f "io";);type SampleWriter interface{WriteSample (_af uint32 )error ;WriteSamples (_dc []uint32 )error ;};type SampleReader interface{ReadSample ()(uint32 ,error );
ReadSamples (_a []uint32 )error ;};func (_da *Reader )ReadSamples (samples []uint32 )(_gb error ){for _aa :=0;_aa < len (samples );_aa ++{samples [_aa ],_gb =_da .ReadSample ();if _gb !=nil {return _gb ;};};return nil ;};func (_ffb *Writer )WriteSamples (samples []uint32 )error {for _fed :=0;
_fed < len (samples );_fed ++{if _cf :=_ffb .WriteSample (samples [_fed ]);_cf !=nil {return _cf ;};};return nil ;};type Reader struct{_dd _de .ImageBase ;_dg *_d .Reader ;_fc ,_g ,_ff int ;_ge bool ;};func NewWriter (img _de .ImageBase )*Writer {return &Writer {_ee :_d .NewWriterMSB (img .Data ),_fa :img ,_ce :img .ColorComponents ,_cef :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func NewReader (img _de .ImageBase )*Reader {return &Reader {_dg :_d .NewReader (img .Data ),_dd :img ,_ff :img .ColorComponents ,_ge :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _c []uint32 ;
_e :=bitsPerSample ;var _gee uint32 ;var _gf byte ;_fcd :=0;_acc :=0;_bc :=0;for _bc < len (data ){if _fcd > 0{_ae :=_fcd ;if _e < _ae {_ae =_e ;};_gee =(_gee <<uint (_ae ))|uint32 (_gf >>uint (8-_ae ));_fcd -=_ae ;if _fcd > 0{_gf =_gf <<uint (_ae );}else {_gf =0;
};_e -=_ae ;if _e ==0{_c =append (_c ,_gee );_e =bitsPerSample ;_gee =0;_acc ++;};}else {_ab :=data [_bc ];_bc ++;_ec :=8;if _e < _ec {_ec =_e ;};_fcd =8-_ec ;_gee =(_gee <<uint (_ec ))|uint32 (_ab >>uint (_fcd ));if _ec < 8{_gf =_ab <<uint (_ec );};_e -=_ec ;
if _e ==0{_c =append (_c ,_gee );_e =bitsPerSample ;_gee =0;_acc ++;};};};for _fcd >=bitsPerSample {_ecf :=_fcd ;if _e < _ecf {_ecf =_e ;};_gee =(_gee <<uint (_ecf ))|uint32 (_gf >>uint (8-_ecf ));_fcd -=_ecf ;if _fcd > 0{_gf =_gf <<uint (_ecf );}else {_gf =0;
};_e -=_ecf ;if _e ==0{_c =append (_c ,_gee );_e =bitsPerSample ;_gee =0;_acc ++;};};return _c ;};type Writer struct{_fa _de .ImageBase ;_ee *_d .Writer ;_ffd ,_ce int ;_cef bool ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ecd []uint32 ;
_ea :=bitsPerOutputSample ;var _cc uint32 ;var _ca uint32 ;_fe :=0;_gd :=0;_eb :=0;for _eb < len (data ){if _fe > 0{_aee :=_fe ;if _ea < _aee {_aee =_ea ;};_cc =(_cc <<uint (_aee ))|(_ca >>uint (bitsPerInputSample -_aee ));_fe -=_aee ;if _fe > 0{_ca =_ca <<uint (_aee );
}else {_ca =0;};_ea -=_aee ;if _ea ==0{_ecd =append (_ecd ,_cc );_ea =bitsPerOutputSample ;_cc =0;_gd ++;};}else {_cg :=data [_eb ];_eb ++;_ed :=bitsPerInputSample ;if _ea < _ed {_ed =_ea ;};_fe =bitsPerInputSample -_ed ;_cc =(_cc <<uint (_ed ))|(_cg >>uint (_fe ));
if _ed < bitsPerInputSample {_ca =_cg <<uint (_ed );};_ea -=_ed ;if _ea ==0{_ecd =append (_ecd ,_cc );_ea =bitsPerOutputSample ;_cc =0;_gd ++;};};};for _fe >=bitsPerOutputSample {_fd :=_fe ;if _ea < _fd {_fd =_ea ;};_cc =(_cc <<uint (_fd ))|(_ca >>uint (bitsPerInputSample -_fd ));
_fe -=_fd ;if _fe > 0{_ca =_ca <<uint (_fd );}else {_ca =0;};_ea -=_fd ;if _ea ==0{_ecd =append (_ecd ,_cc );_ea =bitsPerOutputSample ;_cc =0;_gd ++;};};if _ea > 0&&_ea < bitsPerOutputSample {_cc <<=uint (_ea );_ecd =append (_ecd ,_cc );};return _ecd ;
};func (_ba *Writer )WriteSample (sample uint32 )error {if _ ,_db :=_ba ._ee .WriteBits (uint64 (sample ),_ba ._fa .BitsPerComponent );_db !=nil {return _db ;};_ba ._ce --;if _ba ._ce ==0{_ba ._ce =_ba ._fa .ColorComponents ;_ba ._ffd ++;};if _ba ._ffd ==_ba ._fa .Width {if _ba ._cef {_ba ._ee .FinishByte ();
};_ba ._ffd =0;};return nil ;};func (_gg *Reader )ReadSample ()(uint32 ,error ){if _gg ._g ==_gg ._dd .Height {return 0,_f .EOF ;};_ad ,_ac :=_gg ._dg .ReadBits (byte (_gg ._dd .BitsPerComponent ));if _ac !=nil {return 0,_ac ;};_gg ._ff --;if _gg ._ff ==0{_gg ._ff =_gg ._dd .ColorComponents ;
_gg ._fc ++;};if _gg ._fc ==_gg ._dd .Width {if _gg ._ge {_gg ._dg .ConsumeRemainingBits ();};_gg ._fc =0;_gg ._g ++;};return uint32 (_ad ),nil ;};