//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_fb "github.com/unidoc/unipdf/v4/internal/bitwise";_e "github.com/unidoc/unipdf/v4/internal/imageutil";_d "io";);func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _cg []uint32 ;_aa :=bitsPerSample ;var _b uint32 ;
var _ca byte ;_ee :=0;_bc :=0;_fg :=0;for _fg < len (data ){if _ee > 0{_agd :=_ee ;if _aa < _agd {_agd =_aa ;};_b =(_b <<uint (_agd ))|uint32 (_ca >>uint (8-_agd ));_ee -=_agd ;if _ee > 0{_ca =_ca <<uint (_agd );}else {_ca =0;};_aa -=_agd ;if _aa ==0{_cg =append (_cg ,_b );
_aa =bitsPerSample ;_b =0;_bc ++;};}else {_aef :=data [_fg ];_fg ++;_cbb :=8;if _aa < _cbb {_cbb =_aa ;};_ee =8-_cbb ;_b =(_b <<uint (_cbb ))|uint32 (_aef >>uint (_ee ));if _cbb < 8{_ca =_aef <<uint (_cbb );};_aa -=_cbb ;if _aa ==0{_cg =append (_cg ,_b );
_aa =bitsPerSample ;_b =0;_bc ++;};};};for _ee >=bitsPerSample {_bb :=_ee ;if _aa < _bb {_bb =_aa ;};_b =(_b <<uint (_bb ))|uint32 (_ca >>uint (8-_bb ));_ee -=_bb ;if _ee > 0{_ca =_ca <<uint (_bb );}else {_ca =0;};_aa -=_bb ;if _aa ==0{_cg =append (_cg ,_b );
_aa =bitsPerSample ;_b =0;_bc ++;};};return _cg ;};type Reader struct{_de _e .ImageBase ;_fa *_fb .Reader ;_fe ,_a ,_ag int ;_af bool ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_c []uint32 )error ;};func (_fec *Writer )WriteSample (sample uint32 )error {if _ ,_dg :=_fec ._aea .WriteBits (uint64 (sample ),_fec ._bcg .BitsPerComponent );
_dg !=nil {return _dg ;};_fec ._ba --;if _fec ._ba ==0{_fec ._ba =_fec ._bcg .ColorComponents ;_fec ._cga ++;};if _fec ._cga ==_fec ._bcg .Width {if _fec ._gg {_fec ._aea .FinishByte ();};_fec ._cga =0;};return nil ;};func (_eee *Writer )WriteSamples (samples []uint32 )error {for _aga :=0;
_aga < len (samples );_aga ++{if _ce :=_eee .WriteSample (samples [_aga ]);_ce !=nil {return _ce ;};};return nil ;};type Writer struct{_bcg _e .ImageBase ;_aea *_fb .Writer ;_cga ,_ba int ;_gg bool ;};func (_ae *Reader )ReadSamples (samples []uint32 )(_gc error ){for _cb :=0;
_cb < len (samples );_cb ++{samples [_cb ],_gc =_ae .ReadSample ();if _gc !=nil {return _gc ;};};return nil ;};func NewReader (img _e .ImageBase )*Reader {return &Reader {_fa :_fb .NewReader (img .Data ),_de :img ,_ag :img .ColorComponents ,_af :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func NewWriter (img _e .ImageBase )*Writer {return &Writer {_aea :_fb .NewWriterMSB (img .Data ),_bcg :img ,_ba :img .ColorComponents ,_gg :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func (_g *Reader )ReadSample ()(uint32 ,error ){if _g ._a ==_g ._de .Height {return 0,_d .EOF ;
};_ef ,_df :=_g ._fa .ReadBits (byte (_g ._de .BitsPerComponent ));if _df !=nil {return 0,_df ;};_g ._ag --;if _g ._ag ==0{_g ._ag =_g ._de .ColorComponents ;_g ._fe ++;};if _g ._fe ==_g ._de .Width {if _g ._af {_g ._fa .ConsumeRemainingBits ();};_g ._fe =0;
_g ._a ++;};return uint32 (_ef ),nil ;};type SampleWriter interface{WriteSample (_cd uint32 )error ;WriteSamples (_ea []uint32 )error ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _deb []uint32 ;_bg :=bitsPerOutputSample ;
var _ed uint32 ;var _eb uint32 ;_ff :=0;_cc :=0;_fac :=0;for _fac < len (data ){if _ff > 0{_bd :=_ff ;if _bg < _bd {_bd =_bg ;};_ed =(_ed <<uint (_bd ))|(_eb >>uint (bitsPerInputSample -_bd ));_ff -=_bd ;if _ff > 0{_eb =_eb <<uint (_bd );}else {_eb =0;
};_bg -=_bd ;if _bg ==0{_deb =append (_deb ,_ed );_bg =bitsPerOutputSample ;_ed =0;_cc ++;};}else {_ffe :=data [_fac ];_fac ++;_age :=bitsPerInputSample ;if _bg < _age {_age =_bg ;};_ff =bitsPerInputSample -_age ;_ed =(_ed <<uint (_age ))|(_ffe >>uint (_ff ));
if _age < bitsPerInputSample {_eb =_ffe <<uint (_age );};_bg -=_age ;if _bg ==0{_deb =append (_deb ,_ed );_bg =bitsPerOutputSample ;_ed =0;_cc ++;};};};for _ff >=bitsPerOutputSample {_bbf :=_ff ;if _bg < _bbf {_bbf =_bg ;};_ed =(_ed <<uint (_bbf ))|(_eb >>uint (bitsPerInputSample -_bbf ));
_ff -=_bbf ;if _ff > 0{_eb =_eb <<uint (_bbf );}else {_eb =0;};_bg -=_bbf ;if _bg ==0{_deb =append (_deb ,_ed );_bg =bitsPerOutputSample ;_ed =0;_cc ++;};};if _bg > 0&&_bg < bitsPerOutputSample {_ed <<=uint (_bg );_deb =append (_deb ,_ed );};return _deb ;
};