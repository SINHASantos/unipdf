//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_g "github.com/unidoc/unipdf/v4/internal/bitwise";_ee "github.com/unidoc/unipdf/v4/internal/imageutil";_a "io";);func (_bdb *Writer )WriteSample (sample uint32 )error {if _ ,_fgf :=_bdb ._ebb .WriteBits (uint64 (sample ),_bdb ._ebd .BitsPerComponent );
_fgf !=nil {return _fgf ;};_bdb ._fge --;if _bdb ._fge ==0{_bdb ._fge =_bdb ._ebd .ColorComponents ;_bdb ._fc ++;};if _bdb ._fc ==_bdb ._ebd .Width {if _bdb ._fac {_bdb ._ebb .FinishByte ();};_bdb ._fc =0;};return nil ;};type Writer struct{_ebd _ee .ImageBase ;
_ebb *_g .Writer ;_fc ,_fge int ;_fac bool ;};func (_cdd *Writer )WriteSamples (samples []uint32 )error {for _add :=0;_add < len (samples );_add ++{if _fde :=_cdd .WriteSample (samples [_add ]);_fde !=nil {return _fde ;};};return nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _gf []uint32 ;
_bg :=bitsPerSample ;var _bf uint32 ;var _gd byte ;_adb :=0;_ce :=0;_f :=0;for _f < len (data ){if _adb > 0{_bbe :=_adb ;if _bg < _bbe {_bbe =_bg ;};_bf =(_bf <<uint (_bbe ))|uint32 (_gd >>uint (8-_bbe ));_adb -=_bbe ;if _adb > 0{_gd =_gd <<uint (_bbe );
}else {_gd =0;};_bg -=_bbe ;if _bg ==0{_gf =append (_gf ,_bf );_bg =bitsPerSample ;_bf =0;_ce ++;};}else {_fe :=data [_f ];_f ++;_bd :=8;if _bg < _bd {_bd =_bg ;};_adb =8-_bd ;_bf =(_bf <<uint (_bd ))|uint32 (_fe >>uint (_adb ));if _bd < 8{_gd =_fe <<uint (_bd );
};_bg -=_bd ;if _bg ==0{_gf =append (_gf ,_bf );_bg =bitsPerSample ;_bf =0;_ce ++;};};};for _adb >=bitsPerSample {_eaf :=_adb ;if _bg < _eaf {_eaf =_bg ;};_bf =(_bf <<uint (_eaf ))|uint32 (_gd >>uint (8-_eaf ));_adb -=_eaf ;if _adb > 0{_gd =_gd <<uint (_eaf );
}else {_gd =0;};_bg -=_eaf ;if _bg ==0{_gf =append (_gf ,_bf );_bg =bitsPerSample ;_bf =0;_ce ++;};};return _gf ;};func (_bb *Reader )ReadSample ()(uint32 ,error ){if _bb ._eb ==_bb ._ea .Height {return 0,_a .EOF ;};_c ,_ag :=_bb ._gg .ReadBits (byte (_bb ._ea .BitsPerComponent ));
if _ag !=nil {return 0,_ag ;};_bb ._af --;if _bb ._af ==0{_bb ._af =_bb ._ea .ColorComponents ;_bb ._ad ++;};if _bb ._ad ==_bb ._ea .Width {if _bb ._b {_bb ._gg .ConsumeRemainingBits ();};_bb ._ad =0;_bb ._eb ++;};return uint32 (_c ),nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ge []uint32 ;
_bfe :=bitsPerOutputSample ;var _ca uint32 ;var _fd uint32 ;_d :=0;_cd :=0;_ab :=0;for _ab < len (data ){if _d > 0{_fg :=_d ;if _bfe < _fg {_fg =_bfe ;};_ca =(_ca <<uint (_fg ))|(_fd >>uint (bitsPerInputSample -_fg ));_d -=_fg ;if _d > 0{_fd =_fd <<uint (_fg );
}else {_fd =0;};_bfe -=_fg ;if _bfe ==0{_ge =append (_ge ,_ca );_bfe =bitsPerOutputSample ;_ca =0;_cd ++;};}else {_bfc :=data [_ab ];_ab ++;_fa :=bitsPerInputSample ;if _bfe < _fa {_fa =_bfe ;};_d =bitsPerInputSample -_fa ;_ca =(_ca <<uint (_fa ))|(_bfc >>uint (_d ));
if _fa < bitsPerInputSample {_fd =_bfc <<uint (_fa );};_bfe -=_fa ;if _bfe ==0{_ge =append (_ge ,_ca );_bfe =bitsPerOutputSample ;_ca =0;_cd ++;};};};for _d >=bitsPerOutputSample {_dd :=_d ;if _bfe < _dd {_dd =_bfe ;};_ca =(_ca <<uint (_dd ))|(_fd >>uint (bitsPerInputSample -_dd ));
_d -=_dd ;if _d > 0{_fd =_fd <<uint (_dd );}else {_fd =0;};_bfe -=_dd ;if _bfe ==0{_ge =append (_ge ,_ca );_bfe =bitsPerOutputSample ;_ca =0;_cd ++;};};if _bfe > 0&&_bfe < bitsPerOutputSample {_ca <<=uint (_bfe );_ge =append (_ge ,_ca );};return _ge ;};
func NewWriter (img _ee .ImageBase )*Writer {return &Writer {_ebb :_g .NewWriterMSB (img .Data ),_ebd :img ,_fge :img .ColorComponents ,_fac :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};type SampleReader interface{ReadSample ()(uint32 ,error );
ReadSamples (_ef []uint32 )error ;};type SampleWriter interface{WriteSample (_afc uint32 )error ;WriteSamples (_cg []uint32 )error ;};type Reader struct{_ea _ee .ImageBase ;_gg *_g .Reader ;_ad ,_eb ,_af int ;_b bool ;};func NewReader (img _ee .ImageBase )*Reader {return &Reader {_gg :_g .NewReader (img .Data ),_ea :img ,_af :img .ColorComponents ,_b :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_bbb *Reader )ReadSamples (samples []uint32 )(_gc error ){for _ggc :=0;_ggc < len (samples );_ggc ++{samples [_ggc ],_gc =_bbb .ReadSample ();if _gc !=nil {return _gc ;};};return nil ;};