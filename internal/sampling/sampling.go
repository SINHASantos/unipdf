//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_f "github.com/unidoc/unipdf/v3/internal/bitwise";_d "github.com/unidoc/unipdf/v3/internal/imageutil";_g "io";);func NewReader (img _d .ImageBase )*Reader {return &Reader {_dc :_f .NewReader (img .Data ),_c :img ,_e :img .ColorComponents ,_fg :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_gg []uint32 )error ;};type Writer struct{_ed _d .ImageBase ;_cb *_f .Writer ;_fbg ,_edf int ;_gcg bool ;};type Reader struct{_c _d .ImageBase ;_dc *_f .Reader ;_ga ,_dcd ,_e int ;
_fg bool ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _a []uint32 ;_baf :=bitsPerSample ;var _dd uint32 ;var _ag byte ;_gf :=0;_gb :=0;_ee :=0;for _ee < len (data ){if _gf > 0{_fff :=_gf ;if _baf < _fff {_fff =_baf ;};_dd =(_dd <<uint (_fff ))|uint32 (_ag >>uint (8-_fff ));
_gf -=_fff ;if _gf > 0{_ag =_ag <<uint (_fff );}else {_ag =0;};_baf -=_fff ;if _baf ==0{_a =append (_a ,_dd );_baf =bitsPerSample ;_dd =0;_gb ++;};}else {_ac :=data [_ee ];_ee ++;_gfb :=8;if _baf < _gfb {_gfb =_baf ;};_gf =8-_gfb ;_dd =(_dd <<uint (_gfb ))|uint32 (_ac >>uint (_gf ));
if _gfb < 8{_ag =_ac <<uint (_gfb );};_baf -=_gfb ;if _baf ==0{_a =append (_a ,_dd );_baf =bitsPerSample ;_dd =0;_gb ++;};};};for _gf >=bitsPerSample {_ge :=_gf ;if _baf < _ge {_ge =_baf ;};_dd =(_dd <<uint (_ge ))|uint32 (_ag >>uint (8-_ge ));_gf -=_ge ;
if _gf > 0{_ag =_ag <<uint (_ge );}else {_ag =0;};_baf -=_ge ;if _baf ==0{_a =append (_a ,_dd );_baf =bitsPerSample ;_dd =0;_gb ++;};};return _a ;};func NewWriter (img _d .ImageBase )*Writer {return &Writer {_cb :_f .NewWriterMSB (img .Data ),_ed :img ,_edf :img .ColorComponents ,_gcg :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_bb *Writer )WriteSample (sample uint32 )error {if _ ,_cg :=_bb ._cb .WriteBits (uint64 (sample ),_bb ._ed .BitsPerComponent );_cg !=nil {return _cg ;};_bb ._edf --;if _bb ._edf ==0{_bb ._edf =_bb ._ed .ColorComponents ;_bb ._fbg ++;};if _bb ._fbg ==_bb ._ed .Width {if _bb ._gcg {_bb ._cb .FinishByte ();
};_bb ._fbg =0;};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _baa []uint32 ;_fb :=bitsPerOutputSample ;var _ec uint32 ;var _ab uint32 ;_fe :=0;_af :=0;_dcgg :=0;for _dcgg < len (data ){if _fe > 0{_be :=_fe ;
if _fb < _be {_be =_fb ;};_ec =(_ec <<uint (_be ))|(_ab >>uint (bitsPerInputSample -_be ));_fe -=_be ;if _fe > 0{_ab =_ab <<uint (_be );}else {_ab =0;};_fb -=_be ;if _fb ==0{_baa =append (_baa ,_ec );_fb =bitsPerOutputSample ;_ec =0;_af ++;};}else {_ef :=data [_dcgg ];
_dcgg ++;_gc :=bitsPerInputSample ;if _fb < _gc {_gc =_fb ;};_fe =bitsPerInputSample -_gc ;_ec =(_ec <<uint (_gc ))|(_ef >>uint (_fe ));if _gc < bitsPerInputSample {_ab =_ef <<uint (_gc );};_fb -=_gc ;if _fb ==0{_baa =append (_baa ,_ec );_fb =bitsPerOutputSample ;
_ec =0;_af ++;};};};for _fe >=bitsPerOutputSample {_bd :=_fe ;if _fb < _bd {_bd =_fb ;};_ec =(_ec <<uint (_bd ))|(_ab >>uint (bitsPerInputSample -_bd ));_fe -=_bd ;if _fe > 0{_ab =_ab <<uint (_bd );}else {_ab =0;};_fb -=_bd ;if _fb ==0{_baa =append (_baa ,_ec );
_fb =bitsPerOutputSample ;_ec =0;_af ++;};};if _fb > 0&&_fb < bitsPerOutputSample {_ec <<=uint (_fb );_baa =append (_baa ,_ec );};return _baa ;};func (_bafd *Writer )WriteSamples (samples []uint32 )error {for _ae :=0;_ae < len (samples );_ae ++{if _df :=_bafd .WriteSample (samples [_ae ]);
_df !=nil {return _df ;};};return nil ;};type SampleWriter interface{WriteSample (_bad uint32 )error ;WriteSamples (_afc []uint32 )error ;};func (_bg *Reader )ReadSamples (samples []uint32 )(_dcg error ){for _ff :=0;_ff < len (samples );_ff ++{samples [_ff ],_dcg =_bg .ReadSample ();
if _dcg !=nil {return _dcg ;};};return nil ;};func (_cf *Reader )ReadSample ()(uint32 ,error ){if _cf ._dcd ==_cf ._c .Height {return 0,_g .EOF ;};_bc ,_ba :=_cf ._dc .ReadBits (byte (_cf ._c .BitsPerComponent ));if _ba !=nil {return 0,_ba ;};_cf ._e --;
if _cf ._e ==0{_cf ._e =_cf ._c .ColorComponents ;_cf ._ga ++;};if _cf ._ga ==_cf ._c .Width {if _cf ._fg {_cf ._dc .ConsumeRemainingBits ();};_cf ._ga =0;_cf ._dcd ++;};return uint32 (_bc ),nil ;};