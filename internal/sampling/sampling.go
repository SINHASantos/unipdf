//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_ad "github.com/unidoc/unipdf/v3/internal/bitwise";_e "github.com/unidoc/unipdf/v3/internal/imageutil";_c "io";);func NewWriter (img _e .ImageBase )*Writer {return &Writer {_be :_ad .NewWriterMSB (img .Data ),_afb :img ,_agb :img .ColorComponents ,_ebe :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_da *Reader )ReadSamples (samples []uint32 )(_ba error ){for _df :=0;_df < len (samples );_df ++{samples [_df ],_ba =_da .ReadSample ();if _ba !=nil {return _ba ;};};return nil ;};func (_eef *Writer )WriteSample (sample uint32 )error {if _ ,_cfb :=_eef ._be .WriteBits (uint64 (sample ),_eef ._afb .BitsPerComponent );
_cfb !=nil {return _cfb ;};_eef ._agb --;if _eef ._agb ==0{_eef ._agb =_eef ._afb .ColorComponents ;_eef ._dgd ++;};if _eef ._dgd ==_eef ._afb .Width {if _eef ._ebe {_eef ._be .FinishByte ();};_eef ._dgd =0;};return nil ;};func (_fd *Reader )ReadSample ()(uint32 ,error ){if _fd ._f ==_fd ._b .Height {return 0,_c .EOF ;
};_ag ,_ea :=_fd ._cg .ReadBits (byte (_fd ._b .BitsPerComponent ));if _ea !=nil {return 0,_ea ;};_fd ._af --;if _fd ._af ==0{_fd ._af =_fd ._b .ColorComponents ;_fd ._g ++;};if _fd ._g ==_fd ._b .Width {if _fd ._d {_fd ._cg .ConsumeRemainingBits ();};
_fd ._g =0;_fd ._f ++;};return uint32 (_ag ),nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_ed []uint32 )error ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _cgf []uint32 ;
_fg :=bitsPerOutputSample ;var _de uint32 ;var _aa uint32 ;_eb :=0;_gf :=0;_ee :=0;for _ee < len (data ){if _eb > 0{_fdg :=_eb ;if _fg < _fdg {_fdg =_fg ;};_de =(_de <<uint (_fdg ))|(_aa >>uint (bitsPerInputSample -_fdg ));_eb -=_fdg ;if _eb > 0{_aa =_aa <<uint (_fdg );
}else {_aa =0;};_fg -=_fdg ;if _fg ==0{_cgf =append (_cgf ,_de );_fg =bitsPerOutputSample ;_de =0;_gf ++;};}else {_fc :=data [_ee ];_ee ++;_cf :=bitsPerInputSample ;if _fg < _cf {_cf =_fg ;};_eb =bitsPerInputSample -_cf ;_de =(_de <<uint (_cf ))|(_fc >>uint (_eb ));
if _cf < bitsPerInputSample {_aa =_fc <<uint (_cf );};_fg -=_cf ;if _fg ==0{_cgf =append (_cgf ,_de );_fg =bitsPerOutputSample ;_de =0;_gf ++;};};};for _eb >=bitsPerOutputSample {_acc :=_eb ;if _fg < _acc {_acc =_fg ;};_de =(_de <<uint (_acc ))|(_aa >>uint (bitsPerInputSample -_acc ));
_eb -=_acc ;if _eb > 0{_aa =_aa <<uint (_acc );}else {_aa =0;};_fg -=_acc ;if _fg ==0{_cgf =append (_cgf ,_de );_fg =bitsPerOutputSample ;_de =0;_gf ++;};};if _fg > 0&&_fg < bitsPerOutputSample {_de <<=uint (_fg );_cgf =append (_cgf ,_de );};return _cgf ;
};func NewReader (img _e .ImageBase )*Reader {return &Reader {_cg :_ad .NewReader (img .Data ),_b :img ,_af :img .ColorComponents ,_d :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};type SampleWriter interface{WriteSample (_cd uint32 )error ;
WriteSamples (_ab []uint32 )error ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _gb []uint32 ;_db :=bitsPerSample ;var _ac uint32 ;var _afg byte ;_fb :=0;_dc :=0;_bc :=0;for _bc < len (data ){if _fb > 0{_dg :=_fb ;if _db < _dg {_dg =_db ;
};_ac =(_ac <<uint (_dg ))|uint32 (_afg >>uint (8-_dg ));_fb -=_dg ;if _fb > 0{_afg =_afg <<uint (_dg );}else {_afg =0;};_db -=_dg ;if _db ==0{_gb =append (_gb ,_ac );_db =bitsPerSample ;_ac =0;_dc ++;};}else {_eab :=data [_bc ];_bc ++;_ef :=8;if _db < _ef {_ef =_db ;
};_fb =8-_ef ;_ac =(_ac <<uint (_ef ))|uint32 (_eab >>uint (_fb ));if _ef < 8{_afg =_eab <<uint (_ef );};_db -=_ef ;if _db ==0{_gb =append (_gb ,_ac );_db =bitsPerSample ;_ac =0;_dc ++;};};};for _fb >=bitsPerSample {_dfa :=_fb ;if _db < _dfa {_dfa =_db ;
};_ac =(_ac <<uint (_dfa ))|uint32 (_afg >>uint (8-_dfa ));_fb -=_dfa ;if _fb > 0{_afg =_afg <<uint (_dfa );}else {_afg =0;};_db -=_dfa ;if _db ==0{_gb =append (_gb ,_ac );_db =bitsPerSample ;_ac =0;_dc ++;};};return _gb ;};type Reader struct{_b _e .ImageBase ;
_cg *_ad .Reader ;_g ,_f ,_af int ;_d bool ;};func (_gg *Writer )WriteSamples (samples []uint32 )error {for _ec :=0;_ec < len (samples );_ec ++{if _bb :=_gg .WriteSample (samples [_ec ]);_bb !=nil {return _bb ;};};return nil ;};type Writer struct{_afb _e .ImageBase ;
_be *_ad .Writer ;_dgd ,_agb int ;_ebe bool ;};