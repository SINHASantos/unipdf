//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_b "github.com/unidoc/unipdf/v3/internal/bitwise";_d "github.com/unidoc/unipdf/v3/internal/imageutil";_c "io";);func NewReader (img _d .ImageBase )*Reader {return &Reader {_ae :_b .NewReader (img .Data ),_e :img ,_ad :img .ColorComponents ,_fc :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ecf []uint32 ;_ff :=bitsPerOutputSample ;var _fe uint32 ;var _ce uint32 ;_dgc :=0;_gdd :=0;_fac :=0;for _fac < len (data ){if _dgc > 0{_dgcd :=_dgc ;if _ff < _dgcd {_dgcd =_ff ;
};_fe =(_fe <<uint (_dgcd ))|(_ce >>uint (bitsPerInputSample -_dgcd ));_dgc -=_dgcd ;if _dgc > 0{_ce =_ce <<uint (_dgcd );}else {_ce =0;};_ff -=_dgcd ;if _ff ==0{_ecf =append (_ecf ,_fe );_ff =bitsPerOutputSample ;_fe =0;_gdd ++;};}else {_dd :=data [_fac ];
_fac ++;_ea :=bitsPerInputSample ;if _ff < _ea {_ea =_ff ;};_dgc =bitsPerInputSample -_ea ;_fe =(_fe <<uint (_ea ))|(_dd >>uint (_dgc ));if _ea < bitsPerInputSample {_ce =_dd <<uint (_ea );};_ff -=_ea ;if _ff ==0{_ecf =append (_ecf ,_fe );_ff =bitsPerOutputSample ;
_fe =0;_gdd ++;};};};for _dgc >=bitsPerOutputSample {_bf :=_dgc ;if _ff < _bf {_bf =_ff ;};_fe =(_fe <<uint (_bf ))|(_ce >>uint (bitsPerInputSample -_bf ));_dgc -=_bf ;if _dgc > 0{_ce =_ce <<uint (_bf );}else {_ce =0;};_ff -=_bf ;if _ff ==0{_ecf =append (_ecf ,_fe );
_ff =bitsPerOutputSample ;_fe =0;_gdd ++;};};if _ff > 0&&_ff < bitsPerOutputSample {_fe <<=uint (_ff );_ecf =append (_ecf ,_fe );};return _ecf ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _dff []uint32 ;_bc :=bitsPerSample ;var _de uint32 ;
var _ec byte ;_acc :=0;_dc :=0;_fg :=0;for _fg < len (data ){if _acc > 0{_dg :=_acc ;if _bc < _dg {_dg =_bc ;};_de =(_de <<uint (_dg ))|uint32 (_ec >>uint (8-_dg ));_acc -=_dg ;if _acc > 0{_ec =_ec <<uint (_dg );}else {_ec =0;};_bc -=_dg ;if _bc ==0{_dff =append (_dff ,_de );
_bc =bitsPerSample ;_de =0;_dc ++;};}else {_fgf :=data [_fg ];_fg ++;_ace :=8;if _bc < _ace {_ace =_bc ;};_acc =8-_ace ;_de =(_de <<uint (_ace ))|uint32 (_fgf >>uint (_acc ));if _ace < 8{_ec =_fgf <<uint (_ace );};_bc -=_ace ;if _bc ==0{_dff =append (_dff ,_de );
_bc =bitsPerSample ;_de =0;_dc ++;};};};for _acc >=bitsPerSample {_fa :=_acc ;if _bc < _fa {_fa =_bc ;};_de =(_de <<uint (_fa ))|uint32 (_ec >>uint (8-_fa ));_acc -=_fa ;if _acc > 0{_ec =_ec <<uint (_fa );}else {_ec =0;};_bc -=_fa ;if _bc ==0{_dff =append (_dff ,_de );
_bc =bitsPerSample ;_de =0;_dc ++;};};return _dff ;};type Reader struct{_e _d .ImageBase ;_ae *_b .Reader ;_aeg ,_g ,_ad int ;_fc bool ;};type SampleWriter interface{WriteSample (_ddf uint32 )error ;WriteSamples (_ab []uint32 )error ;};type Writer struct{_cf _d .ImageBase ;
_bg *_b .Writer ;_bd ,_cc int ;_dcc bool ;};func (_ee *Reader )ReadSamples (samples []uint32 )(_gd error ){for _df :=0;_df < len (samples );_df ++{samples [_df ],_gd =_ee .ReadSample ();if _gd !=nil {return _gd ;};};return nil ;};func (_eeb *Writer )WriteSamples (samples []uint32 )error {for _bcd :=0;
_bcd < len (samples );_bcd ++{if _ag :=_eeb .WriteSample (samples [_bcd ]);_ag !=nil {return _ag ;};};return nil ;};func (_gf *Reader )ReadSample ()(uint32 ,error ){if _gf ._g ==_gf ._e .Height {return 0,_c .EOF ;};_ac ,_ef :=_gf ._ae .ReadBits (byte (_gf ._e .BitsPerComponent ));
if _ef !=nil {return 0,_ef ;};_gf ._ad --;if _gf ._ad ==0{_gf ._ad =_gf ._e .ColorComponents ;_gf ._aeg ++;};if _gf ._aeg ==_gf ._e .Width {if _gf ._fc {_gf ._ae .ConsumeRemainingBits ();};_gf ._aeg =0;_gf ._g ++;};return uint32 (_ac ),nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );
ReadSamples (_f []uint32 )error ;};func (_fce *Writer )WriteSample (sample uint32 )error {if _ ,_faf :=_fce ._bg .WriteBits (uint64 (sample ),_fce ._cf .BitsPerComponent );_faf !=nil {return _faf ;};_fce ._cc --;if _fce ._cc ==0{_fce ._cc =_fce ._cf .ColorComponents ;
_fce ._bd ++;};if _fce ._bd ==_fce ._cf .Width {if _fce ._dcc {_fce ._bg .FinishByte ();};_fce ._bd =0;};return nil ;};func NewWriter (img _d .ImageBase )*Writer {return &Writer {_bg :_b .NewWriterMSB (img .Data ),_cf :img ,_cc :img .ColorComponents ,_dcc :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};