//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_f "github.com/unidoc/unipdf/v3/internal/bitwise";_a "github.com/unidoc/unipdf/v3/internal/imageutil";_b "io";);func (_afd *Writer )WriteSamples (samples []uint32 )error {for _gbb :=0;_gbb < len (samples );_gbb ++{if _deb :=_afd .WriteSample (samples [_gbb ]);
_deb !=nil {return _deb ;};};return nil ;};func NewReader (img _a .ImageBase )*Reader {return &Reader {_fg :_f .NewReader (img .Data ),_d :img ,_cc :img .ColorComponents ,_g :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Reader struct{_d _a .ImageBase ;_fg *_f .Reader ;_be ,_ce ,_cc int ;_g bool ;};func (_cb *Reader )ReadSample ()(uint32 ,error ){if _cb ._ce ==_cb ._d .Height {return 0,_b .EOF ;};_fe ,_db :=_cb ._fg .ReadBits (byte (_cb ._d .BitsPerComponent ));
if _db !=nil {return 0,_db ;};_cb ._cc --;if _cb ._cc ==0{_cb ._cc =_cb ._d .ColorComponents ;_cb ._be ++;};if _cb ._be ==_cb ._d .Width {if _cb ._g {_cb ._fg .ConsumeRemainingBits ();};_cb ._be =0;_cb ._ce ++;};return uint32 (_fe ),nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _af []uint32 ;
_bc :=bitsPerOutputSample ;var _abf uint32 ;var _gcd uint32 ;_bce :=0;_bfb :=0;_ag :=0;for _ag < len (data ){if _bce > 0{_ee :=_bce ;if _bc < _ee {_ee =_bc ;};_abf =(_abf <<uint (_ee ))|(_gcd >>uint (bitsPerInputSample -_ee ));_bce -=_ee ;if _bce > 0{_gcd =_gcd <<uint (_ee );
}else {_gcd =0;};_bc -=_ee ;if _bc ==0{_af =append (_af ,_abf );_bc =bitsPerOutputSample ;_abf =0;_bfb ++;};}else {_bfd :=data [_ag ];_ag ++;_ec :=bitsPerInputSample ;if _bc < _ec {_ec =_bc ;};_bce =bitsPerInputSample -_ec ;_abf =(_abf <<uint (_ec ))|(_bfd >>uint (_bce ));
if _ec < bitsPerInputSample {_gcd =_bfd <<uint (_ec );};_bc -=_ec ;if _bc ==0{_af =append (_af ,_abf );_bc =bitsPerOutputSample ;_abf =0;_bfb ++;};};};for _bce >=bitsPerOutputSample {_fgg :=_bce ;if _bc < _fgg {_fgg =_bc ;};_abf =(_abf <<uint (_fgg ))|(_gcd >>uint (bitsPerInputSample -_fgg ));
_bce -=_fgg ;if _bce > 0{_gcd =_gcd <<uint (_fgg );}else {_gcd =0;};_bc -=_fgg ;if _bc ==0{_af =append (_af ,_abf );_bc =bitsPerOutputSample ;_abf =0;_bfb ++;};};if _bc > 0&&_bc < bitsPerOutputSample {_abf <<=uint (_bc );_af =append (_af ,_abf );};return _af ;
};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_bf []uint32 )error ;};func (_ca *Reader )ReadSamples (samples []uint32 )(_da error ){for _cd :=0;_cd < len (samples );_cd ++{samples [_cd ],_da =_ca .ReadSample ();if _da !=nil {return _da ;
};};return nil ;};type Writer struct{_cf _a .ImageBase ;_dg *_f .Writer ;_bd ,_gd int ;_bca bool ;};func NewWriter (img _a .ImageBase )*Writer {return &Writer {_dg :_f .NewWriterMSB (img .Data ),_cf :img ,_gd :img .ColorComponents ,_bca :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _ccg []uint32 ;_ba :=bitsPerSample ;var _gb uint32 ;var _e byte ;_bec :=0;_ccf :=0;_ed :=0;for _ed < len (data ){if _bec > 0{_df :=_bec ;if _ba < _df {_df =_ba ;};_gb =(_gb <<uint (_df ))|uint32 (_e >>uint (8-_df ));
_bec -=_df ;if _bec > 0{_e =_e <<uint (_df );}else {_e =0;};_ba -=_df ;if _ba ==0{_ccg =append (_ccg ,_gb );_ba =bitsPerSample ;_gb =0;_ccf ++;};}else {_eb :=data [_ed ];_ed ++;_ab :=8;if _ba < _ab {_ab =_ba ;};_bec =8-_ab ;_gb =(_gb <<uint (_ab ))|uint32 (_eb >>uint (_bec ));
if _ab < 8{_e =_eb <<uint (_ab );};_ba -=_ab ;if _ba ==0{_ccg =append (_ccg ,_gb );_ba =bitsPerSample ;_gb =0;_ccf ++;};};};for _bec >=bitsPerSample {_gc :=_bec ;if _ba < _gc {_gc =_ba ;};_gb =(_gb <<uint (_gc ))|uint32 (_e >>uint (8-_gc ));_bec -=_gc ;
if _bec > 0{_e =_e <<uint (_gc );}else {_e =0;};_ba -=_gc ;if _ba ==0{_ccg =append (_ccg ,_gb );_ba =bitsPerSample ;_gb =0;_ccf ++;};};return _ccg ;};type SampleWriter interface{WriteSample (_gcc uint32 )error ;WriteSamples (_de []uint32 )error ;};func (_cbb *Writer )WriteSample (sample uint32 )error {if _ ,_abd :=_cbb ._dg .WriteBits (uint64 (sample ),_cbb ._cf .BitsPerComponent );
_abd !=nil {return _abd ;};_cbb ._gd --;if _cbb ._gd ==0{_cbb ._gd =_cbb ._cf .ColorComponents ;_cbb ._bd ++;};if _cbb ._bd ==_cbb ._cf .Width {if _cbb ._bca {_cbb ._dg .FinishByte ();};_cbb ._bd =0;};return nil ;};