//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_e "github.com/unidoc/unipdf/v3/internal/bitwise";_c "github.com/unidoc/unipdf/v3/internal/imageutil";_g "io";);func (_ccd *Writer )WriteSamples (samples []uint32 )error {for _cbc :=0;_cbc < len (samples );_cbc ++{if _gb :=_ccd .WriteSample (samples [_cbc ]);
_gb !=nil {return _gb ;};};return nil ;};type SampleWriter interface{WriteSample (_ag uint32 )error ;WriteSamples (_af []uint32 )error ;};func (_dgf *Writer )WriteSample (sample uint32 )error {if _ ,_fe :=_dgf ._cea .WriteBits (uint64 (sample ),_dgf ._ge .BitsPerComponent );
_fe !=nil {return _fe ;};_dgf ._df --;if _dgf ._df ==0{_dgf ._df =_dgf ._ge .ColorComponents ;_dgf ._da ++;};if _dgf ._da ==_dgf ._ge .Width {if _dgf ._bd {_dgf ._cea .FinishByte ();};_dgf ._da =0;};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _gg []uint32 ;
_bg :=bitsPerOutputSample ;var _eff uint32 ;var _dg uint32 ;_cd :=0;_fgd :=0;_cg :=0;for _cg < len (data ){if _cd > 0{_cc :=_cd ;if _bg < _cc {_cc =_bg ;};_eff =(_eff <<uint (_cc ))|(_dg >>uint (bitsPerInputSample -_cc ));_cd -=_cc ;if _cd > 0{_dg =_dg <<uint (_cc );
}else {_dg =0;};_bg -=_cc ;if _bg ==0{_gg =append (_gg ,_eff );_bg =bitsPerOutputSample ;_eff =0;_fgd ++;};}else {_cfd :=data [_cg ];_cg ++;_ca :=bitsPerInputSample ;if _bg < _ca {_ca =_bg ;};_cd =bitsPerInputSample -_ca ;_eff =(_eff <<uint (_ca ))|(_cfd >>uint (_cd ));
if _ca < bitsPerInputSample {_dg =_cfd <<uint (_ca );};_bg -=_ca ;if _bg ==0{_gg =append (_gg ,_eff );_bg =bitsPerOutputSample ;_eff =0;_fgd ++;};};};for _cd >=bitsPerOutputSample {_ce :=_cd ;if _bg < _ce {_ce =_bg ;};_eff =(_eff <<uint (_ce ))|(_dg >>uint (bitsPerInputSample -_ce ));
_cd -=_ce ;if _cd > 0{_dg =_dg <<uint (_ce );}else {_dg =0;};_bg -=_ce ;if _bg ==0{_gg =append (_gg ,_eff );_bg =bitsPerOutputSample ;_eff =0;_fgd ++;};};if _bg > 0&&_bg < bitsPerOutputSample {_eff <<=uint (_bg );_gg =append (_gg ,_eff );};return _gg ;
};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _dc []uint32 ;_ba :=bitsPerSample ;var _cf uint32 ;var _eb byte ;_ec :=0;_cff :=0;_ee :=0;for _ee < len (data ){if _ec > 0{_ae :=_ec ;if _ba < _ae {_ae =_ba ;};_cf =(_cf <<uint (_ae ))|uint32 (_eb >>uint (8-_ae ));
_ec -=_ae ;if _ec > 0{_eb =_eb <<uint (_ae );}else {_eb =0;};_ba -=_ae ;if _ba ==0{_dc =append (_dc ,_cf );_ba =bitsPerSample ;_cf =0;_cff ++;};}else {_fg :=data [_ee ];_ee ++;_cffe :=8;if _ba < _cffe {_cffe =_ba ;};_ec =8-_cffe ;_cf =(_cf <<uint (_cffe ))|uint32 (_fg >>uint (_ec ));
if _cffe < 8{_eb =_fg <<uint (_cffe );};_ba -=_cffe ;if _ba ==0{_dc =append (_dc ,_cf );_ba =bitsPerSample ;_cf =0;_cff ++;};};};for _ec >=bitsPerSample {_abe :=_ec ;if _ba < _abe {_abe =_ba ;};_cf =(_cf <<uint (_abe ))|uint32 (_eb >>uint (8-_abe ));_ec -=_abe ;
if _ec > 0{_eb =_eb <<uint (_abe );}else {_eb =0;};_ba -=_abe ;if _ba ==0{_dc =append (_dc ,_cf );_ba =bitsPerSample ;_cf =0;_cff ++;};};return _dc ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_cb []uint32 )error ;};type Reader struct{_ga _c .ImageBase ;
_ef *_e .Reader ;_ed ,_d ,_a int ;_b bool ;};type Writer struct{_ge _c .ImageBase ;_cea *_e .Writer ;_da ,_df int ;_bd bool ;};func NewReader (img _c .ImageBase )*Reader {return &Reader {_ef :_e .NewReader (img .Data ),_ga :img ,_a :img .ColorComponents ,_b :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_eae *Reader )ReadSamples (samples []uint32 )(_gf error ){for _ab :=0;_ab < len (samples );_ab ++{samples [_ab ],_gf =_eae .ReadSample ();if _gf !=nil {return _gf ;};};return nil ;};func (_ea *Reader )ReadSample ()(uint32 ,error ){if _ea ._d ==_ea ._ga .Height {return 0,_g .EOF ;
};_gd ,_be :=_ea ._ef .ReadBits (byte (_ea ._ga .BitsPerComponent ));if _be !=nil {return 0,_be ;};_ea ._a --;if _ea ._a ==0{_ea ._a =_ea ._ga .ColorComponents ;_ea ._ed ++;};if _ea ._ed ==_ea ._ga .Width {if _ea ._b {_ea ._ef .ConsumeRemainingBits ();
};_ea ._ed =0;_ea ._d ++;};return uint32 (_gd ),nil ;};func NewWriter (img _c .ImageBase )*Writer {return &Writer {_cea :_e .NewWriterMSB (img .Data ),_ge :img ,_df :img .ColorComponents ,_bd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};